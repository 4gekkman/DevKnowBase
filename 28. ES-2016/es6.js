////=================================================////
////                                                 ////
////            Что нового в ECMAScript 6            ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Ресурсы //
  //---------//

    # Современные возможности ES-2015
        https://learn.javascript.ru/es-modern

    # Здесь можно проверить степень реализации фич ES6 в браузерах
        http://kangax.github.io/compat-table/es6/

    # Транспайлер Babel
        https://babeljs.io/repl

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////

  # А.  Современные возможности ES-2015

    А1. ES-2015 сейчас
    А2. Переменные: let и const
    А3. Деструктуризация
    А4. Функции
    А5. Строки
    А6. Объекты и прототипы
    А7. Классы
    А8. Тип данных Symbol
    А9. Итераторы
    А10. Set, Map, WeakSet и WeakMap
    А11. [Обзорно] Промисы
    А12. [Обзорно] Генераторы
    А13. Модули
    А14. Proxy

////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. ES-2015 сейчас

--------------------------------------
Подоглавление:

  # Ссылки
  # Общие сведения о ES-2015
  # Какие в настоящее время есть возможности использовать ES6?

    ▪ Писать код конкретный JS-движок
    ▪ Использовать Babel

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] ES-2015 сейчас
      https://learn.javascript.ru/es-modern-usage

> Общие сведения о ES-2015

  • Был принят в 2015-м году.
  • Ещё не все возможности реализованы во всех браузерах.
  • Во многих браузерах сейчас работает только с 'use strict'.

> Какие в настоящее время есть возможности использовать ES6?

  • Писать код конкретный JS-движок
    - Про конкретные движки изестно, какие фичи ES6 они уже поддерживают.
    - Поэтому, можно просто не использовать не поддерживемы фичи.
    - Но этот вариант не особо годится для продакшн в большинстве случаев.
    - Для node.js сойдёт, но не для кроссбраузерной поддержки.

  • Использовать Babel

    ▪ Что такое Babel?
      - Это транспайлер, переписывающий код из ES-2015 на предыдущий стандарт.
    
    ▪ Состоит из двух частей

      1. Транспайлер.
      2. Полифилл
        - Это библиотека, которая добавляет в старые браузеры 
          поддержку возможностей, которые в современных браузерах являются встроенными.
        - Он добавляет методы Array.from, String.prototype.repeat и другие.

    ▪ Как обычно применяют babel
      - Обычно он работает на сервере.
      - В составе системы сборки, вроде webpack или brunch.
      - И автоматически переписывает весь код в ES5.
      - Настроить всё это легко, у большинства систем сборки есть плагин с Babel.


    - Он состоит из двух частей


А2. Переменные: let и const

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Отличия let от var
  # Константа const

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] Переменные: let и const
      https://learn.javascript.ru/let-const

> Введение
  - В ES-2015 предусмотрены новые способы объявления переменных.
  - Через let и const вместо var.

> Отличия let от var

  1. Область видимости переменной let – блок {...}.
    - var видна везде в функции.
    - let видна только в блоке {...}, где объявлена.
    - Это касается и блоков в if, while, for.
    - Пример:

      let age = 10;
      if(true) { 
        let age = 15;
        console.log(age);           // 15 
      }
      console.log(age);             // 10

  2. Переменная let видна только после объявления.
    - Переменные var существуют и до объявления, они равны undefined.
    - Переменные let же не существую до объявления.
    - Плюс, переменные let нельзя повторно объявлять, будет ошибка.

  3. При использовании в цикле, для каждой итерации создаётся своя переменная.
    - Переменная var одна на все итерации цикла. И видна даже после него.
    - Но с let по-другому. Каждому повторению цикла - своя let.
    - Если внутри цикла есть сложенные объявлений функций, то 
      в замыкании каждой будет соответствующая итерации переменная let.
    - Пример:

        function makeArmy() {

          let shooters = [];

          for (let i = 0; i < 10; i++) {
            shooters.push(function() {
              alert( i ); // выводит свой номер
            });
          }

          return shooters;
        }

        var army = makeArmy();

        army[0](); // 0
        army[5](); // 5    

> Константа const
  
  • Принципы работы const
    - Объявление const задаёт константу.
    - Константу нельзя изменить.
    - Пример:

        const apple = 5;
        apple = 10;       // ошибка  

    - В остальном, const аналогично let.

  • Если в константу присвоен объект
    - То от изменения защищена сама константа.
    - А вот свойства объекта менять можно.
    - Пример:

      const user = {
        name: "Вася"
      };

      user.name = "Петя"; // допустимо
      user = 5;           // нельзя, будет ошибка    

  • Верхний регистр


А3. Деструктуризация

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Деструктуризация массива

    ▪ Пример деструктуризации массива
    ▪ Ненужные элементы массива можно отбросить с помощью запятых
    ▪ Оператор "spread"
    ▪ Значения по умолчанию

  # Деструктуризация объекта

    ▪ Пример деструктуризации объекта
    ▪ Как присвоить св-во объекта в переменную с другим именем
    ▪ Значения по умолчанию
    ▪ Отсутствие оператора "spread" при диструктуризации объектов
    ▪ Проблема с видимостью let-переменных при деструктуризации

  # Вложенные диструктуризации

    ▪ В чём суть вложенных деструктуризаций
    ▪ Пример вложенных деструктуризаций    

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] Деструктуризация
      https://learn.javascript.ru/destructuring

> Введение
  - Деструктуризация, это особый синтаксис присвоения.
  - Можно присвоить массив или объект сразу нескольким
    переменным, разбив его на части.

> Деструктуризация массива

  • Пример деструктуризации массива
    - Первое значение массива пойдёт в переменную firstName.
    - Второе значение массива пойдёт в переменную lastName.

      'use strict';
      let [firstName, lastName] = ["Илья", "Кантор"];
      alert(firstName); // Илья
      alert(lastName);  // Кантор

  • Ненужные элементы массива можно отбросить с помощью запятых

      'use strict';
      // первый и второй элементы не нужны
      let [, , title] = "Юлий Цезарь Император Рима".split(" ");
      alert(title); // Император

  • Оператор "spread"
    - Иногда мы хотим получить последующие значения массива.
    - Но не уверены в их числе.
    - Можно добавить ещё один параметр, который получит "всё остальное".
    - Для этого надо использовать оператор "..." (spread, троеточие).
    - Пример:

        'use strict';
        let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
        alert(firstName); // Юлий
        alert(lastName);  // Цезарь
        alert(rest);      // Император,Рима (массив из 2х элементов)    

  • Значения по умолчанию
    
    ▪ Undefined по умолчанию
      - Если значений в массиве меньше, чем переменных, ошибки не будут.
      - Лишние переменные просто будут наполнены значениями undefined.
      - Пример:

          'use strict';
          let [firstName, lastName] = [];
          alert(firstName); // undefined    

    ▪ Самому задавать значения по умолчанию
      - Но вместо этого можно задавать значения по умолчанию.
      - Для этого после переменной используют =
      - Пример:

          'use strict';
          // значения по умолчанию
          let [firstName="Гость", lastName="Анонимный"] = [];
          alert(firstName); // Гость
          alert(lastName);  // Анонимный

      - В качестве значений по умолчанию можно задавать не только примитивы.
      - Но можно использовать выражения, фукнции, и т.д.
      - Пример, причём вызов defaultLastName будет осуществлён только
        при необходимости, т.е. если значения нет в массиве:

          'use strict';

              function defaultLastName() {
                return Date.now() + '-visitor';
              }
              // lastName получит значение, соответствующее текущей дате:
              let [firstName, lastName=defaultLastName()] = ["Вася"];
              alert(firstName); // Вася
              alert(lastName);  // 1436...-visitor

> Деструктуризация объекта

  • Пример деструктуризации объекта
    - Объект справа, уже существующий, который мы хотим разбить на переменные.
    - Объект слева, список переменных, в которые надо соотв.св-ва записать.
    - Пример:

        'use strict';
        let options = {
          title: "Меню",
          width: 100,
          height: 200
        };
        let {title, width, height} = options;
        alert(title);  // Меню
        alert(width);  // 100
        alert(height); // 200    

  • Как присвоить св-во объекта в переменную с другим именем
    - Например, чтобы св-во options.width шло в переменную w.
    - Пример:

        'use strict';
        let options = {
          title: "Меню",
          width: 100,
          height: 200
        };
        let {width: w, height: h, title} = options;
        alert(title);  // Меню
        alert(w);      // 100
        alert(h);      // 200    

  • Значения по умолчанию
    - Если каких-то св-в в объекте нет, можно указать значения по умолчанию.
    - Для этого нужно использовать знак =
    - Пример:

        'use strict';
        let options = {
          title: "Меню"
        };
        let {width=100, height=200, title} = options;
        alert(title);  // Меню
        alert(width);  // 100
        alert(height); // 200    

  • Отсутствие оператора "spread" при диструктуризации объектов
    - Если в объекте больше значений, чем переменных.
    - То присвоить "остаток", аналогично массивам, некуда.
    - Но она планируется в будущем стандарте.

  • Проблема с видимостью let-переменных при деструктуризации
    - Чтобы её избежать, надо использовать скобки.
    - Пример:

        let a, b;
        ({a, b} = {a:5, b:6}); // внутри выражения это уже не блок    

> Вложенные диструктуризации

  • В чём суть вложенных деструктуризаций
    - Например, массив/объект содержит другие массивы/объекты.
    - И мы ходим их тоже деструктуризировать - не проблема.
    - Деструктуризации можно как угодно сочетать, вкладывать друг в друга.

  • Пример вложенных деструктуризаций

      'use strict';

      let options = {
        size: {
          width: 100,
          height: 200
        },
        items: ["Пончик", "Пирожное"]
      }

      let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

      // Меню 100 200 Пончик Пирожное
      alert(title);  // Меню
      alert(width);  // 100
      alert(height); // 200
      alert(item1);  // Пончик
      alert(item2);  // Пирожное  


А4. Функции

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Параметры по умолчанию

    ▪ Пример параметров по умолчанию
    ▪ Параметры по умолчанию м.б. не только значениями, но и выражениями

  # Оператор spread вместо arguments

    ▪ Оператор ... для получения массива аргументов
    ▪ Использование ... при вызове функции для передачи параметров

  # Деструктуризация в параметрах

    ▪ Деструктуризация при передачи объекта в функцию
    ▪ Более сложный пример деструктуризации
    ▪ Параметры по умолчанию, чтобы можно было вызвать фукнцию без аргументов

  # Имя функции в св-ве name

    ▪ В св-ве name фунции содержится её имя
    ▪ Даже у анонимных функций могут быть имена

  # Объявленная в блоке ф-ия ведёт себя, как let-переменная
  # Стрелочные функции (через =>)

    ▪ Что такое стрелочная функция?
    ▪ Если аргументво несколько, нужно обернуть их в скобки
    ▪ Если нужно задать функцию без аргументов, также используются скобки
    ▪ Когда тело функции достаточно большое, можно обернуть его в фигурные скобки
    ▪ Стрелочные функции очень удобны в качестве коллбэков
    ▪ У стрелочных функций нет своего this
    ▪ Стрелочные функции нельзя запускать с new
    ▪ Стрелочные функции не имеют своего arguments  

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] Функции
      https://learn.javascript.ru/es-function

> Введение
  - Основные изменения в функциях касаются передачи параметров.
  - Плюс, введена доп.короткая запись через стрелочку =>

> Параметры по умолчанию
  
  • Пример параметров по умолчанию
    - Можно указывать параметры по умолчанию через =
    - Применяется при отсутствующем, или равном undefined аргументе.
    - При любом другом значении кроме undefined, включая null, не применяется.
    - Например:

        function showMenu(title = "Без заголовка", width = 100, height = 200) {
          alert(title + ' ' + width + ' ' + height);
        }
        showMenu("Меню"); // Меню 100 200  

  • Параметры по умолчанию м.б. не только значениями, но и выражениями
    - Соотв.выражение будет выполнено только по мере необходимости.
    - Т.Е. если значение не передано, или равно undefined.
    - Например:

        function sayHi(who = getCurrentUser().toUpperCase()) {
          alert('Привет, ' + who);
        }

        function getCurrentUser() {
          return 'Вася';
        }

        sayHi(); // Привет, ВАСЯ    

> Оператор spread вместо arguments

  • Оператор ... для получения массива аргументов
    - В примере rest является не псевдомассивом, а настоящим (в отличие от arguments).
    - Кроме того, оператор ... должен обязательно быть в конце.
    - Пример:

        function showName(firstName, lastName, ...rest) {
          alert(firstName + ' ' + lastName + ' - ' + rest);
        }

        // выведет: Юлий Цезарь - Император,Рима
        showName("Юлий", "Цезарь", "Император", "Рима");

  • Использование ... при вызове функции для передачи параметров
    - Пример:

        'use strict';
        let numbers = [2, 3, 15];
        // Оператор ... в вызове передаст массив как список аргументов
        // Этот вызов аналогичен Math.max(2, 3, 15)
        let max = Math.max(...numbers);
        alert( max ); // 15    

    - Формально говоря, эти 2 вызова делают одно и то же:

        Math.max(...numbers);
        Math.max.apply(Math, numbers);    

> Деструктуризация в параметрах

  • Деструктуризация при передачи объекта в функцию
    - Определяем объект options.
    - И просто передаём его в функцию.
    - А в аргументах при определении функции тоже размещаем объект.
    - Пример:

      'use strict';

      let options = {
        title: "Меню",
        width: 100,
        height: 200
      };

      function showMenu({title, width, height}) {
        alert(title + ' ' + width + ' ' + height); // Меню 100 200
      }

      showMenu(options);  

  • Более сложный пример деструктуризации
    - С соответствиями и значениями по умолчанию.
    - Пример:

        'use strict';

        let options = {
          title: "Меню"
        };

        function showMenu({title="Заголовок", width:w=100, height:h=200}) {
          alert(title + ' ' + w + ' ' + h);
        }

        // объект options будет разбит на переменные
        showMenu(options); // Меню 100 200    

  • Параметры по умолчанию, чтобы можно было вызвать фукнцию без аргументов

      'use strict';

      function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) {
        alert(title + ' ' + w + ' ' + h);
      }

      showMenu(); // Заголовок 100 200

> Имя функции в св-ве name
  
  • В св-ве name фунции содержится её имя
    - Например:

      'use strict';
      function f() {}               // f.name == "f"
      let g = function g() {};      // g.name == "g"
      alert(f.name + ' ' + g.name)  // f g

  • Даже у анонимных функций могут быть имена
    - Например, при создании анон.функции она записывается в переменную.
    - Тогда она получает имя, равное названию переменной.
    - Пример:

        'use strict';
        // свойство g.name = "g"
        let g = function() {};
        let user = {
          // свойство user.sayHi.name == "sayHi"
          sayHi: function() {}
        };    

> Объявленная в блоке ф-ия ведёт себя, как let-переменная
  - Объявлении функции Function Declaration, сделанное в блоке,
    видно только в этом блоке.
  - Пример:

      'use strict';

      if (true) {
        sayHi(); // работает
        function sayHi() {
          alert("Привет!");
        }
      }
      sayHi(); // ошибка, функции не существует

  - По сути, это тоже самое, что использовать let.
  - Пример:

      if (true) {
        let sayHi = function sayHi() {
          alert("Привет!");
        }
      }
      sayHi(); // ошибка, функции не существует 

> Стрелочные функции (через =>)

  • Что такое стрелочная функция?
    - Появился новый синтаксис для задания функций через стрелку =>
    - Он позволяет подсократить объявление функций.
    - Пример-сравнение обычного и нового синтаксиса:

        let inc = x => x+1;
        let inc = function(x) { return x + 1; };

  • Если аргументво несколько, нужно обернуть их в скобки
    - Пример:

        'use strict';
        let sum = (a,b) => a + b;
        // аналог с function
        // let inc = function(a, b) { return a + b; };
        alert( sum(1, 2) ); // 3

  • Если нужно задать функцию без аргументов, также используются скобки
    - Пример:

        'use strict';
        // вызов getTime() будет возвращать текущее время
        let getTime = () => new Date().getHours() + ':' + new Date().getMinutes();
        alert( getTime() ); // текущее время    

  • Когда тело функции достаточно большое, можно обернуть его в фигурные скобки
    - Однако, если тело обёрнуто в {}, его результат уже не возвращается автоматически.
    - Такая функция должна иметь явный return.

        'use strict';
        let getTime = () => {
          let date = new Date();
          let hours = date.getHours();
          let minutes = date.getMinutes();
          return hourse + ':' + minutes;
        };
        alert( getTime() ); // текущее время

  • Стрелочные функции очень удобны в качестве коллбэков
    - Пример:

        `use strict`;
        let arr = [5, 8, 3];
        let sorted = arr.sort( (a,b) => a - b );
        alert(sorted); // 3, 5, 8

  • У стрелочных функций нет своего this
    - Внутри них this тот же самый, что и снаружи.
    - Это удобно в обработчиках событий и колбэках.
    - Например:

        'use strict';
        let group = {
          title: "Наш курс",
          students: ["Вася", "Петя", "Даша"],

          showList: function() {
            this.students.forEach(
              student => alert(this.title + ': ' + student)
            )
          }
        }
        group.showList();
        // Наш курс: Вася
        // Наш курс: Петя
        // Наш курс: Даша    

  • Стрелочные функции нельзя запускать с new
    - Так как у неё нет своего this.

  • Стрелочные функции не имеют своего arguments
    - А arguments содержит ссылку на оной внешней "обычной" функции.
    - Например, вызов f выведет 1, получив его из аргументов внешней обычной функции:

        'use strict';
        function f() {
          let showArg = () => alert(arguments[0]);
          showArg();
        }
        f(1); // 1    


А5. Строки

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Строки-шаблоны и новый вид кавычек ``

    ▪ Новый вид кавычек ``
    ▪ Возможность делать перевод строки
    ▪ Возможность вставлять шаблоны с выражениями

  # Функции шаблонизации

    ▪ Функция шаблонизации для строк
    ▪ strings.row
    ▪ Использование функции шаблонизации для преобразования строки
    ▪ Использование функции шаблонизации для интернационализации

  # Улучшена поддержка Unicode
  # Добавлены полезные методы

    ▪ include(s)      | Есть ли одна строка внутри другой
    ▪ endsWith(s)     | Заканчивается ли указанная строка указанными символами
    ▪ startsWith(s)   | Начинается ли указанная строа с указанных символов
    ▪ repeat(times)   | Конструирует и возвращает новую строку


--------------------------------------

> Ссылки

  # [learn.javascript.ru] Строки
      https://learn.javascript.ru/es-string

> Введение
  - Есть ряд улучшений и новых методов для строк.

> Строки-шаблоны и новый вид кавычек ``
  
  • Новый вид кавычек ``
    - Добавлен новый вид кавычек ``.
    - Они имеют отличия от '' и "".

  • Возможность делать перевод строки
    - Например:

        alert(`моя
          многострочная
          строка`);    

  • Возможность вставлять шаблоны с выражениями
    - Возможности вставлять выражения с помощью ${...}.
    - Например:

        'use strict';
        let apples = 2;
        let oranges = 3;

        alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5

> Функции шаблонизации

  • Функция шаблонизации для строк
    - Можно использовать свою фукнцию шаблонизации для строк.
    - Название этой функции ставится перед ``.
    - Например:

        let str = func`моя строка`;

    - Эта функция будет автоматически вызвана.
    - И получит в качестве аргументов строку, разбитую по
      вхождениям параметров ${...} и сами эти параметры:

      'use strict';

        function f(strings, ...values) {
          alert(JSON.stringify(strings));     // ["Sum of "," + "," =\n ","!"]
          alert(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]
          alert(JSON.stringify(values));      // [3,5,8]
        }

        let apples = 3;
        let oranges = 5;

        //          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]
        let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;

  • strings.row
    - В св-ве row содержатся участки строки в изначально введённом виде.

  • Использование функции шаблонизации для преобразования строки
    - Например, можно просто склеить полученные фрагменты в строку.
    - Пример:

        'use strict';

        // str восстанавливает строку
        function str(strings, ...values) {
          let str = "";
          for(let i=0; i<values.length; i++) {
            str += strings[i];
            str += values[i];
          }

          // последний кусок строки
          str += strings[strings.length-1];
          return str;
        }

        let apples = 3;
        let oranges = 5;

        // Sum of 3 + 5 = 8!
        alert( str`Sum of ${apples} + ${oranges} = ${apples + oranges}!`);    

  • Использование функции шаблонизации для интернационализации
    - Пример:

        'use strict';

        let messages = {
          "Hello, {0}!": "Привет, {0}!"
        };

        function i18n(strings, ...values) {
          // По форме строки получим шаблон для поиска в messages
          // На месте каждого из значений будет его номер: {0}, {1}, …
          let pattern = "";
          for(let i=0; i<values.length; i++) {
            pattern += strings[i] + '{' + i + '}';
          }
          pattern += strings[strings.length-1];
          // Теперь pattern = "Hello, {0}!"

          let translated = messages[pattern]; // "Привет, {0}!"

          // Заменит в "Привет, {0}" цифры вида {num} на values[num]
          return translated.replace(/\{(\d)\}/g, (s, num) => values[num]);
        }

        // Пример использования
        let name = "Вася";

        // Перевести строку
        alert( i18n`Hello, ${name}!` ); // Привет, Вася!    




> Улучшена поддержка Unicode
  - Суррогатные пары для 4-битных символов.
  - \u{длинный код}
  - Методы fromCodePoint и fromCharCode.
  - Unicode-нормализация

> Добавлены полезные методы

  • include(s) 
    - Есть ли одна строка внутри другой.
    - Например:

        'Blue Whale'.includes('blue'); // returns false    

  • endsWith(s)
    - Заканчивается ли указанная строка указанными символами.
    - Пример:

        var str = 'To be, or not to be, that is the question.';
        console.log(str.endsWith('question.')); // true
        console.log(str.endsWith('to be'));     // false
        console.log(str.endsWith('to be', 19)); // true

  • startsWith(s) 
    - Начинается ли указанная строа с указанных символов.
    - Пример:

        //startswith
        var str = 'To be, or not to be, that is the question.';
        console.log(str.startsWith('To be'));         // true
        console.log(str.startsWith('not to be'));     // false
        console.log(str.startsWith('not to be', 10)); // true    

  • repeat(times)   
    - Конструирует и возвращает новую строку.
    - Которая содержит указанное кол-во копий строки,
      на которой он был вызван, соединённых вместе.
    - Пример:

        'abc'.repeat(-1);   // RangeError
        'abc'.repeat(0);    // ''
        'abc'.repeat(1);    // 'abc'
        'abc'.repeat(2);    // 'abcabc'
        'abc'.repeat(3.5);  // 'abcabcabc' (count will be converted to integer)
        'abc'.repeat(1/0);  // RangeError
        ({ toString: () => 'abc', repeat: String.prototype.repeat }).repeat(2);
        // 'abcabc' (repeat() is a generic method)    


А6. Объекты и прототипы

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Короткое свойство
  # Вычисляемые свойства
  # Геттер-сеттер для прототипа
  # Object.assign
  # Object.is(value1, value2)
  # Методы объекта
  # Ключевое слово super

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Объекты и прототипы
      https://learn.javascript.ru/es-object

> Введение
  - Нововведения, касающиеся объектов и прототипов.
  - Классы рассмотрены отдельно, в следующей главе.

> Короткое свойство
  - В объекте можно указать имя ранее объявленной переменной.
  - И соотв.св-во объекта будет наполнено значением переменной.
  - Например:

      'use strict';
      let name = "Вася";
      let isAdmin = true;
      let user = {
        name,
        isAdmin
      };
      alert( JSON.stringify(user) ); // {"name": "Вася", "isAdmin": true}

> Вычисляемые свойства
  - В качестве имени св-ва можно испольозвать выражение.
  - Примеры:

    // №1
    'use strict';
    let propName = "firstName";
    let user = {
      [propName]: "Вася"
    };
    alert( user.firstName ); // Вася  

    // №2
    'use strict';
    let a = "Мой ";
    let b = "Зелёный ";
    let c = "Крокодил";
    let user = {
      [(a + b + c).toLowerCase()]: "Вася"
    };
    alert( user["мой зелёный крокодил"] ); // Вася    

> Геттер-сеттер для прототипа
  - В ES5 для прототипа был метод-геттер: Object.getPrototypeOf(obj)
  - В ES-2015 также добавился сеттер: Object.setPrototypeOf(obj, newProto)
  - Также "узаконено" св-во __proto__, дающее прямой доступ к прототипу.
    Его реализовали почти все браузеры, кроме IE10-, поэтому его добавили в стандарт.

> Object.assign
  - Это новая функция.
  - Она получает список объектов, и копирует в первый target св-ва из остальных.
  - Её нотация: Object.assign(target, src1, src2...)
  - При этом последующие св-ва перезаписывают предыдущие.
  - Пример:

    'use strict';
    let user = { name: "Вася" };
    let visitor = { isAdmin: false, visits: true };
    let admin = { isAdmin: true };
    Object.assign(user, visitor, admin);
    // user <- visitor <- admin
    alert( JSON.stringify(user) ); // name: Вася, visits: true, isAdmin: true  
 
  - Его также можно исопльзовать для 1-уровневого клонирования объекта:

    'use strict';
    let user = { name: "Вася", isAdmin: false };
    // clone = пустой объект + все свойства user
    let clone = Object.assign({}, user);    

> Object.is(value1, value2)
  - Это новая функция для проверки равенства значений.
  - Возвращает true, если значения равны, иначе false.
  - Она похожа на обычное ===, но есть отличия.
  - Хотя они не критичны, и не похоже, что ф-ия вытеснит обучную ===.
  - Вот эти отличия:

      // Сравнение +0 и -0
      alert( Object.is(+0, -0)); // false
      alert( +0 === -0 );        // true

      // Сравнение с NaN
      alert( Object.is(NaN, NaN) ); // true
      alert( NaN === NaN );         // false

> Методы объекта

  • Метод объекта
    - Ранее "методами" называли просто св-ва с функциями.
    - Но теперь добавлены именно "методы объекта".
    - По сути, это свойства-функции, привязанные к объекту.
    - Что касается вызова метода, он ничем не отличается от обычной функции.
    - Так что пока можно считать это просто синтаксическим сахаром.

  • Особенности методов объекта
    - Более короткий синтаксис объявления.
    - Наличие в методах специального внутреннего св-ва [[HomeObject]]
      (домашний объект), ссылающегося на объект, которому метод принадлежит.

  • Как объявить метод объекта
    - "prop: function() {…}"  // Так объявляется св-во с функцией
    - "prop() { … }"          // А так метод объекта
    - Например:

        'use strict';
        let name = "Вася";
        let user = {
          name,
          // вместо "sayHi: function() {" пишем "sayHi() {"
          sayHi() {
            alert(this.name);
          }
        };
        user.sayHi(); // Вася    

  • Ещё примеры объявления методов

    // №1 - методами станут объявления геттеров get prop() и сеттеров set prop()
    'use strict';
    let name = "Вася", surname="Петров";
    let user = {
      name,
      surname,
      get fullName() {
        return `${name} ${surname}`;
      }
    };
    alert( user.fullName ); // Вася Петров

    // №2 - можно задать и метод с вычисляемым названием:
    'use strict';
    let methodName = "getFirstName";
    let user = {
      // в квадратных скобках может быть любое выражение,
      // которое должно вернуть название метода
      [methodName]() {  // вместо [methodName]: function() {
        return "Вася";
      }
    };
    alert( user.getFirstName() ); // Вася

> Ключевое слово super

  • Что за ключевое слово super
    - В ES-2015 появилось новое ключевое слово super.
    - Оно предназначено только для использования в методах объекта.
    - Вызов super.parentProperty позволяет из метода объекта
      получить свойство его прототипа.
    - Например, в коде ниже rabbit наследует от animal.
    - Вызов super.walk() из метода объекта rabbit обращается к animal.walk():

        'use strict';
        let animal = {
          walk() {
            alert("I'm walking");
          }
        };
        let rabbit = {
          __proto__: animal,
          walk() {
            alert(super.walk); // walk() { … }
            super.walk(); // I'm walking
          }
        };
        rabbit.walk();    

  • Super работает только в методах объектов
    - Как правило, это используется в классах.
    - Но важно понимать, что super работает через прототип,
      на уровне методов объекта.
    - При обращении через super используется [[HomeObject]] текущего метода.
    - И от него берётся __proto__. Поэтому super работает только внутри методов.
      
        'use strict';
        let animal = {
          walk() {
            alert("I'm walking");
          }
        };
        let rabbit = {
          __proto__: animal,
          walk: function() { // Надо: walk() {
            super.walk(); // Будет ошибка!
          }
        };
        rabbit.walk();- Если оформить walk не как метод, а как функцию, будет ошибка:

    - Исключением является использование стрелочной функции.
    - Если оформить walk, как оную, оно будет работать.
    - Т.К. у оной нет this и arguments, и они используют оные от внешних функций.

        'use strict';
        let animal = {
          walk() {
            alert("I'm walking");
          }
        };
        let rabbit = {
          __proto__: animal,
          walk() {
            setTimeout(() => super.walk()); // I'm walking
          }
        };
        rabbit.walk();    


А7. Классы

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Class

    ▪ Синтаксис для классов
    ▪ Пример объявления класса
    ▪ Какие отличия при объявлении класса через class
    ▪ Особенности методов, объявленных внутри class

  # Class Expression
  # Геттеры, сеттеры и вычисляемые свойства
  # Статические свойства

    ▪ Статические свойства
    ▪ Для чего используются статические свойства

  # Наследование

    ▪ Синтаксис наследования
    ▪ Пример наследования
    ▪ Переопределение методов в наследнике
    ▪ Конструктор наследуется, если в потомке нет своего

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Классы
      https://learn.javascript.ru/es-class

> Введение
  - В ES-2015 появился новый красивый синтаксис для классов.
  - Новая конструкция class - удобный синтаксический сахаром
    для задания конструктора вместе с прототипом.

> Class

  • Синтаксис для классов

      class Название [extends Родитель]  {
        constructor
        методы
      }

  • Пример объявления класса
    - Функция constructor запускается при создании new User.
    - Остальные записываются в User.prototype.

      'use strict';
      class User {

        constructor(name) {
          this.name = name;
        }

        sayHi() {
          alert(this.name);
        }

      }
      let user = new User("Вася");
      user.sayHi(); // Вася  
  
    - Это объявление примерно аналогично такому:

      function User(name) {
        this.name = name;
      }
      User.prototype.sayHi = function() {
        alert(this.name);
      };    

  • Какие отличия при объявлении класса через class

    ▪ User нельзя вызвать без new, будет ошибка.
    ▪ Объявление класса с точки зрения области видимости
      ведёт себя, как let. В частности, оно видно только
      в текущем блоке и только в коде, который находится
      ниже объявления (Function Declaration видно и до объявления).

  • Особенности методов, объявленных внутри class

    ▪ Метод sayHi является именно методом, т.е. имеет доступ к super.
    ▪ Все методы класса работают в строгом режиме use strict, даже если он не указан.
    ▪ Все методы класса не перечислимы. Т.Е. в цикле for..in по объекту их не будет.

> Class Expression
  - По аналогии с Function Expression, есть Class Expression.
  - Т.Е. классы можно задавать "индайн", в любом выражении и внутри вызова фукнции.
  - Пример Class Expression:

      'use strict';
      let User = class {
        sayHi() { alert('Привет!'); }
      };
      new User().sayHi();  

  - В примере выше у класса нет имени, но его можно дать.
  - Тогда оно будет доступно только внутри класса:

      'use strict';
      let SiteGuest = class User {
        sayHi() { alert('Привет!'); }
      };
      new SiteGuest().sayHi(); // Привет
      new User(); // ошибка  

  - Имя User доступно лишь внутри класса.
  - И М.Б. использовано для создания новых объектов данного типа.
  - Наиболее очевидная область применения, создание вспомогательного
    класса прямо при вызове функции.
  - Например, функция createModel в примере ниже создаёт объект
    по классу и данным, и добавляет ему _id и пишет в "реестр" allModels:

      'use strict';
      let allModels = {};
      function createModel(Model, ...args) {
        let model = new Model(...args);
        model._id = Math.random().toString(36).slice(2);
        allModels[model._id] = model;
        return model;
      }
      let user = createModel(class User {
        constructor(name) {
          this.name = name;
        }
        sayHi() {
          alert(this.name);
        }
      }, "Вася");
      user.sayHi(); // Вася
      alert( allModels[user._id].name ); // Вася    

> Геттеры, сеттеры и вычисляемые свойства
  - В классах, как и в обычных объектах, можно объявлять геттеры/сеттеры.
  - Для этого можно использовать get/set.
  - Также можно использовать [...].
  - Пример:

      'use strict';
      class User {
        constructor(firstName, lastName) {
          this.firstName = firstName;
          this.lastName = lastName;
        }

        // геттер
        get fullName() {
          return `${this.firstName} ${this.lastName}`;
        }

        // сеттер
        set fullName(newValue) {
          [this.firstName, this.lastName] = newValue.split(' ');
        }

        // вычисляемое название метода
        ["test".toUpperCase()]() {
          alert("PASSED!");
        }

      };
      let user = new User("Вася", "Пупков");
      alert( user.fullName ); // Вася Пупков
      user.fullName = "Иван Петров";
      alert( user.fullName ); // Иван Петров
      user.TEST(); // PASSED! 

> Статические свойства

  • Статические свойства
    - Класс, как и функция, является объектом.
    - Статические свойства класса User - это непосредственно его св-ва.
    - Они доступны через точку.
    - Для их объявления используется ключевое слово static.
    - Например:

        'use strict';
        class User {
          constructor(firstName, lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
          }

          static createGuest() {
            return new User("Гость", "Сайта");
          }
        };
        let user = User.createGuest();
        alert( user.firstName ); // Гость
        alert( User.createGuest ); // createGuest ... (функция)

  • Для чего используются статические свойства
    - Для операций, не требующих наличия объекта.
    - Например, для фабричных, как в примере выше.
    - То есть, как альтернативные варианты конструктора.
    - Также статическими удобно делать константы:

        'use strict';
        class Menu {
          static get elemClass() {
            return "menu"
          }
        }
        alert( Menu.elemClass ); // menu    

> Наследование

  • Синтаксис наследования

      class Child extends Parent {
        ...
      }

  • Пример наследования
    - В примере ниже объявляются 2 класса.
    - Animal и наследующий от него Rabbit.

        'use strict';
        class Animal {
          constructor(name) {
            this.name = name;
          }

          walk() {
            alert("I walk: " + this.name);
          }
        }
        class Rabbit extends Animal {
          walk() {
            super.walk();
            alert("...and jump!");
          }
        }
        new Rabbit("Вася").walk();
        // I walk: Вася
        // and jump!

    - Как видим, в new Rabbit доступны и свои методы.
    - И методы родителя через super.
    
  • Переопределение методов в наследнике
    - Методы родителя можно переопределять в наследнике.
    - При этом для обращения к родительскому методу используют 
      конструкция типа super.walk().

  • Конструктор наследуется, если в потомке нет своего
    - Т.Е. если в потомке не указан свой constructor.
    - Если же у потомка есть свой constructor, то, чтобы в нём
      вызвать конструктор родителя - используется синтаксис super()
      с аргументами для родителя.
    - Например, вызовем конструктор Animal в Rabbit:

        'use strict';
        class Animal {
          constructor(name) {
            this.name = name;
          }

          walk() {
            alert("I walk: " + this.name);
          }
        }
        class Rabbit extends Animal {
          constructor() {
            // вызвать конструктор Animal с аргументом "Кроль"
            super("Кроль"); // то же, что и Animal.call(this, "Кроль")
          }
        }
        new Rabbit().walk(); // I walk: Кроль    

    - Для такого вызова есть ограничения:

      ▪ Вызвать конструктор родителя можно только из конструктора потомка.
        - В частности, super() нельзя вызвать из произвольного метода.

      ▪ В конструкторе потомка мы обязаны вызвать super() до обращения к this
        - До вызова super не существует this, т.к. по спецификации
          в этом случае именно super инициализирует this.


А8. Тип данных Symbol

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Объявление symbol

    ▪ Не используется new
    ▪ Typeof символа  
    ▪ Имя символа  

  # Глобальные символы

    ▪ Что такое глобальный реестр символов
    ▪ Как создать или считать символ в реестре
    ▪ Можно, наоборот, по глобальному символу полуить его имя

  # Использование символов

    ▪ Использование символов в качестве имён для св-в объектов
    ▪ Свойство-символ не участвует в итерации
    ▪ Свойство-символ недоступно, если обратиться к его названию

  # Зачем вообще нужны символы?


--------------------------------------  

> Ссылки

  # [learn.javascript.ru] Тип данных Symbol
      https://learn.javascript.ru/symbol

> Введение
  - Symbol, это новый притимивный тип данных.
  - Он служит для создания уникальных идентификаторов.

> Объявление symbol

  • Не используется new
    - При объявлении не используется new.
    - Выглядит оно так:

      let sym = Symbol();  

  • Typeof символа
    - У символов есть и соответствующий typeof:

      'use strict';
      let sym = Symbol();
      alert( typeof sym ); // symbol  

  • Имя символа
    - Каждый символ уникален.
    - У ф-ии Symbol есть необязательный аргумент "имя символа".
    - Его можно использовать для описания и в целях отладки:

        'use strict';
        let sym = Symbol("name");
        alert( sym.toString() ); // Symbol(name)    

    - Но при этом, если у 2-х символов одно имя, это не значит, что они равны.

        alert( Symbol("name") == Symbol("name") ); // false    

    - А что, если хочется использовать один и тот же символ?
    - Тогда надо передавать объект символа, или использовать
      глобальные символы и реестр глобальных символов.

> Глобальные символы

  • Что такое глобальный реестр символов
    - Существует "глобальный реестр" символов.
    - Он позволяет иметь общие глобальные символы.
    - Их можно получать из реестра по имени.

  • Как создать или считать символ в реестре
    - Примеры:

        'use strict';
        // создание символа в реестре
        let name = Symbol.for("name");
        // символ уже есть, чтение из реестра
        alert( Symbol.for("name") == name ); // true

  • Можно, наоборот, по глобальному символу полуить его имя
    - Если символ не глобальный, keyFor вернёт false.
    - Примеры:

        'use strict';
        // создание символа в реестре
        let name = Symbol.for("name");
        // получение имени символа
        alert( Symbol.keyFor(name) ); // name

> Использование символов

  • Использование символов в качестве имён для св-в объектов

      'use strict';
      let isAdmin = Symbol("isAdmin");
      let user = {
        name: "Вася",
        [isAdmin]: true
      };
      alert(user[isAdmin]); // true

  • Свойство-символ не участвует в итерации

      'use strict';
      let user = {
        name: "Вася",
        age: 30,
        [Symbol.for("isAdmin")]: true
      };
      // в цикле for..in также не будет символа
      alert( Object.keys(user) ); // name, age
      // доступ к свойству через глобальный символ — работает
      alert( user[Symbol.for("isAdmin")] );

  • Свойство-символ недоступно, если обратиться к его названию
    - В примере выше user.isAdmin не существует.

> Зачем вообще нужны символы?
  - Да, особо не зачем.
  - В основном, их используют создатели JS.
  - В системных свойстах объектов, для задания разных аспектов их поведения.
  - Да и поддержка браузерами у них пока не большая.


А9. Итераторы

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Свой итератор
  # Встроенные итераторы

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Итераторы
      https://learn.javascript.ru/iterator

> Введение
  - В современный JS добавлена новая концепция "итерируемых" объектов.
  - Это те, содержимое которых можно перебрать в цикле.
  - Например, перебираемым объектом является массив.
  - Но в браузере есть много объектов-не-массивов, которые можно перебрать.
  - К примеру, список DOM-узлов.
  - Для перебора таких объектов добавлен новый синтаксис цикла for..of
  - Например:

      'use strict';
      let arr = [1, 2, 3]; // массив — пример итерируемого объекта
      for (let value of arr) {
        alert(value); // 1, затем 2, затем 3
      }  

  - Также итерируемой является строка:

      'use strict';
      for (let char of "Привет") {
        alert(char); // Выведет по одной букве: П, р, и, в, е, т
      }

  - Итераторы - расширяющая понятие "массив" концепия.
  - Она пронизывает современный стандарт JS сверху-донизу.
  - Практечески везде, где нужен перебор, действуют итераторы.
  - В отличие от массивов, перебираемые объекты могут не иметь длины (length).
  - Вообще, итераторы дают возможность сделать перебираемыми любые объекты.

> Свой итератор
  - Допустим, некий объект надо "умным образом" перебрать.
  - Например, range - диапазон числе от from до to.
  - И мы хотим, чтобы for(let num of range) перебирал этот объект.
  - При этом под перебором мы подразумеваем перечисление чисел от from до to.
  - Для возможности использования for..of надо создать в объекте
    свойство Symbol.iterator.
  - При вызове метода Symbol.iterator перебираемый объект должен
    возвращать другой объект (итератор), который умеет осуществлять перебор.
  - По стандарту у такого объекта д.б. метод next(), который при каждом вызове
    возвращает очередное значение и окончен ли перебор.
  - Пример своего итератора:  

      'use strict';
      let range = {
        from: 1,
        to: 5
      }

      // сделаем объект range итерируемым
      range[Symbol.iterator] = function() {

        let current = this.from;
        let last = this.to;

        // метод должен вернуть объект с методом next()
        return {
          next() {
            if (current <= last) {
              return {
                done: false,
                value: current++
              };
            } else {
              return {
                done: true
              };
            }
          }

        }
      };

      for (let num of range) {
        alert(num); // 1, затем 2, 3, 4, 5
      }..  

  - Если функционал по перебору (метод next) предоставляется
    самим объектом, то можно вернуть this в качестве итератора:

      'use strict';
      let range = {
        from: 1,
        to: 5,

        [Symbol.iterator]() {
          return this;
        },

        next() {
          if (this.current === undefined) {
            // инициализация состояния итерации
            this.current = this.from;
          }

          if (this.current <= this.to) {
            return {
              done: false,
              value: this.current++
            };
          } else {
            // очистка текущей итерации
            delete this.current;
            return {
              done: true
            };
          }
        }

      };

      for (let num of range) {
        alert(num); // 1, затем 2, 3, 4, 5
      }

      // Произойдёт вызов Math.max(1,2,3,4,5);
      alert( Math.max(...range) ); // 5 (*)    

> Встроенные итераторы
  - Встроенные в JS итераторы можно получить и явно, без for..of
  - Можно просто вызвать Symbol.iterator.
  - Например, этот код получает и вызывает итератор для строки:

      'use strict';
      let str = "Hello";

      // Делает то же, что и
      // for (var letter of str) alert(letter);

      let iterator = str[Symbol.iterator]();

      while(true) {
        let result = iterator.next();
        if (result.done) break;
        alert(result.value); // Выведет все буквы по очереди
      }  


А10. Set, Map, WeakSet и WeakMap

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Map
  # Set
  # WeakMap и WeakSet

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Set, Map, WeakSet и WeakMap
      https://learn.javascript.ru/set-map

> Введение
  - В ES-2015 появились новые типы коллекций.
  - Set, Map, WeakSet и WeakMap.

> Map

  • Общая информация о Map
    - Коллекция для хранения записей вида ключ:значение.
    - В отличие от объектов, ключами могут быть и строки.
    - Например:

        'use strict';

        let map = new Map();

        map.set('1', 'str1');   // ключ-строка
        map.set(1, 'num1');     // число
        map.set(true, 'bool1'); // булевое значение

        // в обычном объекте это было бы одно и то же,
        // map сохраняет тип ключа
        alert( map.get(1)   ); // 'num1'
        alert( map.get('1') ); // 'str1'

        alert( map.size ); // 3  

    - Свойство map.size хранит объее кол-во записей в map.
    - Метод set можно чейнить:

        map
          .set('1', 'str1')
          .set(1, 'num1')
          .set(true, 'bool1');  

    - При создании Map можно сразу инициализировать списком значений.
    - Например:

        let map = new Map([
          ['1',  'str1'],
          [1,    'num1'],
          [true, 'bool1']
        ]);  

    - Аргументом в new Map должен быть итерируемый объект.
    - Не обязательно именно массив.

  • В качестве ключей map можно использовать и объекты
    - А в обычном объекте ключ не может быть объектом.
    - Пример:

        'use strict';
        let user = { name: "Вася" };
        // для каждого пользователя будем хранить количество посещений
        let visitsCountMap = new Map();
        // объект user является ключом в visitsCountMap
        visitsCountMap.set(user, 123);
        alert( visitsCountMap.get(user) ); // 123

  • Итерация
    - Для итерации по map используется один из трёх методов:

      ▪ map.keys()      | возвращает итерируемый объект для ключей
      ▪ map.values()    | возвращает итерируемый объект для значений
      ▪ map.entries()   | возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of 

    - Например:

      'use strict';

      let recipeMap = new Map([
        ['огурцов',   '500 гр'],
        ['помидоров', '350 гр'],
        ['сметаны',   '50 гр']
      ]);

      // цикл по ключам
      for(let fruit of recipeMap.keys()) {
        alert(fruit); // огурцов, помидоров, сметаны
      }

      // цикл по значениям [ключ,значение]
      for(let amount of recipeMap.values()) {
        alert(amount); // 500 гр, 350 гр, 50 гр
      }

      // цикл по записям
      for(let entry of recipeMap) { // то же что и recipeMap.entries()
        alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения
      }

    - Кроме того, у map есть стандартный метод forEach, аналогичный массиву:

      'use strict';
      let recipeMap = new Map([
        ['огурцов',   '500 гр'],
        ['помидоров', '350 гр'],
        ['сметаны',   '50 гр']
      ]);
      recipeMap.forEach( (value, key, map) => {
        alert(`${key}: ${value}`); // огурцов: 500 гр, и т.д.
      });    

> Set

  • Что такое set
    - Коллекция для хранения множества значений.
    - Причём каждое может встречаться лишь раз.
    - Альтернатива - массивы с поиском дубликатов при каждом добавлении.
    - Пример:

      'use strict';
      let set = new Set();
      let vasya = {name: "Вася"};
      let petya = {name: "Петя"};
      let dasha = {name: "Даша"};
      // посещения, некоторые пользователи заходят много раз
      set.add(vasya);
      set.add(petya);
      set.add(dasha);
      set.add(vasya);
      set.add(petya);
      // set сохраняет только уникальные значения
      alert( set.size ); // 3
      set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша    

  • add, delete, has, clear

    ▪ set.add(item)     | добавляет в колекцию item, возвращает set (чейнится)
    ▪ set.delete(item)  | удаляет item из коллекции, возвращает true в случае успеха, иначе false
    ▪ set.has(item)     | возвращает true, если item есть в коллекции, иначе false
    ▪ set.clear()       | очищает set

  • Перебор Set
    - Осуществляется через forEach или for..of, аналогично Map.
    - Причём в Set у forEach 3 аргумента, и первые два - значение.
    - Так сделано для совместимости forEach в Map.
    - Например:

      'use strict';
      let set = new Set(["апельсины", "яблоки", "бананы"]);
      // то же, что: for(let value of set)
      set.forEach((value, valueAgain, set) => {
        alert(value); // апельсины, затем яблоки, затем бананы
      });

> WeakMap и WeakSet

  • Что такое WeakMap и WeakSet
    - Это особые виды map и set.
    - Они не препятствуют сборщику мусора удалять свои элементы.
    - Т.Е. если элемент присутствует только в WeakMap и WeakSet,
      сборщик мусора его удаляет из памяти.

  • Для чего нужны WeakMap и WeakSet
    - Когда основное место для хранения объектов где-то в другом месте кода.
    - А здесь мы хотим хранить для них "вспомогательные" данные.
    - И если самого объекта уже нет, то и этих данных должно не стать.

  • Пример использования WeakMap
    - Допстим, у нас есть пользователи на страницы.
    - И мы хотим хранить для них вспомогательную информацию.
    - И мы можем поместить эту доп.информацию в WeakMap.
    - А объект сделать ключом.
    - И доп.данные будут автоматом удалены, когда удалится элемент.
    - Пример:

        // текущие активные пользователи
        let activeUsers = [
          {name: "Вася"},
          {name: "Петя"},
          {name: "Маша"}
        ];

        // вспомогательная информация о них,
        // которая напрямую не входит в объект юзера,
        // и потому хранится отдельно
        let weakMap = new WeakMap();

        weakMap[activeUsers[0]] = 1;
        weakMap[activeUsers[1]] = 2;
        weakMap[activeUsers[2]] = 3;

        alert( weakMap[activeUsers[0]] ); // 1

        activeUsers.splice(0, 1); // Вася более не активный пользователь

        // weakMap теперь содержит только 2 элемента

        activeUsers.splice(0, 1); // Петя более не активный пользователь

        // weakMap теперь содержит только 1 элемент    

    • Ограничения WeakMap
      - Он имеет следующие ограничения:

        ▪ Нет свойства size.
        ▪ Нельзя перебрать элементы итератором forEach.
        ▪ Нет метода clear().

      - Иными словами, он работает только на запись (set, delete)
        и чтение (has, get) элементов по конкретному ключу, 
        а не как полноценная коллекция.
      - Это из-за того, что содержимое WeakMap не определено в любой момент,
        т.к. там хозяйничает сборщик мусора.


А11. [Обзорно] Промисы

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое Promise?

    ▪ Определение и состояния
    ▪ На promise можно навешивать коллбэки двух типов
    ▪ Способ использования промисов в общих чертах
    ▪ Синтаксис создания Promise
    ▪ Универсальный метод для навешивания обработчиков
    ▪ Throw в промисе

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Промисы
      https://learn.javascript.ru/promise

> Введение
  - Промисы, это удобный способ организации асинхронного кода.
  - В современном JS промисы часто используются в т.ч. неявно, с помощью генераторов.
  - В данной статье промисы рассмотрены повехностно, просто чтобы понять суть.

> Что такое Promise?
  
  • Определение и состояния
    - Это специальный объект, который содержит своё состояние.
    - Стартовое состояние - Pending.
    - Из него он может перейти либо в Fulfilled, либо в Rejected.
    - Вот возможные состояния:

      ▪ Pending     | Ожидание
      ▪ Fulfilled   | Выполнено успешно
      ▪ Rejected    | Выполнено с ошибкой

  • На promise можно навешивать коллбэки двух типов

    ▪ onFulfilled   | Срабатывают, когда promise в состоянии "выполнен успешно".
    ▪ onRejected    | Срабатывают, когда promise в состоянии "выполнен с ошибкой".

  • Способ использования промисов в общих чертах

    1. Код, которому надо что-то сделать асинхронно, создаёт
       объект promise и возвращает его.

    2. Внешний код, получив promise, навешивает на него 
       обработчики.

    3. По завершении процесса асинхронный код переводит promise
       в состояние fulfilled (с результатом) или rejected (с ошибкой). 
       При этом автоматически вызываются соответствующие обработчики
       во внешнем коде.

  • Синтаксис создания Promise

      var promise = new Promise(function(resolve, reject) {
        // Эта функция будет вызвана автоматически

        // В ней можно делать любые асинхронные операции,
        // А когда они завершатся — нужно вызвать одно из:
        // resolve(результат) при успешном выполнении
        // reject(ошибка) при ошибке
      })

  • Универсальный метод для навешивания обработчиков
    - onFulfilled – функция, которая будет вызвана с результатом при resolve.
    - onRejected – функция, которая будет вызвана с ошибкой при reject.

        promise.then(onFulfilled, onRejected)                   | Назначить сразу 2 обработчика
        promise.then(onFulfilled)                               | Назначить только onFulfilled
        promise.then(null, onRejected) или .catch(onRejected)   | Назначить только onRejected

  • Throw в промисе
    - Вызывает reject.
    - Например:

        'use strict';

        let p = new Promise((resolve, reject) => {
          // то же что reject(new Error("o_O"))
          throw new Error("o_O");
        })

        p.catch(alert); // Error: o_O    



А12. [Обзорно] Генераторы

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Создание генератора

    ▪ Объявлении функции-генератора
    ▪ Что происходит при выполнении функции-генератора
    ▪ next() и yield
    ▪ Можно ли "открутить назад" генератор?

  # Передача значения в генератор при next()

    ▪ Генератор - дорога в обе Строки-шаблоны
    ▪ Передача значения в генератор
    ▪ Пример передачи значения в генератор №1
    ▪ Пример передачи значения в генератор №2

  # Плоский асинхронный код на генераторах

    ▪ Зачем нужен плоский асинхронный код
    ▪ Общие принципы плоского асинхронного кода на генераторах
    ▪ Библиотека co

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Промисы
      https://learn.javascript.ru/generator

> Введение
  - Генераторы, это новый вид функций в современном JS.
  - Они могут приостанавливать своё выполнение, возвращать
    промежуточный результат и далее возобновлять выполнение
    позже, в произвольный момент времени.
  - В данной статье поверхностно описаны генераторы.

> Создание генератора

  • Объявлении функции-генератора
    - Примечание: функция-генератор != генератор.
    - Для объявления используется новая конструкция со звёздочкой.
    - Например:

        function* generateSequence() {
          yield 1;
          yield 2;
          return 3;
        }

        function *generateSequence() {  // или так
          yield 1;
          yield 2;
          return 3;
        }            

  • Что происходит при выполнении функции-генератора
    - Код его не выполняется.
    - А возвращается спец.объект, который и называют "генератором".
    - Пример:

        // generator function создаёт generator
        let generator = generateSequence();

  • next() и yield
    - Основным методом генератора является nexe().
    - При вызове он возобнавляет выполнения кода до ближайшего yield.
    - При достижении yield выполнение приостанавливается, а значение возвращается во внешний код.
    - Например:

        function* generateSequence() {
          yield 1;
          yield 2;
          return 3;
        }
        let generator = generateSequence();
        
        let one = generator.next();
        alert(JSON.stringify(one)); // {value: 1, done: false}
    
        let two = generator.next();
        alert(JSON.stringify(two)); // {value: 2, done: false}

        let three = generator.next();        
        alert(JSON.stringify(three)); // {value: 3, done: true}

    - В последнем случае done: true. Новые вызовы не имеют смысла.
    - Но повторные вызовые ошибки не вызовут. Просто будут возвращать: {done: true}.

  • Можно ли "открутить назад" генератор?
    - Нет.

> Передача значения в генератор при next()
  
  • Генератор - дорога в обе Строки-шаблоны
    - Не только генератор может передавать значение во внешний код.
    - Но и внешний код может передавать значение в генератор.

  • Передача значения в генератор
    - Допустим: let result = yield value
    - Этот вызов делает следующее:

      ▪ Возвращает value во внешний код, приостанавливая выполнение генератора.
      ▪ Внешний код может обработать значение, и затем вызвать
        next с аргументом: generator.next(arg).
      ▪ Генератор продолжает выполнение, аргумент next будет
        возвращён, как результат yield (и записан в result).

  • Пример передачи значения в генератор №1

      function* gen() {
        // Передать вопрос во внешний код и подождать ответа
        let result = yield "2 + 2?";
        alert(result);
      }

      let generator = gen();

      let question = generator.next().value;
      // "2 + 2?"

      setTimeout(() => generator.next(4), 2000);  

  • Пример передачи значения в генератор №2

      function* gen() {
        let ask1 = yield "Сколько будет 2 + 2?";

        alert(ask1); // 4

        let ask2 = yield "3 * 3?"

        alert(ask2); // 9
      }

      let generator = gen();
      alert( generator.next().value ); // "2 + 2?"
      alert( generator.next(4).value ); // "3 * 3?"
      alert( generator.next(9).done ); // true  

> Плоский асинхронный код на генераторах

  • Зачем нужен плоский асинхронный код
    - Чтобы избежать коллбэк-хэла.

  • Общие принципы плоского асинхронного кода на генераторах

    ▪ Yield промисов
      - Генератор yield'ит не просто значения, а промисы.

    ▪ Функция-чернорабочий execute
      - Есть специальная функция-чернорабочий execute.
      - Она запускает генератор, и послед.вызовами next 
        получает из него промисы.
      - Один за другим, и, когда очередной промис выполнится,
        возвращает его результат в генератор следующим next.

    ▪ Последнее значение генератора execute обрабатывает, как окончательный результат
      - Например, возвращает через промис куда-то ещё.
      - Во внешний код, или просто использует как-то.

  • Библиотека co
    - Это готовая библиотека для функции-чернорабочего.
    - Пример использования:

        co(function*() {

          let result = yield new Promise(
            resolve => setTimeout(resolve, 1000, 1)
          );

          alert(result); // 1

        })


А13. Модули

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое модуль?
  # export
  # import
  # export default

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Промисы
      https://learn.javascript.ru/modules

> Введение
  - Концепция модулей как способа организации JavaScript-кода существовала давно.
  - Но в предыдущих стандартах ECMAScript её не было.
  - А в стандарте ES-2015 она появились.
  - Значит, рано или поздно, будет поддерживаться всеми браузерами без доп.утилит.

> Что такое модуль?
  - Это файл с кодом.
  - В файле ключевым словом export помечаются переменные
    и функции, которые могут быть использованы снаружи.
  - Другие модули могут подключать их через вызов import.
  - В настоящий момент модули требуют системы сборке на сервере,
    вроде webpack.

> export
  - Можно ставить перед объявлением переменных, функций, классов.
  - Для экспорта функции/класса обязательно должно быть имя.
  - Отдельно, при этом в фигурных скобках указывается, что именно экспортируется.

      export let one = 1;
      let two = 2; export {two};
      export {one, two};

  - При помощи ключевого слова as можно указать, что 
    переменная one будет доступна снаружи под именем once,
    а two - под именем twice:

      export {one as once, two as twice};

> import
  - Другие модули могут подключать экспортированные значения
    с помощью ключевого слова import.
  - Синтаксис:

      import {one, two} from "./nums";  
      import * as numbers from "./nums";  | Импорт всех значений в виде объекта

> export default
  - Можно задать экспортируемое по умолчанию значение модуля.
  - Такое значение можно импортировать без фигурных скобок.
  - Например:

    В файле user.js
    ---
      export default class User {
        constructor(name) {
          this.name = name;
        }
      };  

    В файле login.js
    ---
      import User from './user';
      new User("Вася");

А14. Proxy

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

--------------------------------------

> Ссылки

  # [learn.javascript.ru] Промисы
      https://learn.javascript.ru/proxy

> Введение
  - Proxy - особый объект в JS.
  - Он перехватывает обращения к другому объекту и,
    при необходимости, модифицирует их.
  - Синтаксис:

      let proxy = new Proxy(target, handler)

  - Здесь:

      target    | Объект, обращения к которому надо перехватывать.
      handler   | объект с "ловушками": функциями-перехватчиками для операций target.

  - Почти любая операция м.б. перехвачена и обработана до/после доступа к target.
  - Различных типов ловушек довольно много.
  - Подробнее: см.ссылку в "ссылках" выше.











