////=================================================////
////                                                 ////
////                      Devops                     ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////




////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////

  
  А1. Настройка ВМ Vagrant Ubuntu 16.04
  А2. Подключение диска ВМ к windows в виде тома
  А3. Подготовка каталога проекта в ВМ к разработке
  А4. Настроить терминальный доступ к docker registry на gitlab
  А5. Установка моего стартового Laravel-проекта
  А6. Настройка SSH-подключения только через ключи к VDS-серверу
  А7. Связать домен с сервером, настроить поддомен, сделать переадресацию
  А8. Настроить IPv6 на сервере
  А9. Установка, настройка GitLab EE, загрузка лицензии
  А10. Организация работы с git'ом на GitLab через SSH-ключи
  А11. Создание нового проекта на GitLab, организация git-репозитория
  А12. Защита ветки master от прямой записи на GitLab
  А13. Настройка HTTPS на GitLab
  А14. Настройка Docker Container Registry
  А15. Подготовка, сборка и загрузка Docker-образов в DCR
  А16. Настройка CI/CD и runner'ов для проекта
  А17. Настройка HTTPS на prod-сервере с автообновлением


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Настройка ВМ Vagrant Ubuntu 16.04
-------------------------------------
Подоглавление:

  # Постановка задачи
  # Пошаговая инструкция
  # Советы по настройке
  # Образцы файлов

    ▪ Образец Vagrantfile
    ▪ Образец bootstrap.sh
    ▪ Образец .gitignore
    ▪ Образец README.md

--------------------------------------

> Постановка задачи

  Требуется настроить пригодную для разработки проекта
  виртуальную машину с помощью vagrant на ubuntu 16.04,
  с установленными docker и docker compose.

> Пошаговая инструкция

  1. Создать папку проекта

    Например: C:\WebDev\projects\manveloff\cleaning

  2. В этой папке создать папку vagrant
  3. В vagrant создать файлы по образцам:

    ▪ Vagrantfile
    ▪ bootstrap.sh
    ▪ .gitignore
    ▪ README.md

  4. Актуализировать данные в Vagrantfile

    ▪ config.vm.synced_folder

      Вписать сюда актуальные пути.

    ▪ config.ssh.username, config.ssh.password

      Сюда вписать 'vagrant' как для пароля,
      так и для логина (потом, когда включим
      пользователя root, надо будет сменить).

  5. Создать, запустить и войти в виртуальную машину

    cd "C:\WebDev\projects\manveloff\cleaning\vagrant"
    vagrant up
    vagrant ssh

  6. Разрешить логиниться пользователю root через ssh

    Открыть конфиг:
      sudo nano /etc/ssh/sshd_config

    Изменить значение PermitRootLogin на yes:
      PermitRootLogin yes

    Закрыть и сохранить конфиг.

  7. Включить пользователя root

    Выполните эту команду и задайте пароль 'root' для root:
      sudo passwd root

    Затем выполните эту команду, чтобы разблокировать root-аккаунт:
      sudo passwd -u root

  8. Остановить виртуальную машину

    cd "C:\WebDev\projects\manveloff\cleaning\vagrant"
    vagrant halt

  9. Актуализировать данные в Vagrantfile

    ▪ config.ssh.username, config.ssh.password

      Сюда вписать 'root' как для пароля,
      так и для логина (потом, когда включим
      пользователя root, надо будет сменить).

  10. Сделать так, чтобы при vagrant ssh не спрашивался пароль

    По умолчанию, даже учитывая, что у вас в Vagrantfile
    указан пароль root, команда vagrant ssh продолжает
    запрашивать пароль при входе, что напрягает.

    Сделаем, чтобы она не запрашивала. Для этого заменим
    первым файлом второй:

      первый  C:\Users\<user>\.vagrant.d\insecure_private_key
      второй  C:\WebDev\projects\manveloff\cleaning\vagrant\.vagrant\machines\default\virtualbox\private_key

    После чего vagrant ssh перестанет спрашивать пароль.  

  11. Снова запустить VM и убедиться, что вы вошли, как root
    
    cd "C:\WebDev\projects\manveloff\cleaning\vagrant"
    vagrant root

> Образцы файлов

  • Образец Vagrantfile

    #################################################
    ##                                             ##
    ##   Vagrantfile for VM creating via Vagrant   ##
    ##                                             ##
    #################################################
    ## Table of contents ##
    #######################
    #
    # 1. Configure folders to share via NFS
    # 2. Other settings, you can don't touch them
    #   2.1. The base image (box)
    #   2.2. Configuring of initializers
    #   2.3. Configuring of NAT-network (guest<>host<>world)
    #   2.4. Configuring of host-only-network (guest<>host)
    #   2.5. Disable the check for updates box
    #   2.6. Set limits on virtual machine
    #   2.7. Configure the timeout for the virtual machine (1000 seconds default)
    #   2.n. Message after vagrant up
    #
    Vagrant.configure(2) do |config|
      
      ###########################################
      ## 1. Configure folders to share via NFS ##
      ###########################################  
      config.vm.synced_folder "c:/webdev/projects/manveloff/cleaning/vagrant", "/manveloff/cleaning/env/vagrant"

      #################################################
      ## 2. Other settings, you can don't touch them ##
      #################################################    
        
        ###############################
        ## 2.1. The base image (box) ##
        ###############################
        config.vm.box = "ubuntu/trusty64"
        config.ssh.username = 'root'
        config.ssh.password = 'root'
        
        ######################################
        ## 2.2. Configuring of initializers ##
        ######################################          
        
          ## 2.2.1. Running only in the 1st vagrant up ##
          ###############################################    
          config.vm.provision :shell, path: "bootstrap.sh"
            
          ## 2.2.2. Running every vagrant up ##
          ##################################### 
          # config.vm.provision "shell", inline: "sudo service docker start", run: "always"
            
        ##########################################################
        ## 2.3. Configuring of NAT-network (guest<>host<>world) ##
        ##########################################################
        config.vm.network :forwarded_port, guest: 80, host: 80
        config.vm.network :forwarded_port, guest: 443, host: 443
        config.vm.network :forwarded_port, guest: 25, host: 25
        config.vm.network :forwarded_port, guest: 587, host: 587
        config.vm.network :forwarded_port, guest: 465, host: 465
        config.vm.network :forwarded_port, guest: 993, host: 993
        config.vm.network :forwarded_port, guest: 143, host: 143
        config.vm.network :forwarded_port, guest: 110, host: 110
        config.vm.network :forwarded_port, guest: 995, host: 995
        # config.vm.network :forwarded_port, guest: 9050, host: 9050
        # config.vm.network :forwarded_port, guest: 9150, host: 9150
        
        config.vm.network :forwarded_port, guest: 3306, host: 3306
        config.vm.network :forwarded_port, guest: 6001, host: 6001
        config.vm.network :forwarded_port, guest: 3000, host: 3000
        config.vm.network :forwarded_port, guest: 3001, host: 3001
        config.vm.network :forwarded_port, guest: 3002, host: 3002
        config.vm.network :forwarded_port, guest: 8000, host: 8000
        
        #########################################################
        ## 2.4. Configuring of host-only-network (guest<>host) ##
        #########################################################     
        config.vm.network "private_network", ip: "10.10.10.10", adapter: 2
        
        ############################################
        ## 2.5. Disable the check for updates box ##
        ############################################    
        config.vm.box_check_update = false

        ########################################
        ## 2.6. Set limits on virtual machine ##
        ########################################    
        config.vm.provider "virtualbox" do |v|
          
          ## 2.6.1. Memory ##
          ###################   
          v.memory = 8192
          
          ## 2.6.2. cpu ##
          ################    
          v.cpus = 2
          
          ## 2.6.3. Enable vagrant GUI (for debugging) ##
          ###############################################
          # v.gui = true
          
        end  
        
        ###############################################################################
        ## 2.7. Configure the timeout for the virtual machine (1000 seconds default) ##
        ###############################################################################   
        config.vm.boot_timeout = 1000
        
        #####################################
        ## 2.n. Сообщение после vagrant up ##
        #####################################
        config.vm.post_up_message = "Virtual machine is ready to work!"
      
    end

  • Образец bootstrap.sh

    #!/usr/bin/env bash

    # Установить git
    sudo apt-get update && sudo apt-get install -y \

      git \
      jq

    # Установить docker
    curl -sSL https://get.docker.com/ | sh

    # Установить docker-compose
    curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose

    # Настроить PS1 prompt
    sed -i -e '$aPS1='\''\\s->\\W\\$ '\' /home/vagrant/.bashrc

    # Создать группу docker и добавить в неё пользователя vagrant
    sudo usermod -aG docker vagrant

  • Образец .gitignore

    .vagrant

  • Образец README.md

    # Vagrant box, ubuntu 16.04, docker and docker compose
    ---
    ## Оглавление

      - [Ссылки](#link1)
      - [Описание](#link2)

    ---

    ## Ссылки <a id="link1"></a>
    ```

      > Address
          https://gitlab.manveloff.ru/general/vagrant.git

          
    ```
    ## Описание <a id="link2"></a>
    ```

      Общее описание
      - Это box для vagrant для локальной разработки проектов под брендом manveloff.
      - Cодержит Ubuntu 16.04 и установленные docker и docker compose.
      - Работает как на Windows, так и на MacOS.
      
      Настройка проброса папок
      - В box необходимо пробрасывать папку с проектом с машины-хоста, её надо настроить.
      - Это делается в файле Vagrantfile, в разделе "1. Configure folders to share via NFS".
      
    ```  

А2. Подключение диска ВМ к windows в виде тома
-------------------------------------

  # Постановка задачи
  # Пошаговая инструкция

-------------------------------------

> Постановка задачи

  После каждого запуска ВМ, чтобы разработка с хост-машины
  была возможна, необходимо монтировать файловую систему
  виртуальной машины с ubuntu на windows в виде нового
  тома Z:

> Пошаговая инструкция

  1. Скачать и установить программу SFTP Net Drive.
  2. Настроить в ней новый профиль:

    server:     127.0.0.1:2222
    username:   root
    password:   root

  3. Зайти в advanced

    Выбрать вкладку drive.
    Там для "Root folder on the Server" выбрать 
    "Specified folder", и указать "/". Нажать OK.

  4. Нажать connect

    Должно произойти подключение, и новый том откроется
    в проводнике в новом окне.


А3. Подготовка каталога проекта в ВМ к разработке
-------------------------------------

  # Постановка задачи
  # Пошаговая инструкция

-------------------------------------

> Постановка задачи

  Необходимо подготовить каталог проекта, его структуру,
  в файловой структуре ВМ.

> Пошаговая инструкция

  1. Запустите ВМ и смонтируйте её ФС на хост.
  2. Подготовьте в любом месте смонтированной ФС папку для проекта:

    Например: /manveloff/cleaning

  3. Создайте файловую структуру проекта в этой папке:
  
    docs/
    env/
      docker/
        app/
        mysql/
        redis/
        nodejs/
      vagrant/
    other/
      production/
        backups/
        data/
        dumps/
        https/
        logs/
        secrets/
        storage/
      workbench/
    project/
  
  
А4. Настроить терминальный доступ к docker registry на gitlab
-------------------------------------

  # Постановка задачи
  # Пошаговая инструкция

-------------------------------------

> Постановка задачи

  Мои проекты используют Docker-образы, которые обычно лежат
  в Docker-реестре в GitLab. Но необходимо, чтобы новый проект 
  имел доступ к образам. Доступ надо настроить через 
  .bashrc для root.

> Пошаговая инструкция

  1. Сначала надо создать personal access token

    Идём в settings профиля.
    Там в Access Tokens.
    Создаём новый токен с 2-мя scope'ами: "read_repository", "read_registry".
    Второй может быть недоступен, пока не настроен docker registry.
    Записываем его в project/other/secrets/docker/credentials.json, 
    т.к. потом доступа к нему не будет.

  2. Добавляем строку входа в /root/.bashrc

    Запускаем ВМ.
    Редактируем .bashrc:

      sudo nano /root/.bashrc

    В конце добавляем строки:

      # Login to the GitLab Docker registry
      docker login <адрес>:<порт> -u <login> -p <personal access token>

    Адрес и порт можно посмотреть, открыв проект на gitlab, 
    и там зайдя в Registry.

    Логин используйте тот же, для которого создавался 
    personal access token.


А5. Установка моего стартового Laravel-проекта
-------------------------------------

  # Постановка задачи
  # Пошаговая инструкция

-------------------------------------

> Постановка задачи

  Чаще всего новый проект стартуют не с нуля, а используют
  либо какую-то заготовку под стартовый проект, либо 
  просто клонируют предыдущий проект, и настраивают
  его под новый.

  Я разрабатываю Laravel-проекты, и после клонирования
  такого-проекта требуется выполнить кое-какие действия.

> Пошаговая инструкция

  1. Перейти в каталог проекта.
  2. Установить composer-зависимости

    composer install

  3. Установить npm зависимости

    npm install

  4. Собрать фронтенд для dev

    npm run development

  5. Изменить права для папки storage

    sudo chmod -R 777 storage

  6. Создать папку other/logs/security

    sudo mkdir other/logs/security
    sudo chmod -R 777 other/logs

  7. Создать и заселить базу данных

    artisan migrate:refresh --seed --force
    artisan vendor:publish --tag=extensions --force


А6. Настройка SSH-подключения только через ключи к VDS-серверу
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  # Хороший туториал по теме
      https://www.8host.com/blog/ssh-klyuchi-dlya-podklyucheniya-vps-s-pomoshhyu-putty/

> Введение

  Когда покупаешь новый виртуальный сервер, первым делом
  необходимо обезопасить его от взлома, и настроить
  подключение только через ssh-ключи, отключив возможность
  входа через пароль.

  - Каждый раз вводить пароль для подключения к VDS через SSH надоедает.
  - Кроме того, подключаться к базе данных через пароль небезопасно.
  - Поэтому, лучше организовать подключение через SSH-ключ.
  - В этой главе дана пошагавая инструкция, как это сделать.

> Пошаговая инструкция

  1. Перейти в папку, куда хочешь сохранить пару SSH-ключей

    Например: 
      Z:\bubbles\other\production\secrets\ssh\dev

  2. Создай пару SSH-ключей на своём локальном Linux
    - Введи команду:

      ssh-keygen -t rsa

    - Он спросит, куда сохранить: id_rsa
    - Pass Phrase оставить пустой.
    - Проверить, что ключи создались: ls

  3. Создай Putty-версию (.ppk) приватного ключа
    - Открой программу PuTTY Key Generator (puttygen.exe).
    - File -> Load private key.
    - Справа снизу кнопка "Save private key".

  4. Запиши созданный public-ключ в authorized_keys удалённого сервера
    - Введи пароль, когда попросит.

      ssh-copy-id -i id_rsa.pub root@185.58.205.88

  5. Подключись к серверу по паролю, и проверь
    - Что появился файл authorized_keys.

      ssh root@185.58.205.88
      sudo nano ~/.ssh/authorized_keys

  6. Деактивируй возможность подключаться к серверу через логин/пароль
    - Открой программу WinSCP и подключись к серверу.
    - Открой файл /etc/ssh/sshd_config (не перепутай с ssh_config).
    - Отредактируй там следующим образом следующие св-ва:

        PasswordAuthentication no
        UsePAM no

    - Затем выполни на сервере команду:

        sudo reload ssh         | ubuntu 14.04
        service ssh restart     | ubuntu 16.04

  7. Проверь, работает ли подключение по SSH по ключу

    ssh -i id_rsa root@185.58.205.88

  8. [При использовании WinSCP] В настройках WinSCP не забудь указать ключ вместо пароля
    - После пункта #5 ты уже не сможешь подключаться по логину/паролю.
    - Поэтому, отредактируй подключение в WinSCP, указав приватный ключ.
    - Для WinSCP понадобится putty-версия приватного ключа, но 
      последние версии WinSCP сами создают putty-версию при попытке
      назнаичть не putty-версию.


А7. Связать домен с сервером, настроить поддомен, сделать переадресацию
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговые инструкции
  # Примечания
    ▪ CNAME при переадресации не меняет URL в строке браузера
    ▪ Обязательно пропишите ipv6 (АААА-записи) для домена

--------------------------------------

> Ссылки

  • Как привязать домен к хостингу?
      https://www.reg.ru/support/hosting-i-servery/sajty-i-domeny/kak-nastroit-dns/kak-privyazat-domen-k-hostingu

  • Как привязать домен к стороннему хостингу?
      https://www.reg.ru/support/domains/dns_servery_i_nastroika_zony/DNS-servery/kak-privyazat-domen-k-storonnemu-hostingu

  • Как создать поддомен?
      https://www.reg.ru/support/hosting-i-servery/sajty-i-domeny/kak-dobavit-novy-domen-poddomen-psevdonim/kak-dobavit-poddomen

  • Что такое «Ресурсные записи DNS»
      https://www.reg.ru/support/domains/dns_servery_i_nastroika_zony/Nastroika-zony/chto-takoe-resursnye-zapisi-dns

> Введение

  В любом новом проекте вам понадобится связать домен
  с IP-адресом сервера. Также, часто требуется создать
  поддомен.

> Ситуация-пример для рассмотрения в этой главе

  • Есть такие домены и поддомены

    manveloff.com
    manveloff.ru
    cleaning.manveloff.ru
    gitlab.manveloff.ru

  • Что надо сделать

    1. Переадресацию 301 с .com на .ru

      Чтобы с manveloff.com и любых поддоменов запрос
      переадресовывался на manveloff.ru и соответствующий
      поддомен.

      Примеры:

        manveloff.com           -->  manveloff.ru
        gitlab.manveloff.com    -->  gitlab.manveloff.ru
        cleaning.manveloff.com  -->  cleaning.manveloff.ru
        abcde.manveloff.com     -->  abcde.manveloff.ru

    2. Переадресации c www. на без www.
    3. Связать gitlab.manveloff.ru с gitlab-сервером.
    4. Связать cleaning.manveloff.ru с клининговым сервером.
    5. Связать manveloff.ru с тем же клининговым сервером.

      Идея состоит в том, чтобы просто-напросто в роутинге
      Laravel прописать разные роуты для доменов manveloff.ru,
      и cleaning.manveloff.ru.

      Если домен manveloff.ru, то используется набор роутов
      для моего личного сайта.

      Если домен cleaning.manveloff.ru, то используется набор
      роутов для клинингового агрегатора.

> Пошаговые инструкции

  1. Используем бесплатные DNS-сервера регистратора домена

    Выполняем следующее для каждого домена 
    (manveloff.com, manveloff.ru).

    Заходим на сайт регистратора домена, в панель управления.

    Там заходим в раздел "DNS-серверы", и устанавливаем
    для домена бесплатные DNS-серверы регистратора.

  2. Настраиваем ресурсные записи DNS

    Заходим на сайт регистратора домена, в панель управления.
    Открываем "Управление зоной".

    • Для домена manveloff.com 
    
      КЛАСС   ПОДДОМЕН    ДОМЕН           ЗНАЧЕНИЕ
      --------------------------------------------
      NS      @           manveloff.com   ns1.reg.ru.
      NS      @           manveloff.com   ns2.reg.ru.
      CNAME   www         manveloff.com   manveloff.ru
      CNAME   gitlab      manveloff.com   gitlab.manveloff.ru
      CNAME   cleaning    manveloff.com   cleaning.manveloff.ru
      CNAME   *           manveloff.com   cleaning.manveloff.ru
    
    • Для домена manveloff.ru

      КЛАСС   ПОДДОМЕН    ДОМЕН           ЗНАЧЕНИЕ
      --------------------------------------------
      NS      @           manveloff.ru    ns1.reg.ru.
      NS      @           manveloff.ru    ns2.reg.ru.
      CNAME   www         manveloff.ru    manveloff.ru
      CNAME   *           manveloff.ru    cleaning.manveloff.ru
      A       @           manveloff.ru    <ip клинингового сервера>
      AAAA    @           manveloff.ru    <ipv6 клинингового сервера>
      A       gitlab      manveloff.ru    <ip сервера с гитлабом>
      AAAA    gitlab      manveloff.ru    <ipv6 сервера с гитлабом>
      A       cleaning    manveloff.ru    <ip клинингового сервера>

> Примечания

  • CNAME при переадресации не меняет URL в строке браузера

    То есть, он, конечно, загружает указанную страницу.
    Но при этом, в строке браузера остаётся старый URL.

    Короче говоря, переадресацию надо делать через
    nginx.

  • Обязательно пропишите ipv6 (АААА-записи) для домена

    Потому что многие сервисы, например, certbot 
    используют именно ipv6. Соответственно, если
    его не прописать, будут проблемы.

    В ihor посмотреть ipv6 для своего сервера (их дают 4),
    можно в "Виртуальные серверы", выделив нужный сервер,
    и нажам "IP адреса".


А8. Настроить IPv6 на сервере
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  • Официальная инструкция от Ihor по настройке IPv6 на Ubuntu
      https://wiki.ihor.ru/linux:debian:как_добавить_ip-адрес

  • Разжёвывание на wiki.archlinux.org
      https://wiki.archlinux.org/index.php/Certbot_(Русский)

> Введение

  В главе А7 мы, помимо всего прочего, связали ваши 
  доменные имена с IPv6 вашего сервера.

  Однако, если у вас сервер на ihor, то вам потребуется 
  вручную настроить IPv6 на этом сервере, поскольку
  автоматически там ничего не настроена.

  Многие сервисы, например, certbot используют именно ipv6. 
  Соответственно, если его не прописать, будут проблемы.

  В ihor посмотреть ipv6 для своего сервера (их дают 4),
  а также шлюзы для них,можно в "Виртуальные серверы", 
  выделив нужный сервер, и нажам "IP адреса".

> Пошаговая инструкция

  1. Подготовьте IPv6-адрес и шлюзы от вашего сервера.
  2. Подключитесь к вашему серверу через SSH.
  3. Откройте файл /etc/network/interfaces в редакторе:

    sudo nano /etc/network/interfaces

  4. Добавьте туда такую штуку, заменив 
     <ipv6> и <шлюз> на актуальные значения:

    iface ens3 inet6 static
            address <ipv6>
            netmask 64
            gateway <шлюз>
            dns-nameservers 2001:4860:4860::8888 2001:4860:4860::8844  

  5. Перезагрузите сервер

    reboot

  6. Убедитесь, что домен вашего сервера пингуется через ping6

    Чтобы протестировать доступность вашего домена по ipv6,
    используйте linux-утилиту ping6. Установите её на
    свою ВМ, например:

      sudo apt-get install iputils-ping

    Проверьте работоспособность утилиты на google:

      ping6 ipv6.google.com

    и проверьте, есть ли пинг по ipv6 с вашим GitLab-доменом:

      ping6 http://<ваш GitLab-домен>


А9. Установка, настройка GitLab EE, загрузка лицензии
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  • Официальная инструкция по устаноке GitLab Omnibus
      https://about.gitlab.com/installation/#ubuntu

  • Активация лицензии
      https://docs.gitlab.com/ee/user/admin_area/license.html

> Введение

  В наше время (2018 год), многие проекты, в том числе мои,
  используют GitLab. Наиболее популярная версия, наверное,
  это GitLab EE за 4$/месяц с человека. Рассмотрим здесь,
  как её установить и настроить.

> Пошаговая инструкция

  1. Подключитесь к вашему серверу, куда хотите установить gitlab

    Желательно, чтобы кроме gitlab на этом сервере ничего
    другого не было.

  2. Установите gitlab
  
    sudo apt-get update
    sudo apt-get install -y curl openssh-server ca-certificates
    sudo apt-get install -y postfix
    curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash

    В следующей строке замените <domain> на домен, где будет
    лежать ваш gitlab. Например, "gitlab.example.com"

    sudo EXTERNAL_URL="http://<domain>" apt-get install gitlab-ee

  3. Установите пароль для администратора

    Откройте установленный GitLab в браузере, 
    так как это будет первое посещение,
    он попросит установить пароль для администратора.

  4. Активируйте лицензию

    Используя логин root и установленный для него пароль,
    войтиде в GitLab, как администратор.

    Перейдите в Admin Area, нажав на значок гаечного
    ключа в верхнем меню.

    Затем, в меню слева, нажмите на Licence. Справа-сверху
    нажмите кнопку "Upload new licence".

    Выберите файл с лицензией (он приходит по email после
    покупки), и загрузите его.

  5. Добавьте нового пользователя (себя)

    В Admin Area откройте Overview -> Users,
    и создайте для себя нового пользователя
    с правами администратора.

    После создания вы получите письмо со ссылкой
    на указанный email, по которой сможете
    установить пароль.


А10. Организация работы с git'ом на GitLab через SSH-ключи
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  • Официальная инструкция в документации gitlab
      https://docs.gitlab.com/ce/ssh/README.html

> Введение

  Если не организовать работу с git'ом на GitLab через
  SSH-ключи, то при каждом обращении к git'у придётся
  вводить свой пароль, что конкретно напрягает. Поэтому,
  в этой главе я описываю, как таки организовать оную.
  
> Пошаговая инструкция
  
  1. Перейти в папку, куда хочешь сохранить пару SSH-ключей.

  2. Создай пару SSH-ключей на своём локальном Linux
    - Введи команду:

      ssh-keygen -t rsa

    - Он спросит, куда сохранить: id_rsa
    - Pass Phrase оставить пустой.
    - Проверить, что ключи создались: ls
  
  3. Создай Putty-версию (.ppk) приватного ключа
    - Открой программу PuTTY Key Generator (puttygen.exe).
    - File -> Load private key.
    - Справа снизу кнопка "Save private key".

  4. Измени права доступа на папку с ключами на 400
    - Иначе может вонникнуть ошибка "permissions are too open".
    - Для этого выполни следующую команду:

      sudo chmod -R 400 <путь к папке с ключами>

  5. Добавление ssh ключей в ssh-агент вашей системы
    - Подключитесь к вашей ВМ на Linux через SSH.
    - Откройте .bashrc для пользователя root:

      sudo nano /root/.bashrc

    - В конец добавьте следующие строки
      (только замените <путь к private ssh key> на оный):

      # Start ssh-agent and add SSH-key from GitLab's git
      eval $(ssh-agent -s) && ssh-add <путь к private ssh key>
      
  6. Добавление публичного ssh ключа у себя в настройках в GitLab
    - Заходим в GitLab через свой аккаунт.
    - Идём в: user settings -> SSH keys.
    - Через консоль копируем public ssh ключ в буфер обмена:
      Linux: cat <путь к public ssh key>
    - Вставляем его в поле key в gitlab, пишем title, нажимаем add key.

  7. Замена http/https ссылки на origin, на git-ссылку
    - Идём в папку с проектом. Открываем .git/config.
    - Проверяем блок remote "origin", url.
    - Если там стоит http/https ссылка вида:

      https://gitlab.bubbles.pro/bubbles/mvp.git

    - Меняем её на git-ссылку вида:

      git@gitlab.bubbles.pro:bubbles/mvp.git

    - Благодаря этому git перестанет запрашивать пароль, и начнёт использовать ssh-ключ.    

  8. Профилактика ошибки "User git not allowed because account is locked"
    - Подключение через SSH не работает, если gitlab установлен на ubuntu.
    - В tail -f /var/log/auth.log на gitlab-сервере мы видим User git not allowed because account is locked.
    - Чтобы это решить, надо на gitlab-сервере удалить пароль для пользователя git, для этого: 

      sudo passwd -d git

  9. Проверяем, что всё работает
    - Не забываем перезапустить консоль, чтобы изменения
      из .bashrc применились.
    - Вводим команду: 

      ssh -T git@<домен вашего gitlab'а>
      ssh -T git@gitlab.manveloff.ru       | пример

    - Отвечаем на вопрос: yes и нажимаем enter
    - Если всё ОК, должна появиться надпись: "Welcome to GitLab, <username>!"


А11. Создание нового проекта на GitLab, организация git-репозитория
--------------------------------------
Подоглавление:

  # Введение
  # Пошаговая инструкция

--------------------------------------

> Введение

  В этой главе я описал, как создать новый проект на 
  GitLab с git-репозиторием, как создать локальный 
  git-репозиторий, и как организовать связь между
  ними.
  
> Пошаговая инструкция

  1. Войдите в GitLab под своим аккаунтом.
  2. Если необходимо, создайте новую группу

    Группа представляет коллекцию N проектов.
    Она позволит объединить несколько проектов
    в данной группе, которая будет фигурировать
    в URL проекта по принципу:

      gitlab.domain.com/<имя группы>

    Не забудьте в поле "Description" описать группу.

  3. Создайте новый проект в группе
    - Создав группу, создайте новый проект.
    - Для этого нажмите "Create project".
    - В поле "Project path" выберите вашу группу
    - В поле "Project name" введите имя проекта.
    - В поле "Description" опишите ваш проект.
    - Поставьте галочку "Initialize repository with a README".
    - Нажмите кнопку "Create project".

    URL проекта будет выглядеть примерно так:

      gitlab.domain.com/<имя группы>/<имя проекта>

  4. Связать локальный репозиторий с удалённым
    - Для этого перейти в каталог локального репозитория.
    - И выполнить команду:

      git remote add origin [адрес удал.репо]

    - Например:

      git remote add origin git@gitlab.manveloff.ru:cleaning/site.git

    - Убедитесь, что связи добавились:

      git remote -v

    *Внимание:

      [адрес удал.репо] должен быть в формате git@... ,
      а не https://...

      Иначе, аутентификация через SSH-ключ не будет работать,
      и система будет требовать ввода пароля.

  5. Заполните поля о себе в локальном репозитории
    - Выполните следующие команды (подставьте свои имя и email):

      git config --global user.name "Your Name"
      git config --global user.email "you@example.com"

  6. Выполните push вашего проекта в удалённый репозиторий
    - Если надо, внесите изменения в проект.
    - Выполните следующие команды в папке проекта:

      git add -A
      git commit -m "initial push"
      git pull origin master
      (здесь исправить конфликты, если есть)
      git push origin master


А12. Защита ветки master от прямой записи на GitLab
--------------------------------------
Подоглавление:

  # Введение
  # Пошаговая инструкция

--------------------------------------

> Введение

  Ветку master на GitLab необходимо защитить от прямых
  merge'ей, иначе какой-нибудь дебил что-нибудь с ней
  сделает, что может уничтожить проект.
  Все merge'ы должны проходить через merge request'ы.
  
  С определённой версии GitLab, ветка master защищена
  по умолчанию, и ничего дополнительно делать не нужно.
  Но убедиться, что это так, всё равно следует.
  
> Пошаговая инструкция

  1. Войдите в GitLab под своим логином.
  2. Откройте проект, чью ветку master хотите защитить.
  3. Перейдите в Settings -> Repository.
  4. Раскройте раздел "Protected Branches".
  5. Там выберите Branch: master, и нажмите Protect.


А13. Настройка HTTPS на GitLab
--------------------------------------
Подоглавление:

  # Введение
  # Пошаговая инструкция

--------------------------------------

> Введение

  В целях безопасности следует настроить HTTPS для
  GitLab. В этой главе описано, как это сделать.
  
> Пошаговая инструкция
  
  1. Убедитесь, что IPv6 для вашего домена/сервера настроен

    См.главу А8.

  2. Подключитесь к серверу с GitLab через ssh.
  3. Устанавливаем certbot

    sudo apt-get update
    sudo apt-get install software-properties-common
    sudo add-apt-repository ppa:certbot/certbot
    sudo apt-get update
    sudo apt-get install certbot

  4. Готовим папку для сертификатов

    sudo mkdir -p /var/www/letsencrypt

  5. Прописываем custom_gitlab_server_config в конфиг GitLab

    Открываем:

      sudo nano /etc/gitlab/gitlab.rb

    Редактируем (заменим <gitlab-домен> на оный):

      nginx['custom_gitlab_server_config'] = "location ^~ /.well-known { root /var/www/letsencrypt; }"
  
    Выполняем:

      sudo gitlab-ctl reconfigure

  6. Запрашиваем сертификат

    Внимание! После нескольких неудачных запросов,
    certbot банит вас на неделю. Так что, перед тем, 
    как выполнять реальный запросы, сначала потренируйтесь.

    Выполняем следующую команду. На вопрос отвечаем 
    "сохранить файлы", пункт 2. Не забываем подставить
    вместо <домен с gitlab> оный:

    ▪ Тренировка (с --test-cert и --dry-run)

      sudo certbot certonly --test-cert --dry-run --webroot-path=/var/www/letsencrypt -d <домен с gitlab>

    ▪ Реальный запрос (без --test-cert и --dry-run)

      sudo certbot certonly --webroot-path=/var/www/letsencrypt -d <домен с gitlab>

  7. Прописываем сертификаты и http->https переадресацию в конфиг GitLab

    Открываем:

      sudo nano /etc/gitlab/gitlab.rb

    Редактируем (заменим <gitlab-домен> на оный):

      external_url 'https://<домен с gitlab, например, gitlab.bubbles.pro>'
      nginx['redirect_http_to_https'] = true
      nginx['ssl_certificate'] = "/etc/letsencrypt/live/<gitlab-домен>/fullchain.pem"
      nginx['ssl_certificate_key'] = "/etc/letsencrypt/live/<gitlab-домен>/privkey.pem"
  
    Выполняем:

      sudo gitlab-ctl reconfigure

  8. Проверяем, что GitLab заработал через HTTPS, и переадресация работает

    Открываем в браузере:

      http://<ваш GitLab-домен>

    Вы должны попасть сюда, и GitLab должен открыться:

      https://<ваш GitLab-домен>

  9. Настройка автообновления

    При установке Certbot на Ubuntu 16.04 и старше,
    автоматически создаётся файл:

      /etc/cron.d/certbot

    По идее, это и есть автоматическое обновление
    сертификатов. То есть, что-то дополнительно
    делать вроде как не надо (но это не точно).


А14. Настройка Docker Container Registry
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  • Официальная документация по Gitlab Docker Container Registry
      https://docs.gitlab.com/ce/user/project/container_registry.html

> Введение

  Мои проекты используют Docker-контейнеры для работы.
  Удобнее всего хранить образы для этих контейнеров
  в собственном Docker-реестре. Такой реестр можно
  поднять на GitLab, в этой главе описано, как.
  
  Лучше использовать тот же домен, что для GitLab,
  но с другим портом. Это позволит использовать тот
  же TLS-сертификать (и не делать отдельный).
  
  Допустим, наша задача состоит в том, чтобы поднять
  реестр на том же сервере, где и у нас работает
  GitLab, на порту 4567.

> Пошаговая инструкция

  1. Указать домен для DCR, и путь к tls-сертификату и его ключу
    - Подключаемся к VPS с gitlab по ssh и открываем конфиг в nano:

      sudo nano /etc/gitlab/gitlab.rb

    - Указываем url и порт для DCR, адрес tls-сертификата и ключа от него
      (заменив везде <gitlab домен> на оный)

      registry_external_url 'https://<gitlab домен>:4567'
      registry_nginx['ssl_certificate'] = "/etc/letsencrypt/live/<gitlab домен>/fullchain.pem"
      registry_nginx['ssl_certificate_key'] = "/etc/letsencrypt/live/<gitlab домен>/privkey.pem"

  2. Проверить, что DCR в настройках GitLab включено

    Открываем GitLab, логинимся под своим аккаунтом.
    Идём в: 

      settings -> general -> permitions -> repository -> container registery.

    И проверяем, что Container registry включено.

  n. Перезапускаем gitlab, чтобы он всосал новые настройки:

    sudo gitlab-ctl reconfigure


А15. Подготовка, сборка и загрузка Docker-образов в DCR
--------------------------------------
Подоглавление:

  # Введение
  # Пошаговая инструкция

--------------------------------------

> Введение

  Мои проекты используют Docker-контейнеры для работы.
  Удобнее всего хранить образы для этих контейнеров
  в собственном Docker-реестре. 

  Как поднять такой реестр, я описал в главе А14.
  Теперь же настало время рассказать, как подготовить,
  собрать и загрузить туда Docker-образы проекта.

  В этой главе не описывается в деталях внутреннее
  устройство Docker-образов, а лишь описывается
  их сборка и загрузка в реестр.

> Пошаговая инструкция

  1. Залогиниться в DCR

    С любой Linux-машины введите (заменив <gitlab domain>
    и <port> на оные):

      docker login <gitlab domain>:<port>
      docker login gitlab.bubbles.pro:4567    | например  

  2. Собрать docker-образ

    Перейдите в каталог с образом.
    GitLab поддерживает 3 вида шаблонов:

      <registry URL>/<namespace>/<project>:<tag>  
      <registry URL>/<namespace>/<project>/<[optional]image name>:<tag>  
      <registry URL>/<namespace>/<project>/<[o]name>/<[o]image name>:<tag> 

    Например, для сборки образа для redis введите:

      docker build -t gitlab.bubbles.pro:4567/bubbles/mvp/redis .

  3. Опубликовать собранный образ

    Например:

      docker push gitlab.bubbles.pro:4567/bubbles/mvp/redis

  4. Если вы стартовали новый проект из другого, перепропишите образы

    Часто мы начинаем новый проект, просто скопировав
    старый. Если это так, не забудьте перепрописать
    в docker compose новые образы.


А16. Настройка CI/CD и runner'ов для проекта
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  • Регистрация runner'ов в GitLab
      https://docs.gitlab.com/runner/register/index.html#gnu-linux

> Введение

  Концепция CI (Continious Integration) / CD (Continious Delivery)
  позволяет реализовать "конвейер" по немедленному тестированию
  и доставке только что закомиченного кода в основную
  кодовую базу.

  GitLab из коробки поддерживает CI/CD, но только его 
  нужно настроить.

  В этой главе описано, как работает CI/CD в GitLab,
  и как его настроить, в том числе настроить так называемые
  runner'ы.

> Как работает CI/CD на GitLab

  • Что мы имеем
    - GitLab на отдельном VPS, установленный через Docker.
    - Приватный git-репозиторий с кодом нашего проекта на GitLab.
    - Файл .gitlab-ci.yml в git-репозитории в корне проекта.
    - Dev-сервер на отдельном VPS, к которому есть доступ.
    - Runner'ы с shell-исполнителем на dev-сервере, подключенные к Gitlab.
    - Конфиг для runner'ов config.toml на dev-сервере.

  • Что происходит
    - Кто-то делает push в git-репозиторий.
    - В GitLab добавляется новая job.
    - Срабатывает runner, подключенный к GitLab. Что он делает:
      
      1. Подтягивает на dev-сервер свежий код из git-репозитория на GitLab.
      2. В bash выполняет команды из файла .gitLab-ci.yml в корне проекта.  
    
    - В .gitlab-ci.yml может быть прописано от 1 и более стадий (stages). 
      А каждая стадия может содержать набор команд для выполнения в bash.
      Примеры стадий: 
      
      - test    | тут прогоняются всякие тесты 
      - deploy  | тут выполняется деплой-скрипт

    - Результаты (плохие или хорошие) возвращаются на GitLab,
      где их и можно наблюдать в разделе CI / CD.
  
  • Runner'ы
    - Их может быть несколько.
    - Для каждой стадии через environments можно указать свой runner.

> Пошаговая инструкция

  1. Подключаемся через SSH к серверу, где мы хотим поднять runner

    Runner'ы нам надо поднимать на тех серверах, где у нас
    будут выполняться различные версии проекта - test,
    dev, prod и т.д.

    Причём, для каждой такой среды следует поднять свой
    отдельный runner.

  2. Установить пакет для runner'ов через apt

    Именно через apt, а не через, например, Docker,
    потому что в оф.образе runner'а прописано запускаться 
    от имени пользователя gitlab-runner, а не root. 
    В результате, почти ничего из команд в jobs не может 
    выполниться без ввода пароля. Изменить это никак нельзя, 
    кроме как созданием своего docker образа. Но проще 
    тогда устанавливать runner из apt, а не через docker.

    Выполняем команды:

      # Добавить оф.репозиторий gitlab
      sudo curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash

      # Установить последнюю версию gitlab runner через apt
      sudo apt-get install gitlab-runner

  3. Дать пользователю gitlab-runner право выполнять sudo без пароля
    - Выполняем: 'sudo visudo'
    - В !!!КОНЕЦ ФАЙЛА!!! дописываем: 

      gitlab-runner    ALL=NOPASSWD: ALL
    
    - Сохраняем, выходим.

  4. Зарегистрировать runner'ы в GitLab
    - Введите команду и начните регистрацию раннера:
    
        sudo gitlab-runner register

        В процесе отвечайте на вопросы, подставляя нужные данные:

        # Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )
          - Ввести URL с gitlab
          - https://<ваш gitlab домен>

        # Please enter the gitlab-ci token for this runner
          - Ввести токен из пункта 2.

        # Please enter the gitlab-ci description for this runner
          "test-runner" или "dev-runner" или "prod-runner" и т.д.

        # Please enter the gitlab-ci tags for this runner (comma separated):
          <пусто>

        # Whether to run untagged jobs [true/false]:  
          true  

        # Whether to lock Runner to current project [true/false]:  
          true  

        # Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:  
          shell

    - Либо, можно одной командой:

      sudo gitlab-runner register \
        --description "test-runner" \
        --tag-list "test" \
        --non-interactive \
        --url "https://<ваш gitlab домен>" \
        --registration-token "<токен>" \
        --executor "shell" \
        --shell "bash" \
        --locked="true" \

    - Не забудьте, что зарегистрировать нужно каждый runner.

  5. Пересобрать runner, чтобы он работал от имени root

    Иначе у него будут проблемы с удалением созданных 
    другими пользователями файлов. Для этого:

      cd /home/gitlab-runner              // Пройти в папку /home/gitlab-runner
      sudo rm -rf builds                  // Удалить папку builds
      sudo gitlab-runner uninstall        // Удалить сервис
      sudo gitlab-runner install -u root  // Установить сервис от имени root
      sudo gitlab-runner start            // Запустить сервис

    При следующем запуске runner'а будет создана папка 
    /home/gitlab-runner/builds

  6. Не забудьте добавить на сервера с runner'ами docker

    # Установить git и jq
    sudo apt-get update && sudo apt-get install -y git jq

    # Установить docker
    curl -sSL https://get.docker.com/ | sh

    # Установить docker-compose
    curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose

    # Создать группу docker и добавить в неё пользователя root
    sudo usermod -aG docker root

  7. Перезагрузите сервер

    Это может понадобиться, чтобы у runner'а появился
    доступ к docker'у.

    reboot

  8. Убедитесь, что runner связан с GitLab и работает

    Залогинтесь в GitLab под своим аккаунтом.
    Войдите в проект.
    Перейдите в: 

      Settings -> CI/CD -> Specific Runners -> Runners activated for this project

    Должен быть виден подключенный runner с зелёным маркером.

  9. Протестируйте работоспособность CI/CD на практике

    Сделайте push и посмотрите, сработает ли runner
    в разделе CI/CD в GitLab вашего проекта.


А17. Настройка HTTPS на prod-сервере с автообновлением
--------------------------------------
Подоглавление:

  # Введение
  # Пошаговая инструкция

--------------------------------------

> Введение

  В целях безопасности следует настроить HTTPS для
  GitLab. В этой главе описано, как это сделать.
  
> Пошаговая инструкция
  
  1. Убедитесь, что IPv6 для вашего домена/сервера настроен

    См.главу А8.

  2. Подключитесь к серверу через ssh.
  3. Устанавливаем certbot

    sudo apt-get update
    sudo apt-get install software-properties-common
    sudo add-apt-repository ppa:certbot/certbot
    sudo apt-get update
    sudo apt-get install certbot

  4. Готовим папку для сертификатов

    sudo mkdir -p /var/www/letsencrypt

  5. В конфиге nginx добавляем примерно такой вот блок

    Его смысл состоит в том, чтобы при получении
    сертификата удалённый сервер certbot'а всегда мог
    по 80-му порту получить доступ к URI: ".well-known",
    где лежит файл для проверки.

    Это необходимо добавить, потому что чаще всего у 
    нас сайт работает через https на 443-м порту,
    а с 80-го мы переадресуем. Так вот, до переадресации
    надо, чтобы срабатывал этот блок.

    server {
      
      listen *:80;
      root <path_to_the_project>/project/public;
      
      location ^~ /.well-known {
        allow all;
        auth_basic off;
        default_type "text/plain";
        try_files $uri =404;
      }  
      
    }  

    *Примачание:

      Будьте внимательны с default_server в listen,
      лучше уберите его, чтобы все servers выполнялись
      в том порядке, в котором они идут.

  6. Пробрасываем .well-known в public в docker-compose для prod

    Чаще всего у нас nginx работает в docker-контейнере.
    Однако, папка .well-known лежит на сервере-хосте для
    этого контейнера по адресу 

      /var/lib/letsencrypt/.well-known

    Но чтобы удалённый сервер certbot'а мог её запросить,
    надо положить её в public проекта, который находится
    в контейнере. Для этого, в файле docker-compose.yml
    требуется пробросить туда эту папку в volumes:

    volumes:
      ...
      /var/lib/letsencrypt/.well-known:<path_to_the_project>/project/public/.well-known
      ...

  7. Запрашиваем сертификат

    Внимание! После нескольких неудачных запросов,
    certbot банит вас на неделю. Так что, перед тем, 
    как выполнять реальный запросы, сначала потренируйтесь.

    Выполняем следующую команду. На вопрос отвечаем 
    "сохранить файлы", пункт 2. Не забываем подставить
    вместо <домен#> оные (если у вас домен и поддомены,
    надо все добавить, в стиле: -d <домен1> -d <домен2> ...):

    ▪ Тренировка (с --test-cert и --dry-run)

      sudo certbot certonly --test-cert --dry-run --webroot-path=/var/www/letsencrypt -d <домен1> -d <домен2>

    ▪ Реальный запрос (без --test-cert и --dry-run)

      sudo certbot certonly --webroot-path=/var/www/letsencrypt -d <домен1> -d <домен2>

  8. Прописывае сертификаты в nginx-конфиг для production

    listen *:443 ssl;  # вместо listen *:80;

    ssl_certificate     /etc/letsencrypt/live/<домен>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<домен>/privkey.pem;    

  9. Организуем в nginx-конфиге переадресацию 80 -> 443 порт

    Этот блок требуется установить ПОСЛЕ блока из 
    пункта №5, обеспечивающего доступ к .well-known
    через 80-й порт.

    server {
      listen 80;
      server_name _;
      return 301 https://$host$request_uri;
    }  

  10. Настройка автообновления

    При установке Certbot на Ubuntu 16.04 и старше,
    автоматически создаётся файл:

      /etc/cron.d/certbot

    По идее, это и есть автоматическое обновление
    сертификатов. То есть, что-то дополнительно
    делать вроде как не надо (но это не точно).



