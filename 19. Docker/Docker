////==================================================////
////                                                  ////
////                      Docker                      ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Официальный сайт Docker
        https://www.docker.com/

    # Оф.панель управления и хаб Docker
        https://hub.docker.com/

    # Серия оф.вводных видео-тренингов по Docker
        https://training.docker.com/self-paced-training

    # Официальная документация Docker
        https://docs.docker.com/

  // Видео //
  //-------//

    # Плейлист от LearnCode по базовым принципам Docker
        https://www.youtube.com/playlist?list=PLoYCgNOIyGAAzevEST2qm2Xbe3aeLFvLc

  // Текст //
  //-------//

    # 350+ полезных статей про Docker
        https://habrahabr.ru/company/1cloud/blog/275015/

    # Docker for PHP Developers
    # - Efficient Nginx, PHP, and MySQL development environments with Docker
    # - Подробнейшая, потрясающая статья про Docker from JOSH LOCKHART
        http://www.newmediacampaigns.com/blog/docker-for-php-developers

    # Laravel 5 with dockerized Gulp, PHP-FPM, MySQL and nginx
    # Краткий how-to
        http://harshjv.github.io/blog/laravel-5-with-dockerized-gulp-php-fpm-mysql-and-nginx/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Docker

    А1. Архитектура Docker
    А2. Установка Docker
    А3. Запуск приложений в Docker-контейнерах
    А4. Создание собственных Docker-образов
    А5. Работа с Docker Machines
    А6. Объединение контейнеров в сеть
    А7. Управление данными в/между контейнерами
    А8. Сборка образов из DockerFile и контекста

  # Б.  Рецепты и наработки

    Б1. ...







////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Архитектура Docker

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Что такое Docker

      - Вводная информация
      - Изолированные контейнеры

    # Как можно использовать Docker

      - Быстрая разработка приложений
      - Лёгкое разворачивание и масштабирование
      - Более эффективное использование серверного железа

    # Главные компоненты Docker
    # Клиент-серверная архитектура Docker

      - Клиент-серверная
      - Иллюстрация
      - Подробнее о сервере и клиенте

    # Образы, контейнеры, репозиторий

      - Docker-образы
      - Docker-контейнеры
      - Docker-репозиторий

    # Как работает Docker

      - Вводная информация
      - Как работают Docker-образы, ФС union

        - Слои: вводная информация
        - Слои: причина быстрой работы Docker
        - Каждый Docker-образ наследует от некого базового образа
        - Инструкции для создания образов, DockerFile

      - Как работает Docker-репозиторий
      - Как работают Docker-контейнеры
      - Что происходит при run контейнера

    # Важный функционал ядра Linux, используемый Docker

      - Docker написан на Go
      - Namespaces
      - Control groups
      - Union file systems
      - Container forman

  --------------------------------------

  > Ссылки

    # Оф.статья "Understand the architecture"
        https://docs.docker.com/engine/understanding-docker/

  > Введение
    - В этой главе описана архитектура Docker.
    - Её прочтение должно сформировать чёткое представление об оной.

  > Что такое Docker

    # Вводная информация
      - Открытая платформа для разработки, доставки и запуска приложений.
      - Он позволяет отделить приложение от инфраструктуры.
      - И рассматривать последнюю, как управляемое отдельное приложение.
      - Docker сокращает цикл между написанием/использованием кода,
        и позволяет быстрее:

          # Разрабатывать
          # Тестировать
          # Разворачивать

      - Что позволяет Docker'у обеспечивать подобные преимущества:

          # Использование технологий контейнеризации ядра Linux
          # Наличие инструментов ускорения рабочего процесса, позволяющих
            удобно и быстро управлять приложением, и разворачивать его

    # Изолированные контейнеры
      - Docker позволяет запускать почти любое приложение в контейнере.
      - При этом приложение надёжно изолировано от других контейнеров.
      - Изоляция и безопасность позволяют запускать N контейнеров на 1 хосте.
      - Контейнеры же очень легковесны, ведь они не отягощены гипервизорами.
      - Легковесность контейнеров позволяют получать больше от серверного железа.
      - Примеры того, для чего можно использовать контейнеры:

          # Размещать в них приложения/компоненты
          # Передавать контейнеры членам команды для дальнейшей разработки/тестирования
          # Разворачивать приложения на продакшн-серверах: в датацентрах/облаках

  > Как можно использовать Docker

    # Быстрая разработка приложений
      - Docker является отличным инструментом для улучшения процесса разработки.
      - Команда разработчиков может собрать среду приложения локально из контейнеров.
      - Все члены команды при этом используют на 100% гарантированно идентичную среду.
      - Когда придёт время развернуть приложение, можно использовать эту же самую среду.

    # Лёгкое разворачивание и масштабирование
      - Docker-контейнеры по природе своей очень портативны.
      - Их можно запускать на localhost/в дата-центре/в облаке/на виртуалке/и т.д.
      - Портативность и легковесность контейнеров позволяют легко балансировать нагрузку.
      - С учётом всего этого, скорость работы Docker м.б. близка к realtime.

    # Более эффективное использование серверного железа
      - Docker является более эффективной альтернативой виртуальным машинам.
      - Имея в виду, что Docker потребляет намного меньше ресурсов.
      - Особенно ярко это проявляется при применении на забитом до отказа сервере.

  > Главные компоненты Docker
    - Docker состоит из 2-ух главных компонентов:

      # Docker
        - Платформа для контейнеризации с открытым исходным кодом.

      # Docker Hub
        - Software-as-a-Service платформа.
        - Она позволяет хранить и управлять Docker-контейнерами.
        - Это как GitHub, но только для Docker-образов.

  > Клиент-серверная архитектура Docker

    # Клиент-серверная
      - В Docker применяется клиент-серверная архитектура:

        # Docker-сервер
          - Это демон, который отвечает за управление Docker-контейнерами.
          - За их создание / работу / перемещение / ... .

        # Docker-клиент
          - Это CLI-приложение для взаимодействие с Docker-сервером.

      - Docker-сервер и Docker-клиент могут работать в 1-й системе.
      - А можно с помощью Docker-клиента управлять удалённым Docker-сервером.
      - Клиент и сервер взаимодействуют через сокеты посредством RESTful API.

    # Иллюстрация

                         |--------------|
                         | Client       | Клиент может находитсья на host-машине.
                         |              | А может вне её, на каком-нибудь другом компе.
                         | docker build | Клиент имеет CLI-API для управления сервером.
                         | docker pull  |
                         | docker run   |
                         |--------------|
                                |
                                |
       |------------------------|----------------|      |---------------------------|
       | DOCKER_HOST            |                |      |  Docker Hub (репозиторий) |
       |                       \|/               |      |                           |
       |    |------------------------------|     |      |      |------------|       |
       |    |         Docker daemon        |----------------   |   Images   |       |
       |    |------------------------------|     |      |  |   |------------|       |
       |                                         |      |  |                        |
       |                                         |      |  |      |------|          |
       |                                         |      |  |      | img1 |          |
       |    |------------|    |------------|     |      |  |      |------|          |
       |    | Containers |    |   Images   |     |      |  |---                     |
       |    |------------|    |------------|     |      |      \->|------|          |
       |                                         |      |         | img2 |          |
       |      |--------|         |------|      -------------------|------|          |
       |      |--------|         | img1 |     /  |      |                           |
       |                         |------|    /   |      |---------------------------|
       |      |--------|                    |    |
       |      |--------|         |------|<--|    |        Это SAAS от создателей Docker.
       |                         | img2 |        |        Репозитогий готовых образов для него.
       |      |--------|         |------|        |        Это как GitHub, но только для Docker-образов.
       |      |--------|                         |        Сервер их может отсюда подтягивать.
       |                                         |        А может их сюда и загружать.
       |-----------------------------------------|

         Это host-машина, где запускается Docker-сервер.
         Хост-машиной всегда должен быть именно Linux.


    # Подробнее о сервере и клиенте

      ## Docker-сервер (демон)
        - Docker-сервер запускается на host-машине.
        - Пользователь напрямую не взаимодействует с ним прямо.
        - А взаимодействует чере CLI Docker-клиента.

      ## Docker-клиент
        - Представляет из себя CLI-приложение.
        - Это основной интерфейс для взаимодействия с Docker-сервером.

  > Образы, контейнеры, репозиторий

    # Docker-образы
      - Представляют из себя read-only шаблоны.
      - Например, образ может содержать Ubuntu + Nginx.
      - Образы используются для создания контейнеров.
      - Можно применить метафору: образ - класс, контейнер - объект.
      - Образы можно создавать / обновлять / скачивать с DH / заливать на DH.
      - Docker-образы представляют BUILD-компонент Docker'а.

    # Docker-контейнеры
      - Можно применить метафору: контейнер - каталог.
      - В каждом каталоге необходимые для работы приложения данные.
      - Чтобы приложение заработало, надо собрать вместе эти каталоги.
      - Каждый Docker-контейнер создаётся из Docker-образа.
      - Контейнеры могут быть: run / started / stopped / moved / deleted.
      - Docker-контейнеры представляют RUN-компонент Docker'а.

    # Docker-репозиторий
      - Docker-репозиторий называется Docker Hub.
      - В Docker-репозитории хранятся Docker-образы.
      - Как обычно, есть публичные и приватные репозитории (последние платные).
      - В нём уже существует огромное количество готовых к использованию образов.
      - Можно самому создавать образы, и размещать их в Docker Hub.
      - Docker-репозиторий представляет DISTRIBUTION-компонент Docker'а.

  > Как работает Docker

    # Вводная информация
      - Итак, что мы уже знаем о работе Docker:

        1. Вы можете собирать Docker-образы с вашими приложениями.
        2. Вы можете создавать Docker-контейнеры из Docker-образов,
           и запускать ваши приложения из первых.
        3. Вы можете заливать/скачивать Docker-образы на/с Docker Hub.

      - Рассмотрим работу всех этих компонентов по отдельности и вместе.

    # Как работают Docker-образы, ФС union

      ## Слои: вводная информация
        - Docker-образы представляют из себя read-only шаблоны.
        - Каждый образ состоит из набора слоёв.
        - Docker использует файловую систему union для комбинирования
          всех этих слоёв в единый образ.
        - ФС union умеет комбинировать файлы и каталоги из разных
          файловых систем, называемых ветками по её внутренней терминологии,
          таким образом, что накладываясь друг на друга они образуют
          единую работающую файловую систему.

      ## Слои: причина быстрой работы Docker
        - Одна из главных причин легковесности Docker, это слои.
        - Давайте представим, что вы решили изменить один Docker-образ,
          к примеру, заменить PHP v5.6 на PHP v7.0.
        - Для этого вам потребуется лишь обновить слой, добавляющий PHP в образ,
          но не потребуется полностью пересобирать весь образ, как было бы
          в том случае, если бы вы имеле дело с образом для виртуальной машины.

      ## Каждый Docker-образ наследует от некого базового образа
        - Примеры самых базовых образов: "ubuntu", "fedora".
        - В качестве базового образа может выступать ЛЮБОЙ образ.
        - Docker всегда берёт базовые образы с Docker Hub.

      ## Инструкции для создания образов, DockerFile
        - Представим, вы решили создать собственный образ на базе "ubuntu".
        - Процесс создания представляет процесс накладывания на него новых слоёв.
        - Каждый слой накладывается с помощью отдельной инструкции.
        - Инструкции могут выполнять действия типа:

          ### Запустить команду
          ### Добавить файл или каталог
          ### Создать переменную среды
          ### Указать список процессов к запуску при старте контейнеров из этого образа

        - Инструкции для создания образа описываются в DockerFile.
        - Он используется, когда вы приказываете клиенту создать новый образ.
        - Команда build берёт базовый образ, применяет к нему инструкции
          из DockerFile, и возвращает результирующий образ.

    # Как работает Docker-репозиторий
      - Docker-репозиторий называется Docker Hub, он хранит Docker-образы.
      - Название, по всей вероятности, придумали, вдохновляясь названием GitHub.
      - Любой свой образ вы можете залить/скачать на/с Docker Hub.
      - Используя CLI клиенты можно искать и качать образы с Docker Hub.
      - В Docker Hub есть публичные и приватные репозитории.
      - Последние платные, и исключены из публичного поиска.

    # Как работают Docker-контейнеры
      - Контейнер состоит из ОС, данных пользователя и метаданных.
      - Каждый Docker-контейнер создаётся из Docker-образа.
      - Образ содержит информацию, из чего должен состоять контейнер,
        какие процессы должны подниматься при его запуске, и прочую
        конфигурационную информацию.
      - Docker-образ является read-only. Когда Docker делает run
        контейнера из образа, то добавляет read-write слой поверх
        образа (используя ФС union), в котором ваше приложение
        может работать.

    # Что происходит при run контейнера
      - Через CLI можно приказать Docker-клиенту запустить контейнер.
      - Например:

          docker run -i -t ubuntu /bin/bash

      - Где:

          ubuntu      | Какой образ использовать для создания контейнера
          /bin/bash   | Какую команду внутри контейнера запустить

      - Что происходит за сценой, когда вы запускаете эту команду:

        ## Добывание образа ubuntu
          - Docker проверяет наличие образа ubuntu.
          - В случае отсутствия скачивает скачивает его с Docker Hub.

        ## Создание нового контейнера
          - Добыв образ, Docker создаёт из него новый контейнер.

        ## Создание ФС контейнера, добавление read-write слоя
          - Создаёт файловую систему контейнера.
          - Добавляет в неё read-write слой из образа.

        ## Создание network/bridge интерфейса
          - Создаёт сетевой интерфейс.
          - С его помощью контейнер может общатсья с localhost.

        ## Настраивает IP-адреса
          - Ищет и назначает доступные IP-адреса из пула.

        ## Запускает указанные процессы

        ## Ловит и обрабатывает вывод приложения
          - Все данные из std input/output/error записываются в лог.
          - Лог, разумеется, находится вне контейнера.

      - Запустив контейнер, можно взаимодействовать с приложением
        внутри него. Если потребуется, можно остановить и удалить контейнер.

  > Важный функционал ядра Linux, используемый Docker

    # Docker написан на Go
      - И применяет несколько важных особенностей ядра.
      - Именно это и позволяет ему обеспечивать описанный функционал.
      - Рассмотрим эти особенности, чтобы иметь о них представление.

    # Namespaces
      - Docker используют технологию ядра под названием Namespaces.
      - Она позволяет создавать изолированные рабочие пространства,
        которые в терминологии Docker называются контейнерами.
      - Namespaces позволяют создать изолированный слой, в котором
        каждый контейнер запускается в собственном пр.имён, и к нему
        нет доступа извне.
      - Вот некоторые пр.имён, которые Docker использует в Linux:

        ## pid namespace    | Для изоляции процессов
        ## net namespace    | Для управления сетевыми интерфейсами
        ## ipc namespace    | Для управления доступом к IPC-ресурсам
        ## mnt namespace    | Для управления точками монтирования
        ## uts namespace    | Для изоляции ядра и идентификаторов версий

    # Control groups
      - Docker используют технологию ядра под названием Control groups.
      - Она позволяет указать изолированным контейнерам, какие ресурсы
        он может использовать.
      - Это гарантирует, что контейнеры будут хорошими соседями на 1-ом хосте.
      - Control groups позволяет контейнерам безопасно и совместно использовать
        ресурсы железа.
      - В случае необходимости, можно установить рамки и ограничения,
        например, ограничить MAX память для конкретного контейнера.

    # Union file systems
      - Docker применяет файловую систему UnionFS.
      - Эта операционная система позволяет иметь дело со слоями.
      - Это одна из причин, почему Docker такой легковесный и быстрый.
      - Docker может использовать несколько вариантов UnionFS,
        включая: AUFS, btrfs, vfs, and DeviceMapper.

    # Container format
      - Docker комбинирует эти компоненты в слой, который создатели
        Dockrt называют container format.
      - Формат контейнера по умолчанию называется libcontainer.
      - Не исключено, что в будущем Docker будет поддерживать и
        другие container formats, например, для BSD/Solaris систем.


А2. Установка Docker

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Установка на Windows: Docker Toolbox
    # Требования к машине с Windows

      - Windows >= 7
      - Вкл. технология виртуализации
      - x64

    # Docker Machines, как DOCKER_HOST при установке на Windows

      - Что происходит при установке Docker на Linux
      - Что происходит при установке Docker на Windows

    # Установка/Обновление/Удаление Docker Toolbox на Windows
    # Подключение к Docker при работе на Windows

      - Вводная информация
      - Подключение из Docker Quickstart Terminal
      - Подключение из Powershell
      - Подключение через PuTTY

  --------------------------------------

  > Ссылки

    # Оф.документация по установке Docker на Windows
        https://docs.docker.com/engine/installation/windows/

    # Оф.документация по установке Docker на Linux Ubuntu
        https://docs.docker.com/engine/installation/linux/ubuntulinux/

  > Введение
    - В этой главе описана установка Docker на Windows и Linux Ubuntu.

  > Установка на Windows: Docker Toolbox
    - Чтобы работать с Docker на Windows, надо установить Docker Toolbox.
    - Он включает в себя следующие инструменты:

      # Oracle VM VirtualBox
       # Docker Machine с бинарником docker-machine
        # Docker Engine с бинарником docker
         # Docker Shell - предварительно сконфигурированное окружение для CMD
         # Docker GUI - Kitematic

    - С помощью Docker Machine можно штамповать ВМ для VirtualBox.
    - ВМ создаётся с оч.лёгким дистром Linux и предустановленным Docker Engine.
    - VirtualBox вообще запускается в памяти, жрёт 24мб, и запускается за 5 секнуд.
    - Управлять Docker'ом на ВМ можно через Docker GUI или Kitematic.
    - Или можно просто подключаться к ВМ через PuTTY, или посылать команды
      из CMD или Powershell.
    - Вся тема с VirtualBox и ВМ нужна потому, что Docker может работать
      только на Linux, и запустить его на Windows/MacOS/другой ОС невозможно.

  > Требования к машине с Windows

    # Windows >= 7
      - Docker работает только на Windows 7 и старше.

    # Вкл. технология виртуализации
      - Для работы Docker, в настройках CPU д.б. включена виртуализация.
      - Обычно, включить её можно в биосе.
      - Проверить можно: CTRL+ALT+DEL -> Диспетчер задач -> Производительность.

    # x64
      - Docker поддерживает только 64-битные ОС.

  > Docker Machines, как DOCKER_HOST при установке на Windows

    # Что происходит при установке Docker на Linux
      - Допустим, у нас есть машина (реальная/виртуальная) с ОС Linux.
      - На неё Docker можно поставить без всяких виртуальных машин.
      - Ведь это же Linux, и Docker сможет использовать его ядро.
      - Соответственно, в этом случае DOCKER_HOST == localhost.

         |---------------------------|
         |  DOCKER_HOST              |
         |                           |
         |    Docker client          |
         |          |                |
         |    Docker daemon (server) |
         |          |                |
         |    Containers             |
         |                           |
         |      ----------           |
         |      ----------           |
         |                           |
         |      ----------           |
         |      ----------           |
         |---------------------------|

    # Что происходит при установке Docker на Windows
      - Docker нельзя установить на Windows, т.к. у него нет ядра Linux.
      - Надо сначала установить VirtualBox, на нём создать ВМ с Linux,
        и уже на эту ВМ накатать Docker.
      - И у нас есть 2 основных варианта для управление Docker на этой ВМ:

        1) Через Docker-клиент на Windows
          - Который был установлен в составе Docker Toolbox.
          - Через него можно подключиться к ВМ Docker Machines:

              "$(docker-machine env [имя машины])"

          - И отправлять команды Docker'у.


                    Windows

                      Docker Client
                                |
             |------------------|--------|
             |  DOCKER_HOST (ВМ)|        |
             |                  |        |
             |    Docker daemon (server) |
             |          |                |
             |    Containers             |
             |                           |
             |      ----------           |
             |      ----------           |
             |                           |
             |      ----------           |
             |      ----------           |
             |---------------------------|

        2) Через Docker-клиент на ВМ
          - Через PuTTY можно подключиться к ВМ.
          - И работать с Docker клиентом внутри машины.

                Windows

                  PuTTY
                      |
             |---------------------------|
             |  DOCKER_HOST (ВМ)         |
             |                           |
             |    Docker Client          |
             |          |                |
             |    Docker daemon (server) |
             |          |                |
             |    Containers             |
             |                           |
             |      ----------           |
             |      ----------           |
             |                           |
             |      ----------           |
             |      ----------           |
             |---------------------------|


  > Установка/Обновление/Удаление Docker Toolbox на Windows

    # Установка

      1) Скачать свежий Docker Toolbox
        - Это можно сделать здесь: https://www.docker.com/toolbox

      2) Запустить установщик, и установить Docker
        - При этом (при установках по умолчанию) произойдёт следующее:

          # Исполняемые файлы установятся в "https://www.docker.com/toolbox"
          # Установится или обновится VirtualBox
          # В program shortcuts добавится каталог Docker inc.
          # Добавится/Обновится запись в PATH
          # На рабочий стол добавятся ярлыки Docker Quickstart Terminal и Kitematic.

    # Обновление
      - Для обновления, запустите свежий Docker Toolbox installer.

    # Удаление
      - Стандартными средствами windows.
      - Плюс вручную удалить файл docker-install.exe.

  > Подключение к Docker при работе на Windows

    # Вводная информация
      - Итак, вы установили Docker Toolbox.
      - Теперь, чтобы запустить Docker-контейнер, необходимо:

        1) Создать и запустить новую (или использовать существующую) ВМ с Docker.
        2) Подключиться тем или иным образом к этой ВМ.
        3) Использовать Docker-клиент docker для создания/загрузки/управления контейнерами.

      - Однажды создав ВМ, её можно использовать снова и снова.
      - Она ведь, по сути, обычная ВМ для VirtualBox, и работает также.
      - Все данные на ней сохраняются между её перезапусками.

    # Подключение из Docker Quickstart Terminal

      1) Найти ярлык или исполняемый файл, и запустить DQT
        - После установки Docker Toolbox, ярлык д.б. на рабочем столе.
        - При этом произойдёт следующее:

          -- Откроется CMD
          -- Создатся ВМ default, если она ещё не существует, и запустится
          -- Терминал автоматически подключится в ВМ

        - Сразу после этого можно работать в этом CMD с docker.

      2) Удостоверьтесь, что всё работает, запустив контейнер nginx
        - В оф.инструкции предлагази запустить контейнер hello-world,
          но мы запустим лучше nginx.
        - Для этого в CMD из 1 выполните:

            docker run --rm -i -t -p 80:80 nginx    // Для запуска в интерактивном режиме
            docker run -d -i -t -p 80:80 nginx      // Для запуска в режиме демона

        - В случае запуска врежиме демона, процесс запустится
          в фоновом режиме, и в командную строку можно будет вводить.
        - Узнайте IP для запущенной виртуальной машины:

            docker-machine ip

        - Откройте браузер, впишите туда этот IP, там д.б.
          стартовая страничка для nginx.
        - Чтобы остановить и удалить запущенный контейнер:

            docker ps -a                            // узнайте его имя
            docker stop [имя] && docker rm [имя]    // остановите и удалите

        - При этом ВМ default продолжает работать после закрытия терминала.
        - Чтобы остановить её:

            docker ls                               // узнайте её имя
            docker stop [имя]                       // остановите её

    # Подключение из Powershell

      1) Добавьте в PATH следующее: c:\Program Files (x86)\Git\bin

      2) Запустите Windows PowerShell

      3) Создайте новую ВМ с Docker с помощью Docker Machines
        - Допустим, создадим ВМ с именем my-default.
        - Для этого:

            docker-machine create --driver virtualbox my-default

      4) Убедитесь, что ВМ создалась
        - Для этого просмотрите все имеющиеся ВМ
        - Для этого:

            docker-machine ls

      5) Получите environment commands для вашей новой ВМ:
        - Для этого:

            docker-machine env --shell powershell my-default

      6) Подключитесь к вашей новой ВМ:
        - Для этого:

            eval "$(docker-machine env my-default)"

      7) Запустите контейнер hello-world для проверки работоспособности
        - Для этого:

            docker run hello-world

    # Подключение через PuTTY
      - Для подключения к ВМ Docker Machines понадобится SSH-ключ.
      - При создании новой ВМ, ключ помещается в %USERPROFILE%\.ssh
      - Для подключение потребуется private key из этого каталога.
      - Но надо конвертировать его в PuTTY-формат с помощью puttygen.exe:

        1) Откройте puttygen.exe

        2) Нажмите File -> Load и загрузите private key
          - Который в %USERPROFILE%\.docker\machine\machines\<name_of_your_machine>\id_rsa
          - В моём случае %USERPROFILE% это: C:\Users\German\.ssh

        3) Нажмите Save Private Key

        4) Подключитесь к ВМ с помощью созданного ключа
          - Используйте Login: docker
          - IP и порт: 127.0.0.1:2022


А3. Запуск приложений в Docker-контейнерах

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Пример №1: вывести строку "hello world"
    # Пример №2: запустить контейнер в интерактивном режиме с bash
    # Пример №3: запустить демонизированный контейнер

  --------------------------------------

  > Ссылки

    # Оф.статья "Hello world in a container"
        https://docs.docker.com/engine/userguide/containers/dockerizing/

  > Введение
    - В этой главе описан процесс запуска приложений в контейнере.
    - В рассмотренном примере приложение ежесекундно выводит "Hello world".

  > Пример №1: вывести строку "hello world"
    - В этом примере воспользуемся базовым образом ubuntu.
    - Создадим из него контейнер, и выведем в std out строку "hello world".
    - Для этого введём:

        docker run ubuntu /bin/echo 'Hello world'

    - Рассмотрим подробнее, что произошло:

      # docker run
        - Эта команда создаёт и запускает контейнер из указанного образа.

      # ubuntu
        - Это имя образа, из которого docker run создаёт контейнер.

      # /bin/echo 'Hello world'
        - Эта команда, которая после запуска контенера выполняется в нём.
        - Команда echo просто выводит указанную строку в std out.

    - А что произошло с контейнером после выполнения команды?
    - Контейнер сразу завершил работу. Поскольку, Docker-контейнеры
      работают лишь в течение того времени, пока указанная команда
      выполняется.

  > Пример №2: запустить контейнер в интерактивном режиме с bash
    - В этом примере воспользуемся базовым образом ubuntu.
    - Создадим для него контейнер в интерактивном режиме.
    - И запустим в нём /bin/bash.
    - Благодаря интерактивному режиму, мы сможем ваимодействовать с ним.
    - Для этого введём:

        docker run -t -i ubuntu /bin/bash

    - Введя, мы видим в начале такую строку: root@fc74d37ae42c.
    - root это имя пользователя, а fc74d37ae42c сокращённый id контейнера.
    - То есть, мы получили root-доступ к данному контейнеру.
    - Чтобы выйти, можно ввести:

        exit

  > Пример №3: запустить демонизированный контейнер

    # Введение
      - В примере №1 контейнер завершался после выполнения указанной команды.
      - В примере №2 контейнер завершался после завершения процесса /bin/bash.
      - Но как создать контейнер, который сам не будет завершаться?
      - Который можно будет завершить лишь командой docker stop ?
      - Для этого надо демонизировать создаваемый контейнер параметром -d.

    # Создание демонизированного контейнера
      - Создадим демонизированный контейнер.
      - Он будет каждую секунду выводить в std out "hello world".
      - Создадим:

          docker run -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done"

    # ID контейнера, краткий ID, образ, имя, статус
      - Выполнив команду, мы получим Unique ID контейнера:
          1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147
      - Но удобнее работать с именем контейнера, чем с его громоздким ID.
      - Убедимся, что контейнер запущен, для этого введём:

          docker ps -a

      - Среди прочего здесь указан и короткий вариант ID: 1e5535038e28
      - Это первые 12 цифр полного ID.
      - Также здесь указано имя образа, имя контейнера и его статус.
      - Если при создании контейнера не указать имя, Docker сам его придумает.

    # Посмотреть вывод контейнера через docker logs
      - Итак, мы создали демонизированный контейнер.
      - И управление в нашем Docker-клиенте вернулось к нам.
      - То есть, никакого вывода мы у себя не видим.
      - А чтобы его увидеть, надо воспользоваться командо docker logs:

          docker logs [имя контейнера]

      - Команда выведет данные из std out контейнера (не в realtime).

    # Остановить и удалить демонизированный Docker-контейнер
      - Теперь мы хотим остановить и удалить его.
      - Для этого:

          docker stop [имя] && docker rm [имя]

      - Не забудьте убедиться, что контейнер удалён, с помощью: docker ps -a


А4. Создание собственных Docker-образов

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Просмотр списка образов [images]
    # Теги образов {image}:{tag}
    # Скачивание образов на хост [pull]
    # Поиск образов на Docker Hub [search]
    # Типы образов

      - Вводная информация
      - Official
      - Automated

    # Создание образов [commit/build]

      - Вводная информация
      - Из контейнера [commit]
      - Из DockerFile [build]
      - Образ может иметь <= 127 слоёв

    # Добавить тег существующему образу [tag]
    # Дайджест образа
    # Загрузка образа на Docker Hub [push]
    #

  --------------------------------------

  > Ссылки

    # Оф.статья "Build your own images"
        https://docs.docker.com/engine/userguide/containers/dockerimages/

    # Оф.статьи про official и automated типы образов
        https://docs.docker.com/docker-hub/official_repos/
        https://docs.docker.com/engine/userguide/containers/dockerrepos/#automated-builds

    # Оф.сайт репозиторий Docker Hub
        https://hub.docker.com/

  > Введение
    - Понятие образов является одним из центральных в концепции Docker.
    - Любые контейнеры в конечном итоге создаются из образов.
    - Можно как создавать свои образы, так и использовать уже готовые.
    - Образы можно закачивать/скачивать на/с Docker Hub (аналог github, но для образов).
    - В этой главе прольём свет на следующие темы:

        # Работа и управление образами локально, на Docker Host.
        # Создания базовых образов.
        # Закачка образов на Docker Hub.

  > Просмотр списка образов [images]
    - Командой docker images можно посмортеть список образов в наличии.
    - Эти образы хранятся в файловой системе хоста для Docker.
    - При работе на Windows, хостом является виртуальная машина с Linux.
    - Та самая, которая создаётся Docker Machines, если вы его используете.
    - Правда, найти конкретный каталог с образами на ВМ на данный момент не удалось.

  > Теги образов {image}:{tag}
    - Многие команды CLI Docker принимают имя образа в качестве аргумента.
    - Каждый образ на Docker Hub имеет тег, по аналогии с тегами с GitHub.
    - Когда вы указываете имя образа в CLI, вы можете указать и тег.
    - Тег указывается через символ ":". Общий шаблон: [имя]:[тег].
    - Например:

        docker run -t -i ubuntu:14.04 /bin/bash

    - У каждого образа есть тег "latest", означающий последнюю версию.

  > Скачивание образов на хост [pull]
    - Образы скачиваются автоматически при использовании docker run.
    - Но иногда хочется скачать их заранее, чтобы docker run сработала быстрее.
    - Команда docker pull [имя] позволяет скачать образ [имя].
    - Рядом с именем можно указать и тег для образа: [имя]:[тег].
    - При работе на Windows, образы скачиваются в ФС виртуальной машины.
    - Например, мы хотим скачать ubuntu 14.04:

        docker pull ubuntu:14.04

  > Поиск образов на Docker Hub [search]
    - Искать образы на Docker Hub можно командой docker search.
    - Данная команда не позволяет искать образы по тегам.
    - Например, мы хотим найти образ ubuntu:

        docker search ubuntu

    - Она выведет список всех образов, имеющих "ubuntu" в названии.

  > Типы образов

    # Вводная информация
      - На Docker Hub есть 2 типа образов: official и automated.
      - Подробно они описаны в соответствующем разделе этой методички.

    # Official
      - Официальные образы, разработка которых курируется Docker'ом.
      - На каждый оф.образ Docker выделяет отдельную команду разработчиков.
      - Каждая такая команда работает в тесном сотрудничестве с разработчиками
        того программного обеспечения, который используется в соотв.образе,
        экспертами по безопасности и широкой общественностью.
      - Создание и поддержка официальных образов является открытым процессом,
        который публично протекает на GitHub, любой может принять участие.

    # Automated
      - Не официальные образы, которые может закачать на Docker Hub любой.


  > Создание образов [commit/build]

    # Вводная информация
      - Вы нашли хороший образ, но он не совсем вам подходит?
      - Вы хотите внести корректирующие изменения в этот образ?
      - Это можно сделать 2-мя способами:

        1) Из контейнера
          - Можно создать контейнер из этого образа.
          - Внести изменения в этот контейнер.
          - И создать образ из этого контейнера.

        2) Из DockerFile
          - Можно создать файл с именем "DockerFile".
          - В нём указать базовый образ для изменения.
          - А также описать список необходимых изменений.
          - И создать новый образ из этого DockerFile.

      - После создания образо он НЕ заливается автоматом на Docker Hub.

    # Из контейнера [commit]

      1) Создать контейнер
        - Сначала надо создать контейнер из исходного образа.
        - И получить к нему доступ через командную строку.
        - Например:

            docker run -t -i ubuntu:latest /bin/bash

      2) Изменить созданный контейнер
        - Допустим, мы хотим установить веб-сервер.
        - Установим на свеженькую убунту свеженький nginx.
        - И после этого выйдем из командной строки контейнера:

            sudo apt-get install nginx
            exit

      3) Сделать commit образа из контейнера
        - Требуется сделать коммит нового образа из контейнера на Docker Hub.
        - Для этого:

            docker commit -m "Added json gem" -a "Kate Smith" \
            0b2616b0e5a8 ouruser/sinatra:v2

        - Здесь:

            -m "Added json gem"         // сообщение к коммиту
            -a "Kate Smith"             // автор коммита
            0b2616b0e5a8                // краткий id контейнера
            ouruser/sinatra:v2          // вендор и название:версия

        - Командой docker images можно убедиться, что образ появился в списке.
        - Теперь можно использовать наш новый образ (пример):

            docker run -t -i ouruser/sinatra:v2 /bin/bash

    # Из DockerFile [build]

      1) Создать каталог и DockerFile
        - Например, создадим каталог "ubuntu-nginx".
        - И в нём файл "DockerFile".

      2) Наполнить DockerFile инструкциями
        - Каждая инструкция создаёт новый слой образа.
        - Пример содержимоо DockerFile:

          FROM ubuntu:14.04
          MAINTAINER German Manvelov <4gekkman@gmail.com>
          RUN sudo apt-get update && sudo apt-get install -y nginx

      3) Создать образ из DockerFile
        - Для этого перейти в каталог с DockerFile.
        - И выполнить следующую команду:

            docker build -t 4gekkman/ubuntu-nginx:1.0.0 .

        - Где:

            -t 4gekkman/ubuntu-nginx:1.0.0   // вендор, имя, версия
            .                                // Адрес DockerFile

        - При этом будет выдано предупреждение:

              SECURITY WARNING: You are building a Docker image
              from Windows against a non-Windows Docker host.
              All files and directories added to build context will
              have '-rwxr-xr-x' permissions. It is recommended to
              double check and reset permissions for sensitive
              files and directories.

        - Ничего страшного, оно лишь означает следующее:

              That warning was added, because the Windows filesystem
              does not have an option to mark a file as 'executable'.
              Building a linux image from a Windows machine would
              therefore break the image if a file has to be marked
              executable.

              For that reason, files are marked executable by default
              when building from a windows client; the warning is there
              so that you are notified of that, and (if needed),
              modify the Dockerfile to change/remove the executable
              bit afterwards.

        - Теперь можно создавать контейнеры из нового образа:

              docker run -t -i 4gekkman/ubuntu-nginx:1.0.0 /bin/bash

    # Образ может иметь <= 127 слоёв
      - И это не зависит от storage driver'а.
      - Это ограничение действует глобально.
      - Оно позволяет держать в узде размеры образов.

  > Добавить тег существующему образу [tag]
    - Можно добавить тег уже созданному образу.
    - Уже после того, как он был commit или build.
    - Пример:

        docker tag 5db5f8471261 ubuntu-nginx:devel

  > Дайджест образа
    - Каждый образ имеет связанный с контентом идентификатор.
    - Если input из которого создан образ не изменился, идентификатор тоже.
    - Увидеть digetst'ы образов, можно передав флаг --digest:

        docker images --digests | head

    - Также digest может служить идентификатором этого образа в
      таких командах, как create/run/rmi, а также в инструкции
      FROM в DockerFile.

  > Загрузка образа на Docker Hub [push]
    - После создания образа его можно загрузить на Docker Hub.
    - Например:

        docker push 4gekkman/ubuntu-nginx

  > Удаление образа с хоста
    - Удалить образ можно командой docker rmi.
    - При этом образ удаляется с хоста.
    - Например:

        docker rmi 4gekkman/ubuntu-nginx


А5. Работа с Docker Machines

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Где хранятся виртуальные машины для Docker
    # Что такое Docker Machine

      - Определение Docker Machines
      - Где можно использовать
      - Что позволяет делать команда docker-machine

    # Зачем нужны Docker Machines

      - Вводная информация
      - Запускать Docker на Windows/Mac
      - Управлять хостами Docker на удалённых машинах

    # Какая разница между Docker Engine и Docker Machine

      - Docker Engine
      - Docker Machine

    # Использование Docker Machine для запуска Docker-контейнеров
    # Создание Docker-машины
    # Экспериментирование с Docker-машиной

      - Запуск контейнера с busybox командой docker run
      - Получение IP адреса Docker-машины
      - Запуск nginx в контейнере командой docker run

    # Запуск и остановка Docker-машин

      - Запуск Docker-машины
      - Остановка Docker-машины

    # Имя 'default' умолчательное для многих команд
    # Драйверы для Docker-машин

      - Вводная информация
      - Список доступных драйверов

    # API команды docker-machine

      - active            | Имя активной машины (смотрит DOCKER_HOST)
      - config            | Показывать конфигурацию для указанной docker-машины
      - create            | Создать новую docker-машину
      - env               | Настроить переменные среды, натравив docker на указанную ВМ
      - help              | Посмотреть справку по указанной команде
      - inspect           | Получить информацию об указанной ВМ
      - ip                | Получить IP указаной ВМ.
      - kill              | Сделать power off для указанной ВМ
      - ls                | Вывести список доступных ВМ
      - provision         | Запустить provision на указанной машине
      - regenerate-certs  | Перегенерировать TLS-сертификаты и обновить указанную машину
      - restart           | Перезапустить указанную машину
      - rm                | Удалить указанную машину
      - scp               | Копировать файлы с localhost на указанную машину  через scp
      - ssh               | Выполнить на указанной машине команду через ssh
      - start             | Запустить указанную docker-машину
      - status            | Получить статус указанной docker-машины
      - stop              | Остановить указанную docker-машину
      - upgrade           | Обновить Docker на указанной docker-машине
      - url               | Получить URL хоста указанной машины

  --------------------------------------

  > Ссылки

    # Оф.статья "Docker Machine Overview"
        https://docs.docker.com/machine/overview/

    # Оф.статья "Get started with Docker Machine and a local VM"
        https://docs.docker.com/machine/get-started/

    # Оф.справочник по API: "Command line reference"
        https://docs.docker.com/machine/reference/active/

    # Оф.справочник по драйверам
        https://docs.docker.com/machine/drivers/os-base/

  > Введение
    - Docker Machines является вспомогательным инструментом Docker.
    - Он создан специально для удобной работы с Docker из Windows и MacOS.
    - Ведь Docker Engine можно запустить исключительно на Linux.
    - Поэтому на Windows и MacOS для работы с докер нужна ВМ с Linux.
    - Раньше тематика ВМ оставалась за рамками инструментов Docker.
    - Пользователям предлагалось решать этот вопрос самостоятельно.
    - Но на определённом этапе Docker взял этот вопрок "под крыло".
    - Так для чего же можно использовать Docker Machines:

      # Чтобы устанавливать и использовать Docker на Windows и Mac
      # Управлять множеством удалённых хостов для Docker
      # Управлять Swarm-кластерами

  > Где хранятся виртуальные машины для Docker
    - Виртуальные машины для Docker хранятся в:

        C:\Users\[user]\.docker\machine\machines  // в общем случае
        C:\Users\German\.docker\machine\machines  // в моём случае

  > Что такое Docker Machine

    # Определение Docker Machines

        Инструмент, позволяющие устанавливать
        Docker Engine на виртуальные хосты,
        и управлять ими с помощью команд
        docker-machine.

    # Где можно использовать

      - На локальном компьютере с Windows или MacOS.
      - В дата центре.
      - У облачного провайдера вроде AWS или Digital Ocean.

    # Что позволяет делать команда docker-machine

      - start       | запускать ВМ
      - inspect     | получать информацию о ВМ
      - stop        | останавливать ВМ
      - restart     | перезапускать ВМ
      - upgade      | обновлять Docker-клиент и Docker-демон
      - configure   | настраивать
      ...           | и многое другое

  > Зачем нужны Docker Machines

    # Вводная информация
      - На данный момент DM являются 1-ым путём запустить DE на Windows/Mac.
      - Ещё DM являются хорошим способом управлять удалёнными Docker-хостами на Linux.

    # Запускать Docker на Windows/Mac
      - Для работы на Windows/Mac вы устанавливаете Docker Toolbox.
      - Это набор программ, включающий: DE, DM, VirtualBox, Docker Shell, Kitematic.
      - После установки в консоли становится доступна команда docker-machine.
      - С помощью этой команды можно быстро создать ВМ для VirtualBox, и запустить.
      - Создав ВМ, можно к ней подключиться, и работать с командой docker.

    # Управлять хостами Docker на удалённых машинах
      - Docker может работать лишь на Linux-системах.
      - Если у вас Linux, для работы с Docker надо установить лишь Docker Engine.
      - И после этого можно работать с командой docker.
      - Но что, если у вас есть N Linux-серверов с Docker Engine на борту?
      - Которые могут быть в облаке, в сети, локально, где угодно.
      - Какая бы ОС у вас не была основная, вы можете поставить Docker Machine.
      - И с помощью её команд эффективно управлять вашими удалёнными N хостами.
      - Автоматически создавать хосты, устанавливать DE, настраивать клиенты.

  > Какая разница между Docker Engine и Docker Machine

    # Docker Engine
      - Когда люди говорят "Docker", обычно они имеют в виду DE.
      - То есть:

          Клиент-серверное приложение, состоящее из Docker-сервера
          (демона), REST API интерфейса для взаимодействия с ним,
          и Docker-клиента (CLI), который взаимодействует с сервером
          через REST API-слой.

      - Весь CLI для DE сосредоточен в команде docker.
      - Примеры: docker run / docker ps / docker images

    # Docker Machine
      - Это инструмент для управления докерезированными хостами.
      - То есть хостами с Docker Engine на борту.
      - Обычно Docker Machine устанавливают на основную локальную систему.
      - DE имеет свой CLI, который сосредоточен в команде docker-machine.
      - DM позволяет установить DE на 1 или более вертуальных систем.
      - Эти системы м.б. локальными или удалёнными.

  > Использование Docker Machine для запуска Docker-контейнеров
    - Чтобы запустить Docker-контейнер, понадобится:

      # Создать и запустить новую (запустить существующую) Docker-машину.
      # Подключиться к этой ВМ, чтобы стала доступна команда docker
      # Использовать Docker-клиент для создания/загрузки/управления контейнерами

    - Однаджы создав Docker-машину, её можно использовать снова и снова.
    - Как и любой VirtualBox-бокс, она сохраняет настройки между запусками.

  > Создание Docker-машины

    1) Просмотреть список существующих Docker-машин
      - Для этого выполить команду:

          docker-machine ls

    2) Создать виртуальную машину
      - Это можно сделать командой docker-machine create.
      - Также потребуется указать драйвер флагом --driver.
      - Какие бывают драйверы, будет описано в одном из пунктов ниже.
      - Драйвер для создания ВМ для VirtualBox так и называется.
      - Например, создадим ВМ с именем default:

          docker-machine create --driver virtualbox default

      - Эта команда скачает легковесный дистрибутив Linux.
      - На нём уже будет предустановлен Docker Engine.

    3) Просмотреть список существующих Docker-машин
      - Чтобы проверить, что новая машина была создана.
      - Для этого выполить команду:

          docker-machine ls

    4) Подключиться к новой Docker-машине
      - Для этого использовать команду docker-machine env.
      - Выполнить:

          docker-machine env --shell powershell default
          docker-machine env --shell powershell default | Invoke-Expression

      - После этого команда docker станет доступной.
      - Она будет взаимодействовать в ВМ default.

  > Экспериментирование с Docker-машиной

    # Запуск контейнера с busybox командой docker run
      - Выполнить команду:

        docker run busybox echo hello world

    # Получение IP адреса Docker-машины
      - Все порты Docker-машины будут доступны с этим IP.
      - Унать его можно командой:

        docker-machine ip

    # Запуск nginx в контейнере командой docker run
      - Запустить контейнер с nginx можно командой:

        docker run -d -p 8000:80 nginx

      - Когда контейнер запустится, можно узнать IP Docker-машины.
      - И зная IP, увидеть стартовую страницу nginx на порту 8000.

  > Запуск и остановка Docker-машин

    # Запуск Docker-машины

        docker-machine ls                                // Вывести существующий список Docker-машин
        docker-machine start [имя/id краткое/id полное]  // Запустить Docker-машину

    # Остановка Docker-машины

        docker-machine ls                               // Вывести существующий список Docker-машин
        docker-machine stop [имя/id краткое/id полное]  // Остановить Docker-машину

  > Имя 'default' умолчательное для многих команд
    - Есть список команд, которые требуют указать имя Docker-машины.
    - Но в которых можно это самое имя не указывать.
    - И тогда будет использовано имя по умолчанию: "default".
    - Вот эти команды:

        docker-machine config
        docker-machine env
        docker-machine inspect
        docker-machine ip
        docker-machine kill
        docker-machine provision
        docker-machine regenerate-certs
        docker-machine restart
        docker-machine ssh
        docker-machine start
        docker-machine status
        docker-machine stop
        docker-machine upgrade
        docker-machine url

  > Драйверы для Docker-машин

    # Вводная информация
      - Будем оперировать понятиями "провайдер" и "ОС".
      - Провайдеры, это:

          VirtualBox            |
          Fusion                | локальные провайдеры
          Hyper-V               |

          Digital Ocean         | удалённые провайдеры
          Amazon Web Services   |

      - Операционные системы это разные дистрибутивы Linux:

          Boot2Docker
          Ubuntu
          Debian
          RancherOS
          RedHat Enterprice Linux
          CentOS
          Fedora

      - Для локальныъ и удалённых провайдеров разные ОС по умолчанию:

          Для локальных: Boot2Docker.
          Для удалённых: Ubuntu

      - Для удалённых провайдеров можно указать и другой дистрибутив.
      - Для этого надо использовать провайдер-специфичный флаг. Например:

          --digitalocean-image=debian-8-x64

      - Также можно указать другого SSH-пользователя:

          --amazonec2-ssh-user

      - Каждый драйвер имеет набор провайдер-специфичных опций.
      - Пример для Amazon Web Services:

          docker-machine create -d azure --azure-subscription-id="SUB_ID" --azure-subscription-cert="mycert.pem" A-VERY-UNIQUE-NAME

    # Список доступных драйверов

      virtualbox        |
      hyperv            |
      vmwarefusion      | для конкретных инструментов виртуализации
      vmwarevcloudair   |
      vmwarevsphere     |

      generic           | для существующей ВМ

      digitalocean      |
      amazonec2         |
      exoscale          |
      google            | для облачных хостингов
      softlayer         |
      azure             |
      openstack         |
      rackspace         |

  > API команды docker-machine

    // active //
    //--------//
    // - Имя активной машины (смотрит DOCKER_HOST).

      docker-machine ls       // вывести список всех docker-машин
      docker-machine active   // вывести имя активной docker-машины

    // config //
    //--------//
    // - Показывать конфигурацию для указанной docker-машины.
    // - Если не указать имя, использует оное по умолчанию "default".

      docker-machine config [имя машины]

    // create //
    //--------//
    // - Создать новую docker-машину.

      // Синтаксис и справки
        docker-machine create                                 // получить общую справку
        docker-machine create --driver [драйвер] [имя машины] // создать ВМ с именем и драйвером
        docker-machine create --driver [драйвер] --help       // посмотреть драйвер-специфичную справку

      // Создать ВМ "test" для virtualbox
        docker-machine create --driver virtualbox test

    // env //
    //-----//
    // - Настроить переменные среды, натравив docker на указанную ВМ.

      docker-machine env --shell powershell default
      docker-machine env --shell powershell default | Invoke-Expression

    // help //
    //------//
    // - Посмотреть справку по указанной команде.

      docker-machine help config

    // inspect //
    //---------//
    // - Получить информацию об указанной ВМ.

      docker inspect [имя машины]

    // ip //
    //----//
    // - Получить IP указаной ВМ.

      docker ip [имя машины]

    // kill //
    //------//
    // - Сделать power off для указанной ВМ.

      docker kill [имя машины]

    // ls //
    //----//
    // - Вывести список доступных ВМ.

      docker ls

    // provision //
    //-----------//
    // - Запустить provision на указанной машине.

      # Пример
          docker-machine provision [имя машины]

      # Что происходит

        1. Set the hostname on the instance to the name Machine addresses it by (e.g. default).
        2. Install Docker if it is not present already.
        3. Generate a set of certificates (usually with the default, self-signed CA) and configure the daemon to accept connections over TLS.
        4. Copy the generated certificates to the server and local config directory.
        5. Configure the Docker Engine according to the options specified at create time.
        6. Configure and activate Swarm if applicable.

    // regenerate-certs //
    //------------------//
    // - Перегенерировать TLS-сертификаты и обновить указанную машину.

      docker-machine regenerate-certs [имя машины]

    // restart //
    //---------//
    // - Перезапустить указанную машину.
    // - Обычно это эквивалентно: docker-machine stop; docker-machine: start;
    // - Некоторые облачные хосты пытаются сделать "умный" рестарт с сохранением IP,

      docker-machine restart [имя машины]

    // rm //
    //----//
    // - Удалить указанную машину.
    // - При этом будет удалена локальная ссылка на машину.
    // - А также она будет удалены с облачного хостинга / платформы виртуализации.

      docker-machine rm [имя машины] [имя машины] [имя машины]

    // scp //
    //-----//
    // - Копировать файлы с localhost на указанную машину через scp.

      docker-machine ssh [имя машины] pwd
      docker-machine scp [имя машины]:/home/docker/foo.txt .

    // ssh //
    //-----//
    // - Выполнить на указанной машине команду через ssh.

      docker-machine ssh [имя машины] pwd

    // start //
    //-------//
    // - Запустить указанную docker-машину.

      docker-machine start [имя машины]

    // status //
    //--------//
    // - Получить статус указанной docker-машины.

      docker-machine status [имя машины]

    // stop //
    //------//
    // - Остановить указанную docker-машину.

      docker-machine start [имя машины]

    // upgrade //
    //---------//
    // - Обновить Docker на указанной docker-машине.
    // - Docker обновляется до последней версии.
    // - Процесс обновления зависит от дистрибутива Linux.

      docker-machine upgrade [имя машины]

    // url //
    //-----//
    // - Получить URL хоста указанной машины.

      docker-machine url [имя машины]


А6. Объединение контейнеров в сеть

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # О важности имён контейнеров
    # Два доступных из коробки драйвера: bridge и overlay

      - Вводная информация
      - Bridge
      - Overlay

    # Создание своей bridge-сети
    # Добавление контейнеров в bridge-сеть

  --------------------------------------

  > Ссылки

    # Оф.статья "Network containers"
        https://docs.docker.com/engine/userguide/containers/networkingcontainers/

    # Оф.статья "Understand Docker container networks"
        https://docs.docker.com/engine/userguide/networking/dockernetworks/

    # Оф.статья "Get started with multi-host networking"
        https://docs.docker.com/engine/userguide/networking/get-started-overlay/

  > Введение
    - В этой главе рассмотрено объединени контейнеров в сеть.

  > О важности имён контейнеров
    - При создании контейнера можно не указывать для него имя.
    - Тогда Docker автоматически сгенерирует имя вроде "nostalgic_morse".
    - Однако, лучше самому назначить ему удобное, оптимальное имя.
    - Ведь:

      # Краткое и говорящее имя
        - Имя должно быть коротким, чтобы его было удобно писать.
        - Имя должно говорио о функциях контейнера.
        - К примеру, контейнер с nginx можно так и назвать.

      # По имени Docker может обращаться к контейнерам
        - И если имя короткое и говорящее, так будет лучше.

      # Имя должно быть уникальным
        - Не может быть 2-ух контейнеров с одинаковыми именами.

    - Назначить имя можно при создании контейнера флагом --name.
    - Например:

        docker run -d -P --name web training/webapp python app.py

    - Убедиться, что имя назначено, можно командой: docker ps -l

  > Два доступных из коробки драйвера: bridge и overlay

    # Вводная информация
      - Можно написать собственный сетевой плагин.
      - Но вообще, Docker из коробки имеет 2-ва сетевых драйвера:

        1) bridge
        2) overlay

      - Прикаждой установке Docker Engine автоматически создаются
        3 сети по умолчанию:

          1) Имя: none, driver: null
          2) Имя: host, driver: host
          3) Имя: bridge, driver: bridge
            - Это особая сеть.
            - По умолчанию, Docker запускает контейнеры в ней.
            - Убедитсья в этом легко:

                docker run -itd --name=networktest ubuntu   // запустить контейнер
                docker network inspect bridge               // увидеть контейнер в сети

            - Удалить контейнер из сети bridge можно так:

                docker network disconnect bridge networktest

            - Но удалить саму сеть bridge нельзя.

      - Вообще, сети удобный способ изолировать контейнеры.
      - Как от других контейнеров, так и от других сетей.
      - По мере набора опыта с Docker, вам захочется создать свои сети.

    # Bridge
      - Для объединения в сеть контейнеров на 1-ом Docker Host'е.

    # Overlay
      - Для объединения в сеть контейнеров на разных Docker Host'ах.

  > Создание своей bridge-сети

      docker network create -d bridge my-bridge-network   // создать
      docker network ls                                   // вывести список сетей
      docker network inspect my-bridge-network            // убедиться, что в новой сети нет контейнеров

  > Добавление контейнеров в bridge-сеть
    - Обычно веб-приложение состоит из нескольких контейнеров.
    - Эти контейнеры должны безопасно друг с другом взаимодействовать.
    - Они могут делать это по сети, для этого их надо поместить в 1 сеть.
    - Каждый контейнер можно поместить в любое количество сетей.
    - Для примера, поместим ubuntu и nginx в 1-ну сеть my-bridge-network:

        // 1] Объединить контейнеры в 1-ну сеть

          // Если контейнеры ещё не запущены
            docker run -t -i -d --net=my-bridge-network --name ubuntu ubuntu /bin/bash
            docker run -d --net=my-bridge-network --name nginx nginx

          // Если контейнеры уже запущены
            docker network connect my-bridge-network ubuntu
            docker network connect my-bridge-network nginx

        // 2] Убедиться, что сеть содержит контейнеры
        docker network inspect my-bridge-network

        // 3] Получим IP-адреса каждого контейнера
        docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ubuntu
        docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' nginx

        // 4] Пропингуем каждый из контейнеров из другого

          // Контейнер nginx из контейнера ubuntu
          docker exec -it ubuntu bash
          ping nginx

          // Контейнер ubuntu из контейнера nginx
          docker exec -it nginx bash
          ping ubuntu


А7. Управление данными в/между контейнерами

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Суть кратко

      - Про архитектуру Docker
      - Docker machines работает через VirtualBox
      - Что такое volumes

    # Управление общими папками в VirtualBox
    # Создание объектов volume

      - Вывод списка всеъ объектов volume на host-машине
      - Именованные / Не именованные
      - С авто ссылкой / С ручной ссылкой
      - Создание объекта volume в DockerFile

    # Передача ссылок на объекты volume от одного контейнера другому

      - Суть дела
      - Создание (без запуска) спец.контейнера - пула ссылок на объекты volumes
      - Внимание! Не допускать одновременную запись N-контейнеров в 1-ну volume-папку
      - Backup данных
      - Restore данных

    # Удаление объектов volume

      - Удаление объекта volume при удалении контейнеров
      - Удаление объектов-зомби volume
      - Прямое удаление объекта volume

    # Набор полезных code-tips

  --------------------------------------

  > Ссылки

    # Оф.статья "Manage data in containers"
        - https://docs.docker.com/engine/userguide/containers/dockervolumes/

    # Статья Ивана Бесарабова "Эксперименты с докерными volumes"
        https://ivan.bessarabov.ru/blog/docker-volumes-experiments

  > Введение
    - В этой главе рассмотрим так называемые data volumes.

  > Суть кратко

    # Про архитектуру Docker

      • При работе с Docker на Windows архитектура выглядит так:

          Docker client (Windows)
              |
            Docker host (docker machines with boot2docker linux dist)
                |
              Docker server (Docker Engine)

      • А при работе на Linux:

          Native host (Linux)
              |
            Docker server (Docker Engine)

    # Docker machines работает через VirtualBox
      - Это актуально, если client и host это разные машины.
      - К примеру, client на Windows, а host на docker machine.
      - VirtualBox в этом случае расшаривает по умолчанию лишь 1 каталог.
      - Это: c:/users (client) <---> /c/users (host)

    # Что такое volumes
      - Это такие объекты в мире Docker на host-машине.
      - Каждый такой объект содержит ссылку на каталог на host-машине.
      - В чём их суть:

        • Ссылки на volumes можно передавать в контейнеры
          - А каждый volume содержит ссылку на папку на host-машине.
          - Поэтому контейнер может читать/писать по этой ссылке.
          - А раз папка на host-машине, то и данные сохраняются на постоянной основе.
          - В отличие от, как мы знаем, данных в контейнерах.
          - Volumes не зависят от контейнеров, при удалении последних не удаляются.

        • Можно в volume передать ссылку на общую между client/host папку
          - На host у нас имеется общая с client на Windows папка /c/users.
          - Можно в volume засунуть ссылку на неё и передать volume в контейнер.
          - Тогда контейне сможет работать прямо с данными на client (windows).

  > Управление общими папками в VirtualBox
    - Это актуально, если client и host это разные машины.
    - К примеру, client на Windows, а host на docker machine.
    - VirtualBox в этом случае расшаривает по умолчанию лишь 1 каталог.
    - Это: c:/users (client) <---> /c/users (host)
    - Но в настройках VirtualBox можно настроить ещё:

      • VirtualBox -> Настроить -> Общие папки

  > Создание объектов volume

    # Вывод списка всеъ объектов volume на host-машине
      - Можно просмотреть все объекты volume на host-машине.
      - В том числе увидеть именованный ли тот или иной объект.
      - Здесь предполагаем, что client и host это разные машины.
      - К примеру, client на Windows, а host на docker machine.
      - Тогда:

        • Сначала убедимся, что docker-машина запущена

            docker-machine ls             | список и статус docker-машин
            docker-machine start <name>   | если надо запустить машину <name>

        • Подключить powershell к docker-машине <name>

            docker-machine env --shell powershell <name>
            docker-machine env --shell powershell <name> | Invoke-Expression

        • Вывод списка объектов volume

            docker volume ls

    # Именованные / Не именованные

      • Не именованные объекты volume
        - Каждый объект volume должен иметь UID в пределах host-машины.
        - По умолчанию при создании объект volume получает примерно такой UID:
            b82577be399e690f61e4183c38bf28282bf2c9709133b142600906e24a20f176
        - Такие объекты volume называют не именованными.
        - Пример создания не именованного объекта volume:

            docker run -itd -v /myvolume ubuntu /bin/bash

        - !!! При этом volume связывается с создаваемым контейнером !!!

      • Именованные объекты volume
        - Однако можно задать объекту volume имя при его создании.
        - Такие объекты volume называют именованными.
        - Пример создания объекта volume с именем "somename":

            docker run -itd -v somename:/myvolume ubuntu /bin/bash

        - !!! При этом volume НЕ связывается с создаваемым контейнером !!!

    # С авто ссылкой / С ручной ссылкой

      • Пример объекта volume
        - К каждому контейнеру можно прикрепить >= 0 объектов volume.
        - Для каждого контейнера можно получить объект с его описанием.
        - В этом объекте будет ключ "mounts" с массивом.
        - В этом массиве будут связанные с контейнером объекты volume.
        - Вот так можно всё посмотреть:

          • Сначала убедимся, что docker-машина запущена

              docker-machine ls             | список и статус docker-машин
              docker-machine start <name>   | если надо запустить машину <name>

          • Подключить powershell к docker-машине <name>

              docker-machine env --shell powershell <name>
              docker-machine env --shell powershell <name> | Invoke-Expression

          • Посмотрим список контейнеров на хост-машине и их ID/имён:

              docker ps -l

          • Получим объект с описанием контейнера <name>:

              docker inspect <name>

        - Вот пример volume-объекта:

             {
                "Name": "b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507",
                "Source": "/mnt/sda1/var/lib/docker/volumes/b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507/_data",
                "Destination": "/myvolume",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
             }

        - Здесь:

            Name          | имя объектм volume
            Source        | ссылка на папку на host-машине
            Destination   | ссылка на папку в контейнере

      • С ручной ссылкой
        - При создании объекта volume можно указать <path>.
        - Это может быть путь к каталону на host-машине.
        - В том числе и общему с client-машиной каталогу.
        - Укажем ссылку на "/c/users/uerman" на host-машине:

            docker run -itd -v /c/users/german:/myvolume ubuntu /bin/bash

        - Теперь контейнер связан с только чтозданным volume объектом.
        - И у volume объекта:

           {
              ...
              "Source": "/c/users/german",
              "Destination": "/myvolume",
              ...
           }

      • С авто ссылкой
        - Однако можно и не указывать <path>, опустив его.
        - Сделаем это:

            docker run -itd -v /myvolume ubuntu /bin/bash

        - Теперь контейнер связан с только чтозданным volume объектом.
        - На host-машине в каталоге "/mnt/sda1/var/lib/docker/volumes/"
          была создана новая папка с именем == "Name" volume объекта.
        - Поэтому новый объект volume выглядит примерно так:

           {
              "Name": "b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507",
              "Source": "/mnt/sda1/var/lib/docker/volumes/b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507/_data",
              "Destination": "/myvolume",
              ...
           }

    # Создание объекта volume в DockerFile
      - Это сделать невозможно из-за зависимости <path> host-машины от оной.
      - Это ломает портативность, а DockerFile должен работать на всех host-машинах.
      - Инструкция VOLUME в DockerFile лишь:

        • Помечает точку монтирования.
        • Помечает, что контент из неё не идёт в образ.
        • Помечает, что она д.б. доступна другим контейнерам через --volumes-from

      - Ну типа, вот образ, а вот у него есть такие-то точки монтирования.
      - А в доках к образу написано, куда какие данные надо подключить.

  > Передача ссылок на объекты volume от одного контейнера другому

    # Суть дела
      - Допустим ты создал и запустил именованный контейнер "mystorage".
      - Во время создания ты связал его с набором объектов volumes:

        docker run -itd \
          -v /vol1 \
          -v /vol2 \
          -v /vol3 \
          -v /vol4 \
          -v /vol5 \
          --name mystorage \
          ubuntu /bin/bash

      - Затем ты собрался создать и запустить ещё контейнер с тем же набором объектов volumes.
      - Это д.б. не новые объекты volume, а ссылки на те самые, из примера выше.
      - Сделать это можно с помощью флага --volumes-from:

        docker run -itd \
          --volumes-from mystorage  \
          ubuntu /bin/bash

    # Создание (без запуска) спец.контейнера - пула ссылок на объекты volumes
      - Этот контейнер можно создать исключительно для этих целей.
      - Для хранения и передачи другим контейнерам пула ссылок на объекты volume.
      - Создать контейнер без запуска можно командой docker create:

          docker create \
            -v /vol1 \
            -v /vol2 \
            -v /vol3 \
            -v /vol4 \
            -v /vol5 \
            --name mystorage \

    # Внимание! Не допускать одновременную запись N-контейнеров в 1-ну volume-папку
      - Более 1-го контейнера могут иметь одинаковый пул ссылок на volume-объекты.
      - Это было описано выши и достигается с помощью флага --volumes-from.
      - Как следствие все эти контейнеры теоретически могут одновременно записывать в 1 каталог.
      - Следствием этого м.б. повреждение данных в этом каталоге.
      - Никакой встроенной защиты от этого нет, всё на пользователе.
      - Следует продумывать архитектуру для избежания подобных ситуаций.

    # Backup данных
      - В каталогах из ссылок объектом volume хранятся всякие постоянные данные.
      - А у нас, допустим, есть спец.контейнер с пулом ссылок на все эти volume-объекты.
      - С его помощью мы можем без проблем сделать бэкап всех данных.
      - Причём не только на host-машину, но даже и на client-машину.
      - А ведь client и host могут быть разными машинами.
      - К примеру, client на Windows, а host на docker machine.
      - По умолчанию у них 1 общая папка: c:/users (client) <---> /c/users (host)
      - Можно из контейнера делать бэкап прямо в эту общую папку.

        • Исходные условия
          - У нас имеется контейнер dbstore с пулом ссылок volume-объекты.
          - Для простоты предположим, что в пуле лишь 1-ин volume-объект.
          - И что у него "Destination": "/dbdata".
          - Нам требуется заархивировать /dbdata и положить в /с/users/backups.

        • Решение
          - Ниже представлено решение.
          - После выполнения команды tar контейнер самоуничтожится.

            docker run \                            | создать и запустить новый контейнер
              --rm \                                | удалить контейнер после завершения
              --volumes-from dbstore \              | связать контейнер с пулов объектом volume из контейнера dbstore
              -v /с/users/backups:/backup \         | создать новый объект volume с ручной ссылкой на /с/users/backups на host-машине, и адресом /backups в контейнере
              ubuntu \                              | создавать контейнер из образа ubuntu
              tar cvf /backup/backup.tar /dbdata    | заархивировать /dbdata и положить в /с/users/backups

    # Restore данных

      • Исходные условия
        - У нас имеется архив с /с/users/backups/backup.tar
        - Мы хотим создать новый контейнер и связать его с новым объектом volume.
        - У этого объекта должен быть "Destination": "/dbdata".
        - Мы хотим распаковать backup.tar в "/dbdata".

      • Решение
        - Ниже представлено решение.
        - Сначала надо создать и запустить новый контейнер.
        - Создать новый объект volume и связать его с этим контейнером.

            docker run \              | создать и запустить новый контейнер
              -v /dbdata \            | создать новый объект volume с авто.ссылкой и Destination == /dbdata, и связать с контейнером
              --name dbstore2 \       | назвать контейнер dbstore2
              ubuntu \                | создавать контейнер из образа ubuntu
              /bin/bash               | после создания запустить процесс /bin/bash

        - Затем надо загрузить в контейнер данные из backup.tar.
        - После выполнения команды tar контейнер самоуничтожится.

            docker run \                                                    | создать и запустить новый контейнер
              --rm \                                                        | удалить контейнер после завершения
              --volumes-from dbstore2 \                                     | связать контейнер с пулом объектов volume из контейнера dbstore2
              -v /с/users/backups:/backup \                                 | создать новый объект volume с ручной ссылкой на /с/users/backups на host-машине, и адресом /backups в контейнере
              ubuntu \                                                      | создавать контейнер из образа ubuntu
              bash -c "cd /dbdata && \                                      | перейти в каталог /cbdata
              tar xvf /backup/backup.tar --strip 1"                         | распаковать архив из /backup/backup.tar в текущий каталог

  > Удаление объектов volume

    # Удаление объекта volume при удалении контейнеров
      - Пусть у нас 3-ри контейнера связаны с 1-им объектом volume.
      - Вот что происходит при удалении этих контейнеров:

        docker rm <контейнер 1>     | volume не удалился
        docker rm <контейнер 2>     | volume не удалился
        docker rm <контейнер 3>     | volume не удалился

      - Как видно из примера, объект volume остался цел.
      - Но если при удалении последнего контейнера указать флаг -v

        docker rm -v <контейнер 3>  | volume удалился

    # Удаление объектов-зомби volume
      - Это объекты volume на которые уже не связаны ни с 1-им контейнером.
      - Они появляются при удалении всех связанных контейнеров без флага -v
      - Найти и удалить такие объекты volume можно так:

          docker volume ls -f dangling=true   | показать список объектов-зомби volume на host-машине
          docker volume rm <name>             | удалить объект volume с хост-машины

    # Прямое удаление объекта volume
      - Можно просто взять и вручную удалить объект volume.
      - Но использующие его контейнеры останутся с битыми ссылками.
      - Вот так это делается:

        docker volume ls                      | посмотреть список всех объектов volume на host-машине
        docker volume rm <name>               | удалить объект volume с хост-машины

  > Набор полезных code-tips

      docker-machine ls                             | список и статус docker-машин
      docker-machine start <name>                   | если надо запустить машину <name>
      docker-machine env --shell powershell <name>
      docker-machine env --shell powershell <name>  | Invoke-Expression
      docker ps -l                                  | список всех контейнеров на host-машине
      docker inspect <name>                         | объект с описанием контейнера <name> на host-машине
      docker volume ls                              | список всех объектов volume на host-машине

      docker-machine ssh <name>                     | подключиться по ssh к работающей docker-машине <name>
      docker exec -it <name> /bin/bash              | создать новый интерактивный процесс /bin/bash в контейнере <name>



А8. Сборка образов из DockerFile и контекста

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Что такое DockerFile
    # Использование

      - Контекст сборки
      - Название и путь к DockerFile
      - Репозиторий куда сохранить новый образ
      - Как применяется DockerFile
      - Инструкции выполняются независимо
      - Использование кэша для ускорения работы
      - Размещение образа на Docker Hub

    # Формат DockerFile

      - Как устроены комментарии
      - Инструкции не зависят от регистра
      - Первой инструкцией ДОЛЖНА быть FROM

    # Переменные среды, как переменные в DockerFile

      - Инструкция ENV
      - Чтение ENV-переменных
      - Экранирование переменных
      - Замена значения переменной осуществляется в конце инструкции
      - Переменные среды поддерживаются следующими DF-инструкциями

    # Про .dockerignore

      - Перед отправкой контекста docker-демон ищет .dockerignore
      - Формат .dockerignore
      - Пример .dockerfile
      - Все пробелы и ".", ".." по краям паттерна удаляются
      - Специальный wildcard **
      - Символ ! в начале строки означает исключение из правила исключения
      - Можно даже исключить DockerFile и .dockerignore из контекста
      - Паттерн . игнорируется по историческим причинам
      - Инверсия .dockerignore'а с помощью *! первым паттерном

    # Справка по инструкциям DockerFile

      - FROM          | Выбрать базовый образ, к нему будут применяться все последующие инструкции
      - MAINTAINER    |
      - RUN           |
      - CMD           |
      - LABEL         |
      - EXPOSE        |
      - ENV           |
      - ADD           |
      - COPY          |
      - ENTRYPOINT    |
      - VOLUME        |
      - USER          |
      - WORKDIR       |
      - ARG           |
      - ONBUILD       |
      - STOPSIGNAL    |





  --------------------------------------

  > Ссылки

    # Оф.справка "Dockerfile reference"
        https://docs.docker.com/engine/reference/builder/

    # Оф.справка "Best practices for writing Dockerfiles"
        https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/

    # Как создавать файл .dockerignore
        https://docs.docker.com/engine/reference/builder/#dockerignore-file

  > Введение
    - В этой главе раскрыта тема работы с DockerFile.
    - Присутствует справочник по инструкциям для него.

  > Что такое DockerFile
    - DF - это txt файл с инструкциями для создания Docker-образа.
    - Он может содержать все те команды, которые можно применять
      в CLI при создании нового образа.
    - Создать новый образ с помощью DF можно командой docker build.

  > Использование

    # Контекст сборки
      - Команда docker build соберает образ из DF и контекста.
      - В качестве контекста можно передать:

        • path    | локальный путь к каталогу
        • url     | url к репозиторию на github

      - Переданный контекст передаётся docker-демону рекурсивно.
      - Многие команды из DF могут обращаться к переданному контексту.
      - В простейшем случае контекстом м.б. текущий пустой каталог:

          docker build .

      - В файле .dockerignore можно исключать ф-лы/кат-ги из контекста.
      - Как создавать этот файл описано по ссылке из ссылок главы.

    # Название и путь к DockerFile
      - Традиционно этому файлу присваивают имя DockerFile.
      - И обычно его размещают в корневой каталог контекста.
      - Но никто не мешает назвать его как угодно по другому.
      - И поместить в любое другое место.
      - Однако, Docker по умолчанию ожидает "DockerFile" в корне контекста.
      - Указать путь к DockerFile вручную можно флагом -f:

          docker build -f /path/to/a/Dockerfile .

    # Репозиторий куда сохранить новый образ
      - Можно указать репозиторий для сохранения нового образа.
      - Можно даже указать какой-то конкретный тег для нового релиза.
      - Можно указать не 1, а много репозиториев:

          docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .

    # Как применяется DockerFile
      - Docker запускает инструкции из DF одну за одной.
      - Результаты выполнения инструкций применяет к новому образу.
      - В конце концов Docker возвращает ID нового образа.
      - Копия всего переданного контекста после этого удаляется.

    # Инструкции выполняются независимо
      - Каждая инструкция из DF выполняется независимо от других.
      - Например, инструкция "RUN cd /tmp" никак не повлияет на следующие.

    # Использование кэша для ускорения работы
      - Для ускорения работы Docker использует кэш промежуточных образов.
      - Во время осуществления сборки он сообщает об этом в терминале.

    # Размещение образа на Docker Hub
      - После сборки образа его можно разместить в Docker Hub.

  > Формат DockerFile

    # Как устроены комментарии
      - В DF можно писать комментарии, используя #.
      - Например:

          # Comment
          RUN echo 'we are running some # of cool things'

    # Инструкции не зависят от регистра
      - Однако принято писать их В ВЕРХНЕМ РЕГИСТРЕ.
      - Например: INSTRUCTION arguments

    # Первой инструкцией ДОЛЖНА быть FROM
      - Тут без вариантов, "FROM" обязана быть 1-й инструкцией в DF.
      - Эта инструкция позволяет указать базовый образ для сборки.

  > Переменные среды, как переменные в DockerFile

    # Инструкция ENV
      - Позволяет назначать назначать значения переменным среды.
      - А также могут использоваться в качестве переменных в DF.
      - Это позволяет передавать разные данные между инструкциями в DF.
      - Например:

          FROM busybox
          ENV foo /bar

    # Чтение ENV-переменных
      - Переменную foo можно читать, как $foo или ${foo}.
      - Оба вышеуказанных варианта являются эквивалентными.
      - Наличие 2-ух вариантов синтаксиса может пригодиться.
      - Синтакс с {} также поддерживает некоторые bash-модификаторы:

        • ${variable:-word}
          - Если variable not set, присвоить ей значение word.
          - Если variable is set, присвоить оставить это значение.

        • ${variable:+word}
          - Если variable is set, присвоить ей значение word.
          - Если variable not set, присвоить ей значение "".

      - Во всех случаях word м.б. любой строкой, включая ENV-переменные.

    # Экранирование переменных
      - Функционал экранирования переменных также присутствует.
      - Экранирование может осуществляться с помощью \
      - Это позволяет применять имена переменных буквально.
      - Например:

          COPY \$foo /quux    # COPY $foo /quux

    # Замена значения переменной осуществляется в конце инструкции
      - Нельзя в 1-ой инструкции заменить значение foo и тут же его использовать.
      - Пример:

          ENV abc=hello
          ENV abc=bye def=$abc    // $def == hello, а не bye
          ENV ghi=$abc            // ghi == buy, а не hello

    # Переменные среды поддерживаются следующими DF-инструкциями

      • ADD
      • COPY
      • ENV
      • EXPOSE
      • LABEL
      • USER
      • WORKDIR
      • VOLUME
      • STOPSIGNAL
      • ONBUILD       | (при комбинировании с одной из перечисленных выше)

  > Про .dockerignore

    # Перед отправкой контекста docker-демон ищет .dockerignore
      - Docker-демон ищет файл .dockerignore в корне контекста.
      - Если файл DI существует, docker-демон считывает его.
      - DI содержит список путей для исключения из контекста.
      - Перед отправкой контекста из него исключаются эти пути.
      - Это позволяет избежать пересылки docker-демону лишних файлов.

    # Формат .dockerignore
      - Это разделённый символами новой строки список glob-паттернов.
      - Корневым каталогом вчитается корень контекста DockerFile.

    # Пример .dockerfile

        */temp*
        */*/temp*
        temp?

      Пояснения

        • */temp*
          - Исключает ф-лы и кат-ли с начинающимися с temp именами.
          - Из любого подкаталого 1-го уровня относительно корня.
          - Примеры: /dir1/temprary.txt, /dir2/temp

        • */*/temp*
          - Исключает ф-лы и кат-ли с начинающимися с temp именами.
          - Из любого подкаталого 2-го уровня относительно корня.
          - Примеры: /dir1/dir2/temprary.txt, /dir3/dir4/temp

        • temp?
          - Исключает ф-лы и кат-ли с начинающимися с temp именами,
            состоящие из 5 символов, где 5-й символ м.б. любым.
          - Примеры: /tempa, /tempb

    # Все пробелы и ".", ".." по краям паттерна удаляются
      - Матчинг проводится с помощью правил filepath.Match языка Go.
      - Все пробелы и ".", ".." по краям паттерна удаляются
        с помощью filepath.Clean языка Go.
      - Пустые строки игнорируются.

    # Специальный wildcard **
      - Он не поддерживается filepath.Match языка Go.
      - Но Docker поддерживает этот wildcard.
      - Он означает любое кол-во каталогов, включая нулевое.

    # Символ ! в начале строки означает исключение из правила исключения
      - До или после любого правила можно добавить исключения.
      - На самом деле, исключения можно добавлять в любое место .dockerignore
      - Каждое исключение должно начинаться с !
      - Например:

          *.md          | не передавать все *.md из корневого каталога
          !README.md    | кроме этого файла, его передавать

      - Позиция исключения в .dockerignore влияет на результаты.
      - Рассмотрим два примера для иллюстрации этого утверждения:

        • Пример №1
          - В контекст не включаются .md-файлы, кроме README-secret.md.

            *.md
            !README*.md
            README-secret.md

        • Пример №2
          - Все начинающиеся с README файлы включаются в контекст.
          - Строка README-secret.md, поскольку она идёт до, перекрывается
            строкой !README*.md

            *.md
            README-secret.md
            !README*.md

    # Можно даже исключить DockerFile и .dockerignore из контекста
      - Можно добавить их в .dockerignore и исключить из контекста.
      - При этом они всё равно будут отправлены docker-демону.
      - Ведь docker-демону они просто необходимы для работы.
      - Но вот в инструкциях типа ADD, COPY они уже будут недоступны.

    # Паттерн . игнорируется по историческим причинам
      - Сабж.

    # Инверсия .dockerignore'а с помощью *! первым паттерном
      - Можно инвертировать весь .dockerignore.
      - Для этого 1-ым паттерном надо написать: *!
      - Обычные инструкции будут указывать пути для включения.
      - Инструкции с ! указывать пути для исключения.

  > Справка по инструкциям DockerFile

    // FROM //
    //------//
    // - Выбрать базовый образ, к нему будут применяться все последующие инструкции.
    // - Это инструкция ДОЛЖНА БЫТЬ 1-ОЙ в DockerFile.
    // - Это может быть образ с Docker Hub, или локальный образ.

      # Синтаксис

        • FROM <image>
        • FROM <image>:<tag>
        • FROM <image>@<digest>

      # Примечания

        • FROM должна быть первой инструкцией-не-комментарием в DockerFile.
        • FROM может появляться >= 1 раза в одном DockerFile
          - Это позволит в 1-ом DockerFile создать несколько образов.
        • Значения <tag> и <digest> опциональны
          - Применяется значение latest если их опустить.
          - Билдер вернёт ошибку если не сможет найти соотв.тегу релиз.

    // MAINTAINER //
    //------------//
    // - Указать автора генерируемого образа.

      MAINTAINER YOUR NAME <YOUR EMAIL>

    // RUN //
    //-----//
    // - Выполнить command/exec и закоммитить результат в образ

      # RUN имеет 2-ве формы

        • Shell-форма
          - Команда запускается в командной строке.
          - В качестве обработчика по умолчанию используется /bin/sh.
          - Формат и пример:

              RUN <command>
              RUN /bin/sh

          - Можно использовать \ для разделения строк команды.
          - Например это считается 1-ой RUN-командой:

              RUN /bin/bash -c 'source $HOME/.bashrc ;\
              echo $HOME'

        • Exec-форма
          - Запускается указанная программа из исполняемого файла.
          - Как обычно, обработчик для неё указывается в начале файла.
          - Формат:

              RUN ["executable", "param1", "param2"] (exec form)

          - Примеры обработчиков в начале файлов:

              #!/bin/bash
              #!/bin/node

          - Использование exec-формы позволяет избежать путаницы.
          - Exec-форма орабатывается, как JSON-массив.
          - Поэтому следует вместо '' использовать "" везде.
          - В отличие от shell-формы, exec-форма не подставляет переменные.
          - Потому что при выполнении exec командная оболочка не выполняется.
          - Например, что-то типа этого не сработает:

              RUN [ "echo", "$HOME" ]     | переменная $HOME не подставится

          - Чтобы исправить дело, надо вручную выполнять командную оболочку.
          - Например:

              RUN [ "sh", "-c", "echo", "$HOME" ]

      # Использование отличной от /bin/sh оболочки
        - Для этого надо воспользоваться exec-формой.
        - Например, если нужен /bin/bash:

            RUN ["/bin/bash", "-c", "echo hello"]

      # Кэш для RUN-инструкций не истекает автоматически между билдами
        - Допустим делали билд и выполнили в нём RUN-инструкцию:

            RUN apt-get dist-upgrade -y

        - При этом результат её выполнения закэшировался Docker'ом.
        - Потом вы решаете сделать другой билд с такой же инструкцией.
        - На этот раз никакой работы не происходит, результат берётся из кэша.
        - Но можно запретить кэширование с помощью флага --no-cache:

            RUN apt-get dist-upgrade -y --no-cache

        - Также кэш RUN-инструкций м.б. инвалидирован ADD-инструкциями.

    // CMD //
    //-----//
    // - Команда по умолчанию при запуске контейнера из этого образа.
    // - Подоглавление
    //
    //    • Пояснения к ENTRYPOINT
    //    • Пояснения к CMD
    //    • CMD имеет 3 формы
    //    • Примечания
    //

      # Пояснения к ENTRYPOINT
        - Термином "entrypoint" называют обработчик по умолчанию.
        - Изначально в Docker в качестве EP используется /bin/sh -c.
        - И если запустить такой код:

            docker run -i -t ubuntu bash

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Поэтому bash будет запущен с помощью EP == /bin/sh.
        - То есть, вот таким образом: /bin/sh -c bash
        - Потом народ запросил возможность указывать другой EP.
        - Появился параметр -entrypoint и инструкция ENTRYPOINT.
        - Как ENTRYPOING могут быть полезны на примере:

          Исходная ситуация
            • У нас есть образ с Redis.
            • Его данные хранятсв volume вне образа.
            • Мы хотим запросить данные из хранилища по ключу.
            • Сейчас мы можем это сделать примерно так:

                docker run redisimg redis -H something -u toto get key

          Упрощение с помощью ENTRYPOINT
            • Берём и делаем в DockerFile такой EntryPoint:
                ENTRYPOINT ["redis", "-H", "something", "-u", "toto"]
            • Благодаря этому запрос из хранилища по ключу упростился:

                docker run redisimg get key

      # Пояснения к CMD
        - Выше мы узнали о существовании entrypoint по умолчанию.
        - Но вот команды по умолчанию нет, это пустая строка.
        - Но её можно задать с помощью инструкции CMD в DockerFile.
        - Допустим, мы задали: CMD bash
        - Тогда при выполнении:

            docker run -i -t ubuntu

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Хоть мы и не указали bash после ubuntu, она выполнилась.
        - Потому что мы указали bash в кач-ве CMD в DockerFile.

      # CMD имеет 3 формы

        • Exec-форма
          - Основной формат для CMD:

              CMD ["executable","param1","param2"]

        • Default-форма
          - Можно передать лишь параметры для entrypoint:

              CMD ["param1","param2"]

        • Shell-форма
          - Тоже самое, что exec, только здесь вместо exec указывают команду:

              CMD command param1 param2

      # Примечания

        • Если использована default-форма CMD
          - То ENTRYPOINT тоже ОБЯЗАНА присутствовать.
          - И обе инструкции д.б. в JSON-формате.

        • Exec-форма парсится, как JSON массив
          - То есть везде вместо '' надо применять "".

        • В отличие от shell-формы, exec-форма не подставляет переменные
          - Потому что при выполнении exec командная оболочка не выполняется.
          - Например, что-то типа этого не сработает:

              RUN [ "echo", "$HOME" ]     | переменная $HOME не подставится

          - Чтобы исправить дело, надо вручную выполнять командную оболочку.
          - Например:

              RUN [ "sh", "-c", "echo", "$HOME" ]

        • Если вы выбрали shell-форму
          - То <command> будет выполнено тем, что указано в entrypoint.
          - По умолчанию там указано /bin/sh -c
          - Но можно запустить <command> и без оболочки.
          - Для этого надо передать значение в формате JSON-массива.
          - Эта JSON-форма является предпочтительной для CMD.
          - Пример:

              CMD ["/usr/bin/wc","--help"]

        • CMD в DockerFile м.б. перезаписан параметром в docker run
          - Сабж.

        • Не перепутай CMD с RUN
          - RUN во время сборки запускает команду и коммитит результат.
          - CMD к сборке образа не имеет никакого отношения.
          - Она срабатывает лишь при запуске контейнера на основе этого образа.

    // LABEL //
    //-------//
    // - Метаданные для образа в формате ключ=значение
    // - В одном DockerFile можно использовать несколько LABEL.

      # Примеры применения LABEL

        LABEL "com.example.vendor"="ACME Incorporated"
        LABEL com.example.label-with-value="foo"
        LABEL version="1.0"
        LABEL description="This text illustrates \
        that label-values can span multiple lines."

      # Помните про ограничение 127 слоёв
        - Каждый LABEL, как и другие инструкции, образует новый слой.
        - Но при этом особой важности для образа не имеет.
        - Большое кол-во LABEL можен тестолково потратить эти 127 мест.
        - Эффективнее было бы впихнуть нужную информацию в 1-ин LABEL.
        - Вот ещё примеры:

            LABEL multi.label1="value1" multi.label2="value2" other="value3"
            LABEL multi.label1="value1" \
                  multi.label2="value2" \
                  other="value3"

      # Как посмотреть LABELS конкретного образа
        - Для этого надо использовать команду docker inspect.
        - Нужная информация будет в объекте с ключём "Labels".

    // EXPOSE //
    //--------//
    // - Информировать Docker'а, что контейнеру нужны такие-то порты
    // - Внимание! Это НЕ открывает соответствующие порты для контейнера.
    // - Открыть все "выставленные" порты можно флагом -P при docker run.
    // - Пробросить любые порты при docker run можно флагом -p (p в нижнем регистре).

      EXPOSE <port> [<port>...]

    // ENV //
    //-----//
    // - Назначить переменные среды для нижележащих инструций аля <key> <value>.
    // - Можно в одной инструкции назначить от 1-й и более пар.
    // - Их можно использовать в качестве переменных в нижележащих инструкциях.

      # Форматы

        • Формат №1
          - Вся строка после <key> будет рассматриваться, как <value>

              ENV <key> <value>

        • Формат №2
          - Можно указать сколько угодно пар <key>=<value> через пробел.

              ENV <key>=<value> ...

      # Примеры
        - Ниже пара примеров, которые эквивалентны.
        - 1-ый вариант предпочтительнее, он создаёт лишь 1 слой.

            ENV myName="John Doe" myDog=Rex\ The\ Dog \
                myCat=fluffy

            ENV myName John Doe
            ENV myDog Rex The Dog
            ENV myCat fluffy

      # ENV-переменные сохраняются у образа напостоянной основе
        - Вот какой-то разработчик сделал образ.
        - И у него в DockerFile был такой слой:

            ENV DEBIAN_FRONTEND noninteractive

        - Затем вы решили сделать свой образ на основе его образа.
        - В вашем DockerFile доступна переменная DEBIAN_FRONTEND.
        - И в запущенном из образа контейнере она тоже будет доступна.
        - Если Вы её не заметите, то у вас apt-get работать нормально не будет.

      # Посмотреть ENV-переменные образа можно через docker inspect
        - Надо искать ключ "env".

      # Изменить ENV-переменную при запуске можно ключём --env
        - Например:

            docker run --env <key>=<value>

    // ADD //
    //-----//
    // - Копирует файлы/каталоги из <src> в <dest> контейнера.
    // - В качестве <src> могут быть локальные (path) и удалённые (url).
    // - Подоглавление
    //
    //    • Форматы
    //    • Wildcards в <src>
    //    • Все новые файлы и каталоги создаются с UID == GID == 0
    //    • Если <src> это URL
    //    • Набор замечаний
    //    • ADD подчиняется следующим правилам
    //    •
    //

      # Форматы

        • Формат №1
          - Можно указать от 1 и больше <src> и один <dest>.
          - Если <src> локальные, путь д.б. относительно корня контекста.

              ADD <src>... <dest>

          - <dest> м.б. абсолютным path.
          - Или относительным с корнем в WORKDIR, куда источники будут скопированы.

              ADD test relativeDir/          # adds "test" to `WORKDIR`/relativeDir/
              ADD test /absoluteDir/         # adds "test" to /absoluteDir/

        • Формат №2
          - Эта форма для путей, содержащих пробелы.

              ADD ["<src>",... "<dest>"]

      # Wildcards в <src>
        - Каждый <src> представляет glob-шаблон.
        - Т.Е. можно применять всякие: * / ? / т.д.
        - Всё это обрабатывается с помощью filepath.Math в GO.
        - Например:

            ADD hom* /mydir/        # adds all files starting with "hom"
            ADD hom?.txt /mydir/    # ? is replaced with any single character, e.g., "home.txt"

      # Все новые файлы и каталоги создаются с UID == GID == 0
        - Сабж.

      # Если <src> это URL

        • Всё в <dest> будет иметь chmod 600.
        • Если вернётся HTTP-заголовок Last-Modifyed
          - Он будет использован для установки mtime файлов в <dest>.
          - Однако, mtime не применяется для того, чтобы определить,
            обновился ли файл, и надо ли обновить кэш.

      # Набор замечаний

        • Если DockerFile передаётся в docker build через STD IN
          - В этом случае контекст полностью отсутствует.
          - Поэтому в ADD могут быть лишь <src> с URL.
          - Пример:

              docker build - < somefile

          - Кроме случая, когда передаётся архив.
          - DockerFile должен лежать в корне этого архива.
          - Всё остальное в нём будет рассматриваться в кач-ве контекста.
          - Пример:

              docker build - < archive.tar.gz

        • Если <src> это URL требующий аутентификации
          - Тогда надо использовать RUN wget / RUN curl / другой инструмент.
          - Поскольку инструкция ADD не поддерживает аутентификацию.

        • Замечание по поводу инвалидации кэша инструкцией ADD
          - Кэш инвалидируется в случае изменения содержимого по адресу <src>.
          - Кэш инвалидируется для всех последующих инструкций в Dockerfile.
          - В том числе и для инструкции RUN.

      # ADD подчиняется следующим правилам

        • Локальный <src> не может быть абсолютным
          - Это должен быть относительный локальный путь.
          - В качестве root используется корень контекста.

        • Если <src> URL, а <dest> НЕ заканчивается на /
          - То файл из <src> просто копируется в <dest>.

        • Если <src> URL, а <dest> заканчивается на /
          - То имя для файла из <src> берётся из URL.
          - И файл копируется по адресу <dest>/<filename>
          - Например:

              ADD http://example.com/foobar /

          - Это создаст файл: /foobar
          - Кроме того, URL в <src> должен иметь URI, отличный от /
          - Например, такой URL не сработает, т.к. неоткуда брать <filename>:

              http://example.com

        • Если <src> является каталогом
          - То весь контент каталога копируется.
          - Включая метаданные файловой системы.
          - Сам же каталог не копируется, только его содержимое.

        • Если по адресу <src> находится архив
          - Если это локальный path, архив будет распакован в <dest>.
          - Если это URL, то архив НЕ будет распакован, а будет скопирован в <dest>.

        • Если <src> это файл
          - Он копируется индивидуально, в соотв. со своими метаданными.
          - Плюс см.выше особенности, если <dest> заканчивается или нет на /

        • Если указаны более 1-го <src>
          - Не важно, прямо или с использованием wildcards.
          - Тогда <dest> ОБЯЗАН быть каталогом и заканчиваться на /

        • Если <dest> не заканчивается на /
          - То он будет считаться обычным файлом.
          - И содержимое <src> будет записано в этот файл <dest>.

        • Если <dest> не существует
          - Он будет автоматически создан.


    // COPY //
    //------//
    // - Аналог ADD, но без tar и URL возможностей.

    // ENTRYPOINT //
    //------------//
    // - Позволяет превратить контейнер в некий сервис.
    // - Подоглавление
    //
    //    • Форматы
    //    • Пояснения к ENTRYPOINT
    //    • Превращение контейнера в сервис на примере
    //    • Пояснения к CMD
    //    • ENTRYPOINT м.б. перезаписана с помощью флага --entrypoint
    //    • Только последняя инструкция ENTRYPOINT в DockerFile имеет силу
    //
    //    • Пример работы с exec-форматом ENTRYPOINT
    //    • Пример работы с shell-форматом ENTRYPOINT
    //

      # Форматы

        • Формат №1
          - Это exec-формат, он является предпочтительным.
          - Формат:

              ENTRYPOINT ["executable", "param1", "param2"]

        • Формат №2
          - Это shell-формат (не рекомендуется).
          - Предотвращает использование CLI-аргументов CMD и run.
          - При этом ENTRYPOINT выполняется, как подкаманда /bin/sh -c
          - А последний не передаёт никаких сигналов от ОС.
          - То есть исполняемая не будет PID 1 контейнера.
          - А значит, например, сигнал выключения контейнера docker stop <container>
            не будут доходить.
          - Формат:

              ENTRYPOINT command param1 param2

      # Пояснения к ENTRYPOINT
        - Термином "entrypoint" называют обработчик по умолчанию.
        - Изначально в Docker в качестве EP используется /bin/sh -c.
        - И если запустить такой код:

            docker run -i -t ubuntu bash

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Поэтому bash будет запущен с помощью EP == /bin/sh.
        - То есть, вот таким образом: /bin/sh -c bash
        - Потом народ запросил возможность указывать другой EP.
        - Появился параметр -entrypoint и инструкция ENTRYPOINT.

      # Превращение контейнера в сервис на примере
        - Исходная ситуация
            • У нас есть образ с Redis.
            • Его данные хранятсв volume вне образа.
            • Мы хотим запросить данные из хранилища по ключу.
            • Сейчас мы можем это сделать примерно так:

                docker run redisimg redis -H something -u toto get key

        - Упрощение с помощью ENTRYPOINT
            • Берём и делаем в DockerFile такой EntryPoint:
                ENTRYPOINT ["redis", "-H", "something", "-u", "toto"]
            • Благодаря этому запрос из хранилища по ключу упростился:

                docker run redisimg get key

        - Рассмотрим повнимательнее, что именно здесь происходит.
        - Каким образом будет формироваться итоговая команда:

          • Сначала идёт: docker run <image>
          • Потом аргументы из ENTRYPOINT: redis -H something -U toto
          • Потом идёт то, что было справа от docker run <image>: get key.
          • Итог: docker run redisimg redis -H something -U toto get key
          • Иллюстрация:

              docker run <image>   Аргументы из ENTRYPOINT    Аргументы команды
              -------------------|--------------------------|------------------
              docker run redisimg redis -H something -U toto get key

      # Пояснения к CMD
        - Выше мы узнали о существовании entrypoint по умолчанию.
        - Но вот команды по умолчанию нет, это пустая строка.
        - Но её можно задать с помощью инструкции CMD в DockerFile.
        - Допустим, мы задали: CMD bash
        - Тогда при выполнении:

            docker run -i -t ubuntu

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Хоть мы и не указали bash после ubuntu, она выполнилась.
        - Потому что мы указали bash в кач-ве CMD в DockerFile.

      # ENTRYPOINT м.б. перезаписана с помощью флага --entrypoint
        - Например: docker run --entrypoint

      # Только последняя инструкция ENTRYPOINT в DockerFile имеет силу
        - Сабж.

      # Пример работы с exec-форматом ENTRYPOINT

        • Применяйте ENTRYPOINT для стабильных команд и аргументов
          - Которые должны присутствовать при docker run всегда.
          - А CMD для дополнительных, которые скорее всего заменяются.
          - Например:

              FROM ubuntu
              ENTRYPOINT ["top", "-b"]
              CMD ["-c"]

          - Вот как это будет работать

              docker run ubuntu             // Вызовет: docker run ubuntu top -b -c
              docker run ubuntu -a          // Вызовет: docker run ubuntu top -b -a

        • После запуска контейнера убедитесь, что top 1-нный процесс
          - То есть он не является подпроцессом, скажем, /bin/sh
          - А является единственным процессом, запущенном в контейнере.
          - Пример:

              docker run -it --rm --name test  top -H

          - А для уже работающего контейнера:

              docker exec -it test ps aux

        • Следствием обладания PID == 1 является возможность получать сингналы
          - Допустим в контейнере запущен 1 процесс top с PID == 1.
          - Docker может послать контейнеру test сигнал docker stop test.
          - Процесс top получит этот сигнал и мягко (gracefully) завершится.

        • Пример запуска apache в фореграунд с PID == 1

            FROM debian:stable
            RUN apt-get update && apt-get install -y --force-yes apache2
            EXPOSE 80 443
            VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]
            ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]

        • Как в скрипте убедиться, что final executable получает unix-сигналы
          - С помощью команд exec и gosu.
          - Например:

              #!/bin/bash
              set -e

              if [ "$1" = 'postgres' ]; then
                  chown -R postgres "$PGDATA"

                  if [ -z "$(ls -A "$PGDATA")" ]; then
                      gosu postgres initdb
                  fi

                  exec gosu postgres "$@"
              fi

              exec "$@"

        • Можно даже повесить хук на завершение работы
          - Допустим вы запустили контейнер со своей bash-программой.
          - И в случае получения сигнала завершения надо сделать некую работу.
          - Что-нибудь подчистить, например, или провзаимодействовать с другими контейнерами.
          - Тогда следует убедиться в том, что скрипт в ENTRYPOINT получает unix-сигналы,
            пропускает их, и выполняет некую работу.
          - Пример:

              #!/bin/sh
              # Note: I've written this using sh so it works in the busybox container too

              # USE the trap if you need to also do manual cleanup after the service is stopped,
              #     or need to start multiple services in the one container
              trap "echo TRAPed signal" HUP INT QUIT KILL TERM

              # start service in background here
              /usr/sbin/apachectl start

              echo "[hit enter key to exit] or run 'docker stop <container>'"
              read

              # stop service and clean up here
              echo "stopping apache"
              /usr/sbin/apachectl stop

              echo "exited $0"

        • Ряд замечаний

          • Можно перезаписать ENTRYPOINT с помощью флага --entrypoint
            - Во время использования docker run.
            - В этом случае будет использовать exec-формат ENTRYPOINT.

          • Exec-формат парсится, как JSON-массив
            - Поэтому везде надо использовать '' вместо "".

          • В отличии от shell-формата, exec-формат не запускает командную оболочку
            - Это означает, что обычного оболочечного процесса не происходит.
            - Для примера рассмотрим:

                ENTRYPOINT [ "echo", "$HOME" ]

            - Никакой подстановки значения $HOME не произойдёт.
            - Чтобы оболочечный процесс сработал, надо вручную вызвать оболочку.
            - Например:

                ENTRYPOINT [ "sh", "-c", "echo", "$HOME" ]

            - Однако подстановка ENV-переменных будуте производиться
              в любом случае парсером DockerFile.

      # Пример работы с shell-форматом ENTRYPOINT

        • В качестве ENTRYPOINT можно указать обычную строку
          - Тогда будет запущен процесс /bin/sh -c
          - И эта строка будет исполнена в нём.
          - Любые аргументы из CMD и docker run будут проигнорированы.

        • Лучше начинать с exec
          - Рассмотрим пример:

              FROM ubuntu
              ENTRYPOINT exec top -b

          - И запустим его:

              docker run -it --rm --name test top

          - Мы увидим лишь 1 процесс top с PID == 1.
          - При поступлении сигнала завершения от Linux от мягко завершится.
          - Но если забыть указать "exec" в "exec top -b", например:

              FROM ubuntu
              ENTRYPOINT top -b
              CMD --ignored-param1

          - То в top будут 2 процесса: /bin/sh с PID == 1, и top.
          - В этом случае все сигналы от Linux будет получать /bin/sh.
          - В результате завершать процесс top мягко будет невозможно.
          - Top будет завершаться жёстко после таймаута при поступлении
            от Linux сигнала завершения в /bin/sh.

    // VOLUME //
    //--------//
    // - Монтирует в контейнер каталоги с хоста или других контейнеров.

      

    // USER //
    //------//
    // -


    // WORKDIR //
    //---------//
    // -


    // ARG //
    //-----//
    // -


    // ONBUILD //
    //---------//
    // -


    // STOPSIGNAL //
    //------------//
    // -







