////==================================================////
////                                                  ////
////                      Docker                      ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Официальный сайт Docker
        https://www.docker.com/

    # Оф.панель управления и хаб Docker
        https://hub.docker.com/

    # Серия оф.вводных видео-тренингов по Docker
        https://training.docker.com/self-paced-training

    # Официальная документация Docker
        https://docs.docker.com/

  // Видео //
  //-------//

    # Плейлист от LearnCode по базовым принципам Docker
        https://www.youtube.com/playlist?list=PLoYCgNOIyGAAzevEST2qm2Xbe3aeLFvLc

  // Текст //
  //-------//

    # 350+ полезных статей про Docker
        https://habrahabr.ru/company/1cloud/blog/275015/

    # Docker for PHP Developers
    # - Efficient Nginx, PHP, and MySQL development environments with Docker
    # - Подробнейшая, потрясающая статья про Docker from JOSH LOCKHART
        http://www.newmediacampaigns.com/blog/docker-for-php-developers

    # Laravel 5 with dockerized Gulp, PHP-FPM, MySQL and nginx
    # Краткий how-to
        http://harshjv.github.io/blog/laravel-5-with-dockerized-gulp-php-fpm-mysql-and-nginx/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Docker

    А1. Архитектура Docker
    А2. Установка Docker
    А3. Запуск приложений в Docker-контейнерах
    А4. Создание собственных Docker-образов
    А5. Работа с Docker Machines
    А6. Docker-сети, объединение и взаимодействие контейнеров в сетях
    А7. Управление данными в/между контейнерами
    А8. Сборка образов из DockerFile и контекста
    А9. Поиск и добавление образов на Docker Hub
    А10. Справочник по командам docker
    А11. Docker Compose

  # Б.  Рецепты и наработки

    Б1. ...







////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Архитектура Docker

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Что такое Docker

      - Вводная информация
      - Изолированные контейнеры

    # Как можно использовать Docker

      - Быстрая разработка приложений
      - Лёгкое разворачивание и масштабирование
      - Более эффективное использование серверного железа

    # Главные компоненты Docker
    # Клиент-серверная архитектура Docker

      - Клиент-серверная
      - Иллюстрация
      - Подробнее о сервере и клиенте

    # Образы, контейнеры, репозиторий

      - Docker-образы
      - Docker-контейнеры
      - Docker-репозиторий

    # Как работает Docker

      - Вводная информация
      - Как работают Docker-образы, ФС union

        - Слои: вводная информация
        - Слои: причина быстрой работы Docker
        - Каждый Docker-образ наследует от некого базового образа
        - Инструкции для создания образов, DockerFile

      - Как работает Docker-репозиторий
      - Как работают Docker-контейнеры
      - Что происходит при run контейнера

    # Важный функционал ядра Linux, используемый Docker

      - Docker написан на Go
      - Namespaces
      - Control groups
      - Union file systems
      - Container forman

  --------------------------------------

  > Ссылки

    # Оф.статья "Understand the architecture"
        https://docs.docker.com/engine/understanding-docker/

  > Введение
    - В этой главе описана архитектура Docker.
    - Её прочтение должно сформировать чёткое представление об оной.

  > Что такое Docker

    # Вводная информация
      - Открытая платформа для разработки, доставки и запуска приложений.
      - Он позволяет отделить приложение от инфраструктуры.
      - И рассматривать последнюю, как управляемое отдельное приложение.
      - Docker сокращает цикл между написанием/использованием кода,
        и позволяет быстрее:

          # Разрабатывать
          # Тестировать
          # Разворачивать

      - Что позволяет Docker'у обеспечивать подобные преимущества:

          # Использование технологий контейнеризации ядра Linux
          # Наличие инструментов ускорения рабочего процесса, позволяющих
            удобно и быстро управлять приложением, и разворачивать его

    # Изолированные контейнеры
      - Docker позволяет запускать почти любое приложение в контейнере.
      - При этом приложение надёжно изолировано от других контейнеров.
      - Изоляция и безопасность позволяют запускать N контейнеров на 1 хосте.
      - Контейнеры же очень легковесны, ведь они не отягощены гипервизорами.
      - Легковесность контейнеров позволяют получать больше от серверного железа.
      - Примеры того, для чего можно использовать контейнеры:

          # Размещать в них приложения/компоненты
          # Передавать контейнеры членам команды для дальнейшей разработки/тестирования
          # Разворачивать приложения на продакшн-серверах: в датацентрах/облаках

  > Как можно использовать Docker

    # Быстрая разработка приложений
      - Docker является отличным инструментом для улучшения процесса разработки.
      - Команда разработчиков может собрать среду приложения локально из контейнеров.
      - Все члены команды при этом используют на 100% гарантированно идентичную среду.
      - Когда придёт время развернуть приложение, можно использовать эту же самую среду.

    # Лёгкое разворачивание и масштабирование
      - Docker-контейнеры по природе своей очень портативны.
      - Их можно запускать на localhost/в дата-центре/в облаке/на виртуалке/и т.д.
      - Портативность и легковесность контейнеров позволяют легко балансировать нагрузку.
      - С учётом всего этого, скорость работы Docker м.б. близка к realtime.

    # Более эффективное использование серверного железа
      - Docker является более эффективной альтернативой виртуальным машинам.
      - Имея в виду, что Docker потребляет намного меньше ресурсов.
      - Особенно ярко это проявляется при применении на забитом до отказа сервере.

  > Главные компоненты Docker
    - Docker состоит из 2-ух главных компонентов:

      # Docker
        - Платформа для контейнеризации с открытым исходным кодом.

      # Docker Hub
        - Software-as-a-Service платформа.
        - Она позволяет хранить и управлять Docker-контейнерами.
        - Это как GitHub, но только для Docker-образов.

  > Клиент-серверная архитектура Docker

    # Клиент-серверная
      - В Docker применяется клиент-серверная архитектура:

        # Docker-сервер
          - Это демон, который отвечает за управление Docker-контейнерами.
          - За их создание / работу / перемещение / ... .

        # Docker-клиент
          - Это CLI-приложение для взаимодействие с Docker-сервером.

      - Docker-сервер и Docker-клиент могут работать в 1-й системе.
      - А можно с помощью Docker-клиента управлять удалённым Docker-сервером.
      - Клиент и сервер взаимодействуют через сокеты посредством RESTful API.

    # Иллюстрация

                         |--------------|
                         | Client       | Клиент может находитсья на host-машине.
                         |              | А может вне её, на каком-нибудь другом компе.
                         | docker build | Клиент имеет CLI-API для управления сервером.
                         | docker pull  |
                         | docker run   |
                         |--------------|
                                |
                                |
       |------------------------|----------------|      |---------------------------|
       | DOCKER_HOST            |                |      |  Docker Hub (репозиторий) |
       |                       \|/               |      |                           |
       |    |------------------------------|     |      |      |------------|       |
       |    |         Docker daemon        |----------------   |   Images   |       |
       |    |------------------------------|     |      |  |   |------------|       |
       |                                         |      |  |                        |
       |                                         |      |  |      |------|          |
       |                                         |      |  |      | img1 |          |
       |    |------------|    |------------|     |      |  |      |------|          |
       |    | Containers |    |   Images   |     |      |  |---                     |
       |    |------------|    |------------|     |      |      \->|------|          |
       |                                         |      |         | img2 |          |
       |      |--------|         |------|      -------------------|------|          |
       |      |--------|         | img1 |     /  |      |                           |
       |                         |------|    /   |      |---------------------------|
       |      |--------|                    |    |
       |      |--------|         |------|<--|    |        Это SAAS от создателей Docker.
       |                         | img2 |        |        Репозитогий готовых образов для него.
       |      |--------|         |------|        |        Это как GitHub, но только для Docker-образов.
       |      |--------|                         |        Сервер их может отсюда подтягивать.
       |                                         |        А может их сюда и загружать.
       |-----------------------------------------|

         Это host-машина, где запускается Docker-сервер.
         Хост-машиной всегда должен быть именно Linux.


    # Подробнее о сервере и клиенте

      ## Docker-сервер (демон)
        - Docker-сервер запускается на host-машине.
        - Пользователь напрямую не взаимодействует с ним прямо.
        - А взаимодействует чере CLI Docker-клиента.

      ## Docker-клиент
        - Представляет из себя CLI-приложение.
        - Это основной интерфейс для взаимодействия с Docker-сервером.

  > Образы, контейнеры, репозиторий

    # Docker-образы
      - Представляют из себя read-only шаблоны.
      - Например, образ может содержать Ubuntu + Nginx.
      - Образы используются для создания контейнеров.
      - Можно применить метафору: образ - класс, контейнер - объект.
      - Образы можно создавать / обновлять / скачивать с DH / заливать на DH.
      - Docker-образы представляют BUILD-компонент Docker'а.

    # Docker-контейнеры
      - Можно применить метафору: контейнер - каталог.
      - В каждом каталоге необходимые для работы приложения данные.
      - Чтобы приложение заработало, надо собрать вместе эти каталоги.
      - Каждый Docker-контейнер создаётся из Docker-образа.
      - Контейнеры могут быть: run / started / stopped / moved / deleted.
      - Docker-контейнеры представляют RUN-компонент Docker'а.

    # Docker-репозиторий
      - Docker-репозиторий называется Docker Hub.
      - В Docker-репозитории хранятся Docker-образы.
      - Как обычно, есть публичные и приватные репозитории (последние платные).
      - В нём уже существует огромное количество готовых к использованию образов.
      - Можно самому создавать образы, и размещать их в Docker Hub.
      - Docker-репозиторий представляет DISTRIBUTION-компонент Docker'а.

  > Как работает Docker

    # Вводная информация
      - Итак, что мы уже знаем о работе Docker:

        1. Вы можете собирать Docker-образы с вашими приложениями.
        2. Вы можете создавать Docker-контейнеры из Docker-образов,
           и запускать ваши приложения из первых.
        3. Вы можете заливать/скачивать Docker-образы на/с Docker Hub.

      - Рассмотрим работу всех этих компонентов по отдельности и вместе.

    # Как работают Docker-образы, ФС union

      ## Слои: вводная информация
        - Docker-образы представляют из себя read-only шаблоны.
        - Каждый образ состоит из набора слоёв.
        - Docker использует файловую систему union для комбинирования
          всех этих слоёв в единый образ.
        - ФС union умеет комбинировать файлы и каталоги из разных
          файловых систем, называемых ветками по её внутренней терминологии,
          таким образом, что накладываясь друг на друга они образуют
          единую работающую файловую систему.

      ## Слои: причина быстрой работы Docker
        - Одна из главных причин легковесности Docker, это слои.
        - Давайте представим, что вы решили изменить один Docker-образ,
          к примеру, заменить PHP v5.6 на PHP v7.0.
        - Для этого вам потребуется лишь обновить слой, добавляющий PHP в образ,
          но не потребуется полностью пересобирать весь образ, как было бы
          в том случае, если бы вы имеле дело с образом для виртуальной машины.

      ## Каждый Docker-образ наследует от некого базового образа
        - Примеры самых базовых образов: "ubuntu", "fedora".
        - В качестве базового образа может выступать ЛЮБОЙ образ.
        - Docker всегда берёт базовые образы с Docker Hub.

      ## Инструкции для создания образов, DockerFile
        - Представим, вы решили создать собственный образ на базе "ubuntu".
        - Процесс создания представляет процесс накладывания на него новых слоёв.
        - Каждый слой накладывается с помощью отдельной инструкции.
        - Инструкции могут выполнять действия типа:

          ### Запустить команду
          ### Добавить файл или каталог
          ### Создать переменную среды
          ### Указать список процессов к запуску при старте контейнеров из этого образа

        - Инструкции для создания образа описываются в DockerFile.
        - Он используется, когда вы приказываете клиенту создать новый образ.
        - Команда build берёт базовый образ, применяет к нему инструкции
          из DockerFile, и возвращает результирующий образ.

    # Как работает Docker-репозиторий
      - Docker-репозиторий называется Docker Hub, он хранит Docker-образы.
      - Название, по всей вероятности, придумали, вдохновляясь названием GitHub.
      - Любой свой образ вы можете залить/скачать на/с Docker Hub.
      - Используя CLI клиенты можно искать и качать образы с Docker Hub.
      - В Docker Hub есть публичные и приватные репозитории.
      - Последние платные, и исключены из публичного поиска.

    # Как работают Docker-контейнеры
      - Контейнер состоит из ОС, данных пользователя и метаданных.
      - Каждый Docker-контейнер создаётся из Docker-образа.
      - Образ содержит информацию, из чего должен состоять контейнер,
        какие процессы должны подниматься при его запуске, и прочую
        конфигурационную информацию.
      - Docker-образ является read-only. Когда Docker делает run
        контейнера из образа, то добавляет read-write слой поверх
        образа (используя ФС union), в котором ваше приложение
        может работать.

    # Что происходит при run контейнера
      - Через CLI можно приказать Docker-клиенту запустить контейнер.
      - Например:

          docker run -i -t ubuntu /bin/bash

      - Где:

          ubuntu      | Какой образ использовать для создания контейнера
          /bin/bash   | Какую команду внутри контейнера запустить

      - Что происходит за сценой, когда вы запускаете эту команду:

        ## Добывание образа ubuntu
          - Docker проверяет наличие образа ubuntu.
          - В случае отсутствия скачивает скачивает его с Docker Hub.

        ## Создание нового контейнера
          - Добыв образ, Docker создаёт из него новый контейнер.

        ## Создание ФС контейнера, добавление read-write слоя
          - Создаёт файловую систему контейнера.
          - Добавляет в неё read-write слой из образа.

        ## Создание network/bridge интерфейса
          - Создаёт сетевой интерфейс.
          - С его помощью контейнер может общатсья с localhost.

        ## Настраивает IP-адреса
          - Ищет и назначает доступные IP-адреса из пула.

        ## Запускает указанные процессы

        ## Ловит и обрабатывает вывод приложения
          - Все данные из std input/output/error записываются в лог.
          - Лог, разумеется, находится вне контейнера.

      - Запустив контейнер, можно взаимодействовать с приложением
        внутри него. Если потребуется, можно остановить и удалить контейнер.

  > Важный функционал ядра Linux, используемый Docker

    # Docker написан на Go
      - И применяет несколько важных особенностей ядра.
      - Именно это и позволяет ему обеспечивать описанный функционал.
      - Рассмотрим эти особенности, чтобы иметь о них представление.

    # Namespaces
      - Docker используют технологию ядра под названием Namespaces.
      - Она позволяет создавать изолированные рабочие пространства,
        которые в терминологии Docker называются контейнерами.
      - Namespaces позволяют создать изолированный слой, в котором
        каждый контейнер запускается в собственном пр.имён, и к нему
        нет доступа извне.
      - Вот некоторые пр.имён, которые Docker использует в Linux:

        ## pid namespace    | Для изоляции процессов
        ## net namespace    | Для управления сетевыми интерфейсами
        ## ipc namespace    | Для управления доступом к IPC-ресурсам
        ## mnt namespace    | Для управления точками монтирования
        ## uts namespace    | Для изоляции ядра и идентификаторов версий

    # Control groups
      - Docker используют технологию ядра под названием Control groups.
      - Она позволяет указать изолированным контейнерам, какие ресурсы
        он может использовать.
      - Это гарантирует, что контейнеры будут хорошими соседями на 1-ом хосте.
      - Control groups позволяет контейнерам безопасно и совместно использовать
        ресурсы железа.
      - В случае необходимости, можно установить рамки и ограничения,
        например, ограничить MAX память для конкретного контейнера.

    # Union file systems
      - Docker применяет файловую систему UnionFS.
      - Эта операционная система позволяет иметь дело со слоями.
      - Это одна из причин, почему Docker такой легковесный и быстрый.
      - Docker может использовать несколько вариантов UnionFS,
        включая: AUFS, btrfs, vfs, and DeviceMapper.

    # Container format
      - Docker комбинирует эти компоненты в слой, который создатели
        Dockrt называют container format.
      - Формат контейнера по умолчанию называется libcontainer.
      - Не исключено, что в будущем Docker будет поддерживать и
        другие container formats, например, для BSD/Solaris систем.


А2. Установка Docker

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Установка на Windows: Docker Toolbox
    # Требования к машине с Windows

      - Windows >= 7
      - Вкл. технология виртуализации
      - x64

    # Docker Machines, как DOCKER_HOST при установке на Windows

      - Что происходит при установке Docker на Linux
      - Что происходит при установке Docker на Windows

    # Установка/Обновление/Удаление Docker Toolbox на Windows
    # Подключение к Docker при работе на Windows

      - Вводная информация
      - Подключение из Docker Quickstart Terminal
      - Подключение из Powershell
      - Подключение через PuTTY

  --------------------------------------

  > Ссылки

    # Оф.документация по установке Docker на Windows
        https://docs.docker.com/engine/installation/windows/

    # Оф.документация по установке Docker на Linux Ubuntu
        https://docs.docker.com/engine/installation/linux/ubuntulinux/

  > Введение
    - В этой главе описана установка Docker на Windows и Linux Ubuntu.

  > Установка на Windows: Docker Toolbox
    - Чтобы работать с Docker на Windows, надо установить Docker Toolbox.
    - Он включает в себя следующие инструменты:

      # Oracle VM VirtualBox
       # Docker Machine с бинарником docker-machine
        # Docker Engine с бинарником docker
         # Docker Shell - предварительно сконфигурированное окружение для CMD
         # Docker GUI - Kitematic

    - С помощью Docker Machine можно штамповать ВМ для VirtualBox.
    - ВМ создаётся с оч.лёгким дистром Linux и предустановленным Docker Engine.
    - VirtualBox вообще запускается в памяти, жрёт 24мб, и запускается за 5 секнуд.
    - Управлять Docker'ом на ВМ можно через Docker GUI или Kitematic.
    - Или можно просто подключаться к ВМ через PuTTY, или посылать команды
      из CMD или Powershell.
    - Вся тема с VirtualBox и ВМ нужна потому, что Docker может работать
      только на Linux, и запустить его на Windows/MacOS/другой ОС невозможно.

  > Требования к машине с Windows

    # Windows >= 7
      - Docker работает только на Windows 7 и старше.

    # Вкл. технология виртуализации
      - Для работы Docker, в настройках CPU д.б. включена виртуализация.
      - Обычно, включить её можно в биосе.
      - Проверить можно: CTRL+ALT+DEL -> Диспетчер задач -> Производительность.

    # x64
      - Docker поддерживает только 64-битные ОС.

  > Docker Machines, как DOCKER_HOST при установке на Windows

    # Что происходит при установке Docker на Linux
      - Допустим, у нас есть машина (реальная/виртуальная) с ОС Linux.
      - На неё Docker можно поставить без всяких виртуальных машин.
      - Ведь это же Linux, и Docker сможет использовать его ядро.
      - Соответственно, в этом случае DOCKER_HOST == localhost.

         |---------------------------|
         |  DOCKER_HOST              |
         |                           |
         |    Docker client          |
         |          |                |
         |    Docker daemon (server) |
         |          |                |
         |    Containers             |
         |                           |
         |      ----------           |
         |      ----------           |
         |                           |
         |      ----------           |
         |      ----------           |
         |---------------------------|

    # Что происходит при установке Docker на Windows
      - Docker нельзя установить на Windows, т.к. у него нет ядра Linux.
      - Надо сначала установить VirtualBox, на нём создать ВМ с Linux,
        и уже на эту ВМ накатать Docker.
      - И у нас есть 2 основных варианта для управление Docker на этой ВМ:

        1) Через Docker-клиент на Windows
          - Который был установлен в составе Docker Toolbox.
          - Через него можно подключиться к ВМ Docker Machines:

              "$(docker-machine env [имя машины])"

          - И отправлять команды Docker'у.


                    Windows

                      Docker Client
                                |
             |------------------|--------|
             |  DOCKER_HOST (ВМ)|        |
             |                  |        |
             |    Docker daemon (server) |
             |          |                |
             |    Containers             |
             |                           |
             |      ----------           |
             |      ----------           |
             |                           |
             |      ----------           |
             |      ----------           |
             |---------------------------|

        2) Через Docker-клиент на ВМ
          - Через PuTTY можно подключиться к ВМ.
          - И работать с Docker клиентом внутри машины.

                Windows

                  PuTTY
                      |
             |---------------------------|
             |  DOCKER_HOST (ВМ)         |
             |                           |
             |    Docker Client          |
             |          |                |
             |    Docker daemon (server) |
             |          |                |
             |    Containers             |
             |                           |
             |      ----------           |
             |      ----------           |
             |                           |
             |      ----------           |
             |      ----------           |
             |---------------------------|


  > Установка/Обновление/Удаление Docker Toolbox на Windows

    # Установка

      1) Скачать свежий Docker Toolbox
        - Это можно сделать здесь: https://www.docker.com/toolbox

      2) Запустить установщик, и установить Docker
        - При этом (при установках по умолчанию) произойдёт следующее:

          # Исполняемые файлы установятся в "https://www.docker.com/toolbox"
          # Установится или обновится VirtualBox
          # В program shortcuts добавится каталог Docker inc.
          # Добавится/Обновится запись в PATH
          # На рабочий стол добавятся ярлыки Docker Quickstart Terminal и Kitematic.

    # Обновление
      - Для обновления, запустите свежий Docker Toolbox installer.

    # Удаление
      - Стандартными средствами windows.
      - Плюс вручную удалить файл docker-install.exe.

  > Подключение к Docker при работе на Windows

    # Вводная информация
      - Итак, вы установили Docker Toolbox.
      - Теперь, чтобы запустить Docker-контейнер, необходимо:

        1) Создать и запустить новую (или использовать существующую) ВМ с Docker.
        2) Подключиться тем или иным образом к этой ВМ.
        3) Использовать Docker-клиент docker для создания/загрузки/управления контейнерами.

      - Однажды создав ВМ, её можно использовать снова и снова.
      - Она ведь, по сути, обычная ВМ для VirtualBox, и работает также.
      - Все данные на ней сохраняются между её перезапусками.

    # Подключение из Docker Quickstart Terminal

      1) Найти ярлык или исполняемый файл, и запустить DQT
        - После установки Docker Toolbox, ярлык д.б. на рабочем столе.
        - При этом произойдёт следующее:

          -- Откроется CMD
          -- Создатся ВМ default, если она ещё не существует, и запустится
          -- Терминал автоматически подключится в ВМ

        - Сразу после этого можно работать в этом CMD с docker.

      2) Удостоверьтесь, что всё работает, запустив контейнер nginx
        - В оф.инструкции предлагази запустить контейнер hello-world,
          но мы запустим лучше nginx.
        - Для этого в CMD из 1 выполните:

            docker run --rm -i -t -p 80:80 nginx    // Для запуска в интерактивном режиме
            docker run -d -i -t -p 80:80 nginx      // Для запуска в режиме демона

        - В случае запуска врежиме демона, процесс запустится
          в фоновом режиме, и в командную строку можно будет вводить.
        - Узнайте IP для запущенной виртуальной машины:

            docker-machine ip

        - Откройте браузер, впишите туда этот IP, там д.б.
          стартовая страничка для nginx.
        - Чтобы остановить и удалить запущенный контейнер:

            docker ps -a                            // узнайте его имя
            docker stop [имя] && docker rm [имя]    // остановите и удалите

        - При этом ВМ default продолжает работать после закрытия терминала.
        - Чтобы остановить её:

            docker ls                               // узнайте её имя
            docker stop [имя]                       // остановите её

    # Подключение из Powershell

      1) Добавьте в PATH следующее: c:\Program Files (x86)\Git\bin

      2) Запустите Windows PowerShell

      3) Создайте новую ВМ с Docker с помощью Docker Machines
        - Допустим, создадим ВМ с именем my-default.
        - Для этого:

            docker-machine create --driver virtualbox my-default

      4) Убедитесь, что ВМ создалась
        - Для этого просмотрите все имеющиеся ВМ
        - Для этого:

            docker-machine ls

      5) Получите environment commands для вашей новой ВМ:
        - Для этого:

            docker-machine env --shell powershell my-default

      6) Подключитесь к вашей новой ВМ:
        - Для этого:

            eval "$(docker-machine env my-default)"

      7) Запустите контейнер hello-world для проверки работоспособности
        - Для этого:

            docker run hello-world

    # Подключение через PuTTY
      - Для подключения к ВМ Docker Machines понадобится SSH-ключ.
      - При создании новой ВМ, ключ помещается в %USERPROFILE%\.ssh
      - Для подключение потребуется private key из этого каталога.
      - Но надо конвертировать его в PuTTY-формат с помощью puttygen.exe:

        1) Откройте puttygen.exe

        2) Нажмите File -> Load и загрузите private key
          - Который в %USERPROFILE%\.docker\machine\machines\<name_of_your_machine>\id_rsa
          - В моём случае %USERPROFILE% это: C:\Users\German\.ssh

        3) Нажмите Save Private Key

        4) Подключитесь к ВМ с помощью созданного ключа
          - Используйте Login: docker
          - IP и порт: 127.0.0.1:2022


А3. Запуск приложений в Docker-контейнерах

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Пример №1: вывести строку "hello world"
    # Пример №2: запустить контейнер в интерактивном режиме с bash
    # Пример №3: запустить демонизированный контейнер

  --------------------------------------

  > Ссылки

    # Оф.статья "Hello world in a container"
        https://docs.docker.com/engine/userguide/containers/dockerizing/

  > Введение
    - В этой главе описан процесс запуска приложений в контейнере.
    - В рассмотренном примере приложение ежесекундно выводит "Hello world".

  > Пример №1: вывести строку "hello world"
    - В этом примере воспользуемся базовым образом ubuntu.
    - Создадим из него контейнер, и выведем в std out строку "hello world".
    - Для этого введём:

        docker run ubuntu /bin/echo 'Hello world'

    - Рассмотрим подробнее, что произошло:

      # docker run
        - Эта команда создаёт и запускает контейнер из указанного образа.

      # ubuntu
        - Это имя образа, из которого docker run создаёт контейнер.

      # /bin/echo 'Hello world'
        - Эта команда, которая после запуска контенера выполняется в нём.
        - Команда echo просто выводит указанную строку в std out.

    - А что произошло с контейнером после выполнения команды?
    - Контейнер сразу завершил работу. Поскольку, Docker-контейнеры
      работают лишь в течение того времени, пока указанная команда
      выполняется.

  > Пример №2: запустить контейнер в интерактивном режиме с bash
    - В этом примере воспользуемся базовым образом ubuntu.
    - Создадим для него контейнер в интерактивном режиме.
    - И запустим в нём /bin/bash.
    - Благодаря интерактивному режиму, мы сможем ваимодействовать с ним.
    - Для этого введём:

        docker run -t -i ubuntu /bin/bash

    - Введя, мы видим в начале такую строку: root@fc74d37ae42c.
    - root это имя пользователя, а fc74d37ae42c сокращённый id контейнера.
    - То есть, мы получили root-доступ к данному контейнеру.
    - Чтобы выйти, можно ввести:

        exit

  > Пример №3: запустить демонизированный контейнер

    # Введение
      - В примере №1 контейнер завершался после выполнения указанной команды.
      - В примере №2 контейнер завершался после завершения процесса /bin/bash.
      - Но как создать контейнер, который сам не будет завершаться?
      - Который можно будет завершить лишь командой docker stop ?
      - Для этого надо демонизировать создаваемый контейнер параметром -d.

    # Создание демонизированного контейнера
      - Создадим демонизированный контейнер.
      - Он будет каждую секунду выводить в std out "hello world".
      - Создадим:

          docker run -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done"

    # ID контейнера, краткий ID, образ, имя, статус
      - Выполнив команду, мы получим Unique ID контейнера:
          1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147
      - Но удобнее работать с именем контейнера, чем с его громоздким ID.
      - Убедимся, что контейнер запущен, для этого введём:

          docker ps -a

      - Среди прочего здесь указан и короткий вариант ID: 1e5535038e28
      - Это первые 12 цифр полного ID.
      - Также здесь указано имя образа, имя контейнера и его статус.
      - Если при создании контейнера не указать имя, Docker сам его придумает.

    # Посмотреть вывод контейнера через docker logs
      - Итак, мы создали демонизированный контейнер.
      - И управление в нашем Docker-клиенте вернулось к нам.
      - То есть, никакого вывода мы у себя не видим.
      - А чтобы его увидеть, надо воспользоваться командо docker logs:

          docker logs [имя контейнера]

      - Команда выведет данные из std out контейнера (не в realtime).

    # Остановить и удалить демонизированный Docker-контейнер
      - Теперь мы хотим остановить и удалить его.
      - Для этого:

          docker stop [имя] && docker rm [имя]

      - Не забудьте убедиться, что контейнер удалён, с помощью: docker ps -a


А4. Создание собственных Docker-образов

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Просмотр списка образов [images]
    # Теги образов {image}:{tag}
    # Скачивание образов на хост [pull]
    # Поиск образов на Docker Hub [search]
    # Типы образов

      - Вводная информация
      - Official
      - Automated

    # Создание образов [commit/build]

      - Вводная информация
      - Из контейнера [commit]
      - Из DockerFile [build]
      - Образ может иметь <= 127 слоёв

    # Добавить тег существующему образу [tag]
    # Дайджест образа
    # Загрузка образа на Docker Hub [push]
    #

  --------------------------------------

  > Ссылки

    # Оф.статья "Build your own images"
        https://docs.docker.com/engine/userguide/containers/dockerimages/

    # Оф.статьи про official и automated типы образов
        https://docs.docker.com/docker-hub/official_repos/
        https://docs.docker.com/engine/userguide/containers/dockerrepos/#automated-builds

    # Оф.сайт репозиторий Docker Hub
        https://hub.docker.com/

  > Введение
    - Понятие образов является одним из центральных в концепции Docker.
    - Любые контейнеры в конечном итоге создаются из образов.
    - Можно как создавать свои образы, так и использовать уже готовые.
    - Образы можно закачивать/скачивать на/с Docker Hub (аналог github, но для образов).
    - В этой главе прольём свет на следующие темы:

        # Работа и управление образами локально, на Docker Host.
        # Создания базовых образов.
        # Закачка образов на Docker Hub.

  > Просмотр списка образов [images]
    - Командой docker images можно посмортеть список образов в наличии.
    - Эти образы хранятся в файловой системе хоста для Docker.
    - При работе на Windows, хостом является виртуальная машина с Linux.
    - Та самая, которая создаётся Docker Machines, если вы его используете.
    - Правда, найти конкретный каталог с образами на ВМ на данный момент не удалось.

  > Теги образов {image}:{tag}
    - Многие команды CLI Docker принимают имя образа в качестве аргумента.
    - Каждый образ на Docker Hub имеет тег, по аналогии с тегами с GitHub.
    - Когда вы указываете имя образа в CLI, вы можете указать и тег.
    - Тег указывается через символ ":". Общий шаблон: [имя]:[тег].
    - Например:

        docker run -t -i ubuntu:14.04 /bin/bash

    - У каждого образа есть тег "latest", означающий последнюю версию.

  > Скачивание образов на хост [pull]
    - Образы скачиваются автоматически при использовании docker run.
    - Но иногда хочется скачать их заранее, чтобы docker run сработала быстрее.
    - Команда docker pull [имя] позволяет скачать образ [имя].
    - Рядом с именем можно указать и тег для образа: [имя]:[тег].
    - При работе на Windows, образы скачиваются в ФС виртуальной машины.
    - Например, мы хотим скачать ubuntu 14.04:

        docker pull ubuntu:14.04

  > Поиск образов на Docker Hub [search]
    - Искать образы на Docker Hub можно командой docker search.
    - Данная команда не позволяет искать образы по тегам.
    - Например, мы хотим найти образ ubuntu:

        docker search ubuntu

    - Она выведет список всех образов, имеющих "ubuntu" в названии.

  > Типы образов

    # Вводная информация
      - На Docker Hub есть 2 типа образов: official и automated.
      - Подробно они описаны в соответствующем разделе этой методички.

    # Official
      - Официальные образы, разработка которых курируется Docker'ом.
      - На каждый оф.образ Docker выделяет отдельную команду разработчиков.
      - Каждая такая команда работает в тесном сотрудничестве с разработчиками
        того программного обеспечения, который используется в соотв.образе,
        экспертами по безопасности и широкой общественностью.
      - Создание и поддержка официальных образов является открытым процессом,
        который публично протекает на GitHub, любой может принять участие.

    # Automated
      - Не официальные образы, которые может закачать на Docker Hub любой.


  > Создание образов [commit/build]

    # Вводная информация
      - Вы нашли хороший образ, но он не совсем вам подходит?
      - Вы хотите внести корректирующие изменения в этот образ?
      - Это можно сделать 2-мя способами:

        1) Из контейнера
          - Можно создать контейнер из этого образа.
          - Внести изменения в этот контейнер.
          - И создать образ из этого контейнера.

        2) Из DockerFile
          - Можно создать файл с именем "DockerFile".
          - В нём указать базовый образ для изменения.
          - А также описать список необходимых изменений.
          - И создать новый образ из этого DockerFile.

      - После создания образо он НЕ заливается автоматом на Docker Hub.

    # Из контейнера [commit]

      1) Создать контейнер
        - Сначала надо создать контейнер из исходного образа.
        - И получить к нему доступ через командную строку.
        - Например:

            docker run -t -i ubuntu:latest /bin/bash

      2) Изменить созданный контейнер
        - Допустим, мы хотим установить веб-сервер.
        - Установим на свеженькую убунту свеженький nginx.
        - И после этого выйдем из командной строки контейнера:

            sudo apt-get install nginx
            exit

      3) Сделать commit образа из контейнера
        - Требуется сделать коммит нового образа из контейнера на Docker Hub.
        - Для этого:

            docker commit -m "Added json gem" -a "Kate Smith" \
            0b2616b0e5a8 ouruser/sinatra:v2

        - Здесь:

            -m "Added json gem"         // сообщение к коммиту
            -a "Kate Smith"             // автор коммита
            0b2616b0e5a8                // краткий id контейнера
            ouruser/sinatra:v2          // вендор и название:версия

        - Командой docker images можно убедиться, что образ появился в списке.
        - Теперь можно использовать наш новый образ (пример):

            docker run -t -i ouruser/sinatra:v2 /bin/bash

    # Из DockerFile [build]

      1) Создать каталог и DockerFile
        - Например, создадим каталог "ubuntu-nginx".
        - И в нём файл "DockerFile".

      2) Наполнить DockerFile инструкциями
        - Каждая инструкция создаёт новый слой образа.
        - Пример содержимоо DockerFile:

          FROM ubuntu:14.04
          MAINTAINER German Manvelov <4gekkman@gmail.com>
          RUN sudo apt-get update && sudo apt-get install -y nginx

      3) Создать образ из DockerFile
        - Для этого перейти в каталог с DockerFile.
        - И выполнить следующую команду:

            docker build -t 4gekkman/ubuntu-nginx:1.0.0 .

        - Где:

            -t 4gekkman/ubuntu-nginx:1.0.0   // вендор, имя, версия
            .                                // Адрес DockerFile

        - При этом будет выдано предупреждение:

              SECURITY WARNING: You are building a Docker image
              from Windows against a non-Windows Docker host.
              All files and directories added to build context will
              have '-rwxr-xr-x' permissions. It is recommended to
              double check and reset permissions for sensitive
              files and directories.

        - Ничего страшного, оно лишь означает следующее:

              That warning was added, because the Windows filesystem
              does not have an option to mark a file as 'executable'.
              Building a linux image from a Windows machine would
              therefore break the image if a file has to be marked
              executable.

              For that reason, files are marked executable by default
              when building from a windows client; the warning is there
              so that you are notified of that, and (if needed),
              modify the Dockerfile to change/remove the executable
              bit afterwards.

        - Теперь можно создавать контейнеры из нового образа:

              docker run -t -i 4gekkman/ubuntu-nginx:1.0.0 /bin/bash

    # Образ может иметь <= 127 слоёв
      - И это не зависит от storage driver'а.
      - Это ограничение действует глобально.
      - Оно позволяет держать в узде размеры образов.

  > Добавить тег существующему образу [tag]
    - Можно добавить тег уже созданному образу.
    - Уже после того, как он был commit или build.
    - Пример:

        docker tag 5db5f8471261 ubuntu-nginx:devel

  > Дайджест образа
    - Каждый образ имеет связанный с контентом идентификатор.
    - Если input из которого создан образ не изменился, идентификатор тоже.
    - Увидеть digetst'ы образов, можно передав флаг --digest:

        docker images --digests | head

    - Также digest может служить идентификатором этого образа в
      таких командах, как create/run/rmi, а также в инструкции
      FROM в DockerFile.

  > Загрузка образа на Docker Hub [push]
    - После создания образа его можно загрузить на Docker Hub.
    - Например:

        docker push 4gekkman/ubuntu-nginx

  > Удаление образа с хоста
    - Удалить образ можно командой docker rmi.
    - При этом образ удаляется с хоста.
    - Например:

        docker rmi 4gekkman/ubuntu-nginx


А5. Работа с Docker Machines

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Где хранятся виртуальные машины для Docker
    # Что такое Docker Machine

      - Определение Docker Machines
      - Где можно использовать
      - Что позволяет делать команда docker-machine

    # Зачем нужны Docker Machines

      - Вводная информация
      - Запускать Docker на Windows/Mac
      - Управлять хостами Docker на удалённых машинах

    # Какая разница между Docker Engine и Docker Machine

      - Docker Engine
      - Docker Machine

    # Использование Docker Machine для запуска Docker-контейнеров
    # Создание Docker-машины
    # Экспериментирование с Docker-машиной

      - Запуск контейнера с busybox командой docker run
      - Получение IP адреса Docker-машины
      - Запуск nginx в контейнере командой docker run

    # Запуск и остановка Docker-машин

      - Запуск Docker-машины
      - Остановка Docker-машины

    # Имя 'default' умолчательное для многих команд
    # Драйверы для Docker-машин

      - Вводная информация
      - Список доступных драйверов

    # API команды docker-machine

      - active            | Имя активной машины (смотрит DOCKER_HOST)
      - config            | Показывать конфигурацию для указанной docker-машины
      - create            | Создать новую docker-машину
      - env               | Настроить переменные среды, натравив docker на указанную ВМ
      - help              | Посмотреть справку по указанной команде
      - inspect           | Получить информацию об указанной ВМ
      - ip                | Получить IP указаной ВМ.
      - kill              | Сделать power off для указанной ВМ
      - ls                | Вывести список доступных ВМ
      - provision         | Запустить provision на указанной машине
      - regenerate-certs  | Перегенерировать TLS-сертификаты и обновить указанную машину
      - restart           | Перезапустить указанную машину
      - rm                | Удалить указанную машину
      - scp               | Копировать файлы с localhost на указанную машину  через scp
      - ssh               | Выполнить на указанной машине команду через ssh
      - start             | Запустить указанную docker-машину
      - status            | Получить статус указанной docker-машины
      - stop              | Остановить указанную docker-машину
      - upgrade           | Обновить Docker на указанной docker-машине
      - url               | Получить URL хоста указанной машины

  --------------------------------------

  > Ссылки

    # Оф.статья "Docker Machine Overview"
        https://docs.docker.com/machine/overview/

    # Оф.статья "Get started with Docker Machine and a local VM"
        https://docs.docker.com/machine/get-started/

    # Оф.справочник по API: "Command line reference"
        https://docs.docker.com/machine/reference/active/

    # Оф.справочник по драйверам
        https://docs.docker.com/machine/drivers/os-base/

  > Введение
    - Docker Machines является вспомогательным инструментом Docker.
    - Он создан специально для удобной работы с Docker из Windows и MacOS.
    - Ведь Docker Engine можно запустить исключительно на Linux.
    - Поэтому на Windows и MacOS для работы с докер нужна ВМ с Linux.
    - Раньше тематика ВМ оставалась за рамками инструментов Docker.
    - Пользователям предлагалось решать этот вопрос самостоятельно.
    - Но на определённом этапе Docker взял этот вопрок "под крыло".
    - Так для чего же можно использовать Docker Machines:

      # Чтобы устанавливать и использовать Docker на Windows и Mac
      # Управлять множеством удалённых хостов для Docker
      # Управлять Swarm-кластерами

  > Где хранятся виртуальные машины для Docker
    - Виртуальные машины для Docker хранятся в:

        C:\Users\[user]\.docker\machine\machines  // в общем случае
        C:\Users\German\.docker\machine\machines  // в моём случае

  > Что такое Docker Machine

    # Определение Docker Machines

        Инструмент, позволяющие устанавливать
        Docker Engine на виртуальные хосты,
        и управлять ими с помощью команд
        docker-machine.

    # Где можно использовать

      - На локальном компьютере с Windows или MacOS.
      - В дата центре.
      - У облачного провайдера вроде AWS или Digital Ocean.

    # Что позволяет делать команда docker-machine

      - start       | запускать ВМ
      - inspect     | получать информацию о ВМ
      - stop        | останавливать ВМ
      - restart     | перезапускать ВМ
      - upgade      | обновлять Docker-клиент и Docker-демон
      - configure   | настраивать
      ...           | и многое другое

  > Зачем нужны Docker Machines

    # Вводная информация
      - На данный момент DM являются 1-ым путём запустить DE на Windows/Mac.
      - Ещё DM являются хорошим способом управлять удалёнными Docker-хостами на Linux.

    # Запускать Docker на Windows/Mac
      - Для работы на Windows/Mac вы устанавливаете Docker Toolbox.
      - Это набор программ, включающий: DE, DM, VirtualBox, Docker Shell, Kitematic.
      - После установки в консоли становится доступна команда docker-machine.
      - С помощью этой команды можно быстро создать ВМ для VirtualBox, и запустить.
      - Создав ВМ, можно к ней подключиться, и работать с командой docker.

    # Управлять хостами Docker на удалённых машинах
      - Docker может работать лишь на Linux-системах.
      - Если у вас Linux, для работы с Docker надо установить лишь Docker Engine.
      - И после этого можно работать с командой docker.
      - Но что, если у вас есть N Linux-серверов с Docker Engine на борту?
      - Которые могут быть в облаке, в сети, локально, где угодно.
      - Какая бы ОС у вас не была основная, вы можете поставить Docker Machine.
      - И с помощью её команд эффективно управлять вашими удалёнными N хостами.
      - Автоматически создавать хосты, устанавливать DE, настраивать клиенты.

  > Какая разница между Docker Engine и Docker Machine

    # Docker Engine
      - Когда люди говорят "Docker", обычно они имеют в виду DE.
      - То есть:

          Клиент-серверное приложение, состоящее из Docker-сервера
          (демона), REST API интерфейса для взаимодействия с ним,
          и Docker-клиента (CLI), который взаимодействует с сервером
          через REST API-слой.

      - Весь CLI для DE сосредоточен в команде docker.
      - Примеры: docker run / docker ps / docker images

    # Docker Machine
      - Это инструмент для управления докерезированными хостами.
      - То есть хостами с Docker Engine на борту.
      - Обычно Docker Machine устанавливают на основную локальную систему.
      - DE имеет свой CLI, который сосредоточен в команде docker-machine.
      - DM позволяет установить DE на 1 или более вертуальных систем.
      - Эти системы м.б. локальными или удалёнными.

  > Использование Docker Machine для запуска Docker-контейнеров
    - Чтобы запустить Docker-контейнер, понадобится:

      # Создать и запустить новую (запустить существующую) Docker-машину.
      # Подключиться к этой ВМ, чтобы стала доступна команда docker
      # Использовать Docker-клиент для создания/загрузки/управления контейнерами

    - Однаджы создав Docker-машину, её можно использовать снова и снова.
    - Как и любой VirtualBox-бокс, она сохраняет настройки между запусками.

  > Создание Docker-машины

    1) Просмотреть список существующих Docker-машин
      - Для этого выполить команду:

          docker-machine ls

    2) Создать виртуальную машину
      - Это можно сделать командой docker-machine create.
      - Также потребуется указать драйвер флагом --driver.
      - Какие бывают драйверы, будет описано в одном из пунктов ниже.
      - Драйвер для создания ВМ для VirtualBox так и называется.
      - Например, создадим ВМ с именем default:

          docker-machine create --driver virtualbox default

      - Эта команда скачает легковесный дистрибутив Linux.
      - На нём уже будет предустановлен Docker Engine.

    3) Просмотреть список существующих Docker-машин
      - Чтобы проверить, что новая машина была создана.
      - Для этого выполить команду:

          docker-machine ls

    4) Подключиться к новой Docker-машине
      - Для этого использовать команду docker-machine env.
      - Выполнить:

          docker-machine env --shell powershell default
          docker-machine env --shell powershell default | Invoke-Expression

      - После этого команда docker станет доступной.
      - Она будет взаимодействовать в ВМ default.

  > Экспериментирование с Docker-машиной

    # Запуск контейнера с busybox командой docker run
      - Выполнить команду:

        docker run busybox echo hello world

    # Получение IP адреса Docker-машины
      - Все порты Docker-машины будут доступны с этим IP.
      - Унать его можно командой:

        docker-machine ip

    # Запуск nginx в контейнере командой docker run
      - Запустить контейнер с nginx можно командой:

        docker run -d -p 8000:80 nginx

      - Когда контейнер запустится, можно узнать IP Docker-машины.
      - И зная IP, увидеть стартовую страницу nginx на порту 8000.

  > Запуск и остановка Docker-машин

    # Запуск Docker-машины

        docker-machine ls                                // Вывести существующий список Docker-машин
        docker-machine start [имя/id краткое/id полное]  // Запустить Docker-машину

    # Остановка Docker-машины

        docker-machine ls                               // Вывести существующий список Docker-машин
        docker-machine stop [имя/id краткое/id полное]  // Остановить Docker-машину

  > Имя 'default' умолчательное для многих команд
    - Есть список команд, которые требуют указать имя Docker-машины.
    - Но в которых можно это самое имя не указывать.
    - И тогда будет использовано имя по умолчанию: "default".
    - Вот эти команды:

        docker-machine config
        docker-machine env
        docker-machine inspect
        docker-machine ip
        docker-machine kill
        docker-machine provision
        docker-machine regenerate-certs
        docker-machine restart
        docker-machine ssh
        docker-machine start
        docker-machine status
        docker-machine stop
        docker-machine upgrade
        docker-machine url

  > Драйверы для Docker-машин

    # Вводная информация
      - Будем оперировать понятиями "провайдер" и "ОС".
      - Провайдеры, это:

          VirtualBox            |
          Fusion                | локальные провайдеры
          Hyper-V               |

          Digital Ocean         | удалённые провайдеры
          Amazon Web Services   |

      - Операционные системы это разные дистрибутивы Linux:

          Boot2Docker
          Ubuntu
          Debian
          RancherOS
          RedHat Enterprice Linux
          CentOS
          Fedora

      - Для локальныъ и удалённых провайдеров разные ОС по умолчанию:

          Для локальных: Boot2Docker.
          Для удалённых: Ubuntu

      - Для удалённых провайдеров можно указать и другой дистрибутив.
      - Для этого надо использовать провайдер-специфичный флаг. Например:

          --digitalocean-image=debian-8-x64

      - Также можно указать другого SSH-пользователя:

          --amazonec2-ssh-user

      - Каждый драйвер имеет набор провайдер-специфичных опций.
      - Пример для Amazon Web Services:

          docker-machine create -d azure --azure-subscription-id="SUB_ID" --azure-subscription-cert="mycert.pem" A-VERY-UNIQUE-NAME

    # Список доступных драйверов

      virtualbox        |
      hyperv            |
      vmwarefusion      | для конкретных инструментов виртуализации
      vmwarevcloudair   |
      vmwarevsphere     |

      generic           | для существующей ВМ

      digitalocean      |
      amazonec2         |
      exoscale          |
      google            | для облачных хостингов
      softlayer         |
      azure             |
      openstack         |
      rackspace         |

  > API команды docker-machine

    // active //
    //--------//
    // - Имя активной машины (смотрит DOCKER_HOST).

      docker-machine ls       // вывести список всех docker-машин
      docker-machine active   // вывести имя активной docker-машины

    // config //
    //--------//
    // - Показывать конфигурацию для указанной docker-машины.
    // - Если не указать имя, использует оное по умолчанию "default".

      docker-machine config [имя машины]

    // create //
    //--------//
    // - Создать новую docker-машину.

      // Синтаксис и справки
        docker-machine create                                 // получить общую справку
        docker-machine create --driver [драйвер] [имя машины] // создать ВМ с именем и драйвером
        docker-machine create --driver [драйвер] --help       // посмотреть драйвер-специфичную справку

      // Создать ВМ "test" для virtualbox
        docker-machine create --driver virtualbox test

    // env //
    //-----//
    // - Настроить переменные среды, натравив docker на указанную ВМ.

      docker-machine env --shell powershell default
      docker-machine env --shell powershell default | Invoke-Expression

    // help //
    //------//
    // - Посмотреть справку по указанной команде.

      docker-machine help config

    // inspect //
    //---------//
    // - Получить информацию об указанной ВМ.

      docker inspect [имя машины]

    // ip //
    //----//
    // - Получить IP указаной ВМ.

      docker ip [имя машины]

    // kill //
    //------//
    // - Сделать power off для указанной ВМ.

      docker kill [имя машины]

    // ls //
    //----//
    // - Вывести список доступных ВМ.

      docker ls

    // provision //
    //-----------//
    // - Запустить provision на указанной машине.

      # Пример
          docker-machine provision [имя машины]

      # Что происходит

        1. Set the hostname on the instance to the name Machine addresses it by (e.g. default).
        2. Install Docker if it is not present already.
        3. Generate a set of certificates (usually with the default, self-signed CA) and configure the daemon to accept connections over TLS.
        4. Copy the generated certificates to the server and local config directory.
        5. Configure the Docker Engine according to the options specified at create time.
        6. Configure and activate Swarm if applicable.

    // regenerate-certs //
    //------------------//
    // - Перегенерировать TLS-сертификаты и обновить указанную машину.

      docker-machine regenerate-certs [имя машины]

    // restart //
    //---------//
    // - Перезапустить указанную машину.
    // - Обычно это эквивалентно: docker-machine stop; docker-machine: start;
    // - Некоторые облачные хосты пытаются сделать "умный" рестарт с сохранением IP,

      docker-machine restart [имя машины]

    // rm //
    //----//
    // - Удалить указанную машину.
    // - При этом будет удалена локальная ссылка на машину.
    // - А также она будет удалены с облачного хостинга / платформы виртуализации.

      docker-machine rm [имя машины] [имя машины] [имя машины]

    // scp //
    //-----//
    // - Копировать файлы с localhost на указанную машину через scp.

      docker-machine ssh [имя машины] pwd
      docker-machine scp [имя машины]:/home/docker/foo.txt .

    // ssh //
    //-----//
    // - Выполнить на указанной машине команду через ssh.

      docker-machine ssh [имя машины] pwd

    // start //
    //-------//
    // - Запустить указанную docker-машину.

      docker-machine start [имя машины]

    // status //
    //--------//
    // - Получить статус указанной docker-машины.

      docker-machine status [имя машины]

    // stop //
    //------//
    // - Остановить указанную docker-машину.

      docker-machine start [имя машины]

    // upgrade //
    //---------//
    // - Обновить Docker на указанной docker-машине.
    // - Docker обновляется до последней версии.
    // - Процесс обновления зависит от дистрибутива Linux.

      docker-machine upgrade [имя машины]

    // url //
    //-----//
    // - Получить URL хоста указанной машины.

      docker-machine url [имя машины]


А6. Docker-сети, объединение и взаимодействие контейнеров в сетях

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Изоляция
    # Сети, доступные по умолчанию

      - Bridge / None / Host
      - Сети, как объекты в Docker
      - Вывести список доступных сетей
      - Выбрать сеть при создании контейнера
      - Как выглядит объект docker-сеть
      - Взаимодействие контейнеров в сети по умолчанию bridge

    # Кастомные сети

      - Общая информация
      - Сеть на драйвере bridge
      - Сеть на драйвере overlay [закончить по требованию]
      - О важности имён контейнеров

    # Особенности работы с портами, expose/public

      - В кастомной bridge-сети порты всех контейнеров открыты
      - Про EXPOSE/--expose
      - Опция -P (в верхнем регистре)
      - Опция -p (в нижнем регистре)

    # Список команд для работы с docker-сетями

      - docker network create       | создать новую docker-сеть
      - docker network connect      | подключить контейнер к существующей docker-сети
      - docker network ls           | вывести список всех доступных docker-сетей
      - docker network rm           | удалить docker-сеть
      - docker network disconnect   | отключиться от существующей docker-сети
      - docker network inspect      | получить информацию о существующей docker-сети

    # Немного практики

      - Создать новую кастомную bridge-сеть
      - Добавить в сеть 2 именованных контейнера, сделать ping по имени
      - Подключить и отключить контейнер от существующей сети
      - Подключиться к контейнеру, проверить его network stack

    # Реальный пример общения контейнеров в одной кастомной bridge-сети




    # О важности имён контейнеров
    # Два доступных из коробки драйвера: bridge и overlay

      - Вводная информация
      - Bridge
      - Overlay

    # Создание своей bridge-сети
    # Добавление контейнеров в bridge-сеть

  --------------------------------------

  > Ссылки

    # Оф.документация
      https://docs.docker.com/engine/userguide/networking/dockernetworks/
      https://docs.docker.com/engine/userguide/networking/work-with-networks/
      https://docs.docker.com/engine/userguide/networking/configure-dns/
      https://docs.docker.com/engine/userguide/networking/default_network/

    # Статья "A Brief Primer on Docker Networking Rules: EXPOSE, -p, -P, --link"
        https://www.ctl.io/developers/blog/post/docker-networking-rules/

    # Статья "Docker Tutorial Series : Part 8 : Linking Containers"
        http://rominirani.com/2015/07/31/docker-tutorial-series-part-8-linking-containers/

  > Введение
    - В этой главе будут рассмотрены docker-сети.
    - Контейнеры возможно объединять в сети.
    - Объединённые контейнеры могут общаться через сеть.
    - Например, они могут пропинговать друг-друга.
    - Бывают стандартные сети - bridge, overlay - и кастомные.
    - Bridge это сеть на 1-ом хосте, а overlay - между хостами.
    - Для эффективного управления overlay-сетями есть docker-swarm.

  > Изоляция
    - Веб-приложение может включать в себя много контейнеров.
    - Контейнеры могут взаимодействовать друг с другом через сети.
    - Сеть может быть как в рамках одного docker-хоста, так и многих.
    - Для достижения наивысшей безопасности сети д.б. изолированными.
    - То есть доступ в эти сети извне должен быть невозможен.
    - Именно такие сети и предлагает нам docker-networks.

  > Сети, доступные по умолчанию

    # Bridge / None / Host
      - После установки Docker доступны 3 сети по умолчанию.
      - Исторически сложилось, что эти сети являются частью Docker.
      - Эти сети пользователь никак не сможет удалить вручную.
      - На практике вряд ли понадобится взаимодействовать с none / host.
      - Все новые контейнеры по умолчанию добавляются в сеть bridge.
      - Вот список этих сетей:

        Name         Driver
        • bridge     bridge
        • none       none
        • host       host

    # Сети, как объекты в Docker
      - В Docker сети можно рассматривать в качестве объектов.
      - Каждому такому объекту соотв-ет сеть в Linux хост-машины.
      - Docker-сети "bridge" соответствует Linux-сеть "docker0".
      - Убедимся в этом (предполагая, что работаем из Windows):

        docker-machine ssh <имя машины>     | подключиться по SSH к хост-машине
        ifconfig                            | посмотреть список сетей на ней

    # Вывести список доступных сетей
      - Посмотреть их можно, введя следующую команду на host-машине:

          docker network ls

    # Выбрать сеть при создании контейнера
      - Создать контейнер можно командами docker create/run.
      - С помощью опции --net можно указать сеть для подключения.
      - По умолчанию Все новые контейнеры добавляются в сеть bridge.

    # Как выглядит объект docker-сеть
      - Посмотреть на это можно командой docker inspect.
      - Например, посмотрим на одну из сетей по умолчанию bridge.
      - Введём: docker network inspect bridge
      - Получим такой массив с объектами docker-сетей:

          [
             {
                 "Name": "bridge",
                 "Id": "f7ab26d71dbd6f557852c7156ae0574bbf62c42f539b50c8ebde0f728a253b6f",
                 "Scope": "local",
                 "Driver": "bridge",
                 "IPAM": {
                     "Driver": "default",
                     "Config": [
                         {
                             "Subnet": "172.17.0.1/16",
                             "Gateway": "172.17.0.1"
                         }
                     ]
                 },
                 "Containers": {},
                 "Options": {
                     "com.docker.network.bridge.default_bridge": "true",
                     "com.docker.network.bridge.enable_icc": "true",
                     "com.docker.network.bridge.enable_ip_masquerade": "true",
                     "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
                     "com.docker.network.bridge.name": "docker0",
                     "com.docker.network.driver.mtu": "9001"
                 }
             }
          ]

      - Пояснения к св-вам объектов docker-сетей:

          • Name      | Имя docker-сети
          • ID        | ID docker-сети
          • Scope     | Рамки работы docker-сети
          • Driver    | Драйвер docker-сети
          • Container | С какими контейнерами связана docker-сеть
          • Options   | Опции docker-сети

    # Взаимодействие контейнеров в сети по умолчанию bridge

      • По IP контейнера
        - Контейнеры в 1-ой сети могут общаться друг с другом.
        - Они могут делать это, зная IP друг друга в общей сети.
        - Узнать IP работающего контейнера не составляет труда.
        - Для этого надо (предполагая, что работаем из Windows):

            docker-machine ssh <имя машины>     | подключиться по SSH к хост-машине
            docker ps                           | узнать ID или имя контейнера
            docker attach <id|имя>              | подключиться к контейнеру
            ifconfig                            | посмотреть IP контейнера
            CTRL-p CTRL-q                       | отключиться от контейнера

        - Допустим, у нас есть 2 работающих контейнера в 1-ой сети.
        - Проверить возможность их взаим-ия можно с помощью ping.
        - Для этого надо первым делом узнать IP обоих контейнеров.
        - Затем подключиться к одному из них с помощью attach.
        - И выполнить команду: ping <ip другого контейнера>

      • По имени контейнера
        - По умолчанию Docker не находит другие контейнеры по имени.
        - И взаимодействовать по имени контейнеры просто так не могут.
        - Необходимо внучную линковать контейнеры при их создании.
        - При docker create/run нужно использовать опцию --link
        - Конечно, можно настраивать port mapping и использовать --link.
        - Но эта техника считается устаревшей, лучше создать кастомную сеть.
        - В кастомных сетях линковка контейнеров вообще не поддерживается.

  > Кастомные сети

    # Общая информация

      • Ты можешь создавать свои кастомные сети.
      • Кастомные сети обеспечивают лучшую изоляцию контейнеров.
      • Из коробки доступны 2 драйвера: bridge и overlay.
      • Но можно создать свой network plugin или remote network.
      • Можно создавать неограниченное кол-во кастомных сетей.
      • Один контейнер можно добавлять в неограниченное кол-во сетей.
      • Контейнеры могут общаться по сети только, если они в общей сети.

    # Сеть на драйвере bridge

     • Иллюстрация

      |------------------------------|
      | Изолированная кастомная сеть |       |-------------| Docker-хост может взаимодействовать
      |                              |   /---| Docker Host | с контейнерами по сети, через открытые
      |                       opened |  /    |-------------| ими порты.
      |       |-------------|  port  | /
      |       | Контейнер 1 |--------|-
      |       |-------------|        | \
      |                              |  \    |---------------| Какой-нибудь внешний хост тоже может взаимодействовать
      |       |-------------|        |   |---| External Host | с контейнерами по сети, через открытые
      |       | Контейнер 2 |        |   |   |---------------| ими порты.
      |       |-------------|        |   |
      |                              |   |
      |       |-------------|        |   |
      |       | Контейнер 3 |        |   |   |--------------------| Контейнер, который не состоит в кастомной сети,
      |       |-------------|        |    \--| External Container | может взаимодействовать с контейнерами этой сети
      |                              |       |--------------------| через открытые ими порты.
      |------------------------------|

     • Примечания
      - Внутри изолированной кастомной сети все порты открыты.
      - Каждый контейнер имеет доступ к п

     • Основная информация
      - Эта сеть похожа на присутствующую по умолчанию docker0.
      - Но они не полностью идентичны, что-то добавлено, что-то убрано.
      - С помощью bridge-сети можно объединять контейнеры в сеть на 1-ой host-машине.
      - А для объединения контейнеров в сеть на разных host-машинах нужна overlay-сеть.
      - Создать новую кастомную bridge-сеть можно так (выражения идентичны):

          docker network create <name>
          docker network create --driver bridge <name>

      - После создания можно убедиться, что сеть действительно создана.
      - А заодно и посмотреть все свойства объекта-сети:

        • Код
          docker network ls                   | вывести список сетей
          docker network inspect <name>       | вывести объект сети <name>

        • Объект сети <name>

          [
              {
                  "Name": "isolated_nw",
                  "Id": "1196a4c5af43a21ae38ef34515b6af19236a3fc48122cf585e3f3054d509679b",
                  "Scope": "local",
                  "Driver": "bridge",
                  "IPAM": {
                      "Driver": "default",
                      "Config": [
                          {
                              "Subnet": "172.21.0.0/16",
                              "Gateway": "172.21.0.1/16"
                          }
                      ]
                  },
                  "Containers": {},
                  "Options": {}
              }
          ]

      - После создания сети, можно добавлять в неё контейнеры.
      - Добавлять контейнер в сеть можно при его создании.
      - С помощью опции --net в командах docker create/run
      - Например:

        • Код

            docker run --net=<network> -itd --name=<contname> busybox
            docker network inspect <network>

        • Пояснения
          - Здесь мы создаём и запускаем контейнер командой docker run.
          - <network> это имя созданной ранее кастомной сети.
          - <contname> это имя для нового контейнера.
          - busybox это образ, из которого мы создаём контейнер.
          - Во 2-м выражении мы выводим содержимое объекта-сети.
          - В "Containers" объекта мы видим новый контейнер.

        • Объект-сеть:

          [
              {
                  "Name": "isolated_nw",
                  "Id": "1196a4c5af43a21ae38ef34515b6af19236a3fc48122cf585e3f3054d509679b",
                  "Scope": "local",
                  "Driver": "bridge",
                  "IPAM": {
                      "Driver": "default",
                      "Config": [
                          {}
                      ]
                  },
                  "Containers": {
                      "8c1a0a5be480921d669a073393ade66a3fc49933f08bcc5515b37b8144f6d47c": {
                          "EndpointID": "93b2db4a9b9a997beb912d28bcfc117f7b0eb924ff91d48cfa251d473e6a9b08",
                          "MacAddress": "02:42:ac:15:00:02",
                          "IPv4Address": "172.21.0.2/16",
                          "IPv6Address": ""
                      }
                  },
                  "Options": {}
              }
          ]

      - Линковка контейнеров в кастомной bridge-сети не поддерживается.
      - Зато можно expose (выставлять) и publish (публиковать) порты контейнеров.
      - Это полезно, чтобы сделать часть bridge-сети доступной вне сети.

    # Сеть на драйвере overlay [закончить по требованию]
      - [закончить пункт по требованию]

    # О важности имён контейнеров
      - Контейнеры могут общаться по сети, используя имена друг друга.
      - В кастомной bridge-сети эта фича работает "из коробки".
      - В default bridge-сети надо использовать --link, чтобы оно заработало.
      - При создании контейнера можно не указывать для него имя.
      - Тогда Docker автоматически сгенерирует имя вроде "nostalgic_morse".
      - Однако, автоматически созданное имя ничего не говорит о контейнере.
      - Лучше всё же самому указывать имя, которое:

        • Иллюстрировало бы предназначение контейнера
        • Было бы коротким и лёгким для запоминания
        • Было бы уникальным на этой хост-машине

      - Назначить имя можно при создании контейнера флагом --name.
      - Например:

          docker run -d -P --name web training/webapp python app.py

      - Убедиться, что имя назначено, можно командой: docker ps -l

  > Особенности работы с портами, expose/public

    # В кастомной bridge-сети порты всех контейнеров открыты
      - Любой контейнер имеет доступ к любому порту другого.
      - Но лишь в том случае, если они в 1-ой кастомной bridge-сети.

    # Про EXPOSE/--expose
      - При создании образа можно применять инструкцию EXPOSE.
      - При создани контейнера можно применять опцию --expose.
      - Инструкция EXPOSE и опция --expose делают одно и тоже.
      - Просто данные из --expose дополняют данные из EXPOSE.
      - Они сообщают, какие порты из контейнера надо бы пробросить.
      - Но в реальности никаких портов на host-машину не пробрасывают.

    # Опция -P (в верхнем регистре)
      - Эта опция применяется при создании контейнера.
      - Она извлекает инфу обо всех exposed-портах.
      - И пробрасывает все эти порты на host-машину.
      - При этом на host-машине выбираются свободные случайные порты.
      - Эти случайные порты выбираются из диапазона от 32768 до 61000.
      - Если требуется указать конкретные порты, используй опцию -p (в нижнем регистре).

    # Опция -p (в нижнем регистре)
      - Позволяет пробросить любой порт между контейнером и host-машиной.
      - При этом пробрасываемый порт не обязан быть exposed у контейнера.
      - Опция -p задаёт правила в формате:

          ip:hostPort:containerPort

      - Где:

          • ip            | не обязателен   |
          • hostPort      | не обязателен   | порт на host-машине
          • containerPort | обязателен      | порт в контейнере

      - Если не задать hostPort, он будет подобран автоматически.

  > Список команд для работы с docker-сетями

    • docker network create
    • docker network connect
    • docker network ls
    • docker network rm
    • docker network disconnect
    • docker network inspect

  > Немного практики работы с кастомной bridge-сетью

    # Создать новую кастомную bridge-сеть

      docker network create -d bridge my-bridge-network   // создать
      docker network ls                                   // вывести список сетей
      docker network inspect my-bridge-network            // убедиться, что в новой сети нет контейнеров

    # Добавить в сеть 2 именованных контейнера, сделать ping по имени

      • Создать контейнеры и добавить их в сеть

        docker run -itd --net="my-bridge-network" --name="name1" ubuntu bash
        docker run -itd --net="my-bridge-network" --name="name2" ubuntu bash
        docker ps

      • Подключиться к контейнеру name1

        docker-machine ssh <имя вирт.машины>  | например, default
        docker attach name1

      • Сделать ping контейнера name2

        ping name2

    # Подключить и отключить контейнер от существующей сети

      • Подключить

        docker network connect my-bridge-network name1  // подключить
        docker network inspect my-bridge-network        // проверить

      • Отключить

        docker network desconnect my-bridge-network name1   // отключить
        docker network inspect my-bridge-network            // проверить

    # Подключиться к контейнеру, проверить его network stack

      docker attach name1
      ifconfig

  > Реальный пример общения контейнеров в одной кастомной bridge-сети

    # Постановка задачи
      - Исходим из того, что работа с docker ведётся на Windows.
      - Будем в этой задаче работать с in-memory хранилищем данных Redis.
      - Это хранилище имеет клиент-серверную архитектуру.
      - Мы хотим поместить redis-сервер в контейнер X.
      - Мы хотим поместить redis-клиент в контейнер Y.
      - Контейнеры X и Y мы поместим в одну кастомную bridge-сеть.
      - Затем из Y подключимся к X, убедимся что всё работает.

    # Реализация

      • Создадим сначала новую кастомную bridge-сеть

        docker network create -d bridge my-bridge-network

      • Создадим и запустим 2 контейнера, с redis-сервером и клиентом

        docker run -d --name redisserver redis            | сервер
        docker run -itd --name redisclient redis bash     | клиент
        docker network inspect my-bridge-network          | удостоверимся

      • Подключим redis-сервер и redis-клиент к сети my-bridge-network

        docker network connect my-bridge-network redisserver
        docker network connect my-bridge-network redisclient

      • Подключимся к клиенту, пропингуем сервер

        docker-machine ssh default    | подключаемся из Win к boot2docker
        docker attach redisclient     | подключаемся к клиенту
        ping redisserver              | внутри клиента пингуем сервер

      • Из клиента подключимся к серверу, потестируем его

        redis-cli -h redisserver      | через порт 6379
        PING                          | PONG
        set myvar DOCKER              | OK
        get myvar                     | "DOCKER"

      • Отключимся от redis-клиента, от контейнера, от boot2docker

        ctrl-c          | выход из redis-клиента
        ctrl-p, ctrl-q  | detach из контейнера
        exit            | отключение ssh от boot2docker

      • Удалим созданные контейнеры и сеть

        docker stop dockerserver dockerclient
        docker rm dockerserver dockerclient
        docker network rm my-bridge-network

    # Примечания

      • Для имён контейнеров используй только [a-zA-Z0-9]
        - Иначе могут быть проблемы при общении контейнеров через имена.


А7. Управление данными в/между контейнерами

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Суть кратко

      - Про архитектуру Docker
      - Docker machines работает через VirtualBox
      - Что такое volumes

    # Управление общими папками в VirtualBox
    # Создание объектов volume

      - Вывод списка всех объектов volume на host-машине
      - Именованные / Не именованные
      - С авто ссылкой / С ручной ссылкой
      - Создание объекта volume в DockerFile

    # Передача ссылок на объекты volume от одного контейнера другому

      - Суть дела
      - Создание (без запуска) спец.контейнера - пула ссылок на объекты volumes
      - Внимание! Не допускать одновременную запись N-контейнеров в 1-ну volume-папку
      - Backup данных
      - Restore данных

    # Удаление объектов volume

      - Удаление объекта volume при удалении контейнеров
      - Удаление объектов-зомби volume
      - Прямое удаление объекта volume

    # Набор полезных code-tips

  --------------------------------------

  > Ссылки

    # Оф.статья "Manage data in containers"
        - https://docs.docker.com/engine/userguide/containers/dockervolumes/

    # Статья Ивана Бесарабова "Эксперименты с докерными volumes"
        https://ivan.bessarabov.ru/blog/docker-volumes-experiments

  > Введение
    - В этой главе рассмотрим так называемые data volumes.

  > Суть кратко

    # Про архитектуру Docker

      • При работе с Docker на Windows архитектура выглядит так:

          Docker client (Windows)
              |
            Docker host (docker machines with boot2docker linux dist)
                |
              Docker server (Docker Engine)

      • А при работе на Linux:

          Native host (Linux)
              |
            Docker server (Docker Engine)

    # Docker machines работает через VirtualBox
      - Это актуально, если client и host это разные машины.
      - К примеру, client на Windows, а host на docker machine.
      - VirtualBox в этом случае расшаривает по умолчанию лишь 1 каталог.
      - Это: c:/users (client) <---> /c/users (host)

    # Что такое volumes
      - Это такие объекты в мире Docker на host-машине.
      - Каждый такой объект содержит ссылку на каталог на host-машине.
      - В чём их суть:

        • Ссылки на volumes можно передавать в контейнеры
          - А каждый volume содержит ссылку на папку на host-машине.
          - Поэтому контейнер может читать/писать по этой ссылке.
          - А раз папка на host-машине, то и данные сохраняются на постоянной основе.
          - В отличие от, как мы знаем, данных в контейнерах.
          - Volumes не зависят от контейнеров, при удалении последних не удаляются.

        • Можно в volume передать ссылку на общую между client/host папку
          - На host у нас имеется общая с client на Windows папка /c/users.
          - Можно в volume засунуть ссылку на неё и передать volume в контейнер.
          - Тогда контейне сможет работать прямо с данными на client (windows).

  > Управление общими папками в VirtualBox
    - Это актуально, если client и host это разные машины.
    - К примеру, client на Windows, а host на docker machine.
    - VirtualBox в этом случае расшаривает по умолчанию лишь 1 каталог.
    - Это: c:/users (client) <---> /c/users (host)
    - Но в настройках VirtualBox можно настроить ещё:

      • VirtualBox -> Настроить -> Общие папки

  > Создание объектов volume

    # Вывод списка всех объектов volume на host-машине
      - Можно просмотреть все объекты volume на host-машине.
      - В том числе увидеть именованный ли тот или иной объект.
      - Здесь предполагаем, что client и host это разные машины.
      - К примеру, client на Windows, а host на docker machine.
      - Тогда:

        • Сначала убедимся, что docker-машина запущена

            docker-machine ls             | список и статус docker-машин
            docker-machine start <name>   | если надо запустить машину <name>

        • Подключить powershell к docker-машине <name>

            docker-machine env --shell powershell <name>
            docker-machine env --shell powershell <name> | Invoke-Expression

        • Вывод списка объектов volume

            docker volume ls

    # Именованные / Не именованные

      • Не именованные объекты volume
        - Каждый объект volume должен иметь UID в пределах host-машины.
        - По умолчанию при создании объект volume получает примерно такой UID:
            b82577be399e690f61e4183c38bf28282bf2c9709133b142600906e24a20f176
        - Такие объекты volume называют не именованными.
        - Пример создания не именованного объекта volume:

            docker run -itd -v /myvolume ubuntu /bin/bash

        - !!! При этом volume связывается с создаваемым контейнером !!!

      • Именованные объекты volume
        - Однако можно задать объекту volume имя при его создании.
        - Такие объекты volume называют именованными.
        - Пример создания объекта volume с именем "somename":

            docker run -itd -v somename:/myvolume ubuntu /bin/bash

        - !!! При этом volume НЕ связывается с создаваемым контейнером !!!

    # С авто ссылкой / С ручной ссылкой

      • Пример объекта volume
        - К каждому контейнеру можно прикрепить >= 0 объектов volume.
        - Для каждого контейнера можно получить объект с его описанием.
        - В этом объекте будет ключ "mounts" с массивом.
        - В этом массиве будут связанные с контейнером объекты volume.
        - Вот так можно всё посмотреть:

          • Сначала убедимся, что docker-машина запущена

              docker-machine ls             | список и статус docker-машин
              docker-machine start <name>   | если надо запустить машину <name>

          • Подключить powershell к docker-машине <name>

              docker-machine env --shell powershell <name>
              docker-machine env --shell powershell <name> | Invoke-Expression

          • Посмотрим список контейнеров на хост-машине и их ID/имён:

              docker ps -l

          • Получим объект с описанием контейнера <name>:

              docker inspect <name>

        - Вот пример volume-объекта:

             {
                "Name": "b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507",
                "Source": "/mnt/sda1/var/lib/docker/volumes/b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507/_data",
                "Destination": "/myvolume",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
             }

        - Здесь:

            Name          | имя объектм volume
            Source        | ссылка на папку на host-машине
            Destination   | ссылка на папку в контейнере

      • С ручной ссылкой
        - При создании объекта volume можно указать <path>.
        - Это может быть путь к каталону на host-машине.
        - В том числе и общему с client-машиной каталогу.
        - Укажем ссылку на "/c/users/uerman" на host-машине:

            docker run -itd -v /c/users/german:/myvolume ubuntu /bin/bash

        - Теперь контейнер связан с только чтозданным volume объектом.
        - И у volume объекта:

           {
              ...
              "Source": "/c/users/german",
              "Destination": "/myvolume",
              ...
           }

      • С авто ссылкой
        - Однако можно и не указывать <path>, опустив его.
        - Сделаем это:

            docker run -itd -v /myvolume ubuntu /bin/bash

        - Теперь контейнер связан с только чтозданным volume объектом.
        - На host-машине в каталоге "/mnt/sda1/var/lib/docker/volumes/"
          была создана новая папка с именем == "Name" volume объекта.
        - Поэтому новый объект volume выглядит примерно так:

           {
              "Name": "b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507",
              "Source": "/mnt/sda1/var/lib/docker/volumes/b4e743ad1ff29d625ecfafe4a60a58414702326d10c618458148bbd4d305a507/_data",
              "Destination": "/myvolume",
              ...
           }

    # Создание объекта volume в DockerFile
      - Это сделать невозможно из-за зависимости <path> host-машины от оной.
      - Это ломает портативность, а DockerFile должен работать на всех host-машинах.
      - Инструкция VOLUME в DockerFile лишь:

        • Помечает точку монтирования.
        • Помечает, что контент из неё не идёт в образ.
        • Помечает, что она д.б. доступна другим контейнерам через --volumes-from

      - Ну типа, вот образ, а вот у него есть такие-то точки монтирования.
      - А в доках к образу написано, куда какие данные надо подключить.

  > Передача ссылок на объекты volume от одного контейнера другому

    # Суть дела
      - Допустим ты создал и запустил именованный контейнер "mystorage".
      - Во время создания ты связал его с набором объектов volumes:

        docker run -itd \
          -v /vol1 \
          -v /vol2 \
          -v /vol3 \
          -v /vol4 \
          -v /vol5 \
          --name mystorage \
          ubuntu /bin/bash

      - Затем ты собрался создать и запустить ещё контейнер с тем же набором объектов volumes.
      - Это д.б. не новые объекты volume, а ссылки на те самые, из примера выше.
      - Сделать это можно с помощью флага --volumes-from:

        docker run -itd \
          --volumes-from mystorage  \
          ubuntu /bin/bash

    # Создание (без запуска) спец.контейнера - пула ссылок на объекты volumes
      - Этот контейнер можно создать исключительно для этих целей.
      - Для хранения и передачи другим контейнерам пула ссылок на объекты volume.
      - Создать контейнер без запуска можно командой docker create:

          docker create \
            -v /vol1 \
            -v /vol2 \
            -v /vol3 \
            -v /vol4 \
            -v /vol5 \
            --name mystorage \

    # Внимание! Не допускать одновременную запись N-контейнеров в 1-ну volume-папку
      - Более 1-го контейнера могут иметь одинаковый пул ссылок на volume-объекты.
      - Это было описано выши и достигается с помощью флага --volumes-from.
      - Как следствие все эти контейнеры теоретически могут одновременно записывать в 1 каталог.
      - Следствием этого м.б. повреждение данных в этом каталоге.
      - Никакой встроенной защиты от этого нет, всё на пользователе.
      - Следует продумывать архитектуру для избежания подобных ситуаций.

    # Backup данных
      - В каталогах из ссылок объектом volume хранятся всякие постоянные данные.
      - А у нас, допустим, есть спец.контейнер с пулом ссылок на все эти volume-объекты.
      - С его помощью мы можем без проблем сделать бэкап всех данных.
      - Причём не только на host-машину, но даже и на client-машину.
      - А ведь client и host могут быть разными машинами.
      - К примеру, client на Windows, а host на docker machine.
      - По умолчанию у них 1 общая папка: c:/users (client) <---> /c/users (host)
      - Можно из контейнера делать бэкап прямо в эту общую папку.

        • Исходные условия
          - У нас имеется контейнер dbstore с пулом ссылок volume-объекты.
          - Для простоты предположим, что в пуле лишь 1-ин volume-объект.
          - И что у него "Destination": "/dbdata".
          - Нам требуется заархивировать /dbdata и положить в /с/users/backups.

        • Решение
          - Ниже представлено решение.
          - После выполнения команды tar контейнер самоуничтожится.

            docker run \                            | создать и запустить новый контейнер
              --rm \                                | удалить контейнер после завершения
              --volumes-from dbstore \              | связать контейнер с пулов объектом volume из контейнера dbstore
              -v /с/users/backups:/backup \         | создать новый объект volume с ручной ссылкой на /с/users/backups на host-машине, и адресом /backups в контейнере
              ubuntu \                              | создавать контейнер из образа ubuntu
              tar cvf /backup/backup.tar /dbdata    | заархивировать /dbdata и положить в /с/users/backups

    # Restore данных

      • Исходные условия
        - У нас имеется архив с /с/users/backups/backup.tar
        - Мы хотим создать новый контейнер и связать его с новым объектом volume.
        - У этого объекта должен быть "Destination": "/dbdata".
        - Мы хотим распаковать backup.tar в "/dbdata".

      • Решение
        - Ниже представлено решение.
        - Сначала надо создать и запустить новый контейнер.
        - Создать новый объект volume и связать его с этим контейнером.

            docker run \              | создать и запустить новый контейнер
              -v /dbdata \            | создать новый объект volume с авто.ссылкой и Destination == /dbdata, и связать с контейнером
              --name dbstore2 \       | назвать контейнер dbstore2
              ubuntu \                | создавать контейнер из образа ubuntu
              /bin/bash               | после создания запустить процесс /bin/bash

        - Затем надо загрузить в контейнер данные из backup.tar.
        - После выполнения команды tar контейнер самоуничтожится.

            docker run \                                                    | создать и запустить новый контейнер
              --rm \                                                        | удалить контейнер после завершения
              --volumes-from dbstore2 \                                     | связать контейнер с пулом объектов volume из контейнера dbstore2
              -v /с/users/backups:/backup \                                 | создать новый объект volume с ручной ссылкой на /с/users/backups на host-машине, и адресом /backups в контейнере
              ubuntu \                                                      | создавать контейнер из образа ubuntu
              bash -c "cd /dbdata && \                                      | перейти в каталог /cbdata
              tar xvf /backup/backup.tar --strip 1"                         | распаковать архив из /backup/backup.tar в текущий каталог

  > Удаление объектов volume

    # Удаление объекта volume при удалении контейнеров
      - Пусть у нас 3-ри контейнера связаны с 1-им объектом volume.
      - Вот что происходит при удалении этих контейнеров:

        docker rm <контейнер 1>     | volume не удалился
        docker rm <контейнер 2>     | volume не удалился
        docker rm <контейнер 3>     | volume не удалился

      - Как видно из примера, объект volume остался цел.
      - Но если при удалении последнего контейнера указать флаг -v

        docker rm -v <контейнер 3>  | volume удалился

    # Удаление объектов-зомби volume
      - Это объекты volume на которые уже не связаны ни с 1-им контейнером.
      - Они появляются при удалении всех связанных контейнеров без флага -v
      - Найти и удалить такие объекты volume можно так:

          docker volume ls -f dangling=true   | показать список объектов-зомби volume на host-машине
          docker volume rm <name>             | удалить объект volume с хост-машины

    # Прямое удаление объекта volume
      - Можно просто взять и вручную удалить объект volume.
      - Но использующие его контейнеры останутся с битыми ссылками.
      - Вот так это делается:

        docker volume ls                      | посмотреть список всех объектов volume на host-машине
        docker volume rm <name>               | удалить объект volume с хост-машины

  > Набор полезных code-tips

      docker-machine ls                             | список и статус docker-машин
      docker-machine start <name>                   | если надо запустить машину <name>
      docker-machine env --shell powershell <name>
      docker-machine env --shell powershell <name>  | Invoke-Expression
      docker ps -l                                  | список всех контейнеров на host-машине
      docker inspect <name>                         | объект с описанием контейнера <name> на host-машине
      docker volume ls                              | список всех объектов volume на host-машине

      docker-machine ssh <name>                     | подключиться по ssh к работающей docker-машине <name>
      docker exec -it <name> /bin/bash              | создать новый интерактивный процесс /bin/bash в контейнере <name>



А8. Сборка образов из DockerFile и контекста

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Что такое DockerFile
    # Использование

      - Контекст сборки
      - Название и путь к DockerFile
      - Репозиторий куда сохранить новый образ
      - Как применяется DockerFile
      - Инструкции выполняются независимо
      - Использование кэша для ускорения работы
      - Размещение образа на Docker Hub

    # Формат DockerFile

      - Как устроены комментарии
      - Инструкции не зависят от регистра
      - Первой инструкцией ДОЛЖНА быть FROM

    # Переменные среды, как переменные в DockerFile

      - Инструкция ENV
      - Чтение ENV-переменных
      - Экранирование переменных
      - Замена значения переменной осуществляется в конце инструкции
      - Переменные среды поддерживаются следующими DF-инструкциями

    # Про .dockerignore

      - Перед отправкой контекста docker-демон ищет .dockerignore
      - Формат .dockerignore
      - Пример .dockerfile
      - Все пробелы и ".", ".." по краям паттерна удаляются
      - Специальный wildcard **
      - Символ ! в начале строки означает исключение из правила исключения
      - Можно даже исключить DockerFile и .dockerignore из контекста
      - Паттерн . игнорируется по историческим причинам
      - Инверсия .dockerignore'а с помощью *! первым паттерном

    # Справка по инструкциям DockerFile

      - FROM          | Выбрать базовый образ, к нему будут применяться все последующие инструкции
      - MAINTAINER    | Указать автора генерируемого образа
      - RUN           | Выполнить command/exec и закоммитить результат в образ
      - CMD           | Команда по умолчанию при запуске контейнера из этого образа
      - LABEL         | Метаданные для образа в формате ключ=значение
      - EXPOSE        | Информировать Docker'а, что контейнеру нужны такие-то порты
      - ENV           | Назначить переменные среды для нижележащих инструций аля <key> <value>
      - ADD           | Копирует файлы/каталоги из <src> в <dest> контейнера
      - COPY          | Аналог ADD, но без tar и URL возможностей
      - ENTRYPOINT    | Позволяет превратить контейнер в некий сервис
      - VOLUME        | Пометить точку монтирования для образа
      - USER          | От имени какого пользователя выполнять инструкции из DockerFile в контейнере
      - WORKDIR       | Устанавливает рабочий каталог WORKDIR
      - ARG           | Определяет переменные которые можно передать команде docker build
      - ONBUILD       | Назначить триггер и инструкцию для базовых образов
      - STOPSIGNAL    | Послать экземпляру контейнера на завершение работы

    # Несколько примеров DockerFile
    # DockerFile Best Practice: общие советы

      - Контейнеры д.б. одноразовые
      - Применяй .dockerignore
      - Не добавляй лишние слои
      - Запускай лишь 1-ин процесс в контейнере
      - Минимизируй кол-во слоёв
      - Сортируй многострочные аргументы
      - Используй кэш

    # DockerFile Best Practice: по инструкциям

      - FROM
      - RUN
      - apt-get
      - CMD
      - EXPOSE
      - ENV
      - ADD/COPY
      - ENTRYPOINT
      - VOLUME
      - USER
      - WORKDIR
      - ONBUILD

  --------------------------------------

  > Ссылки

    # Оф.справка "Dockerfile reference"
        https://docs.docker.com/engine/reference/builder/

    # Оф.справка "Best practices for writing Dockerfiles"
        https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/

    # Как создавать файл .dockerignore
        https://docs.docker.com/engine/reference/builder/#dockerignore-file

  > Введение
    - В этой главе раскрыта тема работы с DockerFile.
    - Присутствует справочник по инструкциям для него.

  > Что такое DockerFile
    - DF - это txt файл с инструкциями для создания Docker-образа.
    - Он может содержать все те команды, которые можно применять
      в CLI при создании нового образа.
    - Создать новый образ с помощью DF можно командой docker build.

  > Использование

    # Контекст сборки
      - Команда docker build соберает образ из DF и контекста.
      - В качестве контекста можно передать:

        • path    | локальный путь к каталогу
        • url     | url к репозиторию на github

      - Переданный контекст передаётся docker-демону рекурсивно.
      - Многие команды из DF могут обращаться к переданному контексту.
      - В простейшем случае контекстом м.б. текущий пустой каталог:

          docker build .

      - В файле .dockerignore можно исключать ф-лы/кат-ги из контекста.
      - Как создавать этот файл описано по ссылке из ссылок главы.

    # Название и путь к DockerFile
      - Традиционно этому файлу присваивают имя DockerFile.
      - И обычно его размещают в корневой каталог контекста.
      - Но никто не мешает назвать его как угодно по другому.
      - И поместить в любое другое место.
      - Однако, Docker по умолчанию ожидает "DockerFile" в корне контекста.
      - Указать путь к DockerFile вручную можно флагом -f:

          docker build -f /path/to/a/Dockerfile .

    # Репозиторий куда сохранить новый образ
      - Можно указать репозиторий для сохранения нового образа.
      - Можно даже указать какой-то конкретный тег для нового релиза.
      - Можно указать не 1, а много репозиториев:

          docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .

    # Как применяется DockerFile
      - Docker запускает инструкции из DF одну за одной.
      - Результаты выполнения инструкций применяет к новому образу.
      - В конце концов Docker возвращает ID нового образа.
      - Копия всего переданного контекста после этого удаляется.

    # Инструкции выполняются независимо
      - Каждая инструкция из DF выполняется независимо от других.
      - Например, инструкция "RUN cd /tmp" никак не повлияет на следующие.

    # Использование кэша для ускорения работы
      - Для ускорения работы Docker использует кэш промежуточных образов.
      - Во время осуществления сборки он сообщает об этом в терминале.

    # Размещение образа на Docker Hub
      - После сборки образа его можно разместить в Docker Hub.

  > Формат DockerFile

    # Как устроены комментарии
      - В DF можно писать комментарии, используя #.
      - Например:

          # Comment
          RUN echo 'we are running some # of cool things'

    # Инструкции не зависят от регистра
      - Однако принято писать их В ВЕРХНЕМ РЕГИСТРЕ.
      - Например: INSTRUCTION arguments

    # Первой инструкцией ДОЛЖНА быть FROM
      - Тут без вариантов, "FROM" обязана быть 1-й инструкцией в DF.
      - Эта инструкция позволяет указать базовый образ для сборки.

  > Переменные среды, как переменные в DockerFile

    # Инструкция ENV
      - Позволяет назначать назначать значения переменным среды.
      - А также могут использоваться в качестве переменных в DF.
      - Это позволяет передавать разные данные между инструкциями в DF.
      - Например:

          FROM busybox
          ENV foo /bar

    # Чтение ENV-переменных
      - Переменную foo можно читать, как $foo или ${foo}.
      - Оба вышеуказанных варианта являются эквивалентными.
      - Наличие 2-ух вариантов синтаксиса может пригодиться.
      - Синтакс с {} также поддерживает некоторые bash-модификаторы:

        • ${variable:-word}
          - Если variable not set, присвоить ей значение word.
          - Если variable is set, присвоить оставить это значение.

        • ${variable:+word}
          - Если variable is set, присвоить ей значение word.
          - Если variable not set, присвоить ей значение "".

      - Во всех случаях word м.б. любой строкой, включая ENV-переменные.

    # Экранирование переменных
      - Функционал экранирования переменных также присутствует.
      - Экранирование может осуществляться с помощью \
      - Это позволяет применять имена переменных буквально.
      - Например:

          COPY \$foo /quux    # COPY $foo /quux

    # Замена значения переменной осуществляется в конце инструкции
      - Нельзя в 1-ой инструкции заменить значение foo и тут же его использовать.
      - Пример:

          ENV abc=hello
          ENV abc=bye def=$abc    // $def == hello, а не bye
          ENV ghi=$abc            // ghi == buy, а не hello

    # Переменные среды поддерживаются следующими DF-инструкциями

      • ADD
      • COPY
      • ENV
      • EXPOSE
      • LABEL
      • USER
      • WORKDIR
      • VOLUME
      • STOPSIGNAL
      • ONBUILD       | (при комбинировании с одной из перечисленных выше)

  > Про .dockerignore

    # Перед отправкой контекста docker-демон ищет .dockerignore
      - Docker-демон ищет файл .dockerignore в корне контекста.
      - Если файл DI существует, docker-демон считывает его.
      - DI содержит список путей для исключения из контекста.
      - Перед отправкой контекста из него исключаются эти пути.
      - Это позволяет избежать пересылки docker-демону лишних файлов.

    # Формат .dockerignore
      - Это разделённый символами новой строки список glob-паттернов.
      - Корневым каталогом вчитается корень контекста DockerFile.

    # Пример .dockerfile

        */temp*
        */*/temp*
        temp?

      Пояснения

        • */temp*
          - Исключает ф-лы и кат-ли с начинающимися с temp именами.
          - Из любого подкаталого 1-го уровня относительно корня.
          - Примеры: /dir1/temprary.txt, /dir2/temp

        • */*/temp*
          - Исключает ф-лы и кат-ли с начинающимися с temp именами.
          - Из любого подкаталого 2-го уровня относительно корня.
          - Примеры: /dir1/dir2/temprary.txt, /dir3/dir4/temp

        • temp?
          - Исключает ф-лы и кат-ли с начинающимися с temp именами,
            состоящие из 5 символов, где 5-й символ м.б. любым.
          - Примеры: /tempa, /tempb

    # Все пробелы и ".", ".." по краям паттерна удаляются
      - Матчинг проводится с помощью правил filepath.Match языка Go.
      - Все пробелы и ".", ".." по краям паттерна удаляются
        с помощью filepath.Clean языка Go.
      - Пустые строки игнорируются.

    # Специальный wildcard **
      - Он не поддерживается filepath.Match языка Go.
      - Но Docker поддерживает этот wildcard.
      - Он означает любое кол-во каталогов, включая нулевое.

    # Символ ! в начале строки означает исключение из правила исключения
      - До или после любого правила можно добавить исключения.
      - На самом деле, исключения можно добавлять в любое место .dockerignore
      - Каждое исключение должно начинаться с !
      - Например:

          *.md          | не передавать все *.md из корневого каталога
          !README.md    | кроме этого файла, его передавать

      - Позиция исключения в .dockerignore влияет на результаты.
      - Рассмотрим два примера для иллюстрации этого утверждения:

        • Пример №1
          - В контекст не включаются .md-файлы, кроме README-secret.md.

            *.md
            !README*.md
            README-secret.md

        • Пример №2
          - Все начинающиеся с README файлы включаются в контекст.
          - Строка README-secret.md, поскольку она идёт до, перекрывается
            строкой !README*.md

            *.md
            README-secret.md
            !README*.md

    # Можно даже исключить DockerFile и .dockerignore из контекста
      - Можно добавить их в .dockerignore и исключить из контекста.
      - При этом они всё равно будут отправлены docker-демону.
      - Ведь docker-демону они просто необходимы для работы.
      - Но вот в инструкциях типа ADD, COPY они уже будут недоступны.

    # Паттерн . игнорируется по историческим причинам
      - Сабж.

    # Инверсия .dockerignore'а с помощью *! первым паттерном
      - Можно инвертировать весь .dockerignore.
      - Для этого 1-ым паттерном надо написать: *!
      - Обычные инструкции будут указывать пути для включения.
      - Инструкции с ! указывать пути для исключения.

  > Справка по инструкциям DockerFile

    // FROM //
    //------//
    // - Выбрать базовый образ, к нему будут применяться все последующие инструкции.
    // - Это инструкция ДОЛЖНА БЫТЬ 1-ОЙ в DockerFile.
    // - Это может быть образ с Docker Hub, или локальный образ.

      # Синтаксис

        • FROM <image>
        • FROM <image>:<tag>
        • FROM <image>@<digest>

      # Примечания

        • FROM должна быть первой инструкцией-не-комментарием в DockerFile.
        • FROM может появляться >= 1 раза в одном DockerFile
          - Это позволит в 1-ом DockerFile создать несколько образов.
        • Значения <tag> и <digest> опциональны
          - Применяется значение latest если их опустить.
          - Билдер вернёт ошибку если не сможет найти соотв.тегу релиз.

    // MAINTAINER //
    //------------//
    // - Указать автора генерируемого образа.

      MAINTAINER YOUR NAME <YOUR EMAIL>

    // RUN //
    //-----//
    // - Выполнить command/exec и закоммитить результат в образ

      # RUN имеет 2-ве формы

        • Shell-форма
          - Команда запускается в командной строке.
          - В качестве обработчика по умолчанию используется /bin/sh.
          - Формат и пример:

              RUN <command>
              RUN /bin/sh

          - Можно использовать \ для разделения строк команды.
          - Например это считается 1-ой RUN-командой:

              RUN /bin/bash -c 'source $HOME/.bashrc ;\
              echo $HOME'

        • Exec-форма
          - Запускается указанная программа из исполняемого файла.
          - Как обычно, обработчик для неё указывается в начале файла.
          - Формат:

              RUN ["executable", "param1", "param2"] (exec form)

          - Примеры обработчиков в начале файлов:

              #!/bin/bash
              #!/bin/node

          - Использование exec-формы позволяет избежать путаницы.
          - Exec-форма орабатывается, как JSON-массив.
          - Поэтому следует вместо '' использовать "" везде.
          - В отличие от shell-формы, exec-форма не подставляет переменные.
          - Потому что при выполнении exec командная оболочка не выполняется.
          - Например, что-то типа этого не сработает:

              RUN [ "echo", "$HOME" ]     | переменная $HOME не подставится

          - Чтобы исправить дело, надо вручную выполнять командную оболочку.
          - Например:

              RUN [ "sh", "-c", "echo", "$HOME" ]

      # Использование отличной от /bin/sh оболочки
        - Для этого надо воспользоваться exec-формой.
        - Например, если нужен /bin/bash:

            RUN ["/bin/bash", "-c", "echo hello"]

      # Кэш для RUN-инструкций не истекает автоматически между билдами
        - Допустим делали билд и выполнили в нём RUN-инструкцию:

            RUN apt-get dist-upgrade -y

        - При этом результат её выполнения закэшировался Docker'ом.
        - Потом вы решаете сделать другой билд с такой же инструкцией.
        - На этот раз никакой работы не происходит, результат берётся из кэша.
        - Но можно запретить кэширование с помощью флага --no-cache:

            RUN apt-get dist-upgrade -y --no-cache

        - Также кэш RUN-инструкций м.б. инвалидирован ADD-инструкциями.

    // CMD //
    //-----//
    // - Команда по умолчанию при запуске контейнера из этого образа.
    // - Подоглавление
    //
    //    • Пояснения к ENTRYPOINT
    //    • Пояснения к CMD
    //    • CMD имеет 3 формы
    //    • Примечания
    //

      # Пояснения к ENTRYPOINT
        - Термином "entrypoint" называют обработчик по умолчанию.
        - Изначально в Docker в качестве EP используется /bin/sh -c.
        - И если запустить такой код:

            docker run -i -t ubuntu bash

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Поэтому bash будет запущен с помощью EP == /bin/sh.
        - То есть, вот таким образом: /bin/sh -c bash
        - Потом народ запросил возможность указывать другой EP.
        - Появился параметр -entrypoint и инструкция ENTRYPOINT.
        - Как ENTRYPOING могут быть полезны на примере:

          Исходная ситуация
            • У нас есть образ с Redis.
            • Его данные хранятсв volume вне образа.
            • Мы хотим запросить данные из хранилища по ключу.
            • Сейчас мы можем это сделать примерно так:

                docker run redisimg redis -H something -u toto get key

          Упрощение с помощью ENTRYPOINT
            • Берём и делаем в DockerFile такой EntryPoint:
                ENTRYPOINT ["redis", "-H", "something", "-u", "toto"]
            • Благодаря этому запрос из хранилища по ключу упростился:

                docker run redisimg get key

      # Пояснения к CMD
        - Выше мы узнали о существовании entrypoint по умолчанию.
        - Но вот команды по умолчанию нет, это пустая строка.
        - Но её можно задать с помощью инструкции CMD в DockerFile.
        - Допустим, мы задали: CMD bash
        - Тогда при выполнении:

            docker run -i -t ubuntu

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Хоть мы и не указали bash после ubuntu, она выполнилась.
        - Потому что мы указали bash в кач-ве CMD в DockerFile.

      # CMD имеет 3 формы

        • Exec-форма
          - Основной формат для CMD:

              CMD ["executable","param1","param2"]

        • Default-форма
          - Можно передать лишь параметры для entrypoint:

              CMD ["param1","param2"]

        • Shell-форма
          - Тоже самое, что exec, только здесь вместо exec указывают команду:

              CMD command param1 param2

      # Примечания

        • Если использована default-форма CMD
          - То ENTRYPOINT тоже ОБЯЗАНА присутствовать.
          - И обе инструкции д.б. в JSON-формате.

        • Exec-форма парсится, как JSON массив
          - То есть везде вместо '' надо применять "".

        • В отличие от shell-формы, exec-форма не подставляет переменные
          - Потому что при выполнении exec командная оболочка не выполняется.
          - Например, что-то типа этого не сработает:

              RUN [ "echo", "$HOME" ]     | переменная $HOME не подставится

          - Чтобы исправить дело, надо вручную выполнять командную оболочку.
          - Например:

              RUN [ "sh", "-c", "echo", "$HOME" ]

        • Если вы выбрали shell-форму
          - То <command> будет выполнено тем, что указано в entrypoint.
          - По умолчанию там указано /bin/sh -c
          - Но можно запустить <command> и без оболочки.
          - Для этого надо передать значение в формате JSON-массива.
          - Эта JSON-форма является предпочтительной для CMD.
          - Пример:

              CMD ["/usr/bin/wc","--help"]

        • CMD в DockerFile м.б. перезаписан параметром в docker run
          - Сабж.

        • Не перепутай CMD с RUN
          - RUN во время сборки запускает команду и коммитит результат.
          - CMD к сборке образа не имеет никакого отношения.
          - Она срабатывает лишь при запуске контейнера на основе этого образа.

    // LABEL //
    //-------//
    // - Метаданные для образа в формате ключ=значение.
    // - В одном DockerFile можно использовать несколько LABEL.

      # Примеры применения LABEL

        LABEL "com.example.vendor"="ACME Incorporated"
        LABEL com.example.label-with-value="foo"
        LABEL version="1.0"
        LABEL description="This text illustrates \
        that label-values can span multiple lines."

      # Помните про ограничение 127 слоёв
        - Каждый LABEL, как и другие инструкции, образует новый слой.
        - Но при этом особой важности для образа не имеет.
        - Большое кол-во LABEL можен тестолково потратить эти 127 мест.
        - Эффективнее было бы впихнуть нужную информацию в 1-ин LABEL.
        - Вот ещё примеры:

            LABEL multi.label1="value1" multi.label2="value2" other="value3"
            LABEL multi.label1="value1" \
                  multi.label2="value2" \
                  other="value3"

      # Как посмотреть LABELS конкретного образа
        - Для этого надо использовать команду docker inspect.
        - Нужная информация будет в объекте с ключём "Labels".

    // EXPOSE //
    //--------//
    // - Информировать Docker'а, что контейнеру нужны такие-то порты.
    // - Внимание! Это НЕ открывает соответствующие порты для контейнера.
    // - Открыть все "выставленные" порты можно флагом -P при docker run.
    // - Пробросить любые порты при docker run можно флагом -p (p в нижнем регистре).

      EXPOSE <port> [<port>...]

    // ENV //
    //-----//
    // - Назначить переменные среды для нижележащих инструций аля <key> <value>.
    // - Можно в одной инструкции назначить от 1-й и более пар.
    // - Их можно использовать в качестве переменных в нижележащих инструкциях.

      # Форматы

        • Формат №1
          - Вся строка после <key> будет рассматриваться, как <value>

              ENV <key> <value>

        • Формат №2
          - Можно указать сколько угодно пар <key>=<value> через пробел.

              ENV <key>=<value> ...

      # Примеры
        - Ниже пара примеров, которые эквивалентны.
        - 1-ый вариант предпочтительнее, он создаёт лишь 1 слой.

            ENV myName="John Doe" myDog=Rex\ The\ Dog \
                myCat=fluffy

            ENV myName John Doe
            ENV myDog Rex The Dog
            ENV myCat fluffy

      # ENV-переменные сохраняются у образа напостоянной основе
        - Вот какой-то разработчик сделал образ.
        - И у него в DockerFile был такой слой:

            ENV DEBIAN_FRONTEND noninteractive

        - Затем вы решили сделать свой образ на основе его образа.
        - В вашем DockerFile доступна переменная DEBIAN_FRONTEND.
        - И в запущенном из образа контейнере она тоже будет доступна.
        - Если Вы её не заметите, то у вас apt-get работать нормально не будет.

      # Посмотреть ENV-переменные образа можно через docker inspect
        - Надо искать ключ "env".

      # Изменить ENV-переменную при запуске можно ключём --env
        - Например:

            docker run --env <key>=<value>

    // ADD //
    //-----//
    // - Копирует файлы/каталоги из <src> в <dest> контейнера.
    // - В качестве <src> могут быть локальные (path) и удалённые (url).
    // - Подоглавление
    //
    //    • Форматы
    //    • Wildcards в <src>
    //    • Все новые файлы и каталоги создаются с UID == GID == 0
    //    • Если <src> это URL
    //    • Набор замечаний
    //    • ADD подчиняется следующим правилам
    //

      # Форматы

        • Формат №1
          - Можно указать от 1 и больше <src> и один <dest>.
          - Если <src> локальные, путь д.б. относительно корня контекста.

              ADD <src>... <dest>

          - <dest> м.б. абсолютным path.
          - Или относительным с корнем в WORKDIR, куда источники будут скопированы.

              ADD test relativeDir/          # adds "test" to `WORKDIR`/relativeDir/
              ADD test /absoluteDir/         # adds "test" to /absoluteDir/

        • Формат №2
          - Эта форма для путей, содержащих пробелы.

              ADD ["<src>",... "<dest>"]

      # Wildcards в <src>
        - Каждый <src> представляет glob-шаблон.
        - Т.Е. можно применять всякие: * / ? / т.д.
        - Всё это обрабатывается с помощью filepath.Math в GO.
        - Например:

            ADD hom* /mydir/        # adds all files starting with "hom"
            ADD hom?.txt /mydir/    # ? is replaced with any single character, e.g., "home.txt"

      # Все новые файлы и каталоги создаются с UID == GID == 0
        - Сабж.

      # Если <src> это URL

        • Всё в <dest> будет иметь chmod 600.
        • Если вернётся HTTP-заголовок Last-Modifyed
          - Он будет использован для установки mtime файлов в <dest>.
          - Однако, mtime не применяется для того, чтобы определить,
            обновился ли файл, и надо ли обновить кэш.

      # Набор замечаний

        • Если DockerFile передаётся в docker build через STD IN
          - В этом случае контекст полностью отсутствует.
          - Поэтому в ADD могут быть лишь <src> с URL.
          - Пример:

              docker build - < somefile

          - Кроме случая, когда передаётся архив.
          - DockerFile должен лежать в корне этого архива.
          - Всё остальное в нём будет рассматриваться в кач-ве контекста.
          - Пример:

              docker build - < archive.tar.gz

        • Если <src> это URL требующий аутентификации
          - Тогда надо использовать RUN wget / RUN curl / другой инструмент.
          - Поскольку инструкция ADD не поддерживает аутентификацию.

        • Замечание по поводу инвалидации кэша инструкцией ADD
          - Кэш инвалидируется в случае изменения содержимого по адресу <src>.
          - Кэш инвалидируется для всех последующих инструкций в Dockerfile.
          - В том числе и для инструкции RUN.

      # ADD подчиняется следующим правилам

        • Локальный <src> не может быть абсолютным
          - Это должен быть относительный локальный путь.
          - В качестве root используется корень контекста.

        • Если <src> URL, а <dest> НЕ заканчивается на /
          - То файл из <src> просто копируется в <dest>.

        • Если <src> URL, а <dest> заканчивается на /
          - То имя для файла из <src> берётся из URL.
          - И файл копируется по адресу <dest>/<filename>
          - Например:

              ADD http://example.com/foobar /

          - Это создаст файл: /foobar
          - Кроме того, URL в <src> должен иметь URI, отличный от /
          - Например, такой URL не сработает, т.к. неоткуда брать <filename>:

              http://example.com

        • Если <src> является каталогом
          - То весь контент каталога копируется.
          - Включая метаданные файловой системы.
          - Сам же каталог не копируется, только его содержимое.

        • Если по адресу <src> находится архив
          - Если это локальный path, архив будет распакован в <dest>.
          - Если это URL, то архив НЕ будет распакован, а будет скопирован в <dest>.

        • Если <src> это файл
          - Он копируется индивидуально, в соотв. со своими метаданными.
          - Плюс см.выше особенности, если <dest> заканчивается или нет на /

        • Если указаны более 1-го <src>
          - Не важно, прямо или с использованием wildcards.
          - Тогда <dest> ОБЯЗАН быть каталогом и заканчиваться на /

        • Если <dest> не заканчивается на /
          - То он будет считаться обычным файлом.
          - И содержимое <src> будет записано в этот файл <dest>.

        • Если <dest> не существует
          - Он будет автоматически создан.


    // COPY //
    //------//
    // - Аналог ADD, но без tar и URL возможностей.

    // ENTRYPOINT //
    //------------//
    // - Позволяет превратить контейнер в некий сервис.
    // - Подоглавление
    //
    //    • Форматы
    //    • Пояснения к ENTRYPOINT
    //    • Превращение контейнера в сервис на примере
    //    • Пояснения к CMD
    //    • ENTRYPOINT м.б. перезаписана с помощью флага --entrypoint
    //    • Только последняя инструкция ENTRYPOINT в DockerFile имеет силу
    //
    //    • Пример работы с exec-форматом ENTRYPOINT
    //    • Пример работы с shell-форматом ENTRYPOINT
    //

      # Форматы

        • Формат №1
          - Это exec-формат, он является предпочтительным.
          - Формат:

              ENTRYPOINT ["executable", "param1", "param2"]

        • Формат №2
          - Это shell-формат (не рекомендуется).
          - Предотвращает использование CLI-аргументов CMD и run.
          - При этом ENTRYPOINT выполняется, как подкаманда /bin/sh -c
          - А последний не передаёт никаких сигналов от ОС.
          - То есть исполняемая не будет PID 1 контейнера.
          - А значит, например, сигнал выключения контейнера docker stop <container>
            не будут доходить.
          - Формат:

              ENTRYPOINT command param1 param2

      # Пояснения к ENTRYPOINT
        - Термином "entrypoint" называют обработчик по умолчанию.
        - Изначально в Docker в качестве EP используется /bin/sh -c.
        - И если запустить такой код:

            docker run -i -t ubuntu bash

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Поэтому bash будет запущен с помощью EP == /bin/sh.
        - То есть, вот таким образом: /bin/sh -c bash
        - Потом народ запросил возможность указывать другой EP.
        - Появился параметр -entrypoint и инструкция ENTRYPOINT.

      # Превращение контейнера в сервис на примере
        - Исходная ситуация
            • У нас есть образ с Redis.
            • Его данные хранятсв volume вне образа.
            • Мы хотим запросить данные из хранилища по ключу.
            • Сейчас мы можем это сделать примерно так:

                docker run redisimg redis -H something -u toto get key

        - Упрощение с помощью ENTRYPOINT
            • Берём и делаем в DockerFile такой EntryPoint:
                ENTRYPOINT ["redis", "-H", "something", "-u", "toto"]
            • Благодаря этому запрос из хранилища по ключу упростился:

                docker run redisimg get key

        - Рассмотрим повнимательнее, что именно здесь происходит.
        - Каким образом будет формироваться итоговая команда:

          • Сначала идёт: docker run <image>
          • Потом аргументы из ENTRYPOINT: redis -H something -U toto
          • Потом идёт то, что было справа от docker run <image>: get key.
          • Итог: docker run redisimg redis -H something -U toto get key
          • Иллюстрация:

              docker run <image>   Аргументы из ENTRYPOINT    Аргументы команды
              -------------------|--------------------------|------------------
              docker run redisimg redis -H something -U toto get key

      # Пояснения к CMD
        - Выше мы узнали о существовании entrypoint по умолчанию.
        - Но вот команды по умолчанию нет, это пустая строка.
        - Но её можно задать с помощью инструкции CMD в DockerFile.
        - Допустим, мы задали: CMD bash
        - Тогда при выполнении:

            docker run -i -t ubuntu

              Здесь
              • EP == /bin/sh
              • Образ == ubuntu
              • Команда == bash

        - Хоть мы и не указали bash после ubuntu, она выполнилась.
        - Потому что мы указали bash в кач-ве CMD в DockerFile.

      # ENTRYPOINT м.б. перезаписана с помощью флага --entrypoint
        - Например: docker run --entrypoint

      # Только последняя инструкция ENTRYPOINT в DockerFile имеет силу
        - Сабж.

      # Пример работы с exec-форматом ENTRYPOINT

        • Применяйте ENTRYPOINT для стабильных команд и аргументов
          - Которые должны присутствовать при docker run всегда.
          - А CMD для дополнительных, которые скорее всего заменяются.
          - Например:

              FROM ubuntu
              ENTRYPOINT ["top", "-b"]
              CMD ["-c"]

          - Вот как это будет работать

              docker run ubuntu             // Вызовет: docker run ubuntu top -b -c
              docker run ubuntu -a          // Вызовет: docker run ubuntu top -b -a

        • После запуска контейнера убедитесь, что top 1-нный процесс
          - То есть он не является подпроцессом, скажем, /bin/sh
          - А является единственным процессом, запущенном в контейнере.
          - Пример:

              docker run -it --rm --name test  top -H

          - А для уже работающего контейнера:

              docker exec -it test ps aux

        • Следствием обладания PID == 1 является возможность получать сингналы
          - Допустим в контейнере запущен 1 процесс top с PID == 1.
          - Docker может послать контейнеру test сигнал docker stop test.
          - Процесс top получит этот сигнал и мягко (gracefully) завершится.

        • Пример запуска apache в фореграунд с PID == 1

            FROM debian:stable
            RUN apt-get update && apt-get install -y --force-yes apache2
            EXPOSE 80 443
            VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]
            ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]

        • Как в скрипте убедиться, что final executable получает unix-сигналы
          - С помощью команд exec и gosu.
          - Например:

              #!/bin/bash
              set -e

              if [ "$1" = 'postgres' ]; then
                  chown -R postgres "$PGDATA"

                  if [ -z "$(ls -A "$PGDATA")" ]; then
                      gosu postgres initdb
                  fi

                  exec gosu postgres "$@"
              fi

              exec "$@"

        • Можно даже повесить хук на завершение работы
          - Допустим вы запустили контейнер со своей bash-программой.
          - И в случае получения сигнала завершения надо сделать некую работу.
          - Что-нибудь подчистить, например, или провзаимодействовать с другими контейнерами.
          - Тогда следует убедиться в том, что скрипт в ENTRYPOINT получает unix-сигналы,
            пропускает их, и выполняет некую работу.
          - Пример:

              #!/bin/sh
              # Note: I've written this using sh so it works in the busybox container too

              # USE the trap if you need to also do manual cleanup after the service is stopped,
              #     or need to start multiple services in the one container
              trap "echo TRAPed signal" HUP INT QUIT KILL TERM

              # start service in background here
              /usr/sbin/apachectl start

              echo "[hit enter key to exit] or run 'docker stop <container>'"
              read

              # stop service and clean up here
              echo "stopping apache"
              /usr/sbin/apachectl stop

              echo "exited $0"

        • Ряд замечаний

          • Можно перезаписать ENTRYPOINT с помощью флага --entrypoint
            - Во время использования docker run.
            - В этом случае будет использовать exec-формат ENTRYPOINT.

          • Exec-формат парсится, как JSON-массив
            - Поэтому везде надо использовать '' вместо "".

          • В отличии от shell-формата, exec-формат не запускает командную оболочку
            - Это означает, что обычного оболочечного процесса не происходит.
            - Для примера рассмотрим:

                ENTRYPOINT [ "echo", "$HOME" ]

            - Никакой подстановки значения $HOME не произойдёт.
            - Чтобы оболочечный процесс сработал, надо вручную вызвать оболочку.
            - Например:

                ENTRYPOINT [ "sh", "-c", "echo", "$HOME" ]

            - Однако подстановка ENV-переменных будуте производиться
              в любом случае парсером DockerFile.

      # Пример работы с shell-форматом ENTRYPOINT

        • В качестве ENTRYPOINT можно указать обычную строку
          - Тогда будет запущен процесс /bin/sh -c
          - И эта строка будет исполнена в нём.
          - Любые аргументы из CMD и docker run будут проигнорированы.

        • Лучше начинать с exec
          - Рассмотрим пример:

              FROM ubuntu
              ENTRYPOINT exec top -b

          - И запустим его:

              docker run -it --rm --name test top

          - Мы увидим лишь 1 процесс top с PID == 1.
          - При поступлении сигнала завершения от Linux от мягко завершится.
          - Но если забыть указать "exec" в "exec top -b", например:

              FROM ubuntu
              ENTRYPOINT top -b
              CMD --ignored-param1

          - То в top будут 2 процесса: /bin/sh с PID == 1, и top.
          - В этом случае все сигналы от Linux будет получать /bin/sh.
          - В результате завершать процесс top мягко будет невозможно.
          - Top будет завершаться жёстко после таймаута при поступлении
            от Linux сигнала завершения в /bin/sh.

    // VOLUME //
    //--------//
    // - Пометить точку монтирования для образа.
    // - Помечает, что контент из неё не идёт в образ.
    // - Помечает, что она д.б. доступна другим контейнерам через --volumes-from

      # Формат

          VOLUME ["/data"]

      # Суть кратко
        - В DockerFile можно задать задачу по созданию объекта volume.
        - Эту задачу можно задать с помощью инструкций VOLUME и RUN.
        - Подобных задач в DockerFile можно задать >= 0.
        - Все они будут срабатывать при создании контейнера командой
          docker run из данного образа.
        - Как это работает на примере:

            FROM ubuntu
            RUN mkdir /myvol                          | создать в контейнере каталог /myvol
            RUN echo "hello world" > /myvol/greeting  | создать файл /myvol/greeting с содержимым "hello world"
            VOLUME /myvol                             | создать новый объект volume с Destination == /myvol, и связать с новым контейнером

      # Можно ли создать новый объект volume инструкцией VOLUME?
        - Это сделать невозможно из-за зависимости <path> host-машины от оной.
        - Это ломает портативность, а DockerFile должен работать на всех host-машинах.
        - Инструкция VOLUME в DockerFile лишь:

          • Помечает точку монтирования.
          • Помечает, что контент из неё не идёт в образ.
          • Помечает, что она д.б. доступна другим контейнерам через --volumes-from

        - Ну типа, вот образ, а вот у него есть такие-то точки монтирования.
        - А в доках к образу написано, куда какие данные надо подключить.

      # Что произойдёт после docker run из такого образа
        - Мы решили создать новый образ из DockerFile.
        - Содержимое DockerFile:

            FROM ubuntu
            RUN mkdir /myvol
            RUN echo "hello world" > /myvol/greeting
            VOLUME /myvol

        - Затем мы с помощью docker run создаём контейнер из этого образа.
        - Что при этом будет происходить:

          • Будет создан новый объект volume
            - На той host-машине, где выполнена команда docker run.
            - При этом будет применён метод создания с авто ссылкой.
            - В контейнере появится каталог /myvol со ссылкой на
              каталог из авто ссылки объекта volume на host-машине.
          • Этот объект будет связан с этим новым контейнером.
          • В контейнере появится файл /myvol/greetin с содержимым "Hello World".

      # Важные примечания

        • Нельзя менять данные в Destination после инструкции VOLUME
          - Все подобные изменения будут проигнорированы.
          - Как не надо делать:

              VOLUME /myvol
              RUN echo "hello world" > /myvol/greeting  | будет проигнорировано

          - Как надо делать:

              RUN echo "hello world" > /myvol/greeting  | будет проигнорировано
              VOLUME /myvol

        • Список аргументов VOLUME парсится, как JSON массив.
        • Поэтому вместо '' везде надо использовать "".

    // USER //
    //------//
    // - От имени какого пользователя выполнять инструкции из DockerFile в контейнере.
    // - Можно указать как имя пользователя, так и UID.
    // - Применяется длк инструкций в DockerFile: RUN, CMD и ENTRYPOINT.

      USER daemon

    // WORKDIR //
    //---------//
    // - Устанавливает рабочий каталог WORKDIR.
    // - В контейнере по умолчанию WORKDIR == /

      # Что делает инструкция WORKDIR
        - Устанавливает рабочий каталог WORKDIR для контейнера.
        - Следующие инструкции из DockerFile используют его:

          • RUN
          • CMD
          • ENTRYPOINT
          • COPY
          • ADD

      # WORKDIR по умолчанию, узнать текущий WORKDIR

        • WORKDIR по умолчанию
          - По умолчанию WORKDIR == / во всех контейнерах.

        • Как посмотреть WORKDIR контейнера
          - Значение WORKDIR хранится в объекте с данными контейнера.
          - Его можно посмотреть с помощью команды docker inspect.
          - Следует искать значение с ключём "WorkingDir".

            docker inspect <name>

          - Если "WorkingDir" пустое, значит WORKDIR == /
          - Ещё можно подключиться к контейнеру и узнать в нём.
          - Для этого:

              docker run -itd -v /myvolume ubuntu /bin/bash
              pwd -P

      # Абсолютный и относительные пути в значениях WORKDIR
        - Инструкцию WORKDIR можно использовать в DockerFile >=0 раз.
        - При это можно указывать относительный/абсолютный путь.
        - Если указать абсолютный, новое значение перезапишет предудыщее:

            WORKDIR /a
            WORKDIR /b
            RUN pwd       | /b

        - Если указывать относительный, он будет прибавляться к предыдущему.
        - Например:

            WORKDIR /a
            WORKDIR b
            WORKDIR c
            RUN pwd       | /a/b/c

      # Использование в значении WORKDIR переменных среды
        - Допускается только для определённых в DockerFile ENV-переменных.
        - Пример:

            ENV DIRPATH /path
            WORKDIR $DIRPATH/$DIRNAME
            RUN pwd                       | /path/$DIRNAME

    // ARG //
    //-----//
    // - Определяет переменные которые можно передать команде docker build
    // - Передача идёт таким образом: docker build --build-arg <varname>=<value>
    // - При попытке передать не определённые ARG в DF аргументы, будет ошибка.
    // - В DockerBuilder может быть >= 0 инструкций ARG.
    // - Подоглавление:
    //
    //  • Шаблон
    //  • Ошибка при попытке передать не определённые аргументы
    //  • Примеры и значение по умолчанию
    //  • ARG вступает в силу с момента появления в DockerFile
    //  • Не рекомендуется передавать через ARG секретные данные
    //  • ENV имеет бОльший приоритет, чем ARG
    //  • Подсказка по работе с ENV и ARG - их надо комбинировать
    //  • Зарезервированные ключи для ARG
    //  • Влияние на кэширование билда
    //

      # Шаблон

          ARG <name>[=<default value>]

      # Ошибка при попытке передать не определённые аргументы
        - Будет выглядеть так:

            One or more build-args were not consumed, failing build.

      # Примеры и значение по умолчанию
        - Примеры применения ARG:

            FROM busybox
            ARG user1
            ARG buildno

        - Примеры назначения значений по умолчанию.
        - Они будут применены если при docker build пользователь
          не задаст сооветствующие значения аргументов.

            FROM busybox
            ARG user1=someuser
            ARG buildno=1
            ...

      # ARG вступает в силу с момента появления в DockerFile
        - То есть использовать его можно в инструкциях ниже определения.
        - Даже если значение для ARG задано в docker build --build-arg.
        - Пример:

            docker build --build-arg user=what_user Dockerfile

            1 FROM busybox
            2 USER ${user:-some_user}   | some_user, т.к. user ещё не определён
            3 ARG user
            4 USER $user                | what_user, т.к. user уже определён
            ...

      # Не рекомендуется передавать через ARG секретные данные
        - То есть помещать их в docker build --build-arg
        - Типа ключей от github, платёжные данные и т.д.

      # ENV имеет бОльший приоритет, чем ARG
        - Для определения переменных в DF можно использовать ENV / ARG.
        - Но при наличии одинаковых переменных, ENV всегда перезаписывает ARG.
        - Это похоже на поведение в скрипте, где локальные переменные перезаписывают глобальные.
        - Пример:

            docker build --build-arg CONT_IMG_VER=v2.0.1 Dockerfile

            1 FROM ubuntu
            2 ARG CONT_IMG_VER
            3 ENV CONT_IMG_VER v1.0.0
            4 RUN echo $CONT_IMG_VER    // v1.0.0

      # Подсказка по работе с ENV и ARG - их надо комбинировать
        - ARG-переменные далеко не всегда присутствуют в сборке.
        - Зато ENV-переменные всегда присутствуют в сборке.
        - Например:

            docker build Dockerfile

            1 FROM ubuntu
            2 ARG CONT_IMG_VER                          | отсутствует
            3 ENV CONT_IMG_VER ${CONT_IMG_VER:-v1.0.0}  | назначается v1.0.0
            4 RUN echo $CONT_IMG_VER

        - В этом примере мы скомбинировали ENV и ARG.
        - Это по большому счёту является тернарным оператором.
        - Если ARG отсутствует, то определяется ENV с дефолтным значением.

      # Зарезервированные ключи для ARG
        - Которые нельзя перезаписывать.
        - И которые можно использовать в любом DockerFile
          без соответствующей инструкции ARG:

            • HTTP_PROXY
            • http_proxy
            • HTTPS_PROXY
            • https_proxy
            • FTP_PROXY
            • ftp_proxy
            • NO_PROXY
            • no_proxy

        - Но передавать их в --build-arg <varname>=<value> всё равно надо:

      # Влияние на кэширование билда
        - ARG не присутствуют в итоговом образе, в отличие от ENV.
        - Однако ARG влияют различным образом на кэширование.
        - Если в DockerFile определена ARG со значением, отличающимся
          от значения при предыдущей сборке, тогда кэш сбросится
          только на строге, где ARG в DF в 1-й раз будет использован,
          а не на строке, где он будет определён.
        - Например:

            1 FROM ubuntu
            2 ARG CONT_IMG_VER
            3 RUN echo $CONT_IMG_VER     | кэш сбросится здесь

        - И другой пример:

            1 FROM ubuntu
            2 ARG CONT_IMG_VER
            3 ENV CONT_IMG_VER $CONT_IMG_VER  | кэш сбросится здесь
            4 RUN echo $CONT_IMG_VER          |

    // ONBUILD //
    //---------//
    // - Назначить триггер и инструкцию для базовых образов.

      # Суть
        - Позволяет добавить образу триггер и инструкцию.
        - Триггер сработает, если этот образ в будущем используют, как базовый.
        - То есть с применением инструкции FROM.
        - Триггер будет выполнен в контексте низлежащего потока инструкций,
          как будто инструкция стоит сразу после инструкции FROM в DockerFile.

      # Какие инструкции можно зарегистрировать, как триггеры
        - Любые, кроме FROM и MAINTAINER.

      # В каких случаях применяются триггеры
        - Когда ты разрабатываешь базовый для создания других образов образ.
        - Например среда для сборки приложений.
        - Или демон, который может быть кастомизирован пользовательскими параметрами.
        - Рассмотрим пример:

          • Исходные условия
            - Делаем образ для сборки python-приложений.
            - Этот образ предполагается использовать много раз.
            - Ему для работы понадобится иметь исходники в определённой папке.
            - И скрипт для сборки д.б. запущен ПОСЛЕ монтирования данных.
            - Использовать ADD/RUN нельзя, нет доступа к исходному коду.
            - Конечно, можно заранее проинструкрировать пользователей этого образа.
            - Что нужно сделать RUN, который скопирует такие-то файлы туда-то, и т.д.
            - Но это делает неудобным использование данного образа, надо автоматизировать.

          • Решение
            - В этой ситуации можно применить инструкцию ONBUILD.
            - Она будет запущена во время следующего билда.
            - Вот как это работает:

              1. Парсер нашёл инструкцию ONBUILD
                - Он добавляет триггер в метаданные создаваемого образа.
                - Эта инструкция никак не влияет на процесс создания текущего образа.

              2. В конце процесса создания образа данные обо всех триггерах добавляются в манифест образа
                - Манифест образа это тот самый объект со свойствами образа.
                - Его ещё можно посмотреть с помощью команды docker insect <name>.

              3. Позже при создании других образов этот м.б. использован в кач-ве базового
                - Для этого первой инструцией в DF указывается FROM от этого образа.
                - Парсер начинает обрабатывать инструкцию FROM, и также просматривает триггеры.
                - И выполняет триггеры сразу после FROM в порядке их появления в манифесте образа.
                - Если любой из триггеров вызывает ошибку, вся операция отваливается.
                - Если все триггеры обработаны успешно, обработка FROM завершается.
                - Дальше процесс сборки продолжается, как обычно.

              4. Триггеры базового образа не присутствуют в итоговом образе
                - Другими словами, они им не наследуются.

      # Примеры

          [...]
          ONBUILD ADD . /app/src
          ONBUILD RUN /usr/local/bin/python-build --dir /app/src
          [...]

      # Примечания
        - Цепочки типа ONBUILD ONBUILD запрещены.
        - В ONBUILD нельзя применять инструкции FROM и MAINTAINER.


    // STOPSIGNAL //
    //------------//
    // - Послать экземпляру контейнера на завершение работы
    // - Значение signal м.б. любым валидным unsigned значением.
    // - Наприимер, 9.

        STOPSIGNAL signal

  > Несколько примеров DockerFile

    • Пример №1

        # Nginx
        #
        # VERSION               0.0.1

        FROM      ubuntu
        MAINTAINER Victor Vieux <victor@docker.com>

        LABEL Description="This image is used to start the foobar executable" Vendor="ACME Products" Version="1.0"
        RUN apt-get update && apt-get install -y inotify-tools nginx apache2 openssh-server

    • Пример №2

        # Firefox over VNC
        #
        # VERSION               0.3

        FROM ubuntu

        # Install vnc, xvfb in order to create a 'fake' display and firefox
        RUN apt-get update && apt-get install -y x11vnc xvfb firefox
        RUN mkdir ~/.vnc
        # Setup a password
        RUN x11vnc -storepasswd 1234 ~/.vnc/passwd
        # Autostart firefox (might not be the best way, but it does the trick)
        RUN bash -c 'echo "firefox" >> /.bashrc'

        EXPOSE 5900
        CMD    ["x11vnc", "-forever", "-usepw", "-create"]

    • Пример №3

        # Multiple images example
        #
        # VERSION               0.1

        FROM ubuntu
        RUN echo foo > bar
        # Will output something like ===> 907ad6c2736f

        FROM ubuntu
        RUN echo moo > oink
        # Will output something like ===> 695d7793cbe4

        # You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with
        # /oink.

  > DockerFile Best Practice: общие советы

    # Контейнеры д.б. одноразовые
      - Под "одноразовые" имеется в виду следующее:

        • Абсолютный минимум настроек при старте.
        • Отсутствие постоянной информации в контейнере.
        • Можно уничтожить/создать, ничего не изменится.

    # Применяй .dockerignore
      - Это позволит увеличить скорость сборки образов.
      - Делай вот что:

        • Клади .dockerignore в корень контекста.
        • Добавляй всякие файлы в контекст.
        • Исключай ненужные из сборки с помощью .dockerignore.

    # Не добавляй лишние слои
      - Это уменьшит сложность, зависимости, размер и время сборки образа.
      - Не надо добавлять лишние слои "просто чтоб были".
      - Например, не надо добавлять nano в ubuntu - "чтоб был".

    # Запускай лишь 1-ин процесс в контейнере
      - В большинстве случаев надо запускать 1-ин процесс в 1-ом контейнере.
      - То есть процесс с PID == 1.
      - Это:

        • Упрощает горизонтальное масштабирование.
        • Упрощает повторное использование контейнеров.
        • Позволяет процессу получать сигналы от ОС хоста (т.к. PID == 1)
        • Если 1-ин сервис зависит от другого, используй container link.

    # Минимизируй кол-во слоёв
      - Советы следующие:

        • Найди баланс между читаемостью DockerFile и MIN-ией кол-ва слоёв.
        • Ведь кол-во слоёв в образе ограничено числом 127.

    # Сортируй многострочные аргументы
      - Часто в DockerFile применяются многострочные инструкции.
      - Ведь каждая инструкция создаёт новый слой, а их надом MIN-ать.
      - Поэтому часто в одну инструкцию стараются впихнуть по максимуму.
      - Чтобы было легче работать с DockerFile, сортируйте аргументы.
      - В примере ниже они отсортированы по алфавитно-цифровой сортировке:

          RUN apt-get update && apt-get install -y \
            bzr \
            cvs \
            git \
            mercurial \
            subversion

    # Используй кэш
      - Docker выполняет инструкции из DockerFile одну за одной.
      - Для каждой он проверяет наличие валидного кэша.
      - В случае наличия такового, операции не прводятся, используется кэш.
      - Если ты не хочешь использовать кэш совсем:

          docker build --no-cache=true

      - Но если ты всё же разрешил Docker использовать кэш.
      - Важно знать, когда он находит/не находит соотв.образ.
      - Вот этим базовым правилам следует Docker:

        • Базовый образ изначально находится в кэше
          - Затем просматривается 1-ая инструкция от базового.
          - Пробегаются все образы в кэше 1-го уровня относ.базового.
          - Если соотв.кэш не находится, тогда кэш для 1-й инструкции инвалидируется.
          - А заодно инвалидируется и для всех низлежащих инструкций.

        • Обычно простого сравнения достаточно
          - Инструкции в DockerFile с оной в дочернем образе.
          - Но для некоторых инструкций требуются пояснения, они ниже.

        • Для инструкций ADD/COPY проверяется контент файлов
          - Для каждого файла проверяется контрольная сумма.
          - Таймстампы lastmodyfied и lastaccessed не учитываются.
          - Если что-то изменилось, кэш инвалидируется.

        • Контрольные суммы не учитывают файлы в контейнере
          - Например, выполняем: "RUN apt-get -y update"
          - Файлы в контейнере не будут проверяться на изменение.
          - В этом случае, лишь вышеуказанноа строка проверится.

        • Инвалидация кэша для 1-го слоя инвалидирует кэш всех низлежащих слоёв.

  > DockerFile Best Practice: по инструкциям

    # FROM

      • Лучше используй базовый образы из оф.репозиториев.
      • Разработчики Docker рекомендуют образ Debian
        - Они его очень плотно контролируют.
        - Он очень маленький, но при этом полнофункциональный.
        - https://hub.docker.com/_/debian/

    # RUN

      • Разбивай большие сложные RUN-инструкции на разные строки.
      • Это сделает DockerFile легче-читаемым.
      • Разбитие на строки можно проводить спомощью \ в конце строки.

    # apt-get
      - Очень часто в RUN используется apt-get.
      - Поскольку при этом устанавливаются пакеты, есть подводные камни:

        • Избегай "RUN apt-get upgrade" или "dist-upgrade"
          - Эти выражение не обновят многие пакеты из "базовых" образов.
          - Если надо обновить конкретны пакет, используй:

              apt-get update && apt-get install -y foo

        • Техника "cache busting": всегда комбинируй "apt-get update" и "apt-get install"
          - В одной и той же инструкции RUN.
          - Это гарантия того, что "apt-get update" всегда будет срабатывать.
          - А не браться из старого кэша.
          - И, следовательно, всегда будут устанавливаться самые новые пакеты.
          - Например:

              RUN apt-get update && apt-get install -y \
                  package-bar \
                  package-baz \
                  package-foo

          - Применение одного "apt-get install" приведёт к ошибкам с кэшем.
          - Пример того, как делать НЕ надо:

            • Допустим, у нас такой DockerFile:

              FROM ubuntu:14.04
              RUN apt-get update
              RUN apt-get install -y curl

            • После сборки образа все слои из DockerFile в кэше.
            • Позже мы добавили ещё 1 пакет к apt-get install:

              FROM ubuntu:14.04
              RUN apt-get update
              RUN apt-get install -y curl nginx

            • Но Docker воспринимает старый и новый "apt-get update", как одинаковые.
            • И поэтому использует старый кэш для новой версии.
            • В результате apt-get update не выполняется, т.к. используется старый кэш.
            • А т.к. он не выполняется, то могут установиться старые пакеты (curl, nginx).

        • Пример правильной работы с apt-get

            RUN apt-get update && apt-get install -y \
                aufs-tools \
                automake \
                build-essential \
                curl \
                dpkg-sig \
                libcap-dev \
                libsqlite3-dev \
                mercurial \
                reprepro \
                ruby1.9.1 \
                ruby1.9.1-dev \
                s3cmd=1.1.* \
             && rm -rf /var/lib/apt/lists/*

        • Debian/Ubuntu автоматически вызывают apt-get clean
          - Так что явного вызова не требуется.

    # CMD

      • CMD нужна для запуска программы из образа с аргументами.
        - Почти всегда в форме: CMD [“executable”, “param1”, “param2”…]
        - Эта форма рекомендована для всех образов-сервисов.
        - Но если образ не для сервиса типа Apache, Rails, etc.
        - Можно запустить что-то типа: CMD ["apache2","-DFOREGROUND"]

      • Почти всегда CMD надо дать интерактивную оболочку
        - Типа bash, python, perl, etc.
        - Примеры: CMD ["perl", "-de0"], CMD ["python"], или CMD [“php”, “-a”]
        - Это означает, что если выполнить что-то типа docker run -it python,
          то вы сразу попадёте в пригодную к использованию оболочку.

      • Редко CMD стоит использовать в формате CMD [“param”, “param”]
        - В совокупности с ENTRYPOINT.
        - И то в том случае, если ваши пользователи знакомы с ENTRYPOINT.

    # EXPOSE

      • Выставляйте традиционные для соотв.приложений порты
        - К примеру, веб-сервер обычно использует порт 80.
        - А какая-нибудь mongoDB использует порт 27017.
        - Вот их и выставляйте. Не надо путать людей.

      • А для внешнего использования пользователь сам укажет
        - Пользователь может выполнить docker run для внешнего доступа.
        - И он может с помощью -p пробросить порты куда ему надо.
        - Но опять же, он ожидает, что внутри у веб-сервера порт 80, например.

    # ENV

      • Используйте ENV для назначения PATH
        - Например, у вас есть слой, устанавливающий nginx.
        - И зачем-то требуется, чтобы он был доступен глобально.
        - Значит, его надо добавить в PATH.
        - Например, вот так:

            ENV PATH /usr/local/nginx/bin:$PATH

      • Используйте ENV для добавления нужных для сервисов переменных среды
        - Вы можете устанавливать в своём образе разные сервисы.
        - Разным сервисам могут понадобиться разные переменные среды.
        - Эти переменные среды и можно назначть с помощью ENV.
        - Например, для postgres нужна переменная PGDATA.

      • Ещё ENV можно использовать для указания версий
        - Ну типа в начала DockerFile назначить переменные с версиями.
        - И если надо версию поменять, то меняем в одном месте.

    # ADD/COPY

      • ADD и COPY почти одинаковы, но лучше использовать COPY
        - Если не требудтся особые способности ADD.
        - Поскольку COPY более прозрачна, т.к. у неё нет особых способностей.
        - Типа работы с tar или URL.
        - Вообще говоря, лучшее применения для ADD:

            ADD rootfs.tar.xz /   | распаковать локальный архив в образ

      • Если надо много что COPY, делайте это в разных COPY
        - На надо стараться запихнуть всё всё в один COPY.
        - Если разносить, кэширование будет работать эффективнее.
        - Например:

            COPY requirements.txt /tmp/
            RUN pip install --requirement /tmp/requirements.txt
            COPY . /tmp/

        - Если кэш 1-й строки изменится, кэш низлежащих инвалидируется.

      • Не используйте ADD для извлечения пакетов из URL
        - Вместо этого используйте curl/wget в RUN.
        - Что это даёт:

          • Меньше слоёв в образе.
          • Можно поудалять лишние файлы.

        - Пример, как не надо:

            ADD http://example.com/big.tar.xz /usr/src/things/
            RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
            RUN make -C /usr/src/things all

        - Пример, как надо:

            RUN mkdir -p /usr/src/things \
                && curl -SL http://example.com/big.tar.xz \
                | tar -xJC /usr/src/things \
                && make -C /usr/src/things all

    # ENTRYPOINT

      • Лучший способ использовать ENTRYPOINT
        - Установить в ENTRYPOINT главную команду образа.
        - Это позволит использовать образ таким образом,
          как будто он был бы этой командой.
        - А CMD в этом случае можно использовать для установки
          аргументов по умолчанию.
        - Например, образ работающий, как шелл:

            ENTRYPOINT ["s3cmd"]
            CMD ["--help"]

        - Тогда:

            docker run s3cmd          // вызовет справку
            docker run s3cmd ls s3    // "mybucket"

      • Использование ENTRYPOINT в комбинации с шелл-скриптом
        - Позволит использовать образ аналогичным вышеописанному способом.
        - Даже, если потребуется совершить больше, чем 1 шаг.
        - Например, оф.образ Postgress использует этот скрипт, как ENTRYPOINT:

            #!/bin/bash
            set -e

            if [ "$1" = 'postgres' ]; then
                chown -R postgres "$PGDATA"

                if [ -z "$(ls -A "$PGDATA")" ]; then
                    gosu postgres initdb
                fi

                exec gosu postgres "$@"
            fi

            exec "$@"

        - Важные замечания !!!

          • Скрипт использует bash-команду exec.
          • Поэтому итоговое приложение получит PID 1 в контейнере.
          • Это позволит ему получать unix-сигналы от host-машины.

        - Этот хелпер через DockerFile копируется в контейнер с помощью COPY.
        - И запускается через ENTRYPOINT:

            COPY ./docker-entrypoint.sh /
            ENTRYPOINT ["/docker-entrypoint.sh"]

        - Тогда:

            docker run postgres                   | просто запустить postgres
            docker run postgres postgres --help   | запустить postgess и передать параметры серверу
            docker run --rm -it postgres bash     | запустить bash

    # VOLUME

      • Для чего используется VOLUME
        - Чтобы помечать точки монтирования внутри контейнера.
        - С конфигами, данными БД, или другими каталогами/файлами.
        - В общем, надо использовать для любой изменяемой части образа.

    # USER

      • Если контейнеру не нужны root-права, смените пользователя
        - Сначала надо создать нового пользователя и группу.
        - Потому что USER вовсе не создаёт его сам.
        - Например:

            RUN groupadd -r postgres && useradd -r -g postgres postgres

        - Правда имейте в виду, что UID и GID могут меняться в разных контейнерах.
        - Поэтому очень важно назначать явно UID и GID.
        - А потом с помощью USER можно поменять пользователя.

      • Не используйте sudo
        - Она имеет непредскажуемое поведение в плане TTY и переадресации сигналов.
        - И может создать больше проблем, чем решить.
        - Но если уж без этого никак, используйте gosu вместо sudo:
            https://github.com/tianon/gosu

      • Избегайте множественных USER в DockerFile
        - Чтобу уменьшить кол-во слоёв.

    # WORKDIR

      • Всегдай используйте абсолютные пути для WORKDIR
        - Это сделает всё более ясным и надёжным.

      • Используйте WORKDIR вместо систематических cd
        - То есть вместо инструкций типа:

            RUN cd … && do-something

    # ONBUILD

      • Про ONBUILD
        - Это инструкция от родительского DockerFile дочернему.
        - Которая исполнится в дочернем сразу после FROM.
        - Подробнее см.в справочнике выше.

      • Когда полезна ONBUILD
        - Для образов, которые будут созданы на основе (FROM) этого.

      • Будь осторожен с ADD/COPY в ONBUILD
        - Если копируемый ресурс не будет найден, будет беда.
        - Сборка дочернего образа навернётся.


А9. Поиск и добавление образов на Docker Hub

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Создание аккаунта и аутентификация в Docker Hub

      - Создание аккаунта
      - Аутентификация
      - Файл для хранения данных для аутентификации

    # Поиск образов
    # Добавление образов на Docker Hub
    # Особенности Docker Hub

      - Приватные репозитории
      - Организации и команды
      - Автоматизированные сборки
      - Вебхуки


  --------------------------------------

  > Ссылки

    # Оф.статья "Store images on Docker Hub"
        https://docs.docker.com/engine/userguide/containers/dockerrepos/

  > Введение
    - В главе описано использование Docker Hub для улучшения рабочего процесса.
    - Docker Hub, это публичный репозиторий от создателей Docker.
    - В нём хранятся образы, которые можно скачивать и использовать.
    - Также он поддерживает:

      • Аутентификацию
      • Рабочие группы
      • Инструменты для рабочего процесса (webhooks, build triggers)
      • Приватные репозитории (платные)

  > Создание аккаунта и аутентификация в Docker Hub

    # Создание аккаунта
      - Создать аккаунт можно 2-мя способами:

        • На сайте http://hub.docker.com/
        • С помощью команды docker login
          - Она первым делом запросит у тебя username.
          - И если такового не окажется в их БД, запустит
            процесс создания нового акаунта.

    # Аутентификация
      - Аутентифицироваться можно той же командой docker login.
      - Без аутентификации добавлять образы на Docker Hub нельзя.

    # Файл для хранения данных для аутентификации
      - Они будут автоматически сохранены в:
          ~/.docker/config.json

  > Поиск образов
    - Искать можно на сайте Docker Hub или через CLI.
    - Через CLI поиск производится командой docker searh.
    - Искать можно по следующим параметрам:

        • Имя образа
        • Имя автора
        • Описание

    - Пример поиска через CLI: docker search centos
    - Результат будет такой:

        $ docker search centos
        NAME           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
        centos         The official build of CentOS                    1223      [OK]
        tianon/centos  CentOS 5 and 6, created using rinse instea...   33
        ...

    - Обсудим этот результат:

        • Рассмотрим 2-ва найденных образа: centos и tianon/centos
        • В имене centos не указан vendor, это значит:
          - То есть его имя находится в глобальном пр.имён репозитория.
          - Это значит, что этот репозиторий является официальным.
          - Об этом также свидетельствует флаг official.
          - Такие репозитории отличаются высокой надёжностью, безопасностью, качеством.
        • В имене tianon/centos мы видим имя вендора tianon
          - Это значит, что репозиторий не является официальным.
          - И автор мог там наворотить всё, что угодно.

    - Когда ты нашёл интересующий образ, его можно скачать:

        docker pull <imagename>

    - В pull ещё можно уточнить версию пакета для загрузки.
    - Неявно применяется версия letest:

        docker pull <imagename>:latest

    - Подробнее об этом см.в справочнике по docker.

  > Добавление образов на Docker Hub
    - Чтобы добавить в репозиторий надо иметь именованный образ.
    - Теперь можно сделать push в репозиторий:

        docker push yourname/newimage

    - Образ будет загружен на Docker Hub и доступен всем для использования.

  > Особенности Docker Hub

    # Приватные репозитории
      - Они доступны только владельцу приватного репозитория.
      - И тем, кому он явно даст доступ к нему.
      - Являются платными.

    # Организации и команды
      - Доступны только для приватных репозиториев.
      - Позволяют сделать их доступными для организаций и команд.

    # Автоматизированные сборки
      - Можно связать свой реп-рий на github с реп-ем на Docker Hub.
      - В репозитории на github должен быть DockerFile, в корне.
      - Можно указать конкретную ветку реп-рия на github.
      - При все изменения будут синхронизироватсья по
        направлению github -> docker hub
      - Делать push в автоматизированные сборки не получится,
        вместо этого надо вносить изменения в код на github.
      - Как настроить автоматизированную сборку:

        1. Создай акк на Docker Hub, и залогинься.
        2. Связы свой GitHub аккаунт с Docker Hub аккаунтом
          - https://registry.hub.docker.com/account/accounts/
        3. Настрой автоматическую сборку
          - https://registry.hub.docker.com/builds/add/
        4. Укажи реп. на github с DockerFile
        5. Укажи ветку этого репа (по умолчанию master).
        6. Задай имя автоматизированной сборке.
        7. Назначь Docker Tag сборке.
        8. Укажи, где находится DockerFile ("/" по умолчанию).

    # Вебхуки
      - Это обработчики, отслеживающие события с репозиториями.
      - Могут посылать JSON с данными в случае их возникновения
        по указанному URL.


А10. Справочник по командам docker

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Общий синтаксис команды docker
    # Поддерживемые переменные среды

      - DOCKER_API_VERSION            | указать, какую версию API использовать (например, 1.19)
      - DOCKER_CONFIG                 | путь к конфигам клиента
      - DOCKER_CERT_PATH              | путь к аутентификационным ключам
      - DOCKER_DRIVER                 | the graph driver to use
      - DOCKER_HOST                   | к какому сокету демона подключаться
      - DOCKER_NOWARN_KERNEL_VERSION  | prevent warnings that your Linux kernel is unsuitable for Docker
      - DOCKER_RAMDISK                | отключить pivot_root
      - DOCKER_TLS_VERIFY             | when set Docker uses TLS and verifies the remote
      - DOCKER_CONTENT_TRUST          | when set Docker uses notary to sign and verify images. Equates to --disable-content-trust=false for build, create, pull, push, run
      - DOCKER_CONTENT_TRUST_SERVER   | the URL of the Notary server to use. This defaults to the same URL as the registry
      - DOCKER_TMPDIR                 | путь ко временным файлам Docker'а

    # Конфиги Docker'а
    # Справочник команды docker

      - daemon              | Запустить docker-демон, самодостаточную среду для работы с linux-контейнерами
      - attach              | Подключиться к контейнеру (доступ через командную строку)
      - build               | Собрать новый образ из DockerFile и контекста по указанному адресу
      - commit              | Создать новый образ из изменений контейнера
      - cp                  | Копирование файлов между контейнером и docker-хостом
      - create              | Создать новый контейнер
      - diff                | Вывести список изменений в ФС контейнера
      - events              | Получать события от docker-server в реалтайм
      - exec                | Выполнить команду в работающем контейнере
      - export              | Экспортирует содержимое ФС контейнера в tar-архив
      - history             | Показывает историю образа
      - images              | Выводит список образов
      - import              | Создаёт пустой образ с ФС и импортирует туда содержимое архива
      - info                | Отображает информацию о Docker
      - inspect             | Выводит информацию об образе или контейнере
      - kill                | Прибить процесс контейнера
      - load                | Загружает образ из tar-архива или STDIN
      - login               | Создать аккаунт в репозитории, или аутентифицироваться
      - logout              | Выйти из учётной записи репозитория
      - logs                | Извлекает логи контейнера
      - network connect     | Подключает контейнер к сети
      - network disconnect  | Создать новую сеть с указанным именем
      - network ls          | Выводит список всех сетей, созданных пользователем
      - network rm          | Удалить одну или более сетей
      - pause               | Ставит на паузу все процессы в контейнере
      - port                | Выводит информацию о port mapping контейнера
      - ps                  | Выводит список контейнеров
      - pull                | Извлечь образ с Docker Hub
      - push                | Залить свой образ на Docker Hub
      - rename              | Переименовать контейнер
      - restart             | Перезапустить контейнер
      - rm                  | Удалить 1-ин или более контейнеров
      - rmi                 | Удалить 1 или более образов
      - run                 | Создать контейнер, запустить и выполнить в нём команду
      - save                | Сохранить образ(ы) в tar-архив
      - search              | Искать образы на Docker Hub
      - start               | Запустить 1 или более контейнеров
      - stop                | Остановить контейнер сигналом SIGTERM, а затем SIGKILL
      - tag                 | Пометить образ тегом в репозитории
      - top                 | Вывести запущенные процессы в контейнере
      - unpause             | Снять с паузы все процессы в контейнере
      - update              | Обновляет ограничения контейнера на ресурсы
      - version             | Показать информацию о версии Docker
      - volume create       | Создать новый объект volume
      - volume inspect      | Вывести информацию об 1-м или нескольких объектах volume
      - volume ls           | Вывести список доступных объектов volume
      - volume rm           | Удалить 1 или более объектов volume
      - wait                | Заблокировать до остановки контейнера, затем вывести его exit code

  --------------------------------------

  > Ссылки

    # Оф.статья "Use the Docker command line"
        https://docs.docker.com/engine/reference/commandline/cli/

  > Введение
    - Это глава-справочник для команды docker.

  > Общий синтаксис команды docker
    - В обычном дистрибутиве лучше использовать команду docker с sudo.
    - Ну или можно создать группу docker и добавить туда пользователей.
    - В boot2docker можно не пользоваться sudo.
    - Вот общий синтаксис команды docker:

        docker [OPTIONS] COMMAND [arg...]
        docker daemon [ --help | ... ]
        docker [ --help | -v | --version ]

          -H, --host=[]: The socket(s) to talk to the Docker daemon in the format of tcp://host:port/path, unix:///path/to/socket, fd://* or fd://socketfd.

  > Поддерживемые переменные среды
    - См.оглавление.

  > Конфиги Docker'а
    - По умолчанию хранятся в: ~/.docker
    - Но можно указать другой путь с помощью переменной среды DOCKER_CONFIG.
    - Или с помощью флага --config в CLI, который приоритетнее:

        docker --config ~/testconfigs/ ps

    - В каталоге с конфигами Docker'а не надо ничего трогать.
    - Кроме файла config.json - его можно редактировать:

      • HttpHeaders
        - Список заголовков при клиент-серверном общении Docker'а.

      • psFormat
        - Настраивает формат для docker ps.

      • detachKeys
        - Once attached to a container, users detach from it and leave it running using the using CTRL-p CTRL-q key sequence.
        - This detach key sequence is customizable using the detachKeys property.

      • imagesFormat
        - Настраивает формат для docker images.

    - Пример файла config.json:

        {
          "HttpHeaders": {
            "MyHeader": "MyValue"
          },
          "psFormat": "table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Labels}}",
          "imagesFormat": "table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\\t{{.CreatedAt}}",
          "detachKeys": "ctrl-e,e"
        }

  > Справочник команды docker

    // daemon //
    //--------//
    // - Запустить docker-демон, самодостаточную среду для работы с linux-контейнерами.
    // - Docker использует одни и те же исходними и для демона, и для клиента.
    // - Подоглавление:
    //
    //  • Формат
    //  • Опции
    //  • Подробнее об опции -H
    //  • Подробнее об опции -s
    //  • Подробнее об опции --dns
    //  • Запуск docker-демона за HTTPS_PROXY
    //  • Подробнее об опции --default-ulimit
    //  • Конфиг демона
    //

      # Формат

          docker daemon [OPTIONS]

      # Опции

        --api-cors-header=""                   Set CORS headers in the remote API
        --authorization-plugin=[]              Set authorization plugins to load
        -b, --bridge=""                        Attach containers to a network bridge
        --bip=""                               Specify network bridge IP
        --cgroup-parent=                       Set parent cgroup for all containers
        -D, --debug                            Enable debug mode
        --default-gateway=""                   Container default gateway IPv4 address
        --default-gateway-v6=""                Container default gateway IPv6 address
        --cluster-store=""                     URL of the distributed storage backend
        --cluster-advertise=""                 Address of the daemon instance on the cluster
        --cluster-store-opt=map[]              Set cluster options
        --config-file=/etc/docker/daemon.json  Daemon configuration file
        --dns=[]                               DNS server to use
        --dns-opt=[]                           DNS options to use
        --dns-search=[]                        DNS search domains to use
        --default-ulimit=[]                    Set default ulimit settings for containers
        --exec-opt=[]                          Set exec driver options
        --exec-root="/var/run/docker"          Root of the Docker execdriver
        --fixed-cidr=""                        IPv4 subnet for fixed IPs
        --fixed-cidr-v6=""                     IPv6 subnet for fixed IPs
        -G, --group="docker"                   Group for the unix socket
        -g, --graph="/var/lib/docker"          Root of the Docker runtime
        -H, --host=[]                          Daemon socket(s) to connect to
        --help                                 Print usage
        --icc=true                             Enable inter-container communication
        --insecure-registry=[]                 Enable insecure registry communication
        --ip=0.0.0.0                           Default IP when binding container ports
        --ip-forward=true                      Enable net.ipv4.ip_forward
        --ip-masq=true                         Enable IP masquerading
        --iptables=true                        Enable addition of iptables rules
        --ipv6                                 Enable IPv6 networking
        -l, --log-level="info"                 Set the logging level
        --label=[]                             Set key=value labels to the daemon
        --log-driver="json-file"               Default driver for container logs
        --log-opt=[]                           Log driver specific options
        --mtu=0                                Set the containers network MTU
        --disable-legacy-registry              Do not contact legacy registries
        -p, --pidfile="/var/run/docker.pid"    Path to use for daemon PID file
        --registry-mirror=[]                   Preferred Docker registry mirror
        -s, --storage-driver=""                Storage driver to use
        --selinux-enabled                      Enable selinux support
        --storage-opt=[]                       Set storage driver options
        --tls                                  Use TLS; implied by --tlsverify
        --tlscacert="~/.docker/ca.pem"         Trust certs signed only by this CA
        --tlscert="~/.docker/cert.pem"         Path to TLS certificate file
        --tlskey="~/.docker/key.pem"           Path to TLS key file
        --tlsverify                            Use TLS and verify the remote
        --userns-remap="default"               Enable user namespace remapping
        --userland-proxy=true                  Use userland proxy for loopback traffic

      # Подробнее об опции -H
        - Она позволяет указать, API через какой тип сокетов слушать.
        - Из коробки доступны 3-ри типа:

          • unix    | По умолчанию, в /var/run/docker.sock, с root-правами
          • tcp     |
          • fd

        - Для удалённого доступа к демону нужно использовать сокет tcp.
        - Можно одновременно указать несколько сокетов:

            docker daemon -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2

      # Подробнее об опции -s
        - Она позволяет указать драйвер для хранилища (storage driver).
        - Из коробки доступны следующие драйвера:

          • aufs
          • devicemapper
          • btrfs
          • zfs
          • overlay

      # Подробнее об опции --dns
        - Установить DNS-сервер для всех Docker-контейнеров можно так:

            docker daemon --dns 8.8.8.8

        - Установить DNS-search domain для всех Docker-контейнеров можно так:

            docker daemon --dns-search example.com

      # Запуск docker-демона за HTTPS_PROXY
        - Что происходит при запуске внутри LAN с HTTPS-прокси.
        - Сертификаты Docker Hub будут заменены на сертификаты прокси.
        - Эти сертификаты необходимо добавить в конфиг docker-хоста:

          1. Установить пакет ca-certificates через apt-get.
          2. Добавить сертификаты прокси в /etc/pki/tls/certs/ca-bundle.crt
          3. Запустить docker-демон со следующей переменной среды
            - Заменив все данные на актуальные.
            - Код:

              HTTPS_PROXY=http://username:password@proxy:port/ docker daemon

            - Это лишь добавит прокси и аутентификацию к запросам docker-демона.
            - Но docker build требует доп.настройки для использования прокси.

      # Подробнее об опции --default-ulimit
        - Позволяет установить ulimit по умолчанию для всех контейнеров.
        - Ulimit, это возможность в Linux задать ограничения на использование ресурсов.
        - В docker run тоже есть флаг --ulimit, он приоритетнее.

      # Конфиг демона
        - Можно все опции для docker daemon описать в json-конфиге.
        - А в опциях команды лишь указать путь к этому конфигу.
        - По умолчанию, docker ищет конфиг в:

          /etc/docker/daemon.json                   // Linux
          %programdata%\docker\config\daemon.json   // Windows

        - Опции в конфиге и при запуске команды не должны конфликтовать.
        - Иначе демон не запустится.
        - Полный список разрешённых для конфига опций:

            {
              "authorization-plugins": [],
              "dns": [],
              "dns-opts": [],
              "dns-search": [],
              "exec-opts": [],
              "exec-root": "",
              "storage-driver": "",
              "storage-opts": "",
              "labels": [],
              "log-driver": "",
              "log-opts": [],
              "mtu": 0,
              "pidfile": "",
              "graph": "",
              "cluster-store": "",
              "cluster-store-opts": [],
              "cluster-advertise": "",
              "debug": true,
              "hosts": [],
              "log-level": "",
              "tls": true,
              "tlsverify": true,
              "tlscacert": "",
              "tlscert": "",
              "tlskey": "",
              "api-cors-headers": "",
              "selinux-enabled": false,
              "userns-remap": "",
              "group": "",
              "cgroup-parent": "",
              "default-ulimits": {},
                   "ipv6": false,
                   "iptables": false,
                   "ip-forward": false,
                   "ip-mask": false,
                   "userland-proxy": false,
                   "ip": "0.0.0.0",
                   "bridge": "",
                   "bip": "",
                   "fixed-cidr": "",
                   "fixed-cidr-v6": "",
                   "default-gateway": "",
                   "default-gateway-v6": "",
                   "icc": false
            }

    // attach //
    //--------//
    // - Подключиться к контейнеру (доступ через командную строку).
    // - Отключиться, можно нажав: ctrl-p, ctrl-q

      # Формат

            docker attach [OPTIONS] CONTAINER

      # Опции

        --detach-keys="<sequence>"       Set up escape key sequence
        --help                           Print usage
        --no-stdin                       Do not attach STDIN
        --sig-proxy=true                 Proxy all received signals to the process

    // build //
    //-------//
    // - Собрать новый образ из DockerFile и контекста по указанному адресу.

      # Формат

          docker build [OPTIONS] PATH | URL | -

      # Примеры использования

        • docker build .
          - Здесь мы указываем текущий каталог в качестве контекста.
          - DockerFile должен лежать в этом каталоге.
          - Все файлы из . архивируются и отправляются docker-демону.

        • docker build github.com/creack/docker-firefox
          - Здесь мы указываем github repo в качестве контекста.
          - Он скачивается в tmp каталог docker'a.
          - Затем этот каталог архивируется и отправляется docker-демону.
          - А вообще можно указать любой git-репозиторий с помощью:
              git:// или git@

        • docker build - < Dockerfile
          - Здесь docker прочитает DockerFile из stdin без контекста.
          - То есть никакого контекста docker'у не будет отправлено.

        • docker build - < context.tar.gz
          - Здесь docker возьмёт DockerFile и контекст из архива.


      # Опции

        --build-arg=[]                  Set build-time variables
        --cpu-shares                    CPU Shares (relative weight)
        --cgroup-parent=""              Optional parent cgroup for the container
        --cpu-period=0                  Limit the CPU CFS (Completely Fair Scheduler) period
        --cpu-quota=0                   Limit the CPU CFS (Completely Fair Scheduler) quota
        --cpuset-cpus=""                CPUs in which to allow execution, e.g. `0-3`, `0,1`
        --cpuset-mems=""                MEMs in which to allow execution, e.g. `0-3`, `0,1`
        --disable-content-trust=true    Skip image verification
        -f, --file=""                   Name of the Dockerfile (Default is 'PATH/Dockerfile')
        --force-rm                      Always remove intermediate containers
        --help                          Print usage
        --isolation=""                  Container isolation technology
        -m, --memory=""                 Memory limit for all build containers
        --memory-swap=""                A positive integer equal to memory plus swap. Specify -1 to enable unlimited swap.
        --no-cache                      Do not use cache when building the image
        --pull                          Always attempt to pull a newer version of the image
        -q, --quiet                     Suppress the build output and print image ID on success
        --rm=true                       Remove intermediate containers after a successful build
        --shm-size=[]                   Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`.  Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes). If you omit the unit, the system uses bytes. If you omit the size entirely, the system uses `64m`.
        -t, --tag=[]                    Name and optionally a tag in the 'name:tag' format
        --ulimit=[]                     Ulimit options

      # Общее описание
        - Команда позволяет создать новый образ.
        - Образ создаётся на основе DockerFile и контекста.
        - Адрес к корню контекста можно указать в PATH/URL команды.
        - В URL можно указать git-репозиторий, который станет конекстом.
          • Docker качает репозиторий командой: git clone --depth 1 --recursive
          • Всё это скачивается в tmp-каталог docker'а.
          • Путь к этому каталогу и отправляется docker'у.

      # Уточнить путь к DockerFile относительно корня контекста
        - Можно с помощью опции -f
        - По умолчанию это корень контекста.
        - Новое положение должно быть в каталоге контекста.
        - Это особенно полезно, когда один и тот же набор файлов
          используется для создания разных образов.

      # Параметры при использовании URL
        - При использовании URL можно указать 2 доп.параметра.
        - Их формат: http://github.com/<vendor>/<repo>#<param1>:<param2>
        - Здесь имеются в виду параметры <param1>:<param2>
        - В <param1> можно указать:

          • Тег
          • Ветку
          • SHA коммита

        - В <param2> можно указать каталог относительно корня репозитория.
        - Этот каталог и будет использован, как контекст.
        - Примеры:

            • myrepo.git	refs/heads/master	/
            • myrepo.git#mytag	refs/tags/mytag	/
            • myrepo.git#mybranch	refs/heads/mybranch	/
            • myrepo.git#abcdef	sha1 = abcdef	/
            • myrepo.git#:myfolder	refs/heads/master	/myfolder
            • myrepo.git#master:myfolder	refs/heads/master	/myfolder
            • myrepo.git#mytag:myfolder	refs/tags/mytag	/myfolder
            • myrepo.git#mybranch:myfolder	refs/heads/mybranch	/myfolder
            • myrepo.git#abcdef:myfolder	sha1 = abcdef	/myfolder

    // commit //
    //--------//
    // - Создать новый образ из изменений контейнера.

      # Формат

          docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

      # Опции

        -a, --author=""     Author (e.g., "John Hannibal Smith <hannibal@a-team.com>")
        -c, --change=[]     Apply specified Dockerfile instructions while committing the image
        --help              Print usage
        -m, --message=""    Commit message
        -p, --pause=true    Pause container during commit

      # Не пользуйся этой возможностью
        - Лучше вообще не пользоваться этой возможностью.
        - Потому что её никак нельзя отнести к best practice.
        - Вместо этого следует пользоваться DockerFile.

      # Ряд примечаний

        • Все смонтированные volumes из контейнера игнорируются.
        • Во вреям commit'а все процессы контейнера будут поставлены на паузу.
        • Опцией --change можно применить указанный DockerFile
          - Но поддерживаются не все инструкции.
          - А лишь следующие:
              CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR


    // cp //
    //----//
    // - Копирование файлов между контейнером и docker-хостом.
    // - Копировать можно как оттуда-сюда, так и отсюда-туда.
    // - Подоглавление:
    //
    //  • Формат
    //  • Опции
    //  • Двустороннее копирование
    //  • Стриминг
    //  • Все пути к docker-контейнеру берутся относительно его /
    //  • cp ведёт себя, как linux'овская cp -a
    //  • Поведение в разных условиях, если SRC_PATH это файл
    //  • Поведение в разных условиях, если SRC_PATH это каталог
    //  • Невозможно скопировать системные файлы
    //

      # Формат

          docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH | -
          docker cp [OPTIONS] SRC_PATH | - CONTAINER:DEST_PATH

      # Опции

        -L, --follow-link          Always follow symbol link in SRC_PATH
        --help                     Print usage

      # Двустороннее копирование
        - cp копирует содержимое из SRC_PATH в DEST_PATH.
        - Копировать можно как из ФС контейнера в ФС docker-хоста.
        - Таки из ФС docker-хоста в ФС контейнера.

      # Стриминг

        • Если вместо SRC_PATH tar-архив
          - То есть с использованием -
          - Тогда в DEST_PATH попадает содержимое этого tar-архива.
          - В этом случае в DEST_PATH должен быть каталог.

        • Если вместо DEST_PATH стрим
          - Это стримит контент в STDOUT.

      # Все пути к docker-контейнеру берутся относительно его /
        - То есть можно не указывать / в начале каждого пути.
        - Но для путей docker-хоста это не применимо.

      # cp ведёт себя, как linux'овская cp -a
        - Каталоги копируются рекурсивно.
        - Все права сохраняются теми же, если это возможно.
        - Владельцем устанавливается пользователь и основная группа.

      # Поведение в разных условиях, если SRC_PATH это файл

        • DEST_PATH не существует
          - То есть по адресу DEST_PATH не существует файла.
          - Тогда этот файл туда копируется.

        • DEST_PATH не существует и кончается на /
          - То есть DEST_PATH это не существующий каталог.
          - Возникает ошибка.

        • DEST_PATH существует и это файл
          - Старый файл перезаписывается новым.

        • DEST_PATH существует и это каталог
          - Файл копируется в этот каталог.

      # Поведение в разных условиях, если SRC_PATH это каталог

        • DEST_PATH не существует
          - Создаётся новый каталог DEST_PATH.
          - И туда копируется содержимое из SRC_PATH.

        • DEST_PATH существует и это файл
          - Ошибка.

        • DEST_PATH существует и это каталог, не заканчивающийся на /
          - Весь каталог SRC_PATH копируется внутрь каталога DEST_PATH

        • DEST_PATH существует и это каталог, заканчивающийся на /
          - Содержимое каталога SRC_PATH копируется внутрь каталога DEST_PATH

      # Невозможно скопировать системные файлы
        - Такие как /proc, /sys, /dev, и смонтировать в контейнер

    // create //
    //--------//
    // - Создать новый контейнер.

      # Формат

          docker create [OPTIONS] IMAGE [COMMAND] [ARG...]

      # Опции

        -a, --attach=[]               Attach to STDIN, STDOUT or STDERR
        --add-host=[]                 Add a custom host-to-IP mapping (host:ip)
        --blkio-weight=0              Block IO weight (relative weight)
        --blkio-weight-device=[]      Block IO weight (relative device weight, format: `DEVICE_NAME:WEIGHT`)
        --cpu-shares=0                CPU shares (relative weight)
        --cap-add=[]                  Add Linux capabilities
        --cap-drop=[]                 Drop Linux capabilities
        --cgroup-parent=""            Optional parent cgroup for the container
        --cidfile=""                  Write the container ID to the file
        --cpu-period=0                Limit CPU CFS (Completely Fair Scheduler) period
        --cpu-quota=0                 Limit CPU CFS (Completely Fair Scheduler) quota
        --cpuset-cpus=""              CPUs in which to allow execution (0-3, 0,1)
        --cpuset-mems=""              Memory nodes (MEMs) in which to allow execution (0-3, 0,1)
        --device=[]                   Add a host device to the container
        --device-read-bps=[]          Limit read rate (bytes per second) from a device (e.g., --device-read-bps=/dev/sda:1mb)
        --device-read-iops=[]         Limit read rate (IO per second) from a device (e.g., --device-read-iops=/dev/sda:1000)
        --device-write-bps=[]         Limit write rate (bytes per second) to a device (e.g., --device-write-bps=/dev/sda:1mb)
        --device-write-iops=[]        Limit write rate (IO per second) to a device (e.g., --device-write-iops=/dev/sda:1000)
        --disable-content-trust=true  Skip image verification
        --dns=[]                      Set custom DNS servers
        --dns-opt=[]                  Set custom DNS options
        --dns-search=[]               Set custom DNS search domains
        -e, --env=[]                  Set environment variables
        --entrypoint=""               Overwrite the default ENTRYPOINT of the image
        --env-file=[]                 Read in a file of environment variables
        --expose=[]                   Expose a port or a range of ports
        --group-add=[]                Add additional groups to join
        -h, --hostname=""             Container host name
        --help                        Print usage
        -i, --interactive             Keep STDIN open even if not attached
        --ip=""                       Container IPv4 address (e.g. 172.30.100.104)
        --ip6=""                      Container IPv6 address (e.g. 2001:db8::33)
        --ipc=""                      IPC namespace to use
        --isolation=""                Container isolation technology
        --kernel-memory=""            Kernel memory limit
        -l, --label=[]                Set metadata on the container (e.g., --label=com.example.key=value)
        --label-file=[]               Read in a line delimited file of labels
        --link=[]                     Add link to another container
        --log-driver=""               Logging driver for container
        --log-opt=[]                  Log driver specific options
        -m, --memory=""               Memory limit
        --mac-address=""              Container MAC address (e.g. 92:d0:c6:0a:29:33)
        --memory-reservation=""       Memory soft limit
        --memory-swap=""              A positive integer equal to memory plus swap. Specify -1 to enable unlimited swap.
        --memory-swappiness=""        Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.
        --name=""                     Assign a name to the container
        --net="bridge"                Connect a container to a network
                                      'bridge': create a network stack on the default Docker bridge
                                      'none': no networking
                                      'container:<name|id>': reuse another container's network stack
                                      'host': use the Docker host network stack
                                      '<network-name>|<network-id>': connect to a user-defined network
        --net-alias=[]                Add network-scoped alias for the container
        --oom-kill-disable            Whether to disable OOM Killer for the container or not
        --oom-score-adj=0             Tune the host's OOM preferences for containers (accepts -1000 to 1000)
        -P, --publish-all             Publish all exposed ports to random ports
        -p, --publish=[]              Publish a container's port(s) to the host
        --pid=""                      PID namespace to use
        --privileged                  Give extended privileges to this container
        --read-only                   Mount the container's root filesystem as read only
        --restart="no"                Restart policy (no, on-failure[:max-retry], always, unless-stopped)
        --security-opt=[]             Security options
        --stop-signal="SIGTERM"       Signal to stop a container
        --shm-size=[]                 Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`.  Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes). If you omit the unit, the system uses bytes. If you omit the size entirely, the system uses `64m`.
        -t, --tty                     Allocate a pseudo-TTY
        -u, --user=""                 Username or UID
        --ulimit=[]                   Ulimit options
        --uts=""                      UTS namespace to use
        -v, --volume=[host-src:]container-dest[:<options>]
                                      Bind mount a volume. The comma-delimited
                                      `options` are [rw|ro], [z|Z], or
                                      [[r]shared|[r]slave|[r]private]. The
                                      'host-src' is an absolute path or a name
                                      value.
        --volume-driver=""            Container's volume driver
        --volumes-from=[]             Mount volumes from the specified container(s)
        -w, --workdir=""              Working directory inside the container

      # Общее описание
        - Команда позволяет создать новый контейнер из указанного образа.
        - После создания контейнер не запускается (в отличие от docker run).
        - ID нового контейнера выводится пользователю через STDOUT.
        - Короче, аналог docker run -d, только не запускает контейнер.
        - После создания, запустить контейнер можно: docker start <id контейнера>.

      # Примеры

        • Создать и запустить контейнер

            docker create -it ubuntu bash     // 6d8af538ec5
            docker start -a -i 6d8af538ec5

        • Создать контейнер с объектом volume с авто.ссылкой
          - Который использовать в качестве пула ссылок на объекты
            volume при запуске другого контейнера.
          - Код:

              docker create -v /data --name data ubuntu
              docker run --rm --volumes-from data ubuntu ls -la /data

        • Создать контейнер с объектом volume с ручной.ссылкой
          - Который использовать в качестве пула ссылок на объекты
            volume при запуске другого контейнера.
          - Код:

              docker create -v /c/users/german:/data --name data ubuntu
              docker run --rm --volumes-from data ubuntu ls -la /data

      # Выбор способа изоляции контейнеров на Windows
        - С помощью опции --isolation можно указать оный.
        - Например: --isolation="default"
        - Вот доступные варианты:

          • default     | По умолчанию, 1-нный доступный для Linux вариант
          • process     |
          • hyperv      |

    // diff //
    //------//
    // - Вывести список изменений в ФС контейнера.

      # Формат

          Usage: docker diff [OPTIONS] CONTAINER

      # Опции

        --help              Print usage

      # Описание
        - В выводе в начале каждой строки стоит символ [ADC].
        - Вот что они означают:

          • А - Add
          • D - Delete
          • C - Change

      # Пример
        - Вводим: docker diff 7bb0e258aefe
        - Получаем:

            C /dev
            A /dev/kmsg
            C /etc
            A /etc/mtab
            A /go
            A /go/src
            A /go/src/github.com
            A /go/src/github.com/docker
            A /go/src/github.com/docker/docker
            A /go/src/github.com/docker/docker/.git
            ....

    // events //
    //--------//
    // - Получать события от docker-server в реалтайм.

      # Формат

          docker events [OPTIONS]

      # Опции

        -f, --filter=[]    Filter output based on conditions provided
        --help             Print usage
        --since=""         Show all events created since timestamp
        --until=""         Stream events until this timestamp

      # Пример
        - Открываем 2 шелла в терминале.
        - В одном запускаем демон, который слушает события:

            docker events

        - В другом генерируем какие-нибудь события.
        - Например:

            docker start 4386fb97867d
            docker stop 4386fb97867d
            docker stop 7805c1d35632

      # Фильтрация событий
        - С помощью -f можно фильтровать слушаемые события.

      # Список возможных событий от docker-контейнера
        - attach, commit, copy, create, destroy, die, exec_create, exec_start, export, kill, oom, pause, rename, resize, restart, start, stop, top, unpause, update

      # Список возможных событий от docker-образов
        - delete, import, pull, push, tag, untag

      # Список возможных событий от docker-volumes
        - create, mount, unmount, destroy

      # Список возможных событий от docker-networks
        - create, connect, disconnect, destroy

    // exec //
    //------//
    // - Выполнить команду в работающем контейнере.

      # Формат

          docker exec [OPTIONS] CONTAINER COMMAND [ARG...]

      # Опции

        -d, --detach               Detached mode: run command in the background
        --detach-keys              Specify the escape key sequence used to detach a container
        --help                     Print usage
        -i, --interactive          Keep STDIN open even if not attached
        --privileged               Give extended Linux capabilities to the command
        -t, --tty                  Allocate a pseudo-TTY
        -u, --user=                Username or UID (format: <name|uid>[:<group|gid>])

      # Описание
        - Команда выполнится, если PID == 1 контейнера работает.
        - И она не перезапустится при рестарте контейнера.
        - При постанове контейнера на паузу, запущенная с помощью
          docker exec команда отвалится с ошибкой.

      # Примеры

          docker run --name ubuntu_bash --rm -i -t ubuntu bash
          docker exec -d ubuntu_bash touch /tmp/execWorks
          docker exec -it ubuntu_bash bash

    // export //
    //--------//
    // - Экспортирует содержимое ФС контейнера в tar-архив.

      # Формат

          docker export [OPTIONS] CONTAINER

      # Опции

        --help             Print usage
        -o, --output=""    Write to a file, instead of STDOUT

      # Внимание!
        - Не экспортирует контент из volume-каталогов.
        - Как делать backup/restore для данных из volume см.часть 7.

      # Примеры

          docker export red_panda > latest.tar
          docker export --output="latest.tar" red_panda

    // history //
    //---------//
    // - Показывает историю образа.

      # Формат

          docker history [OPTIONS] IMAGE

      # Опции

        -H, --human=true     Print sizes and dates in human readable format
        --help               Print usage
        --no-trunc           Don't truncate output
        -q, --quiet          Only show numeric IDs

      # Примеры

        • Общая история образа
          - Выполняем: docker history docker
          - Получаем:

              IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
              3e23a5875458        8 days ago          /bin/sh -c #(nop) ENV LC_ALL=C.UTF-8            0 B
              8578938dd170        8 days ago          /bin/sh -c dpkg-reconfigure locales &&    loc   1.245 MB
              be51b77efb42        8 days ago          /bin/sh -c apt-get update && apt-get install    338.3 MB
              4b137612be55        6 weeks ago         /bin/sh -c #(nop) ADD jessie.tar.xz in /        121 MB
              750d58736b4b        6 weeks ago         /bin/sh -c #(nop) MAINTAINER Tianon Gravi <ad   0 B
              511136ea3c5a        9 months ago

    // images //
    //--------//
    // - Выводит список образов.

      # Формат

          docker images [OPTIONS] [REPOSITORY[:TAG]]

      # Опции

        -a, --all            Show all images (default hides intermediate images)
        --digests            Show digests
        -f, --filter=[]      Filter output based on conditions provided
        --help               Print usage
        --no-trunc           Don't truncate output
        -q, --quiet          Only show numeric IDs

      # Описание
        - Команда покажет список всех топ-левел образов.
        - А также их репозитории, теги и размер.
        - Промежуточные образы не показываются.

      # Что имеется в виду под топ-левел образами
        - При создании образа всегда указывается во FROM базовый образ.
        - Затем на него накладываются слои.
        - При наложении каждого слоя образуется "промежуточный" образ.
        - А когда процесс создания закончен, получается топ-левел образ.

      # Примеры

        • Вывести все доступные топ-левел образы с короткими ID

            docker images

        • Вывести все доступные топ-левел образы с полными ID

            docker images --no-trunc

        • Вывести все доступные топ-левел образы дайджестами
          - Digests появились в формате образов версии v2.
          - Их можно использовать также в качестве ID образов.
          - Код:

            docker images --digests

        • Фильтрация вывода по имени и тегу
          - В этом примере имя это "java", тег "8".
          - Код:

            docker images java:8

        • Фильтрация образов
          - С помощью опции -f.
          - Показать все образы-зомби:

              docker images --filter "dangling=true"

          - Это не промежуточные образы.
          - Зомби появляются, когда новый билд образа удаляет
            repo:tag из ID образа, оставляя его <none>:<none>
            или без тега.
          - Массово зарубить всех зомби можно так:

              docker rmi $(docker images -f "dangling=true" -q)

          - Докер предупредит, если контейнеры существуют и работают.

    // import //
    //--------//
    // - Создаёт пустой образ с ФС и импортирует туда содержимое архива.

      # Формат

          docker import file|URL|- [REPOSITORY[:TAG]]

      # Опции

        -c, --change=[]     Apply specified Dockerfile instructions while importing the image
        --help              Print usage
        -m, --message=      Set commit message for imported image

      # Какие архивы может переварить
        - .tar, .tar.gz, .tgz, .bzip, .tar.xz, .txz

      # Примеры

          cat exampleimage.tgz | docker import - exampleimagelocal:new
          cat exampleimage.tgz | docker import --message "New image imported from tarball" - exampleimagelocal:new
          docker import /path/to/exampleimage.tgz
          sudo tar -c . | docker import - exampleimagedir
          sudo tar -c . | docker import --change "ENV DEBUG true" - exampleimagedir

    // info //
    //------//
    // - Отображает информацию о Docker.

      # Формат

          docker info [OPTIONS]

      # Опции

        --help              Print usage


      # Примеры

          docker -D info

    // inspect //
    //---------//
    // - Выводит информацию об образе или контейнере.

      # Формат

        docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]

      # Опции

          -f, --format=""         Format the output using the given go template
          --help                  Print usage
          --type=container|image  Return JSON for specified type, permissible
                                  values are "image" or "container"
          -s, --size              Display total file sizes if the type is container

      # Описание
        - По умолчанию выводит информацию в JSON-массиве.

      # Примеры

        • Получить IP:

          docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $INSTANCE_ID

        • Получить MAC адрес

          docker inspect --format='{{range .NetworkSettings.Networks}}{{.MacAddress}}{{end}}' $INSTANCE_ID

        • Получить путь к логу

          docker inspect --format='{{.LogPath}}' $INSTANCE_ID

        • Получить все связки портов

          docker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} -> {{(index $conf 0).HostPort}} {{end}}' $INSTANCE_ID

        • Получить подсекцию в формате JSON

          docker inspect --format='{{json .Config}}' $INSTANCE_ID

    // kill //
    //------//
    // - Прибить процесс контейнера.

      # Формат

          docker kill [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        --help                 Print usage
        -s, --signal="KILL"    Signal to send to the container

      # Описание
        - Посылает сигнал SIGKILL, или указанный в --signal, конейнеру.

      # Проблема с /bin/sh -c
        - ENTRYPOINT и CMD в shell-форме запускаются, как подкоманда
          процесса /bin/sh -c, который не пропускает сигналов.
        - Это значит, что эта исполняемая не является PID == 1 контейнера,
          и не получает unix-сигналов.

    // load //
    //------//
    // - Загружает образ из tar-архива или STDIN.

      # Формат

          docker load [OPTIONS]

      # Опции

        --help             Print usage
        -i, --input=""     Read from a tar archive file, instead of STDIN. The tarball may be compressed with gzip, bzip, or xz

      # Примеры
        - Будем загружать образы из STDIN и tar-архива.
        - И проверять с помощью docker images, загрузились ли они.
        - Код:

            docker images
            docker load < busybox.tar.gz
            docker images
            docker load --input fedora.tar
            docker images

    // login //
    //-------//
    // - Создать аккаунт в репозитории, или аутентифицироваться.
    // - Попросит ввести логин, если такого нет, то создание аккаунта.
    // - Если сервер не указан, то по умолчанию: "https://index.docker.io/v1/"

      # Формат

          docker login [OPTIONS] [SERVER]

      # Опции

        -e, --email=""       Email
        --help               Print usage
        -p, --password=""    Password
        -u, --username=""    Username

    // logout //
    //--------//
    // - Выйти из учётной записи репозитория.
    // - Если сервер не указан, то по умолчанию: "https://index.docker.io/v1/"

      # Формат

          docker logout [SERVER]

      # Опции

        --help          Print usage

      # Примеры

          docker logout localhost:8080

    // logs //
    //------//
    // - Извлекает логи контейнера.

      # Формат

          docker logs [OPTIONS] CONTAINER

      # Опции

        -f, --follow              Follow log output
        --help                    Print usage
        --since=""                Show logs since timestamp
        -t, --timestamps          Show timestamps
        --tail="all"              Number of lines to show from the end of the logs

      # Внимание!
        - Эта команда доступна не для всех контейнеров.
        - А только для (и/и):

          • Тех, у которых есть json-file
          • У кототорых драйверы ведения лога journald

    // network connect //
    //-----------------//
    // - Подключает контейнер к сети.

      # Формат

        docker network connect [OPTIONS] NETWORK CONTAINER

      # Опции

          --alias=[]         Add network-scoped alias for the container
          --help             Print usage
          --ip               IPv4 Address
          --ip6              IPv6 Address
          --link=[]          Add a link to another container

      # Описание
        - Подключает контейнер к сети.
        - Можно использовать ID или имя контейнера.
        - Подклченные к 1-ой сети контейнеры могут общаться.
        - Один контейнер можно добавть во много сетей.
        - И эти сети не обязаны быть одного типа.

      # Пауза и остановка контейнера

        • Если поставить на паузу, он остаётся подключенным к сети.
        • Если остановить контейнер, он отключается от сети.
        • Если указан IP, но перепременяется после рестарта контейнера
        • Если IP уже недоступен, контейнер не стартует.
          - С помощью --ip-range можно подстраховаться.
          - Например:

              docker network create --subnet 172.20.0.0/16 --ip-range 172.20.240.0/20 multi-host-network

      # Проверить, подключен ли контейнер к сети
        - Можно командой: docker network inspect.

      # Удалить контейнер из сети
        - Можно командой: docker network disconnect

      # Общение контейнеров в одной сети
        - Они могут общаться, используя IP или имена друг друга.
        - Это касается не только bridge-сетей, но и overlay.

      # Примеры

        • Подключить контейнер к сети

            docker network connect multi-host-network container1

        • Подключить контейнер к сети при создании и запуске

            docker run -itd --net=multi-host-network busybox

        • Указать, какой IP присвоить подключенному контейнеру

            docker network connect --ip 10.10.36.122 multi-host-network container2

        • Назначить контейнеру псевдоним
          - Соединить с указанным контейнером, назначив ему псевдоним.
          - Код:

            docker network connect --link container1:c1 multi-host-network container2

        • --alias option can be used to resolve the container by another name in the network being connected to.

            docker network connect --alias db --alias mysql multi-host-network container2

    // network disconnect //
    //--------------------//
    // - Создать новую сеть с указанным именем.

      # Формат

          docker network create [OPTIONS] NETWORK-NAME

      # Опции

        --aux-address=map[]      Auxiliary ipv4 or ipv6 addresses used by network driver
        -d --driver=DRIVER       Driver to manage the Network bridge or overlay. The default is bridge.
        --gateway=[]             ipv4 or ipv6 Gateway for the master subnet
        --help                   Print usage
        --internal               Restricts external access to the network
        --ip-range=[]            Allocate container ip from a sub-range
        --ipam-driver=default    IP Address Management Driver
        --ipam-opt=map[]         Set custom IPAM driver specific options
        -o --opt=map[]           Set custom driver specific options
        --subnet=[]              Subnet in CIDR format that represents a network segment

      # Описание
        - Создаёт новую сеть.

      # Драйвер сети
        - Из коробки доступны 2 драйвера:

          • bridge    | применяется по умолчанию
          • overlay

        - Но можно установить и свой, кастомный драйвер.
        - Драйвер можно указать в опции -d

      # Bridge-сеть по умолчанию
        - При установке Docker Engine он создаёт bridge-сеть "docker0" автоматически.
        - При запуске контейнера командой docker run он автоматом подключается к ней.
        - Эту сеть по умолчанию нельзя удалить.

      # Bridge- и Overlay-сети

        • Bridge-сеть
          - Это изолированные сети в рамках одного docker-хоста.

        • Overlay-сеть
          - Эта сеть может работать между разными docker-хостами.
          - Чтобы создать такие сети, д.б. выполнены условия:

            • Доступ к key-value хранилищу
              - Поддерживаются: Consul, Etcd, and ZooKeeper.
            • Кластер хостов с подключением к key-value хранилищу.
            • Правильно настроенный daemon на каждом хосте кластера.

          - Опции docker daemon, поддерживающие overlay сети:

            • --cluster-store
            • --cluster-store-opt
            • --cluster-advertise

      # Docker Swarm
        - Поможет управлять overlay-сетью.
        - Не обязателен.

      # Примеры

        • Создать новую bridge-сеть

            docker network create -d bridge my-bridge-network

        • Создать новую overlay-сеть (после всех настроек)

            docker network create -d overlay my-multihost-network

    // network disconnect //
    //--------------------//
    // - Отключить контейнер от сети.

      # Формат

        docker network disconnect [OPTIONS] NETWORK CONTAINER

      # Опции

          -f, --force        Force the container to disconnect from a network
          --help             Print usage

      # Описание
        - Отключает контейнер от сети.
        - Контейнер в этот момент должен быть запущен.

      # Примеры

          docker network disconnect multi-host-network container1

    // network inspect //
    //-----------------//
    // - Выводит детальную информацию о сети.

      # Формат

          docker network inspect [OPTIONS] NETWORK [NETWORK..]

      # Опции

        -f, --format=       Format the output using the given go template.
        --help             Print usage

      # Описание
        - Возвращает информацию в формате JSON.

      # Примеры

          sudo docker network inspect bridge

    // network ls //
    //------------//
    // - Выводит список всех сетей, созданных пользователем.

      # Формат

          docker network ls [OPTIONS]

      # Опции

        -f, --filter=[]       Filter output based on conditions provided
        --help                Print usage
        --no-trunc            Do not truncate the output
        -q, --quiet           Only display numeric IDs

      # Описание
        - Выводит список всех сетей, о которых знает docker-daemon.
        - Включая overlay-сети между хостами.
        - Чтобы отображать полные ID сетей используй опцию --no-trunc

      # Примеры

          docker network ls --no-trunc

    // network rm //
    //------------//
    // - Удалить одну или более сетей.

      # Формат

          docker network rm [OPTIONS] NETWORK [NETWORK...]

      # Опции

         --help             Print usage

      # Описание
        - Чтобы удалить сеть, надо сначала отключить от неё все контейнеры.
        - При удалении нескольких сетей одновременно, команда пытается
          удалить каждую из них даже, если удалить одну или несколько
          не удалось.

      # Примеры

          docker network rm my-network

    // pause //
    //-------//
    // - Ставит на паузу все процессы в контейнере.

      # Формат

        docker pause [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

          --help          Print usage

      # Описание
        - Команда использует cgroups freezer для приостановке всех
          процессов в контейнере.


    // port //
    //------//
    // - Выводит информацию о port mapping контейнера.

      # Формат

        docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]

      # Опции

          --help          Print usage

      # Описание
        - Какие порты куда проброшены.

      # Примеры

          docker ps
          docker port test
          docker port test 7890/tcp
          docker port test 7890

    // ps //
    //----//
    // - Выводит список контейнеров.

      # Формат

        docker ps [OPTIONS]

      # Опции

          -a, --all             Show all containers (default shows just running)
          -f, --filter=[]       Filter output based on these conditions:
                                - exited=<int> an exit code of <int>
                                - label=<key> or label=<key>=<value>
                                - status=(created|restarting|running|paused|exited)
                                - name=<string> a container's name
                                - id=<ID> a container's ID
                                - before=(<container-name>|<container-id>)
                                - since=(<container-name>|<container-id>)
                                - ancestor=(<image-name>[:tag]|<image-id>|<image@digest>) - containers created from an image or a descendant.
          --format=[]           Pretty-print containers using a Go template
          --help                Print usage
          -l, --latest          Show the latest created container (includes all states)
          -n=-1                 Show n last created containers (includes all states)
          --no-trunc            Don't truncate output
          -q, --quiet           Only display numeric IDs
          -s, --size            Display total file sizes

      # Описание

        • Показать только запущенные контейнеры

            docker ps

        • Показать все контейнеры (и запущенные, и нет)

            docker ps -a

    // pull //
    //------//
    // - Извлечь образ с Docker Hub.

      # Формат

          docker pull [OPTIONS] NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]

      # Опции

        -a, --all-tags                Download all tagged images in the repository
        --disable-content-trust=true  Skip image verification
        --help                        Print usage

      # Примеры

        • Извлечь образ debian:latest и его промежуточные слои

            docker pull debian

        • Извлечь debian:testing и его промежуточные слои

            docker pull debian:testing

        • Извлечь образ из репозитория debian и его промежуточные слои.
          - Используя указанный digest.
          - Код:

              docker pull debian@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf

        • Извлечь образы со всеми тегами из репозитория centos

            docker pull --all-tags centos

    // push //
    //------//
    // - Залить свой образ на Docker Hub.

      # Формат

        docker push [OPTIONS] NAME[:TAG]

      # Опции

          --disable-content-trust=true   Skip image signing
          --help                         Print usage

      # Описание
        - Если прибить процесс во время push, это отменит операцию.

    // rename //
    //--------//
    // - Переименовать контейнер.

      # Формат

          docker rename [OPTIONS] OLD_NAME NEW_NAME

      # Опции

        --help          Print usage

    // restart //
    //---------//
    // - Перезапустить контейнер.

      # Формат

        docker restart [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        --help             Print usage
        -t, --time=10      Seconds to wait for stop before killing the container

    // rm //
    //----//
    // - Удалить 1-ин или более контейнеров.

      # Формат

        docker rm [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

          -f, --force            Force the removal of a running container (uses SIGKILL)
          --help                 Print usage
          -l, --link             Remove the specified link
          -v, --volumes          Remove the volumes associated with the container

      # Примеры

        • Удалить контейнер по ссылке /redis

            docker rm /redis

        • Удалить link между контейнерами

            docker rm --link /webapp/redis

        • Убить процесс с PID == 1 в контейнере, удалить контейнер

            docker rm --force redis

        • Удалить все остановленные контейнеры

            $ docker rm $(docker ps -a -q)

        • Удалить контейнер и все volume-объекты с ним связанные

            docker rm -v redis

        • В этом примере volume /foo останется, а /bar будет удалён
          - Аналогичное поведение и для --volumes-from.
          - Код:

              docker create -v awesome:/foo -v /bar --name hello redis
              docker rm -v hello

    // rmi //
    //-----//
    // - Удалить 1 или более образов.

      # Формат

        docker rmi [OPTIONS] IMAGE [IMAGE...]

      # Опции

          -f, --force          Force removal of the image
          --help               Print usage
          --no-prune           Do not delete untagged parents

      # Удалить образ можно используя:

        • Его короткий ID.
        • Его длинный ID.
        • Его тег.
        • Его Digest.

      # Сначала надо удалить все теги
        - Если образ связан с одним или более тегами.
        - То надо удалить сначала все эти тега, а потом уже образ.

      # Примеры

        • Примеры удаления образов

            docker images
            docker rmi fd484f19954f
            docker rmi test1
            docker images

    // run //
    //-----//
    // - Создать контейнер, запустить и выполнить в нём команду.

      # Формат

          docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

      # Опции

        -a, --attach=[]               Attach to STDIN, STDOUT or STDERR
        --add-host=[]                 Add a custom host-to-IP mapping (host:ip)
        --blkio-weight=0              Block IO weight (relative weight)
        --blkio-weight-device=[]      Block IO weight (relative device weight, format: `DEVICE_NAME:WEIGHT`)
        --cpu-shares=0                CPU shares (relative weight)
        --cap-add=[]                  Add Linux capabilities
        --cap-drop=[]                 Drop Linux capabilities
        --cgroup-parent=""            Optional parent cgroup for the container
        --cidfile=""                  Write the container ID to the file
        --cpu-period=0                Limit CPU CFS (Completely Fair Scheduler) period
        --cpu-quota=0                 Limit CPU CFS (Completely Fair Scheduler) quota
        --cpuset-cpus=""              CPUs in which to allow execution (0-3, 0,1)
        --cpuset-mems=""              Memory nodes (MEMs) in which to allow execution (0-3, 0,1)
        -d, --detach                  Run container in background and print container ID
        --detach-keys                 Specify the escape key sequence used to detach a container
        --device=[]                   Add a host device to the container
        --device-read-bps=[]          Limit read rate (bytes per second) from a device (e.g., --device-read-bps=/dev/sda:1mb)
        --device-read-iops=[]         Limit read rate (IO per second) from a device (e.g., --device-read-iops=/dev/sda:1000)
        --device-write-bps=[]         Limit write rate (bytes per second) to a device (e.g., --device-write-bps=/dev/sda:1mb)
        --device-write-iops=[]        Limit write rate (IO per second) to a device (e.g., --device-write-bps=/dev/sda:1000)
        --disable-content-trust=true  Skip image verification
        --dns=[]                      Set custom DNS servers
        --dns-opt=[]                  Set custom DNS options
        --dns-search=[]               Set custom DNS search domains
        -e, --env=[]                  Set environment variables
        --entrypoint=""               Overwrite the default ENTRYPOINT of the image
        --env-file=[]                 Read in a file of environment variables
        --expose=[]                   Expose a port or a range of ports
        --group-add=[]                Add additional groups to run as
        -h, --hostname=""             Container host name
        --help                        Print usage
        -i, --interactive             Keep STDIN open even if not attached
        --ip=""                       Container IPv4 address (e.g. 172.30.100.104)
        --ip6=""                      Container IPv6 address (e.g. 2001:db8::33)
        --ipc=""                      IPC namespace to use
        --isolation=""                Container isolation technology
        --kernel-memory=""            Kernel memory limit
        -l, --label=[]                Set metadata on the container (e.g., --label=com.example.key=value)
        --label-file=[]               Read in a file of labels (EOL delimited)
        --link=[]                     Add link to another container
        --log-driver=""               Logging driver for container
        --log-opt=[]                  Log driver specific options
        -m, --memory=""               Memory limit
        --mac-address=""              Container MAC address (e.g. 92:d0:c6:0a:29:33)
        --memory-reservation=""       Memory soft limit
        --memory-swap=""              A positive integer equal to memory plus swap. Specify -1 to enable unlimited swap.
        --memory-swappiness=""        Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.
        --name=""                     Assign a name to the container
        --net="bridge"                Connect a container to a network
                                      'bridge': create a network stack on the default Docker bridge
                                      'none': no networking
                                      'container:<name|id>': reuse another container's network stack
                                      'host': use the Docker host network stack
                                      '<network-name>|<network-id>': connect to a user-defined network
        --net-alias=[]                Add network-scoped alias for the container
        --oom-kill-disable            Whether to disable OOM Killer for the container or not
        --oom-score-adj=0             Tune the host's OOM preferences for containers (accepts -1000 to 1000)
        -P, --publish-all             Publish all exposed ports to random ports
        -p, --publish=[]              Publish a container's port(s) to the host
        --pid=""                      PID namespace to use
        --privileged                  Give extended privileges to this container
        --read-only                   Mount the container's root filesystem as read only
        --restart="no"                Restart policy (no, on-failure[:max-retry], always, unless-stopped)
        --rm                          Automatically remove the container when it exits
        --shm-size=[]                 Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`.  Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes). If you omit the unit, the system uses bytes. If you omit the size entirely, the system uses `64m`.
        --security-opt=[]             Security Options
        --sig-proxy=true              Proxy received signals to the process
        --stop-signal="SIGTERM"       Signal to stop a container
        -t, --tty                     Allocate a pseudo-TTY
        -u, --user=""                 Username or UID (format: <name|uid>[:<group|gid>])
        --ulimit=[]                   Ulimit options
        --uts=""                      UTS namespace to use
        -v, --volume=[host-src:]container-dest[:<options>]
                                      Bind mount a volume. The comma-delimited
                                      `options` are [rw|ro], [z|Z], or
                                      [[r]shared|[r]slave|[r]private]. The
                                      'host-src' is an absolute path or a name
                                      value.
        --volume-driver=""            Container's volume driver
        --volumes-from=[]             Mount volumes from the specified container(s)
        -w, --workdir=""              Working directory inside the container

      # Описание
        - Рассмотрим, что делает команда run:

          • Создаёт контейнер из указанного образа (docker create).
          • Запускает этот контейнер (docker start).
          • Запускает указанную команду.

      # Примеры
      // Подоглавление:
      //
      //  • Сделать run, назначив имя и определив псевдо-терминал
      //  • Сделать run, и записать ID нового контейнера в файл
      //  • Сделать run, и запустить контейнер в режиме бога
      //  • Сделать run, и указать рабочий каталог
      //  • Сделать run, и смонтировать пустую tmpfs
      //  • Сделать run, и создать объекты volume
      //  • Сделать run, и опубиковать или выставить порт
      //  •
      //  •
      //





        • Сделать run, назначив имя и определив псевдо-терминал
          - Имя назначить опцией --name.
          - Псевдотерминал определить 2-мя опциями: -it
          - Псевдотерминал подключается к STDIN контейнера.
          - Код:

              docker run --name test -it debian

        • Сделать run, и записать ID нового контейнера в файл
          - С помощью опции --cidfile.
          - Код:

              docker run --cidfile /tmp/docker_test.cid ubuntu echo "test"

        • Сделать run, и запустить контейнер в режиме бога
          - С помощью опции --privileged.
          - Тогда ему станут доступны доп.возможности.
          - Код:

              docker run -t -i --privileged ubuntu bash
              mount -t tmpfs none /mnt
              df -h

        • Сделать run, и указать рабочий каталог

            docker  run -w /path/to/dir/ -i -t  ubuntu pwd

        • Сделать run, и смонтировать пустую tmpfs

            docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image

        • Сделать run, и создать объекты volume
          - В данном случае смонтировать текущий каталог в контейнер.
          - А с помощью -w назначить текущий каталог рабочим каталогом.
          - Это позволит переданной команде исполнится в этом рабочем каталоге.
          - В итоге эта комбинация выполняет команду с использованием
            контейнера, но в текущем рабочем каталоге.
          - Сделать это с помощью опций -v, --read-only
          - Код:

              docker run -v /doesnt/exist:/foo -w /foo -i -t ubuntu bash

          - Если монтируемый каталог отсутствует у хоста, docker автоматически
            создаст этот каталог на хосте.

        • Сделать run, и опубиковать или выставить порт
          - В этом примере связывается порт 8080 хоста с портом 80 контейнера.
          - На ip 127.0.0.1 хост машины.
          - Сделать это с помощью опций -p, --expose
          - Код:

              docker run -p 127.0.0.1:80:8080 ubuntu bash

          - А в этом примере выставляется порт 80.
          - Но он не публикуется на хост:

              docker run --expose 80 ubuntu bash

        • Сделать run, и установить переменные среды
          - Сделать это с помощью опций -e, --env, --env-file.
          - Добавить в контейнер несколько простых переменных среды.
          - Для примера, все 3 флага здесь использованы.
          - Если = не применён, то значение соотв. переменной среды
            из хоста передаётся соотв.переменной среды в контейнере.

              docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash

        • Сделать run, и добавить метаданные контейнеру
          - Сделать это с помощью опций -l, --label, --label-file
          - --label позволяет добавить контейнеру метаданные в виде ключа=значения.
          - Пример:

              docker run -l my-label --label com.example.foo=bar ubuntu bash

          - По умолчанию значение значения --label это "".
          - Можно добавлять много лейблов.
          - Ключи должны быть уникальны в пределах контейнера.
          - С помощью --label-file можно загрузить много лейблов из файла:

              docker run --label-file ./labels ubuntu bash

        • Сделать run, и подключить контейнер к сети
          - При старте контейнера используй --net для подключения его к сети.
          - В этом примере мы добавим busybox в сеть my-net:

              docker run -itd --net=my-net busybox

          - Можно также выбрать IP для контейнера:

              docker run -itd --net=my-net --ip=10.10.9.75 busybox

          - Добавить работающий контейнер в сеть можно командой
            docker network connect.

        • Сделать run, и смонтировать пул объектов volume из контейнера
          - Это можно сделать с помощью --volumes-from.
          - Пример:

              docker run --volumes-from 777f7dc92da7 --volumes-from ba8c0c54f0f2:ro -i -t ubuntu pwd

        • Сделать run, и подключиться к STDIN/STDOUT/STDERR контейнера
          - С помощью флага -a
          - В примере ниже в контейнер передаётся строка "test".
          - Но подключение произошло только к stdin контейнера.
          - Поэтому мы видим STDOUT хоста, и видим вывод ID контейнера.
          - Однако мы не увидим вывода и ошибок контейнера, т.к. к нему не подключены.

              echo "test" | docker run -i -a stdin ubuntu cat -

        • Сделать run, и добавить устройство с хоста в контейнер
          - Бывает нужно давать доступ к устрйоствам контейнеру.
          - Это можно сделать с помощью опции --device.
          - Пример:

              docker run --device=/dev/sdc:/dev/xvdc --device=/dev/sdd --device=/dev/zero:/dev/nulo -i -t ubuntu ls -l /dev/{xvdc,sdd,nulo}

        • Сделать run, и назначить политику перезагрузки контейнера
          - Можно с помощью опции --restart.
          - Поддерживаются следующие политики:

            • no (по умолчанию)
              - Не перезагружать автоматически контейнер при его остановке.

            • on-failure[:max-retries]
              - Перезагружать если контейнер завершился с не 0 статусом.
              - Можно ограничить кол-во попыток.

            • always
              - Всегда перезагружать контейнер при завершении вне зависимости от статуса.
              - Docker будет пытаться запустить контейнер бесконечно.
              - Контейнер всегда будет подниматься при старте демона,
                вне зависимости от текущего состояния контейнера.

            • unless-stopped
              - Тоже самое, что always, только:

                • Не стартовать при запуске демона
                  - Если контейнер был остановлен ранее.

          - Например, мы хотим всегда держать redis включенным:

              docker run --restart=always redis

        • Сделать run, и добавить записи в hosts контейнера
          - С помощью опции --add-host
          - Можно добавить записи в /etc/hosts контейнера.
          - Можно применять сколько угодно флагов в одной команде.
          - Пример:

              docker run --add-host=docker:10.180.0.1 --rm -it debian

          - Иногда может понадобиться подключиться из контейнера к хосту.
          - Для этого надо передать с --add-host ip адрес хоста.
          - Узнать IP хоста можно командой: ip addr show

        • Сделать run, и установить ulimits контейнеру
          - С помощью опции -ulimit
          - Пример:

              docker run --ulimit nofile=1024:1024 --rm debian sh -c "ulimit -n"

        • Остановить контейнер сигналом
          - Можно с помощью опции --stop-signal.
          - Посылает контейнеру unix-сигнал на выход.
          - Например, 9.

        • Позволяет назначить технологию изоляции контейнера
          - Например: --isolation="default"
          - Вот доступные варианты:

            • default     | По умолчанию, 1-нный доступный для Linux вариант
            • process     |
            • hyperv      |

    // save //
    //------//
    // - Сохранить образ(ы) в tar-архив.

      # Формат

        docker save [OPTIONS] IMAGE [IMAGE...]

      # Опции

          --help             Print usage
          -o, --output=""    Write to a file, instead of STDOUT

      # Описание
        - Возвращает результат в STDOUT.
        - Содержит все родительские слои и все теги + версии.
        - Или можно указать тег через :

      # Примеры
        - Без указания тегов:

          docker save busybox > busybox.tar
          ls -sh busybox.tar
          docker save --output busybox.tar busybox
          ls -sh busybox.tar
          docker save -o fedora-all.tar fedora
          docker save -o fedora-latest.tar fedora:latest

        - С указанием тегов:

          docker save -o ubuntu.tar ubuntu:lucid ubuntu:saucy

    // search //
    //--------//
    // - Искать образы на Docker Hub.

      # Формат

          docker search [OPTIONS] TERM

      # Опции

        --automated          Only show automated builds
        --help               Print usage
        --no-trunc           Don't truncate output
        -s, --stars=0        Only displays with at least x stars

      # Примеры

        • Искать по имени

            docker search busybox

        • Искать по имени и кол-ву звёзд

            docker search --stars=3 busybox

        • Искать автоматизированные образы

            docker search --stars=3 --automated busybox

        • Показывать не обрезанное описание

            docker search --stars=3 --no-trunc busybox


    // start //
    //-------//
    // - Запустить 1 или более контейнеров.

      # Формат

          docker start [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        -a, --attach               Attach STDOUT/STDERR and forward signals
        --detach-keys              Specify the escape key sequence used to detach a container
        --help                     Print usage
        -i, --interactive          Attach container's STDIN

    // stats //
    //-------//
    // - Отобразить статистику потребления ресурсов контейнера в реальном времени.

      # Формат

          docker stats [OPTIONS] [CONTAINER...]

      # Опции

        -a, --all          Show all containers (default shows just running)
        --help             Print usage
        --no-stream        Disable streaming stats and only pull the first result

      # Описание
        - Возвращает потко с данными.

      # Примеры

        • Получать статистику от 1-го контейнера

            docker stats

        • От нескольких контейнеров

            docker stats fervent_panini 5acfcb1b4fd1

    // stop //
    //------//
    // - Остановить контейнер сигналом SIGTERM, а затем SIGKILL.
    // - SIGKILL посылается после истечения grace period.

      # Формат

          docker stop [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        --help             Print usage
        -t, --time=10      Seconds to wait for stop before killing it

    // tag //
    //-----//
    // - Пометить образ тегом в репозитории.

      # Формат

          docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]

      # Опции

        --help               Print usage

    // top //
    //-----//
    // - Вывести запущенные процессы в контейнере.

      # Формат

          docker top [OPTIONS] CONTAINER [ps OPTIONS]

      # Опции

        --help          Print usage

    // unpause //
    //---------//
    // - Снять с паузы все процессы в контейнере.

      # Формат

          docker unpause [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        Unpause all processes within a container

      # Описание
        - Как и pause, использует cgroups freezer.

      # Примеры

    // update //
    //--------//
    // - Обновляет ограничения контейнера на ресурсы.

      # Формат

          docker update [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        --help=false               Print usage
        --blkio-weight=0           Block IO (relative weight), between 10 and 1000
        --cpu-shares=0             CPU shares (relative weight)
        --cpu-period=0             Limit the CPU CFS (Completely Fair Scheduler) period
        --cpu-quota=0              Limit the CPU CFS (Completely Fair Scheduler) quota
        --cpuset-cpus=""           CPUs in which to allow execution (0-3, 0,1)
        --cpuset-mems=""           Memory nodes (MEMs) in which to allow execution (0-3, 0,1)
        -m, --memory=""            Memory limit
        --memory-reservation=""    Memory soft limit
        --memory-swap=""           A positive integer equal to memory plus swap. Specify -1 to enable unlimited swap
        --kernel-memory=""         Kernel memory limit: container must be stopped

      # Описание
        - Используется для предотвращения потребления контейнером
          большого кол-ва ресурсов docker-хоста.
        - Одной командой, можно наложить ограничения на контейнер.
        - Или одновременно на несколько контейнеров (имена через пробел).

      # Можно применять на запущенных и остановленных контейнеров
        - Кроме опции --kernel-memory.
        - Её только на остановленном контейнере.

      # Примеры

          docker update --cpu-shares 512 abebf7571666
          docker update --cpu-shares 512 -m 300M abebf7571666 hopeful_morse

    // version //
    //---------//
    // - Показать информацию о версии Docker.

      # Формат

          Usage: docker version [OPTIONS]

      # Опции

        -f, --format=""    Format the output using the given go template
        --help             Print usage

      # Примеры

          docker version

    // volume create //
    //---------------//
    // - Создать новый объект volume.

      # Формат

          docker volume create [OPTIONS]

      # Опции

        -d, --driver=local    Specify volume driver name
        --help                Print usage
        --name=               Specify volume name
        -o, --opt=map[]       Set driver specific options

      # Описание
        - Создаёт новый объект volume.
        - Его потом можно связать с контейнерами.
        - Если не указать имя, то docker сам сгенерирует.
        - Один volume могут одновременно использовать много контейнеров.
        - Надо только следить, чтобы они не писали в него одновременно.
        - Имена volumes должны быть уникальны среди всех драйверов.

      # Примеры

          docker volume create --name hello
          docker run -d -v hello:/world busybox ls /world

    // volume inspect //
    //----------------//
    // - Вывести информацию об 1-м или нескольких объектах volume.

      # Формат

          docker volume inspect [OPTIONS] VOLUME [VOLUME...]

      # Опции

        -f, --format=       Format the output using the given go template.
        --help              Print usage

      # Описание
        - Возвращает JSON-массив с информацией о volume.

      # Примеры

          docker volume create --name hello
          docker volume inspect hello

    // volume ls //
    //-----------//
    // - Вывести список доступных объектов volume.

      # Формат

          docker volume ls [OPTIONS]

      # Опции

        -f, --filter=[]      Provide filter values (i.e. 'dangling=true')
        --help               Print usage
        -q, --quiet          Only display volume names

      # Описание
        - Выводит список всех объектов volume, про которые Docker знает.
        - Их можно фильтровать, используя флаг -f.

      # Примеры

          docker volume ls
          docker volume ls --filter "dangling=true"

    // volume rm //
    //-----------//
    // - Удалить 1 или более объектов volume.

      # Формат

        docker volume rm [OPTIONS] VOLUME [VOLUME...]

      # Опции

          --help             Print usage

      # Описание
        - Нельзя удалить volume, который связан хотя бы с 1 контейнером.

      # Примеры

          docker volume create --name bye
          docker volume rm bye

    // wait //
    //------//
    // - Заблокировать до остановки контейнера, затем вывести его exit code.

      # Формат

          docker wait [OPTIONS] CONTAINER [CONTAINER...]

      # Опции

        --help          Print usage


А11. Docker Compose

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Что такое Docker Compose

      - Общая информация про Docker Compose
      - Схематично процесс использования
      - Пример docker-compose.yml
      - Команды для управления жизненным циклом приложения
      - Фичи Docker Compose
      - Общие кейсы для применения

    # Установка Docker Compose

      - На Windows
      - На Linux

  --------------------------------------

  > Ссылки

    # Оф.документация по Docker Composer
        https://docs.docker.com/compose/overview/
        https://docs.docker.com/compose/install/
        https://docs.docker.com/compose/gettingstarted/
        https://docs.docker.com/compose/extends/
        https://docs.docker.com/compose/networking/
        https://docs.docker.com/compose/production/
        https://docs.docker.com/compose/compose-file/
        https://docs.docker.com/compose/reference/overview/

    # Running Laravel and Angularjs on Docker
        http://ewanvalentine.io/running-laravel-and-angularjs-on-docker/

  > Введение
    - Это глава про Docker Compose.
    - DC позволяет поднять docker-приложение одной командой.
    - Все необходимое для этого записывается в compose-файле.

  > Что такое Docker Compose

    # Общая информация про Docker Compose
      - Это отдельное консольное приложение.
      - Для настройки и запуска много много-контейнерных приложений.
      - Всё необходимое для этого описывается в 1-ом compose-файле.
      - Compose-файл имеет формат yml.

    # Схематично процесс использования

      1. Создаёшь DockerFile для основного контейнера приложения.
      2. Создаёшь docker-compose.yml
        - В нём определяешь различные серсисы приложения.
        - Различные volumes, и всё прочее для его работы.
      3. Выполняешь команду: docker-compose up
        - И Compose стартуе всё много-контейнерное приложение.

    # Пример docker-compose.yml

        version: '2'
        services:
          web:
            build: .
            ports:
             - "5000:5000"
            volumes:
             - .:/code
             - logvolume01:/var/log
            links:
             - redis
          redis:
            image: redis
        volumes:
          logvolume01: {}

    # Команды для управления жизненным циклом приложения
      - У Docker Compose есть команды для управления сабжем.
      - Start, stop и rebuild для сервисов.
      - View the status для запущенных сервисов.
      - Stream log output для запущенных сервисов.
      - Run a one-off command on a service.

    # Фичи Docker Compose

      • Множество независимых окружений на 1-ом хосте
        - DC использует имя проекта для изоляции его от других.
        - Имя проекта по умолчанию, это имя каталога проекта.
        - Установить иное имя можно с помощью опции -p.
        - Либо, с помощью переменной среды COMPOSE_PROJECT_NAME.
        - Использовать имя проекта можно:

          ▪ Создать много копий среды разработки на dev-хосте.
          ▪ На CI сервере защищать билды от пересечения с другими.
          ▪ На shared-хостах или dev-хосте, для проектов, которые
            могут использовать те же самые имена сервисов,
            предотвращать их пересечение друг с другом.

      • Сохранение данных в volume'ах при создании контейнеров
        - DC защищает все volumes, используемые твоими сервисами.
        - При docker-compose up, если DC просматривает историю
          предыдущих запусков, и если в наличии имеются от них
          контейнеры, DC копирует volumes из этих старых контейнеров
          в новые контейнеры.
        - Процесс гарантирует безопасность данных в volumes.

      • Пересоздание только лишь изменившихся контейнеров
        - DC кэширует конфигурацию, применённую для создания контейнера.
        - При рестарте сервиса, если она не изменилась, DC не будет
          создавать новый контейнер, и использует старый.
        - Это позволяет вносить изменения в среду очень быстро.

      • Переменные, кастомизация
        - В docker-compose.yml можно использовать переменные.
        - С их помощью можно кастомизировать экземпляры окружения.

      • Расширение
        - Во всех твоих средах может быть что-то общее.
        - Это общее можно выделить в 1-ин compose-файл.
        - А в конкретных реализациях брать и расширять его.
        - Делать это можно 2-мя способами:

            1. Расширять compose-файл с помощью extend.
            2. Использовать несколько compose-файлов.

    # Общие кейсы для применения

      • Среда разработки
        - Во время разработки высоко ценится возможность запускать
          приложение в изолированной среде разработки.
        - DC позволяет одной командой создавать изолированную среду.
        - Compose-файл позволяет всё настроить:

          ▪ Всё задокументировать.
          ▪ Сконфигурировать все сервисы-зависимости.
            БД, очереди, кэши, api веб сервисов, и т.д.

        - DC позволяет создавать и стартовать 1 или более контейнеров
          для каждой зависимости, всего одной командой docker-compose up.

      • Развёртка на 1-ом хосте
        - Традиционно DC был сфокусирован на разработке и тестировании.
        - Но с каждым релизом всё больше внимания уделяется и развёртке.
        - С помощью DC можно разворачивать приложение на удалённом Docker Engine.
        - Docker Engine м.б. 1-им экземпляром Docker Machine, или целым
          кластером Docker Swarm.

  > Установка Docker Compose

    # На Windows
      - Docker Compose устанавливается в составе Docker Toolbox.

    # На Linux


















