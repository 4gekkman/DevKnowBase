/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript.
Клиентский браузерный JS - справочник + огравление по объектам


********************************************************
Справочник по объектам клиентского браузерного javascript:












********************************************************








-------------------------------------------------- */



var result = 'Ответа нет';

var request = new XMLHttpRequest();
request.open('GET', 'localhost/temp_php.php');

request.onreadystatechange = function() {
	if(request.readyState === 4 && request.status === 200) {
		var type = request.getResponseHeader('Content-Type');
		if(type.match(/^text/))
			result = request.responseText;
	}
};

request.send(null);


console.log(result);








/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


Илья Кантор:

	> Учебник по DOM, событиям и интерфейсам от Ильи Кантора:
			http://learn.javascript.ru/

	> DOM-шпаргалка по основным св-вам и методам DOM от Ильи Кантора:
			http://learn.javascript.ru/dom-cheatsheet


Mozilla:

	> Учебник по DOM от команды Mozilla:
			https://developer.mozilla.org/en-US/docs/DOM

	> Справочник по DOM от команды Mozilla:
			https://developer.mozilla.org/en-US/docs/DOM/DOM_Reference

	Описание объектов DOM:

		> Описание всех этих объектов доступно в справочнике Web API interfaces:
				https://developer.mozilla.org/en-US/docs/Web/API

		> Document
				https://developer.mozilla.org/en-US/docs/Web/API/document

		> Element
				https://developer.mozilla.org/en-US/docs/Web/API/Element

		> Attr
				https://developer.mozilla.org/en-US/docs/Web/API/Attr

		> Event
				https://developer.mozilla.org/en-US/docs/Web/API/Event


	Описание объектов BOM:

		> Window
				https://developer.mozilla.org/en-US/docs/Web/API/Window

		> Navigator
				https://developer.mozilla.org/en-US/docs/Web/API/Navigator

		> History
				https://developer.mozilla.org/en-US/docs/Web/API/History

		> Location
				https://developer.mozilla.org/en-US/docs/Web/API/Location

		> Screen (описание на w3c, т.к. этого объекта нет на мозилле)
				http://www.w3schools.com/jsref/obj_screen.asp


W3schools:

	> Справочник по объектам DOM, BOM, HTML от w3schools:
			http://www.w3schools.com/jsref/default.asp

	> Туториал по DOM от w3schools:
			http://www.w3schools.com/js/js_htmldom.asp



Прочие ссылки:

	> W3C About DOM:
			http://www.w3.org/DOM/

	> W3C часто задаваемые вопросы о DOM:
			http://www.w3.org/DOM/faq.html

	> W3C Document Object Model standard:
			http://www.w3.org/DOM/DOMTR

	> Учебник "Javascript. Подробное руководство. Редакция №6".
			См. djvu файл.

	> Сайт с информацией об AJAX:
			http://xmlhttprequest.ru/

	> Работа с файлами через AJAX - выбор (в т.ч. drag-n-drop), прием, прогресс и т.д.:
			http://www.html5rocks.com/ru/tutorials/file/dndfiles/



*****************************************************
Оглавление:


	> Дерево DOM
		> О DOM, как W3C стандарте
		> Как DOM относится к JS
		> Что такое DOM и зачем он нужен


	Далее частичный конспект книги "JavaScript. Подробное Руководство",
	раздела книги "2. Клиентский javascript"

	> JavaScript в веб-браузере
		> JS в веб-документах и веб-приложениях
		> Встроить JS в HTML-разметку можно 4-мя способами
		> Выполнение JS кода
			> Происходит в 2 этапа
			> JS - однопоточный
			> Управление порядком выполнения JS-скриптов из внешних файлов
			> Выполнение JS-кода после полной загрузки документа
			> Описание процесса загрузки HTML-документа и выполнения JS-скриптов
		> Вопросы совместимости на стороне клиента
		> Безопасность и JS
			> Общая информация
			> Чего не может javascript (некоторые ограничения)
			> Подробнее о политике общего происхождения
			> Как "ослабить" политику общего происхождения для 2 разных окон
			> XSS - Cross Site Scripting - межсайтовый скриптинг

	> Объект Window
		> Общая информация
		> Таймеры
		> Window.location - получить URL текущего / загрузить новый документ
		> Window.history - как перемещаться вепред/назад по списку ранее посещенных страниц
		> Window.navigator - узнать имя производителя браузера,
			Window.screen - узнать размеры рабочего стола
		> Модальные окна, методы alert(), confirm(), prompt() и showModalDialog()
		> Обработчик onerror
		> Неявное использование значения ID/name в качестве глобальной переменной (св-ва объекта Window)
		> Открытие/закрытие окон браузера, взаимодействие с другими окнами/фреймами

	> Объекты Document, Element, Node. Работа с DOM.
		> Общая информация
		> Обзор модели DOM
		> Поиск и получение элементов DOM
		> Навигация по документу
		> Доступ к атрибутам HTML-элемента
			> Атрибуты в виде св-в HTML-элемента, и в виде св-в объекта attributes
			> Доступ к HTML-атрибуту, как к св-ву объекта HTMLElement
			> Доступ к HTML-атрибуту, как к элементу объекта attributes
			> Пользовательские атрибуты с данными (data-...)
		> Доступ к содержимому HTML-элемента
		> Создание, вставка и удаление узлов
		> Метрики

	> Управление CSS-стилями
		> Встроенные и вычисленные стили
		> Отличие встроенных стилей от вычисленных
		> Встроенные стили
		> Вычисленные стили
		> Управление стилями через классы

	> Обработка событий
		> Общая информация
		> Определимся с терминами
		> Справочник событий находится по следующему адресу
		> Регистрация и удаление обработчиков событий
			> Есть 2 основных способа регистрировать обработчики событий из JS-кода
			> Установить атрибут-событие в виде свойства целевого объекта
			> Регистрация и удаление события методами addEventListener / removeEventListener
		> Вызов функции-обработчиков событий
			> Общая информация
			> Аргумент функции-обработчика событий
			> Контекст функции-обработчика событий
			> Область видимости функции-обработчика событий
			> Возвращаемые значения обработчиков
			> Порядок вызова нескольких обработчиков 1-го события
			> Распространение событий
				> О способности событий "всплывать" вверх по дереву DOM
				> 3 фазы распространения событий
			> Отмена событий
				> Отмена выполнения действий "по умолчанию"
				> Остановка распространения события
		> События мыши, буксировка HTML-элементов
			> О событиях мыши
			> Кроссбраузерный пример буксировки элементов мышью
		> События drag-and-drop (...статья требует завершения...)


	> AJAX - работа с протоколом HTTP
		> Общая информация
			> Javascript способен работать с протоколом HTTP
			> Что такое AJAX
			> Что такое Comet
			> Транспорты
			> О передаче данных из JS в PHP с помощью AJAX
		> Использование объекта XMLHttpRequest
			> Общая информация
			> Выполнение HTTP-запроса
			> Получение HTTP-ответа
				> Общая информация
				> Обработка асинхронного HTTP-ответа
				> Обработка синхронного HTTP-ответа
				> Оформление ответа сервера
			> Оформление тела запроса (при запросах методом POST)
				> Общая информация
				> Передача данных в формате URLEncoded HTML-форм
				> Передача данных в формате JSON
				> Передача файла
				> Передача > 1 куска данных в одном HTTP-запросе в формате multipart
			> События, возникающие в ходе выполнения HTTP-запроса
			> Отмена запроса, предельное время ожидания
			> Междоменные HTTP-запросы
		> Выполнение HTTP-запросов с помощью <script>: JSONP







*****************************************************



> Дерево DOM

	> О DOM, как W3C стандарте
		> DOM - стандарт W3C. Определение DOM в стандарте:
			"W3C Document Object Model (DOM) - платформа и не зависящий от языка
			интерфейс, который позволяет программам и скриптам динамически
			взаимодействовать и изменять содержимое, структуру и стиль документа."
		> Стандарт W3C DOM разделен на 3 разных части:
			- Ядро DOM		| для всех типов документов
			- XML DOM			| для XML-документов
			- HTML DOM   	| для HTML-документов
		> В этом справочнике меня интересует стандарт HTML DOM.
		> Действующий стандарт DOM: Level 3. Стандарт Level 4 находится в
			разработке (на 17.11.2013).

	> Как DOM относится к JS
		> Как описано в справочнике по ядру javascript, JS состоит из ядра и
			клиентской части. Последнюю обеспечивает окружение, в котором запущен
			JS. Так вот браузер - это одно из возможных окружений. А DOM и BOM -
			это и есть та самая клиентская-браузерная часть javascript.

	> Что такое DOM и зачем он нужен
		> Когда браузер загружает XML/HTML-документ, он сканирует (парсит) этот
			документ и создает его модель - дерево объектов, каждый из которых
			называют элементом DOM, или узлом DOM.
		> В DOM попадает все, что содержит исходный HTML-документ:
			- HTML-теги
			- Текст (включая пробелы, переносы строки и т.д.)
			- Комментарии
			- ... и так далее.
		> Все эти объекты, из которых состоит DOM, имеют множество разнообразных
			и полезных свойств и методов, с помощью которых можно совершать
			различные манипуляции с DOM (что сразу же влияет на отображение
			документа):
			- Добавлять, удалять, изменять HTML-элементы и их атритубы в DOM.
			- Изменять любой CSS-стиль на странице.
			- Создавать, удалять и реагировать на любое HTML-событие
			- Получать информацию о любом узле DOM.
		> При изменении любого элемента DOM браузер автоматически обновляет
			документ на экране.




Далее конспект глав книги "JavaScript. Подробное Руководство"
================================


> JavaScript в веб-браузере

	> JS в веб-документах и веб-приложениях
		> Разделение на веб-документы и веб-приложения достаточно условно.
		> Веб-документ должен работать нормально даже при выключенном JS.
		> Веб-приложение скорее всего не будет работать при выключенном JS.

	> Встроить JS в HTML-разметку можно 4-мя способами:

		- С помощью HTML-элемента script:
				<script> ... </script>

		- Из внешнего файла, заданного атрибутом src тега <script>^
				<script src='путь_к_файлу.js'></script>

		- В обработкик события, зананный в виде HTML-атрибута:
				<div onclick='... JS_код ...'></div>

		- Как тело URL-адреса, использующего спецификатор псевдопротокола JavaScript:
				<a href="JavaScript:alert('Hi there!');">
					Вызвать модальное окно
				</a>

	> Выполнение JS кода

		> Происходит в 2 этапа:
			> Этап 1 - происходит загружка содержимого документа и запускается код
				в HTML-элементах script (в т.ч. из подключенных атрибутом src файлов).
				> Обычно (но не всегда) сценарии запускаются в порядке их появления
					в документе.
				> Каждый сценарий выполняется сверху-вниз и слева-направа от начала
					до конца.
				> Обычно этот этап протекает быстро - несколько секунд.
			> Этап 2 - асинхронный и управляемый событиями.
				> Наступает после завершения этапа №1.
				> На этом этапе, браузер в ответ на возникновение тех или иных событий
					вызывает JS-код, который назачен тому или иному события с помощью
					атрибутов-событий HTML-элементов (см. справочник по HTML).
				> Этот этап длится до тех пор, пока документ отображается в браузере.

		> JS - однопоточный
			> И ядро JS, и клиентский JS - подерживают однопоточную модель
				выполнения.
			> Сценарии и обработчики выполняются по очереди, не конкурируя
				друг с другом.
			> Однопоточное выполнение означает, что браузер должен прекратить
				откликаться на действия пользователя на время выполнения скрипта
				или обработчика событий. И это накладывет некоторые ограничения:
				> Если JS-скрипт выполняется слишком долго, и порядок выполнения
					синхронный (см. ниже), то до тех пор, пока он не будет полоностью
					загружен и выполнен, пользователь не увидит остальной части страницы.
					> В таком случае полезно предупредить пользователя, что будут проводитсья
					 	длительные вычисления, и браузер может не откликаться на его действия.
					> А вообще длительные вычисления рекомендуется разбивать на части,
						используя таймеры (см. Ядро JS -> 6. Таймеры).
			> Web Worker
				> Web Worker - фоновый поток выполнения, предназначенный для выполнения
					продолжительных вычислений и предотвращения блокирования пользовательского
					интерфейса.
				> Определен стандартом HTML5.
				> JS-код, выполняемый в потоке web worker, не имеет доступа к содержимому
					документа, информации из главного потока, и к другим потокам web worker.
					И может взаимодействовать с ними только посредством асинхронных событий.

		> Управление порядком выполнения JS-скриптов из внешних файлов
			> Есть 3 варианта:

				- Синхронный (по умолчанию)
					> Пока код из подключенного JS-файла не будет полностью загружен
						и выполнен, оставшаяся часть HTML-документа (которая идет после
						элемента script, подключающего этот файл) не будет продолжать
						загражаться и отображатсья.
					> Это опасно тем, что если скрипт зависнет (например, бесконечный
						цикл), то вся остальная часть HTML-документа так никогда и не
						будет отображена.
					> И еще один минус - бывают тяжелые скрипты, выполнение которых
						может занимать внушительное время. И пока они не выполнятся,
						остальная часть сайта не отобразится, что плохо.

				- defer
					> Скрипт начнет выполняться, когда HTML-документ будет полностью загружен.
					> Это атрибут HTML-элемента script.
					> Может поддерживаться не всеми браузерами.
					  > Поэтому пока что вместо defer лучше использовать старый добрый
					  	метод с обработчиком событий onload (см. ниже).

				- async
					> Скрипт выполняется, а страница продолжает загружаться, не дожидаясь
						окончания его выполнения.
					> Это атрибут HTML-элемента script.
					> Может поддерживаться не всеми браузерами.

		> Выполнение JS-кода после полной загрузки документа
			> Многим JS-скриптам для нормальной работы требуется сначала дождаться
				полной загрузки документа. Например, скрипт, который манипулирует
				DOM, не сможет этого сделать, если DOM еще не сформировался.
			> Решить эту проблему можно 2-мя способами:
				- Размещать тело скрипта в конце HTML-документа.
				- Восползоваться обработчиком событий onload - он срабатывает в тот
					момент, когда HTML-документ полностью загружен.
					> Пример. В принципе, в такую функцию func можно поместить весь
						JS-код, который должен быть выполнен только после полной
						загрузки страницы:

							var func = function() {
								console.log('Страница полностью загружена!');
							};
							window.onload = func;

		> Описание процесса загрузки HTML-документа и выполнения JS-скриптов
			> Общая информация об этом процессе
				> Это идеализированная последовательность, и не все браузеры
					придерживаются её в точности.
				> Событие load поддерживается всеми браузерами.
				> Свойство document.readyState реализовано всеми основными браузерами,
					но значения, которое оно получает, отличаются между браузерами.
				> Атрибут defer поддерживается всеми современными браузерами,
					включая частичную поддержку IE 8-9.
					> Реализовать отложенное выполнение скриптов можно с помощью приема,
						использующего обработчик onload, описанного выше.
				> Атрибут async на данный момент (17.11.2013) поддерживается всеми
					современными браузерами. Не поддерживается IE <= 9.
					> Реализовать асинхронное выполнение скриптов можно и с помощью
						приема, описанного ниже.

			> Этап 1 - синхронное выполнение скриптов

				1.	> Браузер создает объект Document.
						> Начинает синтаксический разбор HTML-кода, добавляя в
							DOM объекты Element и текстовые узлы.
						> Свойство document.readyState = 'loading'.

				2.	> При встрече элементов script без атрибутов async/defer,
							синтаксический анализ ставится на паузу до полной загрузки
							и выполнения внутреннего и/или подключенного из внешнего
							файла JS-кода.
						> После чего синтаксический анализ продолжается.
						> Такие скрипты (с синхронным порядком выполенния) могут
							использовать метод document.write() для вставки текста
							во входной поток. Этот текст станет частью документа.
						> Такие скрипты видят собственный HTML-элемент script и содержимое
							HTML-документа перед ним.

				3.	> При встрече элементов script с атрибутом async, синтаксический
							анализ на паузу не ставится, а продолжается.
						> При этом скрипт загружается, и сразуе после этого выполняется.
						> Такие скрипты (с асинхронным порядком выполнения) не должны
							использовать метод document.write()
						> Такие скрипты видят собственный HTML-элемент script и содержимое
							HTML-документа перед ним. И, возможно, доп. содержимое документа.

				4.	> Когда синтаксический анализ документа заканчивается, значение
							свойства становится document.readyState = 'interactive'

				5.	> Выполняются все скрипты, подключенные с помощью элементов
							script с атрибутом defer.
						> Выполнение происходит в том же порядке, в котором они встречались
							в документе.
						> В этот момент также могут выполняться и асинхронные сценарии,
							например, обработчик события, если это событие произошло.
						> Такие скрипты (с отложенным порядком выполнения) не должны
							использовать метод document.write().
						> Такие скрипты имеют доступ ко всему дереву DOM.

				6.	> Браузер возбуждает событие "DOMContentLoaded" в объекте Document.
							Это событие отмечает переход от этапа синхронного выполнения
							скриптов (этап 1) к управляемому событиями асинхронному этапу
							(этап 2)


			> Этап 2 - управляемый событиями, асинхронный

				7.	> К этому моменту синтаксический анализ завершен.
						> Но браузер все еще может ожидать окончания загрузки доп.
							содержимого, например изображений.
						> Когда все содержимое будет загружено, и все асинхронные сценарии
							будут выполнены, свойство document.readyState = 'complete',
							и браузер возбудит событие "load" в объекте window. На это событие
							и можно повесить обработчик onload.

				8. 	С этого момента будут асинхронно вызываться обработчики событий,
						в ответ на действия пользователя, сетевые операции, истечение
						таймера и т.д.


	> Вопросы совместимости на стороне клиента
		> Вопросы совместимости касаются клиентской части JS. Ядро JS реализовано
			во всех браузерах практически одинаково, и особых проблем с ним нет.
		> Клиентский браузерный JS-код запускается в браузере. В мире
			много разных браузеров:
			- От разных производителей: Microsoft, Mozilla, Apple, Google, Opera и т.д.
			- Разных версий
			- Запускаемых на разных платформах: Windows, Mac OS, Linux, iPhone OS, Android и т.д.
		> Написать JS-код, который бы работал везде - не тривиальная задача. Она сводится
			к тому, чтобы код работал у MAX возможноного процента пользователей.
		> Проблемы совместимости на стороне клиента делятся на 3 основные
			категории:

			- Эволюционные - старые браузеры не поддерживают то, что поддерживают
				новые браузеры. А ведь старыми браузерами все еще пользуется определенный
				% пользователей, и их не хотелось бы терять.

			- Отсутствие реализации - некоторые современные браузеры реализовали
				поддержку какой-то вещи, а другие нет. А ведь этими другими браузерами
				пользуется какой-то % пользователей, и их не хотелось бы терять.

			- Ошибки - реализация каких-то вещей в разных браузеров бывает
				организована по-разному, и имеет свои особенности. Поэтому приходится
				учитывать в своем коде особенности конкретного браузера, если мы
				хотим, чтобы в нем код работал нормально.

		> Очень полезный сайт, на котором можно проверить совместимость
			какой-нибудь вещи в браузерах разных версий и производителей:

				http://caniuse.com/

		> Библиотеки обеспечения совместимости
			> Иногда можно подключить и использовать какую-нибудь JS-библиотеку,
				нивелирующую различия реализации какой-то технологии в разных
				браузерах.
			> Например, jQuery позволяет работать с DOM без оглядки на производителя
				браузера - jQuery-код работает во всех браузерах одинаково и без
				различий.
			> Это одна из причин, по которой большинство разработчиков используют
				фреймфорки на языке javascript, такие как jQuery. Потому что эти
				фреймворки позволяют писать код и не париться по поводу различий
				в разных браузерах.

		> Способы обойти различия реализации клиентского JS в разных браузерах
			> С помощью объекта Navigator можно узнать, в каком браузере запущен
				код, и запустить реализацию кода именно для этого браузера.
			> Проверка наличия св-ва или метода - как способ обойти различия браузеров
				> В браузерах разных производитлей для какого-то действия моугут быть
					предусмотрены отличающиеся друг от друга свойства и методы.
				> Поэтому в чистом JS-коде это надо предусматривать - если такой-то
					метод есть, значит это Chrome, и тогда делать надо так, а если
					вместо него есть вот такой-то, значит это IE, и делать надо так.
			> Условные комментарии в IE
				> Т.К. IE - самый проблемный браузер, то для него даже создали так
					называемые условные комментарии (их поддерживает только IE).
				> Заключенный в условный комментарий код будет исполняться только
					в IE, и только в указанной его версии.
				> Пример:

						<!--[if IE 6]>
								... этот код сработает только в IE6 ...
						<![endif]-->

						<!--[if IE 7]>
								... этот код сработает только в IE7 ...
						<![endif]-->

			> Ну а лучше использовать фреймворки, такие как jQuery, и не париться! =)


	> Безопасность и JS

		> Общая информация
			> Наличие интерпретатора JavaScript в веб-браузерах означает, что
				загружаемая веб-страница может выполнять произвольный JS-код.
				Поэтому производители веб-браузеров прилагают немалые усилия
				по обеспечению безопасности.
			> Производители с одной стороны стремятся увеличивать возможности
				языка, а с другой стараются исключить возможности, угрожающие
				безопасности.

		> Чего не может javascript (некоторые ограничения)

			> Записывать и удалять файлы на компьютере клиента.
				> Однако, можно реализовать чтение файлов, выбранных пользователем.
					(см. класс FileReader и File API)
				> И можно настроить безопасную частную файловую систему, в пределах
					которой JS-программы смогут работать с файлами
					(только Chrome, см. requestFileSystemSync)

			> Клиентский JS не имеет универсальных механизмов сетевых
				взаимодействий.
				> Но он может управлять протоколом HTTP (см. AJAX).

			> JS может открывать новое окно браузера, но большинство браузеров
				позволяют ограничить эту возможность (из-за наглых рекламодателей)
				так, чтобы всплывающие окна могли появляться только в ответ на
				действия пользователя, такие как щелчек мыши.

			> JS может закрыть окно браузера, открытое ею же.
				Но она не может закрыть другое окно без подтверждения пользователя.

			> Свойство value HTML-элемента FileUpload не может быть установлено
				программно. Иначе скрипт мог бы скачать любой файл с компа клиента.

			> JS-скрипт не может "подглядывать" в другие открытые окна браузера,
				и, соответственно, назначать им обработчики событий. Это ограничение
				известно под именем "политика общего происхождения"

		> Подробнее о политике общего происхождения
			> Политика общего происхождения - радикальное ограничение, связанное
				с безопасностью, накладываемое на веб-содержимое, с которым может
				взаимодействовать JS-скрипт.
				> ПОП позволяет избежать кражы данных JS-скриптом, запущенным в
					одной вкладке или фрейме, из других вкладок или фреймов.
			> Обычно применяется, когда:
				- открыты другие окна/вкладки браузера
				- когда HTML-документ содержит элементы iFrame
			> ПОП ограничивает возможность JS-скрипта, работающего на одной
				странице/вкладке/iFrame взаимодействовать с содержимым в других
				окнах/фреймах.
				> Таким образом, JS-скрипт может читать только свойства окон и документов,
					имеющих общее с самим скриптом происхождение.
					(подробнее см. ниже: "Объект Window -> Работа с несколькими окнами и фреймами")
			> Происхождение
				> Определяется протоколом, именем хоста и номером порта URL-адреса,
					откуда был загружен документ.
				> Если хоть что-то отличается - значит происхождение другое. Даже
					если отличаются протоколы: http и https.
			> Работа с AJAX
				> ПОП действует и при работе с AJAX - по протоколу HTTP с применением
					объекта XMLHttpRequest.
				> Этот объект может отправлять произвольные HTTP-запросы, но только
					тому веб-серверу, откуда был загружен документ, содержащий JS-скрипт.

		> Как "ослабить" политику общего происхождения для 2 разных окон
			> Приём №1 - с помощью Document.domain
				> У объекта Document есть свойство domain.
				> Если установить одинаковое значение для domain на 2-х разных
					вкладках/окнах/фреймах, то они смогут читать значения свойств
					друг друга.
			> Приём №2 - cross-domain-messaging
				> Позволяет скрипту из одного документа передавать текстовые сообщения
					скрипту в другом документе, не взирая на ПОП.
				> Отправить сообщение можно методом Window.postMessage(). Он производит
					асинхронную отправку сообщения.
				> Получить сообщение можно обработчиком события onmessage.

		> XSS - Cross Site Scripting - межсайтовый скриптинг
			> XSS - это вид уязвимости веб-приложения.
				Атакующий внедряет HTML-теги или скрипты на уязвимом сайте.
			> Веб-страница считается уязвимой для XSS-атак, если она динамически
				создает содержимое документа на основе пользовательских данных,
				не прошедших предварительную проверку по удалению встроенного
				HTML-кода.
			> Универсальный способ предотвращения XSS-атак - удалять все HTML-теги
				из всех данных сомнительного происхождения, прежде чем использовать
				их для динамического создания содержимого документа.



> Объект Window

	> Общая информация
		> Этот объект содержит свойства и методы, из которых лишь не многие
			имеют отношение к окну браузера, в честь которого объект получил название.
		> Тут будет общий обзореобъекта, некоторых его св-в и методов.

	> Таймеры
		> Подробно описание и примеры таймеров см. "Ядро JS -> 6. Таймеры"

	> Window.location - получить URL текущего / загрузить новый документ
		> Свойство Window.location ссылается на объект Location.
			И св-во Document.location тоже ссылается на тот же объект Location:

				Window.location === document.location  // всегда верно

		> Объект Document имеет св-во URL, хранящее стат. строку с адресом
			URL документа:

				console.log(document.URL);		// "http://localhost:63342/2.%20HTML,%20CSS,%20JS%20Library/3.%20JavaScript/2.%…%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%20%D0%BF%D0%BE%20DOM.html"

		> При переремещении по документу с использованием идентификаторов, таких
			как "#table-of-contents", внутри документа объект Location будет
			обновляться, отражая факт перемещения, а вот document.URL будет
			оставаться неизменным.

		> Метод Location.assign() заставляет окно загрузить и отобразить
			документ по указанному URL-адресу:

				location.assign('http://google.com');  // переход на гугл

		> Метод Location.replace() делает тоже самое, что assign(), но плюс
			еще удаляет текущий документ из списка посещавшихся страниц. Таким
			образом, нажав на кнопку "назад" в браузере, уже не вернуться на
			эту предыдущую страницу. Это позволяет избежать ситуации, когда нажимаешь
			на "назад", и снова срабатывает тот же сценарий, который снова перекидывает
			тебя вперед. Пример:

				location.replace('http://google.com');  // переход на гугл, вернуться "назад" нельзя

		> Метод Location.reload() - заставляет страницу перезагрузиться:

				location.reload();

		> Более традиционный спомоб заставить браузер перейти к новой станице
			заключается в том, чтобы просто присвоить новый URL-адрес свойства
			location (можно присвоить и относительный адрес):

				location = 'http://www.oreilly.com';	// мгновенный переход по этому адресу

				location = './JS - оглавление и общая информация.html';

				location = '#top';  // просто прокрутить страницу к якорю

		> Свойства Location доступны для записи. И если их перезаписать, то браузер
			будет вынужден загрузить документ по этому новому адресу.


	> Window.history - как перемещаться вепред/назад по списку ранее посещенных страниц
		> Свойство Window.history ссылается на объект History данного окна.
		> Объект History хранит историю просмотра страниц в окне в виде списка
			документов и сведений о них.
		> History.length - кол-во элементов в этом списке.
		> JS-код не может получить хранящиеся в History URL-адреса посещенных страниц.
			Это связано с безопасностью - ведь если бы можно было, то:
			- Любой JS-скрипт мог бы исследовать историю посещений сайтов.
			- Любой JS-скрипт мог бы подсмотреть переданые в виде query-string
				данные, а там могут быть важные секретные данные пользователя.
		> Методы back() и forward() действуют подобно кнопкам "надад", "вперед".
		> Метод go(N) пропускает N страниц. N может быть отрицательным.
		> Если окно содержит фреймы, то история посещений в главном окне
			хронологически перемешена с историей посещений во фреймах.
		> Для AJAX документов тоже можно реализовать способ перемещения
			вперед-назад по приложению. Стандарт HTML5 определяет 2 способа
			реализации, и они описаны в разделе про AJAX.
			> Лучше всего использовать готове решения. Например, в jQuery существует
			 	расширение history.

	> Window.navigator - узнать имя производителя браузера,
		Window.screen - узнать размеры рабочего стола
		> Объект Window.navigator - содержит свойства с различной информации
			о браузере, в котором запущен код, и даже о платформе, на которой
			он запущен.
			> Можно посмотреть, что у него внутри:

					console.log(window.navigator);

		> Объект Window.screen содержит информацию о размерах экрана (в px)
			клиента, на котором просматривают этот веб-документ:

					console.log(window.screen.availWidth);		// 1600
					console.log(window.screen.availHeight);		// 854


	> Модальные окна, методы alert(), confirm(), prompt() и showModalDialog()
		> Методы alert, confirm и prompt являются блокирующими. Это значит, что
			пока пользователь не отреагирует на них, программный код ставится
			на паузу, и текущий загружаемый документ, если таковой существует,
			прекращает загружаться.
		> Window.alert() - выводит сообщение в модальном браузерном окне.
		> Window.confirm() - открывает модальное окно, где предлагает щелкнуть
			либо "OK" (возвращает true), либо "Cancel" (возвращает false).
		> Window.prompt() - выводит сообщение и ждет ввода строки пользователем,
			и возвращает эту строку. Либо, если ничего не введено, пустую строку.
		> Пример:

				var name;
				if(confirm('Вы готовы представиться?')) {
					name = prompt();
					alert('Здравствуйте, '+name);
				} else {
					alert('Здравствуйте, анонимус');
				}

		> showModalDialog
			> Также у Window есть более сложный метод showModalDialog.
			> Он тоже создает модальный диалог в отдельном окне браузера.
			> Он принимает HTML-разметку.
			> Он позволяет передавать аргументы, и получать возвращаемое значение.
			> Но вообще, можно обойтись и без него. Должна быть какая-то особая
				ситуация, чтобы понадобилось его задействовать.


	> Обработчик onerror
		> Обработчик onerror - это пережиток первых лет развития JS, когда
			в базовом языке еще небыло try/catch. Однако, он все еще может
			быть полезен (см. пример ниже)
		> Свойство onerror объекта Window - это обработчик собыбий, который
			вызывается тогда, когда необработанное исключение достигло вершины
			стека вызовов - т.е. когда браузер готов уже отобразить сообщение
			об ошибке в консоли.
		> Этому обработчику можно присвоить JS-функцию, который будет выполняться
			каждый раз в таких ситуациях.
		> Этот код - и станет обработчиком ошибок для этого окна браузера.
		> Исторически сложилось так, что обработчику Window.onerror передается
			3 аргумента, а не 1:
			- msg   | сообщение, описывающее произошедшую ошибку
			- url   | строка с URL документа
			- line  | номер строки в документе, где произошла ошибка.
		> Функция-обработчик может вернуть true, это значит - ошибка
			обработана, никаких дальнейших действий не требуется.
 		> Пример - можно определить свой обработчик, который будет уведомлять
 			тебя обо всех происходящих ошибках:

 				window.onerror = function(msg,url,line) {
 					if(onerror.num++ < oneror.max) {
 						alert('ОШИБКА: '+msg+'\r\n'+url+':'+line);
 						return true;
 					}
 				};
 				onerror.max = 3;
 				onerror.min = 0;


	> Неявное использование значения ID/name в качестве глобальной переменной (св-ва объекта Window)
		> Это пережиток развития истории веб-браузеров. Эту особенность
			оставили для сохранения обратной совместимости. Но использовать
			его сейчас не рекомендуется. В любой момент производители браузеров
			могут определить новое св-во в объекте Window, и твой код сдуется.
			> Вместо этого, можно производить поиск элементов с помощью метода
				document.getElementById(). А еще проще пользоваться jQuery.
		> Если у HTML-элемента есть атрибут ID с каким-то значением, и если
			у Window еще нет св-ва с таким именем, то объект Window получает
			свойство с именем, равным значению ID этого атрибута.
		> Это свойство имеет атрибут enumerable = false, и содержит объект
			HTMLElement, представляющий этот элемент документа.
		> Таким образом, HTML-элементы с атрибутом ID становятся глобальными
			переменными, доступными скриптам:

				<p id='okay'></p>
				console.log(okay);		// <p id='okay'></p>

		> Но если у объекта Window уже существует свойство, имя которого
			совпадает со значением атрибута ID HTML-элемента, то естественно,
			еще одно свойство с таким именем у объекта Window создано не будет.
			Например:

				<p id='navigator'></p>
				console.log(navigator);		// Navigator { .. }   - это все тот же старый добрый навигатор

		> Если в скрипте есть переменная с именем X, и HTML-элемент с
			id='x', то явно объявленная переменная скроет под собой HTML-элемент:

				var okay = 10;
				console.log(okay);		// 10  (а не <p id='okay'></p>)

		> Кроме того, некоторые элементы ведут себя подобным образом, если
			у них есть атрибут name. Вот список этих элементов:
			a, applet, area, embed, form, frame, frameset, iframe, img, object

		> С iFrame это работает несколько иначе. Созданная глобальная переменная
			будет ссылаться не на объект Element, а на объект Window этого фрейма.


	> Открытие/закрытие окон браузера, взаимодействие с другими окнами/фреймами
		> Вкладки изолированны друг от друга
			> 1 окно браузера может содержать несколько вкладок. Кажая вкладка имеет
				свой собственнй объект Window, и изолирована от всех остальных.
			> Скрипт, выполняющийся в 1 вкладке, не может даже узнать о существовании
				других, и не может взаимодействовать с их объектами Window и с содержимым
				их документов.
			> Все это касается окон, вкладок и фреймов.
		> Если 1-на вкладка произошла от другой, они могут взаимодействовать
			> Если скрипт из 1-й вкладки открыл новую вкладку, то эти 2 вкладки
				могут взаимодействовать друг с другом.
		> Открытие/закрытие окна/вкладки браузера
			> Открытие
				> Можно:
					- Открыть новое окно/вкладку
					- Открыть существующее окно/вкладку
				> Из существующих окон скрипт может открыть только те, которыми
					ему "разрешено управлять" в соотв. с политикой общего происхождения.
				> Имя окна хранится в св-ве Window.name
				> Открыть окно можно ф-ией open(URL,name,params,doReplace)
					- URL					| URL нового окна
					- name				| имя нового окна - если такое есть, то открывается оно
					- params			| (не стандартизирован)
					- doReplace		| сделать ли в истории replace текущего окна новым?
				> Пример:

						open();											// открыть новое пустое всплывающее окно (Chrome)
						open('http://google.com');	// открыть гугл во всплывающем окне

				> Всплывающими окнами часто злоупотребляют рекламодатели, поэтому в
					большинстве браузеров есть механизм их блокирования.
					> Окно всплывет, только если пользователь щелкнул мышкой по ссылке
						или кнопке.
					> В Chrome всплывающие окна блокируются, и пользователь может сам
						решить, открыть его или нет.

			> Закрытие
				> Если скрипт из окна А открыл окно Б, то закрыть его теперь можно
					следующими способами:
					> Скрипт из окна А может закрыть его так, с использованием
						имени окна:

							close('имя_окна');

					> А скрипт из окна Б мог бы закрыть своё же окно так:

							window.close();

					> Большинство браузеров разрешают JS-скрипту закрывать только
						те окна, которые им же и были созданы.
						> Если же браузер попытается закрыть другое окно, то появится
							диалоговое окно с вопросом к пользователю, надо ли закрывать
							это окно.
							> Пример. Открой 2 окна - А и Б.
								- В окне А открой сайт www.google.com и пропиши в консоли
									имя этого окна (по умолчанию window.name = ''):

										window.name = 'google';

								- В окне Б открой консоль, напиши следующую строку:

										window.close('google');

								> Результат - окно было закрыто без доп. предупреждений,
									потому что все это делалось из консоли браузера. А если
									бы это были разные скрипты, то возникло бы диалоговое окно.




> Объекты Document, Element, Node. Работа с DOM.


	> Общая информация
		> Для работы с DOM лучше всего использовать какой-нибудь фреймворк,
			вроде jQuery. Потому что:
			- Это удобнее.
			- Во всех браузерах работает одинаково.
			- Даже работает в старых браузерах, т.ч. старых IE.
		> Каждое окно/вкладка/фрейм имеет свой объект Window. Каждый объект Window
			имеет своё свойство window.document, которое ссылается на объект Document.
		> Объект Document - центральный объект обширного API, известного как
			Document Object Model - DOM, который определяетпорядок доступа к
			содержимому документа.


	> Обзор модели DOM
		> Объектная модель документа - DOM - это фундаментальный прикладной
			программный интерфейс (API), обеспечивающий возможность работы с содержимым
			XML/HTML-документов.

		> HTML DOM представлен в виде дерева.
			> Терминология:
				- Узел-родитель		| узел непосредственно над данным узлом
				- Дочерний узел		| узел непосредственно под данным узлом
				- Узел-брат				| соседний узел
				- Узлы-потомки		| все узлы под данным узлом
				- Узлы-предки			| все узлы над данным узлом

			> Узлы дерева образуют:
				- HTML-элементы
				- Текст (образует текстовые узлы, в т.ч. пробелы и переносы строки)

			> Каждый узел имеет предком (а не родителем) объект Node.
				> У объекта Node есть дочерние объекты, которые уже непосредственно
					представляют разные виды узлов:
					- Document	| корень дерева, представляет документ целиком
					- Element		| представляют HTML-элементы
					- CharacterData.Text		| представляют текст
					- CharacterData.Comment	| представляют комментарии
					- Attr			| представляют HTML атрибуты
					- DocumentFragment	| (редко встречаются) представляет послед-ть узлов,
																не имеющих общего родителя
					- ...
				> Узлы типа Attr практически никогда не используются, потому что
					класс Element определяет методы, позволяющие интерпретировать
					атрибуты, как пары имя/значение, а не как узлы документа.
				> Самые важные классы в DOM - это Document и Element.


	> Поиск и получение элементов DOM

		> Общая информация
			> Для получения и работы с элементами DOM лучше всего использовать
				какой-нибудь фреймворк, вроде jQuery. Потому что:
				- Это удобнее.
				- Во всех браузерах работает одинаково.
				- Даже работает в старых браузерах, т.ч. старых IE.
			> Большинство клиентских JS-скриптов так или иначе манипулирует
				элементами документа. Чтобы выполнять эти манипуляции, сначала
				скрипт должен получить ссылку на требуетмый объект-элемент.
			> Для этого есть несколько способов, которые описаны ниже:
				- По значению атрибута id
				- По значению атрибута name
				- По имени тега
				- По имени CSS-класса или классов
				- По совпадению с определенным CSS-селектором.

			> Получение элемента по значению атрибута id
				> id элемента уникально в HTML-документе, поэтому поиск по id
					возвращает недвусмысленно ссылку на искомый уникальный элемент.
				> Пример - ищет элемент по ID и вставляет внутрь HTML:

						var element = document.getElementById('uniqueID');
						element.insertAdjacentHTML('afterBegin','Hi there!');

				> Особенности работы метода getElementById в IE <= 7
					- Поиск ведется без учета регистра.
					- Также возвращает элементы, в которых найдено совпадение со
						значением атрибута name.

		> Получение элемента по значению атрибута name
			> Значение name не обязано быть уникальным (в отличие от id).
			> Атрибут name изначально предназначался для присваивания имен
				элементам форм, и использовался для отправки данных формы на сервер.
			> Атрибут name есть не у всех HTML-элементов (см. справочник по HTML),
				преимущественно у форм и их элементов, iFrame и img.
			> Пример:

					var element = document.getElementsByName('someName');

				> Метод getElementByName:
					> определяется не классом Document, а классом HTMLDocument,
						поэтому доступен только в HTML-документах.
					> Возвращает объект NodeList, который ведет себя как доступный
						только для чтения массив объектов Element.
						> При этом NodeList - это не массив, и он не наследует от
							Array соответствующие св-ва и методы.
						> NodeList - не статичен, и если в документе что-то изменяется,
							то изменения происходят и в содержимом NodeList.
							> Поэтому при проведении цикла итераций по NodeList,
								если во время этого процесса возможно будут происходить
								удаления/добавления элементов в DOM, лучше создать
								статичную копию NodeList
					> Если найден только 1 элемент, то ссылка на него и возвращается
						вместо NodeList.

		> Получение элемента по имени тега
			> С помощью этого способа можно получить все элементы указанного
				типа.
			> Например - получить все элементы p, вставить в первый из них текст:

					var elements = document.getElementsByTagName('p');
					element[0].insertAdjacentHTML('afterBegin','Hi there!');

				> Метод getElementsByTagName
					> Если найдено больше 1 элемента, возвращает объект NodeList,
						ведущий себя как массив, и содержащий все найденные элементы.
						> Элементы документа помещаются в NodeList в том же порядке,
							в котором они следуют в документе.
						> При этом NodeList - это не массив, и он не наследует от
							Array соответствующие св-ва и методы.
						> NodeList - не статичен, и если в документе что-то изменяется,
							то изменения происходят и в содержимом NodeList.
							> Поэтому при проведении цикла итераций по NodeList,
								если во время этого процесса возможно будут происходить
								удаления/добавления элементов в DOM, лучше создать
								статичную копию NodeList
					> Если найден 1 элемент, то возвращает этот элемент без объекта
						NodeList.
					> Поиск производится без учета регистра символов.
					> Чтобы получить все элементы документа, можно передать
						символ '*':

							var allElements = document.getElementsByTagName('*');

					> У класса Element есть свой метод getElementsByTagName
						> Он действует точно также, но ищет только элементы, являющиеся
							потомками для элемента, относительно которого вызывается
							метод.
						> Например, найти все элементы span внутри первого в документе
							элемента p можно так:

								var element = document.getElementsByTagName('p')[0];
								var allSpans = element.getElementsByTagName('span');


		> Получение элемента по имени CSS-класса или классов
			> Значение атрибута class не обязательно должно быть уникальным,
				в отличие от id.
			> Ключевое слово class зарезервировано в javascript, поэтому
				для хранения значения HTML-атрибута class в клиентском JS
				используется свойство className.
			> Пример:

					var elements = getElementsByClassName('someClass');

				> Метод getElementsByClassName
					> Если найдено больше 1 элемента, возвращает объект NodeList,
						ведущий себя как массив, и содержащий все найденные элементы.
						> Элементы документа помещаются в NodeList в том же порядке,
							в котором они следуют в документе.
						> При этом NodeList - это не массив, и он не наследует от
							Array соответствующие св-ва и методы.
						> NodeList - не статичен, и если в документе что-то изменяется,
							то изменения происходят и в содержимом NodeList.
							> Поэтому при проведении цикла итераций по NodeList,
								если во время этого процесса возможно будут происходить
								удаления/добавления элементов в DOM, лучше создать
								статичную копию NodeList
					> Если найден 1 элемент, то возвращает этот элемент без объекта
						NodeList.
					> Строке-аргументе можно указать несколько имен классов,
						разделенных пробелами.
					> У класса Element есть свой метод getElementsByClassName
						> Он действует точно также, но ищет только элементы, являющиеся
							потомками для элемента, относительно которого вызывается
							метод.
					> Реализован во всех основных браузерах, кроме IE8.
						> В IE8 приходится его эмулировать с помощью метода
							querySelectorAll().


		> Получение элемента по совпадению с определенным CSS-селектором
			> Можно получить элементы, соответствующие заданному CSS-селектору.
			> Метод document.querySelectorAll():
				> Ищет все соответствующие переданному селектору элементы, и
					возвращает их в виде объекта NodeList, или если наййдент
					только 1 элемент - ссылку на этот элемент.
				> В отличие объектов NodeList, описанных выше, этот NodeList
					не является "живым".
			> Метод document.querySelector()
				> В отличие от querySelectorAll, этот метод возвращает только
					ссылку на 1-й наденный элемент.
			> Оба метода querySelectorAll и querySelectorAll есть также и
				у класса Elements. Работают они так - поиск производится по
				всему документу, а затем результат фильтруется так, чтобы остались
				тольк элементы-потомки элемента, относительно которого вызван
				метод.
			> Вышеописанные методы не найдут псевдоэлементы вроде :first-letter,
				и многие браузеры не возвращают результат для псевдоклассов
				:link и :visited - чтобы злоумышленник не смог собрать информацию
				об истории посещений страниц пользователем.


	> Навигация по документу

		> Общая информация
			> Для работы с DOM лучше всего использовать какой-нибудь фреймворк,
				вроде jQuery. Потому что:
				- Это удобнее.
				- Во всех браузерах работает одинаково.
				- Даже работает в старых браузерах, т.ч. старых IE.

		> Есть 2 интерфейса для навигации по DOM:
			- Навигация по DOM, как по объектам класса Node (старый)
			- Навигация по DOM, как по объектам класса Element (новый)

		> Навигация по DOM, как по объектам класса Node
			> Объекты классов Document, Element и Text - потомки объекта Node.
			> Они наследуют от класса Node следующий св-ва:
				- parentNode			| родительский узел данного узла (или null, если его нет)
				- childNodes			| аналог NodeList, содержащий дочерние узлы; живой; доступный только для чтения;
				-	firstChild			|	первый дочерний узел (или null, если их нет)
				-	lastChild				| последний дочерний узел (или null, если их нет)
				- nextSibling			|	следующий братский узел
				-	previousSibling	|	предыдущий братский узел
				-	nodeType				|	тип узла: 3 - Document, 1 - Element, 3 - Text, 8 - Comments, 11 - DocumentFragment
				-	nodeValue				|	текстовое содержимое узлов Text и Comment
				-	nodeName				| имя тега эл-та Element в верхнем регистре

		> Навигация по DOM, как по объектам класса Element
			> Этот способ новее и проще в использовании, чем вышеописанный.
			> Когда интересуют скорее сами элементы Element, а не текст в них
			  и комментарии (а текста лишнего бывает много - всякие проблеы
			  по краям от элемента, переносы строк и прочее), то лучше и проще
			  использовать прикладной интерфейс, позволяющий перемещаться только
			  по элементам Element, игнорируя элементы Text и Comment, которые
			  тоже являются частью документа.
			> Прикладной интерфейс обеспечивают свойства объекта Element,
				однако все ниже перечисленные свойства, кроме children,
				не поддерживаются IE <= 8:
				- children								| возвращает NodeList всех дочерних элементов (без узлов Text и Comment).
				- firstElementChild				|	первый дочерний элемент
				- lastElementChild				| последний дочерний элемент
				- nextElementSibling			|	следующий братский элемент
				- previousElementSibling	|	предыдущий братский элемент
				- childElementCount				| кол-во дочерних элементов, возвращает тоже, что children.length


	> Доступ к атрибутам HTML-элемента

		> Атрибуты в виде св-в HTML-элемента, и в виде св-в объекта attributes
			> Атрибуты HTML-элементов представлены в 2 разных местах:
				- В виде свойств объекта HTMLElement
				- В виде элемента объекта attributes, который ведет себя, как массив,
					и является св-вом объекта Element.
			> Разница между вышеуказанными представлениями атрибутов:
				> Атрибуты в виде свойств объекта HTMLElement:
					- Могут иметь значение любого типа
					- Название чувствительно к регистру
					- Не видны в innerHTML
				> Атрибуты В виде свойств объекта attribute:
					- Могут иметь значение только типа string
					- Название не чувствительно к регистру
					- Видны в innerHTML
					- Все атрибуты элемента можно получить с помощью свойства
						attributes, которое содержит объект типа Attr.
			> В 98% случаев в прикладных JS-скриптах используют атрибуты в виде
				свойств объекта HTMLElement, а не альтернативу.
				Оставшиеся 2% это:
				> Когда нужно получить пользовательский HTML-атрибут, потому что он
					не синхронизирован со свойством.
				> Когда нужно получить именно значение атрибута, потому что в свойстве
					уже совсем не то (href для ссылки) или оно изменилось (value у input).
				> Когда нужно получить список всех атрибутов, включая пользовательские,
					используя коллекцию attributes.
			> Стандартные св-ва и атрибуты синхронизируются (некоторые - в одну
				сторону). Пользовательские - не синхронизируются.
			> В IE<8 и IE8 в режиме совместимости, св-ва и атрибуты смешаны.

		> Доступ к HTML-атрибуту, как к св-ву объекта HTMLElement:
			> Ключевое слово class зарезервировано в javascript, поэтому
				вместо него для этого вида доступа к атрибутам используется
				другое ключевое слово - className:

					var div = document.getElementById('myDiv');
					div.className = 'red';

			> Зато с помощью к.с. class можно получить доступ к атрибуту,
				как к элементу псевдо-массива attributes.
				> Но в IE <= 8 установить класс таким образом не получится.
				> Поэтому вместо этого рекомендуется пользоваться вышеописанным
					методом, используя className.

		> Доступ к HTML-атрибуту, как к элементу объекта attributes:
			> Об attributes:
				> Тип Node определяет свойство attributes, оно ведет себя как массив,
					доступно только для чтения, и представляет все атрибуты элемента.
				> Содержимое attributes и свойства HTMLElement, представляющие атрибуты,
					синхронизируется в обе стороны (в большинстве случаев). Однако, это
					касается только стандартных атрибутов. А пользовательские не
					синхронизируются.
				> attributes имеет значение null для всех узлов, не являютищхся
					объектами Element.
				> В качестве атрибута, псевдо-массив attributes возвращает объект
					Attr, который является потомком объекта Node.
				> Свойства Attr.name и Attr.value возвращают имя и значение атрибута
					соответственно.
				> Пример:

						var div = document.getElementById('myDiv');

						// получить имя и значение всех атрибутов элемента:
						var attrs = div.attributes;
						for(var i=0; i<attrs.length; i++) {
							console.log(attrs[i].name + ' = ' + attrs[i].value);		// 'id = myDiv'
						}

						// установить значение атрибута id элемента div
						console.log(div.attributes[0].name);				// 'id'

			> Для работы с атрибутами в attributes предусмотрены следующие
				методы объекта HTMLElement:
				- getAttribute()			| получить значение атрибута
				- setAttribute()			| установить значение атрибута
				- hasAttribute()			| проверить наличие атрибута
				- removeAttribute()		| удалить атрибут

				> Эти методы прекрасно подходят и для работы как с нестандартными
					атрибутами, так и с data-атрибутами.

				> Примеры:

						// hasAttribute
						var div = document.getElementById('myDiv');
						console.log(div.hasAttribute('id'));				// true
						console.log(div.getAttribute('id'));				// 'myDiv'
						div.setAttribute('class','red');						// устанавливается атрибут, но конкретно класс лучше устанавливать через className (см. выше)

		> Пользовательские атрибуты с данными (data-...)
			> Иногда нужно прикрепить к элементу некоторые дополнительные
				данные. Стандарт HTML5 определяет для этого способ - пользовательские
				'data-...' атрибуты. Они должны:
				- Начинатсья с 'data-'.
				- Имя их должно быть полностью в нижнем регистре.
			> Эти data-атрибуты с данными не оказывают влияния на представление
				элементов, в которых присутствуют, и обеспечивают стандартный способ
				включения дополнительных данных без нарушения стандартов.
			> Как получить доступ к data-атрибутам:
				> Объект Element.dataset
					> Определен стандартом HTML5 (но проверку браузерами надо проверять).
					> Содержит свойства, имена которых соответствуют всем data-атрибутам
						данного элемента, но без приставки 'data-'.
				> С помощью метода getAttribute()

						var myData = element.getAttribute('data-mydata');



	> Доступ к содержимому HTML-элемента

		> Доступ к содержимому можно получить 3-мя способами, как к:
			- строке с HTML-разметкой
			- простому тексту
			- узлу типа Text

		> Доступ к содержимому, как к HTML-строке
			> Осущетсвляется с помощью 3-х методов объекта Element:
				- innerHTML
				- outerHTML
				- insertAdjacentHTML
			> С помощью этих свойств можно как считывать, так и изменять
				HTML-код элемента, включая его содержимое.

		> Доступ к содержимому, как к простому тексту
			> Во всех браузерах, кроме IE, осущетсвляется с помощью
				свойства объекта Node:
				- textContent
			> В IE:
				- innerText
			> Пример:

					var div = document.getElementById('myDiv');
					console.log(div.textContent);								// 'Hello, John!'

					div.textContent = 'Hello, Harry!';
					console.log(div.textContent);								// 'Hello, Harry!'

			> Элементы script без атрибута src имеют свойство text, с помощью
				которого можно получить содержимое этого элемента в виде текста.
				> Если в атрибуте type элемента script сообщить, что элемент не
					содержит исполняемых JS скриптов (передать строку
					"text/x-custom-data"), то в содержимом script можно хранить
					любые данные - ведь элемент будет в дереве DOM, и при этом
					не будет отображаться.

		> Доступ к содержимому, как к узлу типа text
			> Объекты Text, которые являются потомками объекта Node, наследуют
				от него свойство nodeValue, которое и содержит текст текстовых
				узлов.
			> Пример - поиск всех текстовых узлов-потомков указанного элемента

					function textContent(e) {
						var child, type, s = '';			// s хранит текст всех дочерних узлов
						for(child = e.firstChild; child != null; child = child.nextSibling) {
							type = child.nodeType;
							if( type===3 || type===4)		// узлы типов Text и CDATASection
								s += child.nodeValue;
							else if( type===1)					// Рекурсивный обход узлов типа Element
								s += textContent(child);
						}
						return s;
					}


	> Создание, вставка и удаление узлов
		> Создание узлов:
			> Тип Document определяет методы для создания объектов Element.
			> Вот эти методы:
				- createElement		| создать элемент
				- createTextNode	| создать элемент типа Text
				- createComment		| создать элемент типа Comment
				- cloneNode				| копирует указанный элемент и возвращает его
			> Пример:

					var newnode = document.createTextNode('Содержимое текстового узла');

		> Вставка узлов:
			> Тип Node определяет методы для вставки, удаления и замены узлов в дереве.
			> Вот эти методы:
				- appendChild		| вставить новый эл-т как последний дочерний эл-т того эл-та, относительно которого вызван метод
				- insertBefore	| вставить новый узел перед указанным элементов (вызывается относительго его родителя)
			> Пример:

					var newnode = document.createTextNode('Содержимое текстового узла');
					var div = document.getElementById('myDiv');
					div.appendChild(newnode);												// вставилось

		> Удаление и замена узлов:
			> Для удаления узла используют методы:
				- removeChild		| (вызывается у родительского узла) удаляет указанный дочерний узел
				- replaceChild	| (вызывается у родительского узла) удаляет указанный дочерний узел, и заменяет его другим


	> Метрики
		> Когда браузер отображает документ в своем окне, он создает визуальное
			представление документа, в котором каждый элемент имеет определенную
			позицию и размеры.
		> Метрики элемента - это его размеры и положение в документе.
		> Для работы с метриками есть ряд методов, работа с которыми
			описана в "7. Метрики для элементов".




> Управление CSS-стилями

	> Для работы со стилями лучше всего применять какой-нибудь
		JS-фреймворк, вроде jQuery. Потому что:
		- Это удобнее.
		- Во всех браузерах работает одинаково.
		- Даже работает в старых браузерах, т.ч. старых IE.

	> Встроенные и вычисленные стили
		> Есть 2 вида стилей:
			- встроенные
			- вычисленные

	> Отличие встроенных стилей от вычисленных
		> Встроенные стили определяют то, что будет написано в атрибуте
			style элемента. Т.Е. если применить к элементу, как в примерах
			ниже, стили таким способом, то они будут вписаны в виде значений
			в его атрибут style.
			> Встроенные стили не отражают всех примененных к элементу стилей,
				а отражают только то, что находится в значении его атрибута style.
		> А вот вычисленные стили отражают все CSS-стили, примененные к
			элементу.

	> Встроенные стили
		> Свойство style объекта Element определяет встроенный стиль элемента.
		> В style лежит объект CSSStyleDeclaration.
		> Свойства этого объекта имют почти те же имена, что CSS-свойства.
			> Если значение свойство - пустая строка "" - значит это свойство
				не применяется. Поэтому чтобы сбросить какой-то стиль, надо
				просто записать в него пустую строку:

					document.body.style.backgroundColor = '#444';		// установил серый фон
					document.body.style.backgroundColor = '';				// убрал установленный выше стиль

		> Некоторые имена свойств в объекте CSSStyleDeclaration отличаются
			от соответствующих им имен CSS-свойств:
			- имена св-в в style не могут содержать дефисов, потому что JS
				воспринимает их, как минусы; поэтому все CSS-свойства с дефисами
				в имени заменены по следующему принципу:

					font-size заменен на fontSize
					font-weight заменен на fontWeight
					... и т.д.

			- ключевое слово class уже зарезервировано в JS, поэтому вместо
				него используется className

		> При установке стиля таким образом, всегда надо передавать значение
			в виде строки, и добавлять единицы измерения:

				var div = document.getElementById('myDiv');
				div.style.backgroundColor = '#678';
				div.style.color = '#fff';
				div.style.width = '400px';
				div.style.height = '200px';

		> Свойству style нельзя просто присвоить строку со стилями. Однако,
			можно её присвоить свойству style.cssText - и задать таким образом
			стиль для элемента целиком.
			> Минус в том, что эта новая строка полностью затирает старую
				строку-значение атрибута style элемента.
			> Пример:

					var div = document.getElementById('myDiv');
					div.style.cssText = 'color: #fff; background-color: #888;\
						width: 800px; height: 400px';



	> Вычисленные стили
		> Когда требуется узнать фактически примененные к элементу стили,
			то надо использовать вычисленные стили. Они отражают все примененные
			к элементу стили, со всех уровней.
		> Вычисленные стили, как и встроенные, представлены объектом
			CSSStyleDeclaration.
		> Отличия объекта CSSStyleDeclaration у вычисленных стилей от аналогичного
			объекта у встроенных стелй:
			- Вычисленные стили, в отличие от встроенных, доступны только для чтения.
			- Свойства, являющиеся краткой формой записи, не вычисляются - только
				фундаментальные свойства. Т.Е. для получения правильного значения требуется указать именно
				полное значение свойство, вроде paddingLeft, а не сокращенное,
				вроде padding, потому что в последнем случае результа не гарантирован.
			- Свойство cssText вычисленного стиля не определено.
		> Получить вычисленный стиль элемента можно методом
			Window.getComputedStyle().
			> Поддерживается всеми браузерами, кроме IE<=8.
			> Пример:

				var div = document.getElementById('myDiv');
				var s = window.getComputedStyle(div, null);

				console.log(s.height);			// '18px'


	> Управление стилями через классы
		> Вместо прямого управления стилями элемента, можно просто изменить
			набор CSS-классов, которые к нему применяются.
		> Задать элементу строку с классами можно через его свойство
			className.
			> При этом можно задавать сколько угодно классов через пробел,
				как обычно это делается в css в атрибуте class.
			> Новая строка с классами полностью затрет старую.

				var div = document.getElementById('myDiv');
				div.className = 'red textWhite';




> Обработка событий

	> Общая информация
		> Клиентские JS-программы основаны на модели программирования, когда
			выполнение программы управляется событиями.
		> Браузер генерирует какое-нибудь событие, когда что-нибудь происходит.
		> Есть много видов событий. Часть из них,
			> На данный момент не существует стандарта, который определял бы
				полный набор событий. Их кол-во продолжает быстро пополняться,
				из следующих 3-х источников:
				- Спецификация "DOM Level 3 Events", которая после долгих лет застоя
					стала активно разрабатываться под эгидой консорциума W3C.
				- Прикладные интерфейсы в HTML5 и связанных с ним доп. спецификациях,
					определяют новые события, связанные с управлением историй посещений,
					drag-and-drop, обмена сообщениями между документами и проигрывания
					аудио- и видеороликов.
				- События, которые появились в связи с появлением мобильных устройств
					с сенсорными экранами.
		> С помощью JS можно зарегистрировать 1 или более обработчиков для
			одного события.
			> Обработчик события - это JS-код, в т.ч. это может быть функция,
				который выполняется, когда происходит данное событие.

	> Определимся с терминами
		> Событие - проишествие, о котором браузер извещает JS-скрипт.
		> Тип события - это строка, которая содержит имя события. По этому
			имени можно понять, что же за событие произошло.
		> Цель события - это объект, в котором возникло событие, или с которым
			это событие связано.
		> Обработчик события - это JS-код, в т.ч. это может быть функция,
			который выполняется, когда происходит данное событие.
		> Объект Event - связан с определенным событием и содержит информацию
			об этом событии.
		> Распространение события
			> Когда событие вызвано для некоторого объекта, то:
				> Если "всплытие" в объекте Event включено, событие будет "всплывать"
					вверх по дереву - оно будет доставлено последовательно всем предкам
					этого элемента.
				> А если "всплытие" выключено, то событие будет доставлено только
					объекту, для которого оно вызвано.
			> Настроить, будет ли "всплывать" событие, или нет, можно в объекте
				Event.
		> Для некоторых событий предусмотрены "действия по умолчанию". Например,
			для события "click", возникающего в гиперссылке, по умолчанию
			предусматривается операция перехода по ссылке и загрузки новой
			страницы. Обработчики могут предотсратить выполнение действий по умолчанию.

	> Справочник событий находится по следующему адресу
			"Справочник HTML" -> "13. Атрибуты-события в HTML"

	> Регистрация и удаление обработчиков событий

		> Есть 2 основных способа регистрировать обработчики событий
			из JS-кода:
			- Установить атрибут-событие в виде свойства HTML-элемента
			- С помощью ф-ий addEventListener() и attachEvent() для IE<=8

		> Установить атрибут-событие в виде свойства целевого объекта.
			> Производится установка атрибута-события элементу по методике,
				которая была описана выше (для работы с атрибутами).
			> Нужно присвоить свойству целевого объекта функцию-обработчик
				события.
			> Имя свойства должно совпадать с именем события с префиксом 'on-'.
			 	Например, для события click имя должно быть onclick, и т.д.
			 	См. справочник по ссылке выше.
			> Пример - сделать так, чтобы при каждом клике в консоль
				выводилась надпись "Hello, world".

					window.onclick = function() {
						console.log('Hello, world!');
					};

		> Регистрация и удаление события методами addEventListener / removeEventListener
			> В стандартной модели событий, поддерживаемой всеми браузерами,
				кроме IE <= 8, целью события может быть любой элемент - включая
				объекты Window и Document, и все объекты Elements.
			> Метод addEventListener определен в объекте Elements. Может
				зарегистрировать для указанного типа события указанную функцию-
				обработчик.
			> Не работает в IE <= 8, там вместо addEventListener метод
				attachEvent()
			> Пример - зарегистрировать для одного и того же события click
				2-мя разными методами 2 обработчика:

					window.onclick = function() {
						console.log('Hello, world!');								// 'Hello, world!'
					};

					window.addEventListener('click', function(){
						console.log('Hello again, world!');					// 'Hello again, world!'
					});

					window.addEventListener('click', function(){
						console.log('Hello again 2, world!');				// 'Hello again 2, world!'
					});

				> Теперь при щелчке мыши по окну браузера, в консоли возникает
					3 надписи.
				> Фишка метода addEventListener(), что для одного и того же
					события можно зарегистрировать сколько угодно обработчиков,
					что иллюстрирует пример выше.
					> При появлении события в объекте, будут вызваны все зарегистрированные
						под это событие обработчики, в порядке их регистрации.

			> С помощью метода removeEventListener можно удалить обработчик
				события из объекта.


	> Вызов функции-обработчиков событий

		> Общая информация
			> Некоторые механизмы отличаются в IE <= 8 и других браузерах.

		> Аргумент функции-обработчика событий
			> При вызове обработчика событий, ему передается 1 аргумент -
				объект Event, содержащий дополнительную информацию о событии:

				Посмотрим, что внутри этого объекта Event:
				-----
					var handler = function(event) {
						console.log(event);						// MouseEvent { ... }
					};
					window.onclick = handler;

				А внутри переданного объекта Event несколько десятков свойств,
				в данном случае, для события типа click:
					- Все виды координат курсора во время клика.
					- Тип события (type: 'click')
					- Timestamp - время, когда произошло событие
					- Был ли нажат CTRL, ALT или SHIFT при щелчке мыши
					- ... и так далее.

			> В IE<=8, для событий, зарегистрированных установкой свойства,
				объект Event в функцию-обработчик не передается. А вместо
				этого сохраняется в глобальной переменной window.event. Поэтому,
				чтобы функция-обработчик была совместима с IE<=8 её надо писать
				по такому шаблону:

					var handler = function(event) {
						event = event || window.event;
						...
					};

		> Контекст функции-обработчика событий
			> Во всех браузерах кроме IE<=8, в обработчиках событий, зарегистрированные
				любым способом - установкой свойства или функцией addEventListener() -
				ключевое слово this содержит ссылку на целевой объект:

					var handler = function(event) {
						console.log(this);
					};
					document.body.onclick = handler;	// HTMLElement body

			> В IE<=8 обработчики, зарегистрированные с помощью метода attachEvent()
				имеют в ключевом слове this ссылку на глобальный объект Window.
				> Эту проблему можно решить, вызывая функцию-обработчик с помощью
					call в контексте целевого объекта. Ниже приведена универсальная
					функция, которая подходит для всех браузеров, включая IE<=8:

						var addevent = function(target, type, handler) {
							if(target.addEventListener) {
								target.addEventListener(type, handler, false);
							} else {
								target.attachEvent('on' + type,
									function(event) {
										return handler.call(target,event);
									});
							}
						};

					> Минус этой функции в том, что такое событие нельзя будет
						удалить, потому что ссылка на функцию-обертку, передаваемую
						методу attachEvent нигде не сохраняется, чтобы можно было
						передать ее методу detachEvent().

		> Область видимости функции-обработчика событий
			> Область видимости функции-обработчика событий зависит от того,
				как он был зарегистрирован:

				> С помощью установки атрибута-события в виде свойства HTML-элемента
					> Областью видимости будет глобальная область видимости объекта
						Window, потому что определяя функцию-обработчик этим способом,
						ты фактически создаешь новый метод объекта Window.
					> Однако, это еще не все. По историческим причинам, такие обработчики
						выполняются в модифицированной области видимости - могут
						использовать свойства:
						- Целевого объекта
						- Объемлющего объекта <form>
						- Объекта Document

				> С помощью ф-ий addEventListener() и attachEvent() для IE<=8
			 	 	> Областью видимоси будет так, в которой обработчики событий
			 	 		определены.

		> Возвращаемые значения обработчиков
			> Значение, которое возвращает функция-обработчик событий с помощью
				оператора return имеет разное значение, в зависимости от того,
				как был зарегистрирован обработчик:

				> С помощью установки атрибута-события в виде свойства HTML-элемента
					> Если обработчик вернет false - сообщить браузеру, что он не должен выполнять действия,
						предусмотренные для этого события по умолчанию.
						> Например, обработчик onclick кнопки отправки формы может вернуть
							false, чтобы предотвратить отправку формы браузером.
						> Еще пример - обработчик события onkeypress поля ввода может
							фильтровать ввод с клавиатуры, возвращая false при вводе
							недопустимых символов.
					> В некоторых случаях обработчик может вернуть строку:
						> Например, обработчик onbeforeunload (событие, которое генерируется
							перед закрытием окна) может вернуть строку, и эта строка будет
							выведена в модальном диалоговом окне, предлагающем пользователю
							подтвердить свое желание покинуть страницу (этим часто злоупотребляют
							всякие горе-сетевеки-инфобизнесмены).

							Пример ниже при попытке закрыть окно выведет модельное окно
							с текстом, который вернула функция-обработчик:

								var handler = function() {
									return '*********************************************************\r\n'+
									'Вы точно уверены, что не хотите купить мой супер-пупер-курс!??!?!\n\r'+
									'*********************************************************';
								};
								window.onbeforeunload = handler;

				> С помощью ф-ий addEventListener() и attachEvent() для IE<=8
					> Возвращаемые оператором return значения не учитываются.
					> Для выше описанных целей, в этом случае требуется вызывать
						метод preventDefault() или устанавливать свойство returnValue.
						> Внимание! returnValue устарел, поэтому вместо него надо
							использовать соответствующий стандарту preventDefault().

		> Порядок вызова нескольких обработчиков 1-го события
			> Для объекта можно зарегистрировать > 1 обработчика одного и того же
				события. Браузер будет вызывать их в порядке, определяемом следующими
				правилами:
				- В первую очередь вызываются обработчики, зарегистрированные установкой
					свойства объекта или с помощью HTML-атрибута.
				- Затем вызываются обработчики, зарегистрированные с помощью метода
					addEventListener() - в порядке их регистрации.
				- Обработчики, зарегистрированные с помощью метода attachEvent()
					могут вызываться в произвольном порядке, поэтому скрипт не должен
					полагаться на какой-то определенный порядок.

		> Распространение событий

			> О способности событий "всплывать" вверх по дереву DOM
				> После вызова обработчика событий, зарегистрированного в целевом
					элементе, большинство событий "всплывают" вверх по дереву DOM.
					В результате вызываются обработчики в родителе целевого элемента,
					затем в родителе родителя целевого элемента. Так продолжается, пока
					не будет достигнут объект Document и затем объект Window.
				> Это сделали, чтобы облегчить разработчикам жизнь. Например,
					в форме могут быть десятки элементов. И чтобы не регистрировать
					для них десятки обработчиков событий, можно зарегистрировать
					только 1 - для элемента form.
				> Способностью всплывать обладат большинство событий, но есть исключения:
					- События focus, blur и scroll не всплывают.
					- Событие load, возникающее в элемента всплывает, но только
						до Document, а не до Window. А в Window событие load возбуждается,
						только когда будет полностью загружен весь документ.

			> 3 фазы распространения событий:

				Фаза №1 - перехват.
					> Фаза перехвата напоминает фазу всплытия, только распространяется
						в обратном направлении. В первую очередь вызываются перехватывающие
						обработчики объекта Window, затем перехватывающие обработчики объекта
						Document, затем body и так далее вниз по дереву DOM. Перехватывающие
						обработчики, зарегистрированные в самом целевом объекте не вызываются.
					> Фаза перехвата недоступна для IE<=8.
					> В фазе перехвата участвуют только события, зарегистрированные
						с помощью функции addEventListener().

				Фаза №2 - возбуждение.
					> Вызов обработчика событий в целевом объекте.

				Фаза №3 - всплытие.
					> Описание см. выше.

		> Отмена событий

			> Отмена выполнения действий "по умолчанию"
				> Если событие зарегистрировано, как свойство объекте, или как
					HTML-атрибут, то чтобы отменить выполнение действия, выполняемые
					браузером по умолчанию в случае возникновения этого события,
					можно просто вернуть из функции-обработчика значение false.
				> Если событие зарегистрировано методом addEventListener(),
					то для отмены действий браузера по умолчанию, нужно
					воппользоваться методом preventDefault() объекта-события:

						var handler = function(event) {
							var event = event || window.event;  // для IE<=8

							// здесь выполняется обработка события

							// отменить действие по умолчанию, связанное с событием
							if(event.preventDefault)
								event.preventDefault();	// для всех браузеров, кроме IE<=8

							if(event.returnValue)
								event.returnValue();		// для IE<=8
						};

			> Остановка распространения события
				> Остановить дальнейшее распространение события по дереву DOM
					можно вызвав в обработчике события метод
					Event.stopPropagation().
				> Если в том же целевом объекте были зарегистрированые другие
					обработчики того же самого события, то они все равно будут
					выполнены, даже если 1 или более из них применили вышеуказанный
					метод.
				> Этот метод действует во всех 3 фазах распространения события.
				> В IE<=8 stopPropagation не поддерживается. Вместо этого у объекте
					события Event есть свойство cancelBubble. По умолчанию его значение
					false, но если установить true, то это предотвратит распространение
					события.
				> Есть также метод Event.stopImmediatePropagation().
					> Он делает тоже самое, что stopPropagation, но только вот остальные
						обработчики этого же события в целевом объекте уже не вызываются.
					> Он пока плохо поддерживается, но в некоторыых библиотеках, таких
						как jQuery, определена собственная кроссплатформенная версия
						этого метода.

	> События мыши, буксировка HTML-элементов

		> О событиях мыши
			> Полный список событий мыши ты можешь увидеть по адресу:
				'HTML 5' -> 'Справочник HTML' -> '13. Атрибуты-события'
			> Событие contextmenu
				> Это событие возбуждается при щелчке правок кнопкой мыши в окне
					браузера, и его действие по умолчанию - вызов контекстного меню.
				> Его действие по умолчанию можно отменить, и запрограммировать ему
					друго действие. Но некоторые браузера имеют настройки, которые
					делают это событие не перепрограммируемым.
			> Функции-обработчику события мыши передается объект MouseEvent,
				который содержит очень много разнообразных свойств. Вот пример
				нескольких из них:

					document.onclick  =function(e) {
						console.log(e.clientX);				// клиентские координаты X курсора во время наступления события
						console.log(e.clientY);				// клиентские координаты Y курсора во время наступления события
						console.log(e.altKey);				// true/false - был ли зажат alt во время события
						console.log(e.ctrlKey);				// true/false - был ли зажат ctrl во время события
						console.log(e.shiftKey);			// true/false - был ли зажат shift во время события
						console.log(e.button);
					};

			> Св-во button определяет, какая кнопка мыши удерживалась в нажатом
				состоянии в момент события. Но разные браузеры записывают в это
				св-во разные значения, поэтому его трудно использовать кроссбраузерно.
			> Некоторые браузера возбуждают событие click только в случае щелчка
				левой кнопкой мыши. Поэтому, если потребуется обрабатывать щелчки
				другими кнопками, следует использовать события "mousedown" и "mouseup".

		> Кроссбраузерный пример буксировки элементов мышью
			> С помощью событий мыши можно организовать возможность пользователю
				буксировать перетаскиванием мышью элементы с position: absolute
				в произвольное место.
			> Живой рабочий пример буксировки элемента мышью можно посмотреть
				по следующему адресу:

					3. JavaScript ->
					0. Practical samples and techniques ->
					9. Drag of absolute HTML-element

	> События drag-and-drop (...статья требует завершения...)
		> Drag-and-drop - DnD - интерфейс взаимодействия с пользователем,
		 	позволяющий перемещать данные между "источником" и "приемником", которые
		 	могут находиться в одном или разных приложениях.








> AJAX - работа с протоколом HTTP

	> Общая информация

		> Javascript способен работать с протоколом HTTP.
			> Например, когда JS-скрипт устанавливает значение св-ва Window.location,
				или вызывает метод submit() объекте Form, посылается HTTP-запрос, и
				браузер открывает новое окно.
			> Но в этом разделе будет рассматриваться иное взаимодействие -
				взаимодействие JS-кода с веб-сервером, при котором браузер не
				перезагружает содержимое окна или фрейма..

		> Что такое AJAX
			> AJAX - Asynchronous Javascript And XML - асинхрнонный JS и XML.
		    Термин AJAX описывает архитектуру веб-приложений, отличительной
		    чертой которых является работа с протоколом HTTP.
		  > Ключевой особенностью AJAX-приложения является использование
		    протокола HTTP для инициации обмена данными с веб-сервером без
		    необходимости перезагружать страницу.
		  > Название "AJAX" предложит Jesse James Garret в 2005 году.
		  > Примеры AJAX приложений:
				- Голосование без перезагрузки страницы.
				- Подписка без перезагрузки страницы.
				- AJAX-корзина в интернет-магазине
				- Динамическая подргузка данных. Например, дерево.
				- Живой поиск - как в гугле или яндексе.

		> Что такое Comet
			> Comet - архитектура, похожая на AJAX, но в которой не клиент, а
				сервер инициирует взаимодействие, асинхронно отсылая сообщения
				клиенту.
			> Отличие AJAX от Comet
				> В архитектуре AJAX клиент "вытягивает" данные с сервера.
				> В архитектуре Comet сервер "навязывает" данные клиенту.
				> Условно говоря, AJAX - это "нажал на кнопку - получил результат",
					а Comet - "сижу и наблюдаю за результатами".
			> Название "Comet" предложил Alex Russel. Вероятно, Алекс хотел
				обыграть термин AJAX - дело в том, что в США Comet и AJAX являются
				названиями чистящих средств.
			> Примеры Comet приложений:
				- Чат - сидишь и смотришь, что пишут другие.
				- Аукцион - сидишь и смотришь, как обновляется ставка на товар.
				- Совместное редактирование - как в гугл документе
				- В системе управления бизнесом - сотрудник сидит и наблюдает, как у
					него в ЛК появляются новые задания. Или менеджер сидит и наблюдает,
					как развивается выполнение экземпляра процесса.

		> Транспорты
			> Есть много способов реализации архитектур AJAX и COMET, и эти
				базовые реализации иногда называют транспортами.
			> Таблицу транспортов и их возможностей можно посмотреть здесь:
					http://learn.javascript.ru/ajax-summary

		> О передаче данных из JS в PHP с помощью AJAX
			> Часто требуется передать данные из JS-скрипта на сервер в PHP-скрипт
				с помощью AJAX. Этот процесс требует от исполнителя прозрачного
				понимания некоторых тонкостей работы AJAX. Иначе можно надолго
				застрять.
			> Главная тонкость здесь состоит в следующем. Обычно программист
				открывает в браузере p.php и j.js. И ждет, что сейчас выполнится
				AJAX-запрос, и в p.php на экран будет выведены данные, переданные
				AJAX-запросом. Однако этого не происходит, потому что в этой
				ситуации присутствуют 2 разных запроса к файлу p.php:

					№1 Запрос от браузера - это то окно, в котором программист
						 открыл p.php.
					№2 AJAX-запрос от j.js

				Ошибка программиста в том, что он пытается получить в запросе
				№1 данные, которые были переданы в запросе №2. Которые, естественно,
				не сохранились между запросами.
			> Специально для решения вышеуказанной проблемы есть механизм сессий.
				Архитектура решения выглядит так:

					добавим в p.php этот код:
					- если в текущем потоке массив $_POST содержит данные, значит
						это запрос №2 (от AJAX), и нужно сохранить данные в сессии.
					- если в текущем потоке массив $_POST не содержит данных, значит
						это запрос не от AJAX. Если наша сессионная переменная пуста,
						значит запроса от AJAX еще небыло, и выводить ничего не надо.
						А если не пуста, то можно вывести на экран результат.


						if(!empty($_POST)) {

							session_start();
								$_SESSION['result'] = $HTTP_RAW_POST_DATA;
							session_write_close();

						} else {

							session_start();
								if(!empty($_SESSION['result']))
									echo $_SESSION['result'];
							session_write_close();

						}

			> Разумеется, приведенный выше пример нужен в ситуациях, вроде той,
				когда нужно в пользовательском запросе к p.php получит данные,
				переданные из j.js с помощью AJAX. А если, например, надо передать
				эти данные в СУБД, то это можно просто выполнить в p.php прямо
				во время AJAX-запроса.


	> Использование объекта XMLHttpRequest

		> Общая информация
			> Прикладной интерфейс в браузерах определяется в виде класса
				XMLHttpRequest.
			> XMLHttpRequest используется браузерами достаточно давно,
				а его прикладной интерфейс находится на последних стадиях
				стандартизации консорциумом W3C. В то же время уже ведутся
				работы над проектом стандарта "XMLHttpRequest Level 2".
			> Для работы с XMLHttpRequest потребуется веб-сервер.
			> Каждый экземпляр класса XMLHttpRequest представляет единственную
				пару запрос/ответ, а свойства и методы объекта позволяют определять
				параметры запроса и извлекать данные из ответа.
				> HTTP-запрос состоит и 4 частей:
					- метод HTTP-запроса или тип "операции"
					- запрашиваемый URL-адрес
					- необязательные заголовки запроса, которые могут включать
						информацию для аутентификации
					- необязательное тело запроса
				> HTTP-ответ состоит из 3 частей:
					- числово и текстовое значение, определяющее код состояния,
						указывающий на успех или ошибку
					- набор заголовков ответа
					- тело ответа
			> Поддержка современного стандарт XMLHttpRequest появилась в
				IE>=7, так что по этому поводу можно не беспокоиться.


		> Выполнение HTTP-запроса
			> Состоит из 4-х этапов, которые должны происходить
				именно в порядке, приведенном ниже.

			> Этап 1 - создать объект XMLHttpRequest
				> Перед выполнением запроса надо создать новый экземпляр объекта
					XMLHttpRequest:

						var request = new XMLHttpRequest();

			> Этап 2 - задать запросу HTTP-метод и целевой URL
				> Сделать это методом XMLHttpRequest.open():

					request.open('GET','http://google.com');

				> Спецификация XMLHttpRequest поддерживает следующие HTTP-методы
					запроса:
					- GET
					- POST
					- HEAD
					- ... и другие, не особо нужные (DELETE, OPTIONS, PUT).

			> Этап 3 - установка заголовков запроса (если необходимо)

					request.setRequestHeader('myHeader1', 'myValue1');
					request.setRequestHeader('myHeader2', 'myValue2');
					...

				> Причем нельзя передать собственные значения перечисленным ниже
					заголовкам, объект XMLHttpRequest добавляет их автоматически,
					и не позволяет их подделать:
					- Content-Length
					- Date
					- Referer
					- User-Agent
				> Кроме того, объект XMLHttpRequest автоматически обрабатывает
					cookies, срок поддержки открытого соединения, определяет
					кодировку символов и выполняет кодирование сообщений, поэтому
					не следует передавать методу setRequestHeader следующие
					заголовки:
						Accept-Charset		Content-Transfer-Encofing		TE
						Accept-Encoding		Date												Trailer
						Connection				Expect											Transfer-Encoding
						Content-Length		Host												Upgrade
						Cookie						Keep												User-Agent
						Cookie2						Referer											Via

			>	Этап 4 - передача необязательного тела запроса и отправка его серверу

					request.send(null);

				> GET-запросы не имеют тела. В этом случае можно передать методу
					значение null или вообще опустить этот аргумент.
				> POST-запросы обычно имеют тело, и они должны соответствовать
					заголовку Content-Type, установленному с помощью метода
					setRequestHeader().

			> Пример выполнения HTTP-запроса к серверу с помощью XMLHttpRequest.
				> Этот пример выполняет HTTP-запрос методом POST к серверу, и
					посылает простое текстовое сообщение msg.

						var postMessage = function(msg) {
							var request = new XMLHttpRequest();
							request.open('POST', '/log.php');
							request.setRequestHeader('Content-Type',
																			 'text/plain;charset=UTF-8');
							request.send(msg);
						};


		> Получение HTTP-ответа
			> Общая информация
				> Полный HTTP-ответ содержит:
					- Код состояния
					- Набор заголовков ответа
					- Тело ответа

				> Весь HTTP-ответ доступен в виде свойств и методов объекта
					XMLHttpRequest:
					- status								| код состояния   (например: 404)
					- statusText						| текст состояния (например: 'Not Found')
					- getResponceHeader()		| получить заголовок ответа
					- AllResponceHeader()		| получить все заголовки ответа
						> Причем обработка cookies выполняется объектом XMLHttpRequest
							автоматически: он исключает загловки 'Cookie' из множества,
							возвращаемго этим методом. И возвращает null, если передать
							аргумент 'Set-Cookie' или 'Set-Cookie2' методу getResponseHeader().
					- responseText					| тело ответа в текстовом виде
					- responseXML						| тело ответа в виде объекта Document

				> HTTP-ответ бывает асинхронный и синхронный
					> Ответ от сервера может быть:
						- Асинхронным
						- Синхронным
					> Какой будет ответ - можно настроить с помощью 3-го аргумента
						функции open() - если перадать false, то будет синхронный, если
						не передавать ничего - асинхронный
					> Обработка асинхронного и синхронного HTTP-ответов отличаются,
						и рассмотрены ниже.

			> Обработка асинхронного HTTP-ответа
				> По умолчанию отправка HTTP-запроса происходит в асинхронном
					режиме.
				> Управление тем, в асинхронном/синхронном режиме будет отправка
					осуществляется, как описано выше.
				> Методы и свойства объекта XMLHttpRequest ничего не содержат до
					тех пор, пока фактически не поступит ответ от сервера.
				> Поймать момент, в который поступил ответ, помогут:
					- событие readystatechange, возбуждаемое в объекте XMLHttpRequest
					- свойство XMLHttpRequest.readyState - отражающее состояние запроса
				> Подробнее о свойстве XMLHttpRequest.readyState
					> Может иметь одно из 5 значений-чисел:
						- 0		| метод open() еще не был вызван
						- 1		| метод open() был вызван
						- 2		| были получены заголовки
						- 3		| идет прием тела ответа
						- 4		| прием ответа завершен
				> Подробнее о событии readystatechange
					> Теоретически, оно должно возбуждаться при каждой смене значения
						свойства readyState.
					> На практике, разные браузеры могут возбуждать его когда им вздумается,
						но все они возбуждают его еще и тогда, когда завершен прием
						ответа сервера и свойство readyState получает значение 4.
					> Поэтому проще всего поймать нужный момент так: ловить обработчиком
						все возбуждаемые события, но внутри него определить проверку -
						содержит ли уже свойство readyState значение 4, или нет.
				> Пример обработки асинхронного HTTP-ответа от сервера с
					помощью XMLHttpRequest:

						var getText = function(url, callback) {
							var request = new XMLHttpRequest();
							request.open('GET', url);

							request.onreadystatechange = function() {
								if(request.readyState === 4 && request.status === 200) {
									var type = request.getResponseHeader('Content-Type');
									if(type.match(/^text/))
										callback(request.responseText);		// передать тело ответа функции callback
								}
							};

							request.send(null);
						};


				> Пример отправки/обработки асинхронного HTTP-запроса см. здесь:
					'0. Practical samples and techniques' ->
					'1. Simple async AJAX sample'


			> Обработка синхронного HTTP-ответа
				> Если в 3-м аргументе передать методу open() значение false,
					то выполнение метода send() будет заблокировано до завершения
					запроса.
				> В этом случае отпадает необходимость использовать обработчик
					события - после того, как метод send вернет управление, можно
					будет сразу же проверить свойства status и responseText
					объект XMLHttpRequest.
				> Пример обработки синхронного HTTP-ответа от сервера с
					помощью XMLHttpRequest:

						var getTextSync = function(url) {
							var request = new XMLHttpRequest();
							request.open('GET', url, false);
							request.send();

							return request.responseText;
						};

				> Однако, синхронные запросы лучше использовать только в особых
					случаях.
					> Их минус  в том, что интерпретатор JS на стороне клиента
						выполняется в единственном потоке, и когда метод send забирает
						и не отдает управление, пока не получит ответ, это обычно
						приводит к зависанию пользовательского интерфейса всего браузера.

				> Пример отправки/обработки синхронного HTTP-запроса см. по
					адресу ниже. В нем как раз демонстрируется это "зависание",
					о котором написано выше:
					'0. Practical samples and techniques' ->
					'1. Simple async AJAX sample'


			> Оформление ответа сервера

				> Что можно и нельзя посылать серверу в ответ на запрос JS-скрипта:
					> Сервер в ответ на запрос от JS-скрипта может послать:
						- Строку (в т.ч. сериализованный массив или объект)
					> Сервер в ответ на запрос от JS НЕ может послать:
						- Двоичный код (например, картинку).

				> Сериализация массивов и строк
					> Сервер перед отправкой массива или объекта может сериализовать
						их - т.е. превратить в строку.
					> Удобнее всего это в данном случае делать с помощью JSON.

				> JS не понимает двоичный код.
					> Поэтому, если отправить ему с
						сервера какой-нибудь двоичный код (например, изображение),
						то корректно его обработать не получится.
					> Однако, есть ряд костылей, как все таки обходить это
						ограничение. См. здесь:
						http://stackoverflow.com/questions/4285042/can-jquery-ajax-load-image

				> О важности правильности MIME-типа
					> Для корректного декодирования ответа необходимо, чтобы сервер
						отправлят в ответе заголовок "Content-Type" с правильным значением
						MIME-типа ответа.
					> Если сервер укажет неправильный тип данных, то JS не сможет
						правильно обработать ответ.
					> Если сервер укажет не правильную кодировку в charset, то
						ответ будет декодирован с помощью неправильной кодировки,
						и получатся кракозябры.
					> Можно заставить JS-скрипт проигнорировать загловок "Content-Type"
						из ответа сервера, и самому установить его. Для этого можно использовать
						новый метод overrideMimeType() из готовящейся спецификации XHR2.
						Его нужно применить к объекту XMLHttpRequest до метода send().
						> Он новый, и может поддерживаться не всеми браузерами!
						> Пример:

								request.overrideMimeType('text/plain; charset=utf-8');


		> Оформление тела запроса (при запросах методом POST)

			> Общая информация
				> Запросы HTTP POST, в отличие от HTTP GET, включают тело запроса,
					которое содержит данные, передаваемые клиентом серверу.
				> Данные в теле запроса можно передавать разные, и в этом
					пункте как раз и описывется, какие данные как надо оформлять
					при передаче.
				> В зависимости от формата данных, можно выбирать и метод передачи:
					- POST / GET: 		данные в URL-формате
					- 99% POST / GET: данные в JSON-формате передаются в 99% случаев методом POST
					- POST: 					различные файлы целесообразно передавать только методом POST

			> Передача данных в формате URLEncoded HTML-форм

				> Как это происходит в нескольких словах:
					> Производится передача данных в виде строки, закодированной в
						формате URL encoding.
						> Подробнее об этом здесь:
								http://www.w3schools.com/tags/ref_urlencode.asp
					> К запросу прикрепляется HTTP-заголовок 'Content-Type', указывающий
						на то, что данные поступят в URL-encoded формате:

							application/x-www-form-urlencoded

					> Сервер получает запрос, видит заголовок, парсит полученную строку
						соответствующим образом, и размещает результаты в суперглобальном
						массиве $_POST / $_GET (в зависимости от метода запроса).
					> Данные таким образом могут быть переданы как методом POST,
						так и методом GET.

				> Как это происходит - подробнее:
					> По умолчанию, отправка производится HTTP-методом POST.
					> Имена и значения всех элементов формы упаковываются в
						1 строку, и эта строка отравляется на сервер в теле
						запроса.
					> Схема преобразования данных формы в строку такова:
						- К имени и значению каждого элемента формы применяется обычное
							URI-кодирование (замена спец. символов 16-ричными кодами).
						- В паре имя/значений имя отделено от значения символом =
						- Отдельные пары имя/значени отделены друг от друга символом &
					> Пример того, как могут выглядть упакованные в строку имена
						и значения всех элементов формы:

							'find=pizza&zipcode=02134&radius=1km'

					> Такой формат представления данных формы соответствует формальному
						MIME-типу:

							'application/x-www-form-urlencoded'

						> Этот тип следует указать в заголовке Content-Type запроса
							при отправке данных такого вида в теле запроса матодом POST.

					> Для отправки данных в вышеуказанном формате не требуется
						наличие HTML-форм.

				> Пример передачи данных в URLEncoded формате методом POST
					> Чаще всего в AJAX-приложениях будет иметься некоторый JS-объект,
						который необходимо отправить на сервер. Т.Е. по сути необходимо
						передать на сервер все собственные свойства этого объекта с их
						значениями, проигнорировав методы и унаследованные свойства.
						Ниже пример того, как это делается:

					> Допустим, надо передать следующий объект:

							var data = {
								name: 'John',
								age: '22',
								gender: 'male'
							};

					> Сначала преобразуем его в формат для отправки на сервер в теле
						HTTP-запроса POST (функция для преобразования):

							encodeFormData = function(data) {
								if(!data) return '';
								var pairs = [];

								for(var name in data) {
									if(!data.hasOwnProperty(name)) continue;
									if(typeof data[name] === 'function') continue;

									var value = data[name].toString();
									name = encodeURIComponent(name.replace('%20', '+'));
									value = encodeURIComponent(value.replace('%20', '+'));
									pairs.push(name+'='+value);
								}
								return pairs.join('&');
							};

					> Теперь можно отправлять HTTP-запрос POST, поместив в его
					 	тело наш объект. Здесь мы отправим асинхронный запрос:

							Подготовка запроса
							-----
								var request = new XMLHttpRequest();
								request.open('POST', 'phpfile.php');

							Подготовка обработчика событий
							-----
								request.onreadystatechange = function() {

									if(request.readyState === 4 && request.status === 200) {
										console.log(request.responseText);
									}

								};

							Подготовка заголовка с правильным MIME-типом
							-----
								request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');

							Отправка запроса
							-----
								request.send(encodeFormData(data));

					> Ссылка на рабочий пример:
						'3. Javascript' ->
				 		'0. Practical samples and techniques' ->
				 		'4. AJAX - send object to server (POST)'

				> Пример передачи данных в URLEncoded формате методом GET

					> Вообще, можно отправить информацию на сервер и GET-запросом.
						У него нет тела, поэтому "полезный груз" отправляется в составе
						URL-адреса - в виде query string, которая идет после знака
						вопроса. Вот как отправить такой запрос:

							Подготовка запроса и "полезного груза" в виже query string
							-----
								var request = new XMLHttpRequest();
								request.open('GET', 'phpfile.php' +
																		'?' + encodeFormData(data));

							Подготовка обработчика событий
							-----
								request.onreadystatechange = function() {

									if(request.readyState === 4 && request.status === 200) {
										console.log(request.responseText);
									}

								};

							Подготовка заголовка с правильным MIME-типом
							-----
								request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');

							Отправка запроса
							-----
								request.send();

					> Ссылка на рабочий пример:
						'3. Javascript' ->
				 		'0. Practical samples and techniques' ->
				 		'3. AJAX - send object to server (GET)'


			> Передача данных в формате JSON

				> Как это происходит в нескольких словах:
					> Производится передача данных в виде строки, закодированной в
						формате JSON. Подробнее об этом здесь:
							http://learn.javascript.ru/json
					> К запросу прикрепляется HTTP-заголовок 'Content-Type', указывающий
						на то, что данные поступят в JSON-формате:

							application/json

					> Сервер получает запрос, видит заголовок, парсит полученную строку
						соответствующим образом, и размещает результаты в суперглобальном
						массиве $_POST / $_GET (в зависимости от метода запроса).
					> Данные таким образом в 99% случаев передают методом POST в
						теле запроса.
						> Что касается метода GET, то обычно у него нет тела, и поэтому
							единственным способом передачи данных остается query string
							в строке адреса. Однако, тут сразу возникает 2 проблемы:
							- URL-строка ограничена 256 символами
							- JSON-строку придется закодировать в формат URL перед отправкой,
								и раскодировать после её приёма принимающей стороной.
							Короче говоря, смысла передавать JSON-строку методом GET
							в большинстве случаев нет.

				> Ссылка на рабочий пример передачи данных в JSON-формате методом POST:
					'3. Javascript' ->
					'0. Practical samples and techniques' ->
					'5. AJAX - send object as JSON to server (POST)'


			> Передача файла
				> Подробнее об этом см. хорошую статью по ссылке:
						http://www.html5rocks.com/ru/tutorials/file/dndfiles/
				> Как это происходит в нескольких словах:
					> Сам процесс передачи файла состоит из 2-х принципиальных частей:
						- Выбор файла или файлов для отправки.
						- Отправка файла.
					> Выбор файла
						> можно осуществить 2-мя способами:
							- Выбор с помощью элемента <input type='text'>
							- Выбор с помощью технологии drag-and-drop
						> Выбор с помощью элемента <input type='text'>
							> Это стандартный древний способ выбрать файл. Пользователь
								нажимает на кнопку, открывается проводник его операционной
								системы, и он выбирает требуемый файл.
							> Можно настроить механизм так, что пользователь сможет
								выбрать > 1 файла.
							> Все эти файлы в итоге будут лежать в свойстве files
								элемента input.
						> Выбор с помощью технологии drag-and-drop
							> Этот способ новее предыдущего, он основан на технологиях
								HTML5. И может не работать, соответственно, в некоторых
								старых браузерах.
							> Он основан на обработке событий dragover и drop, а
								передаваемые таким образом файлы будут лежать в
								свойстве event.dataTransfer.files.
					> Отправка файла
						> В рамках AJAX, отправка файла происходит с помощью запроса
							POST - файл передают в теле запроса.
						> Вместе с запросом можно отправить заголовок "Content-Type",
							который сообщает серверу о том, какого типа файл ему
							отправили.
							Тут есть 2 варианта:

							> 1 вариант
								> К запросу можно явно прикрепить HTTP-заголовок 'Content-Type',
									и указать в нем тип отправляемого файла. Например:

									Если тип не известен, или это просто файл в 2-ном формате:
									-----
										application/octet-stream

									Если это текстовый файл
									-----
										text/plain

									Если это PDF-файл
									-----
										application/pdf

									Если это JPEG-изображение
									-----
										image/jpeg

									... и так далее.

							> 2 вариант
								> Не прикреплять явно к запросу заголовок 'Content-Type'.
									В этом случае тип файла будет определен автоматически
									по его расширению.
								> А если расширение отсутствует или не опознано, то будет
									использован тип:

										application/octet-stream

								> Тут надо предупредить об опасности - могут быть ситуации,
									когда расширение файла не соответствует его реальному типу.

				> Прогресс передачи файла
					> Как отслеживать прогресс передачи файла из JS-скрипта на сервер
						можно подробно посмотреть в этом обучающем видео:
							http://www.youtube.com/watch?v=EraNFJiY0Eg
					> В основе этого лежит отслеживание событий loaded и total.

				> Об объекте File и его родитель Blob
					> Одна из особенностей HTML-форм в том, что если пользователь выберет
						файл с помощью элемента <input type='file'>, форма отправит содержимое
						этого файла в теле POST-запроса.
					> Еще недавно операция передачи файла с помощью прикладного интерфейса
						XMLHttpRequest была недоступна. Но теперь это возможно благодаря
						прикладному интерфейсу, определяемому спецификацией 'XHR2' - можно
						передавать файлы за счет передачи объекта File методу send().
					> Объект File нельзя просто создать конструктором File() - сценарий
						может только получить объект File, представляющий файл, выбранный
						пользователем.
					> В браузерах, поддерживающих объекты File, каждый элемент
						<input type='file'> имеет свойство files, которое ссылается на
						объект, подобный массиву, хранящий объекты File.
					> Кроме того, прикладной интерфейс drag-and-drop также позволяет
						получить доступ к файлам, "сбрасываемым" пользователем на элемент
						через свойство dataTransfer.files события "drop".
					> Подробное описание объекта File от команды Mozilla:
							https://developer.mozilla.org/en-US/docs/Web/API/File
					> Тип File является подтипом более общего типа Blob. Спецификация
						'XHR2' позволяет передавать методу send() произвольные объекты
						Blob.
						> Свойство Blob.type можно использовать для установки заголовка
							'Content-Type', если он не будет определен явно.
						> Если потребуется выгрузить двоичные данные, сгенерированные
							клиентским скриптом, можно воспользоваться приемами
							преобразования данных в объект Blob.

				> Ссылка на рабочий пример передачи файла из JS-скрипта на сервер
					в php-скрипт с помощью AJAX:
						'3. Javascript' ->
						'0. Practical samples and techniques' ->
						'6. AJAX - send file to server (POST)'

					> Описание примера:

						Cкрипт обходит документ и ищет все HTML-элементы input
						с type = 'file'. Для каждого найденного элемента он регистрирует
						обработчик onchange. Когда обработчик срабатывает, с помощью
						XMLHttpRequest отправляет методом POST запрос к серверу,
						передавая в теле объект File, относящийся к добавленному в
						форме файлу.


			> Передача > 1 куска данных в одном HTTP-запросе в формате multipart
				> Что значит > 1 куска данных?
					> Кусок данных - это некая отдельная единица данных - строка,
					 	объект, массив, файл.
					> Часто нам требуется одновременно передать из JS-скрипта на
						сервер сразу несколько кусков данных.

				> Есть у способы передать в 1-м запросе > 1 куска данных:
					- Каждый кусок данных передавать отдельным HTTP-запросом.
					- Упаковать все куски в 1 тело в собственном формате, и
						и передать в 1-м HTTP-запросе.
					- Упаковать все куски в 1 тело в формате multipart/form-data,
						и передать в 1-м HTTP-запросе.

				> Каждый кусок данных передавать отдельным HTTP-запросом
					> Так можно делать. Но это становится особенно неудобно, когда
						нужно передать очень много кусков, причем все они должны быть
						задействованы на сервере одновременно.
					> Как простой пример, надо передать 10 файлов + имена и типы
						этих файлов. Пришлось бы создать минимум 11 запросов к
						серверу.

				> Упаковать все куски в 1 тело в собственном формате, и
					и передать в 1-м HTTP-запросе.
					> Суть этого способа в том, чтобы каким-то образом упаковать
						все куски в 1 строку и передать их так. А на стороне сервера
						каким-то образом получить информацию о том, как эту строку
						надо парсить, распарсить её и извлечь куски.
					> Так можно было бы сделать, но нет смысла изобретать
						велосипед - это уже придумали до нас (см. следующий способ).

				> Упаковать все куски в 1 тело в формате multipart/form-data,
					и передать в 1-м HTTP-запросе.

					> Чтобы отправить > 1 куска данных в этом формате, надо сначала
						как-то сформировать строку в таком формате. Сделать это
						можно 2-мя способами:
						- Автоматически, при отправке данных из формы, содержащей
							передачу файла.
						- С помощью прикладного интерфейса FormData спецификации XHR2.

					> Автоматически, при отправке данных из формы, содержащей
						передачу файла
						> Если форма включает элементы с передачей файлов, например
							<input type='file'>, то при отправке данных этой формы на
							сервер в HTTP-запросе автоматически посылается заголовок
							'Content-Type' со значением multipart/form-data.

					> С помощью прикладного интерфейса FormData спецификации XHR2
						> Интерфейс FormData позволяет легко объединить несколько
							кусков данных в 1-ин в формате multipart/form-data:

								// подготовка данных к отправке
								var f = new FormData();
								f.append(1 кусок);
								f.append(2 кусок);
								f.append(3 кусок);

								// отправка данных в теле AJAX-запроса методом POST
								var xhr = new XMLHttpRequest();
								xhr.open('POST', url);
								xhr.setRequestHeader('Content-Type', 'multipart/form-data');
								xhr.send(f);

						> Причем заголовок Content-Type можно вручную не устанавливать,
							поскольку метод send, когда ему передается объект FormData,
							сам автоматически его устанавливает.


	> События, возникающие в ходе выполнения HTTP-запроса

		> В спецификации XHR для определения момента завершения HTTP-запроса
			использовалось событие readystatechange + отслеживание свойства
			readyState - при завершении запроса оно должо быть = 4.

		> В спецификации XHR2 набор доступных событий стал шире и удобнее:
			- loadstart	| возбуждается при вызове метода send()
			- progress	|	возбуждаются каждые ~50мс в ходе ожидания ответа сервера
			- load			| возбуждается по завершении запроса
			- timeout		| запрос окончился неудачей - истекло время ожидания ответа сервера
			- abort			| запрос окончился неудачей - отменен пользователем
			- error			| запрос окончился неудачей - по какой-то иной причине

		> С помощью новых событий из списка выше, мониторить можно:
			- Ход выполнения загрузки HTTP-ответа
				> Нужные события лежат по адресу (на примере load):

					XMLHttpRequest.load

			- Ход выполнения выгрузки HTTP-запроса
				> Нужные события лежат по адресу (на примере load):

					XMLHttpRequest.upload.onload

		> Подробнее о loadstart
			> Возбуждается 1 раз, когда вызывается метод send().

		> Подробнее о progress
			> В ходе ожидания/загрузки ответа сервера возбуждается каждые
				~50 миллисекунд.
			> Можно использовать для предоставления обратной связи пользователю.
				Например, это может быть индикатор загрузки.
			> Если запрос завершается очень быстро, событие progress может и
				не успеть возбудиться ни разу.

		> Подробнее о load
			> По завершении запроса (не важно, успешном или нет), вобуждается
				событие load.
			> Для 1-го запроса возбуждается только 1 раз.
			> Возбуждение события load означает лишь то, что запрос окончился.
				А окончиться он может:
				- Успехом
				- Неудачей
			> Поэтому в событии load надо проверить, какой код запроса вернул
				сервер. Если "200 OK", значит запрос окончился успехом. А если
				какой-нибудь другой, например "404 Not Found" - значит неудачей.

		> Подробнее об timeout, abort, error
			> Если запрос окончился неудачей, то в зависимости от причины этой
				неудачи возбуждается соответствующее событие.
			> timeout
				> Если предельное время ожидания ответа от сервера истекло, то
					возбуждается событие timeout.
			> abort
				> Если выполнение запроса было прервано, то генерируется событие
					abort.
			> error
				> Если выполнению запроса воспрепятствовали какие-то другие ошибки
					в сети, такие как слишком большое количество переадресаций,
					то в этих случаях генерируется событие error.
			> Для 1-го запроса браузер может возбуждать только по 1-му событию
				timeout, abort, error.

		> Проверка наличия новых событий в браузере
			> Новые события постоянно прибывают, а вопрос поддержки в разных
				браузерах остается актуальным. Поэтому нужно уметь проверять,
				поддерживает ли данный браузер данное событие.
			> Для этого надо просто проверить наличие такого свойства в
				соответствующем объекте:

					if('onprogress' in (new XMLHttpRequest())) {

					}

		> Объект Event для новых событий поддерживает доп. свойства
			> А именно, наследник объекта Event - объект ProgressEvent
				и содержит данные свойства.
			> Объект Event, который передается обработчику событий при его
				возбуждении, для новых событий из списка выше, содержит 3
				новых свойства:
				- loaded						| кол-во байтов, переданных к моменту возбуждения события
				- total							| общий объем загружаемых данных
				- lengthComputable	| true - если total известен, иначе false.


	> Отмена запроса, предельное время ожидания

		> Отмена запроса
			> Выполнение HTTP-запроса можно прервать методом abort() объекта
				XMLHttpRequest.
			> После вызова метода abort() генерируется событие abort.
			> Где можно использовать:
				- При выгрузке с помощью AJAX-запроса файла, можно дать возможность
					пользователю отменить выгрузку, отменив запрос.
				- В механизме автодополнения поиска, если пользователь успевает
					ввести новый символ до того, как подсказка будет получена с
					сервера, то эта подсказка устаревает и больше не нужна. Тогда
					можно и отменить связанный с ней запрос.

		> Предельное время ожидания
			> В спецификации XHR2 у объекта XHR есть свойство timeout, в котором
				указывается промежуток времени в миллисекундах, после которого
				запрос автоматически будет прерван.
			> Если запрос будет прерван по этой причине, то будет вызвано
				событие timeout.
			> Перед использованием проверить поддержку браузерами.


	> Междоменные HTTP-запросы

		> О проблеме междоменных запросов
			> На объект XMLHttpRequest также действует политика общего
				происхождения (см. выше). Поэтому он может использоваться для
				отправки HTTP-запросов только серверу, откуда был получен
				использующий его документ.
			> Это ограничение закрывает дыру в безопасности, но также предотсращает
				возможность использования объекта для вполне законных междоменных
				запросов:
				> Дыра состоит в том, что содержимое документа, к которому производится
					запрос всегда доступно через свойство XMLHttpRequest.responseText.
				> А пример вполне законных междоменныз запросов - например, элементы
					form и iframe позволяют указывать URL-адреса с другими доменными
					именами, и в этих случаях браузеры будут отображать документы,
					полученные из других доменов.
			> Элемент script никогда не был субъектом политики общего происхождения
			  - он будет загружать и выполнять любой скрипт, независимо от его
			  происхождения.

		> Возможное решение: CORS-заголовки
			> CORS - Cross-Origin Resource Sharing.
			> Спецификация XHR2 позволяет выполнять междоменные запросы к другим
				веб-сайтам, указанным в HTTP-заголовке CORS HTTP-ответа.
			> Поддержка:
				- Все современные браузеры и IE>=9
				- Для IE8 поддерживается собственный объект XDomainRequest
			> Как это работает
				> Если браузер поддерживает заголовок CORS для объекта XMLHttpRequest,
					и если вы пытаетесь выполнить междоменный запрос к веб-сайту, доступ
					к которому разрешен в заголовке CORS, политика общего происхождения
					просто не будет препятствовать выполнению междоменного запроса,
					и все будет работать само собой.

		> Другие возможные решения:
			> Здесь Ильёй Кантором описан ряд решений:
					http://learn.javascript.ru/xhr-crossdomain
			> Здесь описано простое решение с помощью проксирования запроса:
					http://www.securityscripts.ru/articles/AJAX/cross-domain-ajax-request.html


	> Выполнение HTTP-запросов с помощью <script>: JSONP

		> Общая информация о JSONP
			> HTTP-элемент <script> как AJAX-транспорт
				> Прием использования элемента script в качестве AJAX-транспорта
					известен под названием JSONP - это способ организации взаимодействий,
					когда на HTTP-запрос возвращаются данные в формате JSON, а P - означает
					"prefix" - дополнение.
				> HTTP-элемент script можно использовать в качестве AJAX-транспорта.
				> Достаточно поместить элемент script в документ, и установить его
					атрибут src, и браузер сгенерирует HTTP-запрос, чтобы загрузить
					содержимое ресурса по указанному в src URL-адресу.
			> Преимущества элемента script, как AJAX-транспорта
				- Элемент script не является субъектом политики общего происхождения,
					и поэтому его можно использовать для запроса данных с другого сервера.
				- Элемент script автоматически декодирует и выполняет тело ответа
					в формате JSON.

		> Как работает JSONP
			> Этап 1
				> Скрипт посылает серверу GET-запрос - это происходит, когда скрипт вставляет
					в документ HTML-элемент script с атрибутом src. В query string которого
					сообщает 2 вещи:
					- О том, что это JSONP-запрос, т.е. в ответ надо посылать не просто JSON,
						а JSON, завернутый в теле функции (см. ниже).
					- Имя функции, в которую сервер должен завернуть ответ.
			> Этап 2
				> Получив JSONP-запрос, сервер заворачивает ответ в виде JSON-строки в
					переданное ему через query string имя функции, и отправляет скрипту
					ответ.
			> Этап 3
				> Скрипт должен был перед отправкой запроса подготовить функцию,
					имя которой совпадает с тем именем, в которое сервер завернул
					JSON-ответ.
				> Когда скрипт получает ответ, эта функция автоматически выполняется,
					и ответ сервера можно забрать в теле функции из её единственного
					аргумента.
				> Ответ сервера в виде JSON-строки автоматически парсится скриптом в
					объект, так что в вышеуказанном аргументе будет лежать этот объект.

		> Безопасность и JSONP
			> Используя JSONP ты разрешаешь своей веб-страницы выполнять любой
				код на JS, который пришлет удаленный сервер. И этот код может
				заставить твою веб-страницу выполнить любой код, отобразить или
				украсть любые данные.
			> Поэтому не следует при работе с JSONP использовать данные, поступившие
				с не 100% доверенных серверов.
			> Также следует учитывать возможность того, что твой собственный веб-сервер
				будет взломан, и с него будет отправлен через JSONP вредоносный код.

		> Пример работы JSONP можно посмотреть по адресу:

				3. Javascript ->
				0. Practical samples and techniques ->
				11. JSONP test


	> Архитектура Comet на основе стандарта "Server-Sent Events" (SSE)
		> Общая информация
			> Проект стандарта "Server-Sent Events" определяет объект EventSource.
			> С его помощью легко реализовать архитектуру Comet.
		> Как это работает

			> На стороне клиента:
				1. С помощью объекта EventSource производится "подписка" на
					 "прослушивание" выходного буфера серверного скрипта,
					 на который производится подписка:

						var sse = new EventSource('p.php');
						sse.onmessage = function(event) {
							var msg = event.data;		// отправленные сервером данные
						};

					> Это самое прослушивание осуществляется 1 раз в 3 секунды.
					> Суть этого действа в том, что сервер по своей инициативе
						может отдать в любой момент какие-то данные. А клиент их
						принять в течение 3-х секунд. Это может быть использовано,
						например:
						- Для чата - разные клиенты посылают на сервер данные, а сервер
							их тут же выводит для всех клиентов.
						- В системе управления бизнесом - сотрудник сидит ждет задание,
							и вот менеджер его создал и отправил на сервер, а сервер тут
							же выводит его для сотрудника.
				2. С помощью XMLHttpRequest клиент может отправить на сервер данные,
					которые могут быть использованы сервером для отправки через SSE.

			> На стороне сервера:
				1. Сервер должен отвечать с заголовком "Content-Type: text/event-stream".
				2. - Ответ сервера должен быть в формате "data:...любая_строка...\n\n"
					> Это строка в формате text/event-stream.
					> Причем кавычки обязательно должны быть двойные "", иначе никакого
						ответа отправлено не будет.
				3. HTTP-запрос от XMLHttpRequest и установленное с помощью SSE
					соединение - это разные соединения, и информацию между ними
					напрямую передать нельзя.
					> Поэтому, чтобы SSE получило информацию, переданную от клиента
						с помощью XMLHttpRequest, её нужно где-нибудь сохранить во
						время получения XMLHttpRequest-запроса. Например, в сессии.
					> А затем при отправке данных через SSE извлечь из буфера,
						и использовать. Можно обнулить буфер, если надо.


		> Протокол обмена Server-Sent Events
			- Клиент создает объект EventSource и тем самым устанавливает соединение
				с сервером по адресу, указанному в аргументе этого конструктора:

					var object = new EventSource('p.php');

			- Сервер сохраняет это соединение открытым.
			- Когда происходит событие, сервер передает через соединение текстовую
				строку.
		> Ответ сервера:
			- Сервер должен отвечать с заголовком "Content-Type: text/event-stream".
			- Ответ сервера должен быть в формате "data:...любая_строка...\n\n".
				Кавычки обязательно должны быть двойные "", с одинарными '' работать не будет.
			-
		> Идентификатор события
			> Событиям могут быть присвоены идентификаторы. И клиент в случае
				разрыва соединения с сервером, может после его восстановления по
				этим идентификаторам повторно запросить пропущенные события.
		> Поддержка
			> Поддерживается всеми современными браузерами, кроме IE.
			> Ни одна из версий IE, включая IE11, не поддерживает EventSource.
		> Рабочий пример Comet можно посмотреть по адресу:

				3. Javascript ->
				0. Practical samples and techniques ->
				12. Comet test - chat













-------------------------------------------------- */

















