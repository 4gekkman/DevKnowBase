=============================================================
KnockoutJS


Ссылки:

	> Официальный сайт фреймворка:
				http://knockoutjs.com/

  > Официальная документация фреймворка:
        http://knockoutjs.com/documentation/introduction.html

  > Набор официальных интерактивных туториалов:
        http://learn.knockoutjs.com/#/?tutorial=intro

  > Набор официальных примеров использования:
        http://knockoutjs.com/examples/index.html

  > Хорошая статья на хабре про knockout:
        http://habrahabr.ru/post/124731/

  > Применение, советы, особенности KnockoutJS. Статья на habr:
        http://habrahabr.ru/post/164937/

  > Статья в wiki про шаблон Model-View-ViewModel:
        https://ru.wikipedia.org/wiki/Model-View-ViewModel

  > Блог: мысли, идеи, рассуждения о KnockoutJS
        http://www.knockmeout.net/

  > Knockout mapping plugin:
        https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output


*****************************************************
Оглавление:

    1.  Про фреймворк KnockoutJS
    2.  Наблюдаемые
    3.  Наблюдаемые массивы
    4.  Вычисляемые наблюдаемые
    5.  Связки
    6.  Шаблоны
    7.  Кастомные связки
    8.  Компоненты
    9.  Сохранение модели на сервер / загрузка модели с сервера
    10. Разделение модели KnockoutJS на AMD-модули с помощью RequireJS
    11. Seo и Knockout + Laravel

*****************************************************


1.  Про фреймворк KnockoutJS

  --------------------------------------
  Подоглавление:

    - Предназначение
    - Характеристики
    - Шаблон MVVM

  --------------------------------------

  > Предназначение
    - KO позволяет на стороне клиента создать модель данных.
    - Связать эту модель с пользовательским UI.
    - И автоматически синхронизирует модель с UI.
    - Этот фукнционал дорогого стоит, и серьёзно облегчает frontend-разработку.
    - Схематический пример:

      # Модель
        - Слева условно представлена модель данных на стороне клиента.
        - Она представляет из себя объект.

      # Пользовательский UI
        - Справа условно представлен браузер пользовательским UI.
        - В данном случае это простые input type='text'.

      # Синхронизация "Модель" => "UI"
        - Если внести изменения в модель, значение в UI тоже изменится.

      # Синхронизация "UI" => "Модель"
        - Если внести изменения в UI, модель тоже изменится.


         Модель                             Браузер

      {                   -------------------------------------------
        input1: '10',     |                                         |
        input2: 'ivan',   |    input1       input2       input3     |
        input3: '50',     |  ----------   ----------   ----------   |
      }                   |  |   10   |   |  ivan  |   |   50   |   |
                          |  ----------   ----------   ----------   |
                          |                                         |
                          |                                         |
                          -------------------------------------------


  > Характеристики

      Основные

        # Двусторонняя синхронизация модели и UI
          - При изменении в UI, модель автоматически синхронизируется.
          - При изменении в модели, UI автоматически синхронизируется.

        # Декларативный стиль
          - Связывать UI с моделью можно в декларативном стиле.
          - Т.Е. просто указать, что часть UI "А" связана с частью модели "Б".
          - А уж каким обрабом эта связь через JS реализуется, нас не волнует.

        # Легко расширяемый
          - Легко писать и использовать кастомные дополнения.

      Прочие

        # Нет зависимостей. Работает на чистом JS.

        # Можно начать использовать в проекте на любой его стадии.
          - При этом не придётся менять его архитектуру и т.д.
          - KnockoutJS провто снесёт доп. функционал, и все дела.

        # Компактный ~ 20 кб

        # Поддерживает IE6+. Работает на любом современном браузере.


  > Шаблон MVVM

    > Шаблон MV
      - VM - View-Model.
      - Представление напрямую общается с "моделью на сервере" (таблица в БД).

        -----------------         ---------------------
        |               |         |                   |
        | Представление | < --- > | Модель на сервере |
        |               |         |                   |
        -----------------         ---------------------

      - С использования VM обычно начинают все новичики.
      - В VM модель представления отсутствует напрочь.
      - Чтобы собрать данные для отправки на сервер, пишут спец.функции.
      - VM годится для разработки простых интерфейсов.
      - Если интерфейс сложен, то используя VM, придётся писать тонны кода.
      - Потом вникать, обслуживать, дополнять, изменять его будет очень трудно.

    > Шаблон MVVM
      - MVVM - Model-View-ViewModel.
      - View связано с ViewModel. А ViewModel связана с Model.

          View          - представление
          ViewModel     - модель представления
          Model         - модель на сервере (таблица в БД)

        --------        -------------        ---------
        |      |        |           |        |       |
        | View | < -- > | ViewModel | < -- > | Model |
        |      |        |           |        |       |
        --------        -------------        ---------

      - В MVVM, в отличие от VM, присутствует ViewModel.
      - ViewModel представляет из себя банальный JS-объект.
      - ViewModel и пользовательский UI обладают 2-сторонней синхронизацией.
      - Если надо что-то послать на сервер, берём данные из ViewModel.
      - Если надо что-то принять с сервера и изменить UI, записываем данные во ViewModel.


2.  Наблюдаемые

  --------------------------------------
  Подоглавление:

    - Введение
    - Декомпозиция

  --------------------------------------

  > Введение
    - Создать модель представления можно из любого JS-объекта.
    - Связать св-ва модели с DOM-элементом можно атрибутом data-bind.
    - Активировать KnockoutJS можно так: ko.applyBindings([объект-модель]);

  > Декомпозиция

    2.  Наблюдаемые
      2.1.  Создание модели представления из простого JS-объекта
        - Модель представления можно создать из простого JS-объеткта.
        - Здесь показано, как это делается.

      2.2.  Создание модели представления, как объекта польз-го класса
        - Более продвинутым считается создавать модель, как объект класса.
        - Здесь показано, как это делается.

      2.3.  Связывание свойств модели и элементов DOM
        - Для организации шаблона MVVM, должна быть возможность их связать.
        - KnockoutKS позволяет это сделать декларативным путём прямо в HTML.
        - Для этого следует использовать пользовательский атрибут data-bind.

      2.4.  Связывание только с эл-тами DOM внутри указанного эл-та
        - Иногда может потребоваться в 1 документи использовать > 1 ViewModel.
        - Св-ва одной модели связывать с DOM-элементами из одной части DOM.
        - Св-ва другой модели связывать с DOM-элементами из другой части DOM.
        - KnockoutJS позволяет настроить это 2-м аргументов в data-bind.

      2.5.  Декларирование св-в модели, как наблюдаемых
        - Когда НЕ наблюдаемое св-во модели меняется, связанные UI при этом НЕ меняются.
        - Когда связанный UI меняется, НЕ наблюдаемое свойство модели меняется тоже.
        - Чтобы была 2-направленная синхронизация, надо сделать св-во модели наблюдаемым.
        - Тогда при своём изменении св-во будет уведомлять всех UI-подписчиков.
        - Делается это с помощью метода ko.observable().

      2.6.  Чтение из / запись в наблюдаемое св-во модели
        - При чтении из наблюдаемого свойства надо не забывать ставить ().
        - Например: var value = Model.value();
        - При записи в наблюдаемое св-во не надо использовать = .
        - Как надо: Model.value('Иван'); Как не надо: Model.value = 'Иван';

      2.7.  Ручная подписка callback-функции на изменения св-ва модели
        - Осуществляется с помощью метода subscribe.
        - Например: Model.value.subscribe(function{});
        - Срабатывает при каждом изменении этого свойства модели.

      2.8.  Принудительное оповещение подписчиков об изменении св-ва модели
        - При изменении св-ва с примитивным значением все UI-подписчики уведомляются.
        - Но если при изменении было вписано такое-же значение, то нет.
        - А можно с помощью notify extender сделать так, чтобы тоже уведомлялись.

      2.9.  Откладывание уведомления св-вом модели UI-подписчиков об изменении
        - По умолчанию, при изменении св-ва модели, UI-подписчики уведомляются сразу.
        - Но с помощью rateLimit extender можно отложить уведомление на N мс.


  > 2.1.  Создание модели представления из простого JS-объекта

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Модель представления можно создать из простого JS-объеткта.
      - Здесь показано, как это делается.

    > Практика:
      - Сделаем модель представления из этого вот объекта:

             j.js
           -----------------
            var Model = {
              name: 'Иван',
              age: 18
            };

      - Активируем KnockoutJS и модель методом applyBindings:

             j.js
           -----------------
            ko.applyBindings(Model);


  > 2.2.  Создание модели представления, как объекта польз-го класса

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Более продвинутым считается создавать модель, как объект класса.
      - Здесь показано, как это делается.

    > Практика
      - Создадим объет-прототип, который условно будем называть классом:

             j.js
           -----------------
            var Model = {
              constructor: function() {
                name: 'Иван',
                age: 18
              },
            };

      - Создадим объект класса Model, и скормим его KnockoutJS, активировав его:

             j.js
           -----------------
            ko.applyBindings( Object.create(Model).constructor() );


  > 2.3.  Связывание свойств модели и элементов DOM

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Для организации шаблона MVVM, должна быть возможность их связать.
      - Связать св-ва модели представления и элементы UI между собой.
      - KnockoutKS позволяет это сделать декларативным путём прямо в HTML.
      - Для этого следует использовать пользовательский атрибут data-bind.

    > Практика
      - Создадим объет-прототип, который условно будем называть классом:

             j.js
           -----------------
            var Model = {
              constructor: function() {
                name: 'Иван',
                age: 18
              },
            };

      - Создадим в файле h.html два DOM-элемента input type='text'.
      - И свяжем один из них со св-вом name модели, а второй со св-вом age.
      - Связывание производится в декларативном стиле в польз. атрибуте data-bind.
      - Связывать будем value этих элементов.

               h.js
           -----------------
            <input type='text' data-bind='value: name'>
            <input type='text' data-bind='value: age'>

      - Создадим объект класса Model, и скормим его KnockoutJS, активировав его:

             j.js
           -----------------
            ko.applyBindings( Object.create(Model).constructor() );

      - Теперь при изменении value этих эл-в input, меняются соотв. св-ва модели.


  > 2.4.  Связывание только с эл-тами DOM внутри указанного эл-та

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Иногда может потребоваться в 1 документи использовать > 1 ViewModel.
      - Св-ва одной модели связывать с DOM-элементами из одной части DOM.
      - Св-ва другой модели связывать с DOM-элементами из другой части DOM.
      - KnockoutJS позволяет настроить это 2-м аргументов в data-bind.

    > Практика
      - Пусь у нас есть 2 модели:

             j.js                j.js
         -----------------   -----------------
          var Model1 = {      var Model2 = {
            name: 'Иван',       name: 'Пётр',
            age: 18             age: 28
          };                  };

      - И есть вот такое представление:

               h.js
           -----------------
            <div id="part1">
              <input type='text' data-bind='value: name'>
              <input type='text' data-bind='value: age'>
            </div>

            <div id="part2">
              <input type='text' data-bind='value: name'>
              <input type='text' data-bind='value: age'>
            </div>

      - Как связать input'ы из part1 с Model1, а из part2 с Model2?
      - У при применении applyBindings можно указать 2-й аргумент.
      - Ссылку на DOM-элемент. Только в нём KO и должен искать связи для модели.

             j.js
           -----------------
            ko.applyBindings( Model1, document.getElementById('part1') );
            ko.applyBindings( Model2, document.getElementById('part2') );


  > 2.5.  Декларирование св-в модели, как наблюдаемых

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Когда НЕ наблюдаемое св-во модели меняется, связанные UI при этом НЕ меняются.
      - Когда связанный UI меняется, НЕ наблюдаемое свойство модели меняется тоже.
      - Чтобы была 2-направленная синхронизация, надо сделать св-во модели наблюдаемым.
      - Тогда при своём изменении св-во будет уведомлять всех UI-подписчиков.
      - Делается это с помощью метода ko.observable().

    > Практика
      - Создадим объект-модель представления.
      - С помощью метода observable укажем, что св-ва name и age - наблюдаемые:

             j.js
           -----------------
            var Model = {
              name: ko.observable(),
              age: ko.observable()
            };

      - ... или же его можно определить так, со стартовыми свойствами.
      - В аргументе можно передать стартовое значение для св-ва:

             j.js
           -----------------
            var Model = {
              name: ko.observable('Иван'),
              age: ko.observable(18)
            };

      - Активируем KnockoutJS и модель методом applyBindings:

             j.js
           -----------------
            ko.applyBindings(Model);


  > 2.6.  Чтение из / запись в наблюдаемое св-во модели

    --------------------------------------
    Подоглавление:

      - Введение
      - Зачем эти неудобства
      - Чтение
      - Запись

    --------------------------------------

    > Введение
      - При чтении из наблюдаемого свойства надо не забывать ставить ().
      - Например: var value = Model.value();
      - При записи в наблюдаемое св-во не надо использовать = .
      - Как надо: Model.value('Иван'); Как не надо: Model.value = 'Иван';

    > Зачем эти неудобства
      - Не все браузеры поддерживают геттеры и сеттеры.
      - Поэтому, ради совместимости, автор KnockoutJS не стал их использовать.

    > Чтение
      - Вот у нас есть такая модель с наблюдаемыми свойствами:

             j.js
           -----------------
            var Model = {
              name: ko.observable(),
              age: ko.observable()
            };

      - Прочесть эти свойства можно так:

            var name = Model.name();
            var age = Model.age();

      - Не забывать скобки!!1

    > Запись
      - Инициализировать св-ва модели значениями можно так:

            Model.name('Пётр');
            Model.age(18);

      - Не применять !!1 при инициализации оператор =
      - Тоже самое можно написать и так:

            Model.name('Пётр').age(18);


  > 2.7.  Ручная подписка callback-функции на изменения св-ва модели

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Осуществляется с помощью метода subscribe.
      - Например: Model.value.subscribe(function{});
      - Срабатывает при каждом изменении этого свойства модели.
      - Работает, разумеется, только для наблюдаемых свойств.

    > Практика
      - Вот у нас есть такая модель с наблюдаемыми свойствами:

             j.js
           -----------------
            var Model = {
              name: ko.observable(),
              age: ko.observable()
            };

      - Назначим событиям "изменился" этих свойств ф-ии - обработчики:

            Model.name.subscribe(function() {
              console.log('name изменился');
            });

            Model.age.subscribe(function() {
              console.log('age изменился');
            });

      - Теперь при изменении соотв. св-ва модели будет срабатывать соотв. обработчик.
      - Кроме callback ф-ия subscribe принимает ещ2 аргумента: target, event.
      - Target - порезеляет значение this в callback.
      - Event - имя события, которое надо отлавливать. По умолчанию: 'change'.
      - Пример:

            Model.name.subscribe(function() {
              console.log('name изменился');
            }, null, 'change');

      - Ещё можно ловить событие 'beforeChange'. Это как before-фильтр.
      - Оно срабатывае непосредственно перед осуществлением изменения св-ва.

            Model.name.subscribe(function() {
              console.log('name изменился');
            }, null, 'beforeChange');


  > 2.8.  Принудительное оповещение подписчиков об изменении св-ва модели

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - При изменении св-ва с примитивным значением все UI-подписчики уведомляются.
      - Но если при изменении было вписано такое-же значение, то нет.
      - А можно с помощью notify extender сделать так, чтобы тоже уведомлялись.

    > Практика
      - Вот у нас есть такая модель с наблюдаемыми свойствами:

             j.js
           -----------------
            var Model = {
              name: ko.observable(),
              age: ko.observable()
            };

      - Сделаем так, чтобы св-ва оповещали своих подписчиков при любом изменении.
      - Даже, если это было изменение на такое же значение:

            myViewModel.name.extend({ notify: 'always' });
            myViewModel.age.extend({ notify: 'always' });


  > 2.9.  Откладывание уведомления св-вом модели UI-подписчиков об изменении

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - По умолчанию, при изменении св-ва модели, UI-подписчики уведомляются сразу.
      - Но с помощью rateLimit extender можно отложить уведомление на N мс.

    > Практика
      - Вот у нас есть такая модель с наблюдаемыми свойствами:

             j.js
           -----------------
            var Model = {
              name: ko.observable(),
              age: ko.observable()
            };

      - Сделаем так, чтобы св-ва оповещали своих подписчиков не сразу.
      - А лишь спустя 50 мс после изменения.

            myViewModel.name.extend({ rateLimit: 50 });
            myViewModel.age.extend({ rateLimit: 50 });


3.  Наблюдаемые массивы

  --------------------------------------
  Подоглавление:

    - Введение
    - Декомпозиция

  --------------------------------------

  > Введение
    - Если надо связать 1 DOM эл. с 1 св-вом модели, используем наблюдаемую.
    - Если надо связать N DOM эл-ов с N св-вам модели, используем наблюдаемый массив.

  > Декомпозиция

    3.  Наблюдаемые массивы
      3.1.  Наблюдаемые массивы отслеживают нахождение объектов, а не их состояние
        - Помещение obj в наблюд. массив не делает св-ва этого obj наблюдаемыми.
        - Наблюдаемые массивы лишь отслеживают, какие объекты в них находятся.
        - И сообщают своим подписчикам, когда тот или иной объект добавлен/удалён.

      3.2.  Создание и инициализация наблюдаемого массива
        - Наблюдаемый массив можно создать методом ko.observableArray
        - Рассмотрим пример его создания.

      3.3.  Чтение из наблюдаемого массива
        - Наблюдаемый массив это ни что иное, как наблюдаемая, в которой лежи массив.
        - Но при этом, он, конечно, обладает некоторым дополнительным функционалом.
        - Читать значения из наблюдаемого массива можно также, как из обычного.
        - Не забывать ставить () при чтении !!1

      3.4.  Манипуляция элементами наблюдаемого массива
        - KO предоставляет ряд функций для манипуляции содержимым наблюд.массива.
        - push,pop,unshift,shift,reverse,sort,remove,removeAll,destroy,destroyAll,indexOf,slice.
        - Многие из них дублируют функционал ядра JS, но есть несколько новичков.
        - Применение этих методов уведомляет всех подписчиков набл.мас. об изменении.

      3.5.  При использовании foreach, 'destroyed' эл-ты наблюдаемого массива не отображаются
        - В KO существует возможность "мягкого" удаления эл-та из наблюдаемого массива.
        - "Мягкое" удаление в KO реализуется методами destroy и destroyAll.
        - При "мягком" удалении объекта из набл.мас., ему присваивается св-ва _destroy.
        - Если значение _destroy == true, объект считается удалённым. Если false - нет.
        - "Мягко" удалённые объекты игнорируются при использовании foreach.

      3.6.  Откладывание и подавление сообщений об изменении
        - По умочанию, observableArray уведомляет подписчиков об изменении немедленно.
        - Но с помощью rateLimit extender можно отложить уведомление на N мс

      3.7.  Типичное использование наблюдаемых массивов с параметром связывания foreach
        - Параметр связывания foreach отрисовывает содержимое DOM-элемента N раз.
        - Где N это длина массива, имя которого стоит в значении параметра.
        - Если массив не наблюдаемый, то при удалении эл-та соотв. отрисовка не удалится из DOM.
        - А вот если он наблюдаемый, то удалится. И это очень удобно.



  > 3.1.  Наблюдаемые массивы отслеживают нахождение объектов, а не их состояние

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Помещение obj в наблюд. массив не делает св-ва этого obj наблюдаемыми.
      - Наблюдаемые массивы лишь отслеживают, какие объекты в них находятся.
      - И сообщают своим подписчикам, когда тот или иной объект добавлен/удалён.

    > Практика
      - Вот обычный наблюдаемый массив внутри прототипа модели:

            var Model = {

              constructor: function (){

                this.people = ko.observableArray([
                  {num: 1, name: 'Иван', age: 18},
                  {num: 2, name: 'Джон', age: 28},
                  {num: 3, name: 'Вася', age: 38},
                ]);

                return this;
              }

            };

      - Все объекты в массиве people не являются наблюдаемыми.
      - При изменении этих объектов их подписчики уведомлятсья не будут.
      - А вот, как можно сделать их наблюдаемыми:

            var Model = {

              constructor: function (){

                this.people = ko.observableArray([
                  ko.observabl({num: 1, name: 'Иван', age: 18}),
                  ko.observabl({num: 2, name: 'Джон', age: 28}),
                  ko.observabl({num: 3, name: 'Вася', age: 38})
                ]);

                return this;
              }

            };




  > 3.2.  Создание и инициализация наблюдаемого массива

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Наблюдаемый массив можно создать методом ko.observableArray
      - Рассмотрим пример его создания.

    > Практика
      - Создадим и инициализируем наблюдаемый массив в прототипе модели:

            var Model = {

              constructor: function (){

                this.people = ko.observableArray([
                  {num: 1, name: 'Иван', age: 18},
                  {num: 2, name: 'Джон', age: 28},
                  {num: 3, name: 'Вася', age: 38},
                ]);

                return this;
              }

            };

      - Активируем KO экземпляром прототипа:

            ko.applyBindings(Object.create(Model).constructor());


  > 3.3.  Чтение из наблюдаемого массива

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Наблюдаемый массив это ни что иное, как наблюдаемая, в которой лежи массив.
      - Но при этом, он, конечно, обладает некоторым дополнительным функционалом.
      - Читать значения из наблюдаемого массива можно также, как из обычного.
      - Не забывать ставить () при чтении !!1

    > Практика
      - Создадим и инициализируем наблюдаемый массив в прототипе модели:

            var Model = {

              constructor: function (){

                this.people = ko.observableArray([
                  {num: 1, name: 'Иван', age: 18},
                  {num: 2, name: 'Джон', age: 28},
                  {num: 3, name: 'Вася', age: 38},
                ]);

                return this;
              }

            };

      - Активируем KO экземпляром прототипа:

            var m = Object.create(Model).constructor();
            ko.applyBindings(m);

      - Получим ссылку на элемент массива с индексом 0 (объект):

            var zero = m.people()[0];

      - Получим значение свойства name эл-та массива с индексом 1:

            var name = m.people()[1].name;


  > 3.4.  Манипуляция элементами наблюдаемого массива

    --------------------------------------
    Подоглавление:

      - Введение
      - Методы

        > push        | вставить 1 или несколько элементов в конец массива
        > pop         | удалить последний элемент из массива
        > unshift     | вставить элемент в начало массива
        > shift       | удалить первый элемент из массива
        > reverse     | изменить исходный массив на обратный
        > sort        | отсортировать исходный массив
        > indexOf     | возвращает индекс 1-го эл-та массива, равного указанному значению
        > slice       | берет подмассив из элементов указанного массива
        > remove      | удалить все эл-ты, равные указанному
        > removeAll   | удалить все объекты из массива
        > destroy     | найти указанный объект в массиве, и добавить ему св-во _destroy == true
        > destroyAll  | присвоить всем объектам в массиве св-во _destroy == true

    --------------------------------------

    > Введение
      - KO предоставляет ряд функций для манипуляции содержимым наблюд.массива.
      - push,pop,unshift,shift,reverse,sort,remove,removeAll,destroy,destroyAll,indexOf,slice.
      - Многие из них дублируют функционал ядра JS, но есть несколько новичков.
      - Применение этих методов уведомляет всех подписчиков набл.мас. об изменении.

    > Методы:
    
      //> push(element1, ..., elementN)
      //  - вставить 1 или несколько элементов в конец массива
      //  - возвращает удалённый элемент

          var obsArray = [1,2,3];
          obsArray.push(4, 'john');   // 5
          console.log(obsArray);		  // [1, 2, 3, 4, "john"]

      //> pop()
      //  - удалить последний элемент из массива
      //  - изменяет исходный массив
      //  - возвращает length измененного массива

          // вызов pop с пустым массивом
          var element = [].pop();
          console.log(element);			  // undefined

          // вызов pop с не пустым массивом
          var obsArray = ['One','Two','Three'];
          element = obsArray.pop();   // 'Three'
          console.log(obsArray);			// ["One", "Two"]

      //> unshift(element1, ..., elementN)
      //  - вставить 1 или несколько элементов в начало массива
      //  - возвращает удалённый элемент

          var obsArray = [1,2,3];
          obsArray.unshift('John','Javascript');
          console.log(obsArray);      // ["John", "Javascript", 1, 2, 3]

      //> shift()
      //  - удалить первый элемент из массива
      //  - изменяет исходный массив
      //  - возвращает length измененного массива

          // вызов shift с пустым массивом
          var element = [].shift();
          console.log(element);			  // undefined

          // вызов shift с не пустым массивом
          var obsArray = ['One','Two','Three'];
          element = obsArray.shift(); // "One"
          console.log(obsArray);		  // ["Two", "Three"]

      //> reverse()
      //  - изменить исходный массив на обратный
      //  - происходит изменение исходного массива

          var obsArray = ['One','Two','Three'];
          var newArray = obsArray.reverse();
          console.log(obsArray);			// ["Three", "Two", "One"]
          console.log(newArray);			// ["Three", "Two", "One"]

      //> sort(callback compare)
      //  - отсортировать исходный массив
      //  - compareFunction(a, b) - callback-функция, определяющая порядок сортировки;
      //    - если она опущена, то массив сортируется в алфавитном порядке
      //    - Если compareFunction возвращает значение < 0, то a < b
      //    - Если compareFunction возвращает значение > 0, то a > b
      //    - Если compareFunction возвращает значение = 0, a и b не сортируются по отношению друг к другу
      //  - изменяет исходный массив

          // сортировка в алфавитном порядке; изменяет исходный массив;
          var obsArray = ['One','Two','Three'];
          var newArray = array.sort();
          console.log(obsArray);				// ["One", "Three", "Two"]
          console.log(newArray);				// ["One", "Three", "Two"]

          // сортировка чисел в алфавитном порядке
          var obsArray = [1,2,3,4,5,20,22,25,300,310];
          obsArray.sort();
          console.log(obsArray);				//[1, 2, 20, 22, 25, 3, 300, 310, 4, 5]

          // сортировка с помощью compareFunction
          func = function(a,b) {
              if(a>b) return 1;
              if(a<b) return -1;
              if(a===b) return 0;
          };
          var obsArray = [1,2,3,4,5,20,22,25,300,310];
          obsArray.sort(func);
          console.log(obsArray);				// [1, 2, 3, 4, 5, 20, 22, 25, 300, 310]

          var obsArray = ['One','Two','Three'];
          obsArray.sort(func);
          console.log(obsArray);				// ["One", "Three", "Two"]


      //> indexOf(searchElement[, fromIndex])
      //  - возвращает индекс 1-го эл-та массива, равного указанному значению
      //  - если ничего не нашёл, вернёт -1.

          var obsArray = [1,2,3,4,5,6,5,4,3,2,1];
          console.log(obsArray.indexOf(2));			// 1
          console.log(obsArray.indexOf(5));			// 4
          console.log(obsArray.indexOf(10));		// -1

      //> slice(begin[, end])
      //  - берет подмассив из элементов указанного массива
      //  - begin - индекс элемента, с которого начинается извлечение
      //  - end - индекс элемента (не включая его), которым закончить извлечение
      //  - begin и end могут быть отрицательным. Тогда отсчет ведется с конца
      //	  массива, справа-налево.
      //  - не изменяет исходный массив
      //  - возвращает новый массив, содержащий извлеченный подмассив
      //  - вызов obsArray.slice(..) эквивалентен вызову obsArray().slice(..)

          var obsArray = [1,2,3,4,5];
          var newArray = array.slice(2);		  // [3, 4, 5]
          console.log(newArray);

          var newArray = obsArray.slice(1,3);	// [2, 3]
          console.log(newArray);

          var newArray = obsArray.slice(-2);	// [4, 5]
          console.log(newArray);

          var newArray = obsArray.slice(1,-1);
          console.log(newArray);				      // [2, 3, 4]

      //> remove(string | callback)
      //  - удалить все эл-ты, равные указанному аргументу
      //  - если callback возвращает true для эл-та, то он удаляется
      //  - возвращает массив удалённых элементов

        - Допустим, имеется такой наблюдаемый массив:

              obsArray = ko.observableArray([
                {num: 1, name: 'Иван', age: 18},
                {num: 2, name: 'Джон', age: 28},
                {num: 3, name: 'Вася', age: 38},
                {num: 4, name: 'Иван', age: 14}
              ]);

        - Найдём и удалим из него все объекты, у которых name == 'Иван':

              var removedElements = obsArray.remove(function(item){

                if( item.name == 'Иван') return true;

              });

        - Вот эти объекты были удалены из массива:

              // [{num: 1, name: 'Иван', age: 18}, {num: 4, name: 'Иван', age: 14}]
              console.log(removedElements);

      //> removeAll(array)
      //  - удалить все объекты из массива
      //  - возвращает массив удалённых элементов

        - Допустим, имеется такой наблюдаемый массив:

              var obj = {};
              obsArray = ko.observableArray([
                'Иван',
                18,
                obj,
                undefined,
                'Иван'
              ]);

        - Удалим из него все строки 'Иван', а также объект obj

              var removedElements = obsArray.removeAll(['Иван', obj]);

        - А вот так можно удалить вообще все объекты из массива:

              var removedElements = obsArray.removeAll();


      //> destroy(string | callback)
      //  - найти указанный объект в массиве, и добавить ему св-во _destroy == true

        - Допустим, имеется такой наблюдаемый массив:

              var obj = {num: 1, name: 'Иван', age: 18};
              obsArray = ko.observableArray([
                obj,
                {num: 2, name: 'Джон', age: 28},
              ]);

        - Найдём в нем объект obj и добавим ему св-во _destroy == true

              // {num: 1, name: 'Иван', age: 18, _destroy: true};
              obsArray.destroy(obj);

        - Найдём в нём объект со св-вом name == 'Джон', и добавим ему св-во _destroy == true

              // {num: 2, name: 'Джон', age: 28, _destroy: true}
              obsArray.destroy(function(item){
                if( item.name == 'Джон') return true;
              });

      //> destroyAll()
      //  - присвоить всем объектам в массиве св-во _destroy == true

        - Допустим, имеется такой наблюдаемый массив:

              var obj = {};
              obsArray = ko.observableArray([
                {num: 1, name: 'Иван', age: 18},
                {num: 2, name: 'Джон', age: 28},
                {num: 3, name: 'Вася', age: 38},
                {num: 4, name: 'Иван', age: 14}
              ]);

        - Присвоим всем элементам в массиве св-во _destroy == true:

              var removedElements = obsArray.removeAll();


  > 3.5.  При использовании foreach, 'destroyed' эл-ты наблюдаемого массива не отображаются

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - В KO существует возможность "мягкого" удаления эл-та из наблюдаемого массива.
      - "Мягкое" удаление в KO реализуется методами destroy и destroyAll.
      - При "мягком" удалении объекта из набл.мас., ему присваивается св-ва _destroy.
      - Если значение _destroy == true, объект считается удалённым. Если false - нет.
      - "Мягко" удалённые объекты игнорируются при использовании foreach.

    > Приактика
      - См. примеры "мягкого" удаления выше (функции destroy и destroyAll).


  3.6.  Откладывание и подавление сообщений об изменении

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - По умочанию, observableArray уведомляет подписчиков об изменении немедленно.
      - Но с помощью rateLimit extender можно отложить уведомление на N мс

    > Практика
      - Создадим и инициализируем наблюдаемый массив в прототипе модели:

            var Model = {

              constructor: function (){

                this.obsArray = ko.observableArray([
                  {num: 1, name: 'Иван', age: 18},
                  {num: 2, name: 'Джон', age: 28},
                  {num: 3, name: 'Вася', age: 38},
                ]);

                return this;
              }

            };

      - Активируем KO экземпляром прототипа:

            var m = Object.create(Model).constructor();
            ko.applyBindings(m);

      - Применим rateLimit к наблюдаемому массиву.
      - Будем откладывать уведомления на 50 мс:

            m.obsArray.extend({ rateLimit: 50 });


  > 3.7.  Типичное использование наблюдаемых массивов с параметром связывания foreach

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Параметр связывания foreach отрисовывает содержимое DOM-элемента N раз.
      - Где N это длина массива, имя которого стоит в значении параметра.
      - Если массив не наблюдаемый, то при удалении эл-та соотв. отрисовка не удалится из DOM.
      - А вот если он наблюдаемый, то удалится. И это очень удобно.

    > Практика
      - Создадим и инициализируем наблюдаемый массив в прототипе модели:

            j.js
           ------------------
            var Model = {

              constructor: function (){

                this.people = ko.observableArray([
                  {num: 1, name: 'Иван', age: 18},
                  {num: 2, name: 'Джон', age: 28},
                  {num: 3, name: 'Вася', age: 38},
                ]);

                return this;
              }

            };

      - Активируем KO экземпляром прототипа:

            j.js
           ------------------
            var m = Object.create(Model).constructor();
            ko.applyBindings(m);

      - В представление добавим такую разметку:

            <div data-bind="foreach: people">

              <mark data-bind="text: num"></mark>
              <p>Имя: <span data-bind="text: name"></span></p>
              <p>Возраст: <span data-bind="text: age"></span></p>

            </div>

      - Теперь разметка внутри div будет отрисована people.length раз
      - Т.Е. это будет сделано для каждого объекта в наблюдаемом массиве people.


4.  Вычисляемые наблюдаемые

  --------------------------------------
  Подоглавление:

    - Введение
    - Декомпозиция

  --------------------------------------

  > Введение
    - Выч.наблюдаемая вычисляется на основе N других свойств модели.
    - Вычисление происходит внутри callback-функции, возвращающей результат.
    - При изменении любого из эти N св-в, значение выч.наб. автоматич. перерассчитывается.
    - Все N св-св, от которых зависит выч.набюдаемая, должны быть наблюдаемыми.
    - Если какое-либо из них не является наблюдаемым, то при его изменении выч.наб. не изменится.

  > Декомпозиция

    4.  Вычисляемые наблюдаемые
      4.1.  Использование вычисляемых наблюдаемых
        - Здесь будет описана практика работы с вычисляемыми наблюдаемыми.

      4.2.  Редактируемые вычисляемые наблюдаемые
        - По умолчанию вычисляемые наблюдаемые можно только читать.
        - Но KO позволяет настроить и запись в вычисляемые наблюдаемые.
        - Да, существуют ситуации, когда это оправданно.

      4.3.  Информационная глава - как KO отслеживает зависимости
        - Здесь описано, как как KO отслеживает зависимости

      4.4.  Функционал по работе с вычисляемыми наблюдаемыми
        - Здесь описан различный функционал по работе с вычисяемыми наблюдаемыми.
        - И также техники его применения на практике.


  > 4.1.  Использование вычисляемых наблюдаемых

    --------------------------------------
    Подоглавление:

      - Введение
      - Вычисляемая наблюдаемая
      - Цепочка выч.наблюдаемых
      - Нюанс с this
      - Принудительно оповещать подписчиков
      - Откладывание и подавление сообщений об изменении
      - Является ли св-во высисляемой наблюдаемой?
      - Практика

    --------------------------------------

    > Введение
      - Здесь будет описана практика работы с вычисляемыми наблюдаемыми.

    > Вычисляемая наблюдаемая
      - Выч.наблюдаемая вычисляется на основе N других свойств модели.
      - Вычисление происходит внутри callback-функции, возвращающей результат.
      - При изменении любого из эти N св-в, значение выч.наб. автоматич. перерассчитывается.
      - Все N св-св, от которых зависит выч.набюдаемая, должны быть наблюдаемыми.
      - Если какое-либо из них не является наблюдаемым, то при его изменении выч.наб. не изменится.

    > Цепочка выч.наблюдаемых
      - При желании можно создать цепочку вычисляемых наблюдаемых.
      - Например, можно создать такую цепочку зависимостей:

                                    -------------
                                    |Выч.набл. 1|
                                    -------------
                                          |
                                ---------------------
                                |                   |
                          -------------       -------------
                          |Выч.набл. 2|       |Выч.набл. 3|
                          -------------       -------------
                                |                   |
              -------------------                   ------------------
              |              |                        |              |
        -------------  -------------            -------------  -------------
        |Выч.набл. 4|  |Выч.набл. 5|            |Выч.набл. 6|  |Выч.набл. 7|
        -------------  -------------            -------------  -------------

      - При изменении в зависимостях, зависящие ВН тоже перевычисляются.
      - Например, при изменинии в ВН4, будут перевычислены ВН2 и ВН1.

    > Нюанс с this
      - Метод computed 2-м аргументом принимает this.
      - Например:

          this.fullName = ko.computed(function() {
              return this.firstName() + " " + this.lastName();
          }, this);

      - Это позволяет передать в callback ссылку на контекст модели.
      - Благодаря этому в callback можно писать вещи вроде this.firstName().
      - Но есть способ не париться по этому поводу, и не передавать 2й аргумент.
      - Для этого в модели определяем свойство self == this, вот так:

            var x = {
              constructor: function() {
                var self = this;

                self.firstName = ko.observable('Bob');
                self.lastName = ko.observable('Smith');
                self.fullName = ko.computed(function() {
                    return self.firstName() + " " + self.lastName();
                });

                return self;
              }
            };

    > Принудительно оповещать подписчиков
      - При изменении ВС с примитивным значением все UI-подписчики уведомляются.
      - Но если при изменении было вписано такое-же значение, то нет.
      - А можно с помощью notify extender сделать так, чтобы тоже уведомлялись.
      - Сделать это можно при определении наблюдаемого вычисляемого св-ва:

          myViewModel.fullName = ko.pureComputed(function() {
              return myViewModel.firstName() + " " + myViewModel.lastName();
          }).extend({ notify: 'always' });

    > Откладывание и подавление сообщений об изменении
      - По умочанию, ВС уведомляет подписчиков об изменении немедленно.
      - Но с помощью rateLimit extender можно отложить уведомление на N мс
      - Вот как это делается:

          myViewModel.fullName.extend({ rateLimit: 50 });

    > Является ли св-во вычисляемой наблюдаемой?
      - Проверить это можно с помощью методов ko.isComputed.
      - ko.isWritableObservable - является ли доступной для записи ВН.
      - Например, есть у нас такая модель:

          var Model = {
            constructor: function() {
              var self = this;

              self.name = ko.observable();
              self.surname = ko.observable();

              self.fullname = ko.computed(function(){
                return self.name + ' ' + self.surname;
              });

              return self;
            }
          };

      - Активируем KO экземпляром прототипа:

            var m = Object.create(Model).constructor();
            ko.applyBindings(m);

      - Проверяем:

          // является ли выч.наблюд. св-во m.fullname:
            var isComputed = ko.isComputed(m.fullName); // true

          // является ли выч.наблюд. св-во m.name:
            var isComputed = ko.isComputed(m.name);     // false

          // Проверяем, является ли ВН, доступной для записи, св-во m.fullname:
            var isComputed = ko.isWritableObservable(m.fullName); // false

          // Проверяем, является ли ВН, доступной для записи, св-во m.name:
            var isComputed = ko.isWritableObservable(m.name);     // false

    > Практика
      - Создадим типичную вычисляемую наблюдаемую.
      - Используем для модели такой прототип:

            var Model = {

              constructor: function (){
                var self = this;

                self.a = ko.observable(1);
                self.b = ko.observable(2);

                self.c = ko.computed(function(){
                  return +self.a() + +self.b();
                });

                return self;
              }

            };

      - Активируем KO экземпляром прототипа:

            var m = Object.create(Model).constructor();
            ko.applyBindings(m);

      - Напишим такой код в представлении:

            <input type="text" size="5" data-bind="value: a"> +
            <input type="text" size="5" data-bind="value: b"> =
            <span data-bind="text: c"></span>

      - В итоге у нас получился мини калькулятор.
      - Он складывает числа a и b в соотв. input'ах.
      - А значение в span (выч.набл.) автоматически перерасчитывается.


  > 4.2.  Редактируемые вычисляемые наблюдаемые

    --------------------------------------
    Подоглавление:

      - Введение
      - Принцип работы
      - Практика: простой пример
      - Практика: выделение/развыделение всех чекбоксов
      - Практика: фильтрация пользовательского ввода

    --------------------------------------

    > Введение
      - По умолчанию вычисляемые наблюдаемые можно только читать.
      - Но KO позволяет настроить и запись в вычисляемые наблюдаемые.
      - Да, существуют ситуации, когда это оправданно.

    > Принцип работы
      - Обычно мы передаём методу ko.computed() callback-функцию.
      - Если надо сделать вычисляемую редактируемой, надо передать объект.
      - Этот объект должен содержать 2 свойства: read и write.
      - Каждое из них содержит callback, обрабатывающий чтение/запись соответственно.

            ko.computed({

              read:   function(){ ..обработка чтения.. },
              write:  function(){ ..обработка записи.. },
              owner: this

            });

      - Можно до кучи добавить св-во owner, содержащее контекст this.

    > Практика
      - Демонстрация использования редактируемой вычисляемой наблюдаемой.
      - Используем для модели такой прототип:

            var Model = {

              constructor: function (){
                var self = this;

                self.name = ko.observable('Иван');
                self.surname = ko.observable('Петров');

                self.fullname = ko.computed({

                  // Обработка чтения
                  read: function(){
                    return self.name() + ' ' + self.surname();
                  },

                  write: function(value) {

                    // Разберём fullname на name и surname
                    // - name запишем в self.name
                    // - surname запишем в self.surname
                    console.log(value);
                      // 1. Получить индекс первого вхождения символа " "
                      var lastSpacePos = value.lastIndexOf(" ");

                      // 2. Если lastSpacePos найден, произвести запись
                      if (lastSpacePos > 0) {
                          self.name(value.substring(0, lastSpacePos));
                          self.surname(value.substring(lastSpacePos + 1));
                      }

                  }

                });

                return self;
              }

            };

      - Активируем KO экземпляром прототипа:

            var m = Object.create(Model).constructor();
            ko.applyBindings(m);

      - Напишим такой код в представлении:

            <label><input type="text" data-bind="value: name"> - имя</label><br>
            <label><input type="text" data-bind="value: surname"> - фамилия</label><br>
            <label><input type="text" data-bind="value: fullname"> - фамилия и имя</label><br>

      - Теперь при редактировании name и surname, fullname автоматом обновляется.
      - Но главная фишка не в этом, а в том что ...
      - Теперь при обновлении fullname, name и surname обновляются.



  > 4.3.  Информационная глава - как KO отслеживает зависимости

    --------------------------------------
    Подоглавление:

      - Введение
      - Как KO отслеживает зависимости
      - Функция peek
      - Циклическая зависимость

    --------------------------------------

    > Введение
      - Здесь описано, как как KO отслеживает зависимости

    > Как KO отслеживает зависимости

        1) При объявлении вычисляемой наблюдаемой, запускается функция.
          - Она задаёт св-ву стартовое значение.

        2) При запуске вышеуказанной функции обновляются все связи.
          - Отменяются связи, которые больше не действуют.
          - Добавляются новые связи.

        3) KO оповещает всех подписчиков
          - О том, что у вычисляемоей наблюдаемой появилось новое значение.

      - Т.О. KO проверяет связи при каждом вызове callback-функции вычисл.наблюаемой.
      - А связки реализованы просто, как вычисляемые наблюдаемые.
      - Т.Ч. если связка читает значение наблюдаемой, связка становится от неё зависимой.
      - Как следствие, связка будет перерасчитываться, если значение наблюдаемой будет меняться.

    > Функция peek
      - Выч.наб. обновл. автомат., если измен.знач. наблюд-ых, от которых она зависит.
      - Но иногда требуется внести коррективу в эту автоматическую логику KO.
      - Например определить, при обновл. каких набл. будет обновляться выч.наб.

      - Рассмотрим стандартное поведение KO:

          Стандартное поведение
         -----------------------

                         -------------------------
                         |Вычисляемая наблюдаемая|
                         -------------------------
                                     |
                                     | .. зависит от ..
                          -------------------------
                          |                       |
                    ---------------         ---------------
                    |Наблюдаемая 1|         |Наблюдаемая 2|
                    ---------------         ---------------

            - При изменение наблюдаемой 1/2, выч.наб. перерасчитывается.
            - Так ведёт себя KO по умолчанию.

      - А вот, как можно настроить с помощью ф-ии peak, чтобы KO вёл себя:

            - При изменение Н1, вычисляемая наблюдаемая не перерасчитывается.
            - При изменение Н2, вычисляемая наблюдаемая перерасчитывается.

      - Это особенно полезно, если выч.наб. осуществляет какое-либо действие.
      - Например, посылает ajax-запрос с данными на сервер.
      - Ф-ию peak можно применить набл. внутри callback'a выч.наблюдаемой.
      - Тогда связ с этой наблюд. не будет создана.
      - И выч.наб. не будет обновлсяться при её обновлении.
      - Например, есть у нас такая вычисляемая наблюдаемая:

            ko.computed(function() {
                var params = {
                    page: self.pageIndex(),
                    selected: self.selectedItem.peek()
                };
                $.getJSON('/Some/Json/Service', params, this.currentPageData);
            });

      - Она зависит от 2-х других наблюдаемых: pageIndex и selectedItem.
      - Эти 2 наблюдаемые собираются в объект data.
      - А объект data ajax'ом отправляется на сервер.
      - И мы не хотим, чтобы каждый раз при изменении selectedItem данные отправлялись на сервак.
      - Для этого мы просто в конце добавляем ей peek().

    > Циклическая зависимость
      - Допустим, ВН "А" зависит от наблюдаемых "Б" и "В".
      - А наблюдаемая "Б" зависит от наблюдаемой "В", и наоборот.
      - Получается циклическая зависимость:

         - Обновляется "Б" -> обновляется "В" и "А".
         - Обновляется "В" -> обновляется "Б" и "А".
         - Обновляется "Б" -> обновляется "В" и "А".
         ...

      - С помощью функции peak() можно разорвать циклическую зависимость.


  > 4.4.  Функционал по работе с вычисляемыми наблюдаемыми

    --------------------------------------
    Подоглавление:

      - Введение
      - Функционал

        > computed v1             | способ создать вычисляемую наблюдаемую
        > computed v2             | способ создать редактируюемую вычисляемую наблюдаемую

        > dispose                 | вручную отписаться от изменений
        > extend                  | применяет указанный extender к вычисляемой наблюдаемой
        > getDependenciesCount    | возвращает кол-во св-в, от которых зависит эта выч.наблюдаемая
        > isActive                | возвращает true, если у выч.наб. нет зависимостей
        > peek                    | возвращает текущее значение вычисляемой наблюдаемой без создания связи.
        > subscribe               | вручную подписать выч.наб. на изменения фигурирующих в callback наблюдаемых

        > isInitial               | используется внутри callback вычисляемой наблюдаемой
        > getDependenciesCount    | возвращает кол-во св-в, от которых зависит эта выч.наблюдаемая

    --------------------------------------

    > Введение
      - Здесь описан различный функционал по работе с вычисяемыми наблюдаемыми.
      - И также техники его применения на практике.

    > Функционал

      //---------------------------------
      // > computed v1
      //---------------------------------
      // - ko.computed( callback [, targetObject, options] )
      //
      //      callback      | вычисляет значение вычисляемого наблюдаемого св-ва.
      //                      - ф-ия должна вернуть вычисленное значение.
      //      targetObject  | значение this внутри callback
      //      options       | конфиг с опциями
      //

        this.x = ko.computed(function(){  }, this);


      //---------------------------------
      // > computed v2
      //---------------------------------
      // - ko.computed( options )
      //
      //  * # read    | callback, срабатывающий при чтении св-ва
      //    # write   | callback, срабатывающий при записи в св-во
      //    # owner   | значение this в колбеках read / write
      //    # pure    | если true, то сделать эту выч.наб. pure
      //    # deferEvaluation   | не запускать read при загрузки (по умолчанию запускается)
      //    # disposeWhen       | callback, если вернёт true, выч.наб. отпишется от изменений
      //    # disposeWhenNodeIsRemoved  | ссылка на узел DOM, который если удалить, то выч.наб. отпишется от изменений
      //                                | - полезно, если этот узел был необходим.
      //

        this.x = ko.computed({

          read: function() {
            return 123;
          },

          write: function(value) {
            return value;
          },

          owner: this

        });


      //---------------------------------
      // > dispose()
      //---------------------------------
      // - Вручную отписаться от изменений.

        x.dispose();

      //---------------------------------
      // > extend(extenders)
      //---------------------------------
      // - Применяет указанный extender к вычисляемой наблюдаемой.
      // - Доступные extender'ы: http://knockoutjs.com/documentation/extenders.html



      //---------------------------------
      // > getDependenciesCount()
      //---------------------------------
      // - Возвращает кол-во св-в, от которых зависит эта выч.наблюдаемая

        var number = x.getDependenciesCount();


      //---------------------------------
      // > isActive()
      //---------------------------------
      // - Если у выч.наб. нет зависимостей, то она не активна.
      // - Если она не активна, эта функция возвращает false.

        var isActive = x.isActive();


      //---------------------------------
      // > peek()
      //---------------------------------
      // - Возвращает текущее значение вычисляемой наблюдаемой без создания связи.


      //---------------------------------
      // > subscribe( callback [,callbackTarget, event] )
      //---------------------------------
      // - Вручную подписать выч.наб. на изменения фигурирующих в callback наблюдаемых
      //

        x.subscribe(function(){  });


      //---------------------------------
      // > isInitial()
      //---------------------------------
      // - Используется внутри callback вычисляемой наблюдаемой.
      // - Возвращает true, если этот callback срабатывает 1-й раз в жизни.
      // - Иначе false.

        x.subscribe(function(){

          var y = isInitial();

        });


      //---------------------------------
      // > getDependenciesCount()
      //---------------------------------
      // - Используется внутри callback вычисляемой наблюдаемой.
      // - Возвращает кол-во обнаруженных зависимостей.

        x.subscribe(function(){

          var numOfDeps = getDependenciesCount();

        });


5.  Связки

  --------------------------------------
  Подоглавление:

    - Введение
    - Синтаксис и контекст связок
    - Стандартные типы связок:

      -- Текст и отображение
      ----------------------

          # visible | связь видимости DOM-эл-та (display: none) со св-вом модели (true/false)
          # text    | связь внутреннего текста эл-та со св-вом модели
          # html    | связь внутреннего html эл-та со св-вом модели
          # css     | связь атрибута class DOM-эл-та со св-вом модели
          # style   | связь атрибута style DOM-эл-та со св-вом модели
          # attr    | связь любого атрибута DOM-эл-та со св-вом модели

      -- Управление потоком выполнения
      --------------------------------

          # foreach   | послед-но дублирует innerHTML DOM-эл-та для кажд.элем.связанного массива в св-ве модели
          # if        | определяет, будет ли DOM-элемент отображён, или нет
          # ifnot     | полный аналог связки if, только инвертирует результат
          # with      | назначает указанный контекст внутри DOM-элемента-контейнера
          # component | вставляет указанный компонент в DOM-элемент, и передаёт ему парамтеры

      -- События и поля формы
      -----------------------

          # click           | связь события click на DOM-элементе с функцией-обработчиком
          # event           | связь указанных событий на DOM-элементе с функциями-обработчиками
          # submit          | связывает событие submit на форме с функцией-обработчиком
          # enable          | связывает CSS-св-во enable элемента со св-вом модели (true/false)
          # disable         | тоже самое, что enable, только с инвертированным значением
          # value           | связывает атрибут value DOM-эл-та со св-вом модели
          # textInput       | аналог value, только модель обновляется мгновенно, без потери фокуса
          # hasFocus        | связывает наличие фокуса у DOM-эл-та со св-вом модели (true/false)
          # checked         | связывает атрибут checked чекбоксов и радиокнопок со св-вом модели (true/false)
          # options         | связывает опции в select со св-вом модели
          # selectedOptions | связывает выбранные опции в multi-select со св-вом модели
          # uniqueName      | обеспечивает не пустой атрибут name у связанного DOM-элемента

    - Кастомные связки

  --------------------------------------

  > Введение
    - Св-во модели можно связать с элементом DOM.
    - Тип связки определяет, как будет влиять значение св-ва модели на эл-т DOM.
    - Типы связок бывают стандартные и кастомные (пользовательские).
    - В этом разделе подробно рассмотрим указанные темы.

  > Синтаксис и контекст связок

    --------------------------------------
    Подоглавление:

      - Введение
      - Синтаксис
      - Контексты

    --------------------------------------

    > Введение
      - Связка осуществляется с помощью польз.атрибута data-bind.
      - Здесь будет в деталях описан синтаксис осуществления связки.
      - Также здесь будут описаны контексты связок.
      - Контексты - это объекты с данными из модели, доступные из data-bind.

    > Синтаксис

      > В общем
        - Связка производится в польз.атрибуте data-bind.
        - Синтаксис состоит из 2 частей - имени из начения связки.
        - В общем виде:

            <div data-bind="[имя связки]: [значение связки]">

        - В одном data-bind может быть не ограниченное число связок.
        - Они должны быть разделены между собой запятыми.
        - Например:

            div data-bind="[имя]: [значение], [имя]: [значение]">

        - Внутри "" может быть сколько угодно пробелов, они не учитываются.
        - Например:

            <div data-bind="[имя]   : [значение]   ">

      > Имя связки
        - Имя связки должно соответствовать зарегистрированному типу связки.
        - Это либо один из стандартный типов, либо кастомный пользовательский тип.
        - В противном случае knockout проигнорирует связку без предупреждений.

      > Значение связки
        - Это может быть: значение / переменная. Иначе говоря, любое JS-выражение.
        - Также это может быть callback, возвращающая значение / переменную.
        - Если значени связки не правильное, knockout тормознёт и вернёт ошибку.
        - Примеры правильных значений:

          - Переменная
              <div data-bind="visible: shouldShowMessage">...</div>


          - Выражение (результат которого - значение)
              <span data-bind="text: price() > 50 ? 'expensive' : 'cheap'"></span>.


          - Сравнение, содержащее функцию
              <button data-bind="enable: parseAreaCode(cellphoneNumber()) != '555'">...</button>


          - Анонимная функция
              <div data-bind="click: function (data) { myFunction('param1', data) }">...</div>


          - Простой объект-литерал
              <div data-bind="with: {emotion: 'happy', 'facial-expression': 'smile'}">...</div>

        - Можно опустить значение при объявлении связки.
        - Тогда данная связка получит значение undefined.
        - Например:

            <span data-bind="text">Some text</span>


    > Контексты
      - В [значении связки] могут быть доступны некоторые доп. объекты с данными.
      - Эти объекты официальное руководство называет контекстами связки.
      - KO автоматически создаёт и контролирует иерархию контекстов связок.
      - Корнем этой иерархии является объект-модель, переданный KO при его активации.

        ----------------------------------
        Вот список доступных контекстов:

          > $parent         | Ссылка на объект с родительским контекстом в иерархии
          > $parents        | Массив родительских контекстов
          > $root           | Ссылка на объект-модель, переданный KO при его активации
          > $data           | Эта переменная содержит текущий контекст связывания
          > $index          | [только для foreach] Это номер i того эл-та массива, который является текущим контекстом
          > $parentContext  | Ссылка на родительский контекст относ.текущего в иерархии
          > $rawData        | Почти тоже самое, что $data
          > $context        | Ссылка на объект текущего контекста
          > $element        | Ссылка на DOM-элемент, к которому относится связка

        ----------------------------------

        //---------------------------------
        // > $parent
        //---------------------------------
          - Ссылка на объект с родительским контекстом в иерархии.
          - В корневом контексте $parent будет содержать undefined.

              <h1 data-bind="text: name"></h1>

              <div data-bind="with: manager">

                  <!-- Теперь мы находимся внутри вложенного контекста -->
                  <span data-bind="text: name"></span> is the
                  manager of <span data-bind="text: $parent.name"></span>

              </div>


        //---------------------------------
        // > $parents
        //---------------------------------
          - Массив родительских контекстов.
          - $parents[0] - это тоже самое, что $parent.
          - $parents[0] - родительский для $parent контекст.
          - И так далее.


        //---------------------------------
        // > $root
        //---------------------------------
          - Ссылка на объект-модель, переданный KO при его активации.
          - Это, по сути, корневой контекст.
          - $root эквивалентен $parents[$parents.length - 1].


        //---------------------------------
        // > $data
        //---------------------------------
          - Эта переменная содержит текущий контекст связывания
          - Очень актуально при работе с foreach и with

          - Простой пример с with.
          - Здесь $data содержит ссылку на объект {ivan: 10, petro: 20}:

              <div data-bind="with: {ivan: 10, petro: 20}">
                <span data-bind="text: $data.ivan"></span>
                <span data-bind="text: $data.petro"></span>
              </div>

          - Другой простой пример с foreach.
          - Здесь $data содержит ссылку на эл-т i массива ['cats', 'dogs', 'fish'].
          - Т.Е. в foreach на каждом проходе цикла контекст - это i-ый эл-т массива.

              <ul data-bind="foreach: ['cats', 'dogs', 'fish']">
                  <li><span data-bind="text: $data"></span></li>
              </ul>

          - Близкий к практике пример с with:

            - Представим такую модель:

                var Model = {
                  constructor: {
                    var self = this;

                    self.me = {name: 'Николай', age: 15};

                    self.persons = {
                      ivan: {name: 'Иван', age: 18},
                      petro: {name: 'Петро', age: 28}
                    };

                    return self;
                  }
                };

            - Активируем её объектом KO:

                ko.applyBindings(Object.create(Model).constructor());

            - И имеем такое представление:

              // Здесь мы в контексте объекта-модели
              // - Т.Е. в значении data-bind можно обращаться к ..
              //   его свойствам без квалификации.
              <p data-bind="text: me.name"></p>
              <p data-bind="text: me.age"></p>

              <div data-bind="with: persons">

                // Здесь мы в контексте объекта persons
                // - Т.Е. в значении data-bind можно обращаться к ..
                //   его свойствам без квалификации.
                <p data-bind="text: ivan.name"></p>
                <p data-bind="text: petro.name"></p>

              </div>



        //---------------------------------
        // > $index
        //---------------------------------
          - ! Работает только при использовании со связкой foreach
          - Это номер i того эл-та массива, который является текущим контекстом.
          - Например:

              <ul data-bind="foreach: ['cats', 'dogs', 'fish']">
                <li><span data-bind="text: $index"></span></li>
              </ul>

          - В итоге будет выведен список из 3-х элементов li.
          - Первый будет содержать "0". Второй: "1". Третий: "2".



        //---------------------------------
        // > $parentContext
        //---------------------------------
          - Ссылка на родительский контекст относ.текущего в иерархии.


        //---------------------------------
        // > $rawData
        //---------------------------------
          - В большинстве случаев тоже самое, что $data.


        //---------------------------------
        // > $context
        //---------------------------------
          - Ссылка на объект текущего контекста.
          - Например, в foreach, это будет соответствующий массив значений.
          - В то время, как $data в foreach это ссылка на i-й эл-т массива.


        //---------------------------------
        // > $element
        //---------------------------------
          - Ссылка на DOM-элемент, к которому относитсясвязка.
          - Пример использования:

              <div id="item1" data-bind="text: $element.id"></div>


  > Стандартные типы связок

    --------------------------------------
    -- Текст и отображение
    --------------------------------------
    Подоглавление:

      - Введение
      - Типы связок

    --------------------------------------

    > Введение
      - Здесь описаны типы связок для контроля текста и отображение DOM-элементов.
      - visible, text, html, css, style, attr.

    > Типы связок:

    //---------------------------------
    // # visible
    //---------------------------------
    // - связь видимости DOM-эл-та (display: none) со св-вом модели (true/false)

      > Автоматическое обновление видимости DOM-элемента
        - Если значение связки содержит наблюдаемую.
        - Тогда вид-ть DOM-эл-та будет обновл. при каждом изменении наблюдаемой.

      > Использование условий и callback-функций
        - Очень удобно в кач-ве значения в data-bind использовать их.
        - Логика функции, например, может зависеть от различных наблюдаемых модели.

      > Практика
        - Рассмотрим пример, где связка типа visible использована для валидации.
        - Используем такую модель:

            var Model = {

              constructor: function (){
                var self = this;

                self.value = ko.observable('Иван');
                self.isVisible = function() {

                  // Если в input введено число, вернуть true
                  var reg = /\d+/i;
                  if(reg.test(self.value())) return true;

                  // Иначе вернуть false
                  return false;
                };

                return self;
              }

            };

        - Активируем KO экземпляром этой модели:

            ko.applyBindings(Object.create(Model).constructor());

        - А вот так выглядит html:

            <input type="text" data-bind="value: value">
            <p style="color: #f00" data-bind="visible: !isVisible()">Введено не число!</p>

        - Если в input ввести не число, блок с предупреждением становится видимым.
        - А если ввести число - не видимым.


    //---------------------------------
    // # text
    //---------------------------------
    // - связь внутреннего текста эл-та со св-вом модели

      > Информация
        - Чаще всего используется в таких эл-тах, как p / span.
        - Но вообще связку text можно использовать с любым DOM-элементом.
        - Тест из св-ва модели записывается в текстовый узел внутри DOM-элемента.
        - Если св-во модели наблюдаемое, то при его изменении DOM-эл.тоже меняется.
        - Значение связки автоматически приводится к строке (toString()).

      > Использование условий и callback-функций
        - Очень удобно в кач-ве значения в data-bind использовать их.
        - Логика функции, например, может зависеть от различных наблюдаемых модели.

      > Безопасность
        - В св-во с этой связкой безопасно пихать любой текст без проверки.
        - Потому что оно не записывает значение в innerHTML DOM-элемента.
        - А записывает его в текстовый узел, где любые теги бесполезны.

      > Безконтейнерный синтаксис
        - Иногда нужно вставить текст в такой эл-т, где запрещены внут. теги.
        - И сделать это нам надо непременно с помощью связки text.
        - Например, хотим мы проделать такую штуку:

            <select data-bind="foreach: items">

              <option>
                <span data-bind="text: name"></span>
              </option>

            </select>

        - Но нас ждёт облом, т.к. внутри option вставлять эл-ты запрещено.
        - В этом случае самое время воспользоваться безконтейнерным синтаксисом.
        - Он основан на комментариях, и позволяет связать текстовый узел и св-во модели:

            <select data-bind="foreach: items">

              <option>
                <!--ko text: name--><!--/ko-->
              </option>

            </select>

      > Практика
        - См.выше пример для visible.


    //---------------------------------
    // # html
    //---------------------------------
    // - связь внутреннего html эл-та со св-вом модели

      > Информация
        - Используется, если значение связки, это строка c HTML-разметкой.
        - Значение связки записывается в innerHTML связанного DOM-элемента.

      > Как работает
        - Сначала KO удаляет всё старое содержимое innerHTML DOM-элемента.
        - А затем вставляет туда значение из связки.
        - Перед вставкой значение из связки приводится к строке (toString()).

      > Если связанное св-во модели наблюдаемое
        - То innerHTML связанного DOM-элемента будет меняться при изменении значения св-ва.
        - Это прикольно, можно таким образом манипулировать HTML-разметкой.
        - Всего-лишь изменяя строку с HTML-разметкой в св-ве модели.

      > Безопасность
        - Значение связки следует перед вставкой тщательно проверять.
        - Особенно, если оно зависит каким-то образом от пользовательского ввода.
        - Если в этом значении окажется какой-нибудь script, он исполнится.
        - Короче говоря, надо тщательно очищать значение связки от скриптов.

      > Практика
        - Модель:

            var Model = {

              constructor: function (){
                var self = this;

                self.myHtml = ko.observable('<div style="width: 300px; height: 300px; color: #f00; box-shadow: 0 0 10px RGBA(0,0,0,.3)">Привет!</div>');

                return self;
              }

            };

        - Активируем модель:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <textarea type="text" data-bind="value: myHtml" rows="10" cols="60"></textarea>
            <div data-bind="html: myHtml"></div>

        - В этом примере можно вводить любой текст в textarea.
        - Она связана связкой text со свойством модели myHtml.
        - А ещё с этим св-вом связкой html связан эл-т div.
        - Редактируя значение в textarea, ты редактируешь HTML-разметку внутри div.
        - Получается этакий редактор html-разметки онлайн.


    //---------------------------------
    // # css
    //---------------------------------
    // - связь атрибута class DOM-эл-та со св-вом модели

      > Информация
        - Этот тип связи добавляет/удаляет классы связанному DOM-элементу.

      > Как работает
        - В качестве значения связки выступает JS-объект:

            {
              [имя класса]: [выражение true/false],
              [имя класса]: [выражение true/false],
              ...
            }

        - Если выражение возвращает true, то класс добавляется DOM-элементу.
        - Если выражение возвращает false, то класс удаляется у DOM-элемента.

      > Динамическая манипуляция классами
        - Можно сделать [выражение] зависимым от каких-либо наблюдаемых.
        - Тогда при любом их изменении, решение о наличие класса принимается заново.

      > Динамические имена классов
        - Можно сделать имена классов в объекте выше наблюдаемыми.
        - А сам объект поместить в вычисляемую наблюдаемую.
        - Тогда можно будет динамически менять имена задействованных классов.

      > Пример
        - Модель:

            var Model = {

              constructor: function (){
                var self = this;

                self.class1State = ko.observable(false);
                self.class2State = ko.observable(false);
                self.cssObject = ko.computed(function(){

                    return {
                      ivan: self.class1State(),
                      petro: self.class2State()
                    }

                });

                self.text = ko.computed(function(){

                  // "Дотронемся" до этих наюлюдаемых.
                  // - Тогда при их обновлении text тоже будет обновлятсья.
                  var x = self.class1State() +
                          self.class2State();

                  // Вернём содержимое атрибута classes связанного элемента DIV.
                  return document.getElementById('classes').className;

                });


                return self;
              }

            };

        - Активируе KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p>Класс ivan: <input type="checkbox" data-bind="checked: class1State"></p>
            <p>Класс petro: <input type="checkbox" data-bind="checked: class2State"></p>

            <div>
              <span><i>Классы элемента вот этого div: </i></span>
              <div class="lena" id="classes" data-bind="css: cssObject, text: text" style="width: 300px; height: 250px; background-color: #eee; font-size: 20px; text-align: center; line-height: 250px; box-shadow: 0 0 10px RGBA(0,0,0,.3)"></div>
            </div>

        - В этом примере можно переключать туда-сюда чекбоксы.
        - Этим самым для связ-го DIV добавляется/извлекается соотв.класс.


    //---------------------------------
    // # style
    //---------------------------------
    // - связь атрибута style DOM-эл-та со св-вом модели

      > Информация
        - Позволяет использовать некую логику для манипуляции стилями связанного эл-та.
        - Если надо манип-ть не прямо стилями, а классами, то см. связку типа css.

      > Как работает
        - В качестве значения связки выступает JS-объект:

            {
              [имя стиля]: [значение стиля],
              [имя стиля]: [значение стиля],
              ...
            }

        - Применяются все стили, которые присутствуют в этом объекте.
        - Стили записываются в атрибут style связанного DOM-элемента.
        - Стили вроде font-style надо писать, как fontStyle.

      > Практика
        - Есть такая модель:

              var Model = {

                constructor: function (){
                  var self = this;

                  self.class1State = ko.observable(false);
                  self.cssObject = ko.computed(function(){

                      if(self.class1State())
                        return { backgroundColor: '#aaa'};

                      else
                        return { backgroundColor: '#eee' };

                  });

                  return self;
                }

              };

        - Активируе KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p><input type="checkbox" data-bind="checked: class1State"> - Сделать фон связанного эл-та DIV серым</p>
            <div data-bind="style: cssObject" style="width: 300px; height: 250px; background-color: #eee; font-size: 20px; text-align: center; line-height: 250px; box-shadow: 0 0 10px RGBA(0,0,0,.3)"></div>

        - В итоге с помощью checkbox можно переключать цвет фона связанного div.


    //---------------------------------
    // # attr
    //---------------------------------
    // - связь любого атрибута DOM-эл-та со св-вом модели

      > Информация
        - Тип связки attr является универсальным инструментом.
        - Она позволяет связать любой атрибут связанного DOM-эл-та со св-вом модли.

      > Как работает
        - В качестве значения связки выступает JS-объект:

            {
              [имя атрибута]: [значение атрибута],
              [имя атрибута]: [значение атрибута],
              ...
            }

        - Применяются все атрибуты, присутствующие в этом объекте.
        - Атрибуты, в который присутствует тире, нельзя записывать так:

            {
              data-something: 'ivan'
            }

        - Поскольку имя переменной в JS не может содержать тире.
        - В таких случаях имя надо заключать в кавычки, вот так:

            {
              "data-something": 'ivan'
            }


      > Практика
        - Модель:

              var Model = {

                constructor: function (){
                  var self = this;

                  self.imageUrl = ko.observable('http://artmmuseum.ru/wp-content/uploads/2013/08/Widescreen_Flag_of_Russia_021276_.jpg');
                  self.attrs = ko.computed(function(){

                    return {
                      "src": self.imageUrl
                    };

                  });

                  return self;
                }

              };

        - Активируе KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p><input size="100" type="text" data-bind="value: imageUrl"> - введи URL картинки</p>
            <img data-bind="attr: attrs" style="width: 800px; height: 500px; box-shadow: 0 0 10px RGBA(0,0,0,.3)">

        - В этом примере в input можно вводить URL-картинки.
        - При этом input связан со свойством модели imageUrl.
        - А атрибут src DOM-эл-та img тоже связан с imageUrl.
        - Поэтому можно на лету ввести другой URL, и картинка поменяется.


    --------------------------------------
    -- Управление потоком выполнения
    --------------------------------------
    Подоглавление:

      - Введение
      - Типы связок

    --------------------------------------

    > Введение
      - Здесь описаны типы связок для контроля потока отображения DOM-элементов.
      - foreach, if, ifnot, with, component.

    > Типы связок:

    //---------------------------------
    // # foreach
    //---------------------------------
    // - послед-но дублирует innerHTML DOM-эл-та для кажд.элем.связанного массива в св-ве модели

      ------------------
      Подоглавление:

        - Что в качестве значения
        - Как работает
        - Наглядный пример
        - Как сделать, чтобы при изменении связ-го массива менялся и связ.DOM-эл-т
        - Контексты для использования с foreach
        - Дать псевдоним текущему контексту (== $data)
        - Использование foreach без контейнерного элемента

      ------------------

      > Что в качестве значения

        # Вариант №1
          - В качестве значения связки выступает массив.
          - Как правило, это массив JS-объектов.

              [
                {property: value},      // 0-ой элемент
                {property: value},      // 1-ый элемент
                {property: value},      // 2-й элемент
                ...
              ]

        # Вариант №2
          - Вот такой вот объект с опциями:

                {
  Обязательная*   data: [массив],           // (обязательно) данные для foreach
                  as: [строка],             // имя псевдонима для $data
                  includeDestroyed: [1/0],  // показывать ли destroyed-элементы
                  afterRender: [callback],  // выполняется после каждой i-й отрисовки
                  afterAdd: [callback],     // выполнится после отрисовки при добавлении нового объекта в data
                  beforeRemove: [callback], // вып-ся после удаления элемента из data, но до изменений в DOM
                  beforeMove: [callback],   // вып-ся после изменения позиции эл-та в data, но до изменений в DOM
                  afterMove: [callback]     // вып-ся после изменения позиции эл-та в data, и после изменений в DOM
                }

          - Подробнее о некоторых опцииях:
            # includeDestroyed
              - По умолчанию foreach не отображает destroyed-элементы.
              - Таковыми считаются те элементы-объекты, у которых есть св-во:

                  _destroy == true

              - Например, в этом массиве объектов:

                  {
               0    {name: 'Иван', age: 18},
               1    {name: 'Пётр', age: 28, _destroyed: true},
               2    {name: 'Вася', age: 38}
                  }

              - 1-й элемент считается destroyed (мягко удалённым).

            # afterRender, afterAdd, beforeRemove, beforeMove, afterMove
              - Эти опции предназначены для организации анимации.
              - Для всего прочего поведение автор не советует их использовать.
              - А советует вместо этого использовать кастомные связки.

      > Как работает
        - Сохраняет содержимое innerHTML связанного DOM-объекта в переменную.
        - Удаляет содержимое innerHTML связанного DOM-объекта.
        - Отрисовывает innerHTML объекта в контексте 0-го объекта связанного массива.
        - Отрисовывает innerHTML объекта в контексте 1-го объекта связанного массива.
        - Отрисовывает innerHTML объекта в контексте 2-го объекта связанного массива.
        ...
        - Следующая отрисовка добавляется в конец предыдущей.

      > Наглядный пример
        - Вот модель. В ней связанное св-во - users.
        - Оно представляет из себя массив объектов-пользователей.

              var Model = {

                constructor: function (){
                  var self = this;

                  self.users = [
                    {name: 'ivan', age: 18},
                    {name: 'petro', age: 28},
                    {name: 'lena', age: 38}
                  ];

                  return self;
                }

              };

        - Вот связанный DOM-элемент.

              <div data-bind="foreach: users">

                <!-- Это место отрисуется 3 раза
                     - 1-й раз в контексте объекта {name: 'ivan', age: 18}
                     - 2-й раз в контексте объекта {name: 'petro', age: 28}  -->
                     - 3-й раз в контексте объекта {name: 'lena', age: 38}  -->
                <p data-bind="text: name"></p>
                <p data-bind="text: age"></p>

              </div>

        - Как будет выглядеть он после отрисовки:

              <div data-bind="foreach: users">

                <p data-bind="text: name">ivan</p>
                <p data-bind="text: age">18</p>

                <p data-bind="text: name">petro</p>
                <p data-bind="text: age">28</p>

                <p data-bind="text: name">lena</p>
                <p data-bind="text: age">38</p>

              </div>

      > Как сделать, чтобы при изменении связ-го массива менялся и связ.DOM-эл-т
        - Для этого достаточно сделать связанный массив наблюдаемым.
        - Рассмотрим с использованием примера выше.
        - Допустим, массив users является наблюдаемым:

              self.users = ko.observableArray([
                {name: 'ivan', age: 18},
                {name: 'petro', age: 28},
                {name: 'lena', age: 38}
              ]);

        - И допустим, вот так выглядит уже отрисованная HTML-разметка:

              <div data-bind="foreach: users">

                <p data-bind="text: name">ivan</p>
                <p data-bind="text: age">18</p>

                <p data-bind="text: name">petro</p>
                <p data-bind="text: age">28</p>

                <p data-bind="text: name">lena</p>
                <p data-bind="text: age">38</p>

              </div>

        - Удалим из users 2-й элемент - объект {name: 'lena', age: 38}.
        - Тогда из DOM соответствующие эл-ты тоже пропадут.
        - Вот так станет выглядеть отрисованная HTML-разметка:

              <div data-bind="foreach: users">

                <p data-bind="text: name">ivan</p>
                <p data-bind="text: age">18</p>

                <p data-bind="text: name">petro</p>
                <p data-bind="text: age">28</p>

              </div>

      > Контексты для использования с foreach

        > Напоминание
          - Ниже мы рассмотрим ряд контекстовых переменных.
          - Использовать их можно внутри data-bind в html-разметке.
          - Рассматривать мы их будет в контексте использования с foreach.

        > Переменные контекста

          # $data     | Эта переменная содержит текущий контекст связывания
            - Содержит i-ый контекст связывания.
            - Используем для наглядной иллюстрации пример выше.
            - На 0-й итерации отрисовки $data содержал ссылку на объект:

                 {name: 'ivan', age: 18}

            - На 1-й итерации отрисовки $data содержал ссылку на объект:

                 {name: 'petro', age: 28}

            - На 2-й итерации отрисовки $data содержал ссылку на объект:

                 {name: 'lena', age: 38}

            - Обратиться к св-вам объекта из data-bind можно было так:

                <div data-bind="foreach: users">

                  <!-- это синонимы, name == $data.name -->
                  <p data-bind="text: name"></p>
                  <p data-bind="text: $data.name"></p>

                </div>

            - Поэтому $data в foreach актуальна, когда связ.массиве вместо ..
            - .. объектов лежат литералы. Тогда доступ к ним - через $data.

          # $index    | [только для foreach] Это номер i того эл-та массива, который является текущим контекстом
            - Содержит номер текущей итерации foreach (0 / 1 / ..)

          # $parent   | Ссылка на объект с родительским контекстом в иерархии
            - Если надо получить доступ к род.контексту, $parent поможет.
            - Если foreach применён в контексте $root, то $parant == $root.

      > Дать псевдоним текущему контексту (== $data)
        - Можно дать псевдоним переменной контекста $data.
        - Не знаю, зачем это надо, но такая возможность есть.
        - Вот пример:

            <ul data-bind="foreach: { data: users, as: 'user' }">

              <!-- $data.name == user.name == name -->
              <p data-bind="text: $data.name"></p>
              <p data-bind="text: user.name"></p>
              <p data-bind="text: name"></p>

            </ul>

      > Использование foreach без контейнерного элемента
        - Иногда нужно применить foreach, но без контейнерного элемента.
        - Например, требуется отрисовать повторяющуюся разметку в body.
        - Но при этом не хочется цеплять на body foreach с его контекстом.
        - Это делается так:

            <!-- ko foreach: users -->
                <p data-bind="text: name"></p>
                <p data-bind="text: age"></p>
            <!-- /ko -->



    //---------------------------------
    // # if
    //---------------------------------
    // - определяет, будет ли DOM-элемент отображён, или нет

      > Информация
        - По эффекту связка if аналогична связке visible.
        - Но по внутреннему механизму у них есть существенное отличие.
        - visible: false присваивает контейнерному элементу display: none.
        - if: false делает так, что контейнерный эл-т не присутствует в DOM.

      > Как работает
        - Если if: true, то элемент-контейнер присутствует в DOM.
        - Если if: false, то элемент-контейнер НЕ присутствует в DOM.

      > Использование if без контейнерного элемента
        - Иногда нужно применить if, но без контейнерного элемента.
        - Это можно сделать так:

            <!-- ko if: [выражение] -->
                <p>Привет!</p>
            <!-- /ko -->

      > Практика
        - Модель:

            var Model = {

              constructor: function (){
                var self = this;

                self.displayMessage = ko.observable(false);

                return self;
              }

            };

        - Активируе KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p><input type="checkbox" data-bind="checked: displayMessage"> - выключатель сообщения</p>
            <p data-bind="if: displayMessage">Сообщение</p>

        - Итого, с помощью этого чекбокса мы можем управлять присутствием ...
        - ... DOM-элемента в разметке.


    //---------------------------------
    // # ifnot
    //---------------------------------
    // - полный аналог связки if, только инвертирует результат

      > Информация
        - Если ifnot: true, то элемент-контейнер НЕ присутствует в DOM.
        - Если ifnot: false, то элемент-контейнер присутствует в DOM.


    //---------------------------------
    // # with
    //---------------------------------
    // - назначает указанный контекст внутри DOM-элемента-контейнера

      > Информация
        - С помощью with можно назначить любой контекст любому DOM-элементу.
        - Контексты могут быть не ограниченно вложенными друг в друга.

      > Использование widh без контейнерного элемента
        - Иногда хочется назначить контекст без контейнерного элемента.
        - Он будет действовать только в обозначенной зоне.
        - Вот, как это делается:

            <!-- ko with: someContext -->
                ...
            <!-- /ko -->

      > Практика:
        - Модель:

            var Model = {

              constructor: function (){
                var self = this;

                self.number = 10;
                self.context = {
                  number: 20
                };

                return self;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p data-bind="text: number"></p>    // 10

            <!-- ko with: context -->
              <p data-bind="text: number"></p>  // 20
            <!-- /ko -->


    //---------------------------------
    // # component
    //---------------------------------
    // - вставляет указанный компонент в DOM-элемент, и передаёт ему парамтеры

      > Информация
        - Здесь будет рассмотрено лишь использование связки component.
        - Сами же компоненты подробно рассмотрены в соответствующей главе.
        - Работает, начиная с KnockoutJS 3.2.

      > Синтаксис использования
        - Короткий:

            <div data-bind='component: "my-component"'></div>

        - Длинный (с передачей параметров)

            <div data-bind='component: {
                name: "shopping-cart",
                params: { mode: "detailed-list", items: productsList }
            }'></div>

      > Пример
        - Рассмотрим пример использования компонентов.
        - Создадим новый компонент:

            ko.components.register('message-editor', {
                viewModel: function(params) {
                    this.text = ko.observable(params && params.initialText || '');
                },
                template: 'Message: <input data-bind="value: text" /> '
                        + '(length: <span data-bind="text: text().length"></span>)'
            });

            ko.applyBindings();

        - Вот, как его можно использовать:

            <h4>First instance, without parameters</h4>
            <div data-bind='component: "message-editor"'></div>

            <h4>Second instance, passing parameters</h4>
            <div data-bind='component: {
                name: "message-editor",
                params: { initialText: "Hello, world!" }
            }'></div>

        - В результате будут созданы 2 элемента input.
        - В первом value == '', во втором value == "Hello, world!".

      > Использование компонента без элемента-контейнера
        - Без передачи параметров:

            <!-- ko component: "message-editor" -->
            <!-- /ko -->

        - С передачей параметров:

            <!-- ko component: {
                name: "message-editor",
                params: { initialText: "Hello, world!", otherParam: 123 }
            } -->
            <!-- /ko -->


    --------------------------------------
    -- События и поля формы
    --------------------------------------
    Подоглавление:

      - Введение
      - Типы связок

    --------------------------------------

    > Введение
      - Здесь описаны типы связок для работы с полями формы.
      - click, event, submit, enable, disable, value, textInput,
      - hasFocus, checked, options, selectedOptions, uniqueName

    > Типы связок:

    //---------------------------------
    // # click
    //---------------------------------
    // - связь события click на DOM-элементес функцией-обработчиком

      > Информация
        - Это тоже самое, что присвоить DOM-элементу обработчик события click.
        - Преимущество: возможность интеграции с моделью.

      > Параметры обработчика
        - KO передаст переменную с контекстом в обработчик 1-ым аргументом.
        - KO передаст объект-события в обработчик 2-ым параметром.

      > KO отменяет действия события click по умолчанию
        - Чтобы не отменял, надо вернуть true из обработчика.

      > KO по умолчанию отменяет всплытие события click
        - Чтобы не отменял, надо добавить в data-bind "clickBubble: false".

      > Пример:
        - Модель:

            var Model = {

              constructor: function() {
                var self = this;

                self.places = ko.observableArray(['Moscow', 'Ivanovo', 'Tver']);

                self.removePlace = function(place) {
                  self.places.remove(place);
                };

                return this;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <ul data-bind="foreach: places">
                <li>
                    <span data-bind="text: $data"></span>
                    <a href="#" data-bind="click: $parent.removePlace">Удалить</a>
                </li>
            </ul>

        - В этом примере при щелчке по эл-ту a запускается ф-ия removePlace.
        - Она удаляет соответствующий элемент из массива places.
        - А т.к. массив наблюдаемый, то и из DOM этот эл-т исчезает.


    //---------------------------------
    // # event
    //---------------------------------
    // - связь указанных событий на DOM-элементе с функциями-обработчиками

      > Информация
        - Это тоже самое, назначить обработчики обычным образом.
        - Преимущество: возможность интеграции с моделью.

      > Что принимает в качестве значения связки
        - Объект с событиями и соответствующими им функциями-обработчиками.
        - Такого вида:

            {
              [имя события без on]: [ссылка на функцию-обработчик],
              [имя события без on]: [ссылка на функцию-обработчик],
              [имя события без on]: [ссылка на функцию-обработчик],
              ...
            }

        - Функции могут быть не обязательно из модели.

      > Параметры обработчика
        - KO передаст переменную с контекстом в обработчик 1-ым аргументом.
        - KO передаст объект-события в обработчик 2-ым параметром.

      > KO отменяет действия события click по умолчанию
        - Чтобы не отменял, надо вернуть true из обработчика.

      > KO по умолчанию отменяет всплытие события click
        - Чтобы не отменял, надо добавить в data-bind "clickBubble: false".

      > Пример:
        - Модель:

            var Model = {

              constructor: function() {
                var self = this;

                self.detailsEnabled = ko.observable(false);

                self.enableDetails = function() {
                    self.detailsEnabled(true);
                };

                self.disableDetails = function() {
                    self.detailsEnabled(false);
                };

                self.eventsHandlersObj = {
                  mouseover: self.enableDetails,
                  mouseout: self.disableDetails
                };

                return this;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <div>
                <div data-bind="event: eventsHandlersObj">
                    Mouse over me
                </div>
                <div data-bind="visible: detailsEnabled">
                    Details
                </div>
            </div>

        - В этом примере с помощью KO мы назначили DOM-элементу 2 обработчика.
        - Для событий mouseover и mouseout.
        - При наведении мышки эл-т div с деталями становится видим.
        - А при уводе курсора мыши со связанного эл-та, div с деталями скрывается.


    //---------------------------------
    // # submit
    //---------------------------------
    // - связывает событие submit на форме с функцией-обработчиком

      > Информация
        - Это тоже самое, назначить обработчик обычным образом.
        - Преимущество: возможность интеграции с моделью.

      > KO отменяет действия события submit по умолчанию
        - То есть форма не отправляется на сервер при нажатии кнопки submit.
        - Чтобы не отменял, надо вернуть true из обработчика.

      > Параметры обработчика
        - KO передаст ссылку на DOM-элемент формы, как 1-й параметр в обработчик.

      > В чём преимущество submit перед click при работе с формами?
        - Почему просто не использовать click вместо submit?
        - Потому что submit перехватывает также некоторые доп.действия.
        - Например, при на жатии на enter на форме, submit тоже возбуждается.

      > Пример
        - Модель:

            var Model = {

              constructor: function(){
                var self = this;

                self.someHandler = function() {

                  alert('Форма отправлена');

                }

                return self;
              }

            }

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <form data-bind="submit: someHandler">
                <input type='text' placeholder="Имя">
                <input type='text' placeholder="Фамилия">
                <input type='text' placeholder="Возраст">
                <button type="submit">Submit</button>
            </form>

        - В этом примере при нажатии на кнопку submit срабатывает ф-ия someHandler.
        - Если навести фокус на поле формы и нажать enter, она тоже сработает.
        - При этом стандартное действие формы при нажатии на submit не срабатывает.


    //---------------------------------
    // # enable
    //---------------------------------
    // - связывает CSS-св-во enable элемента со св-вом модели (true/false)

      > Информация
        - Особенно полезно для элементов input, select, textarea.

      > Использование выражений и сравнений
        - В качестве значения для этой связки можно использовать выражения.
        - И сравнения тоже.

      > Пример
        - Модель:

            var Model = {

              constructor: function(){
                var self = this;

                self.hasCellphone = ko.observable(false);
                self.cellphoneNumber = ko.observable('');

                return self;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p>
                <input type='checkbox' data-bind="checked: hasCellphone" />
                I have a cellphone
            </p>
            <p>
                Your cellphone number:
                <input type='text' data-bind="value: cellphoneNumber, enable: hasCellphone" />
            </p>

        - В этом примере изначально поле для ввода номера не enabled.
        - CSS-св-во enabled этого поля можно переключать чекбоксом.
        - И чекбокс, и поле связаны со св-вом hasCellphone модели.
        - Св-во hasCellphone имеет 1 из 2 значений: true / false.


    //---------------------------------
    // # disable
    //---------------------------------
    // - тоже самое, что enable, только с инвертированным значением

      > Информация
        - Особенно полезно для элементов input, select, textarea.

      > Использование выражений и сравнений
        - В качестве значения для этой связки можно использовать выражения.
        - И сравнения тоже.


    //---------------------------------
    // # value
    //---------------------------------
    // - связывает атрибут value DOM-эл-та со св-вом модели

      > Информация
        - Особенно полезно при работе с эл-ми input, select, textarea.

      > Как работает
        - Если св-во модели является наблюдаемым:
          - Тогда синхронизация будет двусторонней.
          - Тогда когда поль-ль изменяет эл-т, св-вом модели тоже меняется.
          - И наоборот.
        - Если св-во модели не является наблюдаемым:
          - Тогда синхронизация будет односторонней.
          - При изменении связанного DOM-эл-та, св-во в модели тоже изменится.
          - При изменении св-ва модели, DOM-эл-т не изменится.

      > Стартовое значение
        - Допустим, мы педедали св-ву модели стартовое значение.
        - При старте value элемента будет заменено на это стартовое значение.

      > В каком момент происходит синхронизация?
        - В текстовых элементах при потере фокуса.
        - В чекбоксах и радио, сразу.

      > valueUpdate: как сделать, чтобы синхронизация происходила сразу
        - То есть нажал, скажем, клавишу, и сразу произошла синхронизация.
        - Без потери фокуса.
        - Для этого надо использовать дополнительную связку valueUpdate.
        - Она принимает следующие текстовые значения:

          # input
            - Есть ограничение по браузерам: IE9+.
            - Модель обновляется, как только значение input/textarea изменяется.
            - В случае с input, актуально использовать для input type='text'

          # keyup
            - Модель обновляется, как только пользователь отпускает кнопку.

          # keypress
            - Модель обновляется, как только пользователь нажимает кнопку.
            - Если он держит кнопку, то идёт непрерывный поток обновлений.

          # afterkeyDown
            - Есть ограничение: не работает в некоторых мобильных браузерах.
            - Обновляет модель, как только пользователь начал печатать символ.
            - Ловит событие keydown.

      > Синхронизация сразу для textarea и input type='text'
        - Если для этих элементов нужна синхронизация сразу после нажатия ..
        - .. то вместо valueUpdate автор рекомендует связку textInput.
        - Он говорит, что у неё меньше ограниений по браузерам.

      > Работа с select

        > Работа с объектами
          - Связка value в сочетании со связкой options очень полезны.
          - Это позволяет работать с объектами, а не с текстовыми значениями.
          - Подробнее об этом см. в описании связки options.

        > Связка valueAllowUnset
          - Это дополнительная (для value) связка.
          - Она нужна только при работе с элементами select.
          - Она указывает, что KO должен делать, если св-во модели, ..
          - .. связанное с value эл-та записать не входящее в список значение.

            # valueAllowUnset == false (по умолчанию)
              - KO не позволяет записать в модель такое значение.
              - Он возвращает предыдущее значение, которое есть в списке.

            # valueAllowUnset == true
              - KO позволяет записать в модель такое значение.

      > Использование связки value совместо со связкой checked
        - Допустим, в 1 data-bind мы используем и checked, и value связки.
        - Тогда value будет соотв. опции checkedValue связки checked.
        - Подробнее про checkedValue см. в описании связки checked.

      > Пример:
        - Модель:

            var Model = {

              constructor: function(){
                var self = this;

                self.name = ko.observable();
                self.description = ko.observable();

                return self;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p>
              <input type="text" data-bind="value: name, valueUpdate: 'keyup'" placeholder="Имя">
              <span data-bind="text: name"></span>
            </p>

            <p>
              <textarea data-bind="value: description, valueUpdate: 'keyup'" placeholder="Описашка"></textarea>
              <span data-bind="text: description"></span>
            </p>

        - В этом примере модель обновляется сразу, при вводе символа.
        - То есть она не ожидает потери фокуса текстовым эл-том для обновления.
        - В обычном случае обновление происходит при появлении события change.
        - А в данном примере, при появлении события keyup.


    //---------------------------------
    // # textInput
    //---------------------------------
    // - аналог value, только модель обновляется мгновенно, без потери фокуса

      > Информация
        - Связка textInput является аналогом value.
        - Но с тем отличием, что модель обновляется мгновенно, без потери фокуса.
        - textInput спроектирован специально для тех случаев, когда нужно мгновенное обновление.

      > Не использовать value и textInput вместе
        - Иначе будет каБум.

      > Практика
        - Рассмотрим тот же самый пример, что приведён для связки value.
        - В том примере для мгнов.обновл. использовали value вместе с valueUpdate.
        - А в этом примере вместо указанного дуэта используем textInput.
        - Модель:

            var Model = {

              constructor: function(){
                var self = this;

                self.name = ko.observable();
                self.description = ko.observable();

                return self;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <p>
              <input type="text" data-bind="textInput: name" placeholder="Имя">
              <span data-bind="text: name"></span>
            </p>

            <p>
              <textarea data-bind="textInput: description" placeholder="Описашка"></textarea>
              <span data-bind="text: description"></span>
            </p>

        - В этом примере модель обновляется сразу, при вводе символа.
        - То есть она не ожидает потери фокуса текстовым эл-том для обновления.
        - В обычном случае обновление происходит при появлении события change.


    //---------------------------------
    // # hasFocus
    //---------------------------------
    // - связывает наличие фокуса у DOM-эл-та со св-вом модели (true/false)

      > Как работает
        - Если значение св-ва модели true, то фокус у связанного DOM-эл-та есть.
        - Если значение св-ва модели false, то фокуса у связанного DOM-эл-та нет.

      > Для чего удобно использовать
        - Связка очень удобна для управления фокусом.

      > Практика
        - Модель:

            var Model = {

              constructor: function(){
                var self = this;

                self.isSelected = ko.observable();
                self.setIsSelected = function() {
                  self.isSelected(true);
                };

                return self;
              }

            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <input data-bind="hasFocus: isSelected" />
            <button data-bind="click: setIsSelected">Навести фокус программно</button>
            <span data-bind="visible: isSelected">Текстовое поле имеет фокус</span>

        - В этом примере фокус текстового поля связан со св-вом isSelected модели.
        - В то же время span с надписью через связку visible тоже связан с этим св-вом.
        - Т.О. когда у текст.поля есть фокус, рядом появляется надпись об этом.
        - А когда нет фокуса, то надпись исчезает.
        - Плюс есть кнопка, связанная связкой клик с методом setIsSelected модели.
        - Этот метод устанавливает isSelected == true, т.е. присваивает фокус текст.полю.


    //---------------------------------
    // # checked
    //---------------------------------
    // - связывает атрибут checked чекбоксов и радиокнопок со св-вом модели (true/false)

      > Для каких DOM-элементов актуально
        - Для input type='checkbox'.
        - Для input type='radio'.

      > Работа с checkbox'ами. Что принимает в качестве значения:

        # Вариант 1 - true/false
          - Принимает логическое значение.
          - Если true, значит присваивает DOM-элементу checked == true.
          - Если false, значит присваивает DOM-элементу checked == false.

        # Вариант 2 - массив.
          - Каждый чекбокс имеет какое-то значение value.
          - Так вот, checked может принимать вот такой массив:

              [
                значение value какого-то чекбокса,
                значение value какого-то чекбокса,
                ...
              ]

          - Чекбоксы, чьи значения value присутствуют в этом массиве ...
          - ... получат checked == true.
          - А чьи отсутствуют, получат checked == false.
          - Когда пользователь вкл/выкл чекбоксы, KO синхронизирует этот массив.

      > Работа с radiobutton'ами.

        > Значение для связки
          - Это должна быть строка.
          - Если строка == value этого эл-та radio, тогда checked == true.
          - Если строка != value этого эл-та radio, тогда checked == false.

        > Убедиться, что радиобутоны объеденены в группу
          - Только 1 радиобутон может быть выбран одновременно в группе.
          - Если нам нужно такое поведение, то надо убедиться, что они в 1 группе.
          - Для этого у всех радиобутонов должен быть атрибут name с 1 и тем же значением.

        > Что происходит, когда пользователь выбирает друг.радиобутон в группе
          - Связанное св-во в модели получает значение == value нов.выбранного радиобутона.

        > checkedValue - дополнительная опция
          - Если используется, то определяет значение value вместо соотв.атрибута.
          - Это полезно, если нужно, чтобы value было не строкой, а, скажем, объектом.
          - Или если надо назначать value динамически.
          - В примере ниже item-объекты (а не строки itemName) будут включены...
          - ... в массив chosenItems, когда соотв. чекбоксы будут включены.

            - html:

              <!-- ko foreach: items -->
                <input type="checkbox" data-bind="checkedValue: $data, checked: $root.chosenItems" />
                <span data-bind="text: itemName"></span>
              <!-- /ko -->

            - Модель:

              var Model = {
                constructor: function() {
                  var self = this;

                  self.items = ko.observableArray([
                      { itemName: 'Choice 1' },
                      { itemName: 'Choice 2' }
                  ]);
                  self.chosenItems = ko.observableArray();

                  return self;
                }
              }

        > Использование связки value совместо со связкой checked
          - Допустим, в 1 data-bind мы используем и checked, и value связки.
          - Тогда value будет соотв. опции checkedValue связки checked.

        > Практика с чекбоксами (значение true/false):
          - Модель:

              var Model = {

                constructor: function(){
                  var self = this;

                  self.checked = ko.observable(false);
                  self.text = ko.computed(function(){

                    if(self.checked()) return 'чекбокс включён';
                    else return 'чекбокс выключен';

                  });

                  return self;
                }

              };

          - Активируем KO экземпляром модели:

              ko.applyBindings(Object.create(Model).constructor());

          - html:

              <input type="checkbox" data-bind="checked: checked"> -
              <span data-bind="text: text"></span>

          - В этом примере демонстрируется работа связки checked.
          - Соотв. св-во модели связано с чекбоксом, и меняется при его переключении.
          - Также от него зависит вычисляемая фукнция text.
          - Если чекбокс включён, она возвращает 1 сообщение, а если выключен другое.
          - Функция text связана связкой text со span, при переключении чекбокса сообщение меняется.


        > Практика с чекбоксами (значение - массив):
          - Модель:

              var Model = {

                constructor: function(){
                  var self = this;

                  self.checkboxes = ko.observableArray([
                    'one',
                    'two',
                    'three',
                    'four',
                    'five'
                  ]);

                  return self;
                }

              };

          - Активируем KO экземпляром модели:

              ko.applyBindings(Object.create(Model).constructor());

          - html:

              <hr>

              <p><input type="checkbox" value="one" data-bind="checked: checkboxes"> - value="one"</p>
              <p><input type="checkbox" value="two" data-bind="checked: checkboxes"> - value="two"</p>
              <p><input type="checkbox" value="three" data-bind="checked: checkboxes"> - value="three"</p>
              <p><input type="checkbox" value="four" data-bind="checked: checkboxes"> - value="four"</p>
              <p><input type="checkbox" value="five" data-bind="checked: checkboxes"> - value="five"</p>

              <hr>

              <p>Содержание массива checkboxes:</p>
              <ul data-bind="foreach: checkboxes">
                <li data-bind="text: $data"></li>
              </ul>

          - В данном примере в качестве значения использован массив значений value чекбоксов
          - Всё устроено так, что все чекбоксы, value которых в этом массиве, имеют checked == true
          - При переключении чекбоксов KO автоматически синхронизирует массив
          - Что и наглядно продемонстрировано в этом примере

        > Практика с радиобутонами:
          - Модель:

              var Model = {

                constructor: function(){
                  var self = this;

                  self.radioValue = ko.observable('two');

                  return self;
                }

              };

          - Активируем KO экземпляром модели:

              ko.applyBindings(Object.create(Model).constructor());

          - html:

              <hr>

              <p><input name="group1" type="radio" value="one" data-bind="checked: radioValue"> - value="one"</p>
              <p><input name="group1" type="radio" value="two" data-bind="checked: radioValue"> - value="two"</p>
              <p><input name="group1" type="radio" value="three" data-bind="checked: radioValue"> - value="three"</p>
              <p><input name="group1" type="radio" value="four" data-bind="checked: radioValue"> - value="four"</p>
              <p><input name="group1" type="radio" value="five" data-bind="checked: radioValue"> - value="five"</p>

              <hr>

              <p>Содержание св-ва radioValue модели: </p>
              <span data-bind="text: radioValue"></span>

          - Здесь продемонстрирована работа связки checked c radio-бутонами


    //---------------------------------
    // # options
    //---------------------------------
    // - связывает опции в select со св-вом модели

      > Что принимает в качестве значения

        # Вариант №1: массив строк
          - Это самый простой вариант.
          - Когда св-во модели содержит простой массив строк.
          - Эти строки и используются в связнном select в качестве опций.
          - Пример:

            - Модель:

                var Model = {
                  constructor: function(){
                    var self = this;

                    self.countries = ko.observableArray(['RF', 'USA', 'UK']);

                    return self;
                  }
                };

            - Активируем KO экземпляром модели:

                ko.applyBindings(Object.create(Model).constructor());

            - Представление

                <p>
                  Выбери страну:
                  <select data-bind="options: countries"></select>
                </p>

        # Вариант №2: массив объектов
          - Это продвинутый вариант.
          - Когда св-во модели содержит массив JS-объектов, а не строк.
          - С помощью различных опций мы можем указать, какое св-во для чего использовать.
          - Доступные опции:

            # optionsCaption
              - Иногда хочется, чтобы в select в начале ни 1 опция не была выбрана.
              - Обычно, для этого создают какую-нибудь "вспомогательную" опцию.
              - Вроде: "Выбери элемент...", "Выбери страну..." и т.д.
              - Так вот, в KO для создания такой вспом.опции есть optionsCaption.
              - Например: "optionsCaption: 'Выбери страну...'"
              - optionsCaption имеет value == undefined.

            # optionsText
              - Актуальна, если значением options выступает массив объектов.
              - И каждый объект представляет в select одну из опций.
              - optionsText позволяет указать имя св-ва в объекте ..
              - .. значение которого будет использовано в качестве текста в соотв.опции.
              - См. пример ниже.

            # optionsValue
              - Актуальна, если значением options выступает массив объектов.
              - И каждый объект представляет в select одну из опций.
              - optionsValue позволяет указать имя св-ва в объекте ..
              - .. значение которого будет использовано в качестве значения соотв.опции.
              - См. пример ниже.

            # optionsIncludeDestroyed
              - Пометить опцию, как "мягко" удалённую.
              - Такие опции KO не будет отображать в select.

            # optionsAfterRender
              - Задать для опции callback-функцию.
              - Она будет срабатывать кажд.раз при вставки опции в select.

            # selectedOptions
              - Вообще, это отдельная связка, она описана ниже.
              - Актуально для multi-select'а.
              - В качестве значения эта связка принимает массив.
              - Массив содержит все выбранные опции (строки / объекты).

            # valueAllowUnset
              - Что, если поставить value в модели, не отвечающее ни 1 опции в select?
              - valueAllowUnset как раз и позволяет это настроить.
              - По умолчанию, KO автоматом изменит value модели на что-нибудь валидное.
              - Но если поставить valueAllowUnset = true, то поведение изменится.
              - Тогда KO добавить новое значение в качестве опциии в select.

          - Пример:
            - Модель:

                var Model = {
                  constructor: function(){
                    var self = this;

                    self.employee = ko.observableArray([
                      {name: 'Иван', id: 1},
                      {name: 'Петр', id: 2},
                      {name: 'Вася', id: 2}
                    ]);
                    self.selected = ko.observable();

                    return self;
                  }
                };

            - Активируем KO экземпляром модели:

                ko.applyBindings(Object.create(Model).constructor());

            - Представление

                <p>
                  Выбери сотрудника:
                  <select data-bind=" options: employee,
                                      optionsText: 'name',
                                      value: selected,
                                      optionsCaption: 'Выбери сотрудника...'"></select>
                </p>


    //---------------------------------
    // # selectedOptions
    //---------------------------------
    // - связывает выбранные опции в multi-select со св-вом модели

      > Информация
        - Контролирует, какие эл-ты в multi-select выбраны.
        - Должно использоваться совместно с эл-том select и связкой options.

      > Как работает
        - selectedOptions принимает в качестве значения массив.
        - Этот массив лежит в одном из св-в модели.
        - Пользователь выбирает/развыбирает значения в multi-select.
        - KO автоматически синхронизирует этот массив.
        - Массив содержит только выбранные элементы.

      > Пример
        - Модель:

            var Model = {
              constructor: function(){
                var self = this;

                    self.availableCountries = ko.observableArray(['France', 'Germany', 'Spain']);
                    self.chosenCountries = ko.observableArray(['Germany']);

                return self;
              }
            };

        - Активируем KO экземпляром модели:

            ko.applyBindings(Object.create(Model).constructor());

        - html:

            <hr>

            <p>
                Choose some countries you'd like to visit:
                <select data-bind="options: availableCountries, selectedOptions: chosenCountries" size="5" multiple="true"></select>
            </p>

            <hr>
            Выбранные значения:
            <div data-bind="foreach: chosenCountries">
              <p data-bind="text: $data"></p>
            </div>

        - В этом примере в multi-select можно выбрать несколько значений.
        - И на экран также выводится содержимое массива выбранныых значений.
        - Так что наглядно видно, как меняется этот массив при изменении выбора.


    //---------------------------------
    // # uniqueName
    //---------------------------------
    // - обеспечивает не пустой атрибут name у связанного DOM-элемента

      > Информация
        - Если у DOM-эл-та нет атрибута name, KO автоматом назначает его.
        - И присваивает ему какое-нибудь уникальное значение.
        - Эта связка скорее всего будет использоваться редко.

      > Какое значение принимает
        - true

      > Пример:

          <input data-bind="value: someModelProperty, uniqueName: true" />


6.  Шаблоны

  --------------------------------------
  Подоглавление:

    - Введение
    - Синтаксис и параметры
    - В какой элемент запихнуть шаблон
    - Примеры

  --------------------------------------

  > Введение
    - KO позволяет организовывать шаблоны HTML-разметки.
    - Каждому шаблону можно дать уникальное имя.
    - Каждый шаблон можно в любой момент отрисовать.
    - При отрисовке шаблона можно использовать данные из модели.

  > Синтаксис и параметры

    # Вариант 1: простой синтаксис
      - Можно передать в качестве значения строку.
      - Это будет расценено, как имя шаблона (как name).

          data-bind="template: 'someString'"

    # Вариант 2: полный синтаксис
      - Можно передать в качестве значения объект с параметрами.
      - Например, вот это тоже самое, что написано выше:

          data-bind="template: {name: 'someString'}"

      - Вот доступные параметры и их описание:

        # name
          - id элемента, который содержит шаблон, который надо отрисовать.
          - Например: <script id='myId' type="text/html">... шаблон ...</script>

        # data
          - Объект-контекст, который будет действовать внутри шаблона при отрисовке.
          - Если опустить, KO будет искать foreach.
          - Если и foreach опустить, то в качестве контекста будет $root.

        # if
          - Этот параметр принимает значение true/false.
          - Шаблон будет отрисован, только если значение == true.

        # foreach
          - Отрисовать шаблон в стиле foreach.
          - Работает точно также, как описанный ранее foreach.

        # as
          - Только в сочетании с foreach.
          - Определить псевдоним для текущего i-го контекста.
          - Вместо этого, можно просто использовать переменную $data.

        # afterRender, afterAdd, beforeRemove
          - Только в сочетании с foreach.
          - Это всё calback-функции, которые выполняются при манипуляциях с массивом.
          - Подробнее см. в описании связки foreach.

  > В какой элемент запихнуть шаблон
    - По инструкции шаблон надо размещать внутри элемента script.
    - Причем с атрибутом type="text/html".
    - Атрибут обязателен, чтобы внутренность скрипта не исполнялась, как JS>

  > Примеры

    //---------------
    // Пример 1
    //---------------
    // - Простой пример использования шаблона

      - Модель:

          var Model = {
            constructor: function(){
              var self = this;

              self.buyer = { name: 'Иван', credits: 250 };
              self.seller = { name: 'Петро', credits: 5800 };

              return self;
            }
          };

      - Активируем KO экземпляром модели:

          ko.applyBindings(Object.create(Model).constructor());

      - Шаблон (в html):

          <script type="text/html" id="person-template">
              <h3 data-bind="text: name"></h3>
              <p>Кредиты: <span data-bind="text: credits"></span></p>
          </script>

      - Html (применяем шаблон):

          <h2>Покупатели</h2>
          <div data-bind="template: { name: 'person-template', data: buyer }"></div>
          <div data-bind="template: { name: 'person-template', data: seller }"></div>


    //---------------
    // Пример 2
    //---------------
    // - Использование шаблона с foreach

      - Модель:

          var Model = {
            constructor: function(){
              var self = this;

              self.people = [
                self.buyer = { name: 'Иван', credits: 250 },
                self.seller = { name: 'Петро', credits: 5800 }
              ];

              return self;
            }
          };

      - Активируем KO экземпляром модели:

          ko.applyBindings(Object.create(Model).constructor());

      - Шаблон (в html):

          <script type="text/html" id="person-template">
            <h3 data-bind="text: name"></h3>
            <p>Кредиты: <span data-bind="text: credits"></span></p>
          </script>

      - Html (применяем шаблон):

          <h2>Покупатели</h2>
          <div data-bind="template: { name: 'person-template', foreach: people }"></div>


7.  Кастомные связки

  --------------------------------------
  Подоглавление:

    > Введение
    > Создание

      > Регистрация
      > Про update-callback
      > Про init-callback
      > Организация синхронизации в обе стороны

    > Запретить связки внутри элемента
    > Дополнить контекст связывания внтури элемента

    > Поддержка виртуальных элементов [добавить описание по требованию]
    > Реализация логики при удалении связ-го эл-та

  --------------------------------------

  > Введение
    - В KO есть набор стандартных связок, вроде click или value, они описаны выше.
    - Но KO также позволяет и создавать свои собственные, кастомные связки.
    - Это позволяет очень гибко контролировать взаим-ие DOM-эл-в и модели.
    - И даёт возможность упаковывать сложное поведение в кастомные связки.

  > Создание

    > Регистрация
      - Происходит, как свойство объекта ko.bindingHandlers.
      - Например:

          ko.bindingHandlers.yourBindingName = {
              init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {

                .. этот callback сработает в момент применения связки к эл-ту ..
                .. позволяет осуществить стартовые настройки ..

              },
              update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {

                .. этот callback сработает в момент применения связки к эл-ту ..
                .. и каждый раз, когда связ. св-во модели (observable/computed) изменяется ..
                .. обновляет DOM-элемент, основываясь на заданных здесь значениях ...

              }
          };

      - И теперь можно использовать эту связку на практике:

          <div data-bind="yourBindingName: someValue"> </div>

      - Объявлять одновременно и init, и update - не обязательно.
      - Можно объявить только одно из них, любое.

    > Про update-callback
      - При объявлении кастомной связки можно назначить update-callback.
      - Он будет вызыватьяс в следующих случаях:

        1) Один раз при стартовом осуществлении связки.
        2) Каждый раз при изменении связанного наблюдаемого св-ва модели.

      - На вход получает следующие параметры:

          # element
            - Ссылка на связанный DOM-элемент.

          # valueAccessor

            var propName = valueAccessor();   | Получить имя связанного св-ва модели.
            var value = ko.unwrap(propName);  | Получить значение св-ва propName

          # allBindings
            - Это JS-объект со всеми связанными с этим DOM-эл-м св-ми модели.
            - Примеры:

                // Получить значение св-ва по имени propName
                // - Вернёт undefined, если такого св-ва нет.

                  var value = allBindings.get('propName');


                // Узнать, есть ли в allBindings св-во по имени propName

                  var is = allBindings.has('propName');

          # viewModel
            - Этот параметр устарел в KO 3.x.

          # bindingContext
            - Объект, который содержит доступный контекст связывания.

              bindingContext.$data    | ссылка на текущий объект-контекст
              bindingContext.$parent  | ссылка на родит. объект-контекст
              bindingContext.$root    | ссылка на корень (объект-модель)
              ... и т.д. (см. главу про контексты)

      - Пример использования:

        - Связка:

            ko.bindingHandlers.myBinding = {
              update: function(element, valueAccessor, allBindings) {

                // 1. Получить имя связанного свойства
                var name = valueAccessor();

                // 2. Получить значение св-ва name
                var value = ko.unwrap(name);

                // 3. Получить значение другого св-ва модели по имени 'age'
                // - При этом задать значение по умолчанию на всякий случай.
                var duration = allBindings.get('age') || 18;

                // 4. Провести какие-то манипуляции с DOM
                ...

              }
            };

        - Теперь связку можно использовать так:

            <div data-bind="myBinding: 28"></div>


    > Про init-callback
      - При объявлении кастомной связки можно назначить init-callback.
      - Он будет вызываться в следующих случаях:

        1) Один раз при стартовом осуществлении связки.

      - Вот в основном, для чего можно использовать init-callback:

        1) Установить начальное состоятие DOM-эл-та единожды, на старте.
        2) Зарегистрировать некие обработчики событий единожды, на старте.

      - init- получаеть точно такой же набор параметров, как update-callback.


    > Организация синхронизации в обе стороны

      > Модель -> DOM
        - При изменении связанного св-ва модели вызывается update-callback.
        - В нём и можно прописать логику данной синхронизации.

      > DOM -> Модель
        - При применении связки вызывается init-callback.
        - В нём можно назначить DOM-элементу любые обработчики событий.
        - В них и можно прописать логику данной синхронизации.


  > Запретить связки внутри элемента
    - KO позволяет запретить применение связывания внутри элемента.
    - Пример:

      - Создадим кастомную связку, которой сможем управлять запретом:

          ko.bindingHandlers.allowBindings = {
            init: function(elem, valueAccessor) {

              // true / false
              var shouldAllowBindings = ko.unwrap(valueAccessor());

              // Если вернуть true - запретить, false - разрешить.
              return { controlsDescendantBindings: !shouldAllowBindings };

            }
          };

      - Вот, как это работает:

          <div data-bind="allowBindings: true">

              <!-- Выведет "Иван", т.к. связки внутри div разрешены -->
              <span data-bind="text: 'Иван'">Пётр</span>

          </div>

          <div data-bind="allowBindings: false">

              <!-- Выведет "Пётр", т.к. связки внутри div запрещены -->
              <span data-bind="text: 'Иван'">Пётр</span>

          </div>


  > Дополнить контекст связывания внтури элемента
    - KO позволяет дополнить контекст связывания внутри элемента.
    - Пример:

      - Создадим кастомную связку, позволяющую дополнять контекст связывания:

          ko.bindingHandlers.withProperties = {
            init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {

              // Создать дополненный объект-контекст связывания
              // - Для этого берём оригинальный контекст bindingContext.
              // - Используем метод extend, чтобы его дополнить.
              // - А методу скармливаем объект-значение связки (то, чем надо дополнить)
              var innerBindingContext = bindingContext.extend(valueAccessor);

              // Применяем новый контекст ко всем дочерним эл-ам элемента element
              ko.applyBindingsToDescendants(innerBindingContext, element);

              // Говорим KO, чтобы не применял связки в дочерних элементах
              // - Потому что applyBindingsToDescendants уже применил их.
              // - И нам не надо, чтобы они были применены дважды.
              return { controlsDescendantBindings: true };

            }
          };

      - Вот, как это работает:

          <div data-bind="withProperties: { name: 'Иван', age: 18 }">

            <!-- Выведет "Иван" -->
            <span data-bind="text: name"></span>

            <!-- Выведет 18 -->
            <span data-bind="text: age"></span>

          </div>

    - А что, если требуется не дополнить контекст, а создать новый уровень?
    - Имеется в виду создание нового дочерного уровня контекста.
    - Тогда вместо extend(data) надо использовать createChildContext(data).


  > Поддержка виртуальных элементов
    - Добавить описание по требовани.
    - Официальная справка:
        http://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html


  > Реализация логики при удалении связ-го эл-та
    - В типичном KO-приложении DOM-эл-ты удаляются/добавляются динамически.
    - При удалении эл-тов может потребоваться что-нибудь за ними подчищать.
    - Иначе говоря, вызывать при удалении некую callback-функцию для подчистки.
    - Это актуально для кастомных связок, т.к. в стандартных уже всё написано до нас.
    - Эта callback-функция должна срабатывать при удалении связанного DOM-элемента.
    - Пример

      - Назначим подчищающий callback элементу element.
      - Делать это будем при объявлении кастомной связки myCustomBind.
      - Единственный правильный вариант делать это в init:


        ko.bindingHandlers.myCustomBind = {

          init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {

            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {

                .. выполнение некой логики ..

            });

          }

        }


8.  Компоненты

  --------------------------------------
  Подоглавление:

    - Введение
    - Декомпозиция

  --------------------------------------

  > Введение
    - В этой главе будет описан функционал KO по использованию компонентов.


  > Декомпозиция

    8.  Компоненты
      8.1.  Обзор
        - В KO есть функционал, позволяющий создавать т.н. компоненты.
        - Это независимые, самодостаточные мини-KO-приложения.
        - Они могут содержать и представление, и модель.
        - Они могут подгружаться в основное приложение из отдельного файла.
        - И они могут быть использованы многократно в разных приложениях.

      8.2.  Объявление и регистрация компонента
        - Здесь описано, как объявить, зарегистрировать и настроить компонент.
        - Всё это делается одновременно 1 методом: ko.components.register().
        - Так что вся глава посвящена описанию параметров этого метода.

      8.3.  Связка component
        - Уже была ранее описана в главе 5. См:  # component

      8.4.  Кастомные HTML-элементы
        - Есть 2 способа применить компонент: связка component / кастомный HTML-элемент.
        - Первый был описан в 8.3. Второй будет описан здесь.
        - Автор утверждает, что 2-й способ гораздо удобнее.

      8.5.  Кастомные загрузчики компонентов
        - [изучить по запросу]


  > 8.1.  Обзор

  --------------------------------------
  Подоглавление:

    - Введение
    - Что может компонент
    - Когда стоит использовать компоненты
    - Есть 2 способа применить компонент
    - Пара наглядных примеров

  --------------------------------------

  > Введение
    - В KO есть функционал, позволяющий создавать т.н. компоненты.
    - Это независимые, самодостаточные мини-KO-приложения.
    - Они могут содержать и представление, и модель.
    - Они могут подгружаться в основное приложение из отдельного файла.
    - И они могут быть использованы многократно в разных приложениях.

  > Что может компонент

      # 1
        - Может представлять отдельный виджет, или даже целую секцию приложения.

      # 2
        - Содержать своё представление, и часто (по желанию), свою модель.

      # 3
        - Может хранитсья в отдельном файле.
        - Может подгружаться асинхронно, например, с помощью requireJS.

      # 4
        - Могут совмещаться друг сдругом в иерархическую структуру.

      # 5
        - Могут с лёгкостью использоваться в разных проектах.

      ... и многое другое.

  > Когда стоит использовать компоненты
    - При разработке больших, сложных JS-приложений.
    - Например, масштабных одностраничных приложений.
    - Компоненты позволяют разбить задачу на отдельные кусочки.
    - А в будущем эти кусочки можно будет повторно использовать.

  > Есть 2 способа применить компонент

    1) С помощью связки component
      - Компонент загружается внутрь связанного DOM-элемента.
      - Подробнее об этом способе см. ниже в пункте 8.3

    2) С помощью использования кастомного HTML-элемента
      - В качестве имени элемента применяется имя компонента.
      - Компонент загружается внутрь этого кастомного элемента.
      - Это довольно удобный способ, мне нравится.

  > Наглядный пример

    //--------------------
    // Пример 1
    //--------------------
    // Простейший пример использования компонента

      - Создать и зарегистрировать компонент

          ko.components.register('my-component', {

            viewModel: {
              createViewModel: function(params, componentInfo) {

                //> Здесь params - объект с параметрами, переданный из связки.
                //> Здесь componentInfo.element - ссылка на эл-т, в который был вставлен компонент

                // 1. Создаём прототип
                var Model = {
                  constructor: function() {
                    var self = this;

                      self.name = ko.observable(params.name);
                      self.age = ko.observable(params.age);
                      self.gender = ko.observable(params.gender);

                    return self;
                  }
                };

                // 2. Создаём новый объект из прототипа и возвращаем его
                return Object.create(Model).constructor();

                }

            },

            template:
              '<input type="text" data-bind="textInput: name">' +
              '<span data-bind="text: name"></span><br><br>' +

              '<input type="text" data-bind="textInput: age">' +
              '<span data-bind="text: age"></span><br><br>' +

              '<input type="text" data-bind="textInput: gender">' +
              '<span data-bind="text: gender"></span>'

          });

      - Активировать KO

          ko.applyBindings();

      - Применить компонент, как кастомный HTML-элемент

          <my-component params="name: 		'ivan',
                                age: 			18,
                                gender: 	'man'"></my-component>


  > 8.2.  Объявление и регистрация компонента

  --------------------------------------
  Подоглавление:

    - Введение
    - Синтаксис
    - Параметры

  --------------------------------------

  > Введение
    - Здесь описано, как объявить, зарегистрировать и настроить компонент.
    - Всё это делается одновременно 1 методом: ko.components.register().
    - Так что вся глава посвящена описанию параметров этого метода.

  > Синтаксис
    - Вот такой синтаксис у этой функции:

        ko.components.register(name, config)
          - name: имя компонента (строка).
          - config: настройки компонента (объект).

    - Например:

        ko.components.register('my-component', {
          [свойство]: [значение],
          [свойство]: [значение],
          ...
        });

    - Подробнее о параметре name:
      - Является обязательным параметром.
      - Рекомендуется использовать имя в нижнем регистре.
      - А также между словами ставить символ -
      - Тогда компонент м.б. использовать, как кастомный HTML-элемент.


  > Параметры

    # viewModel
      - Не обязательный параметр.
      - Если viewModel не указано, то:
        - Компонент рассматривается, как простой блок с HTML.
      - Принимает ссылку на модель в нескольких форматах:

      # 1 - функция-конструктор
        - Это вариант с функциональным наследованием.
        - Создаём отдельно функцию-конструктор.
        - И передаём св-ву viewModel значение-ссылку на эту фукнцию.
        - Например:

          - Создадим функцию-конструктор:

              function SomeComponentViewModel(params) {

                  // Здесь params - объект с параметрами, переданный из связки.
                  this.someProperty = params.something;

              }

          - Зарегистрируем новый компонент:

              ko.components.register('my-component', {
                  viewModel: SomeComponentViewModel,
                  template: ...
              });


      # 2 - простой объект
        - Это самый простейший вариант.
        - Во viewModel мы передаём ссылку на простой JS-объект.
        - Считаем, что этот объект и является объектом-моделью.
        - Например:

          - Создаём объект:

              var sharedViewModelInstance = { ... };

          - Регистрируем компонент:

              ko.components.register('my-component', {
                  viewModel: { instance: sharedViewModelInstance },
                  template: ...
              });


      # 3 - функция-фабрика createViewModel
        - Этот вариан очень хорошо сочетается с прототипным наследованием.
        - Вот, как это работает:

            ko.components.register('my-component', {
              viewModel: {
                createViewModel: function(params, componentInfo) {

                  //> Здесь params - объект с параметрами, переданный из связки.
                  //> Здесь componentInfo.element - ссылка на эл-т, в который был вставлен компонент

                  // 1. Создаём прототип
                  var Model = {
                    constructor: function() {
                      var self = this;

                        // ... св-ва модели ...

                      return self;
                    }
                  };

                  // 2. Создаём новый объект из прототипа
                  var obj = Object.create(Model).constructor();

                  // 3. Возвращаем ссылку на этот объект
                  return obj;
                  
                },
                template: ""
              }
            });


      # 4 - AMD-модуль, чье значение описывает viewmodel
        - Этот вариант для применения с require.js
        - Внутри модуля require могут быть реализованы варианты с 1 по 3.
        - Например:

          - Модуль require (реализован вариант с простым объектом, №2):

              define(['knockout'], function(ko) {

                // 1. Создать объект-модель
                var obj = { ... };

                // 2. Вернуть
                return obj;

              });

          - Применение

              ko.components.register('my-component', {
                  viewModel: { require: 'some/module/name' },
                  template: ...
              });

    # template
      - Обязательный параметр.
      - Должен содержать шаблон HTML-разметки для компонента.
      - Принимает значение в нескольких форматах:

        # 1 - как id элемента, innerHTML которого является шаблоном
          - innerHTML этого блока и будет рассматриваться, как шаблон.
          - Создадим такой блок, используя для этого тег script.
          - И обязательно указав type="text/html".
          - Иначе содержимое будет исполняться, как JS.

              <script type="text/html" id="person-template">
                <h3 data-bind="text: name"></h3>
                <p>Кредиты: <span data-bind="text: credits"></span></p>
              </script>

          - Но использовать тег script не обязательно.
          - Можно использовать любой элемент-обёртку.
          - Суть в том, чтобы он был невидим, и служил просто хранилищем шаблона.
          - Например, можно использовать тег template, т.к. это наглядно:

              <template id='person-template'>
                <h3 data-bind="text: name"></h3>
                <p>Кредиты: <span data-bind="text: credits"></span></p>
              </template>

          - Теперь можно передать в template id этого блока:

              ko.components.register('my-component', {
                  template: { element: 'my-component-template' },
                  viewModel: ...
              });

        # 2 - как ссылку на эл-т, innerHTML которого является шаблоном
          - innerHTML этого блока и будет рассматриваться, как шаблон.
          - Суть та же, что с id, только здесь надо передать ссылку.
          - Получим ссылку:

              var elem = document.getElementById('my-component');

          - Передадим в template:

              ko.components.register('my-component', {
                  template: { element: elemInstance },
                  viewModel: ...
              });

        # 3 - как строку
          - Можно просто передать строку с HTML-разметкой.
          - Она тогда будет воспринята, как innerHTML.
          - Вот, как это происходит:

              ko.components.register('my-component', {
                template: '<h1 data-bind="text: title"></h1>\
                           <button data-bind="click: doSomething">Clickety</button>',
                viewModel: ...
              });

          - Есть неудобство в том, что в HTML нет аналога heredoc.
          - Но это можно решит вот таким хаком:

              ko.components.register('my-component', {
                template: (function () {/*

                  <h1 data-bind="text: title"></h1>
                  <button data-bind="click: doSomething">Clickety</button>

                */}).toString().match(/[^]*\/\*([^]*)\*\/\}$/)[1],

                viewModel: ...
              });


    # createViewModel
      - Как использовать, см. выше (viewModel - #3).

    # require
      - Как использовать, см. выше (viewModel - #4).


  > 8.3.  Связка component

  --------------------------------------
  Подоглавление:

    - Введение

  --------------------------------------

  > Введение
    - Уже была ранее описана в главе 5. См:  # component




  > 8.4.  Кастомные HTML-элементы

  --------------------------------------
  Подоглавление:

    - Введение
    - Пример

  --------------------------------------

  > Введение
    - Есть 2 способа применить компонент:
      1) Чераз связку component.
      2) Через кастомные HTML-элементы.
    - Здесь будет как раз описан 2-й вариант.
    - Автор говорит, 2-й вариант более удобный, чем первый вариант.
    - Например, сравним. Вот применение связки 1-ым способом:

        <div data-bind='component: { name: "flight-deals", params: { from: "lhr", to: "sfo" } }'></div>

    - А вот применение этой же связки 2-м способом:

        <flight-deals params='from: "lhr", to: "sfo"'></flight-deals>

    - Вывод: 2-ым способом получилось короче и красивее.
    - Причём оба способа поддерживаются браузерами IE6+.

  > Пример
    - См. пример в "8.1.  Обзор".
    - Он же в папке с живыми примерами: "35. Компоненты - простой пример".


9.  Сохранение модели на сервер / загрузка модели с сервера

  --------------------------------------
  Подоглавление:

    - Введение
    - Сериализация модели и отправка на сервер
    - Извлечение с сервера и развёртка модели

  --------------------------------------

  > Введение
    - Часто понадобится сохранять модель на сервер, в базу данных.
    - Также часто понадобится загружать модель с сервера в представление.
    - Для этих операций будет использоваться AJAX.
    - В этой главе описано, как сохранять/загружать модель.


  > Сериализация модели и отправка на сервер
    - Прежде, чем сохранить модель на сервер, её надо сериализовать.
    - Стандартным форматом для сериализации является JSON.
    - KO предоставляет 2 метода, помогающих сериализовать модель:

      # ko.toJS
        - Создаёт копию модели в виде простого JS-объекта, готового к сериализации.
        - Подставляет для наблюдаемых св-в их текущие значения.

      # ko.toJSON
        - Сначала вызывает ko.toJS.
        - Потом применяет стандартную JS-функцию JSON.serialize()

    - Пример:

      - Допустим, есть у нас такая модель:

          var viewModel = {
              firstName : ko.observable("Bert"),
              lastName : ko.observable("Smith"),
              pets : ko.observableArray(["Cat", "Dog", "Fish"]),
              type : "Customer"
          };
          viewModel.hasALotOfPets = ko.computed(function() {
              return this.pets().length > 2
          }, viewModel)

      - Сериализовать её можно так:

          var jsonData = ko.toJSON(viewModel);

      - jsonData содержит JSON-строку с моделью, готовую к отправке на сервер.

    - Остаётся лишь отправить jsonData на сервер с помощью AJAX.


  > Извлечение с сервера и развёртка модели
    - Итак, допустим мы сериализовали модель и AJAX-ом послали на сервер.
    - И она у нас теперь лежит в базе данных в виде JSON-строки.
    - Каким образом теперь её извлечь и превратить в действующую модель?
    - Ну, извлечь можно с помощью AJAX-запроса.
    - А вот развернуть (превратить в действующую KO-модель) можно 2 способами:

        1) Вручную
        2) С помощью плагина mapping

    # Ручное извлечение
      - Пусть у нас уже имеется такая модель:

          var viewModel = {
            serverTime: ko.observable(),
            numUsers: ko.observable()
          }

      - И вот такое представление:

          The time on the server is: <span data-bind='text: serverTime'></span>
          and <span data-bind='text: numUsers'></span> user(s) are connected.

      - Теперь извлекаем данные с сервера.
      - Здесь getDataUsingAjax некая абстрактная AJAX-функция:

          var data = getDataUsingAjax();

      - В data на текущий момент лежит JSON-строка с извлечённой моделью.
      - Пусть это такой вот JSON:

          {
              serverTime: '2010-01-07',
              numUsers: 3
          }

      - И теперь вручную обновляем значения действующей модели:

          viewModel.serverTime(data.serverTime);
          viewModel.numUsers(data.numUsers);

      - Всё, дело сделано.


    # Извлечение с помощью плагина mapping

      > Введение
        - Ручное извлечение м.б. утомительным, если у модели много свойств.
        - А особенно, если она содержит объёмные наблюдаемые массивы.
        - Поэтому Стив Сандерсон и придумал функционал для облегчения работы.
        - И назвал его knockout mapping plugin.
        - Скачать его можно здесь: https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output

      > Практика

        # Получим готовую модель из JSON строки.
          - Все св-ва будут превращены в наблюдаемые.
          - А все св-ва с массивами в наблюдаемые массивы:

              var viewModel = ko.mapping.fromJS(data);

        # Обновим готовую модель данными из JSON-строки
          - Допустим, у нас уже есть готовая модель viewModel.
          - И мы извлеки с сервера JSON-строку с её состоянием.
          - И хотим обновить viewModel.
          - Сделать это можно таке:

              ko.mapping.fromJS(data, viewModel);


10. Разделение модели KnockoutJS на AMD-модули с помощью RequireJS

  --------------------------------------
  Подоглавление:

    - Ссылки
    -

  --------------------------------------

  > Ссылки

    - Официальная справка KnockoutJS по применению модульной архитектуры с RequireJS:
        http://knockoutjs.com/documentation/amd-loading.html

    - Вспомогательная библиотека от Райана Нимейера [на github]:
        https://github.com/rniemeyer/knockout-amd-helpers

    - Вспомогательная библиотека от Райана Нимейера [статья на его сайте]:
        http://www.knockmeout.net/2013/05/knockout-amd-helpers-plugin.html

    - Статья о том, как грамотно строить большие KnockoutJS-приложения, используя RequireJS:
        http://code.tutsplus.com/tutorials/building-large-maintainable-and-testable-knockout-js-applications--net-30996

  >

11. Seo и Knockout + Laravel

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Проблема
    # Суть решения проблемы кратко
    # Проверка результатов с помощью Google Console
    # Методология решения проблемы, при работе с Laravel

      ▪ Только там, где это действительно необходимо
      
      ▪ Не отображаемые элементы
        ▪ Санкции поисковиков
        ▪ Избегать скрытых элементов при отдаче HTML с сервера
        ▪ Тактика работы со скрытыми элементами
        ▪ Проблема "мерцания" при загрузке решается "панелью загрузки"
      
      ▪ Работа с text, value, textValue
        ▪ Если значение не передаётся с сервера
        ▪ Если значение передаётся с сервера
      
      ▪ Работа с foreach
        ▪ Унификация передаваемых для foreach с сервера данных
        ▪ Вывод foreach-блока knockout'ом


  --------------------------------------

  > Ссылки

    # Google Search Console
        https://www.google.com/webmasters/verification/add-resource-ac
        https://support.google.com/webmasters/answer/6066468?hl=ru    

  > Проблема
    - Поисковые роботы Google и Яндекс не выполняют JS.
    - Они находят лишь тот HTML, который изначально отдал сервер.
    - Затем они уходят, и лишь после этого выполняется JS документа.
    - И knockout отрабатывает все свои связки, text, foreach, и т.д.
    - Из-за этого роботы упускают много важных ресурсов документа.
    - И у подобного рода документов возникают проблемы с SEO.

  > Суть решения проблемы кратко

    1. Отдаём всё необходимое роботам в HTML
      - Сервер отдаёт HTML, в котором есть всё, нужное роботу.
      - Робот считывает этот HTML.
      - Робот уходит, довольный.
      - Проблем с SEO нет.

    2. Потом передаём управление knockout'у
      - Инициализируем ko-наблюдаемые данными из HTML, и т.д.

  > Проверка результатов с помощью Google Console
    - Ссылка на неё есть выше в ссылках.
    - Она покажет, как роботы воспринимают документ.
    - Надо иметь привязанный к домену IP сервера.

  > Методология решения проблемы, при работе с Laravel

    • Только там, где это действительно необходимо
      - Есть вещи, которые действительно влияют на SEO.
      - А есть вещи, которые особо на SEO не влияют.
      - При работе с последними, не стоит напрягатсья,
        и применять описанную методологию.

    • Не отображаемые элементы

      ▪ Санкции поисковиков
        - Поисковики не любят скрытые элементы ("display: none").
        - И могут применить санкции.

      ▪ Избегать скрытых элементов при отдаче HTML с сервера
        - При начальной отдаче HTML не должно быть скрытых эл-в.
        - Тогда поисковики их и не найдут, и не применят санкции.

      ▪ Тактика работы со скрытыми элементами
        - Показывать все "display: none" эл-ты при загрузке.
        - А после, скрывать с помощью knockout.

      ▪ Проблема "мерцания" при загрузке решается "панелью загрузки"
        - В начальном html элемент не скрыт.
        - Потом, когда выполняется js, он скрывается.
        - Мы имеем эффект "мерцания" элемента при загрузке.
        - Чтобы этого не происходило, надо использовать экран загрузки.
        - Который должен исчезать после полной загрузки страницы и исполнения JS.

    • Работа с text, value, textValue

      ▪ Если значение не передаётся с сервера
        - То надо просто его продублировать.
        - С одной стороны, прописать прямо в HTML.
        - С другой, инициировать им наблюдаемую.

      ▪ Если значение передаётся с сервера
        - То надо в HTML подставить его с помощью blade.
        - И также передать в модель knockout, чтобы
          инициировать им наблюдаемую.

    • Работа с foreach

      ▪ Унификация передаваемых для foreach с сервера данных
        - Надо, чтобы они подходили и для foreach knockout.
        - И, одновременно, для foreach laravel blade.
        - Потому что передавать 2 версии данных для обеих
          технологий не целесообразно.

      ▪ Дублирование foreach-блоков blade'ом и knockout'om

        ▪ Вывод foreach-блока blade'ом
          - И выводится прямо шаблонизатором blade'а.
          - Это то, что видят поисковые роботы.
          - После загрузки документа, он получает "display: none". 

        ▪ Вывод foreach-блока knockout'ом
          - Рядом тоже самое выводится knockout'ом.
          - Содержимое этого блока недоступно поисковым роботам.
          - После загрузки документа, blade-блок скрывается.
          - И остаётся только knockout-блок.







