=============================================================
Модульные интерфейсы






-----------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------

Ссылки:

	> Создание графических компонентов (раздел сайта Ильи Кантора):
				http://learn.javascript.ru/widgets





*****************************************************
Оглавление:

  > Цель этого документа
	> 1. Архитектура





*****************************************************


> Цели этого документа
  - Составить такой справочник, руководствуясь которым даже новичок
    сможет построить грамотное модульное приложение изначально с
    правильной архитектурой.
  - Надо описать такую архитектуру, используя которую можно клепать
    такие приложения.

> 1. Архитектура

  > Подоглавление:
    - Метод описания через декомпозицию, который здесь применён
    - Полное декомпозиционное дерево сущностей архитектуры
    - Декомпозиция архитектуры на составляющие

  > Метод описания через декомпозицию, который здесь применён
    - Изначально есть 1 цельная главная сущность - архитектура.
    - Её можно раздробить на несколько подсущностей, которые в совокупности
      полностью описывают главную сущность.
    - Каждую из этих подсущностей также можно раздробить на несколько
      более мелких подсущностей. И так далее.
    - Каждая подсущность должна быть описана в отдельном разделе.
    - Чем мельче подсущность, тем более углублённое должно быть описание
    - В итоге получается дерево сущностей, которое описывает главную
      сущность так глубоко, как это требуется, и которым удобно пользоваться,
      как справочником - легко можно находить нужную тему.

  > Полное декомпозиционное дерево сущностей архитектуры

    1.  Архитектура
      1.1.  Архитектура модульной структуры
        1.1.1.  Общая архитектура модуля
        1.1.2.  Архитектура дерева модулей (requireJS)
        1.1.3.  Архитектура deploy-модуля
        1.1.4.  Архитектура main-модуля
        1.1.5.  Архитектура inner-модуля
      1.2.  Архитектура объекта-прототипа
        1.2.1.  Архитектура функции-конструктора
          1.2.1.1.  Архитектура конфигурационного объекта, принимаемого на вход конструктором
          1.2.1.2.  Архитектура сопроводительных процедур при создании нового экземпляра прилоежния
          1.2.1.3.  Архитектура инициации start-объекта
          1.2.1.4.  Архитектура инициации manage-объекта
          1.2.1.5.  Архитектура создания bin-объекта с функционалом приложения
          1.2.1.6.  Архитектура инициации dom-объекта с DOM-проекцией экземпляра
        1.2.2.  Архитектура набора статических свойств
        1.2.3.  Архитектура структуры связей между manage-объектом и DOM-проекцией
      1.3.  Архитектура объекта-экземпляра
        1.3.1.  Архитектура start-объекта
        1.3.2.  Архитектура manage-объекта
        1.3.3.  Архитектура dom-объекта c DOM-проекцией приложения
        1.3.4.  Архитектура bin-объекта с функционалом для работы с приложением

        
  > Декомпозиция на составляющие и общий взгляд

      1.  Архитектура
        1.1.  Архитектура модульной структуры
          - Приложение состоит из модулей.
          - Модули могут принимать входы, и возвращать выходы.
          - Я выделяю 3 типа модулей: inner, main, deploy.
          - Deploy-модуль не относится к приложению, а использует его.
          - Main-модуль в 99% случаев возвращает в deploy-модуль объект-прототип приложения.
          - Inner-модули составляют внутренние модули приложения, чей функционал
            в итоге концентрируется в main-модуле.

        1.2.  Архитектура объекта-прототипа
          - Он содержит функцию-конструктор для создания объектов-экземпляров.
          - Он содержит набор статических свойств, доступных экземплярам.
          - Все объекты-экземпляры приложения - потомки объекта-прототипа.
          - В deploy-модуле из объекта-прототипа создают объект экземпляр.
          - При создании объекта-экземпляра конструктору передают конфигурационнй объект.

        1.3.  Архитектура объекта-экземпляра
          - Он полностью описывает приложение, включая все настройки и данные.
          - Он всегда содержит строго фиксированный задуманный набор параметров.
          - Он может быть создан, как потомок объекта-прототипа в deploy-модуле.
          - Он содержит весь функционал для работы с приложением.
          - Он содержит DOM-проекцию приложения, на 100% синхронизированную с manage-объектом.
          - Он содержит start-объект, в который сохраняет начальное состояние 
            объекта-экземпляра, которая была при его создании.
          - Он держит текущую конфигурацию в manage-объекте.


> 1.1.  Архитектура модульной структуры

  > Подоглавление:
    - Декомпозиция на составляющие и общий взгляд
    - Почему стоит использовать модульную архитектуру в приложениях?

  > Декомпозиция на составляющие и общий взгляд

      1.1.  Архитектура модульной структуры
        1.1.1.  Общая архитектура модуля
          - У модуля есть входы и выходы.
          - Все модули определяются в соответствии с концепцией AMD.
          - Main- и inner-модули определяются функцией define фреймворка requireJS
          - Deploy-модуь определяется функцией require фреймворка requireJS
          - На выход main- и inner-модули обычно возвращает ссылку на объект,
            но не обязательно, может вернуть и ссылку на функци, и литерал.

        1.1.2.  Архитектура дерева модулей (requireJS)
          - Приложение состоит из модулей разных типов.
          - У модулей есть входы и выходы.
          - На вход одного модуля могут быть подключены > 1 других модулей.
          - В итоге функционал всех модулей концентрируется в main-модуле.
          - А от main-модуля вниз идёт древообразная цепочка зависимостей.
          - К deploy-модулю может быть подключено множество main-модулей приложений.
          - Работа со всем этим производится с помощью фреймворка requireJS.

        1.1.3.  Архитектура deploy-модуля
          - Это модуль, который вообще то не входит в состав приложения.
          - Это top-level модуль, который ничего не возвращает на выход,
            и не предназначен для подключения к другим модулям.
          - Его предназначение - минификация и деплой на боевой сервер.
          - На вход он принимает main-модули приложений, которые будет задействовать.
          - Внутри себя реализует логику использования подключённых приложений
            в предназначенных для этого HTML-документах.

        1.1.4.  Архитектура main-модуля
          - Это главный модуль приложения.
          - Он является корневым узлом дерева модулей приложения.
          - В нём сконцентрирован весь функционал приложения.
          - На вход он принимает свои модули-зависимости 1-й линии.
          - На выход в 99% случаев возвращает объект-прототип приложения.
          - Предназначен для подключения на вход deploy-модуля.

        1.1.5.  Архитектура inner-модуля
          - Это внутринний модуль приложения.
          - Inner-модулем является любой модуль приложения, кроме main-модуля.
          - На вход принимает свои зависимости - какие-то другие модули приложения.
          - На выход возвращате в 99% случаев ссылку на объект. Но не
            обязательно, может вернуть и ссылку на функци, и литерал.
          - В 90% случаев цель такого модуля - у себя в теле сформировать
            набор функций - функционал - разместить их в объекте и вернуть
            этот объект.
          - В 10% случаев такой модуль реализует объект-прототип некой
            подсущности, которая используется в приложении. Например, "узел
            "дерева в приложении "дерево"

  > Почему стоит использовать модульную архитектуру в приложениях?
    - Позволяет разбивать весь код на отдельные единицы кода: модули.
    - Код каждого модуля изолирован внутри своего пространства имён.
    - При этом глобальное пространство имён остаётся девственно чистым.
    - Каждый модуль может возвращать выходы (объект, фукнцию и др.)
    - Каждый модуль может принимать на вход выходы из других указанных модулей.
    - В итоге весь функционал приложения концентрируется в 1-ом main-модуле.
    - Всю работу по подключению цепочек зависимостей выполняет requireJS.
    - Такая архитектура идеальна для создания гигантских многофункциональных
      приложений.
    - Развивать такие приложения легко, дополняя новыми модулями, создавая
      новае версии старых.
    - Комбинировать > 1 такого приложения для работы над одним документом
      легко.
    - Адаптировать любое такое приложение под специфическую задачу легко.


> 1.1.1.  Общая архитектура модуля

  > Подоглавление:
    - Наглядная схематичная структура любого модуля
    - Шаблон определения inner- и main-модулей в стиле requireJS
    - Шаблон определения deploy-модулей в стиле requireJS

  > Наглядная схематичная структура любого модуля

                  [выходные данные]
                      /\     /\
                     /  \   /  \
                      ||     ||
                    -------------
                    |           |
                    |           |
                    |   МОДУЛЬ  |
                    |           |
                    |           |
                    -------------
                      /\     /\
                     /  \   /  \
                      ||     ||
                   [входные данные]

  > Шаблон определения inner- и main-модулей в стиле requireJS
    - Стандарт: каждый модуль определён в отдельном файле.
    - В шаблоне ниже выход модуля - ссылка на объект с функционалом.
    - В шаблоне ниже на вход подаются выходы 2-х модулей.

    define([module1, module2],function(module1, module2){

      // Этот объект будет наполнен функционалом и возвращён.
      var functional = {};

      // Наполняем объект functional функционалом
      // - Можем использовать переданные на вход данные через переменные
      //   module1 и module2
      functional.function1 = function() {};
      functional.function2 = function() {};
      functional.function3 = function() {};

      // Выход модуля - возвращаем объект functional
      return functional;

    });

  > Шаблон определения deploy-модулей в стиле requireJS
    - В принципе, практически одно и тоже, что для inner- и main-модулей.
    - Только в начале ещё надо передать конфигурационный файл для requireJS.
    - Еще вместо функции define() используется require().
    - И еще callback-функция deploy-модуля ничего не выход не возвращает.
    - В шаблоне ниже на вход deploy-модуля передаются выходы 2-х main-модулей
      2-х приложений.

    require.config({
      ... конфиг для настройки работы requireJS ...
    });

    require([main-app1, main-app2],function(main-app1, main-app2){

      // Реализация логики работы с документом
      // - Можно использовать переданные на вход данные через переменные
      //   main-app1 и main-app2


    });


> 1.1.2.  Архитектура дерева модулей (requireJS)

  > Подоглавление:
    - Полная общая схема модульной архитектуры приложения
    - Что такое дерево модулей?
    - Всё это управляется с помощью requireJS
    - Этапы работы requireJS

  > Полная общая схема модульной архитектуры приложения

    > Схема

      - deploy-модуль
        - Main-модуль №1   - Main-модуль
        - Main-модуль №2     - Inner-модуль №1   - Inner-модуль
        - Main-модуль №3     - Inner-модуль №2     - Inner-модуль №1
          ...                - Inner-модуль №3     - Inner-модуль №2
                               ...                 - Inner-модуль №3
                                                      ...

    > Пояснения
      > По deploy-модулю:
        - На вход deploy-модуля могут подаваться только main-модули прилоежний.
        - На вход deploy-модуля можно подать сколько угодно main-модулей.
        - У deploy-модуля нет выходов, он не подаётся на вход какого-либо другого модуля.
      > По main-модулю:
        - На вход main-модуля могут подаваться только inner-модули.
        - На вход main-модуля можно подать сколько угодно inner-модулей.
        - На выход main-модуля в 99% случаев подаётся объект-прототип приложения.
      > По inner-модулю:
        - На вход inner-модуля могут подаваться только inner-модули.
        - На вход inner-модуля можно подать сколько угодно inner-модулей.
        - На выход inner-модуля в 90% случаев подаётся объект с функционалом.

  > Что такое дерево модулей?
    > Под main-модулем может быть дерево из inner-модулей неограниченных размеров:

      Обозначения:
        [main-модуль]:  [MM]
        [inner-модуль]: [IM]

      Как выглядит дерево модулей (схематично):

                                [MM]
                                /   \
                            [IM] ... [IM]
                       /     |         |     \
                   [IM] ... [IM] ... [IM] ... [IM]
                  / | \    / | \    / | \    / | \
            ............................................


  > Всё это управляется с помощью requireJS
    - Он передаёт между модулями их входы и выходы.
    - Он подгружает все модули из дерева модулей.
    - Он исполняет все модули из дерева модулей в правильном порядке.
    - Подробнее о работе requireJS см. в спец. учебном файле.

  > Этапы работы requireJS

    > Этап 1: подгрузить все модули всего дерева модулей
      - Все модули подгружаются и сохраняются в памяти.
      - На этом этапе никакой код ещё не выполняется.

    > Этап 2: исполнить код из модулей дерева в правильном порядке
      - Исполнение происходит снизу вверх.
      - Входы и выходы модулей автоматически передаются куда надо.
      - Один и тот же модуль не исполняется дважды.
      - Сначала снизу-вверх исполняются inner-модули приложения.
      - Потом исполняется main-модуль приложения.
      - Самым последним исполняется deploy-модуль, использующий main-модули.


> 1.1.3.  Архитектура deploy-модуля

  > Подоглавление:
    - Общая информация о deploy-модуле
    - Наглядная схематичная структура deploy-модуля
    - Проведение минификации
    - Способ подключения к документу в не минифицированном виде, с целью отладки
    - Способ подключения к документу в минифицированном виде

  > Общая информация о deploy-модуле
    - Он не входит в состав приложения
    - На вход принимает только main-модули приложений.
    - На выход ничего не поставляет.
    - Является top-level модулем, т.е. он не предназначен для подключения
      к какому-либо другому модулю.
    - Для его определения используется функция require, в отличие
      от main- и inner-модулей, для которых используется функция define.
    - Внутри себя реализует всю JS-логику работы с документом.
    - Deploy-модуль предназначен для минификации вместе со всеми своими
      зависимостями в 1 JS-файл и использования на боевом сервере.
    - Его можно подключить к документу и без минификации, но это полезно
      только в целях отладки.


  > Наглядная схематичная структура deploy-модуля

                        [нет]
                      /\     /\
                     /  \   /  \      выходы
                      ||     ||
                    -------------
                    |           |
                    |   DEPLOY  |
                    |   МОДУЛЬ  |
                    |           |
                    |           |
                    -------------
                      /\     /\
                     /  \   /  \      входы
                      ||     ||
           [main-модуль] ... [main-модуль]


  > Проведение минификации
    - Минификация проводиться с помощью r.js, входящего в состав requireJS.
    - Подробно процесс минификации описан в учебном файле о requireJS.

  > Способ подключения к документу в не минифицированном виде, с целью отладки

      <script data-main="deploy.js" src="require.js"></script>

  > Способ подключения к документу в минифицированном виде

      <script src="deploy.min.js"></script>


> 1.1.4.  Архитектура main-модуля

  > Подоглавление:
    - Общая информация о main-модуле
    - Наглядная схематичная структура main-модуля

  > Общая информация о main-модуле
    - Это главный модуль приложения.
    - Он является корневым узлом дерева модулей приложения.
    - На вход принимает свои inner-модули-зависимости 1-й линии.
    - На выход в 99% случаев возвращает объект-прототип приложения.
    - Предназначен для подключения на вход deploy-модуля.
    - Подробное описание содержания main-модуля см. в разделе:
        "1.2.  Архитектура объекта-прототипа".

  > Наглядная схематичная структура main-модуля

                   [deploy-модуль]
                      /\     /\
                     /  \   /  \      выходы
                      ||     ||
                    -------------
                    |           |
                    |   MAIN    |
                    |   МОДУЛЬ  |
                    |           |
                    |           |
                    -------------
                      /\     /\
                     /  \   /  \      входы
                      ||     ||
           [inner-модуль] ... [inner-модуль]


> 1.1.5.  Архитектура inner-модуля

  > Подоглавление:
    - Общая информация о inner-модуле
    - Наглядная схематичная структура inner-модуля
    - Наиболее часто используемые роли inner-модуля

  > Общая информация о inner-модуле:
    - Это внутренний модуль приложения.
    - Он является одним из не корневых узлов дерева модулей.
    - На вход принимает свои inner-модули-зависимости 1-й линии.
    - На выход можер вернуть что угодно: объект, фукнцию, литерал.
    - В 90% случаев на выход возвращает ссылку на объект с функционалом.
    - В 10% случаев на выход возвращает объект-прототип какой-нибудь
      подсущности приложения.
    - Может использоваться, как библиотека функций для всего приложения.

  > Наглядная схематичная структура inner-модуля


                   [inner-модуль]
                      /\     /\
                     /  \   /  \      выходы
                      ||     ||
                    -------------
                    |           |
                    |   MAIN    |
                    |   МОДУЛЬ  |
                    |           |
                    |           |
                    -------------
                      /\     /\
                     /  \   /  \      входы
                      ||     ||
           [inner-модуль] ... [inner-модуль]

  > Наиболее часто используемые роли inner-модуля
    - Библиотека часто используемых функций приложения
    - Реализация части функционала приложения
    - Реализация прототипа для какой-нибудь подсущности, которую использует приложение.


> 1.2.  Архитектура объекта-прототипа

  > Подоглавление:
    - Декомпозиция на составляющие и общий взгляд
    - Наглядная схема

  > Декомпозиция на составляющие и общий взгляд

      1.2.  Архитектура объекта-прототипа
        1.2.1.  Архитектура функции-конструктора
          - Она содержится в свойстве constructor объекта-прототипа.
          - Она автоматически запускается при создании экземпляра из прототипа.
          - Она принимает 1 аргумент - конфигурационный объект, описывающий начальное состояние экземпляра.
          - Она "собирает" и возвращает в конце себя ссылку на новый объект-экземпляр приложения.
          - Она проводит все необходимые процедуры при создании нового экземпляра.
            Например, икрементирует счётчик экземпляров, добавляет новый экземпляр в коллекцию.
          - Она сохраняет инициирует в объекте-экземпляре start-объект.
          - Она создаёт manage-объект, и инициирует его копией start-объекта.
          - Она инициирует весь функционал приложения, который будет доступен из экземпляра.
          - Она добавляет синтаксический сахар для некоторого инициируемого функционала.

        1.2.2.  Архитектура набора статических свойств
          - Определяются, как свойства объекта-прототипа, наравне с конструктором.
          - Статические они потому, что доступны в deploy-модуле через объект-прототип.
          - Идеальное место для размещения некого функционала, общего для всех экземпляров приложения.
          - Среди них функции create/delete для создания/узаления экземпляров приложения.
          - Среди них default-объект со значениями по умолчанию для всех параметров.
          - Среди них коллекция присутствующих в документе экземпляров приложения.
          - Среди них счётчик созданных в документе экземпляров приложения.

        1.2.3.  Архитектура структуры связей между manage-объектом и DOM-проекцией
          - Значение каждого св-во manage-объекта отражается на DOM-проекции.
          - Для каждого свойства manage-объекта должо быть прописано правило,
            как отражено его значение в DOM-проекции. И как последняя меняется
            при изменении значения данного свойства manage-объекта.
          - Совокупность таких правил - и есть структура связей между
            manage-объектом и DOM-проекцией.

  > Наглядная схема
    - Ниже вы можете увидеть некий базовый шаблон объекта прототипа.
    - Разумеется, он может дополняться любыми иными статическими свойствами,
      это зависит от вашей задачи.

      var prototype = {

        // Функция-конструктор
        constructor: function(config) {
          ... реализация конструктора ...
        },

        // Различные статические свойства

          ... код ...

      };


> 1.2.1.  Архитектура функции-конструктора

  > Подоглавление:
    - Наглядная схема
    - Декомпозиция на составляющие и общий взгляд

  > Наглядная схема
    - Ниже вы можете увидеть некий базовый шаблон функции-конструктора.
    - Разумеется, он может дополняться любым иным функционалом, это зависит
      от вашей задачи.

      constructor: function(config) {

        // Проведение всех необходимых процедур, предусмотренных при
        // создании нового экземпляра приложения. Например:
        // - Инкремент счётчика экземпляров в соотв.стат.св-ве прототипа.
        // - Добавление нового экземпляра в коллекцию в соотв.стат.св-ве прототипа.

          ... код ...

        // Создание и инициация start-объекта
        this.start = {
          ... код ...
        };

        // Создание и инициация manage-объекта
        this.manage = {
          ... код ...
        };

        // Создание и инициация bin-объекта с функционалом приложения
        // - При инициации может использоваться синтаксический сахар,
        //   например, чтобы запускать функцию в нужном контексте.
        this.bin = {
          ... код ...
        };

        // Создание и инициация dom-объекта, содержащего DOM-проекцию экземпляра приложения.
        this.dom = {
          ... код ...
        };

        return this;  // В конце конструктора вернуть ссылку на созданный экземпляр

      }

  > Декомпозиция на составляющие и общий взгляд

      1.2.1.  Архитектура функции-конструктора
        1.2.1.1.  Архитектура конфигурационного объекта, принимаемого на вход конструктором
          - Конструктор принимает на вход на вход конфигурационный объект.
          - Из него он может сформировать start-объект в экземпляре приложения.
          - Фактически, конфигурационный объект определяет начальные параметры и данные экземпляра.
          - В конфиге можно передать значения для любого набора свойств из default-объекта.
          - Значения передаются в формате имя/значение.
          - Конфиг может быть опущен, и тогда значения для start-объекта будут взяты из default-объекта.

        1.2.1.2.  Архитектура сопроводительных процедур при создании нового экземпляра прилоежния
          - При создании нового экземпляра могут быть предусмотрены сопровождающие
            этот процесс процедуры.
          - Количество и сущность этих процедур зависит от конкретного прложения.
          - Но есть и типовые процедуры, которые есть в 99% всех приложений.

        1.2.1.3.  Архитектура инициации start-объекта
          - Создаётся новый объект.
          - В нём создаются все свойства, которые должны быть в manage-объекте.
          - В конфиге могут быть переданы значения для от 0 до всех свойств manage-объекта.
          - Все переданные значения проверяются на соответствие ограничениям.
            Если не соответствуют, то либо исправляются, либо игнорируются.
          - Все не переданные или не прошедшие проверку (и не поддающиеся исправлению)
            значения заменяются на значения по умолчанию из default-объекта из прототипа.
          - В итоге, все свойства start-объекта должны быть инициированы значением.

        1.2.1.4.  Архитектура инициации manage-объекта
          - Создаётся новый объект.
          - В него копируется содержимое start-объекта ПО ЗНАЧЕНИЮ, а не по ссылке.

        1.2.1.5.  Архитектура инициации bin-объекта с функционалом приложения
          - Bin-объект содержит весь функционал экземпляра приложения.
          - В нём могут быть свойства любых типов: литералы, фукнции и т.д.
          - Если функционала много, он может быть разбит по подобъектам.
          - Все функции, кроме обработчиков событий, должны быть обёрнуты
            в функцию-обёртку, которая будет вызывать их с помощью apply
            в контексте объекта-экземпляра, а не в контексте подъобъекта,
            в котором они фактически находятся.

        1.2.1.6.  Архитектура инициации dom-объекта с DOM-проекцией экземпляра
          - Как известно, DOM-проекция может состоять из нескольких отдельных частей.
          - А каждая часть - это 1 корневой DOM-элемент, содержащий дерево других DOM-элементов.
          - Главное правило организации dom-объекта - каждая часть лежит в своём отдельном свойстве.
          - А название свойства должно отражать назначение части, которую он содержит.


> 1.2.1.1.  Архитектура конфигурационного объекта, принимаемого на вход конструктором

  > Подоглавление:
    - Что может содержать конфигурационный объект?

  > Что может содержать конфигурационный объект?
    - Любой набор свойств, которые присутствуют в default-объекте.
    - Может быть пуст (*Исключения: могут быть и обязательные свойства)
    - То есть передать можно только значения для тех свойств, для которых
      это требуется. А всем остальным будут автоматически присвоены значения
      по умолчанию.

  > Наглядный пример того, что может содержать конфиг:

                      Конфиг      Конфиг      Конфиг          и
   default объект:    вариант 1:  вариант 2:  вариант 3:      так
   {                  {           {           {               далее -
      a: 10,          }             a: 20       a: 100,       любые
      b: 20,                      }             b: 200,       комбинации
      c: 30,                                    c: 300,       свойств
      d: 40,                                    d: 400,       a,b,c,d,e
      e: 50                                     e: 500        ...
   }                                          }


> 1.2.1.2.  Архитектура сопроводительных процедур при создании нового экземпляра прилоежния

  > Подоглавление:
    - Часто используемые сопроводительные процедуры при создании нового экземпляра

  > Часто используемые сопроводительные процедуры при создании нового экземпляра
    - Инкремент счётчика созданных в документе экземпляров.
    - Добавление нового экземпляра в коллекцию экземпляров данного приложения.
    - ...


> 1.2.1.3.  Архитектура инициации start-объекта

  > Подоглавление:
    - Что должен содержать start-объект после инициации?
    - Ограничения для значений свойств объекта
    - Какими значениями должен быть инициирован start-объект?
    - Описание процесса инициации start-объекта в объекте-экземпляре
    - Наглядный пример инициации start-объекта

  > Что должен содержать start-объект после инициации?
    - Должен содержать весь тот же набор свойств, что присутствует в default-объекте.
      Не больше, не меньше.
    - Все эти свойства должны быть инициированы значениями.

  > Ограничения для значений свойств объекта
    - Диапазон значений каждого из свойств может быть ограничен
      определёнными значениями.
    - Если переданное значение не соответствует, то оно может быть либо
      проигнорировано, либо исправлено.

  > Какими значениями должен быть инициирован start-объект?
    > Тут 3 варианта:
      1)  Значение, переданное через конфигурационнй объект.
        - Используется в том случае, если оно было передано через конфиг,
          и если оно удовлетворяет ограничениям, наложенным на значения
          данного свойства.
      2)  Автоматически исправленное значение, переданное через конфигурационнй объект.
        - Используется в том случае, если оно было передано через конфиг,
          при этом оно не соответствовало ограничениям, но было успешно
          исправлено.
      3)  Значение "по умолчанию", взятое из default-объекта.
        - Используется, если значение не было передано через конфиг.
        - Используется, если значение было передано через конфиг, но не
          прошло ограничения, и не было исправлено.

  > Описание процесса инициации start-объекта
    1.  В объекте-экземпляре создаётся новое свойство start, и
        инициируется пустым объектом.
    2.  Внутри объекта start происходит последовательная инициация
        всех свойств, которые присутствуют в default-объекте.

  > Наглядный пример инициации start-объекта
    > Плюс для значений некоторых свойств у нас есть правлиа:
      - x должен быть не менее 50
      - z должен быть не более 2


      Переданный         Содержание         Итоговый
      конструктору   =>  default-     =>    start-
      конфиг:            объекта:           объект:

        {                {                 {
          x=10,            x=5,              x=50,
          y=20,            y=15,             y=20,
          z=30             z=25,             z=2,
                           q=40,             q=40,
                           k=50              k=50
        }                }                 }


> 1.2.1.4.  Архитектура инициации manage-объекта

  > Подоглавление:
    - Описание процесса инициации manage-объекта

  > Описание процесса инициации manage-объекта
    1.  В объекте-экземпляре создаётся новое свойство manage, и
        инициируется пустым объектом.
    2.  В manage-объект копируются ПО ЗНАЧЕНИЮ все свойства start-объекта.


> 1.2.1.5.  Архитектура инициации bin-объекта с функционалом приложения

  > Подоглавление:
    - Описание процесса инициации bin-объекта

  > Описание процесса инициации bin-объекта
    1.  В объекте-экземпляре создаётся новое свойство bin.
    2.  Если функционал приложения разбит по подгруппам, то внутри bin
        создаются свойства, имена которых отражают смысл этих подгрупп.
    3.  В каждой подгруппе инициируются свойства, каждое из которых
        обозначает некий функционал - функцию или данные.
    4.  Для инициации данных свойств используются данные, поступившие
        на вход main-модуля, в котором всё это и происходит.
    5.  Все функции, кроме обработчиков событий, должны быть обёрнуты
        в функцию-обёртку, которая будет вызывать их с помощью apply
        в контексте объекта-экземпляра, а не в контексте подъобъекта,
        в котором они фактически находятся.
    6.  Прочий функционал, для которого нет спец. условий, как на контекст
        для функций, инициируется без затей.

> 1.2.1.6.  Архитектура инициации dom-объекта с DOM-проекцией экземпляра

  > Подоглавление:
    - Принципы инициации dom-объекта
    - Описание процесса инициации dom-объекта

  > Принципы инициации dom-объекта
    - Как известно, DOM-проекция может состоять из нескольких отдельных частей.
    - А каждая часть - это 1 корневой DOM-элемент, содержащий дерево других DOM-элементов.
    - Главное правило организации dom-объекта - каждая часть лежит в своём отдельном свойстве.
    - А название свойства должно отражать назначение части, которую он содержит.

  > Описание процесса инициации dom-объекта
    1.  В объекте-экземпляре создаётся новое свойство dom.
    2.  Внутри dom создаются свойства, имя каждого из которых отражает
        смысл той части dom-проекции, которая в нём будет лежать.
    3.  Каждое из этих свойств иницируется соответствующей частью dom-проекции.
        Скорее всего функционал для работы с dom-проекций будет вынесен в отдельный
        модуль, так что для инициации потребуется использовать эти фукнции.

> 1.2.2.  Архитектура набора статических свойств

  > Подоглавление:
    - Описание
    - Наиболее часто используемые статичекие свойства

  > Описание
    - Определяются, как свойства объекта-прототипа, наравне с конструктором.
    - Статические они потому, что доступны в deploy-модуле через объект-прототип.
    - Идеальное место для размещения некого функционала, общего для всех экземпляров приложения.
    - Среди них функции create/delete для создания/узаления экземпляров приложения.
    - Среди них default-объект со значениями по умолчанию для всех параметров.
    - Среди них коллекция присутствующих в документе экземпляров приложения.
    - Среди них счётчик созданных в документе экземпляров приложения.

  > Наиболее часто используемые статичекие свойства
    - Create: функция создания нового объекта. Одна из её задач - служить
              синтаксическим сахаром.
    - Delete: функция удаления нового объекта. Тут уже не до синтаксического
              сахара, весь функционал по удалинию экземпляра приложения и
              сопровождающие это процедуры находятся в этой функции, ведь
              никаких деструкторов автоматически вызвано не будет.
    - Counter: счётчик присутствующих в документе экземпляров приложения,
               всегда содержащий актуальную информацию.
    - Collection: коллекция ссылок на присутствующие в документе экземпляры
                  приложения, доступ к которым можно получить по их id.


> 1.2.3.  Архитектура структуры связей между manage-объектом и DOM-проекцией

  > Подоглавление:
    - Описание
    - Наглядный пример того, как можно описать структуру связей между manage-объектом и DOM-проекцией
    - Как это использовать

  > Описание
    - Значение каждого св-во manage-объекта отражается на DOM-проекции.
    - Для каждого свойства manage-объекта должо быть прописано правило,
      как отражено его значение в DOM-проекции. И как последняя меняется
      при изменении значения данного свойства manage-объекта.
    - Совокупность таких правил - и есть структура связей между
      manage-объектом и DOM-проекцией.

  > Наглядный пример того, как можно описать структуру связей между manage-объектом и DOM-проекцией

    1.  Допустим, у нас в manage-объекте 3 свойства:
          {
            a
            b
            c
          }

    2.  Допустим, у нас DOM-проекция состоит из 1-й части, и представляет
        собой список UL.

    3.  Пропишем связи между параметрами manage-объекта и DOM-представления
        > a
          - Представляет кол-во элементов li в списке UL.
          - Может быть от 0 до 10.
        > b
          - Значение типа boolean.
          - Означает, подключить ли класс "super" эл-ту UL.
        > c
          - Значение типа string
          - Означает, какую строку поместить в каждый li.

    4.  Создадим наглядный макет с плейсхолдерами структуры связей.
        - Отразим на схеме всё, что можно.
        - В данном случае связь между параметром b и DOM-проекцией
          на схеме отразить проблематично, поэтому учитываем её в уме.

          <ul class={b}>
            <li>{c}</li>
            <li>{c}</li>
            <li>{c}</li>
          </ul>

    5.  Создадим пример валидной итоговой HTML-разметки, которая должна
        получаться при вставке DOM-представления (в нашем случае
        DOM-элемента UL) в документ:

          <ul class='super'>
            <li>Иван петров стремится к знаниям</li>
            <li>Иван петров стремится к знаниям</li>
            <li>Иван петров стремится к знаниям</li>
          </ul>

  > Как это использовать
    - Допустим, DOM-проекция создана, ссылка на неё и размещена в свойстве dom.
    - В примере выше она представляет собой DOM-элемент ul,
      который содержит потомков - другие DOM-элементы.
    - Можно взять эту ссылку и добавить в документ с помощью, например, appendChild.
    - Тогда пользователь увидит всё это в документе.
    - Это и есть интерфейс, с которым может взаимодействовать пользователь.
    - Если что-то понадобится в экземпляре приложения изменить, то надо
      воспользоваться специальным функционалом, который соблюдая 100% синхронизацию
      между manage-объектом и DOM-проекцией приложения внесёт изменения.
    - После изменений автоматически перерисуется и DOM-проекция, размещённая
      в документе.


> 1.3.  Архитектура объекта-экземпляра

  > Подоглавление:
    - Декомпозиция на составляющие и общий взгляд
    - Как может быть создан объект-экземпляр из объекта-прототипа?

  > Декомпозиция на составляющие и общий взгляд

      1.3.  Архитектура объекта-экземпляра
        1.3.1.  Архитектура start-объекта
          - Хранится в свойстве start объекта-экземпляра.
          - Содержит строго задуманный набор свойств, на 100% совпадающий набором из default-объекта
          - Полностью описывает начальное состояние экземпляра приложения при
            его создании (все параметры и данные).
          - Создаётся конструктором из переданного ему конфига и default-объекта.
          - Не переданные в конфигурационном объекте св-ва создаются автоматически
            и инициируются значениями из default-объекта.
          - Защищён от записи программно.

        1.3.2.  Архитектура manage-объекта
          - Хранится в свойстве manage объекта-экземпляра.
          - При создании экземпляра инициируется КОПИЕЙ start-объекта.
          - Свойства manage и старт содержат ссылки на РАЗНЫЕ объекты.
          - Создаётся конструктором как КОПИЯ start-объекта.
          - Доступен для записи.
          - Полностью описывает текущее актуальное состояние объекта-экземпляра приложения.
          - Прямое изменение значений свойств запрещено, делать это нужно
            только через "функционал для работы с приложениями", который соблюдает
            100% синхронизацию между manage-объектом и DOM-проекцией.

        1.3.3.  Архитектура dom-объекта c DOM-проекцией приложения
          - Она хранится в св-ве dom объекта-экземпляра.
          - Она всегда на 100% синхронизирована с manage-объектом.
          - Она является интерфейсом приложения, который может быть размещён в документе.
          - Интерфейс может быть распределённым, и состоять из нескольких частей.
          - Она состоит из >= 1 древообразной структуры из DOM-элементов.
          - Каждая такая древообразная структура - это отдельная часть интерфейса.
          - При изменении приложения спец.функционалом, они сразу автоматич.отражаются в интерфейсе.
          - Прямое изменение DOM-проекции запрещено, делать это нужно
            только через "функционал для работы с приложениями", который соблюдает
            100% синхронизацию между manage-объектом и DOM-проекцией.

        1.3.4.  Архитектура bin-объекта с функционалом для работы с приложением
          - Хранится в свойстве bin объекта-экземпляра приложения.
          - Инициируется в функции-конструкторе прототипа.
          - Контекст для всех функций, кроме обработчиков событий - это
            объект-экземпляр приложения.
          - Любые изменения экземпляра следует проводить только через эти фукнции.
          - Обеспечивает 100% синхронизацию manage-объекта и DOM-проекции.
          - Прямые изменения manage-объекти и DOM-проекции в обход этого
            функционала запрещены.

  > Как может быть создан объект-экземпляр из объекта-прототипа?

    > Общая информация
      - Объект-экземпляр приложения создают, как потомок объекта-прототипа приложения.
      - Объект-прототип в deploy-модуль передан main-модулем приложения.
      - Объект-экземпляр создают в deploy-модуле, который эксплуатирует это приложение.


    > Вот так выглядит процесс создания объекта-экземпляра
      1.  Подготовить конфигурационный объект.
      2.  Запустить функцию конструктор прототипа, и передать ей конфиг в виде аргумента.
          - Она вернёт ссылку на свежесозданный объект-экземпляр.
          - Часто для этого шага предусмотрена функция create, которая представляет
            из себя синтаксический сахар. И создание экземпляра выглядит так:

              [экземпляр] = [прототип].create([конфиг]);

    > Наглядная схема создания экземпляра:

        [Объект-прототип приложения]
                    ||
                    || <= [Конфигурационный объект]
                    \/
        [Функция-конструктор приложения в объекте-прототипе]
                    ||
                    \/
        [Объект-экземпляр приложения]

  > Наглядная схема архитектуры объекта-экземпляра:

      Имя св-ва   Тип   Описание
      ----------------------------------
      {
        start     {}    start-объект с начальным состоянием экземпляра
        manage    {}    manage-объект с текущим состоянием экземпляра
        bin       {}    bin-объект, содержит весь функционал экземпляра
        dom       {}    dom-объект, содержит DOM-проекцию экземпляра
      }


> 1.3.1.  Архитектура start-объекта

  > Подоглавление:
    - Описание
    - Наглядный пример
    - Программная защищённость от записи
    - Что из себя представляет start-объект?

  > Описание
    - Хранится в свойстве start объекта-экземпляра.
    - Содержит строго задуманный набор свойств, на 100% совпадающий набором из default-объекта
    - Полностью описывает начальное состояние экземпляра приложения при
      его создании (все параметры и данные).
    - Создаётся конструктором из переданного ему конфига и default-объекта.
    - Не переданные в конфигурационном объекте св-ва создаются автоматически
      и инициируются значениями из default-объекта.
    - Защищён от записи программно.

  > Наглядный пример

    Допустим, наш default-объект  =>  Тогда start-объект должен содержать тот же
    выглядит так:                     набор свойств, значения могут отличаться
      {                                 {
        a: 20,                            a: 10,
        b: 30,                            b: 500,
        c: 40,                            c: 40,
        d: 50                             d: 200
      }                                 }

  > Программная защищённость от записи
    - Защищённость нужна, потому что start-объект не предназначен для записи.
    - Он просто хранит начальное состояние и всё. Его можно только считывать.
    - Чтобы защитить св-ва объекта от записи, нужно атрибуту "writable" каждого
      из них присвоить значение false. Сделать это можно с помощью метода
      Object.defineProperty. Подробнее об этом в моём справочинке по ядру JS.

  > Что из себя представляет start-объект?
    - Полностью описывает начальное состояние экземпляра приложения при
      его создании (все параметры и данные).
    - Это значит, что start-объект содержит значения всех параметров
      экземпляра, включая все его данные.


> 1.3.2.  Архитектура manage-объекта

  > Подоглавление:
    - Описание
    - О копировании объекта по значению
    - Наглядный пример
    - Что из себя представляет manage-объект?
    - Как работать с manage-объектом?

  > Описание
    - Хранится в свойстве manage объекта-экземпляра.
    - При создании экземпляра инициируется КОПИЕЙ start-объекта.
    - Свойства manage и старт содержат ссылки на РАЗНЫЕ объекты.
    - Создаётся конструктором как КОПИЯ start-объекта.
    - Доступен для записи.
    - Полностью описывает текущее актуальное состояние объекта-экземпляра приложения.
    - Прямое изменение значений свойств запрещено, делать это нужно
      только через "функционал для работы с приложениями", который соблюдает
      100% синхронизацию между manage-объектом и DOM-проекцией.

  > О копировании объекта по значению
    - Объект можно скопировть либо по значению, либо по ссылке.
    - Если скопировать по ссылке из переменной x в переменную y, то в обеих
      переменных ссылка будет указывать на один и тот же объект.
    - Если скопировать по значению из переменной x в переменную y, то
      в каждой переменной будет лежать ссылка на свой собственнй объект.
    - Manage-объект инициируется путём копирования start-объекта
      ПО ЗНАЧЕНИЮ, а не по ссылке.

  > Наглядный пример

    Допустим, вот так выглядит      Инициируем manage-объект путём копирования
    start-объект                    start-объекта по значению:
      {                               {
        a: 10,                          a: 10,
        b: 20,             ===>         b: 20,
        c: 30                           c: 30
      }                               }

                                                ||
                                                ||
                                                \/
    При этом start-объект не        Изменим значение свойства a на 500:
    изменился:                        {
      {                                 a: 500,
        a: 10,              <===        b: 20,
        b: 20,                          c: 30
        c: 30                         }
      }

  > Что из себя представляет manage-объект?
    - Полностью описывает текущее состояние экземпляра приложения
      (все параметры и данные). То есть он в любой момент времени
      отражает актуальное состояние экземпляра приложения.
    - Это значит, что start-объект содержит значения всех параметров
      экземпляра, включая все его данные.


  > Как работать с manage-объектом?
    - Запрещено вручную прямо менять значения свойств manage- и dom-объекта.
    - Работать с ними нужно только через функционал из bin-объекта.
    - Это позволяет изменять настроки и данные приложения, при этом
      одновременно обеспечивая 100% синхронизацию между manage- и dom-объектами.



> 1.3.3.  Архитектура dom-объекта c DOM-проекцией приложения

  > Подоглавление:
    - Описание
    - О структуре dom-объекта
    - О распределённом интерфейсе DOM-проекции из нескольких частей
    - Наглядный пример структуры dom-объекта с DOM-проекцией из 3-х частей
    - О структуре связей между dom-объектом и manage-объектом
    - О постоянной 100%-й синхронизации manage-объекта и dom-объекта
    - Как работать с dom-объектом?
    - О публикации интерфейсов DOM-проекции в документе
    - О мгновенном отражении измений в док-те при изменении в DOM-проекции

  > Описание:
    - Она хранится в св-ве dom объекта-экземпляра.
    - Она всегда на 100% синхронизирована с manage-объектом.
    - Она является интерфейсом приложения, который может быть размещён в документе.
    - Интерфейс может быть распределённым, и состоять из нескольких частей.
    - Она состоит из >= 1 древообразной структуры из DOM-элементов.
    - Каждая такая древообразная структура - это отдельная часть интерфейса.
    - При изменении приложения спец.функционалом, они сразу автоматич.отражаются в интерфейсе.
    - Прямое изменение DOM-проекции запрещено, делать это нужно
      только через "функционал для работы с приложениями", который соблюдает
      100% синхронизацию между manage-объектом и DOM-проекцией.

  > О структуре dom-объекта
    - Dom-объект содержит свойства, имена которых отражают сущность
      того интерфейса, ссылка на который лежит в этом свойстве.
    - А в каждом таком свойстве лежит ссылка на 1 DOM-объект, который
      внутри себя древообразным образом содержит другие DOM-объекты.
      В совокупности, такой DOM-объект является частью DOM-проекции
      приложения. А если он у приложения только один, то и целой
      DOM-проекцией.

  > О распределённом интерфейсе DOM-проекции из нескольких частей
    - DOM-проекция не обязательно должна быть представлена только
      одним корневым DOM-элементом, являющимся единственным интерфейсом
      этого приложения.
    - DOM-проекция может состоять из любого кол-ва частей, каждая из
      которых представляет отдельный интерфейс, который может быть
      размещён где угодно в документе.
    - Каждую часть представляет ссылка на 1 DOM-элемент, который внутри
      себя древообразно уже содержит другие DOM-элементы.

  > Наглядный пример структуры dom-объекта с DOM-проекцией из 3-х частей
    > Допустим, у нас приложение-дерево.
    > И его DOM-представление состоит из 4-х частей:
      - Само дерево
      - Панель с кнопками "добавить узел" и "удалить узел".
      - Статистика дерева (общее кол-во узлов, кол-во раскрытых узлов и т.д.)

      Имя св-ва     Содержание
    -----------------------------------------
      {
        tree        Ссылка на DOM-элемент DIV, в котором находится дерево
        control     Ссылка на DOM-элемент DIV, в котором находятся кнопки
        stats       Ссылка на DOM-элемент DIV, в котором отображаются данные
      }

  > О структуре связей между dom-объектом и manage-объектом
    - Эта область описана выше в пункте:
      "1.2.3.  Архитектура структуры связей между manage-объектом и DOM-проекцией"

  > О постоянной 100%-й синхронизации manage-объекта и dom-объекта
    - Manage-объект и dom-объект в любой момент времени постоянно на 100%
      синхронизированы в сооветствии со структурой связей между ними.
    - Синхронизация не означает, что в них лежат одинаковые свойства
      с одинаковыми значениями. То есть связь не прямая, а в соответствии
      с определённым набором правил. Подробнее об этом см. по ссылке
      выше "О структуре связей...".

                     [manage-объект]
                            /\
                            ||
      100% синхронизация => || <= [Функционал для работы экземпляром приложения]
                            ||
                            \/
                        [dom-объект]

  > Как работать с dom-объектом?
    - Запрещено вручную прямо менять значения свойств manage- и dom-объекта.
    - Работать с ними нужно только через функционал из bin-объекта.
    - Это позволяет изменять настроки и данные приложения, при этом
      одновременно обеспечивая 100% синхронизацию между manage- и dom-объектами.

  > О публикации интерфейсов DOM-проекции в документе
    - Чтобы пользователь их увидел, интерфейсы приложения - части
      DOM-проекции - должны быть опубликованы в документ.
    - Сделать это можно, например, с помощью функции appendChild.

  > О мгновенном отражении измений в док-те при изменении в DOM-проекции
    - Допустим, интерфейсы приложения опубликованы в документе.
    - И нам понадобилось изменить настройки или данные прилоежния.
    - Мы вносим изменения с помощью спец.функционала из bin-объекта.
    - Синхронно изменяются manage-объект и dom-объект.
    - Пользователь мгновенно видит изменения в опубликованных частях
      DOM-проекции.


1.3.4.  Архитектура bin-объекта с функционалом для работы с приложением

  > Подоглавление:
    - Описание
    - О структуре bin-объекта
    - Наглядный пример структуры bin-объекта
    - О контексте выполнения функций в bin-объекте

  > Описание
    - Хранится в свойстве bin объекта-экземпляра приложения.
    - Инициируется в функции-конструкторе прототипа.
    - Контекст для всех функций, кроме обработчиков событий - это
      объект-экземпляр приложения.
    - Любые изменения экземпляра следует проводить только через эти фукнции.
    - Обеспечивает 100% синхронизацию manage-объекта и DOM-проекции.
    - Прямые изменения manage-объекти и DOM-проекции в обход этого
      функционала запрещены.

  > О структуре bin-объекта
    - Функционал для работы с экземпляром приложения, размещённый внутри
      объекта-экземпляра в bin-объекте, может быть для удобства разбит
      на подгруппы.
    - Каждую подгруппу может представлять отдельное свойство внутри
      bin-объекта. Например:
        bin.[подгруппа 1]
        bin.[подгруппа 2]
        ...
    - В каждой подгруппе находятся свойства, каждое из которых уже
      непосредственно содержит функционал или данные для работы с
      объектом-экземпляром приложения.
    - Имя каждого из этих свойств должно отражать сущность функционала,
      который он содержит.

  > Наглядный пример структуры bin-объекта

      {
        common = {
          ... функционал из подгруппы common ...
        },
        selection = {
          ... функционал из подгруппы selection ...
        },
        closeopen = {
          ... функционал из подгруппы closeopen ...
        }
      }

  > О контексте выполнения функций в bin-объекте
    - Как показано выше, в bin-объекте функции могут быть для удобства
      разложены по объектам-подгруппам.
    - Но при выполнении функции она выполняется в контексте того
      объекта, в контексте которого вызвана. Так что если, например,
      запустить функцию из подгруппы common в контексте этого объекта,
      то в его контексте она и вызовется.
    - Но нас это не устраивает. Изначально все функции, которые должны
      будут попасть в bin-объект, должны быть написаны с учётом того,
      что вызваны они будут в контексте объекта-экземпляра.
    - Все, кроме обработчиков событий - они вызываются в контексте того
      DOM-элемента, к которому они добавлены.
    - Чтобы организовать вызов функций в контексте объекта-экземпляра,
      надо при инициализации bin-объекта в функции-конструкторе завернуть
      эти функции в функции-обёртки, внутри которых выполнить эти функции
      с помощью apply в нужном контексте.






















