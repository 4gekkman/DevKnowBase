/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
1. Переменные - типы - приведение

=
> Однострочные и многострочные комментарии
> Техники просмотра значения переменной
  > Alert()
  > document.write()
  > console.log()

> Константы
  > Пример
> Переменные
  > Создание
  > Применение
  > Явное объявление типов
> Демонстрация проблемы с неточностью вычислений при работе с не целыми числами
> NaN, +Infiniti, -Infinity
> Типы переменных

> Способы определить тип переменной
  > isNaN()          | приводит аргумент к number и определяет, NaN получился, или нет
  > isFinite()       | является ли аргумент одним из: NaN, +Infinite, -Infinite
  > isNumeric()      | (пользовательская) Проверка на число для любого типа
  > Оператор typeof  | возвращает строку с типом аргумента
  > Техника определения класса переменной типа object
    с помощью техники заимствования метода
  > Техника проверки соответствия объекта конкретному классу,
    проверяя наличие характерных только для этого класса свойств
  > Проверка объекта на соответствие указанному классу   | оператор instanceof
    (так можно проверять пользовательские объекты)

> Приведение типов (примитивы)
  > -> number
  > -> string
  > -> boolean

> Приведение типов (объекты)
  > object -> string
  > object -> number

> Сравнение null и undefined


 -------------------------------------------------- */

// Однострочные и многострочные комментарии
    // Это - однострочный комментарий
    /* Это -
           многострочный
                комментарий
     */

// Техники просмотра значения переменной
// Alert()

// document.write()

// console.log()


// Константы
    // Пример
        var PI = 3.14;

// Переменные
    // Создание
    var x = 10;
    // Применение
    var y = x + 5;  // 15
    // Явное объявление типов
    var x1 = new Number;
    var x2 = new String;
    var x3 = new Boolean;
    var x4 = new Array;
    var x5 = new Object;
    x1 = 'df';  // все равно ей можно задать значение другого типа, ошибки нет

// Демонстрация проблемы с неточностью вычислений при работе с не целыми числами
console.log('Неточные вычисления: 0.1.toFixed(20) = ' + 0.1.toFixed(20));  // 0.10000000000000000555

// NaN, +Infiniti, -Infinity
    // Получение +Infinity
        var inf = 1/0;    // Infinity
        // +Infinity равна и строго равна самой себе
            r = inf == Infinity;   // true
            r = inf === Infinity;  // true
    // Получение -Infinity
        var inf = -1/0;   // -Infinity
        // -Infinity равна и строго равна самой себе
            r = inf == -Infinity;   // true
            r = inf === -Infinity;  // true
    // Получение NaN
        var nan = 1/'Колю';
        // Любые операции с NaN - это NaN
            r = nan + 10;     // NaN
        // NaN ничему не равен, даже себе
            r = NaN == NaN;   // false

// Типы переменных
r = 10.5;                // number
r = 'Строка';            // string
r = true;                // boolean
r = null;                // null
r = undefined;           // undefined
r = {};                  // object (класс Object)
   r = [1,2,3];          //    object (класс Array)
   r = new Date;         //    object (класс Date)
   // ...                // ...



// Способы определить тип переменной
    // boolean isNaN([Number] x)
    // > приводит аргумент к number и определяет, NaN получился, или нет
        r = isNaN(10);    // false     (нет, не NaN)
        r = isNaN('');    // false
        r = isNaN(null);  // false
        r = isNaN(false); // false
        r = isNaN(true);  // false
        r = isNaN('John');// true

    // boolean isFinite([Number] x)
    // > Возвращает false, если x равен NaN, +Infinity, -Infinity; иначе true.
        r = isFinite(NaN);        // false
        r = isFinite(-Infinity);  // false
        r = isFinite(+Infinity);  // false
        r = isFinite(10);         // true

    // boolean isNumeric(n)
    // > Пользовательская функция
    // > Проверяет, является ли аргумент числом
    // > Возвращает true, если аргумент - число; иначе false
        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        r = isNumeric('124dfs');    // false
        r = isNumeric('444');       // true
        r = isNumeric('5.23');      // true
        r = isNumeric(15);          // true
        r = isNumeric(true);        // false
        r = isNumeric('1');         // true
        r = isNumeric({});          // false
        r = isNumeric([1,2,3]);     // false

    // Оператор typeof
    // > Возвращает строку, содержащую имя типа
    // > Есть 2 равнозначных синтаксиса:
    //   > typeof X
    //   > typeof(x)
    // > Недостаток: все объекты - включая массивы, даты и другие -
    //   имеют тип 'object', и с помощью typeof их не различить.
        r = typeof undefined;     // 'undefined'
        r = typeof 0;             // 'number'
        r = typeof true;          // 'boolean'
        r = typeof 'foo';         // 'string'
        r = typeof {};            // 'object'

        r = typeof null;          // 'object'
        r = typeof function(){};  // 'function'

    // Техника определения класса переменной типа object
    // > С помощью техники одалживания метода (подробное описание в Информации ниже)
    // > Недостаток: класс пользовательских объектов так не определить, только встроенных
        // Взять не переопределенный метод toString() у стандартного объекта
            var toStringVirgin = {}.toString;              // здесь теперь лежит function

        // > Запустить toStringVirgin в контексте объекта, класс которого нужно узнать
        // > Так как toStringVirgin вернет значение в стиле [object Array]  , надо бы
        //   обрезать все лишнее - все, кроме Array
            r = toStringVirgin.call([1,2,3]).slice(8,-1);  // Array
            r = toStringVirgin.call(new Date).slice(8,-1); // Date

    // Техника проверки соответствия объекта конкретному классу ...
    // > Проверяя наличие характерных только для этого класса свойств
        // Проверка, не Array ли
            if([1,2].splice) {}     // splice() - это метод; splice - это свойство со значением типа function.
        // Проверка, не Date ли
            if((new Date).getTime) {}

    // Проверка объекта на соответствие указанному классу (оператор instanceof)
    // > Так можно проверять пользовательские объекта
    // > Можно также проверять и встроенные объекты, но не рекомендуется,
    //   так как есть недостаток (см. Информацию). Поэтому лучше использовать
    //   технику заимствования метода.
    // > Возвращает true, если объект соответстует указанному классу; иначе false;
        // Проверка типа встроенных объектов (не рекомендуется использовать для этого instanceof)
            r = [1,2] instanceof Array;        // true
            r = (new Date) instanceof Date;    // true

        // Проверка типа пользовательского класса
            function myClass1() {}
            res = new myClass1();
            r = res instanceof myClass1;       // true


// Приведение типов (примитивы)
    var s = '13 друзей Оушена';
    var n = 5.5;
    var b = true;
    var r;  // для результата

    // -> number
        // string -> number
            r = +s;
            r = Number(s);          // NaN   (тип number)
            r = Number('  13  ');   // 13
            r = Number('');         // 0

            r = parseInt('12px');   // 12
            r = parseInt('px12');   // NaN
            r = parseInt('5px12');  // 5

            r = parseFloat('5.5px');// 5.5
            r = parseFloat('a5.5'); // NaN

        // boolean -> number
            r = +b;                 // 1
            r = Number(b);          // 1

        // undefined -> number
            r = +undefined;         // NaN   (тип number)

        // null -> number
            r = +null;              // 0

    // -> string
        // number -> string
            r = String(n);          // '5.5'
            r = '' + n;             // '5.5'

        // boolean -> string
            r = String(b);          // 'true'
            r = '' + b;             // 'true'

    // -> boolean
        // number -> boolean
            r = !!(n);              // true
            r = Boolean(n);         // true

        // string -> boolean
            r = !!(s);              // true
            r = Boolean(s);         // true
            r = !!"0";              // true  (а не false, как в PHP)
        // Все возможные false значения:
            r = !!0;                // false
            r = !!'';               // false
            r = !!null;             // false
            r = !!undefined;        // false
            r = !!NaN;              // false

// Приведение типов (объекты)
    // создаю объект и переопределяю 2 его метода:
    r = {
        user: "Иван",
        age: 20,
        toString: function() {
            return 'Иван';
        },
        valueOf: function() {
            return 20;
        }
    };
    res = String(r);   // 'Иван'     (строковое представление объекта)
    res = Number(r);   // 20         (числовое представление объекта)

// Сравнение null и undefined
    // null и undefined
        r = null >= undefined;   // false
        r = null <= undefined;   // false
        r = null == undefined;   // true
        r = null === undefined;  // false

    // null
        r = null >= null;  // true
        r = null <= null;  // true
        r = null == null;  // true
        r = null === null; // true

        r = null >= 0;     // true
        r = null <= 0;     // true
        r = null == 0;     // false   (это поведение отдельно прописано в стандарте ECMA)

    // undefined
        r = undefined >= undefined;   // false
        r = undefined <= undefined;   // false
        r = undefined == undefined;   // true

        r = undefined >= 0;           // false
        r = undefined <= 0;           // false
        r = undefined == 0;           // false



/* --------------------------------------------------
 ---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

> Современный учебник по JavaScript от Ильи Кантора:
	http://learn.javascript.ru/





*****************************************************
Оглавление:


	> PHP может быть вставлен в любое место документа. А JavaScript - только в head или body.
	> Техники просмотра значения переменной
	> Передача по ссылке, и по значению.
	> Константы
	> Переменные
	> Типы данных
	> Определить имя родителя объекта с помощью техники одалживани метода
	> Приведение типов (примитивы)
	> Приведение типов (объекты)
	> Сравнение типов
		> Гибкое сравнение ==
		> Жесткое сравнение ===
		> Поведение null и undefined при сравнении



*****************************************************




> PHP может быть вставлен в любое место документа. А JavaScript - только в head или body.
	> В отличие от PHP, JavaScript-код можно вставить только внутри тегов
		<head> ... </head> или <body> ... </body> документа. То есть, его
		можно вставить только в голову, и в тело документа.

> Техники просмотра значения переменной
	> Alert()
		> Вызывает модальное окно с переданной в качестве параметра строкой.
		> Минус: если в документе много alert'ов, замучаешься кликать кнопку OK на каждом окне.
	> document.write()
		> Пишет любой текст в укзанное место документа.
		> Его проблема в том, что он пишет этот текс в документ еще до того,
			как браузер построит из него DOM.
			> А вот если попробовать добавить текст в документ этим методом
				после того, как страница уже загрузилась и отобразилась, то он
				удалит все содержимое страницы, и добавить этот самый текст.
	> console.log()
		> Отображает добавленную через аргумент строку в консоли.
		> НАШ ВЫБОР, самый удобный метод для просмотра значения переменной.
	> просмотр через отладку
		> Можно, конечно, просмотривать еще и через отладку. Она в каждом браузере
			происходит по своему. Я пользуюсь Chrome. Описание отладки в chrome
			можно найти здесь: http://learn.javascript.ru/debugging-chrome

> Передача по ссылке, и по значению.
	> Все типы object в JS всегда передаются по ссылке.
	> Все простые типв в JS всегда передаются по значению.
		> Единственный способ передать простой типа по ссылке в JS -
			это сделать из него object.

> Константы
	> В спецификации JS такое понятие отсутствует. Но программисты договорились
		называть константами переменные, написанные большими буквами. Они считают,
		так можно сделать код понятнее.

> Переменные
	> Объявляются с помощью ключевого слова var
	> По умолчанию в JS присваиваются по значению

> Типы данных
	> В JS динаимическая типизация, как и в PHP, так что тип переменной
		определяется интерпретатором автоматически.

	 > В JavaScript всего 6 типов данных - 5 примитивный и 1 сложный.
		 ----------------
		 > number       | числа (целые и дробные)
										| > числа: 0, 3.14, а также NaN и Infinity
		 ----------------
		 > string       | строки
										| > Строки, такие как "Мяу" или пустая строка ""
		 ----------------
		 > boolean      | логический тип
										| > true, false
		 ----------------
		 > null         | ничего
										| > Содержит только значение null и больше ничего
		 ----------------
		 > undefined    | значение не присвоено
										| > Содержит только значение undefined
		 ----------------
		 > object       | объект
										| > Все остальные значения являются объектами, включая функции и массивы




> Определить имя родителя объекта с помощью техники одалживани метода
  > Знать, что переменная имеет тип object зачастую недостаточно. Часто нужно узнать,
    какого класса этот объект: Array, Date, ...
  > Любой объект содержит свойство с информацией о том, какого он класса.
    > Но получить доступ к этому свойству напрямую нельзя.
    > Однако, toString() стандартного объекта как раз и выводит значение
      этого свойства, и выглядит оно так: '[object Object]'
    > Но есть проблема - в большинстве объектов стандартный метод toString()
      переопределен. И больше не выводит свойство с информацией о классе объекта.
      > Например:     var r = [1,2]; alert(r);
        Выведет вовсе не [object Array]
          а 1,2  -  значения массива.
      > Чтобы решить эту проблему, используем технику одалживания метода. Берешь
        девственно чистый не переопределенный метод toString() у стандартного
        объекта, который возвращает значение свойства с информацией о классе, и
        запускаешь его в контексте нужного тебе объекта (см. примеры выше)
	> Почему для проверки встроенных типов рекомендуется использовать технику
		одалживания метода, а не оператор instanceof.
		> Есть случай, когда instanceof нас подведет, а именно, когда объект создан
			в другом окне или iFrame, а оттуда передан в текущее окно.
			> Так что arr instanceof Array вернет false в этом случае, так как
				у каждого окна и фрейма свой собственный набор объектов.

 > Приведение типов (примитивы)
  > Автоматическое приведение -> string происходит:
    > Когда требуется представление чего-либо в виде строки, например Alert(x)
  > Автоматическое приведение -> number происходит:
    > В математических функциях и выражениях, а также при сравнении (кроме строгого)
  > Автоматическое приведение ( null | undefined ) -> number:
    > Происходит при арифметических операциях и операциях сравнения
      > Кроме операции проверки равенства ==

> Приведение типов (объекты)
  > Если объект является частью выражения, и требуется преобразование к примитиву, то:
    > Сначала объект преобразуется к примитиву, затем происходит все остальное.
    > При этом для преобразования к примитиву используется valueOf(), а если его нет
      (или он есть, но возвращает не примитив), то toString()
      > !!! Есть 1 единственное исключение: объект Date преобразуется в примитив,
        используя сразу toString().
    > Методы toString() и valueOf() в объектах можно переопределить, и они будут
      возвращать то, что тебе нужно.
      > Метод valueOf() хоть и вызывается при преобразовании object -> number, но
        возвращать может не только число, а вообще любое примитивное значение.
  > Как приводить object к любому другому типу:
    > object -> string
      > Запускается метод toString() объекта. Значение, которое он вернет, и будет
        результатом преобразования.
        > Метод toString обязателен, и есть у всех объектов.
          > По умолчанию toString() возвращает "[object Object]"
    > object -> number
      > Запускает метод valueOf() объекта, если он у него есть. А если его нет,
        то запускает toString(), который уж точно есть. Возвращаемое значение
        и будет результатом преобразования.
        > Метод valueOf() не обязателен, и его нет у большинства объектов.
          > Он обязат возвращать примитивное значение, иначе будет проигнорирован.
    > object -> другие типы
      > object можно преобразовать к любому типу. Но сначала его преобразуешь к
        number или string, а затем уже к любому другому.

> Сравнение типов
  > Гибкое сравнение ==
    > Обозначается: ==
    > При гибком сравнении происходит попытка автоматического приведения типов.
    > Типы приводятся по принципу: привести все операнды к числу.
      > Кроме случая, когда все операнды - строки. В этом случае происходит
        их побуквенное сравнение.
  > Жесткое сравнение ===
    > Обозначается: ===
    > При жестком сравнении автоматического приведения типов операндов
      не происходит.
    > Например, false === false и только. Выражение false === 0 вернет false.
  > Поведение null и undefined при сравнении особым образом отдельно прописано в
		стандарте ECMA script:
		> null и undefined равны себе, между собой, и не равны больше ничему.
			> Отсюда получается парадокс, что:
				> null >= 0     | true
				> null <= 0     | true
				> null == 0     | false  (парадокс)




 -------------------------------------------------- */