/* --------------------------------------------------
 ---------------- О Г Л А В Л Е Н И Е ----------------
 Функции (общая информация)

 > Общий синтаксис и JSDocumentator
 > В JS функция - это значение, а ее имя передается по ссылке
 > В JS глобальные переменные передаются в локальную область видимости
   по ссылке автоматически, а через аргумент функции - по значению.
 > Рекурсивный вызов
 > Условное определение функции
 > Вложенные функции

 > Пример function declaration
 > function expression
   > Простой пример function expression
   > Пример именованного function expression
   > function expression c вызовом на месте

 > Установка аргументов функции по умолчанию
 > Передача в функцию аргументов внтури объекта -
   - как удобный пульт управления функцией.
 > Псевдо-массив аргументов переменной длины arguments

 > Демонстрация содержимого глобального объекта window

 > Хранение данных в замыкании.
 > Статическое свойство класса
 > Прием проектирования Модуль



 -------------------------------------------------- */

// Общий синтаксис и JSDocumentator
    /**
     * Возвращает сумму аргументов a и b
     * @author 4gekkman@gmail.com
     * @param {number} a аргумент №1
     * @param {number} b аргумент №2
     * @returns {number} сумма a и b
     */
    function sum(a,b) {
        return a+b;
    }
    var r = sum(5,10);   // 15

// В JS функция - это значение типа object класса Function.
//   Поэтому она передается по ссылке, как и все object's в JS.
    r = sum;  // теперь r является псевдонимом sum
    var res = r(5,10);    // 15    (r - псевдоним функции sum)

// В JS глобальные переменные передаются в локальную область видимости
// по ссылке автоматически, а через аргумент функции - по значению.
// > В отличие от PHP. Там не передаются, и просто так из локальной области не видны.
// > Но можно передать глобальную переменную в функцию и по значению:
//   > ... как аргумент этой функции.
    r = 10;
    function f11() {
        r += 15;
    }
    f11();
    console.log(r);  // 25

    // Передать в функцию глобальную переменную по значению можно как аргумент функции:
    r = 10;
    function f11a(r) {
        r += 15;
    }
    f11a();
    console.log(r);  // 10    (глобальная переменная не тронута)

// Рекурсивный вызов
    // На примере вычисления факториала
        function factorial(n) {
            if(n<=0) return 1;
            return n * factorial(n-1);
        }
        r = factorial(5);   // 120

// Условное определение функции

    // !! Это в JS не сработает, в отличие от PHP, определятся обе функции
    // > Потому что наличие function declaration'ов интерпретатор проверяет
    //   еще до начала выполнения кода. Именно поэтому функцию, определенную как
    //   function declaration можно вызвать в коде до ее определения.
    if(2>1) {
        function abc() {
            console.log(111);
        }
    } else {
        function cba() {
            console.log(222);
        }
    }
    r = abc();   // 111
    r = cba();   // 222

    // В JS для условного определения функции используются function expression (функциональное выражение)
    // > Так как функция - это значение, то здесь просто в зависимости от условия
    //   переменной f присваивается то или иное значение (функция).
    // > Здесь f_name - это имя функционального выражения, оно нужно только для того,
    //   чтобы можно было организовать рекурсивный вызов.
    var f;
    if(2>1) {
        f = function f_name() {
            console.log(111);
        }
    } else {
        f = function f_name() {
            console.log(222);
        }
    }
    r = f();   // 111

// Вложенные функции
    function qwer() {
        function qwer2() {
            return 222;
        }
        return 111;
    }
    // r = qwer2();  // Ошибка: вложенная функция не доступна отсюда

// Пример function declaration
    function a1() {
        return 10;
    }

// function expression
    // Простой пример function expression
        r = function() {
            return 20;
        };

    // Пример именованного function expression
        r = function a2(n) {
            if(n<=0) return 1;
            return n * a2(n-1);
        };

    // function expression c вызовом на месте
        (function() {
            console.log('function expression c вызовом на месте');
        })();

// Установка аргументов функции по умолчанию
    function args(a,b,c) {
        a = a || "a не задано";
        b = b || "b не задано";
        c = c || "c не задано";

        console.log(a + ', ' + b + ', ' + c);
    }
    args();        // a не задано, b не задано, c не задано
    args(2,3);     // 2, 3, c не задано
    args(2,3,4);   // 2, 3, 4

// Передача в функцию аргументов внтури объекта -
// - как удобный пульт управления функцией.
// > На первый взгляд выгоды не видно, можно вообще не передавать в
//   функцию объект с аргументами, все равно в ней автоматом будет
//   создана переменная со ссылкой на объект. А если передать, то произойдет
//   ровно тоже самое. Так зачем лишние действия? А вот зачем:
//   > В такой ситуации объект становится удобным пультом управления
//     выводом функции. Конечно, можно и без него, но с ним удобнее.
//     > Например, меняется динамически какое-то свойство объекта,
//       и результат работы функции также меняется динамически.

    // Передавай объект, не передавай, а результат от этого не меняется
    r = {a:10}
    r2 = {b:30, c:40}
    function f13(r) {
        r.a = 20;    // что эту переменную передали как аргумент, значение - ссылка на свойство объекта r
        r2.b = 40;   // что эту переменную НЕ передавали, а она все равно, аналогично верхней, значение - ссылка на свойство объекта r2
    }
    f13(r);
    console.log('a = '+r.a);  // 20
    console.log('b = '+r2.b);  // 40

    // Объект - удобный пульт управления функцией
    var click = {
        id:        'obj747',
        width:     300,
        height:    150,
        opacity:   0.7
    };
    function f14(ob) {
        console.log('id = ' + ob.id);            // id = obj747
        console.log('width = ' + ob.width);      // width = 300
        console.log('height = ' + ob.height);    // height = 150
        console.log('opacity = ' + ob.opacity);  // opacity = 0.7
    }
    f14(click);

// Псевдо-массив аргументов переменной длины arguments

    // Для начала определим класс объекта arguments
    function f17() {
        var toStringVirgin = {}.toString;
        r = toStringVirgin.call(arguments).slice(8,-1);
        console.log('arguments - объект класса '+r);
    }
    f17();  // Ответ: класса Arguments

    // Скопируем содержимое arguments в объект класса Array
    // > Чтобы с этим содержимым можно было работать, как с массивом
    function teas(a,b) {
        var arrArgs = [].slice.call(arguments);  // одолжить метод slice у класса Array и применить к Arguments (копирует содержимое в новый массив)
        teas.showAllArgs = function() {
            for(var i in arrArgs) {
                console.log(i+' = '+arrArgs[i]);
            }
        }
    }
    teas("Улунь","Пуэр","Железная баттисатхва", "Дахунпао", "Майский");
    teas.showAllArgs();


// Демонстрация содержимого глобального объекта window
// > Тут можно увидеть все фукнции этого скрипта, даже определенные позже этой строки
//   - они стали методами объекта window.
// > Тут можно увидеть все переменные этого скрипта, объявленные с var
//   - они стали свойствами объекта window.
    for(var i in window) {
        // console.log(i+' = '+window[i]);   // все свойства и методы объекта window
    }

// Хранение данных в замыкании.
// > На примере счетчика
    function counter() {
        // --- Вот это все считай замыкание --- //

        var staticProp = 0;  // это статическая переменная, которая хранится в замыкании

        function plusOne() {                    // это метод функции counter (типа function declaration),
            staticProp++;                      // он увеличивает значение статической
        }                                       // переменной staticProp на 1

        plusOne.showStaticProp = function() { // это метод функции plusOne (типа function expression),
            console.log(staticProp);          // он выводит в консоль текущее значение
        };                                    // статической переменной staticProp
        return plusOne;  // функция counter() возвращает ссылку на свой же метод
        // ------------------------------------ //
    }
    var c = counter();  // 1. Создан экземпляр функции (читай класса) counter
                        // 2. Переменная c теперь ссылается на метод plusOne
                        //    Иначе говоря, c - это теперь псевдоним метода plusOne

    c();  // вызов метода plusOne в  1-й раз.
    c();  // вызов метода plusOne во 2-й раз.
    c();  // вызов метода plusOne в  3-й раз. [сейчас staticProp == 3]
    c.showStaticProp();  // 3


// Статическое свойство класса
function f15() {                              // это примерно тоже самое, что в PHP - определение класса
    f15.myStaticProp = f15.myStaticProp + 1;  // это тоже самое, если в PHP в определении класса определить статическое свойство:
                                                 // public static myStaticProp
}
f15.myStaticProp = 0;
f15();   // вызов в  1-й раз
f15();   // вызов во 2-й раз
f15();   // вызов в  3-й раз [сейчас myStaticProp] = 3
console.log(f15.myStaticProp);  //  3  (доступ к myStaticProp есть откуда угодно)


// Прием проектирования МОДУЛЬ
// > Скрывает все методы и свойства в замыкании, делая их недоступными из
//   родительского класса (аналог protected в PHP)
// > Наружу выставляется объект со ссылками только на те методы, которые
//   должны быть доступны из родительского объекта (аналог public в PHP).
    var cntr = (function() {
        // protected свойство и метод
        var count = 0;
        var autoReset = function() {
            if(count > 2)
                count = 0;
        };

        // public методы
        return {             // возвращаемо объект со ссылками на public методы
             plus: function() {
                 count++;
                 autoReset();  // если count > 2, сбросить
             },
             reset: function() {
                 count = 0;
             },
             show: function() {
                 return count;
             }
        }
    })();
    r = cntr.show();    // 0
      cntr.plus();
    r = cntr.show();    // 1
      cntr.plus();
    r = cntr.show();    // 2
      cntr.plus();
    r = cntr.show();    // 0




/* --------------------------------------------------
 ---------------- И Н Ф О Р М А Ц И Я ----------------


 JSDocumentator

 > JSDocumentator - техника создания документации в JS. В том числе описания функции.
 > Если при определении функции использовать эту технику, то многие IDE,
 например PHPStorm при использовании этих функций будут выводить подсказки
 с информацией из той самой документации.
 > Примечание*: документация начинается с /** (обязательно 2-х звездочек)
 > Документация по
 > GitHub репозиторий здесь: https://github.com/jsdoc3/jsdoc
 > Примеры тут: http://usejsdoc.org/howto-commonjs-modules.html
 > HTML 5 сайт с документацией: http://usejsdoc.org/
 > Чтобы просмотреть полную справку функции (описание, типы параметров ... ):
 1. Щелкнуть ЛК мыши по названию функции
 2. Нажать CTRL + Q


 Общее о функциях в JS

 > Что такое функция в JS
   > Объявление функции - это объект класса Function.
     > Например, function f() {} . Здесь в переменной f лежит объект класса Function.
   > Цепочка наследования следующая: Function (от)-> Object
     > Таким образом объект класса Function имеет встроенные свойства
       и методы класса Function, а также наследует их у класса Object.
   > Вызов функции
     > Простой вызов функции:         F();
       > В этом случае в памяти создается объект класса F.
       > В случае повторного вызова F() в этом же скрипте, предыдущий созданный в
         памяти объект удаляется, и вместо него создается новый.
         > Примечание*: если вот так перезаписать старый объект новым, и при этом в старом
           объекте была использована техника замыкания, то разумеется, старый объект
           не удалится, а так и останется в памяти, потому что на него останется ссылка.
           > Этот принцип используется при построении 2-х счетчиков.
     > Вызов функции через new:  var x =  new F();
       > В этом случае функция выступает в роли класса.
         > В таком контексте функцию называют функция-конструктор. При вызове функции
           F с помощью оператора new, создается объект класса F, а ссылка на него
           присваивается переменной x.
         > Цепочка наследования в этом случае будет такая: X -> Function -> Object
         > Про классы и функции-конструктору см. "6. Работа с объектами и массивами"
   > Свойства и методы функции
     > Переменные, объявленные в функции F с помощью var - становятся свойствами этого
       объекта.
     > В том числе и переменные, содержащие function expression.
     > Вложенные функции, объявленные внутри функции F, как function declaration,
       становятся методами этого объекта.
     > Переменные, объявленные в функции F, как свойства класса F (например,
       F.myProp;) - становятся статическими переменными класса F с областью
       видимости public.
   > Области видимости у функций в JS
     > Дочерний объект видит через свое свойство __proto__ все
       свойства и методы всех поколений родительских объектов.
       То есть, функция видит внешние переменные (в отличие от PHP)
     > Если в дочернем объекте определить свойство или метод с тем же
       именем, то ссылка на свойство или метод в родительском
       объекте будет скрыта.


 Function Expression и Function Declaration

 > Два способа объявить функцию в JavaScript:
   > Function Declaration (FD)
     > Становится методом объекта того класса, в котором объявлена. Если функция
       FD объявлена в глобальной области видимости, а скрипт запущен в браузере,
       то эта функция является методом объекта window класса Global.
     > К тому моменту, как скрипт начинает выполняться в браузере, объект window
       уже создан, вместе со всеми своими методами (FD) и свойствами (var).
       > Методы созданы уже полностью, со всеми значениями.
       > Свойства созданы пока что со значениями undefined.
     > И именно поэтому невозможно организовать условное определение функции,
       которая определяется как FD. Потому что к моменту начала выполнения
       скрипта, все FD УЖЕ созданы.
   > Function Expression (FE)
     > Это объект класса Function. Если он присвоен переменной, объявленной с
       помощью var, то эта переменная является свойством объекта window класса
       Global, а значение этой переменной - этот самый объект класса Function.
     > Определение функции можно назвать FE, когда оно является частью какого-либо
       выражения.
     > В отличие от FD, определение function expression происходит в порядке
       общей очереди.
       > Поэтому возможно организовать условное определение фукнции, которая
         определяется как FE.
     > Function Expression бывают:
       > Не именованные, например:
         > r = function() {}
       > Именованные, например:
         > r = function funcName() {}
         > Это имя нужно только для того, чтобы из тела этой функции можно
           было организовать рекурсивный вызов.

 > Передача, присваивание и возврат значений в JavaScript
   > Могут происходить по значению, или по ссылке.
     > Однако, в JS явно нельзя указать с помощью & (как в PHP),
       по значению или по ссылке передается переменная. Здесь он
       автоматизирован, и приходится под него подстраиваться.
       Вот как он работает в разных ситуациях:
       > Простые типы:
         > присваиваются и передаются в функцию в качестве аргумента
           - по значению.
       > Объекты:
         > присваиваются и передаются в функцию в качестве аргумента
           - по ссылке.

 > Глобальный объект создается до выполнения скрипта
   > Все переменные и функции в глобальной области видимости являются
     свойствами и методами глобального объекта класса Global.
     > В браузере этот объект явно доступен под именем window. Он также
       дополнительно содержит ряд свойств и методов для работы с окном
       браузера.
     > В других окружениях, например node.js, глобальный объект может
       быть не доступен явно, и называется по другому.
   > К тому моменту, как скрипт начинает выполняться в браузере, объект window
     уже создан, вместе со всеми своими методами (FD) и свойствами (var).
     > Методы созданы уже полностью, со всеми значениями.
     > Свойства созданы пока что со значениями undefined.

 > Замыкания
   > Как работает замыкание подробно и доходчиво:
     > В дочернем объекте есть скрытое свойство [[scope]], в котором лежит
       ссылка на родительский объект.
     > JS уничтожает объект тогда, когда на него больше нет ссылки, и
       доступ к нему уже никак не получить.
     > Поэтому, если функция А вернет ссылку (просто имя) на свой метод Б
       (метод, потому что объявлен как function declaration),
       и завершит свою работу, то свойства и методы функции А, а также
       их значения не будут уничтожены, потому что есть ссылка на
       метод Б, в котором есть скрытое свойство [[scope]], в котором
       есть ссылка на функцию А.
       А раз есть ссылка, значит уничтожать объект А нельзя. И все его
       родительские объекты тоже.
 > Хранение информации в замыкании
   > С помощью замыкания. Применяешь технику замыкания и имеешь:
     > Ссылку на объект А, созданный в памяти. И не удаляющийся из нее после
       завершения выполнения функции, так как есть эта самая ссылка. Он так
       и будет болтаться в памяти до конца скрипта, если не очистить ссылку.
       И все его родительские объекты тоже.
     > Этот объект унаследовал ссылку на свойство своего родительского
       объекта Б. Эта ссылка доступна только из объекта А и его наследников.
       > Поэтому если у объекта А есть метод, который вернет эту самую
         ссылку, то получить ссылку на это свойство можно будет из объекта С,
         являющегося родителем объекта Б.

   > Статическое свойство в JS
     > Статическое свойство функции - значение которого сохраняется в течение
       выполнения этого скрипта между вызовами функции.
     > Статическое свойство в JS - является свойством класса (описания) функции,
       а не свойством объека этого класса.
       Поэтому на все экземпляры этого класса приходится только одно статическое
       свойство с таким именем и ссылкой на одно и то же значение.
     > В JS нет служебного слова static, как в PHP - где его можно указать
       перед свойством, и оно станет статическим.
       > В JS чтобы объявить свойство статическим, нужно объявить его свойством
         класса, а не свойством объекта. Например:
         > Если у нас есть определение функции Func() {}, то:
           > чтобы создать статическое свойство внутри этого определения,
             надо написать Func.staticProp = 0;
           > а чтобы создать свойство для объектов этого класса внутри этого
             определения, надо написать staticProp = 0;
     > Область видимости статического свойства - public.

 > Псевдо-массив arguments
   > В функцию можно передавать больше аргументов, чем указано при ее
     объявлении. Доступ к 'лишним' аргументам можно получить с помощью
     псевдо-массива arguments
     > Поведение arguments различно в старом и новом стандарте JS:
       > В старом стандарте в arguments содержатся ссылки-псевдонимы аргументов.
       > В новом стандарте - 'use strict' - в arguments содержатся копии значений
         аргументов.
     > arguments - объект object класса Arguments, а не класса Array.
       > А класс Arguments - это тоже самое, что класс Object, только
         есть еще свойство length. Но у Arguments нет всех этих методов
         по работе с массивами, что есть у Array.
       > Поэтому выгодно копировать содержимое arguments в настоящий массив
         (техника приведена выше в соотв. разделе), чтобы можно было работать
         с ним спец. методами по работе с массивами, которые есть у класса Array.


 -------------------------------------------------- */



















