/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript.
1. Ядро JS -> 6. Таймеры



	> setTimeout					| запустить выполнение ф-ии/кода 1 раз через указанное время
	> clearTimeout				| отменить setTimeout

	>	setInterval					| запускать выполнение ф-ии/кода периодически, через указанное время

	> setImmediate(func)	| (только IE10)	позволяет поставить выполнение func в очередь
													на ближайшее время после текущего кода, и без задержек
	>	setImmediate				| (пользовательская функция) позволяет поставить выполнение
													func в очередь на ближайшее время после текущего кода, и без задержек







-------------------------------------------------- */

var timerId, func, string, intervalID;











//timerId = setTimeout(func/code, delay[, arg1, arg2...])
//> запустить выполнение ф-ии/кода 1 раз через указанное время
//> timerId - уникальный ID, который можно передать в clearTimeout
//  для того, чтобы остановить выполнение.
//> func/code - функция или строка кода для исполнения
//  > строку кода использовать не надо, она поддерживется для совместимости.
//> delay - задержка в мс.
//> arg - аргументы для передачи функции
//	> не поддерживается в IE <= 9


	// простой тест отложенного на 2 секунды запуска функции

	func = function() {
		console.log('Простой тест toTimeString');
		console.log(new Date().toTimeString());
	};


	console.log(new Date().toTimeString());
	timerId = setTimeout(func,2000);


	// использование строки с кодом вместо функции в 1-м аргументе

	string = 'console.log(\'Использование строки вместо функции\')';
	timerId = setTimeout(string,3000);


	// лучше вместо строки использовать функцию, можно анонимную:

	timerId = setTimeout(function(){
		console.log('Использование анонимной функции вместо строки');
	}, 3000);


	// т.к. в IE <= 9 нельзя передать аргументы arg, то чтобы обойти это
	// препятствие заворачивают вызов функции в анонимную функцию:

		var f = function(name,age) {
			console.log('Меня зовут '+name+', мне '+age);
		};

		setTimeout(function(){
			f('John', 26);
		},3000);								// Меня зовут John, мне 26


	// вызов функции через setTimeout не передает конекст this

		// иллюстрация проблемы
		function User(id) {
			this.id = id;
			this.getId = function() {
				console.log(this.id);
			};
		}

		var user = new User(12345);
		setTimeout(user.getId, 3000);			// undefined

		// решение - использовать анонимную функцию-обертку
		var user = new User(12345);
		setTimeout(function(){
			user.getId();
		}, 3000);													// 12345




	// заказ отложенного выполнения и его отмена еще до начала
	timerId = setTimeout(function(){
		console.log('Hello');
	},1000);
	clearTimeout(timerId);		// отмена заказанного выполнения


	//Замена ф-ии setInterval ф-ей setTimeout, организация обязательных
	// 	фиксированных задержек между выполнениями

/*
	var i = 1;
	var id = setTimeout(function run(){
		console.log(i++);
		id = setTimeout(run, 2000);
	},2000);
*/



//intervalID = window.setInterval(func/code, delay[, param1, param2, ...])
//> запускать выполнение ф-ии/кода периодически, через указанное время
//> intervalID - уникальный ID, который можно передать в clearTimeout
//  для того, чтобы остановить выполнение.
//> func/code - функция или строка кода для исполнения
//  > строку кода использовать не надо, она поддерживется для совместимости.
//> delay - задержка в мс перед каждым запуском
//> param - параметры для передачи запускаемой функции

	// простой тест периодического (каждые 5 секунд) запуска функции

	/*
		intervalID = setInterval(function(){
			console.log('Запуск');
		},5000);
	*/

	// блокировка таймера модальным окном (только Chrome и Safari)

/*	alert('В Chrome и Safari теперь таймер заблокирован');
	intervalID = setInterval(function(){
		console.log('Это было заблокировано модальным окном');
	},5000);*/




	//Тест минимальной задержки метода intervalID - от 0мс до 20мс с шагом в 2мс:
		for (var i=0; i<=20; i+=2) {
			document.write('<div>'+i+'</div>');
		}

		var startButton = document.getElementById('start');
		var stopButton = document.getElementById('stop');

		var timers = [];

		stopButton.onclick = function() {
			startButton.disabled = false;
			stopButton.disabled = true;

			for(var i=0; i<timers.length; i++) clearInterval(timers[i]);
			timers = [];
		};

		startButton.onclick = function() {
			startButton.disabled = true;
			stopButton.disabled = false;

			var divs = document.getElementsByTagName('div');
			for (var i=0; i<divs.length; i++) {
				animateDiv(divs, i);
			}
		};

		function animateDiv(divs, i) {
			var div = divs[i], speed = div.innerHTML;
			timers[i] = setInterval(function() {
				div.style.width = (parseInt(div.style.width||0) + 2) % 400 + 'px'
			}, speed);
		}




//setImmediate				| (пользовательская функция) позволяет поставить выполнение
//											func в очередь на ближайшее время после текущего кода, и без задержек
// > Это эмуляция ф-ии setImmediate
// > Добавляется как метод window (а если дело происходит в IE>=10, где такая
//   функция уже есть, то не добавляется)
// > Здесь используется прием cross-domain-messaging:
//		> Позволяет скрипту из одного документа передавать текстовые сообщения
//			скрипту в другом документе, не взирая на ПОП.
//		> Отправить сообщение можно методом Window.postMessage(). Он производит
//			асинхронную отправку сообщения.
//		> Получить сообщение можно обработчиком события onmessage.
// > Работает во всех браузерах, кроме IE<=7


	// Проверить cледующее:
	// > Если это IE>=10, и ф-ия setImmediate есть, то ничего не добавлять.
	// > В ином случае, добавить объекту window метод setImmediate:
	if (!window.setImmediate) window.setImmediate = (function() {
		var head = { }, tail = head; // очередь вызовов, 1-связный список

		var ID = Math.random(); // уникальный идентификатор

		// Подготовка функции-перехватчика события message из другого документа
		function onmessage(e) {
			if(e.data != ID) return; // не наше сообщение
			head = head.next;
			var func = head.func;
			delete head.func;
			func();
		}

		// Кросдоменное назначение обработчика событий onmessage
		if(window.addEventListener) { // IE9+, другие браузеры
			window.addEventListener('message', onmessage, false);
		} else { // IE8
			window.attachEvent( 'onmessage', onmessage );
		}

		// > Если это не IE<=7, то поставить func в конец текущей очереди
		// > Если это IE<=7, то вызвать для func обычный setTimeout.
		return window.postMessage ? function(func) {
			tail = tail.next = { func: func };
			window.postMessage(ID, "*");
		} :
		function(func) { // IE<8
			setTimeout(func, 0);
		};
	}());



	// Сравнение производительности функций setTimeout и setImmediate


		// 100 раз выполнить ф-ию go c помощью setTimeout(go,0), и вывести в консоль
		// время, которое на это ушло в миллисекундах
		function testTimeout() {

			// Засечем текущее время
			var start = new Date();		// текущая UNIX-метка в мс
			var i = 0;								// счетчик

			// Эта функция выполнится 100 раз, и выведет в консоль время, которое
			// это у неё заняло в мс.
			var go = function go() {

				// Прибавить 1 к счетчику
				i++;

				// Получить ссылку на элемент span с id setImmediate справа от соотв-ей кнопки:
				var spanSetInter = document.getElementById('setTimeout');

				// Если:
				// > Уже настала 100-ая итерация, то вывести в консоль время, которое
				//   прошло с момента start до текущего момента
				// > Если еще не настала 100-ая итерация, то запустить ф-ию еще раз.
				if (i == 100) spanSetInter.innerHTML = 'На выполнение 100 итераций setTimeout(go,0) ушло: '+
						(new Date - start)+' миллисекунд.';
				else setTimeout(go, 0);
			};


			// Запустить 100 итераций функции go
			setTimeout(go,0);
		}


		// 100 раз выполнить ф-ию go c помощью setImmediate(go), и вывести в консоль
		// время, которое на это ушло в миллисекундах
		function testImmediate() {

			// Засечем текущее время
			var start = new Date();		// текущая UNIX-метка в мс
			var i = 0;								// счетчик

			// Эта функция выполнится 100 раз, и выведет в консоль время, которое
			// это у неё заняло в мс.
			var go = function go() {

				// Прибавить 1 к счетчику
				i++;

				// Получить ссылку на элемент span с id setImmed справа от соотв-ей кнопки:
				var spanSetImmed = document.getElementById('setImmed');

				// Если:
				// > Уже настала 100-ая итерация, то вывести в консоль время, которое
				//   прошло с момента start до текущего момента
				// > Если еще не настала 100-ая итерация, то запустить ф-ию еще раз.
				if (i == 100)
					spanSetImmed.innerHTML = 'На выполнение 100 итераций setImmediate(go) ушло: '+
							(new Date - start)+' миллисекунд.';
				else setImmediate(go);
			};


			// Запустить 100 итераций функции go
			setImmediate(go);
		}









/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


	> Описание таймеров в JS:
			http://learn.javascript.ru/timers




*****************************************************
Оглавление:

	> Общая информация
	> 2 функции для работы с таймерами в JS
	> setTimeout
		> Первый аргумент func/code
		> Использование функции-обертки для решения 2-х проблем с setTimeout
			> Проблема 1 - IE <= 9 не поддерживает передачу аргументов arg
			> Проблема 2 - вызов через setTimeout не передает контекст this
		> clearTimeout - отмена выполнения запланированной функции
		> Замена ф-ии setInterval ф-ей setTimeout, организация обязательных
			фиксированных задержек между выполнениями
	> setInterval
	> Разбивка выполнения долгих скриптов на части с помощью таймера

	> Функция setImmediate
	> Поддержка setImmediate в браузерах







*****************************************************


> Общая информация
	> Почти все реализации JS имеют внутренний таймер-планировщик, который
		позволяет задавать вызов функции через заданный период времени.
		В частности, эта возможность поддерживается в браузерах и на сервере
		Node.JS.
	> Минимальная задержка составляет 4мс по современном стандарту.
		> Поэтому если поставить меньше, то разницы особой не должно быть.
		> Выше в примерах есть наглядный тест.
		> Но даже если поставить 4мс, срабатывать может гораздо реже:
			- В большинстве браузеров таймеро продолжает работать даже, если
				вкладка не активна. Однако частота его срабатывания снижается.
				Ряд браузеров (Chrome, FF, IE10) снижают её до 1 раза в секунду.
			- При работе от батареи в ноутбуке, браузеры тоже могут снижать
				частоту срабатывания таймера.
			- При слишком большой загрузке процессора JS может не успевать
				обрабатывать таймеры вовремя, при этом некоторые запуски
				setInterval будут пропущены.
	> Интерпретатор начинает выполнять запланированные функциями setTimeout
		и setInterval функции толпо после того, как полностью будет выполнен
		весь текущий скрипт.
		> Таким образом, если завернуть фукнцию, как показано ниже, то
			они будет выполнена в конце скрипта:


				setTimeout(function(){ 'Конец скрипта!' },0)



> 2 функции для работы с таймерами в JS
	- setTimeout			| запустить выполнение ф-ии/кода 1 раз через указанное время
	- setInterval			| запускать выполнение ф-ии/кода периодически, через указанное время

> setTimeout

	> Первый аргумент func/code
		> Функция setTimeout может организовать отложенный запуск либо другой
			функции, либо строки с javascript-кодом.
		> Если первый аргумент является строкой, то интерпретатор создает
			анонимную функцию из этой строки. Так что по сути, это тоже самое,
			что самому использовать ту же анонимную функцию.
		> Использоваь строку вместо функции не рекомендуется, так как это может
			вызвать проблемы при минимизации кода. Вообще, сама возможность
			использовать строку сохраняется лишь для совместимости.

	> Использование функции-обертки для решения 2-х проблем с setTimeout.

		> Проблема №1, и решение.
			> Все современные браузеры позволяют в функции setTimeout указать
				сколько угодно аргументов arg, с которыми и будет запущена
				та функция, чей отложенный запуск организован.
			> Однако, это не работает в IE <= 9.
				> Поскольку поддержка IE9 и IE8 нам нужна, то чтобы их передать
					заворачивают вызываемую функцию в анонимную функцию:

						var f = function(name,age) {
							console.log('Меня зовут '+name+', мне '+age);
						};

						setTimeout(function(){
							f('John', 26);
						},3000);								| Меня зовут John, мне 26

		> Проблема №2, и решение.
			> Вызов функции через setTimeout не передает конекст this:

					function User(id) {
						this.id = id;
						this.getId = function() {
							console.log(this.id);
						};
					}

					var user = new User(12345);
					setTimeout(user.getId, 3000);		| undefined	 (контекст this не был передан)

			> Решение - использовать анонимную функцию-обертку:

			 		var user = new User(12345);
					setTimeout(function(){
						user.getId();
					}, 3000);												| 12345

	> clearTimeout - отмена выполнения запланированной функции
		> После заказа выполнения функции с помощью setTimeout, можно отменить
			выполнение (если оно еще не началось), используя функцию clearTimeout.

	> Замена ф-ии setInterval ф-ей setTimeout, организация обязательных
		фиксированных задержек между выполнениями
		> Например, требуется, чтобы между последовательными выполнениями
			функции был постоянный интервал в N мс. Не зависимо от того,
			как долго выполняется функция.
		> Этого можно добиться с помощью вложенного вызова setTimeout:

				var i = 1;
				var id = setTimeout(function run(){
					console.log(i);
					id = setTimeout(run, 2000);
				},2000);



> setInterval

	> Браузер не учитывает время выполнения функции
		> Браузер инициирует запуск функции аккурат каждые N мс установленного
			интервала, без учета времени выполнения самой функции.
		> Если функция выполняется дольше, чем размер установленного
			интервала, то то запуск следующей функции невозможен, пока предыдущая
			не закончит выполняться. Поэтому следующая становится в очередь, и
			выполняется, как только браузер освободится.
		> В результате реальное время выполнения фунций - больше, чем заявленное
			в интервале.

	> В очередь может быть поставлено только 1 выполнение, не больше
		> Например:
			> У нас есть фукнция, которая выполняется 350 мс.
			> Мы запускаем её периодическое выполнение с помощью setInterval и
				с периодом в 100 мс.
			> Далее происходит следующее:
				- На 100мс: таймер срабатывает, запускается выполнение функции
				- На 200мс: таймер срабатывает, очередное выполнение ставится в очередь
				- На 300мс: таймер не срабатывает
				- На 400мс: таймер не срабатывает
				- На 450мс: запущенная на 100мс функция заканчивает работу, и сразу запускается
										новая итерация - та, что стояла в очереди.
				- На 500мс: таймер срабатывает, очередное выполнение ставится в очередь
					...
						...

	> В некоторых браузерах модальные окна блокируют таймер
		> То есть пока есть открытое модальное окно, таймер не тикает.
		> Это характерно для браузеров надвижке webkit: Chrome и Safari.



> Разбивка выполнения долгих скриптов на части с помощью таймера
	> Разбиение начасти нужно тогда, когда скрипт выполняется настолько
		долго, что есть риск получить от браузера timeout, после чего выполнение
		скрипта оборвется и не будет закончено как надо.
	> Околонулевой интервал используют для того, чтобы разбирть выполнение
		тяжелого скрипта на части. Выполнение каждой части запускается через
		мини-интервал сразу после предыдущей.



> Функция setImmediate

	> Функция setTimeout(func, 0) позволяет отложить выполнение func не менее, чем
		на 1 тик таймера: [4 - 1000] мс.

	> Иногда такая дополнительная задержка не нужна. А вместо этого нужно отложить
		выполнение func, поставив его на ближайшее место в очереди на выполнение
		после текущего кода.
		> Пример, когда это может понадобиться:
				Большинство событий асинхронны - т.е. выполнение их обработчика встает в
				очередь на обработку. Но есть и синхронные события, такие как focus. Выполнение
				их функций-обработчиков в очередь на обработку не встает, а выполняется тут
				же на месте. Иногда такое поведение не устраивает, поэтому этот обработчик
				надо поставить в очередь на ближайшее место. И причем еще может быть очень
				важно, чтобы небыло никаких лишних задержек.

				Допустим, мы обрабатываем событие onclick, и нам надо преобразовать все буквы
				в верхний регистр. Если будет большая задержка - как при применении ф-ии
				setTimeout(func,0) - то пользователь будет сначала видеть маленькую букву,
				а потом как она превращается в большую. А это не красиво, лучше, чтобы
				задержка была такая маленькая, чтобы пользователь просто не успевал замечать
				это превращение.

	> Таким образом, функция setImmediate(func) нужна для того, чтобы поставить
		func на ближайшее свободное место в конец очереди выполнения, без задержки.
		> В то время, как setTimeout(func,0) прибавляет к этому еще и задержку не
			менее, чем 1 тик таймера [4 - 1000] мс.


> Поддержка setImmediate в браузерах
	> setImmediate поддерживается только в IE>=10.
	> В прочих браузерах можно пользоваться пользовательской версией этой
		функции (см. выше в примерах).










-------------------------------------------------- */
