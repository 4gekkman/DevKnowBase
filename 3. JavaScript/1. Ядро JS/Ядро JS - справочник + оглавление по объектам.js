/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript.
Ядро JS - справочник + оглавление по объектам



********************************************************
Справочник по объектам ядра javascript:


	Список объектов ядра JS.

		0. Global     | глобальный объект
		1. Array			| глобальный объект-конструктор для создания и работы с массивами
		2. Boolean		| объект-обертка для значений типа boolean, для работы с этими типами
		3. Date				| глобальный объект-конструктор для создания и работы с датой и временем
		4. Function		| глобальный объект для создания и работы с функциями
		5. Number			| объект-обертка для значений типа number, для работы с этими типами
		6. Object			| объект-обертка
		7. RegExp			| глобальный объект для создания и работы с регулярными выражениями
		8. String			| глобальный объект-конструктор для создания и работы со строками
		9. Math				| встроенный объект, содержащий статические свойства и методы для работы с математикой
		10. JSON			| объект, содержащий методы для конвертации значений в JSON-формат, и обратно
		11. Error			| глобальный объект для создания и работы с объектом Error

	Свойства и методы объектов.


		0. Global     | глобальный объект
			Свои свойства
				> Infinity						| числовое значение, означающее полож./отриц. бесконечность
				> NaN									| специальное значение 'Not a Number'
				> undefined						| означает, что переменной не было присвоено значение
			Свои методы
				> isFinite						| возвращает true, если значение не +/- Infinity или NaN; иначе false.
				> isNaN								| возвращает true, если значение равно NaN; иначе false.
				> Number							| конвертирует значение в число
				> String							| конвертирует значение в строку
				> parseInt						| парсит строку и возвращает целое число
				> parseFloat					| парсит строку и возвращает число с плавающей запятой
				> eval								| выполняет строку как код скрипта
				> encodeURI						| кодирует URI
				> decodeURI						| декодирует URI
				> encodeURIComponent	| кодирует компонент URI
				> decodeURIComponent	| декодирует компонент URI



		1. Array			| глобальный объект-конструктор для создания и работы с массивами
			Свои свойства:
				> prototype				| (стат.) св-во prototype функции-конструктора Array
				> constructor			| содержит ссылку на функцию-конструктор объекта prototype.
				> length					| индекс последнего элемента в массиве + 1
			Свои методы:
			> Методы для работы с массивами из ES3-ES4
				> join				| конкатенирует все элементы массива в 1 строку
				> reverse			| возвращает обратный массив
				> sort				| сортирует массив в алфавитном порядке, может принимать сортирующую callback-функцию
				> concat			| конкатенирует массив с другим массивом, или с какими-то другими элементами
				> slice				| берет подмассив из элементов указанного массива
				> splice			| одновременно удаляет и вставляет элементы в массив
				> push				| вставляет в конец массива 1 или нескольких элементов
				> unshift			| вставляет в начало массива 1 или нескольких элементов.
				> pop					| удаляет последний элемент из массива, и возвращает его.
				> shift				| удаляет первый элемент из массива, и возвращает его.
			> Методы для работы с массивами из ECMAScript 5
				> forEach			| изменяет исходный массив, обрабатывая каждый его элемент callback-функцией
				> map					| возвращает массив из элементов, обработанных и возвращенных callback-функцией
				> filter			| возвращает новый массив из элементов, отсеянных callback-функцией
				> every				| вернет true, если для всех без исключения элементов будет выполнено условие, заданное в callback-функции, иначе false.
				> some				| вернет true, если хотя бы для 1 элемента будет выполнено условие, заданное в callback-функции, иначе false.
				> reduce			| возвращает результат цепного вызова callback-функции для всех элементов слева-направо
				> reduceRight	|	возвращает результат цепного вызова callback-функции для всех элементов справа-налево
				> indexOf			| слева-направо ищет заданный элемент в массиве, и если находит, возвращает индекс первого найденного элемента.
				> lastIndexOf	| справа-налево ищет заданный элемент в массиве, и если находит, возвращает индекс первого найденного элемента.


		2. Boolean		| объект-обертка для значений типа boolean, для работы с этими типами
			Свои свойства:
				> length					|	(стат.) длина, всегда = 1
				> prototype				| (стат.) св-во prototype функции-конструктора Boolean
			Свои методы:
				>


		3. Date				| глобальный объект-конструктор для создания и работы с датой и временем

			Свои свойства:
				> prototype				| (стат.) св-во prototype функции-конструктора Array
				> length					| (стат.) это значение = 7

			Свои методы:
				> now							| (стат.) возвращает кол-во мс, прошедших с 01.01.1970 00:00:00 UTC
				> parse						| (стат.) парсит строковое представление времени и возвращает UNIX-метку в мс
				> UTC							| (стат.) как конструктор принимает от 2 до 7 параметров, возвращает UNIX-метку UTC

				Геттеры:
					> getTimezoneOffset 	| возвращает смещение временной зоны текущего локального времени

					> getTime							| возвращает числовое представление объекта date в виде UNIX-метки
					> getFullYear					| год (4 цифры) в текущей временной зоне
					> getMonth						| месяц (0-11) в текущей временной зоне
					> getDate							| номер дня в месяце (1-31) в текущей временной зоне
					> getDay							| номер дня недели (0-6) в текущей временной зоне
					> getHours						| час (0-23) в текущей временной зоне
					> getMinutes					| минуты (0-59) в текущей временной зоне
					> getSeconds					| секунды (0-59) в текущей временной зоне
					> getMilliseconds			| миллисекунды (0-999) в текущей временной зоне

					> getUTCFullYear 			| год (4 цифры) во временной зоне UTC
					> getUTCMonth 				| месяц (0-11) во временной зоне UTC
					> getUTCDate 					| номер дня в месяце (1-31) во временной зоне UTC
					> getUTCDay 					| номер дня недели (0-6) во временной зоне UTC
					> getUTCHours 				| час (0-23) во временной зоне UTC
					> getUTCMinutes 			| минуты (0-59) во временной зоне UTC
					> getUTCSeconds 			| секунды (0-59) во временной зоне UTC
					> getUTCMilliseconds 	| миллисекунды (0-999) во временной зоне UTC

				Преобразующие в строку геттеры:
					> toDateString 				| возвращает строку с датой (без времени) в человеко-читаемой форме
					> toTimeString 				| возвращает строку с временем (без даты) в человеко-читаемой форме

					> toUTCString 				| возвращает строку с датой и временем во временной зоне UTC
					> toISOString 				| возвращает строку с датой и временем в формате ISO 8601
					> toJSON							| возвращает строку с датой в JSON формате

					> toLocaleString 			| возвращают строку с датой и временем, стилизованную "как в указанной стране"
					> toLocaleDateString 	| возвращают строку с датой (без времени), стилизованную "как в указанной стране"
					> toLocaleTimeString 	| возвращают строку с временем (без даты), стилизованную "как в указанной стране"

				Сеттеры:
					> setTime							| установить UNIX-метку объекта date
					> setFullYear 				| установить год (4 цифры) в текущей временной зоне
					> setMonth 						| установить месяц (0-11) в текущей временной зоне
					> setDate 						| установить номер дня в месяце (1-31) в текущей временной зоне
					> setHours 						| установить час (0-23) в текущей временной зоне
					> setMinutes 					| установить минуты (0-59) в текущей временной зоне
					> setSeconds 					| установить секунды (0-59) в текущей временной зоне
					> setMilliseconds 		| установить миллисекунды (0-999) в текущей временной зоне
					> setUTCFullYear 			|	установить год (4 цифры) во временной зоне UTC
					> setUTCMonth 				|	установить месяц (0-11) во временной зоне UTC
					> setUTCDate 					|	установить номер дня в месяце (1-31) во временной зоне UTC
					> setUTCHours 				|	установить час (0-23) во временной зоне UTC
					> setUTCMinutes 			|	установить минуты (0-59) во временной зоне UTC
					> setUTCSeconds				|	установить секунды (0-59) во временной зоне UTC
					> setUTCMilliseconds 	|	установить миллисекунды (0-999) во временной зоне UTC


		4. Function		| глобальный объект для создания и работы с функциями
			Свои свойства:
				> prototype			| (стат.) св-во prototype функции-конструктора Function
				> length				| (стат.) всегда 1
				> name					| (стат.) имя конструктора, всегда Function
				> arguments			| массив переданных в функцию аргументов
				> length				| самый большой индекс массива аргументов + 1
				> constructor		| содержит ссылку на функцию-конструктор объекта prototype.
			Свои методы:
				> call					| вызывает функцию в контексте указанного объекта, аргументы можно передать списком
				> apply					| вызывает функцию в контексте указанного объекта, аргументы можно передать массивом
				> bind					| связывает 2 функции, так что при вызове 1-й вызывается и 2-я (исходную ф-ию не менят, возвращает новую)
				>	isGenerator		| позволяет выяснить, является ли эта функция функцией-генератором


		5. Number			| объект-обертка для значений типа number, для работы с этими типами
			Свои свойства:
				> prototype						| (стат.)
				> MAX_VALUE						| (стат.)
				> MIN_VALUE						| (стат.)
				> NaN									| (стат.)
				> NEGATIVE_INFINITY		| (стат.)
				> POSITIVE_INFINITY		| (стат.)
			Свои методы:
				> toExponential()			| возвращает строку с числом в экспоненцаильной нотации
				> toFixed()						| возвращает строку, представляющую число, округленное до указанного кол-ва цифр после запятой
				> toPrecision()				| возвращает строку, представляющую число, округленное до указанного кол-ва цифр в общем


		6. Object			| объект-обертка
			Свои свойства:
				> prototype				| (стат.) св-во prototype функции-конструктора Object
				> constructor			| содержит ссылку на функцию-конструктор объекта prototype.
			Свои методы:
				> create										|	(стат.) создает новый объект, и записывает в его __proto__ ссылку на указанный объект
				> getPrototypeOf						|	(стат.) возвращает прототип указанного объекта
				> isPrototypeOf							| содержится ли объект А в цепочке прототипов объекта Б
				> getOwnPropertyDescriptor	|	(стат.) получить объект-дескриптор указанного свойства
				> defineProperty						|	(стат.) определить значения атрибутов свойства объекта
				> defineProperties					|	(стат.) определить значения атрибутов свойств объекта
				> keys											|	(стат.) получить массив имен собственных (только enumerable) свойств объекта
				> propertyIsEnumerable			|	проверить значение атрибута enumerable свойства
				> getOwnPropertyNames				|	(стат.) получить массив имен собственных (enumerable + non-enumerable) свойств объекта
				> preventExtensions					|	(стат.) запретить расширение объекта
				> isExtensible							|	(стат.) проверить, запрещено ли расширение объекта
				> seal											|	(стат.) preventExtensions + запретить удалять св-ва и менять атрибуты (ставит configurable всех св-в = false)
				> isSealed									|	(стат.) проверить, был ли применен к объекту метод seal
				> freeze										|	(стат.) seal + нельзя менять значения св-в (делает атрибут writable всех св-в = false)
				> isFrozen									|	(стат.) проверить, был ли применен к объекту метод freeze
				> hasOwnProperty						| позволяет проверить, является ли указанное св-во родным у указанного объекта
				> toString									| возвращает строковое представление объекта
				> valueOf										| возвращает числовое предствалениео объекта


		7. RegExp			| глобальный объект для создания и работы с регулярными выражениями
			Свои свойства:
				> prototype				| (стат.) св-во prototype функции-конструктора RegExp
				> length					| (стат.) всегда 2
				> constructor			|	ссылка на объект-функцию-конструктор
				> global					|	регулярное выражение с флагом g
				> ignoreCase			| регулярное выражение с флагом i
				> multiline				| регулярное выражение с флагом m
				> lastIndex				| индекс, с которого начать следующий поиск
				> source					| строка с текстом паттерна
			Свои методы:
				> exec			| применяет это РегВыр к строке в аргументе, возвращает индекс 1-го совпадения или null
				> test			| применяет это РегВыр к строке в аргументе, возвращает true / false


		8. String			| глобальный объект-конструктор для создания и работы со строками
			Свои свойства:
				> prototype			| (стат.) св-во prototype функции-конструктора String
				> constructor		| ссылка на объект-функцию-конструктор
				> length				| кол-во символов в строке
				> N							| доступ к N-ому символу строки (0 ... )

			Свои методы:
				> fromCharCode				| (стат.) возыращает строку, собранную из цепочки переданных Unicode значений
				> charAt							| возвращает строку с символом с указанным индексом
				> charCodeAt					| возвращает число, обозначающее юникод указанного символа
				> concat							| конкатенирует 2 строки, и возвращает результат
				> indexOf							| возвращает индекс первого вхождения (слева-направо) строки А в строку Б, или -1 (если не входит)
				> lastIndexOf					| возвращает индекс первого вхождения (справа-налево) строки А в строку Б, или -1 (если не входит)
				> split								| разделяет строку с указанным разделителем на массив строк
				> slice								|	копирует кусок строки от индекса A до Б, и возвращает его
				> substr							|	копирует кусок строки от индекса А, длины L, и возвращает его
				> substring						| копирует кусок строки от индекса A до Б, и возвращает его

				> match								| (работает с RegExp) применить регулярное выражение к строке
				> replace							| (работает с RegExp) найти и заменить
				> search							| (работает с RegExp) найти подстроку в строке

				> toLowerCase					| изменить регистр всех символов строки на верхний
				> toUpperCase					| изменить регистр всех символов строки на нижний

				> trim								| обрезать пробелы перед и после строки

				> localeCompare				| [только Chrome, IE, Opera] сравнивает (>,<,=) "вес" двух строк для сортировочных функций
				> contains						| [работает только в Firefox] содержится ли (true/false) указанная строка в другой строке?
				> endsWith						| [работает только в Firefox] кончается ли (true/false) указанная строка символами другой строки
				> startsWith					| [работает только в Firefox] начинается ли (true/false) строка символами указанной строки
				> toLocaleLowerCase		|
				> toLocaleUpperCase		|


		9. Math				| встроенный объект, содержащий статические свойства и методы для работы с математикой
			Свои статические свойства:
				> E				| значение числа e (~2.718)
				> LN2			| значение натурального логарифма с 2 в основании (~0.693)
				> LN10		| значение натурального логарифма с 10 в основании (~2.303)
				> LOG2E		|	значение логарифма e с основанием 2
				> LOG10E	| значение логарифма e с основанием 10
				> PI			| значение числа ПИ (~3.14159)
				> SQRT1_2	| квадратный корень от 1/2 (~0.707)
				> SQRT2		| квадратный корень от 2 (~1.414)
			Свои статические методы:
				> random						| возвращает псевдо-случайное число от 0 до 1

				> sin								|	синус
				> cos								|	косинус
				> tan								|	тангенс
				> asin							|	арксинус
				> acos							| арккосинус
				> atan							|	арктангенс
				> atan2							| возвращает арктангенс частного 2-х аргументов

				> pow								| возвести x в степень y
				> sqrt							| взять квадратный корень от аргумента
				> abs								| взять аргумент по модулю
				> exp								| возвести e в степень аргумента
				> log								| натуральный логарифм от аргумента
				> max								| возвращает MAX-ое число из переданных в аргументах
				> min								| возвращает MIN-ое число из переданных в аргументах

				> ceil							| округление до целого в большую сторону
				> floor							| округление до целого в меньшего сторону
				> round							| округление до ближайшего целого


		10. JSON			| объект, содержащий методы для конвертации значений в JSON-формат, и обратно
			> Свои статические свойства:
				>
			>	Свои статические методы:
				> parse				| преобразовать строку в JSON-формате в объект JS
				> stringify		| преобразовать JS-объект в строку в JSON-формате

********************************************************




-------------------------------------------------- */



console.log('Another \
very long \
string');









/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


	Основные учебные материалы:

	> JS tutorial на w3cschools.com:
			http://www.w3schools.com/js/default.asp

	> JS и HTML DOM справочник на w3cschools.com:
			http://www.w3schools.com/jsref/default.asp

										-----

	> JS полный учебник на developer.mozilla.org
			https://developer.mozilla.org/en-US/docs/Web/JavaScript

	> JS tutorial на developer.mozilla.org
			https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide

	> JS справочник по объектам на developer.mozilla.org
			https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference


	> Учебник по DOM (Document Object Model)
			https://developer.mozilla.org/en-US/docs/DOM

										-----

	> Учебник по JS от Ильи Кантора:
			http://learn.javascript.ru/

	> Видео курс от Sorax: "Javascript-джедай"
			http://www.youtube.com/playlist?list=PL363QX7S8MfSxcHzvkNEqMYbOyhLeWwem

	> Руководство по JS с разъяснениями тонкостей языка:
			http://bonsaiden.github.io/JavaScript-Garden/ru/

										-----

	> Javascript Ninja - 90 "тонких мест" в JS от создателя jQuery - John'а Resing'а:
			http://ejohn.org/apps/learn/



Инструменты:

	> Онлайн парсер JavaScript, проверяет на ошибки, создает синтаксическое дерево:
			http://esprima.org/demo/parse.html



Статьи:


	> Современный стандарт JavaScript - ECMA-262:
			http://www.ecma-international.org/publications/standards/Ecma-262.htm

	> Перевод на русский ECMAscript 5.1 с аннотациями:
			http://es5.javascript.ru/

	> Статья о прототипно-ориентированном программировании:
			ru.wikipedia.org/wiki/Прототипно-ориентированное_программирование

	> Статья об объектах 1-го класса:
			ru.wikipedia.org/wiki/Объект_первого_класса

	> Статья об отличии экспрешенов от стейтментов в JS:
			http://www.2ality.com/2012/09/expressions-vs-statements.html

	> Статья о замыканиях:
			ru.wikipedia.org/wiki/Замыкание_(программирование)

	> Подробно о примесях (mixins) в JavaScript:
			http://habrahabr.ru/post/132340/

	> Подробно о наследовании в JavaScript:
			http://habrahabr.ru/post/131714/

	> О литералах:
			http://en.wikipedia.org/wiki/Object_literal



*****************************************************
Оглавление:



Общая информация о JS
=====================

	> Как устроен этот справочник

	> Инструменты для работы с JavaScript
		> В Chrome
		> В Firefox
		> Парсер JS и синтаксическое дерево

	> Что такое JavaScript?
		> Факты о JS
		> О среде выполнения
		> Куда и как может быть вставлен

	> Структура языка
		> Общая информация
		> Ядро
		> Объектная модель браузера (BOM)
		> Объектная модель документа (DOM)

	> Основные черты JavaScript

	> О некоторых концепциях, которые использует JS
		> Немного о прототипном программировании
		> Об объектах 1-го класса (first-class object)
		> Анонимные функции
		> Динамическая типизация
		> Замыкания (closure)
		> Трейты (trait)
		> Примеси (mixin)
		> Литерал

	> Области применения JS

	> Безопасность и JS
		> 2 принципиальных ограничения
		> XSS-уязвимости
		> CSRF-уязвимости
		> Чрезмерное доверие на стороне клиента
		> Троянские программы на JS



Базовые концепции ядра JavaScript
=================================


	> Стейтменты
		> Стейтменты
		> Пустые стейтменты
		> Блок стейтментов

	> Экспрешены
		> Общая информация
		> Виды экспрешенов: простые и сложные
			> Простые экспрешены (Primary Expression)
			> Составные экспрешены

	> Отличия стейтментов от экспрешенов

	> Операторы

	> Типы данных и переменные
		> Переменные
		> Типы данных (общая информация)

		> Числа. Почему простые значения в JS могут вести себя, как объекты.
			> Целые числа, и числа с плавающей запятой. Точность вычислений.
			> Системы счисления
			> Вещественные числа
			> Об объекте-обертке Number
			> Бесконечность
			> NaN
			> Underflow

		> Строки
		    [общая информация]
			> Строку можно записывать на нескольких строчках
			> Управляющие последовательности (некоторые)
			> Конкатенация
			> Объект-обертка String

		> Логические значения
				[общая информация]
			> Логические операторы

		> Null и undefined
			  [общая информация]
			> Несколько ситуаций, в которых можно встретить undefined
			> Сравнение null и undefined
			> Что если вызвать функцию в контексте null: f.call(null)

		> Преобразования типов
			> Автоматическое преобразование типов
			> Явное преобразование типов
			> Преобразование простого типа в объект

	> Условные стейтменты
		> if
		> Условный (тернарный) оператор
		> switch

	> Стейтменты - циклы
		> for
		> while
		> do ... while

	> Функции
		> FunctionDeclaration
		> FunctionExpression
			> Имя Named FunctionExpression доступно только внутри этой функции (кроме IE <= 8)
		> Анонимная функция
		> FunctionDeclaration и FunctionExpression - это разные вещи
		> Аргументы

	> Область видимости (scope) переменной и цепочки областей видимости
		> Цепочки областей видимости
			> var надо всегда писать при объявлении локальных переменных!
		> Hoisting - подъем объявления переменных в начало области видимости

	> Замыкания
		> Лексическая область видимости
		> Замыкание - это функция и связанная с ней цепочка областей видимости
		> 2 реализация счетчика: на замыканиях и на свойстве объекта

	> Обработка исключений - стейтменты throw и try/catch/finally
		> Для чего это нужно
		> Исключения интерпретатора
		> Создание объектов-ошибок вручную
		> throw
		> Пример создания исключения
		> Как поймать и обработать исключения с помощью стейтмента try/catch/finally

	> Объекты
		> Базовая информация
			> Объект - это
			> 3 способа создания объекта
			> Экспрешен обращения - для обращения к свойствам объекта
			> Методы
			> Оператор delete - удаление свойств объектов
			> Оператор IN - проверка наличия свойства в объекте
		> Ключевое слово this и родные методы функций bind,call,apply
				[общая информация]
			> Метды call и apply
			> Метод bind
		> Аксессоры - геттер, сеттер - и атрибуты свойств
			> Каждое обычное свойство (вкл. методы) объекта имеет 4 атрибута
			> Каждое свойство-аксессор объекта имеет 4 следующих атрибута
			> Object.getOwnPropertyDescriptor - получить дескриптор
			> Object.defineProperty - определить значения атрибутов свойства
			> Атрибут writable
			> Атрибут enumerable
			> Атрибут configurable
			> Object.defineProperties - определить значения атрибутов свойств
			> Расширяемость объектов
				> Object.isExtensible - проверить, расширяем ли объект
				> preventExtensions - запритить расширяемость объекта
				> seal
				> freeze

	> Прототипы и наследование
			[общая информация]
		> Наследование через __proto__
		> Простой пример наследования
		> Для чего все это нужно
		> Класс в JS
		> Метод isPrototypeOf - содержится ли объект А в цепочке прототипов объекта Б
		> Пример наследования в прототипном программировании через Object.create()

	> Конструкторы и классы
		> В JS есть 2 способа построения классов
		> Конструкторы
		> Prototype
		> Оператор instanceof - проверить, является ли объект X объектом класса Y
		> Пример создания дочернего класса
		> Пример использования дочернего класса
		> Методы toString() и valueOf()
		> Определение класса объекта с помощью техники заимствования метода

	> Цепные вызовы методов

	> JSON

	> Массивы в JS
		> Определение массива
		> Литерал массива
		> Индексы массива
		> Элементы массива
		> Свойство length массива
		> Конструктор Array массива
		> "Удаление" элемента из массива оператором delete
		> Array.isArray() - проверка типа значения на массив
		> Методы для работы с массивами из ES3-ES4
			> Общая информация
			> join				| конкатенирует все элементы массива в 1 строку
			> reverse			| возвращает обратный массив
			> sort				| сортирует массив в алфавитном порядке, может принимать сортирующую callback-функцию
			> concat			| конкатенирует массив с другим массивом, или с какими-то другими элементами
			> slice				| берет подмассив из элементов указанного массива
			> splice			| одновременно удаляет и вставляет элементы в массив
			> push				| вставляет в конец массива 1 или нескольких элементов
			> unshift			| вставляет в начало массива 1 или нескольких элементов.
			> pop					| удаляет последний элемент из массива, и возвращает его.
			> shift				| удаляет первый элемент из массива, и возвращает его.
		> Методы для работы с массивами из ECMAScript 5
			> Общая информация
			> forEach			| возвращает массив из элементов, обработанных callback-функцией
			> map					| возвращает массив из элементов, обработанных callback-функцией
			> filter			| возвращает новый массив из элементов, отсеянных callback-функцией
			> every				| вернет true, если для всех без исключения элементов будет выполнено условие, заданное в callback-функции, иначе false.
			> some				| вернет true, если хотя бы для 1 элемента будет выполнено условие, заданное в callback-функции, иначе false.
			> reduce			| возвращает результат цепного вызова callback-функции для всех элементов слева-направо
			> reduceRight	|	возвращает результат цепного вызова callback-функции для всех элементов справа-налево
			> indexOf			| слева-направо ищет заданный элемент в массиве, и если находит, возвращает индекс первого найденного элемента.
			> lastIndexOf	| справа-налево ищет заданный элемент в массиве, и если находит, возвращает индекс первого найденного элемента.








*****************************************************


=====================
Общая информация о JS============================================================
=====================




> Как устроен этот справочник
======================================================

	> Он разбит на оглавление + 5 основных частей:

		# Оглавление
			> Находится в файле "JS - оглавление и общая информация.js".
			> Содержит:
				- Оглавление по всему справочнику, позволяющее быстро
					найти нужную тему, и перейти для подробного её рассмотрения к
					конкретному файлу.
				- Концептуальный полный справочник по ядру JS. Этот справочник поможет
					быстро вспомнить, как работает тот или иной аспект ядра JS.

		# Ядро JS
			> Здесь содержится кое-что по работе с некоторыми аспектами Ядра JS.
				> Здесь далеко не полная информация.
				> Полная информация по ядру JS
				  = Концептуальный полный справочник по ядру JS
				  + Справочник объектов
				  + Ядро JS
			> В качестве концептуального справочника по Ядру JS можно использовать
				справочник "Базовые концепции ядра JavaScript", который находится
				в этом файле.

		# Клиентский JS, DOM, события, AJAX
			> Прикладной полный справочник по клиентскому браузерному JS,
				DOM, BOM, работе с событиями, AJAX.

		# Справочник объектов
			> Прикладной полный справочник по объектам в javascript.

		# Прикладные решения и техники JS
			> Прикладные техники и решения, с использованием любых технологий
				javascript - ядра, DOM, BOM, событий, jQuery, всяких фреймворков,
				и так далее.
			> Здесь должен храниться багаж хорошо прокомментированных наработок,
				которые можно будет использовать в своих проектах.

		# jQuery
			> Прикладной полный справочник по jQuery.





> Инструменты для работы с JavaScript
======================================================

*****
Оглавление этого раздела

	> В Chrome
		> Консоль JavaScript
		> JsonView

	> В Firefox
		> FireBag
		> JsonView

	> Парсер JS и синтаксическое дерево
		> Синтаксическое дерево
		> Парсер
		> Как все это может помочь в работе с JavaScript?


*****

	> В Chrome
		> Консоль JavaScript
			> В браузере Chrome есть полезный для работы с JS инструмент, который
				называется "Инструменты разработчика".
			> Вызвать его можно горячими клавишами:   CTRL + SHIFT + I.
			> Вызвать его сразу с открытой консолью:  CTRL + SHIFT + J.
			> Этот инструмент содержит консоль JavaScript, в которой непосредственно
				можно писать JS-код, который попадает прямо в интерпретатор JS в
				браузере, и результат (если он есть) выводится тоже в эту консоль.
			> Горячие клавиши для инструментов разработчика:
					https://developers.google.com/chrome-developer-tools/docs/shortcuts?hl=ru
			> Уствновка другой цветовой темы для консоли:
				> Иногда хочется установить для консоли Chrome другую цветовую тему.
					Например, потемнее. Это можно сделать следующим образом:
				> Скачать новую цветовую тему, например отсюда:
						https://github.com/zenorocha/dracula-theme
				> Перебросить файл custom.css в следующую папку (windows 8):
						C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\User StyleSheets
		> JsonView
			> Позволяет просматривать JSON документы прямо в браузере.

	> В Firefox
		> FireBag
			> В FireFox также имеется инструмент для работы с JS непосредственно
				из консоли в браузере. Этот инструмент называется FireBag. Он поставляется,
				как расширение к браузеру, которое можно установить отсюда:
					https://addons.mozilla.org/ru/firefox/addon/firebug/‎
			> Для быстрого доступа к FireBag можно воспользоваться горячей клавишей
				F12.
			> Дополнения, улучшающие FireBag:
				- Fire Rainbow					| подсветка кода для FireBug
				- FireQuery							| для разработки под jQuery — выводит в разных местах вспомогательную информацию.
				- Firebug Autocompleter | автодополнение для консоли в многострочном режиме
				- CSS-X-Fire						| позволяет редактировать CSS в Firebag и сохранять изменения,
																	интегрировано с редакторами от JetBrains.
		> JsonView
			> Позволяет просматривать JSON документы прямо в браузере.

	> Парсер JS и синтаксическое дерево
		> Синтаксическое дерево
			> Это внутренняя структура, которую интерпретатор javascript создает
				из исходного кода.
			> А вообще в computer science - Абстрактное Синтаксическое Дерево (или
				просто Синтаксическое Дерево) - представление в виде дерева абстрактной
				синтаксической структуры кода, написанного на языке программирования.
			> Интерпретатор javascript использует синтаксисечкое дерево для семантического
			  анализа кода - проверяет правильность использования элементов языка
			  программирования.
		> Парсер
			> Это программа, которпя проводит синтаксический анализ кода, и дает
				некий выходной результат.
			> Результатом может быть и синтаксическое дерево.
			> Отличный парсер javascript есть в интернете по адресу:
					http://esprima.org/demo/parse.html
		> Как все это может помочь в работе с JavaScript?
			> Провить код на синтаксические ошибки.
			> Точно узнать, как интерпретатор JS воспринимает тот или иной код.


> Что такое JavaScript?
======================================================

	> Факты о JS
		> JavaScript - прототипно-ориентированный язык программирования.
		> Официальное название - ECMAScript.
		> Ядро JS описан стандартом ECMA-262.
			> Последняя редакция - ECMAScript 5.1.
			> Редакция ECMAScript 6 в настоящий момент находится в работе,
				и может скоро выйти.
		> Клиентский JS браузеров - описан стандаром DOM Level 3 от W3C.
		> Все современные браузеры - Chrome, Safari, Firefox, Opera, IE,
			и другие - полностью поддерживают текущий стандарт JS.
		> Языком JavaScript не владеет какая-либо компания.

	> О среде выполнения
		> JS предоставляет только базовую функциональность - ядро - а прочую
			часть функциональности предоставляет среда, в которой он запускается.
		> JS может быть запущен совершенно в разных средах, а не только в браузере.
			Например, он может быть использован на сервере (напр., node.js).
		> Но чаще всего его используют именно в браузере.

	> Куда и как может быть вставлен
		> JS может быть вставлен в элементы head и body HTML-документа.
	 	> Написать код JS можно либо непосредственно в коде HTML-документа,
	 	 	в элементе script, например:

	 	 		<script> .. js-код .. </script>

	 	 	либо добавить в HTML-документ, подключив из внешнего файла. Например:

	 	 		<script src="myFile.js"></script>



> Структура языка
======================================================

*****
Оглавление этого раздела

	> Общая информация
	> Ядро
	> Объектная модель браузера (BOM)
	> Объектная модель документа (DOM)

*****

	> Общая информация:
		> JavaScript состоит из:
			- Ядро JS
			- Клиентский JS - дополнительный функционал, который обеспечивается
				средой выполнения.
		> О клиентском JS
			> Средой выполнения может быть не только браузер, а все что угодно,
				у чего есть интерпретатор JS.
			> Но в первую очередь меня интересует выполнение в браузере. Эта среда
				снабжает JS следующим доп. фунационалом:
				- BOM - Browser Object Model
				- DOM - Document Object Model
		> Суть в том, что ядро - это несколько базовых объектов да структурных
			элементов. А подключение остальной функциональности зависит среды,
			в которой скрипт выполняется.
			> Если в браузере, то подключаются доп. функционал в виде BOM и DOM.
			> Если на сервере, то подключается доп. функционал в ... каком-то
				ином видео.
			> Таким образом, при работе JS в отличных от браузера окружениях,
				BOM и DOM могут и не поддерживаться.

	> Ядро
		> ECMAScript не является браузерным языком, и в нем не определяются
			методы ввода/вывода информации. Это скорее основа для построения
			сктиптовых языков.
		> Ядро содержит:
			- Базовый набор объектов, таких как Array, Date, Math
			- Базовый набор элементов языка, таких как операторы, контролирующие
				ход выполнения скрипта структуры (if, for, ...), и стейтменты.
		> Ядро JavaScropt может быть снажбено дополнительными объектами.
			Например:
			> Client-side JavaScript дополняется объектами для конотоля различных
				аспектов браузера (BOM) и для воздействия на документ (DOM).
			> Server-side JavaScript дополняется объектами, относящимися к его
				выполнению на сервере. Например, server-side дополнения позволяют
				установить соединение с базой данных, обеспечивают непрерывность
				информации от одного взаимодейстия к другому, или позволяют
				осуществлять манипуляции на сервере.

	> Объектная модель браузера (BOM)
		> BOM - это прослойка между ECMAScript и DOM.
		> BOM на данный момент (05.11.2013) не стандартизирован, однако
			стандарт находится в разработке.
		> Основное предназначение BOM - управление окнами браузера и обеспечение
			их взаимодействия.
		> Каждое из окон браузера представлено объектом window
			- центральным объектом для DOM.
		> Помимо управления окнами, в рамках BOM обычно обеспечивается
			поддежка следующих сущностей:
			- Управление фреймами
			- Поддержка задержки в исполнении кода и зацикливания с задержкой
			- Системные диалоги
			- Управление адресом открытой страницы
			- Управление информацией о браузере
			- Управление информацией о параметрах монитора
			- Ограниченное управление историей просмотра страниц
			- Поддержка работы с HTTP cookie

	> Объектная модель документа (DOM)
		> DOM - это API для работы с HTML и XML документами.
		> Согласно дом, документ может быть представлен в виде дерева
			объектов, обладающих рядом свойств, которые позволяют производить
			с ним различные манипуляции:
			- Создание и добавление узлов
			- Получение узлов
			- Изменение узлов
			- Изменение связей между узлами
			- Удаление узлов



> Основные черты языка
======================================================

*****
Оглавление этого раздела

	> Список основных черт
	> Подробнее о динамичности
		> Динамическая типизация
		> В основе - объекты
		> Run-time evaluation

	> Подробнее о функциональности
		> Функции 1-го класса

	> Подробнее о прототипно-ориентированности
		> Прототипы, а не классы
		> Функции - как конструкторы объектов
		> Функции - как методы

	> Подробнее о скрытой и явной делегации
		> Явная делегация
		> Неявняа делегация

	> Подробнее о прочих чертах
    > Среда выполнения
    > Переменное число аргументов у функций
    > Литералы - объект и массив
    > Регулярныев выражения


*****

	> Список основных черт:
		> Динамичный:
			- Динамическая типизация
			- В основе - объекты
			- Run-time evaluation

		> Функциональный:
			- Функции 1-го класса

		> Прототипно-ориентированный:
			- Прототипы
			- Функции - как конструкторы для объектов
			- Функции - как методы

		> Скрытая и явная делегация:
			- Функции - как трейты (trait) и примеси (mixin).
			- Связь между объектами (Composition) и наследование

		> Прочие черты:
			- Среда выполнения
			- Переменное число аргументов у функций
			- Литералы - объект и массив
			- Регулярныев выражения
			- Анонимные функции

	> Подробнее о динамичности:

		# Динамическая типизация
			> В JS типы данных ассоциируются со значениями, а не с переменными.
				так происходит в большинстве скриптовых языков.
		# В основе - объекты
			> JS почти полнсотью основан на объектах:
				- Объекты в JS - это ассоциативные массивы, дополненные прототипами.
				- Имена свойств объекта - ключи.
				- Подерживается 2 равнозначных синтаксиса:
					- через точку (obj.x = 10)
					- через квадратные скобки (obj['x'] = 10).
				- Свойства объекта и их значения могут быть добавлены, изменены,
					удалены в процессе выполнения программы.
				- К большинству свойств объекта (включая те, что унаследованы от прототипа
					и цепочки родителей) можно получить доступ с помощью цикла for...in.
				- В ядре JS есть достаточно мало встроенных объектов, таких
					как Function и Date.
		# Run-time evaluation
			>	У JS есть функция eval, которая может выполнять стейтменты, переданные
				в виде строк, прямо в процессе выполнения программы.

	> Подробнее о функциональности:
		# Функции 1-го класса
			> Все JS-объекты Function - функции 1-го класса.
					(подробнее о фунациях 1-го класса читай ниже).
			> Вложенной - называют функцию, определенную внутри другой функции.
			> Вложенная функция создается каждый раз, когда вызывается её
				внешняя функция, и образует замыкание.
					(подробнее о замыканиях читай ниже)

	> Подробнее о прототипно-ориентированности:
			(еще подробнее читай ниже "Немного о прототипном программировании")
		# Прототипы, а не классы
			> JS для наследования использует прототипы, а не классы.
			> Однако, с помощью проторипов можно симулировать многие основанные
				на классах фичи.
		# Функции - как конструкторы объектов
			> Функции в JS имеют двойное предназначение:
				- Быть функцией.
				- Быть конструктором новых объектов.
			> Если перед вызовом функции поставить ключевое слово new, то будет
				создан новый экземпляр, наследующий свойства и методы своей
				функции-прототипа, а также всех своих предков вверх по цепочке.
			> В ECMAScript 5 есть возможность явно создать экземпляр с помощью
				метода Object.create, при этом автоматического наследования от
				прототипа Object не происходит.
			> Свойство prototype функции-конструктора определяет объект, ссылка на
				который, при создании нового объекта оператором new из этой функции-
				конструктора, будет записано в св-во __proto__ этого нового объекта
				для внутреннего прототипа нового объекта.
			> Новые методы могут быть добавлены путем модификации прототипа объекта,
				используемого как конструктор.
			> Встроенные в JS конструкторы, такие как Array или Object, тоже имеют
				прототипы, которые могут быть модифицированы.
			> Однако, хоть и возможно модифицировать прототип Object'а, это считают
				плохой практикой, потому что большинство объектов в JS имеют в цепочке
				наследования Object, и для них может стать неожиданностью, что в нем
				что-то изменилось.
		# Функции - как методы
			> В JS нет различий между объявлением функции, и объявлением метода.
				Различие есть во время вызова: если вызвать функцию, как метод
				объекта, то локальное this этой функции ссылается на этот объект.

	> Подробнее о скрытой и явной делегации:
		> Язык JS поддерживает делегацию
				(подробнее читай ниже в: "Немного о прототипном программировании")
		# Явная делегация.
			(Функции - как трейты (trait) и примеси (mixin))
			> JS изначально поддеживает разные, основанные на функциях реализации
				Role-паттернов, таких как трейты (Traits) или примеси (Mixins).
			> Такая функция определяет дополнительное поведения с помощью хотя бы
				1-го метода, ссылающегося на ключевое слово this в теле функции.
			> Роль должна быть делегирована явно с помощью методов call или apply
				объектам, которым требуется передать доп. функциональность, которую
				они не получают из прототипной цепочки.
		# Неявная делегация.
			(Связь между объектами (Composition) и наследование)
			> Неявная делегация происходит каждый раз, когда в случае отсутствия
				метода в объекте начинается поиск этого метода вверх по цепочке
				прототипов. А когда этот метод находится, то он вызывается в
				контексте того объекта, из которого был запрошен.

	> Подробнее о прочих чертах:
		# Среда выполнения
			> Обычно JS погалается на среду, в которой он выполняется (например,
				браузер) - которая и должна обеспечить объекты, с которыми JS
				может взаимодействоват, и методы, которыми JS может взаимодействоать.
				Например, это DOM в браузерах.
			> Также, JS полагается на среду выполнения, которая должна обеспечить
				возможность встроить/импортировать скрипт (например, HTML-элемент
				script).
			> Все это не является частью языка JS само по себе, но это используется
				в большинстве реализаций JS.
		# Переменное число аргументов у функций
			> В функцию можно передать переменное число аргументов. Функция может
				получить к ним доступ через локальный объект arguments.
		# Литералы - объект и массив
			> Как и во многих скриптовых языках, массивы и объекты могут быть
				созданы с использованием укороченного синтаксиса. Фактически, эти
				формы литералов - основ формата данных JSON.
		# Регулярныев выражения
			> JS поддерживает регулярные выражения, с помощью которых можно быстро
				искать в тексте и выполнять с ним различные операции.



> О некоторых концепциях, которые использует JS
======================================================

*****
Оглавление этого раздела

	> Немного о прототипном программировании
	> Об объектах 1-го класса (first-class object)
	> Анонимные функции
	> Динамическая типизация
	> Замыкания (closure)
	> Трейты (trait)
	> Примеси (mixin)
	> Литерал
	> Идентификатор

*****

	> Немного о прототипном программировании
		> Прототипное программирование - стиль ООП, при котором отсутствует понятие
			класса, а наследование производится путем клонирования существующего
			экземпляра класса.

		> Сравнение прототипного и класс-ориентированного подхода к ООП
			> Класс-ориентированный подход:
				- Все объекты разделены на два основных типа: классы и экземпляры.
				- Новый экземпляр создают через вызов конструктора класса (возможно, с
					параметрами). Получившийся экземпляр имеет структуру и поведение, жестко
					заданные его классом.
			> Прототипный подход:
				- Понятие "класс" отсутствует. Одни объекты, которые называют "базовыми", используют для создания
					других объектов.
				- 2 метода создания нового объекта: клонирование и "с нуля".
					> При клонировании копия наследует все свойства и методы своего прототипа.
						В некоторых реализациях копия хранит ссылку на своего прототипа,
						делигируя ему эту часть своей функциональности (как в JS)
					> Объект можно создать "с нуля", присвоив ему свойства и методы.
						После создания его можно клонировать.

		> Есть 2 методики клонирования, применяющиеся в разных прототипно-
			ориентированных языках.
			> 2 методики:
				- Делегирование
				- Каскадирование
			> Подробнее о них:
				> Делегирование
					> Именно этот метод и применяется в JavaScript.
					> При клонировании объекта А получаем объект Б, для которого объект
						А - прототип. У объекта Б нет ни 1-го метода или свойства. Но
						у него есть ссылка на объект А. Поэтому все методы и свойства
						объекта А доступны объекту Б.
					> Мало того, если объект А - тоже клон какого-нибудь объекта В,
						то объекту Б доступны методы и свойства объекта В тоже. И так
						далее по цепочке вверх до самого последнего объекта-прородителя.
					> Это дает возможность для каждого объекта легко расширять, изменять,
						дополнять доставшуюся ему по наследству от цепочки прородителей
						функциональность.
				> Каскадирование
					> См. описание по ссылке:
						"Статья о прототипно-ориентированном программировании"

	> Об объектах 1-го класса (first-class object)
		> Объект называют объектом 1-го класса, если:
			- Он может быть сохранен в переменной или структурах данных.
			- Может быть передан в функцию, как аргумент.
			- Может быть возвращен из функции, как результат.
			- Может быть создан во время выполнения программы.
			- Внутренне самоидентифицируем (независим от именования)

	> Анонимные функции
		> Которые при объявлении не получают уникального идентификатора.
		> После объявления анонимная функция:
			> Либо сразу выполняется.
			> Либо ссылка на нее присваивается переменной, с помощью которой
				потом можно вызвать эту фукнцию (и передать аргументы, если потребуется).

	> Динамическая типизация
		> Как и в большинстве скриптовых языков, в JS типы ассоциируются со
			значениями, а не с переменными.
		> Например, переменной X можно присвоить сначала число 10, потом
			строку "John".

	> Замыкания (closure)
		> Общая информация
			> Также его называют lexical closure или function closure.
			> Замыкание - способ упаковать в одну коробку функцию данные, на которые
				она ссылается, во внешней относительно её области видимости среде,
				в которой она вызвана.
			> В записи это выглядит как функция, находящаяся целиков в теле другой
				функции. При этом вложенная фукнция содержит ссылки на локальные
				переменные внешней фукнции.
			> Каждый раз при выполнении внешней функции происходит создание нового
				экземпляра внутренней функции, с новыми ссылками на переменные
				внешней функции.
		> Замыкания в JS
			> В JS областью видимости локальных переменных (объявляемых словом var),
				являетс тело функции, внутри которой они определены.
			> Если объявить функцию внутри другой функции, первая получает доступ
				к переменным и агрументам последней:

					function outerFn(myArg) {
						var myVar;
						function innerFn() {
							// имеет доступ к myVar и myArg
						}
					}

			> При этом, такие переменные продолжают существовать и остаются доступными
				внутренней фукнции даже после того, как внешняя функция, в которой
				они определены, была исполнена.
			> Пример счетчика, сделанного на основе замыкания:

						function createCounter() {
							 var numberOfCalls = 0;
							 return function() {
									return ++numberOfCalls;
							 }
						}
						var fn = createCounter();
						fn(); // 1
						fn(); // 2
						fn(); // 3

	> Трейты (trait)
		> Общая информация
			> Объект, определенный как трейт, создан как композиция методов, которые
				могут быть использованы другими классами без необходимости множественного
				наследования.

	> Примеси (mixin)
		> Подрбно о примесях в JS здесь:
				http://habrahabr.ru/post/132340/
		> Примесь (mixin) - объект с набором функций, который сам по себе
			(отдельно от других объектов) не используется.

	> Литерал
		> Литерал - обозначение, которое дают фиксированному значению в коде.
		  То есть парсер воспринимает литерал, как готовое значение. В отличие,
		  например, от идентификатора, который парсер воспринимает как ссылку
		  на какой-то экспрешен.
		> Литералы можно как просто вставлять в код, так и инициализировать
		  ими переменные.
		> Есть несколько типов литералов.
		> В JS литералами также могут быть массив и объект.

	> Идентификатор
		> Идентификатор - Identifier - указывает на какой-то экспрешн.
		> Когда парсер видит в коде идентификатор, то он вычисляет его значение,
			и заменяет идентификатор его значением. Например, если идентификатор
			x ссылается на литерал 10, то выражение:

				x + x

			интерпретатор JS заменит на:

				20


> Области применения JS
======================================================

	> Список областей применения:
		- Как на стороне клиента, так и на стороне сервера.
		- AJAX и Comet
		- Пользовательские скрипты в браузере
		- Браузерные операционные системы
		- Серверные приложения
		- Мобильные приложения
		- Прикладное ПО
		- Манипуляция объектами приложений
		- Офисные приложения

	> Клиент или сервер?
		> JS может быть использован:
			- Как на стороне клиента.
			- Так и на стороне свервера.
		> На стороне клиена. Например в браузере, который можно рассматривать как
			клиент в клиент-серверном взаимодействии с веб-сервером.
		> На стороне сервера. Нампимер, в node.js.

	> Использование JS в веб-документах
		> Чаще всего JS используют для написания кода, который встраивают в
			HTML-документ, и который взаимодействует с DOM этого документа.
			Вот некоторые способы применения JS:
			- Загружать новый контент на сайт, или отпрвлять данные на сервер,
				используя AJAX - без перезагрузки страницы.
			- Анимировать элементы страницы - двигать, скрывать/раскрывать,
				менять размер и т.д.
			- С помощью JS может быть создан интерактивный контент, такой как
				игры, проигрывание видео/аудио.
			- Валидация веб форм (не рекомендуется, не безопасно, её лучше делать
				на сервере).
			- Передача информации о поведении пользователя на другой сайт, например.
				Веб-документы часто делают это для сбора веб-аналитики, аналитики
				для рекламы, персонализации и так далее.
		> Посколько JS-код работает у пользователя в браузере, то он может отвечать
			на действия пользователя очень быстро, ведь вся эта среда работает по
			сути на локальном компьютере пользователя.


> Безопасность и JS
======================================================

	> Автор вредоносного кода может запустить его на любом в компьютере в сети -
		достаточно с этого компьютера открыть HTML-документ с вредоносным
		JS-кодом.
	> Поэтому для JS существуют 2 принципиальных ограничения:
		> JS программы выполняются "в песочнице" - они могут выполнять только
			ограниченный круг действий.
		> Для JS кода применяется политика "общего происхождения" - встроенный
			в страницу скрипт не может получить доступ к ряду свойств объектов
			другой страницы (в частности, к большинству свойств объекта document)
			при отличии в протоколе, хосте или номере порта этих страниц.
		> Помимо этого разработчики браузеров вносят доп. ограничения в ответ
			на появляющиеся злоупотребления.
	> XSS-уязвимости
		> XSS - Cross Site Scripting - межсайтовый скриптинг.
		> Имеет место в ситуациях, когда злоумышленник имеет возможность поместить
			скрипт на страницу, демонстрируемую пользователю. В этом случае скрипт
			получает доступ к сайту с правами этого пользователя, что в ряде случаев
			открывает возможность отсылки конфеденциальной информации, осуществлении
			нежелательных транзакций и т.д.
		> Например, можно создать копию страницы для входа и работы в личном
			кабинете какого-то сервиса, и заманить пользователей, чтобы они работали
			через эту страницу. А на этой странице будет вредоносный JS код, который
			будет собирать пароли и логины этих пользователей.
	> CSRF-уязвимости
		> CSRF - Cross Site Request Falsification - подделка межсайтовых запросов.
		> Заключается в том, чтобы заставить браузер пользователя, зашедшего на
			страницу злоумышленника, осуществить задуманное злоумышленником действие
			на задуманном им сайте.
			> Это сработает, если целевой сайт будет полагаться только на
				HTTP-cookie. Тогда браузер жертвы заходит на целевой сайт, и в нем
				уже имеются старые куки. И он совершает задуманное злоумышленником
				действие.
		> Защита - проведение аутентификации при любом запросе с важными и
			необратимыми последствиями.
	> Чрезмерное доверие на стороне клиента
		> Нельзя доверять клиенту ничего, потому что:
			- Любой JS код на странице открыт всему миру, и может быть прочитан
				и изучен кем угодно, кто имеет доступ к этой веб-странице.
			- Любая JS-проверка на стороне клиента (например, валидация формы)
				может быть легко обойдена - достаточно выключить выполнение JS
				в браузере, или даже вручную внести в него изменение.
				> А это в свою очередь может грозить, например, SQL-инъекциями или
					другой гадостью, в зависимости от конкретного веб-приложения.
				> Поэтому, валидацию надо проводить на стороне сервера.
	> Троянские программы на JS
		> MS Windows позволяет файлам с кодом JS запускаться как обычным программам,
			без помещения в "песочницу", это делает возможным создание троянских
			программ на JS.










=================================
Базовые концепции ядра JavaScript=============================================
=================================



	> Стейтменты
		> Стейтменты
			> Все программы на JS состоят из стейтментов (statement)
			> Стейтменты, в отличие от экспрешенов, не возвращают значения,
				а просто выполняются.
			> Все стейтменты (кроме составных) разделены между собой точкой с
				запятой ; . Например:

					statement; statement; statement;

			> JS игнорирует пустыи символы и переносы строк, поэтому часто
				стейтменты пишут на разных строчках:

					statement;
					statement;
					statement;

			> Точку с запятой в конце стейтмента можно не ставить, парсер сам
				поставит её за тебя. Однако, лучше все же ставить ее самому, иначе
				парсер в некоторых ситуациях может поставить её не туда, куда ты
				ожидаешь, и появится трудно уловимая ошибка.

		> Пустые стейтменты
			> Парсер JS нормально принимает и пустые стейтменты, и называет их
				EmptyStatement. Проверить это можно с помощью онлайн парсера JS,
				ссылка на который есть в ссылках.
			> Например, 5 пустых стейтментов:

					;;;;;

			> Есть 2 основных области применения пустых стейтментов:
				1. Пустые стейтменты можно использовать там, где парсер ожидает увидеть
					 какую-либо инструкцию, но мы не хотим, чтобы что-то выполнялось.
					 Например:

						for(;;) { }

				2. Пустой стейтмент устанавливается в самом начале файла со скриптом.
					 Дело в том, что перед выпуском в продакшн, считается хорошей привычкой
					 сжимать все скрипты проекта и конкатенировать их в 1 файл.
					 И если окажется, что предыдущем файле кто-то не поставил в конце
					 точку с запятой ; , а в начале текущего файла нет точки с запятой,
					 то будет ошибка. Ну а ином случае, от лишней ; ничего плохого не
					 произойдет, будет просто лишний пустой стейтмент.
						Пример:

							;(function() {

							}());

		> Блок стейтментов
			> Блок стейтментов можно использовать в тех местах, где парсер ожидает
				увидеть 1 стейтмент, но ты хочешь использовать несколько.
			> Пример блока стейтментов:

				{
					statement;
					statement;
					statement;
				}


	> Экспрешены
		> Общая информация
			> Экспрешен (Expression) - это фраза языка JavaScript, которая может
				быть вычислена интерпретатором для получения значения. Экспрешены -
				это как слова в стейтментах-предложениях.
			> Экспрешены, в отличие от стейтментов, всегда возвращают какое-то значение.
			> Когда интерпретатор JS видит в коде экспрешн, он заменяет его значением
				этого экспрешена. Например:

					Интерпретатор видит такой экспрешн:

						2 + 5

					И заменяет его его значением:

						7

		> Виды экспрешенов: простые и составные

			> Простые экспрешены (Primary Expression)
			  > Это такие, которые не включают в себя другие экспрешены.
			  > В качестве примера возьмем простой экспрешн и его синтаксическое
			  	дерево:

			  		7;														| expression
						----------
            "type": "ExpressionStatement",
            "expression": {
                "type": "Literal",
                "value": 7,
                "raw": "7"
            }

				> К простым выражениям относятся:
					- Идентификаторы.
						> Например:

								Sorax;
								Ivan;

					- Литералы.
						> Например:

								12345;
								"Jonh";

					- Некоторые ключевые слова.
						> Например:

								this;

			> Составные экспрешены
				> Отличаются от простых более сложным составом. Если в простом
					экспрешене узел "expression" содержит сразу литералы, то в
					составном экспрешене он содержит вложенный экспрешен/экспрешены.
				> Примеры составных экспрешенов и их синтаксические деревья:

					+7;                               | UnaryExpression
					----------
							"type": "ExpressionStatement",
							"expression": {
									"type": "UnaryExpression",
									"operator": "+",
									"argument": {
											"type": "Literal",
											"value": 7,
											"raw": "7"
									},
									"prefix": true
							}

													---

					7+7;															| BinaryExpression
					----------
							"type": "ExpressionStatement",
							"expression": {
									"type": "BinaryExpression",
									"operator": "+",
									"left": {
											"type": "Literal",
											"value": 7,
											"raw": "7"
									},
									"right": {
											"type": "Literal",
											"value": 7,
											"raw": "7"
									}
							}

													---

					(7>3) ? 10 : 20										| ConditionalExpression
					----------

							"type": "ExpressionStatement",
							"expression": {
									"type": "ConditionalExpression",
									"test": {
											"type": "BinaryExpression",
											"operator": ">",
											"left": {
													"type": "Literal",
													"value": 7,
													"raw": "7"
											},
											"right": {
													"type": "Literal",
													"value": 3,
													"raw": "3"
											}
									},
									"consequent": {
											"type": "Literal",
											"value": 10,
											"raw": "10"
									},
									"alternate": {
											"type": "Literal",
											"value": 20,
											"raw": "20"
									}
							}

													---

					a=10;                              | AssignmentExpression
					----------
								"type": "ExpressionStatement",
								"expression": {
										"type": "AssignmentExpression",
										"operator": "=",
										"left": {
												"type": "Identifier",
												"name": "a"
										},
										"right": {
												"type": "Literal",
												"value": 10,
												"raw": "10"
										}
								}

													---


	> Отличия стейтментов от экспрешенов
		> JS различает понятия стейтмент и экспрешн.
		> Я специально пишу эти термины так, не переводя их на русский, чтобы
			не создавать дополнительнойпутаницы.
		> Экспрешен - возвращает значение, и может быть помещен в любое место,
			где ожидается значение.
			> Примеры:
					myvar;
					myvar = 10;
					1 + 2;
					x = 1 + 2;
					myfunc('a', 'b');    // вызов функции
		> Стейтмент - не возвращает значения.
			> Пример:
					if() {  }
					for() {  }
		> Итого:
			> Экспрешн - это то, что возвращает значение, и может быть вставлено
				везде, где JS ожидает получить значение или стейтмент.
			> Стейтмент - это все, что не экспрешн. Его нельзя вставить туда,
				где JS ожидает экспрешн-значение.
				> Например, стейтмент не может стать аргументом функции.


	> Операторы
		> Операторы служат для объединения простых экспрешенов в составной.
		> Есть 3 вида операторов, различаются они кол-вом операндов:
			- Унарный (Unary)     | (1 операнд)
				> Например:
					+10;
					-20;

			- Бинарный (Binary)   | (2 операнда)
				> Например:
					10+20;
					20-10;

			- Тернарный (Ternary) | (3 операнда) - такой есть только 1
				> Например:
					(20>10) ? (30) : (40)      | если 20 > 10 дает true, вернуть 30, иначе вернуть 40.
		> Всего операторов достаточно много, их полный список можно посмотреть
			в другом справочнике, или в соответствующем файле этого справочника.
		> Замечение по поводу операторов == (не строгое сравнение) и === (
			строгое сравнение).
			> В своих скриптах рекомендуется использовать только оператор === и
			  соответствующие ему прочие операторы строгого сравнения, потому что
			  при их использовании не происходит автоматического преобразования
			  типов, что делает поведение скрипта более предсказуемым.



	> Типы данных и переменные
		> Переменные
			> Когда на время выполнения программы нам требуется сохранить какое-то
				значение, мы записываем его в переменную (Variable).
			> Получить обратно сохраненное значение мы можем по имени переменной.
			> Для объявления переменной используют ключевое слово var. После него
				идет идентификатор, который будет являться именем переменной.
			> Инициализация переменной - это задание ей первичного значения
				при объявлении.
			> Стейтмент с ключевым словом var называется Declaration Statement
				(или Стейтент Объявления).
			> Пример и синтаксическое дерево:

					var myVar = 'Ivan';                | VariableDeclaration
					---------------------
								"type": "VariableDeclaration",
								"declarations": [
										{
												"type": "VariableDeclarator",
												"id": {
														"type": "Identifier",
														"name": "myVar"
												},
												"init": {
														"type": "Literal",
														"value": "Ivan",
														"raw": "'Ivan'"
												}
										}
								],
								"kind": "var"

			> Можно объявить и инициализировать сразу несколько переменных
				в 1-м стейтменте:

					var myVar1=10, myVar2=20;
					---------------------
								"type": "VariableDeclaration",
								"declarations": [
										{
												"type": "VariableDeclarator",
												"id": {
														"type": "Identifier",
														"name": "myVar1"
												},
												"init": {
														"type": "Literal",
														"value": 10,
														"raw": "10"
												}
										},
										{
												"type": "VariableDeclarator",
												"id": {
														"type": "Identifier",
														"name": "myVar2"
												},
												"init": {
														"type": "Literal",
														"value": 20,
														"raw": "20"
												}
										}
								],
								"kind": "var"

			> После того, как переменные объявлены, и им присвоены какие-то
				значения, мы можем обращаться к ним где угодно в нашей программе.
				> Например, можно вывести значение переменной в консоль:

						console.log(myNumber);
						console.log(myString);

			> Идентификаторы
			 	> Идентификаторы в JS могут начинаться с:
					- Буквы          | Ivan
					- Символа _      | _Ivan
					- Знака $        | $Ivan
				> Идентификаторы не могут начинатсья с цифры. Это сделано для
					того, чтобы парсеру было проще различать идентификаторы и
					числа.
				> Также в JS есть список зарезервированных слов, которые нельзя
					использовать в качестве идентификатора:
						break,delete,case,do,catch,else,continue,false,debugger,
						finally,default,for,function,return,typeof,if,switch,var,
						in,this,void,instanceof,throw,while,new,true,with,null,
						try,class,const,enum,export,extends,import,super,implements,
						let,private,public,yield,interface,package,protected,static
				> JS чувствителен к регистру. Поэтому следующие 2 идентификатора
					он воспринимает, как разные, а не как одинаковые:

						myvar;
						myVar;

				> Нотации идентификаторов
					> Хорошим тоном считается использовать ту нотацию, которая
						общепринята для того языка, на котором ты в данный момент
						пишешь.
					> Есть 2 наиболее распространенных видов нотации идентификаторов:
						> CamelCase - верблюжья нотация
							> Такой стиль принят в языке JS.
							> Примеры:

								myVar;
								myCar;

						> Underscore - нижнее подчеркивание.
							> Такой стиль принят, например, в языке PHP.
							> Примеры:

								my_var;
								my_car;

		> Типы данных (общая информация)
			> В программах обычно производят какие-то действия над данными, и данные
				в программах бывают разных типов.
			> Типы данных в JS можно разделить на:
				- Простые    | primitive
				- Объектные	 | object
			> Простые типы
				> В JS вего 5 простых типов (примитивов):

						var myNumber = 2525,     | числовой литерал
								myString = 'Ivan',   | строковы литерал
								myBool = true,			 | логический литерал
								myNull = null,       | ноль литерал
								myUndef = undefined; | неопределенный (не литерал, а идентификатор)

				> В том, что undefined - идентификатор, можно убедиться с помощью
					нашего онлайн парсера. Вот его синтаксическое дерево:

						var x = undefuned;
						---------------------

									"type": "VariableDeclaration",
									"declarations": [
											{
													"type": "VariableDeclarator",
													"id": {
															"type": "Identifier",
															"name": "x"
													},
													"init": {
															"type": "Identifier",
															"name": "undefuned"
													}
											}
									],
									"kind": "var"

				> Для определения типа выражения в JS есть унарный оператор typeof.
					Например:

						console.log(typeof myNumber);  | "number"
						console.log(typeof myString);  | "string"
						console.log(typeof myBool);    | "boolean"
						console.log(typeof myNull);    | "object"
						console.log(typeof myUndef); 	 | "undefined"

				> Тот факт, что тип переменной myNull определяется, как объект,
					является известно ошибкой в языке JS. Но люди, которые занимаются
					разработкой спецификации JS ничего не могут изменить, потому что
					уже много кода написано с учетом этой ошибки. И если изменить
					поведение оператора typeof, сломается много скриптов по всему миру,
					в том числе большинство существующих на сегодняшний день JS-библиотек.

			> Объектные типы
				> Объектные типы можно называть просто "Объекты".
				> К объектам относятся:

					var obj = {name: 'Sorax'},   | объекты
							array = [1,2,3],         | массивы
							regexp = /w+/g,          | регулярные выражения
							func = function(){};     | функции

				> Чтобы убедиться, что эти переменные являются объектами, можно
					воспользоваться оператором typeof:

						console.log(typeof obj);     | "object"
						console.log(typeof array);   | "object"
						console.log(typeof regexp);  | "object"
						console.log(typeof func);		 | "function"

				> Тот факт, что тип переменной func определяется, как "Function" -
					это просто еще одна особенность оператора typeof.

			> JS - это язык с динамической типизацией. Это значит, что тип переменной
				автоматически определяется интерпретатором, в зависимости от присвоенного
				ей значения.
				> Таким образом, переменные в JS не имеют типа (untyped).

			> В JS есть автоматическая конвертация типа
				> Это работает так. Если парсер ожидает в каком-то месте увидеть
					значение определенного типа, то любое подставленное туда значение
					будет приведено к ожидаемому типу.

			> Изменяемые и не изменяемые типы
				> Типы в JS можно разделить на:
					- Изменяемые (mutable)
					- Не изменяемые (immutable)
				> Все простые типы в JS не изменяемые.
				> Объектные типы - изменяемые.
					> Например:

						obj.name='Henry';
						array[1] = 123456;

				> Можно подумать, что раз строка - это ни что иное, как массив
					символов, то она является изменяемой. Но это не так. Нельзя,
					например, сделать вот так (это не сработает):

						var str = 'абвгд';
						str[2] = 'й';

		> Числа
			Почему простые значения в JS могут вести себя, как объекты.

			> Целые числа, и числа с плавающей запятой. Точность вычислений.
				> В JS типо number представлены и целые числа, и числа с плавающей
					запятой.
				> Целое - число, у которого нет дробной составляющей.
					> С целыми числами можно проводить абсолютно точные операции.
					> Тут есть 1 оговорка - очень большие целые числа JS приводит
						к вещественным, что влечет за собой потерю точности. Это числа
						порядка 10^15 и более.
						> Например:

							Точная операция:
								console.log(1000000000000008 + 1000000000000001);    | 2000000000000009

							Неточная операция:
								console.log(10000000000000008 + 10000000000000001);  | 20000000000000010

				> Число с плавающей запятой (точкой) - любое число, у которого
				  есть дробная составляющая, или число в 16-ричной или 8-ричной
				  счистеме счисления.
				  > Вычисления с дробными числами не являются точными, и их нельзя
				  	использовать там, где требуется точность, например при подсчете
				  	денег.
				  > Для проведения точных вычислений с числами с плавающей запятой,
				  	их сначала надо привести к целым, провести операцию, а затем
				  	привести обратно. Например:

				  		Неточная операция:
				  			console.log(0.1 + 0.2);            | 0.30000000000000004

				  		Точная операция:
				  			console.log((0.1*10 + 0.2*10)/10); | 0.3

			> Все числа в языке JS относятся к типу number.
			> Тим number позволяет оперировать числами в диапазоне:
					[-2^53 .. 2^53]
					[-9,007,199,254,740,992 .. 9,007,199,254,740,992]
				> Вне этого диапазона для целых чисел операции будут проходить
					с потерей точности.
			> Для некоторых операций, например, для побитовых, числа сначала
				преобразуются в 32-битный целый тип (из 64-битного)
				> Поэтому можно использовать оператор побитового сдвига для
					возведения числа 2 в степень (но это медленнее, чем pow() ).

			> Системы счисления
				> JS поддерживает следующие системы счисления:
					> 10-ричная

						console.log(5);
						console.log(-10);
						console.log(300000);

					> 16-ричная (первый символ: 0x или 0X)

						console.log(0xfffcc);   | 1048524
						console.log(0xbbbccc);  | 12303564

					> 8-ричная (первый символ: 0)
						> Если цифра будет начинаться с 0, но содержать цифры > 7,
						  недопустимые в 8-ричной системе, то такое число парсер будет
						  автоматически считать десятичным

						console.log(0345);			| 229
						console.log(03458);     | 3458 - десятичное

			> Вещественные числа записываются так (0 перед точкой можно опускать):

					Обычная запись:
						console.log(12.45);
						console.log(104.67);
						console.log(0.77);
						console.log(.77);

					Экспоненциальная запись:
						console.log(5.2e2);  | 5.2 * 10^2 = 520
						console.log(6E3);	   | 6 * 10^3   = 6000
						console.log(.2e2);   | 0.2 * 10^2 = 20
						console.log(.2e-3);  | 0.2 * 10^-3 = 0.0002

			> Об объекте-обертке Number
				> В языке JS есть т.н. объекты-обертки (Wrapper Objects) для простых
					типов.
				> Эти объекты предоставляют более широкие возможности для работы с
				  простыми типами.
				> Для числовых типов есть объект-обертка Number.
				> Чтобы создать такой объект, требуется использовать конструктор.
					Чтобы создать объект Number, требуется использоват конструктор.
				> Конструктор - это функция, которая создает новые объекты.
					Идентификатор конструктора принято писать с большой буквы.
				> Создадим новый объект-обертку с помощью конструктора Number:

						var N = new Number(4000);
						console.log(typeof N);    | 'object'

					А если бы мы создали это число без функции обертки, то его тип
					был бы 'number':

						var N = 5000;
						console.log(typeof N);    | 'number'

				> Для числа в объекте-обертке становятся доступны его методы.
					Например:

						console.log(N.toFixed(2)); | 4000.00

				> Однако JS устроен так, что методы объекта-обертки Number доступны
					не только для чисел, находящихся в объекте-обертке, но и для
					переменных, содеражщих числовой литерал, и просто для числовых
					литералов в коде:

						console.log(n.toFixed(2));    | 5000.00
						console.log(2 .toFixed(2));   | 2.00

					> Это происходит потому, что при попытке получить доступ к этим
					  методам JS "на лету" создает для числового литерала объект-обертку
					  Number.
					  > Процесс выглядит так: интерпретатор берет значение переменной,
					   	создает объект Number с этим значением, затем вызывает метод
					   	toFixed с этим значением, и значение, которое возвращает этот
					   	метод и будет значением нашего экспрешена. А сам объект Number
					   	автоматически уничтожается в конце процесса.
					  > Именно поэтому простые значения могут вести себя, как объекты,
					    а вовсе не потому, что простых значений в JS нет, и все является
					    объектами.

					> В выражении выше после цифры 2 стоит пробел. Если пробел убрать,
						то интерпретатор подумет, что это вещественное число, и после
						точки должа идти цифра. А т.к. там идет буква, то будет ошибка:

						console.log(2.toFixed(2));   | ошибка!

				> Зная о том, что простые типы могут вести себя как объекты, как описано
					выше, явно использовать объекты-обертки потребуется довольно редко.

			> Бесконечность
				> Очень большое число интерпретатор JS воспримет, как бесконечность.
				> Существует +бесконечность и -бесконечность.
				> Для бесконечности у JS есть специальные обозначения:
					- Infinity
					- -Infinity
				> В JS есть глобальные переменная Infinity и -Infinity, которые
					хранят соответствующее значения. Поэтому если записать Infinity
					в парсер, то мы увидим, что это идентификатор:

					Infinity
					----------

            "type": "ExpressionStatement",
            "expression": {
                "type": "Identifier",
                "name": "Infinity"
            }


				> Бесконечность - это числовой литерал - имеет тип number:

						console.log( typeof Infinity);  | 'number'

				> Примеры бесконечности:

						console.log(1e308);   | 1e+308
						console.log(1e309);   | Infinity

						console.log(-1e308);  | -1e+308
						console.log(-1e309);  | -Infinity

				> В арифметических операциях бесконечность ведет себе в соответствии
					с математическими правилами:

						console.log(Infinity + 10);  | Infinity
						console.log(-Infinity * 5);  | Infinity

				> Деление на 0 не вызывает в JS ошибки, и возвращает Infinity, или
				  -Infinity, если на 0 делится отрицательное число:

				  	console.log(1/0);   | Infinity
				  	console.log(-1/0);  | -Infinity

			> NaN
				> Значение NaN обычно возвращается тогда, когда мы делаем что-то,
					чего в обычной математике делать нельзя.
				> В JS есть глобальная переменная NaN, которая хранит соответствующее
					значение. Поэтому если записать NaN в парсер, то мы увидим, что
					это идентификатор:

					NaN
					----------

            "type": "ExpressionStatement",
            "expression": {
                "type": "Identifier",
                "name": "NaN"
            }

				> Проверка NaN на равенство всегда возвращает false, даже при
					сравлении с самим собой.

						console.log(NaN === NaN);  | false

				> Примеры NaN:

						console.log(0/0);                | NaN
						console.log(Infinity/Infinity);  | NaN
						console.log(Math.sqrt(-10));     | NaN

			> Underflow
				> Если результат армфметической операции ближе к 0, чем наименьшее
					допустимое число в JS, то результатом будет 0.
				> В английском языке для описания этой ситуации есть хорошее слово
					Underflow.
				> Например:

					console.log(1e-323);  | 1e-323
					console.log(1e-324);  | 0


		> Строки
			> Строковые литералы записываются в "" или '' кавычках.
				Например:

					console.log('Иван');
					console.log('Петр');

			> Можно использовать любые кавычки, разницы нет.
				> Но есть 1 исключение
					>	Использование кавычек внутри строкового
						литерала - в этом случае внутри литерала нельзя использовать
						тот же вид кавычек, в который обернут сам литерал. Например:

							Это вызовет ошибку, потому что интерпретатор подумает, что
							кавычка перед long - это закрывающая кавычка литерала.

								console.log('Some 'long' string');   | ошибка!

					> Обойти это исключение можно 2-мя способами:
						- Экранированием (Escaping) кавычек внутри литерала:

								console.log('Some \'long\' string');  | Some 'long' string

						- Использованием кавычек другого вида:

								console.log('Some "long" string');    | Some "long" string

			> Строка - это последовательность символов, каждый из которых занимает
				2 байта.
			> В JS нет отдельного типа данных для хранения 1-го символа, как это
				есть, например, в языке C (тип char). Поэтому в JS для этой цели
				обычно используют строку длиной в 1 символ.
			> Длина строки вычисляется, как количество 2-байтовых символов,
				из которых она состоит.
				> Для получения длины строки можно использовать св-во length:

					console.log('Иванов'.length);  | 6

			> Строку можно записывать на нескольких строчках (в спецификации ES5).
				Для этого в конце каждой строчки надо ставить обратный слэш \ :

					console.log('Another \
					very long \
					string');

				> Но если скопировать код выше в консоль, будет шибка. Потому что
					в коде выше после 1-го и 2-го слешей идет много символов индентации,
					а их быть не должно.

			> Управляющие последовательности (некоторые)
				> \n - перенос строки.
					> Чтобы указанный выше перенос стал частью строки, необходимо заменить
						обратный слеш на управляющую последовательность \n :

							console.log('Another \nvery long \nstring');

				> \t - табуляция

							console.log('Another \n\tvery long \n\tstring');

				> \" и \'  -  символ кавычек в строке, как в примеер выше.

				> \\  -  обратный слэш в строке

			> Конкатенация
				> Конкатенация - сложение строк.
				> Оператор + обозначает конкатенацию в том случае, если одним из его
					операндов является строка.
				> Пример конкатенации:

						var str = 'Hello';
						console.log(str + ' world');   | Hello world

			> Объект-обертка String
				> Для работы со строкам у объекта-обертки String есть ряд методов,
				 	их полный список можно посмотреть в другом справочнике, или в
				 	соответствующем файле этого справочника. А тут рассмотрены
				 	несколько методов.
				> Строка - это неизменяемый тип в JS. Таким образом, все методы
					объекта String никак не изменяют исходную строку, а возвращают
					новую строку.
				> charAt(n) - возвращает символ с индексом n из строки:

						var str = 'Sometimes the same is different';
						console.log(str.charAt(0));  | "S"
						console.log(str.charAt(1));  | "o"
						console.log(str.charAt(2));  | "m"
						console.log(str.charAt(str.length - 1)); | "t" - последний символ в строке

						> В ES5 строки интерпретируются, как массивы, и поэтому вместо
							метода charAt для доступа к символу можно использовать вот
							такую запись:

							console.log(str[0]);  | "S"
							console.log(str[1]);  | "o"
							console.log(str[2]);  | "m"

				> substring(n,m) - возвращает подстроку с индексами от n до m

						console.log(str.substring(10));     | "the same is different"
						console.log(str.substring(10,21));  | "the same is"

				> slice(n) - возвращает подстроку, но может принимать отриц. арг.

						console.log(str.slice(-10));	| different

				> substr(n,length) - аналог substring, но с другими параметрами

						console.log(str.substr(14,4));  | same

				> indexOf(str) - поиск подстоки с начала строки

						console.log(str.indexOf('i'));   | 5
						console.log(str.indexOf('me'));  | 2

				> lastIndexOf(str) - поиск подстоки с конца строки

						console.log(str.lastIndexOf('i'));   | 23

				> relpace(str,str_for_r) - найти и заменить подстроку в строке

						console.log(str.replace('is','is not'));  | 'Sometimes the same is not different'

				> split(del) - разбивает строку на массив, используя разделитель del

						console.log(str.split(' '));  | ["Sometimes", "the", "same", "is", "different"]

				> toUpperCase() - привести строку к верхнему регистру
				> toLowerCase() - привести строку к нижнему регистру

						console.log(str.toUpperCase());  | 'SOMETIMES THE SAME IS DIFFERENT'
						console.log(str.toLowerCase());  | 'sometimes the same is different'


		> Логические значения
			> Логическое (Boolean) значение - это простой тип данных в javascript.
			> Может принимать 1 из 2 значений:
				- true
				- false
			> Обычно логическое значение является результатом операции
			  сравнения. Например:

			  	console.log(5 === 6);  | false
			  	console.log(5 === 5);  | true

			> Абсолютно любое значение в JS может быть преобразовано в значение
				логического типа с помощью конструктора Boolean. Например

					console.log(Boolean(5));  | true

				Причем значения true будут принимать все значения, кроме перечисленных
				ниже - они будут всегда false:

					console.log(Boolean(undefined));  | false
					console.log(Boolean(null));       | false
					console.log(Boolean(0));          | false
					console.log(Boolean(NaN));        | false
					console.log(Boolean(''));         | false

			> В тех местах, где интерпретатор JS ожидает получить логическое значение,
			  любое значение будет преобразовано к логическому. Например:

						var x = 10;
						if(x) {                   | здесь x преобразуется в true, и стейтмент выполняется
							console.log(x += 5);
						}

						var x = '';
						if(x) {                   | здесь '' преобразуется в false, и стейтмент НЕ выполняется
							console.log(x += 5);
						}

			> Логические операторы
				> &&   - логическое И (true, если оба операнда true)

						console.log(true && false);   | false
						console.log(true && true);    | true
						console.log(false && false);  | false

					> Еще одно применение оператора &&
						> В стейтменте:

								экспрешн && экспрешн;

						  правый экспрешен будет вычисляться только в том случае,
						  если левый экспрешн возвращает true, т.к. если левый false,
						  то значение правого уже вычислять излишне.
						> Это можно использовать следующим образом:

								isTrue && (a = 5)

							Т.Е. значение 5 будет присвоено переменной a, только если
							переменная isTrue возвращает true. Пример:

								var a = 0;
								var isTrue = 5;
								isTrue && (a = 10);
								console.log(a);			 | 10   - значение присвоилось

								var a = 0;
								var isTrue = 0;
								isTrue && (a = 20);
								console.log(a);      | 0   - значение не присвоилось


				> ||   - логическое ИЛИ (true, если хотя бы 1 из операндов true)

						console.log(true || false);  | true
						console.log(true || true);   | true
						console.log(false || false); | false

					> Еще одно применение оператора ||
						> В стейтменте:

								переменная = экспрешн || экспрешн;

							интерпретатор будет просматривать экспрешены слева направо,
							и первый экспрешн, который вернет true - и будет присвоен
							переменной.
						> Это можно использовать, например, для задания значений по
							умолчанию аргументам функции. Если аргумент не задан, то
							он получает значение по умолчанию. А если задан, то заданное
							значение:

									function args(a,b,c) {
											a = a || "a не задано";
											b = b || "b не задано";
											c = c || "c не задано";

											console.log(a + ', ' + b + ', ' + c);
									}
									args();        // a не задано, b не задано, c не задано
									args(2,3);     // 2, 3, c не задано
									args(2,3,4);   // 2, 3, 4


				> !   - логическое НЕ (унарный, инвертирует операнд)

						console.log(!true);   | false
						console.log(!false);  | true


		> Null и undefined
			> Оба этих типа данных обозначают отсутствие значения.
			> Null - это пустое значение
			> Undefined - полное отсутствие какого-либо значения.
			> Тип Null определяется, как object - это известная ошибка в
				javascript. Но ее не могут исправить, ведь если это сделает,
				большинство современных JS-библиотек перестанут нормально работать.

					console.log(typeof null);      | object

			> Тип undefined определяется, как undefined.

					console.log(typeof undefined); | undefined

			> Несколько ситуаций, в которых можно встретить undefined:

				Не инициализированная переменная
					var temp;
					console.log(temp);  | undefined

				Обращение к не существующему св-ву объекта
					var obj = {};
					console.log(obj.someProperty);  | undefined

				Обращение к не существующему элементу массива
					var a= [1,2,3,4];
					console.log(a[10]);  | undefined


				Не передача значений аргументов функции, где они ожидаются (они будут undefined):
					function greet(name) {
						return "Hello " + name;
					}
					greet('Sorax');    | "Hello Sorax"
					greet();           | "Hello undefined"

				Если функ-я не возвращает никакого значения, то возвращаемое значение - undefined

						function greet(name) {}
						greet();                  | undefined

			> Сравнение null и undefined

					console.log(null == undefined);   | true
					console.log(null === undefined);  | false

			> Что если вызвать функцию в контексте null: f.call(null)

					function f() {
						console.log(this);
					}

					f.call(null);         | Window (или error если включен 'use strict')

		> Преобразования типов
			> Автоматическое преобразование типов
				> В языке javascript есть автоматическая конвертация типов - если
					интерпретатор ожидает увидеть в каком-то месте программы значение
					определенного типа, то любое значение будет автоматически приведено
					к этому типу.
				> Если 1 из операндов в операции сложения является строкой, то другой
					тоже преобразуется в строку:

						console.log(5 + '5');            | '55'
						console.log(typeof(5 + '5'));    | 'string'

				> Оператор умножения будет пытаться преобразовать любые значения в
					числа:

						console.log('5' * '4');          | 20
						console.log(typeof('5' * '4'));  | number

					А если такое преобразование выполнить невозможно, то мы получим
					число NaN:

						console.log('5' * 'Ivan');  | NaN

				> Автоматическое приведение происходит и при использовании оператора
					не строгого сравнения == (при строгом сравнении === автоматического
					приведения не происходит)
					> Типы приводятся по принципу: привести все операнды к числу.
						Кроме случая, когда все операнды - строки. В этом случае происходит
						их побуквенное сравнение.
					> Поведение null и undefined особым образом отдельно прописано в
						стандарте ECMA script:
						 > null и undefined равны себе, между собой, и не равны больше ничему.
							 > Отсюда получается парадокс, что:
								 > null >= 0     | true
								 > null <= 0     | true
								 > null == 0     | false  (парадокс)
					> Примеры:

							console.log('5' == 5);            | true
							console.log('0' == false);        | true
							console.log('0' == true);         | false
							console.log(0 == false);          | true
							console.log('5' == true);         | false
							console.log('' == false);         | true

							console.log(null == false);       | false
							console.log(null == true);        | false
							console.log(undefined == false);  | false
							console.log(undefined == true);   | false
							console.log(undefined == null);   | true

					> Замечение по поводу операторов == (не строгое сравнение) и === (
						строгое сравнение).
						> В своих скриптах рекомендуется использовать только оператор === и
							соответствующие ему прочие операторы строгого сравнения, потому что
							при их использовании не происходит автоматического преобразования
							типов, что делает поведение скрипта более предсказуемым.

			> Явное преобразование типов
				> Для проведения явного преобразования типов мы будем использовать
					конструкторы соответствующих типов:
				> -> number

						console.log(Number('555'));          | 555
						console.log(typeof(Number('555')));  | number

						console.log(+'324');                 | 324
						console.log(typeof(+'324'));         | number

						console.log(parseInt('45'));         | 45
						console.log(typeof(parseInt('45'))); | number

						console.log(parseInt('45 px'));      | 45
						console.log(parseInt('45 px', 10));  | 45 - 10-чная система счисления
						console.log(parseInt('ivan 45'));    | NaN

						console.log(parseFloat('45.432'));          | 45.432
						console.log(typeof(parseFloat('45.432')));  | number

						console.log(parseFloat('45.432 px'));       | 45.432
						console.log(parseFloat('ivan 45.432'));     | NaN

						console.log(+'45 ivan');                    | NaN

						console.log(+'');                    | 0

						console.log(+true);                  | 1
						console.log(+false);                 | 0

				> -> string

						console.log(String(444));            | '444'
						console.log(typeof(String(444)));    | string

						console.log(789 + '');               | '789'
						console.log(typeof(789 + ''));       | string

						var num = 765;
						console.log(num.toString());         | '765'
						console.log(typeof (num.toString()));| string

						console.log(num.toString(16));       | '2fd' - в 16-ричной системе счисления
						console.log(typeof (num.toString()));| string

						console.log(typeof false.toString());| string

						console.log(String(Infinity));       | 'Infinity'
						console.log(typeof String(Infinity));| string

						console.log(String(NaN));      			 | 'NaN'
						console.log(typeof String(NaN));     | string

				> -> boolean

						console.log(Boolean(1));             | true
						console.log(typeof(Boolean(1)));     | boolean

						console.log(!!5);                    | true
						console.log(typeof(!!5));            | boolean

						console.log(!!'');                   | false
						console.log(!!NaN);                  | false
						console.log(!!0);                    | false
						console.log(!!null);                 | false
						console.log(!!undefined);            | false

			> Преобразование простого типа в объект
				> Когда интерпретатор ожадает в каком-то месте программы получить
					объект, но получает значение простого типа, то он преобразует
					это значение в объект, используя объект-обертку этого типа:

						var n = 5;
						console.log(n.value);      | undefined

						n = 'hello';
						console.log(n.value);      | undefined

						n = null;
						console.log(n.value);      | ошибка! typeError

						n = undefined;
						console.log(n.value);      | ошибка! typeError


	> Условные стейтменты
		> if
			> Благодаря условному стейтменту if мы можем выполнить какой-нибудь
				экспрешен или блок экспрешенов только в случае истинности заданного
				условия.
			> Синтаксис:

					if(экспрешн)
						стейтмент
					else
						стейтмент

					if(экспрешн) {
						стейтмент;
						стейтмент;
						стейтмент;
					} else {
					  стейтмент;
					  стейтмент;
					  стейтмент;
					}

				> Хорошим стилем считается всегда прописывать фигурные скобки, даже
					если требуется выполнить только 1 стейтмент.
					> Потому что позже, когда понадобится добавить еще стейтмент в этот
						if, можно забыть, что скобки не стоят, и получить не то
						поведение, на которое рассчитывал.
					> Потому что часто позже требуется добавить еще стейтмент в этот if,
					  и всегд так лень прописывать эти фигурные скобки. Лучше уж прописывать
					  их всегда сразу.

			> В скобках может быть любой экспрешн, его результат будет приведен
				к логическому типу автоматически.
			> В случае, если условие в скобках оказалось false, можно выполнить
				другой блок стейтментов, который идет после ключевого слова
				else.
			> Примеры:

				if(true) console.log("It's true");     | "It's true'

				if(true) {
					console.log("It's true 1");
					console.log("It's true 2");
				}


				if(false) console.log("It's true");    | [не выполняется]

				if(false) {
					console.log("It's true");            | [не выполняется]
				} else {
					console.log("It's false");           | "It's false'
				}


				var n = 5;
				if(n < 3) {
					console.log('n < 3');
				} else if(n > 4) {
					console.log('n > 4');                | 'n > 4'
				} else {
					console.log('n не определено');
				}

		> Условный (тернарный) оператор (аналог стейтмента if):
			> Если выражение1 = true, то он возвращает выражение2.
				Если выражение1 = false, то он возвращает выражение3.
			> Синтаксис:

					выражение1 ? выражение2 : выражение3;

			> Примеры:

				Тернарный оператор в действии:
					var n = 5;
					var x = (n > 10) ? x = 20 : y = 30;
					console.log(x);												| 30  - потому что (n > 10) = false

				Тернарный оператор в тернарном оператор:

					var x = (n > 10) ? 20 :
						(n === 5) ? 30 : 40;
					console.log(x);												| 30

		> switch
			> Позволяет выполнять заданные стейтменты в зависимости от значения
				экспрешена в скобках.
			> Когда интерпретатор дойдет до такого case, значение экспрешена
				которого совпадает со значением экспрешена в круглых скобках,
				будет выполнен стейтмент после двоеточия.
			> В конце каждого стейтмента каждого case обычно ставят стейтмент break,
			 	иначе интерпретатор сначала выполнит стейтмент после двоеточия у
			 	того case, для которого совпали экспрешены, а затем выполнит все
				остальные стейтменты в switch, уже не сравнива экспрешены.
				> Хотя могут быть ситуации, когда потребуется специально не ставить
					где-то break's, если также поведение требуется.
				> Стейтмент break - стейтмент мгновенного выхода из цикла.
			> Может быть сколько угодно case.
			> Default - выполнится, если ни одно значение экспрешенов из всех
				case не совпадет с экспрешеном в круглых скобках после switch.
			> Синтаксис:

					switch(экспрешн) {
						case экспрешн: стейтмент; break;
						case экспрешн: стейтмент; break;
						case экспрешн: стейтмент; break;
						case экспрешн: стейтмент; break;
									...
						default: стейтмент
					}
			> Примеры:

				Break's не поставлены. Интерпретатор выполняет экспрешен для
				case 'Sorax', потому что name='Sorax', а затем выполняет все
				оставльные.

					var name = 'Sorax';
					switch(name) {
						case 'John': homecity = "Boston";
						case 'Sorax': homecity = 'Belgorod';
						case 'Bill': homecity = 'LA';
					}
					console.log(homecity);        | 'LA' - потому что не поставил break'и

				Исправим ситуацию, расставив стейтменты break's:

					var name = 'Sorax';
					switch(name) {
						case 'John': homecity = "Boston"; break;
						case 'Sorax': homecity = 'Belgorod'; break;
						case 'Bill': homecity = 'LA'; break;
					}
					console.log(homecity);      | 'Belgorod'


	> Стейтменты - циклы
		> Нужны для многократного повторения заданных стейтментов в скрипте.
		> В javascript есть 4 вида циклов:
			- for
			- while
			- do .. while
			- for .. in
		> for
			> Синтаксис:

				Вообще синтаксис выглядит так:
					for(стейтмент1; экспрешн; стейтмент2) стейтмент4

				Чтобы было проще, запишем так:
					for(инициализация; тест; инкремент) тело цикла


				> Инициализация - переменной, которая будет служить счетчиком.
				> Тест - проверка значения переменное-счетчика.
					> Если true, выполнить еще раз тело цикла.
					> Если false - не выполнять, и сразу выйти из цикла (break).
					> Так как этот экспрешн будет вычисляться на каждом цикле, то
						чем проще это выражение, тем быстрее будет работать скрипт.
				> Инкремент - если "тест" вернул true, и было выполнено тело цикла,
					то выполнить "инкремент" - изменение переменной-счетчика. Например,
					прибавить к нему 1.

			> Итерация - это 1 выполнение тела цикла.
			> Операция декремента работает быстрее.
				> Поэтому лучше уменьшать счетчик от N до 0, чем увеличивать от
					0 до N.
			> Примеры:

					Можно везде написать пустые стейтменты:
						for(;;);      	| бесконечный цикл, который не делает ничего

					Бесконечный цикл:
						for(;;) 5+5;    | который бесконечно прибавляет 5 к 5

					Объявление с инициализацией:
						for(var i=0; i<10; i++) {
							console.log(i);         | | 0 .. 9
						}

					Объявление отдельно, инициализация отдельно:
						var i;
						for(i=0; i<10; i++) {
							console.log(i);       | 0 .. 9
						}

					Лучше уменьшать счетчик от N до 0 (так быстрее):
						var i;
						for(i=10; i--; ) {
							console.log(i);				| 9 .. 0
						}

			> while
				> Синтаксис:

						while(экспрешн) стейтмент

					> Интерпретатор ожидает, что экспрешн вернет значение логического
						типа. Если он вернет значение другого типа, то произойдет
						автоматическое приведение типов, как описано выше.
					> На каждой итерации проверяется экспрешн в скобках - если он
					 	возвращает true, то выполняется стейтмент. Если экспрешн
					 	возвращает false, то происходит выход из цикла.
					> Так как этот экспрешн будет вычисляться на каждом цикле, то
						чем проще это выражение, тем быстрее будет работать скрипт.
				> Примеры:

						var i = 10;
						while(i--) {
							console.log(i);      | 9 .. 0
						}

			> do ... while
				> Применяется редко.
				> В отличие от while, тут условие проверяется после тела цикла,
					а не до него.
					> Таким образом, тело цикла do ... while выполняется хотя бы
						1 раз не зависимо от у словия.
				> Синтаксис:

						do
							тело цикла
						while(экспрешн)

				> Примеры:

						var i = 0;
						do
							console.log(i++);     | 0 .. 9
						while(i < 10)

			> for ... in
				> С помощью цикла for ... in можно перебрать все свойства в
					объекте.
				> Цикл for ... in перебирает все свойства объекта, а также все
					свойства из его предков - по цепочке прототипов. Плюс, он перебирает
					только те свойства, у которых атрибут enumerable = true.
					Пример:

						var x = {
							name: 'John',
							age: 14
						};

						var newX = Object.create(x);

						newX.gender = 'male';

						for(var key in newX) {
							console.log(key);           | gender name age
						}

				> Порядок, в котором цикл for ... in будет пробегать свойства объекта,
					зависит от браузера:
					> Браузеры IE<=8, Safari:
						> Перебирают ключи в том же порядке, в котором свойства
							присваивались.
					> Браузеры Opera, IE>=9, Chrome, Firefox:
						> Если присутствуют свойства с числовыми ключями, перебирают
							их до свойств со строковыми ключами, в порядке возрастания.
						> Порядок строковых ключей сохраняют.
					> Пример (его можно попробовать запустить в разных браузерах):

							var obj = {
								name: 'ivan',
								1: 1,
								2: 2,
								age: 14
							};

							for(var key in obj) {
								console.log(key);  		| 1 2 name age    (chrome)
							}												| 1 2 name age    (Firefox)


	> Функции
		> FunctionDeclaration
			> Ниже описан стейтмент FunctionDeclaration.
			> Функция - это блок стейтментов (BlockStatement), который определяется
				1 раз, и может быть вызван сколько угодно раз с разными параметрами.
				> Поэтому, если в своем скрипте ты повторяешь одни и те же строчки
					кода более 1 раза, то это уже хороший повод вынести этот код в
					отдельную функцию.
			> Синтаксис:

					function идентификатор(аргументы) {
						стейтменты
						return экспрешн;
					}

			> Аргументы - это переменные, которые передаются в функцию.
				В JS нельзя выбрать, как передавать - по ссылке, или по значению,
				этот выбор происходит автоматически следующим образом:
				> Простые типы передаются по значению.
				> Объекты передаются по ссылке.
			> Функция может возвращать какое-нибудь значение (как экспрешн), для
				этого предусмотрено ключевое слово return.
				> В случае, если функция ничего явно не возвращает, то неявно она
					возвращает undefined.
			> FunctionDeclaration может быть определен в любом месте скрипта, и
				может быть вызван из любого места. Например, можно определить функцию
				в конце скрипта, а вызывать в начале.
			> Примеры:

					Функция конкатенации 2-х строк:

						function greet(name) {
							return "Hello " + name;
						}
						console.log(greet("Sorax"));    | "Hello Sorax"

		> FunctionExpression
			> Ниже описан стейтмент FunctionExpression.
			> FunctionExpression можно определить, если присвоить какой-нибудь
				переменной определение функции. В приведенном ниже примере представлен
				Named FunctionExpression, потому что он имеет имя.

					var greet = function greet(name) {
										    return "Hello " + name;
									    }

			> FunctionExpression может быть вызван только после своего определения,
				в отличие от FunctionDeclaration, который может быть вызван и до
				своего определения в любом месте скрипта.
			> FunctionExpression может быть вызван сразу после определения:

					Здесь переменной greeting присваивается значение функции, а не функция
						var greeting = (function(name) {
							return 'Hello ' + name;
						}('Sorax'));
						console.log(greeting);    	     | "Hello Sorax"

			> Имя Named FunctionExpression доступно только внутри этой функции (кроме IE <= 8):
				> Имя именованной FunctionExpression доступно только изнутри нее
					самой.
				> Это справедливо для всех браузеров, кроме IE <= 8. Там это имя доступно
					где угодно.

					var f = function g() { return 23; }
					console.log(typeof g());            | ReferenceError: g is not defined (в IE <= 8 будет 'function')


		> Анонимная функция:
			> При определении FunctionExpression можно пропустить идентификатор
				функции, потому что её идентификатором и так является идентификатор
				переменной, которой она присвоена. Такая функция называется анонимной.
			> Пример:

					var greet = function (name) {
										 		return "Hello " + name;
									    };

					*Примечание: поскольку теперь это выглядит, как объявление переменной
					             и её инициализация, то теперь в конце надо ставить ;
			> Функция, которая вызывается сразу после определения, называется
				анонимной самовызывающейся функцией:

					(function(name) {
						console.log('Привет, ' + name);
					}('Иван'));                            | 'Привет, Иван'

				> Ей можно дать имя, но самовызывающимся функциям нет никакого
					смысла давать имя, за исключением случая, когда нам требуется
					использовать рекурсию.


		> FunctionDeclaration и FunctionExpression - это разные вещи, и интерпретатор
			понимает их по разному.
		> Аргументы
			> Передача произвольного числа аргументов в функцию
				> В функцию можно передавать больше аргументов, чем было объявлено
					при её определении. Например:

						console.log(greet('Sorax',34));

					Первый аргумент получит внутри функции идентификатор name, а
					второй аргумент не получит никакого идентификатора - но доступ
					к нему все равно получить можно.
				> Для того, чтобы получить все переданные аргументы, внутри функции
					мы можем использовать объект arguments.
					> Он ведет себя, как массив, но это объект.
					> Примеры:

						var greet = function(name) {
							console.log(arguments);					| ["Sorax", 34, "Belogrod"]
							console.log(arguments.length);	| 3
							return "Hello " + name;					| "Hello Sorax"
						}
						greet("Sorax",34,'Belogrod');

			> Если передать в функцию меньшее число аргументов, чем передано при
				объявлении, то никакой ошибки не происходит. Просто все не инициализированные
				аргументы получают значение undefined.

						console.log(greet());   | Hello undefined

			> Поскольку функция в JS является объектом, то мы можем передавать функции
				в функции в качестве аргументов, а также возвращать функции из функции.
				> Эта особенность может быть использована для реализации т.н. callback'ов.
					Т.Е. передачи функции1 в функцию2, в которой функция 1 выполняется и
					производит какое-то действие.
				> Например:

						Callback-функци, передается в другую функцию в виде аргумента
							var func = function(сallback) {
								var name = 'Sorax';
								сallback(name);
							};
							func(function(n) {
								console.log('Hello ' + n);     | 'Hello Sorax'
							});

						Функция возвращает функцию, и мы тут же ее выполняем:
							var func = function() {
								return function() {
									console.log('hi');
								}
							};
							func()();                 | 'hi'


	> Область видимости (scope) переменной и цепочки областей видимости
		> Область видимости (scope) переменной - та часть программы, где эта
			переменная определена и доступна.
		> Область видимости бывает 2 видов:
			> Глобальная
			> Локальная
		> Глобальная область видимости
			> Переменная находится в глобальной области видимости, если она
				объявлена вне каких-либо функций.
		> Локальная область видимости
			> В JS только функции создают локальные области видимости.
				Поэтому...
			> Переменные, объявленные внутри функции, обладают локальной
				областью видимости, и их называют локальными.
			> Функции в JS могут быть вложенными друг в друга. Внутри функции,
				вложенной в функцию, может быть еще одна локальная переменная i.
		> Локальные переменные имеют бОльший приоритет, чем другие локальные
			переменные на мЕньшем уровне вложенности, или глобальные переменные:

				Приоритет локальной переменной над глобальной:
					var i = 5;
					var func = function() {
						var i = 10;
						console.log(i);
					};
					func();                   | 10

				Приоритет локальной переменной 1-го уровня вложенности над
					локальной переменной 2-го уровня вложенности и глобальной переменной

					var i = 5;
					var func = function() {
						var i = 10;
						var innerFunc = function() {
							var i = 15;
							console.log(i);
						}
						innerFunc();
					};
					func();                           | 15

		> Цепочки областей видимости
			> Вложенные функции создают т.н. цепочки областей видимости.
			> Когда в примере выше мы обращаемся внутри функции innerFunc к
				i, интерпретатор в первую очередь проверяет первую область видимости
				в цепочке, т.е. область видимости в функции innerFunc.
			> Если в этой О.В. не окажется переменной i, то интерпретатор попытается
				найти переменную в следующей области видимости цепочки, т.е. в
				О.В. FunctionExpression func.
				> Например:

						var i = 5;
						var func = function() {
							var i = 10;
							var innerFunc = function() {
								//var i = 15;
								console.log(i);
							}
							innerFunc();
						};
						func();                           | 10

			> var надо всегда писать при объявлении локальных переменных!
				> Если при объявлении глобальных переменных мы еще можем позволить
					себе не писать ключевое слово var при их определении, то при
					определении локальных переменных мы должны писать var, иначе
					мы рискуем вместо того, чтобы объявить новую переменную в данной
					области видимости, изменить значение переменной с таким же
					идентификатором в области видимости вверх по цепочке.
				> Например:

					Пример переопределения переменной из-за того, что не написали var:
						var i = 5;
						var func = function() {
							var i = 10;                   | значение этой i изменяется на 15
							var innerFunc = function() {
								i = 15;
								console.log(i);              | 15
							}
							innerFunc();
							console.log(i);                | 15 (а не 10)
						};
						func();

					Исправление ситуации (добавим var переменной i):
						var i = 5;
						var func = function() {
							var i = 10;
							var innerFunc = function() {
								var i = 15;
								console.log(i);             | 15
							}
							innerFunc();
							console.log(i);               | 10 (теперь все ок)
						};
						func();

			> Hoisting - подъем объявления переменных в начало области видимости
				> В JS всегда лучше объявлять переменные в начале функций, поскольку
					это будет лучше отражать суть происходящего. Потому что это в конце
					концов то, что интерпретатор сделает за тебя в любом случае.
				> Hoisting'ом называют явление, когда все объявления переменных
					неявно поднимаются интерпретатором в начало области видимости:

						Например, если написать так:

							var i = 10;
							var func = function() {
								console.log(i);         | undefined
								var i = 15;
							}

						То на самом деле интерпретатор увидит следующее:

							var i = 10;
							var func = function() {
								var i;                  | с этой переменной произошел Hoisting
								console.log(i);         | undefined
								i = 15;
							}


	> Замыкания
		> Лексическая область видимости
			> Lexical Scope. При выполнении функций в языке javascript используется
			 	та область видимости, которая существовала на момент объявления этой
			 	функции.
			> Например:

					var func = function() {
						var i = 10;
						return function() {
							return i;
						}
					};

					myFunc = func();

					var anotherFunc = function() {
						var i = 20;
						console.log(myFunc());				   | 10 (а не 20)
					};
					anotherFunc();

		> Замыкание - это функция и связанная с ней цепочка областей видимости.
			> С каждой функцией связана цепочка областей видимости, и функция вместе
				с этой цепочкой называется замыканием.
			> Строго говоря, каждую функцию можно назвать замыканием.
			> Это становится возможно благодаря тому, что:
			 	1 Когда интерпретатор выполняет какую-либо функцию, он создает
			 		объект, который будет содержать все локальные переменные этой
			 		фунцкии.
			 		> Например, при создании функции func из примера выше, создается
			 		  объект, содержащий локальную переменную i.
			 	2 И любые функции, определяемые внутри этой функции, сохраняют ссылку
			 		на этот объект.
			 		> Например, в примере выше, возвращаемая оператором return анонимная
			 		  функция сохранила ссылку на объект с локальными переменными функции
			 		  func.
			> Этот объект с локальными переменными будет существовать в памяти до
				тех пор, пока есть функции, которые на него ссылаются. Иначе - он
				будет автоматически удален из памяти (с помощью Garbage Collection).
		> 2 реализация счетчика: на замыканиях и на свойстве объекта

				Счетчик, который хранит текущий счет в замыкании
					var counter = (function() {
						var count = 0;
						return function() {
							return count++;
						}
					}());
					console.log(counter());   | 0
					console.log(counter());   | 1
					console.log(counter());   | 2

		> Замыкания позволяют реализовать что-то вроде инкапсуляции данных.
			В примере выше получить доступ к переменной count никак не возможно
			извне. Т.Е. её можно считать приватной.
		> Можно усовершенствовать счетчик:

				Счетчик, значение которого можно изменить, передав ему аргумент:
					var counter = (function() {
						var count = 0;
						return function(num) {
							count = num !== undefined ? num : count;
							return count++;
						}
					}());
					console.log(counter());   										| 0
					console.log(counter());   										| 1
					console.log(counter());   										| 2
					console.log(counter(50));   									| 50
					console.log(counter());   										| 51

		> Однако замыкания - не единственный способ добитсья такого поведения.
			Поскольку функция является объектом, мы можем добавить её свойство
			count, и внутри функции изменять это свойство:

				var counter = function(num) {
					counter.count = num !== undefined ? num : counter.count;
					return counter.count++;
				}

				counter.count = 0;

				console.log(counter());   																	| 0
				console.log(counter());   																	| 1
				console.log(counter());   																	| 2
				console.log(counter(50));   																| 50
				console.log(counter());   																	| 51


	> Обработка исключений - стейтменты throw и try/catch/finally
		> Для чего это нужно:
			> Часто JS скрипты работают с какими-то внешними данными. Так
				происходит в большинстве JS-скриптов. Например, они могут
				обрабатывать данные, вводимые пользователем с помощью мыши,
				клавиатуры, гироскопа, камеры и других устройств ввода.
			> Кроме того, программы могут получать данные из файловой системы,
				или из сторонних сервисов черех их API.
			> Во всех этих случаях могут возникать ситуации, когда ты не можешь
				знать точно, какие данные ты получишь. И во всех этих случаях
				требуется иметь возможность обрабатывать исключения.
		> Исключения интерпретатора
			> С точки зрения интерпретатора тот код, который ты пишешь, является
				внешними данными. И по отношению к интерпретатору JS можно сказать,
				что мы являемся пользователями, поскольку мы используем его возможности
				для выполнения скриптов, которые мы пишем. И поскольку в исходном
				коде мы можем писть что угодно, что взбредет нам в голову, интерпретатор
				должен уметь как-то реагировать на эти вещи, то есть генерировать
				исключительные ситуации.
			> Например:

					Напишем неправильное выражение:
						10 = 'string';  | ReferenceError: Invalid left-hand side in assignment

			> ReferenceError - это на самом деле объект - один из дочерних объектов
				объекта Error
		> Создание объектов-ошибок вручную
			> Объекты, подобные ReferenceError, мы можем создавать вручную.
			> Для разных типов ошибок есть свой конструктор. Например, SyntaxError,
				ReferenceError, и т.д.
			> Примеры:

				Создать объект-ошибку
					var myError = new Error('My Error Message');

				Так можно получить сообщение объекта-ошибки
					console.log(myError.message);                 | "My Error Message"

				Так можно получить имя конструктора объекта-ошибки:
					console.log(myError.name);										| 'Error'

		> throw
			> Любую ошибку мы можем выбросить с помощью оператора throw,
				и затем ловить её где-то дальше в коде.
			> Когда интерпретатор увидит стейтмент throw, он будет искать ближайший
			 	обработчик для него в стеке вызовов.
			 	> Это значит, что сначала интерпретатор просматривает в поисках catch
			 		ту область видимости, в которой возник throw. Если не находит, то
			 		смотрит в следующей по цепочке области в видимости. И так далее.
			 	> И в том случае, если ни в одной области видимости интерпретатро
			 		не нашел catch, то выполнение скрипта прекратится, а интерпретатро
			 		вернет сообщение об ошибке, которое об этом и говорит:
			 		"Uncaught Error: ..."
			 	> Uncaught Error - означает, что в стеке вызовов небыло встречено ни
			 		одного блока catch.
			> Выбрасывать исключения стоит только в каких-то крайних случаях, когда
				на правильности каких-то данных держится вообще весь смысл выполнения
				вашего скрипта.
				> В большинстве случаев можно обойтись без исключений. И это то, что
					делает большинство всех стандартных методов в языке javascript.
					> Например, если метод indexOf не сможет найти подстроку в строке,
						он не будет бросать ошибку, а просто вернет -1.
			> Пример:

					throw myError;

		> Пример создания исключения.
			> Допустим у нас есть функция с аргументом n. Мы хотим, чтобы он был
				не больше 10. Если n > 10, то мы не хотим дальше выполнять функцию,
				и кидаем исключение. Если же n <= 10, то продолжаем выполнять функцию:

					var calculate = function(n) {
						if(n > 10) throw new Error('n should be less than 10');
						return n + 10;
					}
					calculate(20);

		> Как поймать и обработать исключения с помощью стейтмента try/catch/finally
			> Синтаксис try/catch/finally:

					try {
						стейтменты
					} catch (идентификатор) {
						стейтменты
					} finally {
						стейтменты
					}

				> Здесь фигурные скобки являются частью стейтмента, и они всегда
					обязательны.
				> Блок catch и блок finally могут отсутствовать, но не одновременно.
				> В блок try мы должны поместить стейтменты, которые могут бросить
					исключения.
				> В блоке catch мы ловим эти исключения - туда мы помещаем стейтменты,
					которые будут выполняться только, если в блоке try произошло какое-то
					исключение.
					> При этом в него передается экспрешн, который был в инструкции throw.
						И для него в скобках мы можем прописать любое имя (идентификатор в
						синтаксисе). Обычно просто сокращают до 1 буквы:

							.. catch(e) ...
				> В блок finally мы помещаем стейтменты, которые будут выполнятсья не
				  зависимо от того, произошли какие-то исключения в блоке try, или нет.
			> Примеры:

					В этом случае в случае возникновения исключения скрипт не будет выполнятсья дальше
						try {
							calculate(20);
						} catch(e) {

						}

					...а в этом случае будет
						try {
							calculate(20);
						} catch(e) {
							console.log("Can't execute calculate: " + e.message);  | 'Can't execute calculate: calculate is not defined'
						}


	> Объекты
		> Базовая информация
			> Объект - это набор свойств, которые представляют собой пары
				имя-значение. Свойства объекта также иногда называют их полями.
				Имя отделено от значения двоеточием. В объекте может быть сколько
				угодно таких пар.
				> В других языках аналогами объектов могут быть ассоциативные массивы,
					или словари.
			> 3 способа создания объекта:
				- С помощью объектного литерала.
				- С помощью функции-конструктора и оператора new.
				- С помощью статического метода Object.create()

				> Создание объекта с помощью объектного литерала
					> Литерал - 1 из способов создания объекта.
						Пример объектного литерала (ObjectExpression в парсере):

							Объектный литерал:
								{
									name: 'Sorax',
									age: 20,
									gender: 'male'
								}
					> При создании объекта с помощью объектного литерала все ключи
						приводятся к строке. Поэтому в примере ниже свойство 1: 1
						перезаписывает свойство "1": 0:

							var obj = {'1': 0, 1: 1, 0: 2};
							console.log(obj['1']);					| 1

				> Создание объекта с помощью функции-конструктора и оператора new
					> Раньше, до появления способа с объектным литералом, использовали
						следующий метод создания объектов. Сначала создавали объект с
						помощью конструктора Object(). И затем на него вешали свойства:

							var object = new Object();
							object.property = 'value';

					> Но с объектным литералом это делать проще - синтаксис получается
						короче.

				> Создание объекта с помощью статического метода Object.create()
					> Он принимает 1-м параметром объект, который будет являться
						прототипом.

							Если мы не хотим, чтобы объект наследовал какие-то свойства,
							то можно передать null:

								var object = Object.create(null);
								console.log(object);

							К можно передать какой-то объект:

								var object = Object.create({x: 10, y:20});
								console.log(object);


			> Экспрешен обращения - для обращения к свойствам объекта
				> Можно присвоить этот объект переменной, и обращаться через нее к
					отдельным свойствам этого объекта.

					Объектный литерал, присвоенный переменной:
						var man = {
							name: 'Sorax',
							age: 20,
							gender: 'male'
						}

				> Для обращения к полям объектов используют выражение, которое
					так и называется, экспрешен обращения - Property Access Expression -
					(MemberExpression в парсере).
					> Оно имеет 2 синтаксиса в JS:

						1 синтаксис

							эксрешен.идентификатор;

							console.log(man.name);		| sorax
							console.log(man.gender);	| male

						2 синтаксис

							выражение[выражение]

							console.log(man['name']);
							console.log(man['gender']);

					> Используя 2-й синтаксис, можно изменять имя свойства динамически.
						Идентификатор же должен быть прописан в коде программы, иначе никак.

							var x = 'name';
							console.log(man[x]);	| Sorax

					> С помощью экспрешенов обращения можно изменять значения свойств
						объекта:

							man.age = 25;
							man['age'] = 25;
							console.log(man.age);

					> С помощью экспрешенов обращения можно добавлять новые свойства
						в объект на лету, во время выполнения скрипта, что возможно
						далеко не во всех языках.

							man.userID = 423423;
							console.log(man);

			> Методы
				> Значением любого свойства объекта может быть функция. В этом
					случае такое свойство называют методом.
				> Поскольку в JS функции являются объектами, самоя понятие метод
					является условным. Поскольку чисто технически в JS нет никакой
					разницы между обычными свойствами и методами, в отличие от
					некоторых других языков, в которых эта разница есть. Возможно,
					будет правильным сказать, что в JS нет методов, мы просто делаем
					функции значениями некоторых свойств.

			> Оператор delete - удаление свойств объектов.
				> Оператор delete может удалить только родные - не наследованные -
					свойства объекта.
					> Наследованные свойства можно удалить только напрямую у прототипа,
						которому они принадлежат.
				> Синтаксис:

						delete экспрешен

				> Пример:

						var obj = {
							x: 10,
							y: 20
						}
						delete obj.x;
						console.log(obj);		| {y: 20}

			> Оператор IN - проверка наличия свойства в объекте:
				> Оператор in не различает родные и наследованные свойства.
				> Чтобы выяснить, является ли это свойство родным у объекта,
					требуется использовать метод hasOwnProperty()

					console.log('x' in obj);  | false
					console.log('y' in obj);	| true

				> Часто вместо оператора in просто с помощью экспрешена обращения
					получают свойство, и смотрят что там - если undefined, значит
					свойства нет, иначе - свойство есть.
					> Однако, оператор IN в отличие от этого способа, различает
						отсутствующие свойства и свойства, которым присвоено значение
						undefined.
					> Так что лучше пользоваться оператором in.
					> Пример:

								console.log(obj.z);        | undefined
								console.log('z' in obj);	 | false

								obj.z = undefined;
								console.log(obj.z);				 | undefined
								console.log('z' in obj);	 | true

		> Ключевое слово this и родные методы функций bind,call,apply
			> Ключевое слово this указывает на объект, в контексте которого
				оно применено
			> Ключевое слово this, вызванное в глобальном контексте (скажем,
			  в браузере), указывает на глобальный объект - window.
			> Примеры:

					Как в примере ниже делать не удобно, потому что:
						> В методе greet жестко прописано имя объекта. Если потребуется
							применить этот метод к другому объекту - не получится - придется
							изменять имя объекта для обращения к каждому объекту с отличающимся
							именем. Мало того, имени у объекта вообще может не быть.

						var person = {
							name: 'John',
							greet: function() {
								return 'Hi! My name is ' + person.name;
							}
						}
						console.log(person.greet());	            	| 'Hi! My name is John'

					А лучше использовать ключевое слово this:

						var person = {
							name: 'John',
							greet: function() {
								return 'Hi! My name is ' + this.name;
							}
						}
						console.log(person.greet());	            	| 'Hi! My name is John'

					Поскольку функции в JS - объекты - можно объявить эту функцию
					где угодно, а внутри объекта оставить на нее ссылку:

						var greet = function() {
								return 'Hi! My name is ' + this.name;
						}
						var person = {
							name: 'John',
							greet: greet
						}
						console.log(person.greet());		           | 'Hi! My name is John'

					И можно создать другой объект, в котором можно в качестве
					метода greet использовать ту же самую функцию, которая будет
					запущена уже в контексте этого нового объекта, и вернет его
					name:

						var person = {
							name: 'Bob',
							greet: greet
						}
						console.log(person.greet());		           | 'Hi! My name is Bob'

			>

			> Метды call и apply:
				> Если при вызове функции требуется вручную указать объект, в
					контексте которого будет вызвана эта фуннкция, то можно
					воспользоваться родными методами функции call и apply.
				> Метод call делает то же самое, что и метод apply, только
				  в call аргументы функции передаются через запятую, а в
				  apply - в виде массива.
				> Примеры метода call:

						var greet = function() {
								return 'Hi! My name is ' + this.name;
						}

						var person = {
							name: 'John',
							greet: greet
						}

						var anotherPerson = {
							name: 'Bob',
							greet: greet
						}


					Вызов методов greet в контексте их объектов:

						console.log(person.greet());                | 'Hi! My name is John'
						console.log(anotherPerson.greet());         | 'Hi! My name is Bob'


					Вызов метода greet объекта person в контексте
					объекта anotherPerson:

						console.log(person.greet.call(anotherPerson));		  | 'Hi! My name is Bob'


					Вызов метода greet объекта anotherPerson в контексте
					объекта person:

						console.log(anotherPerson.greet.call(person));      | 'Hi! My name is John'


					Вызов функции greet в контекстах объектов person и anotherPerson:

						console.log(greet.call(person));				| 'Hi! My name is John'
						console.log(greet.call(anotherPerson));	| 'Hi! My name is Bob'


					Вызов функции greet в контекстах объектов person и anotherPerson,
					с передачей аргументов:

						console.log(greet.apply(person,1,2,3));			  | 'Hi! My name is John'
						console.log(greet.apply(anotherPerson,1,2,3));	| 'Hi! My name is Bob'


				> Примеры метода apply:

						var greet = function(arg1, arg2, arg3) {
								return 'Hi! My name is ' + this.name;
						}

					Вызов функции greet в контекстах объектов person и anotherPerson,
					с передачей аргументов:

						console.log(greet.apply(person, [1,2,3]));			  | 'Hi! My name is John'
						console.log(greet.apply(anotherPerson, [1,2,3]));	| 'Hi! My name is Bob'

			> Метод bind
				> В отличие от методов call и apply, он не вызывает функцию, а
					просто связывает ее с каким-то объектом. Чтобы при вызове этой
					функции ключевое слово this указывало на тот объект, с которым
					эта функция была связана.
				> Метод bind не изменяет исходную функцию, а возвращает новую
					функцию.
				> Примеры:

						var bound = greet.bind(anotherPerson);
						console.log(bound('Hello there'));			| 'Hi! My name is Bob'


		> Аксессоры - геттер, сеттер - и атрибуты свойств
			> Свойства-аксессоры
				> Свойства-аксессоры - это свойства для получения/изменения другого
					или других свойств объекта.
				> Свойства-аксессоры бывают:
					- Геттеры
					- Сеттеры
				> Для аксессоров в объектном литерале предусмотрен специальный
					синтаксис. Например, заменим обычное свойство age парой геттер-
					сеттер:

						var person = {
							get age(){},
							set age(){}
						};

				> Сеттер принимает значение, и внутри него можно что угодно делать
					с этим значением. Ниже пример работы сеттера и геттера, при этом
					в сеттере производится доп. проверка получаемого значения.

						var person = {
							personAge: 20,
							get age(){
								return this.personAge;
							},
							set age(value){
								this.personAge = value < 0 ? 0 :
									value > 122 ? 122 : value;
							}
						};
						person.age = 100;
						console.log(person.age);		| 100

						person.age = 180;
						console.log(person.age);		| 122


				> Примеры:

						В данном примере пара геттер-сеттер заменят обычное свойство age.
						При попытке получить св-во age будет вызвана функция get().
						При попытке назначить св-во age будет вызвана функция set().

							var person = {
								name: 'Sorax',
								sayHi: function() {
									console.log('Hi! My name is'+this.name);
								},
								get age(){                         					| функция-геттер
									return 'Hello from getter!';
								},
								set age(){}				                						 | функция-сеттер
							};
							console.log(person.age);          							 | 'Hello from getter!'


		> Дескриптор и атрибуты свойства
			> Каждое обычное свойство (вкл. методы) объекта имеет 4 атрибута:
				- value         | значение
				- writable      | (true по умолчинию) доступно ли для записи true/false
				- enumerable    | (true по умолчинию)
				- configurable  | (true по умолчинию)
			> Каждое свойство-аксессор объекта имеет 4 следующих атрибута:
				- get           |
				- set           |
				- enumerable    | (true по умолчинию)
				- configurable  | (true по умолчинию)
			> У аксессоров среди свойств нет атрибута writable, потому что доступность
				для записи определяется наличием или отсутствием сеттера.
			> Эти 4 атрибута можно получать и изменять с помощью объекта,
				который называется дескриптором свойства.
			> Object.getOwnPropertyDescriptor - получить дескриптор
				> Чтобы получить дескриптор, надо воспользоваться статическим методом
					Object.getOwnPropertyDescriptor(obj, propName)
				> Где:
					- obj       | объект
					- propName  | имя свойства
				> Получить дескрипторы свойств:

						console.log(Object.getOwnPropertyDescriptor(person,'name'));
							// Object {value: "Sorax", writable: true, enumerable: true, configurable: true}

						console.log(Object.getOwnPropertyDescriptor(person,'age'));
							// Object {get: function, set: function, enumerable: true, configurable: true}

						console.log(Object.getOwnPropertyDescriptor(person,'sayHi'));
							// Object {value: function, writable: true, enumerable: true, configurable: true}

			> Object.defineProperty - определить значения атрибутов свойства объекта
				> Для определения или переопределения значений атрибутов свойств
					можно использовать статический метод
					Object.defineProperty(объект, свойство, дескриптор)
				> Изменить значения атрибутов объекта person:

					var person = {
						gender: 'male',
						age: 20
					}

					Object.defineProperty(person, 'gender', {
						value: 'male',
						writable: false,
						enumerable: false,
						configurable: false
					});

			> Атрибут writable
				> Может принимать значения true/false.
				> Если true, то value свойства можно изменить. Иначе - нельзя.
				> Пример:

						console.log(person.gender);	 	| 'male'

						person.gender = 'female';     | попытка поменять
						console.log(person.gender);	  | 'male' (а не 'female')

			> Атрибут enumerable
				> Означает, будет ли видно это свойство при перечислении в цикле
					for .. in и при получении через метод keys().
				> Может принимать значения true/false.
				> Если true, то будет. Иначе - нет.
				> Для проверки значения атрибута enumerable есть специальный метод
					propertyIsEnumerable.
				> Пример:

						С помощью цикла for .. in:
							for(property in person) {
								console.log(property);   | age (св-ва gender нет)
							}

						С помощью статического метода Object.keys():
							console.log(Object.keys(person));  | age (св-ва gender нет)

						Тест propertyIsEnumerable
							console.log(person.propertyIsEnumerable('gender'));  | false

			> Атрибут configurable
				> Предназначен для определения возможности изменения атрибутов
					этого свойства.
				> Может принимать значения true/false
				> Если false, то нельзя будет изменить значение любого другого
					атрибута этого свойства, а также нельзя удалить само свойство.
					А если true, то все можно.

			> Object.defineProperties - определить значения атрибутов свойств
				> Object.defineProperties - тоже самое, что defineProperty, только
					позволяет настроить атрибуты не для 1 свойства, а для многих сразу.
				> Пример:

					var myObject = {};
					Object.defineProperties(myObject, {
						x: {
							value: 10,
							writable: false
						},
						y: {
							value: 20,
							writable: false
						},
						r: {
							get: function() {
								return Math.sqrt(this.x * this.x + this.y * this.y);
							}
						}
					});

					console.log(myObject.r);		| 22.360679774997898

					myObject.x = 50;  | не изменится, потому что writable = false
					console.log(myObject.r);		| 22.360679774997898

			> Расширяемость объектов
				> Расширяемость объектов - возможность добавления новых свойств.
				> Object.isExtensible - проверить, расширяем ли объект
					> Для проверки расширяемости объекта существует специальный метод
						Object.isExtensible(obj)
					> Пример:

						var obj = {};
						console.log(Object.isExtensible(obj));		| true

				> preventExtensions - запритить расширяемость объекта
					> Если пропустить объект через метод Object.preventExtensions(obj),
						то можно сделать объект не расширяемым.
					> Этот метод делает не расширяемым только сам объект. Если мы будем
						добавлять свойства к прототипу, то объект их успешно унаследует.
					> Например:

						var obj = {};
						Object.preventExtensions(obj);
						console.log(Object.isExtensible(obj));		| false

						obj.x = 10;
						console.log(obj.x);		| undefined - x не добавился

				> seal
					> Аналог preventExtensions, только дополнительно ставить значения
						configurable всех свойства объекта равным false.
					> Т.О. после применения этого метода, нельзя будет:
						- добавлять в объект новые свойства
						- удалять из объекта свойства
						- изменять значения атрибутов свойств
					> Для того, чтобы проверить, был ли применен этот метод, есть
						метод isSealed()
					> Пример:

						var obj = {};
						Object.seal(obj);
						Object.isSealed(obj);		| true

				> freeze
					> Делает тоже самое, что seal, но при этом еще делает атрибут
						всех свойств writable = false.
					> Метод isFrozen позволяет проверить, заморожен ли объект,
						или нет.


	> Прототипы и наследование
		> JS - прототипно-ориентированный язык программирования.
		> Наследование через прототипы
			> Это единственный тип наследования, который есть в JS.
			> Практически любой объект в JS имеет связанный с ним объект,
				называемый прототипом.
			> Объект наследует свойства свого прототипа. Т.Е. все свойства
				прототипа будут доступны через этот объект.

		> Наследование через __proto__
			> Так делать не нужно, этот пример просто для наглядности - чтобы
				легче было понять, что происходит.
			> В браузерах Chrome/Safari/Firefox/ свойство __proto__ доступно явно,
				в остальных - спрятано. Поэтому так и не надо делать, как показано
				в этом примере.
			> Пример:

					var object = {name: 'John'};
					var object2 = {age: 10};
					object2.__proto__ = object;
					console.log(object2.name);		// 'John'


		> Простой пример наследования:

				Создадим объект-прототип
					var objectProto = {
						name: 'Sorax'
					};

				Создадим другой объект, который будет наследником objectProto:
					var object = Object.create(objectProto);
					console.log(object.name);		            | 'Sorax'

		> Для чего все это нужно
			> Как делать НЕ надо
				> Допустим, нам в программе требуется иметь много однотипных
					объектов.
				> Тогда мы могли бы прописать каждый объект вручную:

						var person1 = {
							name: 'John',
							age: 35,
							gender: 'male',
							greet: function() {
								console.log('Hi, my name is'+this.name);
							}
						};
						var person2 = {
							name: 'Bob',
							age: 35,
							gender: 'male',
							greet: function() {
								console.log('Hi, my name is'+this.name);
							}
						};
						var person3 = {
							name: 'Ivor',
							age: 35,
							gender: 'male',
							greet: function() {
								console.log('Hi, my name is'+this.name);
							}
						};

			> Как делать НАДО
				> В коде выше в каждом из объектов пришлось создавать одни и
					те же свойства, повторяющие друг друга. А это увеличивает
					объем кода, и отнимает время.
				> Поэтому лучше создать один прототип для всех этих объектов,
					от которого они и будут наследовать часть свойств:

							var Person = {
								constructor: function(name,age,gender) {
									this.name = name;
									this.age = age;
									this.gender = gender;
									return this;
								},
								greet: function() {
									console.log('Hi, my name is'+this.name);
								}
							};

							var person1,person2,person3;

							person1 = Object.create(Person).constructor('John',35,'male');
							person2 = Object.create(Person).constructor('Bob',35,'male');
							person3 = Object.create(Person).constructor('Ivor',35,'male');

		> Класс в JS
			> Класс в JS - это условное понятие.
			> Класс в JS - это множество всех объектов, которые наследуют свои
				свойства от 1-го прототипа.

		> Метод isPrototypeOf - является ли объект А прототипом объекта Б
			> Пример:

					console.log(Person.isPrototypeOf(person1));		| true

		> Пример наследования в прототипном программировании через Object.create()
			> Наследование в прототипном программировании обычно подразумевает
				возможность создания дочерних классов, которые будут наследовать
				свойства и методы родительских классов.
			> Например, создадим класс 'WebDeveloper', объекты которого должны
				вести себя также, как объекты класса Person. Но при этом мы хотим
				также добавить некоторые свойства и методы, характерные только
				для веб девелоперов.

					var WebDeveloper = Object.create(Person);
					WebDeveloper.constructor = function(name,age,gender,skills) {
						Person.constructor.apply(this, arguments);
						this.skills = skills || [];
						return this;
					};

					WebDeveloper.develop = function() {
						console.log('working...');
					}

					var developer = Object.create(WebDeveloper).constructor('Jack', 21,
					'male', ['html', 'css', 'js', 'php', 'mysql']);

					console.log(developer.skills);			| ["html", "css", "js", "php", "mysql"]
					developer.develop();								| 'working...'
					console.log(developer.name);				| 'Jack'
					developer.greet();			| 'Hi, my name isJack'


	> Конструкторы и классы
		> О способах моделирования классов в JS
			> В JS есть 2 способа построения классов:
				- Новый - с помощью метода Object.create()
				- Старый - с помощью функций-конструкторов и ключевого слова new.
			> Новый способ был описан в разделе "Прототипы и наследование".
			> Старый способ - аналог нового способа, все здесь происходит с
				использованием тех-же механизмов, но есть отличия:
				- Применяется языковая абстракция - в виде функции-конструктора.
				- В объекте prototype, кроме пользовательских св-в и методов,
					содержатся свойства constructor и __proto__ (см. про них ниже),
					которые будет содержать новый объект этого класса, созданный
					спомощью ключевого слова new, помимо пользовательских св-в и методов.
			> Новый способ лучше тем, что позволяет легко организовывать многоуровневое
				наследование любой глубины.
		> Конструкторы
			> Конструктор - это функция, которая будучи вызвана с ключевым словом
				new возвращает новый объект.
			> Конструктор принято называть с большой буквы.
			> Внутри конструкторов ключевое слово this указывает на новый
				создаваемый объект.
				> При создании с помощью оператора new нового объекти из функции-
					конструктора, последняя неявно возвращает this.
				> Если в функция-конструктор с помощью оператора return будет
					возвращать любой другой объект, то позже, при создании с помощью
					оператора new нового объекта из этой функции-конструктора,
					этот объект получит не ссылку this (которую возвращает функция-
					конструктор по умолчанию), а ссылку на тот объект, что возвращает
					функция-конструктор оператором return. И в этом объекте не будет
					пользовательских св-в и методов из св-ва prototype функции-
					конструктора, а будут только св-ва и метода из того объекта, что
					вернула функция конструктор оператором return.
					> Пример 1:

							var F = function() {
								this.name = 'John';
								return {
									name: 'Irma'
								};
							};

							F.prototype.name = 'John';

							var obj = new F();
							console.log(obj.name);			// 'Irma'


			> Пример создания конструктора:

					Person = function(name) {
						this.name = name;
					}

			> Пример использования конструктора:

					var person = new Person('Jack');
					console.log(person.name);        	| 'Jack'

			> Функция-конструктор ничем не отличается от обычной функции
				> Любая функция в JS потенциально является конструктором.
				> Любую функцию в JS можно вызывать с ключевым словом new.
				> Для того, чтобы можно было отличать в коде конструкторы от
					обычных функций, их называют с большой буквы.


		> Prototype
			> Каждая функция в JS, в том числе и конструкторы, имеет свойство
				prototype, в котором хранится объект-прототип, от которого будут
				наследовать все объекты, создаваемые с помощью конструктора.
				> Св-во prototype есть только у функций. У объектов, например,
					его нет.
				> Зато свойства constructor и __proto__ есть у любого объекта.
			> В объекте prototype находится следующее:
				- Пользовательские свойства и методы.
				- Свойство constructor
				- Свойство __proto__
			> Пользовательские свойства и методы.
				> Изначально в объекте prototype нет пользовательских свойств
					и методов. Но их можно туда добавлять.
				> Например:

					Person = function(name) {
						this.name = name;
					}

					Person.prototype.greet = function() {
						console.log('Hello, my name is '+this.name);
					}

					var person = new Person('Jack');
					person.greet(); 																| 'Hello, my name is Jack'

			> constructor
				> Содержит ссылку на функцию-конструктор объекта, содержащего
					объект prototype.

			> __proto__
				> Содержит ссылку на объект в prototype класса-функции-родителя.
					> То есть при создании объекта-наследника, в его св-во __proto__
						записывается ссылка на объект из св-ва prototype его родителя.
				> Есть у любого объекта.
				> Через это свойство можно получить прототип класса любого
					объекта напрямую. Например:

						console.log(person.__proto__);

				> Это свойство поддерживается разными браузерами по-разному,
					поэтому в общем случае лучше никогда его не использовать.

		> Оператор instanceof - проверить, является ли объект X объектом класса Y
			> Это можно сделать 2-мя способами (они эквивалентны):
				> С помощью оператора instanceof
					> Оператор instanceof проверяет всю цепочку наследования, и если
						объект X содержит среди своих предков функцию-конструктор Y,
						то объект X считается объектом класса Y, и instanceof вернет true.
					> Например:

							console.log(person instanceof Person);		| true

				> С помощью метода isPrototypeOf
					> Например:

							console.log(Person.prototype.isPrototypeOf(person));  | true


		> Пример создания дочернего класса
			> Допустим, есть класс А. Надо создать его дочерний класс (а не объект) Б.
				Чтобы это сделать, надо:
				- создать новый объект, записать в его __proto__ ссылку на А.prototype,
					и затем записать ссылку на этот новый объект в свойство Б.prototype.
				- создать функцию-конструктор для класса Б, и положить ссылку на неё
					в Б.prototype.constructor, заменив лежащую там ссылку из свойства
					А.prototype.constructor

				Создадим функцию-конструктор Developer, родителем которой является
				функция-аконструктор Person:

						var Developer = function(name, skills) {
							Person.apply(this, arguments);
							this.skills = skills || [];
						};

				Теперь надо сделать так, чтобы Developer унаследовал все пользовательские
				св-ва и методы, находящиеся в prototype класса Person. Для этого
				надо создать новый объект, прототипом которого является Person.prototype,
				и поместить его в Developer.prototype:

						Developer.prototype = Object.create(Person.prototype);

				Но теперь свойство Developer.prototype.constructor указывает на Person,
				а не не Developer. Это надо исправить:

						Developer.prototype.constructor = Developer;

		> Пример использования дочернего класса:

				var developer = new Developer('John', ['ruby', 'ror', 'python']);
				console.log(developer.name);                                      | 'John'
				console.log(developer.skills);																		| '["ruby", "ror", "python"]'
				developer.greet();																								| 'Hello, my name is John'

			> Проверка на принадлежность объекта к классу с помощью instanceof:

					console.log(developer instanceof Developer);	| true
					console.log(developer instanceof Person);			| true

		> Методы toString() и valueOf()
			> Функция-конструктор Object() - это класс, который стоит на вершине
				иерархии всех классов в JS.
				> Другими словами, почти все объекты в JS наследуют свойства
					от объекта Object.prototype. В том числе и методы toString()
					и valueOf().
			> toString()
				> Когда объект требуется вывести в виде строки, то вызывается
					его метод toString(), и возвращается её результат в виде строки.
				> Этот метод можно переопределить у прототипа любого класса,
					что и делают многие классы в JS, изменяя таким образом поведение
					объектов этого класса при преобразовании в строку. Например:

						Person.prototype.toString = function() {
							return this.name;
						}

			> valueOf()
				> Когда объект требуется вывести в виде числа, то вызывается
					его метод valueOf(), и возвращается её результат в виде числа.
				> Этот метод можно переопределить у прототипа любого класса,
					что и делают многие классы в JS, изменяя таким образом поведение
					объектов этого класса при преобразовании в число. Например:

						Person.prototype.valueOf = function() {
							return 100;
						}

		> Определение класса объекта с помощью техники заимствования метода
			> Примеры:

				console.log(Object.prototype.toString.call({}));					| '[object Object]'
				console.log(Object.prototype.toString.call([]));					|	'[object Array]'
				console.log(Object.prototype.toString.call(/\w/));				|	'[object RegExp]'
				console.log(Object.prototype.toString.call(function(){}));|	'[object Function]'

				console.log(Object.prototype.toString.call('hi'));				|	'[object String]'
				console.log(Object.prototype.toString.call(12345));				|	'[object Number]'
				console.log(Object.prototype.toString.call(true));				|	'[object Boolean]'

			> Можно написать отдельную функцию, которая будет возвращать класс
				объекта:

					var classOf = function(object) {
						return Object.prototype.toString.call(object).slice(8,-1);
					}

					Тест:
						console.log(classOf(''));						| 'String'
						console.log(classOf([]));						| 'Array'
						console.log(classOf({}));						| 'Object'
						console.log(classOf(function(){}));	| 'Function'
						console.log(classOf(52422));				| 'Number'
						console.log(classOf(true));					| 'Boolean'
						console.log(classOf(/\d/));					| 'RegExp'


	> Цепные вызовы методов
		> Возможно создавать методы, которые можно вызывать по цепочке. Такие
			методы интенсивно используются в jQuery, что позволяет писать очень
			короткий и красивый код.
		> В JS есть родные методы, которые можно вызывать по цепочке. Например,
			это методы по работе со строками. В примере ниже каждый метод возвращает
			новую строку, и если нам не нужно сохранять промежуточные результаты, то
			мы можем просто вызывать методы по цепочке таким образом.

				var string, newString;
				string = 'Sometimes the same is different';

				newString = string
					.replace('is', 'is not')
					.concat(' actually')
					.toUpperCase()
					.replace(/ /g, '\n')
					.slice(10);

		> Аналогичный подход можно использовать и при работе с объектами.
			Допустим мы пишем движок для какой-то 2D игры.

			Нам нужен класс для работы с 2d-векторами:

				var Vec2 = function(x,y) {
					this.x = x;
					this.y = y;
					return this;
				};

			Для определения следующего положения объекта в пространстве, надо
			сложить его радиус-вектор с вектором скорости и вектором гравитации.
			Для этого напишем метод для сложения векторов, и мы хотим иметь
			возможность использовать этот метод в цепочке вызовов:

				Vec2.prototype.add = function(vec) {
					this.x += vec.y;
					this.y += vec.y;
					return this;
				}

			В объекте world мы будем хранить гравитацию:

				var world = {
					gravity: new Vec2(0,1)
				};

			Допустим, у нас есть некий объект:

				var object = {
					position: new Vec2(10,20),
					speed: new Vec2(1,3),
					update: function() {

						// Update object state - цепные вызовы метода
						this.position
							.add(this.speed)
							.add(world.gravity);

					}
				};

				console.log(object.position);		| Vec2 {x: 10, y: 20, add: function}
				console.log(object.update);
				console.log(object.position);		| Vec2 {x: 14, y: 24, add: function}


	> JSON
		> JSON - JS Object Notation.
		> Сериализация объекта - это его преобразование в строку.
		> Это нужно главным образом для удобства хранения и передачи информации.
			> Например, если требуется получать какие-то данные с сервера во время
				работы приложения, можно использовать для этого JSON или XML.
			> Или еще пример - можно хранить объекты в базе данных, предварительно
				преобразовав их в JSON строку. Или хранить эти строки локально,
				используя localStorage.
		> JSON представляет собой небольшое подмножество javascript.
			> Говоря точнее, в нем можно хранить:
				- Объекты
				- Массивы
				- Строки
				- Числа
				- true
				- false
				- null
			> Любые другие значения при сериализации преобразуются в null.
		> Для преобразования объекта в строку в JSON-формате в JS есть
			статический метод JSON.stringify:

				var user = {
					name: 'Frank',
					id: 43325
				};

				var userData = JSON.stringify(user);
				console.log(userData);								| {"name":"Frank","id":43325}
				console.log(typeof userData);         | string

		> Для того, чтобы получить из JSON-строки объект в JS есть статический
			метод JSON.parse:

				console.log(JSON.parse(userData));	|Object {name: "Frank", id: 43325}

		> Объекта JSON нет в старых браузерах, а точнее говоря в IE <= 7.
			> Поэтому, если нужна поддержка в старых IE, понадобится подключить
				к проекту отдельный скрипт, который можно скачать по адресу:
					http://bestiejs.github.io/json3/lib/json3.min.js

		> Когда метод stringify преобразует объект в строку, он первым делом
			ищет в объекте наличие метода toJSON.
			> Если метод toJSON отсутствует, то преобразование проходит стандартным
				способом, например:

				var user = {
					name: 'Frank',
					id: 43325,
					lastvisit: Date.now(),
					friends: [2344,4342,6443]
				};

				var userData = JSON.stringify(user);
				console.log(userData);							 | {"name":"Frank","id":43325,"lastvisit":1384268597968,"friends":[2344,4342,6443]}

			> Если метод toJSON присутствует, то в строку будет преобразовываться
				то, что возвращает метод toJSON. Т.О. если мы не хотим по каким-то
				причинам передавать id этого пользователя, и id его другей, то в
				методе toJSON мы може вернуть объект, не содержащий этих свойств:

				var user = {
					name: 'Frank',
					id: 43325,
					lastvisit: Date.now(),
					friends: [2344,4342,6443],
					toJSON: function() {
						return {
							name: 'Frank',
							lastvisit: Date.now()
						}
					}
				};

				var userData = JSON.stringify(user);
				console.log(userData);							 | {"name":"Frank","lastvisit":1384269156462}


	> Массивы в JS

		> Определение массива
			> Массив - упорядоченный набор элементов, каждый из которых имеет свой
				порядковый номер, который называется индексом.

		> Литерал массива
			> Литерал массива в JS выглядит так:

					var array = [1,3,4];

			> В литералах массивов можно пропускать элементы
				> Пропущенные элементы имеют значение undefined
				> Пример:

					var array3 = [,,,23];
					console.log(array3);	| [3: 23]

				> Такой массив (как в примере ниже) будет иметь длину не 3, а 2,
					поскольку в литералах массивов допускается лишняя запятая в конце:

						var array3 = [,,];
						console.log(array3.length);		| 2

			> Пустой литерал массива возвращает пустую строку в строковом
				контексте:

						console.log([] + 'John');         | 'John'

		> Индексы массива
			> Индексация элементов массива начинается с 0.
			> Индексы массивов - это практически тоже самое, что и имена свойств
				объектов. И также, как и имена свойств объектов, они хранятся в
				массиве в виде строк.
				> В примере ниже число 20 преобразуется в строку "20", и с этой
					строкой связывается значение "Something":

						var months = [];
						months[20] = 'Something';

				> Ничто не мешает использовать строки вместо индексов, как в
					примере ниже. И это работает также, как в обычных объектах.
					Однако, для этого есть объекты, так что смысла делать это с
					массивами особого нет.

						months['someProperty'] = 'someValue';

				> Индексы объектов - это не на 100% тоже самое, что имена свойств.
					> Индексами могут быть только не отрицательные целые числа.
					> При добавлении элемента с индексом, автоматически обновляется
						свойство length.
					> Это единственные отличия индексов от имен свойств, и это то,
						что делает массивы массивами. Поскольку во всем остальном
						можно обращаться с массивами также, как с обычными объектами.

		> Элементы массива
			> Элементами массивов могут быть значения абсолютно любых типов,
				как простых, так и объектных, в том числе объекты и массивы.
			> К элементам массива можно обращаться с помощью оператора []
				> Перед оператором может быть какое угодно кол-во пробелов.
				> Получение элемента:

					console.log(array[1]);     | 3
					console.log(array    [2]); | 4

				> Изменение элемента:

					array[1] = 30;
					console.log(array[1]);  | 30

				> Создание элемента:

					array[3] = 'John';
					console.log(array[3]);	| 'John'

			> Обращение к несуществующему элементу возвращает undefined:

					console.log(array[10]);		| undefined

		> Свойство length массива
			> У каждого массива есть свойство length, которое хранит индекс последнего
				элемента в массиве + 1.
				> Получить значение length:

						console.log(array.length);		| 4

				> Добавить элемент в конец массива можно таким образом:

						array[array.length] = 'Elma';
						console.log(array);						| [1, 30, 4, "John", "Elma"]

				> Не стоит использовать length для того, чтобы попытаться узнать
					количество элементов в массиве, поскольку индексация в массиве
					не обязана быть сквозной, и могут быть пропущенные индексы:

						var array = ['Jan','Feb','Mar'];
						array[20] = 'Apr';
						console.log(array.length);		   | 21

				> Если вручную присвоить свойству length массива какое-то значение,
					то все элементы с индексами большими, чем присвоенное значение,
					будут удалены из массива:

						var array4 = [0,1,2,3,4,5,6,7,8,9];
						array4.length = 4;
						console.log(array4);								| [0, 1, 2, 3]

		> Конструктор Array массива
			> Несмотря на наличие специального синтаксиса для литералов-массивов,
				массивы в JS являются объектами:

					console.log(typeof array);		| 'object'

			> Поэтому у массивов есть функция конструктор, которая называется Array,
				и мы также можем с её помощью создавать новые массивы.
				> При этом, аргументы, которые мы передаем в конструктор, будут
					элементами массива.
				> Но если передается только 1 аргумент, он станет длиной массива.
					Причем, никакого смысла в данном поведении нет, потому что массивы
					в JS бывают только динамические, и на самом деле в этот массив все
					еще можно добавлять большее число элементов, чем указано.

					var myArray = new Array();
					console.log(myArray);       | []

					var myArray = new Array(55,66,77,88);
					console.log(myArray);      							 | [55, 66, 77, 88]

					var myArray = new Array(25);
					console.log(myArray.length);						 | 25

		> "Удаление" элемента из массива оператором delete
			> Удаление элемента из массива оператором delete:
				> Не удаляет элемент, а присваивает ему значение undefined.
				> Не изменяет значение свойства length.
				> Пример:

						var array = [1,2,3,4,5];
						delete array[1];
						delete array[3];
						console.log(array);				| [1,undefined,3,undefined,5]

		> Array.isArray() - проверка типа значения на массив
			> Этот статический метод проверяет, является ли указанное значение
				типа Array.
			> Принцип работы этого метода тот же самый, какой описан в пункте
				"Определение класса объекта с помощью техники заимствования метода".
				Так что можно использовать любой на выбор.
			> Пример:

					console.log(Array.isArray(array));		| true
					console.log(Array.isArray('Hello'));  | false


		> Методы для работы с массивами из ES3-ES4
			> Общая информация
				> Некоторые методы по работе с массивами изменяют исходный массив,
					а некоторые возвращают новый массив.
			> join
				> Конкатенирует все элементы массива в 1 строку.
				> Разделитель по умолчанию - запятая.
				> Можно передать строку-аргумент, который станет разделителем.
				> Пример:

						var array = ['Some String',
												 'Another String',
												 'Third String'];

						console.log(array.join());			 | 'Some String,Another String,Third String'
						console.log(array.join(' || ')); | 'Some String || Another String || Third String'

			> reverse
				> Возвращает обратный массив.
				> При этом происходит изменения исходного массива.
				> Пример:

						console.log(array.reverse());		| ["Third String", "Another String", "Some String"]
						console.log(array);             | ["Third String", "Another String", "Some String"]

			> sort
				> Сортирует массив в алфавитном порядке.
				> Каждый элемент массива преобразуется в строку.
				> Может принимать функцию, которая определит другое поведение при сортировке.
				> Пример:

						console.log(array.sort());	| ["Another String", "Some String", "Third String"]

			> concat
				> Конкатенирует массив с другим массивом, или с какими-то другими
					элементами.
				> Этот метод не изменяет исходный массив, а возвращает новый массив.
				> Пример:

						console.log(array.concat('Hello', ['Even More', 'Strings']));		| ["Another String", "Some String", "Third String", "Hello", "Even More", "Strings"]

			> slice
				> Берет подмассив из элементов указанного массива.
				> Работает также, как метод slice у строк.
				> Принимает 2 аргумента, которые могут быть как +, так и -.
				> Не изменяет исходный массив.
				> Пример:

						console.log(array.slice(0));		| ["Some String", "Another String", "Third String"]
						console.log(array.slice(1));		| ["Another String", "Third String"]
						console.log(array.slice(2));		| ["Third String"]
						console.log(array.slice(-1));   | ["Third String"]

			> splice
				> Может использоватсья для одновременного удаления элементов
					из массива, и вставки элементов в массив.
				> Аргументы:
					1 Индекс элемента, с которого надо начать удаление.
					2 Кол-во элементов, которые надо удалить.
					3 Все последующие элементы это значения, которые надо вставить
						в то место, откуда мы удалили элемент.
				> Возвращает массив удаленных элементов.
				> Изменяет массив, у которого он вызывается
				> Пример:

						var array = ['Some String',
												 'Another String',
												 'Third String'];

						console.log(array.splice(1,1,'Sorax','WebDev'));	| ["Another String"]
						console.log(array);																| ["Some String", "Sorax", "WebDev", "Third String"]

			> push
				> Вставляет в конец массива 1 или нескольких элементов.
				> Изменяет исходный массив.
				> Пример:

						array.push('Javascript');
						console.log(array);					| ["Some String", "Sorax", "WebDev", "Third String", "Javascript"]

			> unshift
				> Вставляет в начало массива 1 или нескольких элементов.
				> Изменяет исходный массив.
				> Пример:

						array.unshift('Hello there!');
						console.log(array);							| ["Hello there!", "Some String", "Sorax", "WebDev", "Third String", "Javascript"]

			> pop
				> Удаляет последний элемент из массива, и возвращает его.
				> Не принимает никаких аргументов.
				> Изменяет исходный массив.
				> Пример:

						array.pop();
						array.pop();
						console.log(array);  | ["Hello there!", "Some String", "Sorax", "WebDev"]

			> shift
				> Удаляет первый элемент из массива, и возвращает его.
				> Не принимает никаких аргументов.
				> Изменяет исходный массив.
				> Пример:

						array.shift();
						console.log(array);  | ["Some String", "Sorax", "WebDev"]


		> Методы для работы с массивами из ECMAScript 5
			> Общая информация
				> Все методы в этом пункте не изменяют исходный массив. Они просто
					возвращают новый массив.
				> За исключением тех случаев, когда ты изменяешь массив в
					callback функции.

			> forEach
				> Возвращает массив из элементов, обработанных callback-функцией
				> Принимает в качестве аргумента callback-фукнкцию с 3-мя аргументами,
					которая будет применяться к каждому элементу массива.
				> 3 аргумента callback-функции:
					> element  | ссылка на элемент массива
					> index    | индекс этого элемента в массиве
					> array    | ссылка на сам массив
				> Пример:

						var array = ['Some String',
												 'Another String',
												 'Third String',
												 'JavaScript',
												 'Sorax'];

						Вывести значение каждого элемента в консоль
							array.forEach(function(element, index, array) {
								console.log(element);
							});

						Преобразовать все строки к верхнему регистру (изменит исходный массив)
							array.forEach(function(element, index, array) {
								array[index] = element.toUpperCase();
							});
							console.log(array);  														| ["SOME STRING", "ANOTHER STRING", "THIRD STRING", "JAVASCRIPT", "SORAX"]

			> map
				> Возвращает новый массив, каждый элемент которого формируется из
					значений, которые возвращаются из функции, которую мы передаем
					в качестве первого аргумента.
				> Преобразовать все строки к верхнему регистру (как в примере выше):

						console.log(array.map(function(e){ return e.toUpperCase()}));		| ["SOME STRING", "ANOTHER STRING", "THIRD STRING", "JAVASCRIPT", "SORAX"]

			> filter
				> Позволяет отсеить элементы из массива по какому-либо критерию.
				> Возвращает новый массив из элементов, отсеянных callback-функцией
				> Он принимает функцию, которая должна вернуть true/false для
					каждого элемента.
					> Если для элемента функция возвращает true, то он добавляется в
						массив, который возвращает функция filter.
					> А если false, то не добавляется.
				> Пример - попробуем отсеять все элементы в массиве, содержащие
					букву 'o':

						var array = ['Some String',
												 'Another String',
												 'Third String',
												 'JavaScript',
												 'Sorax'];

						var filtered = array.filter(function(e) {
							return e.indexOf('o') === -1;
						});
						console.log(filtered);                   	| ["Third String", "JavaScript"]

			> every
				> Вернет true, если для всех без исключения элементов будет выполнено
					условие, заданное в callback-функции, иначе false.
				> Возвращает true/false.
				> Пример - проверим, все ли строки в массиве имеют длину более 4 символов:

						console.log(array.every(function(e){return e.length > 4})); 	| true

					А теперь добавим в массив элемент из 2 символов и проверим снова:

						array.push('JS');
						console.log(array.every(function(e){return e.length > 4}));  | false

			> some
				> Вернет true, если хотя бы для 1 элемента будет выполнено условие, заданное в callback-функции, иначе false.
				> Возвращает true/false.
				> Вернет true, если в массиве есть хотя бы 1 элемент, для которого
					выполняется заданное условие. Иначе false.
				> Пример 1 - проверим, есть ли в массиве хотя бы 1 строка, содержащая
					букву 'z':

						console.log(array.some(function(e){return e.indexOf('z') !== -1}));  | false

				> Пример 2 - проверим, есть ли в массиве хотя бы 1 строка, содержащая
					букву 'x':

						console.log(array.some(function(e){return e.indexOf('x') !== -1}));	 | true

			> reduce
				> Возвращает результат цепного вызова callback-функции для всех элементов
					слева-направо.
				> Возвращает какое-то одно значение, которое получается в результате
					выполнения функции для каждого элемента массива с возможностью
					сохранения промежуточного результата. Другими словами, на каждой
					итерации, помимо того, что вы будете иметь ссылку на текущий
					элемент массива, в вашем распоряжении также будет переменная с
					промежуточным результатом, который сформировался в результате
					выполнения предыдущих итераций.
				> Аргументы:
					1 a - промежуточное значение на текущей итерации (результат
								операций на предыдущих итерациях)
					2 b - значение текущего элемента массива
					3 index - индекс текущего элемента
					4 array - ссылка на массив
				> Пример 1 - сложить все элементы массива

						var numbers = [1,2,3,4,5,6];
						var reduced = numbers.reduce(function(a,b,index,array){
							return a + b;
						});
						console.log(reduced);   																| 21

				> Пример 2 - перемножить только те элементы-числа в массиве,
					которые кратны 3:

						var reduced = numbers.reduce(function(a,b,index,array){
							return a * (b % 3 === 0 ? b : 1);
						});
						console.log(reduced);   																| 18

			> reduceRight
				> Возвращает результат цепного вызова callback-функции для всех элементов
					справа-налево.
				> Аналог метода reduce, но пробегает значения массива справа-налево,
					а не слева-направо.
				> Полезен в тех случаях, когда порядок имеет знаение.
				> Пример 1 - вычтем все элементы массива с помощью метода reduce:

						var reduced = numbers.reduce(function(a,b,index,array){
							return a - b;
						});
						console.log(reduced);   																| -19

				> Пример 2 - вычтем все элементы массива с помощью метода reduceRight:

						var reduced = numbers.reduceRight(function(a,b,index,array){
							return a - b;
						});
						console.log(reduced);   																     | -9

			> indexOf
				> Слева-направо ищет заданный элемент в массиве, и если находит,
					возвращает индекс первого найденного элемента.
				> Если метод ничего не находит, он возвращает -1.
				> Пример:

						var numbers = [1,2,3,4,5,6,5,4,3,2,1];
						console.log(numbers.indexOf(2));			| 1
						console.log(numbers.indexOf(5));			| 4
						console.log(numbers.indexOf(10));			| -1


			> lastIndexOf
				> Справа-налево ищет заданный элемент в массиве, и если находит,
					возвращает индекс первого найденного элемента.
				> Если метод ничего не находит, он возвращает -1.
				> Пример:

						var numbers = [1,2,3,4,5,6,5,4,3,2,1];
						console.log(numbers.lastIndexOf(2));	| 9
						console.log(numbers.lastIndexOf(5));	| 6
						console.log(numbers.lastIndexOf(10)); | -1










-------------------------------------------------- */

























