/* --------------------------------------------------
 ---------------- О Г Л А В Л Е Н И Е ----------------
 Работа с объектами и массивами

 Массивы
 > Создать массив
 > Доступ к элементам массива
 > Создать многомерный массив
 > Доступ к элементам многомерного массива
 > Посмотреть содержимое массива через Alert
 > Посмотреть все встроенные свойства и методы класса Array
 > Узнать длину массива - встроенное свойство length
 > Перебор элементов массива
 > Удаление элемента из массива с помощью delete (плохой вариант)
   Для удаления лучше использовать: pop (из конца), shift (из начала), splice (из середины)

 > Встроенные методы класса Array по работе с массивами
   > split        | разбивает строку на массив строк по разделителю
   > join         | склеивает массив строк в одну строку с указанным разделителем
   > concat       | Добавляет в целевой массив переданные аргументы (в конец). Исходный массив не меняется.
   > indexOf      | Ищет элемент в массиве слева-направо, и возвращает его индекс или -1
   > lastIndexOf  | Ищет элемент в массиве справа-налево, и возвращает его индекс или -1
   > pop          | Удаляет последний элемент из массива и возвращает его
   > push         | Добавляет элемент в конец массива
   > shift        | Удаляет из массива первый элемент и возвращает его
   > unshift      | Добавляет элемент в начало массива
   > splice       | Удалить, вставить, заменить элементы
   > slice        | Копирует и возвращает участок массива от А до Б. Исходный массив не меняется.
   > sort         | Сортирует массив по указанной callback функции
   > reverse      | Меняет порядок элементов в массиве на обратный

 Объекты
 > Создать объект
 > Запись, чтение и удаление свойства объекта
 > Проверка наличия свойства по его имени в объекте
 > Перебор свойств объекта с / без прототипа
 > Узнать количество свойств в объекте
 > Проверить объект "на пустоту"
 > Запись и чтение метода объекта
 > Работа с this
   > this в методе в локальном контексте
   > this в функции в глобальном контексте
     > this при вызове FD-функции
     > this при вызове FE-функции

 > Полезные функции
   > call   | Вызвать функцию в указанном контексте с указанным списком аргументов
   > apply  | Вызвать функцию в указанном контексте с указанным массивом аргументов


 Прототипы и наследование

	A1. Работа с объектом прототипом:
			- Создание объекта-прототипа
			- Создание и использование его объектов-наследников
			- Использование статических свойств



 	 [далее просто для сведения]

		 > Создать пользовательский класс
			 > Объявить функцию-конструктор
			 > Записать в объект внутри свойства prototype свойства и методы класса
		 > Создать объект пользовательского класса
			 > Создать объект - вызвать функцию-конструктор с new
			 > Убедиться, что ему доступны свойства и методы класса Animal
			 > Посмотреть все методы и свойства объекта и его родителей
		 > Наследование
			 > Наследование на прототипах. Путем присвоения свойству __proto__ ссылки на объект-родитель
			 > Наследование на функциях. Через вызов конструктора родителя в конструкторе наследника
		 > Полезные функции:
			 > Object.getPrototypeOf   | Получить содержимое __proto__ объекта (ссылку на объект-родитель, изменить нельзя)
			 > obj.hasOwnProperty      | Проверить, принадлежит ли св-во X самому объекту без учета его __proto__
			 > instanceof              | Проверить, создан ли объект X данной функцией-конструктором Y (с учетом наследования!)




 -------------------------------------------------- */


// ##########################################
// --------------> Массивы <-------------- //

// Создать массив
    var arr;

    // Способ №1
    arr = new Array(10);   // массив длиной 10, все элементы == undefined
    arr = new Array('Элемент 1', 'Элемент 2', 'И так далее');  // массив из 3-х элементов

    // Способ №2
    arr = ['Элемент 1', 'Элемент 2', 'И так далее'];

// Доступ к элементам массива
    var res;
    res = arr[0];  // 'Элемент 1'
    res = arr[1];  // 'Элемент 2'
    res = arr[2];  // 'И так далее'

// Создать многомерный массив
    var matrix = [
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ];

// Доступ к элементам многомерного массива
    res = matrix[0][0];  // 1
    res = matrix[0][1];  // 2
    res = matrix[0][2];  // 3
    res = matrix[1][0];  // 4
    res = matrix[1][1];  // 5
    res = matrix[1][2];  // 6
    res = matrix[2][0];  // 7
    res = matrix[2][1];  // 8
    res = matrix[2][2];  // 9

// Посмотреть содержимое массива через Alert
    // alert(matrix);  // 1,2,3,4,5,6,7,8,9

// Посмотреть все встроенные свойства и методы класса Array
    console.dir(arr);

// Узнать длину массива - встроенное свойство length
// > !! На самом деле length возвращает последний индекс массива + 1
    arr = [0,1,2];
    res = arr.length;   // 3

    // Демонстрация того, что length == последний индекс массива + 1
    arr[999] = 5;
    res = arr.length;  // 1000

    // Укорачивание массива с помощью length
    // > Изменения не обратимы, значения не вернуть
    arr = [0,1,2,3,4,5];
    arr.length = 3;     // оставить в массиве 3 первых элемента
    console.log('Укорачивание массива с помощью length '+arr);  // 0,1,2

// Перебор элементов массива
    arr = [0,1,2];
    // Способ №1. Оператор In (НЕЖЕЛАТЕЛЕН, перебирает ВСЕ свойства объекта класса Array, а на только элементы массива)
        for(var k in arr) {
            console.log('Перебор с помощью In: '+k+" = "+arr[k]);
        }
    // Способ №2. Оператор For (НАШ ВЫБОР, к тому же быстрее в 10-100 раз, чем In)
        for(var i=0; i<arr.length; i++) {
            console.log('Перебор с помощью For: '+i+" = "+arr[i]);
        }

// Удаление элемента из массива с помощью delete (плохой вариант)
// > Для удаления лучше использовать: pop (из конца), shift (из начала), splice (из середины)
//   > Их описание см. далее
    arr = [0,1,2,3];
    delete arr[1];  // удалить элемент с индексом 1 и значением 1 из массива.
    console.log(arr);  // 0,,2,3     образовалась дырка.


// Встроенные методы класса Array по работе с массивами

    // Array String.prototype.split([*] Separator, [Number, optional] limit)
    // > разбивает строку на массив строк по разделителю
    // > limit - ограничить MAX количество элементов в результирующем массиве
    // > Возвращает массив строк
        var str = 'Один Два Три';
        arr = str.split(' ',2);  // Один,Два
        arr = str.split(' ');    // Один,Два,Три

        // Разбить строку на буквы
        str = 'Река';
        arr = str.split('');  // Р,е,к,а

    // string Array.prototype.join([String, optional] separator)
    // > склеивает массив строк в одну строку с указанным разделителем
        arr = ['Один', 'Два', 'Три'];
        str = arr.join(' - ');  // 'Один - Два - Три'

        // Повторение строки N-1 раз с помощью join
        str = new Array(4).join('Ля');  // ЛяЛяЛя    повторяется 4 - 1 = 3 раза.

    // array Array.prototype.concat concat([ ...*, optional ] items)
    // > Добавляет в целевой массив переданные аргументы (в конец).
    //   Исходный массив не меняется.
    // > Возвращает новый массив.
        arr = [0,1,2];
        arr2 = arr.concat(3,4);
        console.log(arr2);  // 0,1,2,3,4

    // Number Array.prototype.indexOf([ Object ] searchElement,
    //                                [ number, optional ] fromIndex)
    // > Ищет элемент в массиве слева-направо, и возвращает его индекс или -1
    // > Для поиска использует строгое соответствие ===
    // > Не поддерживается IE < 9. Для поддержки подключи библиотеку ES5-shim ( https://github.com/kriskowal/es5-shim )
    // > searchElement - какое значение искать
    // > fromIndex - c какого индекса искать
        arr = ['Иван', 'Жорик', 'Петр'];
        res = arr.indexOf('Иван');   // 0
        res = arr.indexOf('Жорик');  // 1
        res = arr.indexOf('Петр');   // 2

    // Number Array.prototype.lastIndexOf([ Object ] searchElement,
    //                                    [ number, optional ] fromIndex)
    // > Ищет элемент в массиве слева-направо, и возвращает его индекс или -1
    // > Для поиска использует строгое соответствие ===
    // > Не поддерживается IE < 9. Для поддержки подключи библиотеку ES5-shim ( https://github.com/kriskowal/es5-shim )
    // > searchElement - какое значение искать
    // > fromIndex - c какого индекса искать
        arr = ['Иван', 'Жорик', 'Петр'];
        res = arr.lastIndexOf('Иван');   // 0
        res = arr.lastIndexOf('Жорик');  // 1
        res = arr.lastIndexOf('Петр');   // 2


    // * Array.prototype.pop()
    // > Удаляет последний элемент из массива и возвращает его
        arr = [0,1,2];
        arr.pop();
        console.log(arr);  // 0,1

    // number Array.prototype.push([...*, optional] items)
    // > Добавляет элемент в конец массива
        arr = [0,1,2];
        arr.push(3);
        console.log(arr);  // 0,1,2,3

    // * Array.prototype.shift()
    // > Удаляет из массива первый элемент и возвращает его
        arr = [0,1,2];
        arr.shift();
        console.log(arr);  // 1,2

    // number Array.prototype.unshift([...*, optional] items)
    // > Добавляет элемент в начало массива
        arr = [0,1,2];
        arr.unshift(5);
        console.log(arr);  // 5,1,2,3

    // Array.prototype.splice splice([ Number, optional ] start,
    //                               [ Number, optional ] deleteCount,
    //                               [ ...*, optional ] items )
    // > Удалить, вставить, заменить элементы
    // > start - индекс, с которого он начинает действовать
    // > deleteCount - сколько элементов начиная с индекса start и выше удалить.
    //

        // Удаление элементов
            arr = [0,1,2,3];
            arr.splice(1,2);    // начиная с индекса 1 удалить 2 элемента. Удаляет элементы 1,2.
            console.log(arr);   // 0,3

        // Замена элементов
            arr = [0,1,2,3,4];
            arr.splice(0,3, 10,10,10);  // Начиная с индекса 0 удалить 3 элемента. Вместо них вставить элементы 10,10,10.
            console.log(arr);           // 10,10,10,3,4

        // Добавление элементов
            arr = [0,1,2];
            arr.splice(0,0, 10);  // Начиная с индекса 0 удалить 0 элементов, на их место вставить 10
            console.log(arr);     // 10,0,1,2

        // Использование отрицательного start
        // > Отриц. индекс считывается с конца. -1 означает последний индекс - 1.
            arr = [0,1,4];
            arr.splice(-1,0, 2,3);  // Начиная с индекса -1 удалить 0 элементов, на их место вставить 2,3
            console.log(arr);       // 0,1,2,3,4

    // Array Array.prototype.slice slice([ Number, optional ] start,
    //                             [ Number, optional ] end)
    // > Копирует и возвращает участок массива от start (включит.) до end (не включит.)
    //   Исходный массив не меняется.
    var arr2;

        // Скопировать весь массив
            arr = [0,1,2,3,4,5];
            arr2 = arr.slice();  // 0,1,2,3,4,5

        // Скопировать массив, начиная с индекса start и до конца
            arr = [0,1,2,3,4,5];
            arr2 = arr.slice(2);  // 2,3,4,5

        // Скопировать массив от индекса start (включит.) до индекса end (не включит.)
            arr = [0,1,2,3,4,5];
            arr2 = arr.slice(1,4);  // 1,2,3

        // Использование отрицательных индексов в slice
        // > Отриц. индекс считывается с конца. -1 означает последний индекс - 1.
            arr = [0,1,2,3,4,5];
            arr2 = arr.slice(-2);  // 4,5

    // Array Array.prototype.sort([ Function, optional ] compareFn)
    // > Сортирует массив по указанной callback функции compareFn
    //   > Если функцию compareFn не указать, сортирует значения как строки
    // > Использует алгоритм сортировки "быстрая сортировка" - http://algolist.manual.ru/sort/quick_sort.php
    //   > Для сортировки ему надо знать только одно: А больше или меньше или равно Б?
    // > Изменяет массив, к которому применяется. Также еще и возвращает ссылку на измененный массив.
    // > Требования к фукнции compareFn:
    //   > Вернуть + число, если a > b
    //   > Вернуть - число, если a < b
    //   > Если равны не важно, что возвращать, их взаимный порядок не имеет значения

        // Сортировка значений, как строк, без указания compareFn
            arr = [0,1,2,15,16];
            arr2 = arr.sort();
            console.log(arr);  // 0,1,15,16,2

        // Сортировка с использованием compareFn функции
            function compare(a,b) {
                return a - b;
            }
            arr = [0,1,2,15,16];
            arr2 = arr.sort(compare);
            console.log(arr);  // 0,1,2,15,16

    // Array Array.prototype.reverse()
    // > Меняет порядок элементов в массиве на обратный
    // > Изменяет целевой массив. Но еще также возвращает ссылку на измененный массив.
        arr = [0,1,2,3];
        arr.reverse();   // 3,2,1,0



// ##########################################
// --------------> Объекты <-------------- //

// Создать объект
    // Создать пустой объект класса Object
        var obj;
        obj = new Object();       // способ №1
        obj = {};                 // способ №2

    // Создать объект класса Object со свойствами
        obj = {
                  a:    10,
                  b:    'Иван',
            'c+b+d':    {}
        };

// Запись, чтение и удаление свойства объекта
obj = {};
    // Запись
        obj.name = 'Иван';          // способ №1
        obj['name1'] = 'Иван1';     // способ №2

    // Чтение
        res = obj.name;      // 'Иван'          способ №1
        res = obj['name1'];  // 'Иван1'         способ №2

        var varName = 'name1';
        res = obj[varName];  // 'Иван1'

    // Удаление
        delete obj.name;         // способ №1
        delete obj['name1'];     // способ №2

// Проверка наличия свойства по его имени в объекте
    // Способ №1. Оператор In
        obj = {};
        obj.name = 'Иван';
        res = 'surname' in obj;  // false    нет такого свойства
        res = 'name' in obj;     // true     есть такое свойство

    // Способ №2. Сравнение с undefined
        obj = {};
        obj.name = 'Иван';
        res = obj.surname !== undefined;  // false    нет такого свойства
        res = obj.name !== undefined;     // true    нет такого свойства

// Перебор свойств объекта с / без прототипа
// Порядок перебора:
// Группа 1: IE<9, Firefox, Safari перебирают ключи в порядке их присвоения
// Группа 2: IE>=9, Chrome, Opera - сохраняют поярдок только для строковых ключей;
//           числовые ключи идут до строковых, и сортируются в порядке возрастания.

    // Перебор с прототипами
        for (var key in rabbit) {
            console.log (key + " = " + rabbit[key]); // выводит и "eats" и "jumps"
        }

    // Перебор без прототипов
        for (var key in rabbit) {
            if(!rabbit.hasOwnProperty(key)) continue;
            console.log (key + " = " + rabbit[key]); // выводит только "jumps"
        }

    // Перебор с сохранением порядка присвоение для Группы 2
    // > Для числовые индексы делают data.distrindexстроками, ставя символ '+' как показано ниже.
        var codes = {
            "+7": "Россия", // передаём 7 в виде строки, чтобы браузер сохранил порядок
            "+38": "Украина",
            "+1": "США"
        };

        for (var key in codes ) {
            var value = codes[key];
            var id = +key; // ..если нам нужно именно число, преобразуем: "+7" -> 7

            console.log( id + ": " + value );   // 7, 38, 1 во всех браузерах
        }


// Узнать количество свойств в объекте
function getKeysCount(obj) {
    var counter = 0;
    for (var key in obj) {
        counter++;
    }
    return counter;
}

// Проверить объект "на пустоту"
function isEmpty(obj) {
    for (var key in obj) {
        return false; // если цикл хоть раз сработал, то объект не пустой => false
    }
    // дошли до этой строки - значит цикл не нашёл ни одного свойства => true
    return true;
}

// Запись и чтение метода объекта

    // Способ №1 - при объявлении объекта
        o = {
            sayHi: function() {
                console.log('Привет!');
            }
        };
        o.sayHi();  // 'Привет!'

    // Способ №2 - явным присвоением
        o.sayHi2 = function() {
            console.log('Привет 2!');
        };
        o.sayHi2();  // 'Привет 2!'


// Работа с this

    // this в методе в локальном контексте
    // > получает ссылку на тот объект, чей это метод.

        // Доступ к свойству объекта из метода объекта
        o = {
            name: 'Иван',
            showName: function() {
                console.log(this.name);  // покажет 'Иван'
            }
        };
        o.showName();  // 'Иван'

        // Передача ссылки на объект из метода во внешнюю функцию

        // Функция, которая принимает ссылку на объект
        function showNameFunc(object) {
            console.log(object.name);
        }

        // Объект, метод showNameFunc которого передает this (ссылку на объект)
        //   функции showName и вызывает ее
        o = {
            name: 'Петр',
            showName: function() {
                showNameFunc(this);
            }
        };
        o.showName();  // 'Петр'

        // Еще пример использования this, который называется "Лестница"
        var ladder = {
            step: 0,
            up: function() {
                this.step++;
                return this;
            },
            down: function() {
                this.step--;
                return this;
            },
            showStep: function() {
                console.log('Текущий шаг лестницы: '+this.step);
                return this;
            }
        };
        ladder.up().up().up().showStep();    // 3
        ladder.up().down().up().showStep();  // 4


    // this в методе в глобальном контексте
    // > без 'use strict' - получает ссылку на глобальный объект;
    // > с 'use strict' - получает undefined

        // this при вызове FD-функции в глобальном контекте
            function test() {
                console.log('this в функции = '+this);
            }
            test();  // [object Window]

        // this при вызове FE-функции в глобальном контекте
            var tst = function tst() {
                console.log('this в функции = '+this);
            };
            tst();  // [object Window]


// Полезные функции

    // * Function.prototype.call( [Object, optional] thisArg, [ ...*, optional ] args )
    // > Вызвать функцию в указанном контексте с указанным списком аргументов

        // Создать пару объектов, у которых есть свойство 'name' с разными значениями
            var donkey = {name: 'Осёл', nickname: 'Ося', age: 5};
            var lion =   {name: 'лев', nickname: 'Лёва', age: 10};

        // Создать функцию, которую будем вызывать в контексте тех 2-х объектов выше
            function showName(a,b) {
                console.log('Имя животного: '+this.name);
                console.log('Аргумент 1: '+this[a]);
                console.log('Аргумент 2: '+this[b]);
            }

        // Вызов в контексте 'Осла'
            showName.call(donkey, 'nickname', 'age');  // 'Осёл'
                                                       // 'Ося'
                                                       // 5

        // Вызов в контексте 'Льва'
            showName.call(lion, 'nickname', 'age');    // 'Лев'
                                                       // 'Лёва'
                                                       // 10

    // * Function.prototype.apply( [Object, optional] thisArg, [ Array, optional ] argArray )
    // > Вызвать функцию в указанном контексте с указанным массивом аргументов

        // Создать массив аргументов для вызова
            $arr = ['nickname', 'age'];

        // Вызов в контексте 'Осла'
            showName.apply(donkey, $arr);  // 'Осёл'
                                           // 'Ося'
                                           // 5

        // Вызов в контексте 'Льва'
            showName.apply(lion, $arr);    // 'Лев'
                                           // 'Лёва'
                                           // 10






// ###################################################################
// --------------> Прототипы и наследование <-------------- //


// A1. Работа с объектом прототипом:
// 		- Создание объекта-прототипа
// 		- Создание и использование его объектов-наследников
// 		- Использование статических свойств

	// - A1.1.	Создание объекта-прототипа
	var Person = {
			constructor: function(name,age,gender) {
				this.name = name || 'Иван';
				this.age = age || 18;
				this.gender = gender || 'Мужик';
				return this;
			},
			greet: function() {
				console.log('Hi, my name is '+this.name);
			}
	};

	// - A1.2.	Создание и использование его объектов-наследников

		// Создание и использование экземпляра со значениями "по умолчанию" -
		// без передачи аргументов конструктору:

			// Создание
			var person1 = Object.create(Person).constructor();

			// Использование
			console.log(person1.name);			// 'Иван'
			console.log(person1.age);				// 18
			console.log(person1.gender);		// 'Мужик'
			person1.greet();								// 'Hi, my name is Иван'


		// Создание и использование экземпляра, в котором часть значений
		// "по умолчанию" заменяется на переданные значения

			// Создание
			var person2 = Object.create(Person).constructor('Николай', 29);

			// Использование
			console.log(person2.name);			// 'Николай'
			console.log(person2.age);				// 29
			console.log(person2.gender);		// 'Мужик'
			person2.greet();								// 'Hi, my name is Николай'



	// - A1.3.	Использование статических свойств

		// Создание объектапрототипа со статическим св-вом в конструкторе
		var PersonX = {

				count: 0,													// статич. св-во

				constructor: function(name,age) {
					PersonX.count++;								// При создании экземпляра увеличить стат.св-во на 1
					this.name = name;
					this.age = age;
					return this;
				}

		};

		// Использование статических свойств

			// Создать 1-й экземпляр
			var personX1 = Object.create(PersonX).constructor('Иван', 'Петров');
			console.log(personX1.count);		// 1

			// Создать 2-й экземпляр
			var personX2 = Object.create(PersonX).constructor('Иван', 'Петров');
			console.log(personX2.count);		// 2

			// Создать 3-й экземпляр
			var personX3 = Object.create(PersonX).constructor('Иван', 'Петров');
			console.log(personX3.count);		// 3







/*

// Создать пользовательский класс

    // Объявить функцию-конструктор
        function Animal(name) {
            this.name = name;
        }

    // Записать в объект внутри свойства prototype свойства и методы класса

        // Записать свойство speed
        Animal.prototype.speed = 0;

        // Записать метод letHimGo
        Animal.prototype.letHimGo = function(speed) {
            this.speed = speed;
        };

        // Записать метод letHimStop
        Animal.prototype.letHimStop = function() {
            this.speed = 0;
        };


// Создать объект пользовательского класса
// (в его св-ве __proto__ будет ссылка на объект из св-ва prototype ф-ии конструктора)

    // Создать объект
    var elephant = new Animal('elephant');  // создать новый объект "Слон" класса "Animal"

    // Убедиться, что ему доступны свойства и методы класса Animal
    console.log('Скорость движения слона: '+elephant.speed);  // 0
    elephant.letHimGo(10);                                    // Пусть слон идет со скоростью 10
    console.log('Скорость движения слона: '+elephant.speed);  // 10
    elephant.letHimStop();                                    // Пусть слон остановится
    console.log('Скорость движения слона: '+elephant.speed);  // 0

    // Посмотреть все методы и свойства объекта и его родителей
    console.dir(elephant);


// Наследование классов

    // Наследование на прототипах. Путем присвоения свойству __proto__ ссылки на объект-родитель

        // Создать 2 объекта
        var animal = {eats: true};            // класс Животное
        var rabbit = {jumps: true};           // класс Заяц


        // Сделать rabbit наследником объекта animal

            // Для Chrome, Safari, Firefox (где __proto__ явно доступен)
            rabbit.__proto__ = animal;  // Записать в rabbit.__proto__ ссылку на объект animal

            // Для IE (где __proto__ явно НЕ доступен)

                // Для современных IE (где доступен метод Object.create() )
                var rabbit1 = Object.create(animal);  // создать пустой объект rabbit1 с __proto__==animal

                // Для IE6+ (в старых IE метод Object.create() не доступен )
                // > Вместо Object.create используем эту функцию:
                function inherit(proto) {
                    function F() {}
                    F.prototype = proto;
                    var object = new F;
                    return object;
                }

        // Проверить, доступны ли из rabbit свойства его родителя - объекта animal
        console.log(rabbit.eats);   // true
        console.log(rabbit.jumps);  // true

    // Наследование на функциях. Через вызов конструктора родителя в конструкторе наследника

        // Объявить класс menu
            function Menu(options) {
                // Свойства
                   // Приватные
                   var self = this;
                   var elem = options.elem;

                   // Публичные
                   this.elem = options.elem;

                   // Защищенные
                   this._elem = options.elem;

                // Приватные методы
                function onTitleClick() {
                    self.toogle();
                }

                // Публичные методы
                this.toogle = function() {}
                this.open = function () {}
                this.close = function() {}
            }

        // Объявить наследника класса menu - класс SlidingMenu
            function SlidingMenu(menuId) {
                // Вызвать конструктор класса menu
                Menu.apply(this, arguments);

                // Сохранить в новом свойстве старый метод open() родителя
                var parentOpen = this.open;

                // Создать новый open() (перекрыв тем самым доступ к старому)
                // * Но доступ сохраняется - потому что старый open() доступен через новое свойство parentOpen
                this.open = function() {};
            }

// Полезные функции

    // Получить содержимое __proto__ объекта (ссылку на объект-родитель, изменить нельзя)
        res = Object.getPrototypeOf(rabbit) === animal;   // true

    // Проверить, принадлежит ли св-во X самому объекту без учета его __proto__
        res = rabbit.hasOwnProperty('jumps');   // true
        res = rabbit.hasOwnProperty('eats');    // false

    // Проверить, создан ли объект X данной функцией-конструктором Y (с учетом наследования!)
        function Computer() {}
        var compaq = new Computer();
        res = compaq instanceof Object;  // true



function f1() {
    var x = 0;
    function f2() {
        x++;
        console.log(x);
    }
    var y = f2;
    function f3() {

    }
    return f2;
}
var counter = f1();

var counter2 = f1();

counter();
counter();
counter2();
counter2();


*/


/* --------------------------------------------------
 ---------------- И Н Ф О Р М А Ц И Я ----------------

Ссылки:


	> Объекты как ассоциативные массивы:
				http://learn.javascript.ru/object

	> Массивы с числовыми индексами:
				http://learn.javascript.ru/array

	> Массивы: методы
				http://learn.javascript.ru/array-methods

	> Объекты и методы:
				http://learn.javascript.ru/objects-more

	> Продвинутая работа с объектами:
				http://learn.javascript.ru/inheritance-prototypes

	> Диаграмма про прототипы:
				http://i.imgur.com/IkxPv.png

	> Объяснение прототипов на stackoverflow:
				http://stackoverflow.com/questions/650764/how-does-proto-differ-from-constructor-prototype



*****************************************************
Оглавление:

	> Глобальный объект
	> Передача, присваивание и возврат значений в JavaScript
	> Ключевое слово this










*****************************************************



 > Глобальный объект
   > Создается еще до выполнения скрипта
     > Все переменные и функции в глобальной области видимости являются
       свойствами и методами глобального объекта класса Global.
       > В браузере этот объект явно доступен под именем window. Он также
          дополнительно содержит ряд свойств и методов для работы с окном
          браузера.
       > В других окружениях, например node.js, глобальный объект может
         быть не доступен явно, и называется по другому.
     > К тому моменту, как скрипт начинает выполняться в браузере, объект window
       уже создан, вместе со всеми своими методами (Function Declaration) и свойствами (var).
       > Методы созданы уже полностью, со всеми значениями, готовые к работе.
       > Свойства созданы пока что со значениями undefined.


 > Передача, присваивание и возврат значений в JavaScript
   > Могут происходить по значению, или по ссылке.
     > Однако, в JS явно нельзя указать с помощью & (как в PHP),
       по значению или по ссылке передается переменная. Здесь он
       автоматизирован, и приходится под него подстраиваться.
       Вот как он работает в разных ситуациях:
       > Простые типы:
         > присваиваются и передаются (в т.ч. и в функцию):
           - по значению.
       > Объекты:
         > присваиваются и передаются (в т.ч. и в функцию):
           - по ссылке.


 > Ключевое слово this
	 > this - это контекст вызова любой функции в JS
	 > Значение this определяется в момент вызова функции (но не в момент её создания)
	 > this в момент вызова функции получает ссылку на объект, в контексте которого
		 эта функция была вызвана.
		 > Тип функции - FE или FD - значения не играет.
		 > Поведение при вызове в глобальном контексте (контексте глобального объекта) отличается:
			 > Без 'use strict' this получит ссылку на глобальный объект: [object Window]
			 > С 'use strict' this получит undefined



 -------------------------------------------------- */










