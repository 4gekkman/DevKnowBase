/* --------------------------------------------------
 ---------------- О Г Л А В Л Е Н И Е ----------------
 Регулярные выражения


 Прочее
 > 2 способа создать объект класса RegExp
 > Простой пример поиска с помощью регулярного выражения
 > Защита от ошибке в скрипте, если совпадений не найдено

 Модификаторы (флаги)
   > g        | искать все совпадения, а не только 1-е попавшееся
                 > g не установлен: ищет только 1-е вхождение, остальные нет
   > m        | мультистрочный поиск (^ и $ матчат начало/конец строки)
                 > m не установлен:
   > i        | регистронезависимый поиск
                 > i не установлен: регулярное выражение регистрозависимое

 Синтаксис регулярных выражений PCRE
 > \          | обычный символ превращает в специальный; специальный - в обычный.
 > ^          | ищет совпадение в начале строки; если есть флаг 'm', ищет в начале строк.
 > $          | ищет совпадение в конце строки; если есть флаг 'm', ищет в конце строк.
 > .          | матчится с любым символом, кроме символов начала новой строки: \n \r \u2028 \u2029
 > *          | жадный квантификатор - аналог {0,} - 0 или более повторений; ставится после символа, символьного класса или группы.
 > +          | жадный квантификатор - аналог {1,} - 1 или более повторений; ставится после символа, символьного класса или группы.
 > ?          | квантификатор - аналог {0,1} - 0 или 1 повторение; ставится после символа, символьного класса или группы.
 > *?         | ленивый квантификатор, аналог * (0 или более повторений) - но матчит самый короткий результат; ставится после символа, символьного класса или группы.
 > +?         | ленивый квантификатор, аналог + (1 или более повторений) - но матчит самый короткий результат; ставится после символа, символьного класса или группы.
 > {n}        | квантификатор; ровно n раз; ставится после...
 > {n,m}      | квантификатор; от n до m раз; ставится после...
 > {m,}       | квантификатор; от m раз; ставится после...
 > (x)        | Группировка. Запоминающие скобки - сохраняют значения в $1 ... $9
 > (?:x)      | Группировка. Не запоминающие скобки. Аналог (x), только не запоминает значения.
 > x(?=y)     | Группировка. Матчит x, только если за ним следует y.
 > x(?!y)     | Группировка. Матчит x, только если за ним НЕ следует y.
 > x|y        | матчит либо x, либо y
 > [xyz]      | Набор. Матчит любой из символов из набора
 > [^xyz]     | Набор. Матчит любой из символов НЕ из набора
 > [\b]       | Находит символ backspace:  \b
 > x\b, \bx   | Матчит, если x - правая или левая граница слова соответственно
                > Работает только с латиницей, с русским не сработает.
 > x\B, \Bx   | Матчит, если справа или слева от x соответственно не граница слова
 > \cX        | Ищет CTRL-ные символы, где X == [A-Z].
 > \d         | любая цифра == [0-9]
 > \D         | любой символ, который НЕ цифра == [0-9]
 > \f         | символ form feed (\f)
 > \n         | символ новой строки
 > \r         | символ возврата каретки
 > \s         | матчит 1 символ - пробел, а также \f \n \r \t \v \xA0 \u00A0 \u2028 \u2029
 > \S         | матчит 1 символ - антипод \s. Аналог [^ \t\r\n]
 > \t         | символ табуляции
 > \v         | символ вертикальной табуляции
 > \w         | матчит 1 символ из набора [A-Za-z0-9_]
                > Работает только с латиницей, с русским не сработает.
 > \W         | матчит 1 символ - антипод \w. Аналог [^A-Za-z0-9_]
 > \n         | обратная ссылка на n-ную запомненную ()-ми подстроку
 > \0         | найдет символ NUL. Не добавлять в конец другие цифры.
 > \xhh       | найдет символ с кодом из 2-х шестнадцатеричных цифр
 > \uhhhh     | найдет символ с кодом из 4-х шестнадцатеричных цифр

 Функции для работы с PCRE
 > test           | быстро проверить, подходит ли строка под рег. выражение
 > exec           | возвращает массив с результатами поиска в строке с помощью регулярного выражения
 > match          | возвращает массив с результатами поиска в строке с помощью регулярного выражения
 > replace        | заменяет все вхождения подстроки в строку другой подстрокой
 > search         | ищет вхождение регулярного выражения в строку, возвращает индекс



 -------------------------------------------------- */





// #########################################
// --------------> Прочее <-------------- //


// 2 способа создать объект класса RegExp
    // 1 способ
        r = /абв/gmi;   // абв - паттерн регулярного выражения; g m i - флаги.
    // 2 способ
        r = new RegExp('абв','gmi');

// Простой пример поиска с помощью регулярного выражения
    var str = 'Черный кот Иван любил бродить в темноте';  // строка, в которой будем искать
    var regexp = /бро/;          // паттерн
    var r = str.search(regexp);  // 22   (такой паттерн найден, начинается с индекса 22 включительно)

// Защита от ошибке в скрипте, если совпадений не найдено
// > Если совпадений не найдено, res == null
str = 'baa aaa';
reg = /^a/;
res = reg.exec(str);  // null

// Защита от null значения
if(res !== null) console.log(res['index']);
else console.log('res == null!');






// #######################################################
// --------------> Модификаторы (флаги) <-------------- //

    // g - искать все совпадения, а не только 1-е попавшееся
        // тут есть 2 совпадения: на 2 и 6 индексах
        reg = /a\b/g;      // флаг g
        str = 'aaa aaa';
        // найти и вывести все совпадения в консоль
        while((res = reg.exec(str))) {
            console.log(res['index']);   // 2, 6
        }

    // m - мультистрочный поиск (влияет только на ^ и $)
    str = 'aaa \\naaaaa';  // Внимание! После '\n' не должно быть пробелов!
    reg = /a\b/mg;        // чтобы найти матчи на 2-х строках, кроме фалага m еще нужен флаг g
    while((res = reg.exec(str))) {
        console.log('Поиск с флагом m: '+res['index']);   // 2, 10
    }

    // i - регистронезависимый поиск
    // тут есть 2 совпадения (при регистронезависимом поиске): на 0 и 5 индексах
        // Регистро зависимый поиск
        reg = /\bA/;
        str = 'aaa Aaa';
        res = reg.exec(str);
        if(res !== null) console.log(res['index']);  // 4
        else console.log('res == null!');

        // Регистро независимый поиск
        reg = /\bA/i;
        str = 'aaa Aaa';
        res = reg.exec(str);
        if(res !== null) console.log(res['index']);  // 0
        else console.log('res == null!');






// ######################################################################
// --------------> Синтаксис регулярных выражений PCRE <-------------- //

var reg;
var res;

// \        - обычный символ превращает в специальный; специальный - в обычный.
    reg = /a\b/;
    res = reg.exec('aaa aaa');
    if(res)console.log(res['index']);  // 2
    else console.log('Совпадение не найдено');

    reg = /\ba/;
    res = reg.exec('aaa aaa');
    if(res) console.log(res['index']);  // 0
    else console.log('Совпадение не найдено');

// ^        - ищет совпадение в начале строки; если есть флаг 'm', ищет в начале строк.
    reg = /^a/;
    str = 'baa aaa';
    res = reg.exec(str);
    if(res) console.log(res['index']);
    else console.log('Совпадение не найдено');  // NULL

    str = 'aaa aaa';
    res = reg.exec(str);
    if(res) console.log(res['index']);          // 0
    else console.log('Совпадение не найдено');

// $         - ищет совпадение в конце строки; если есть флаг 'm', ищет в конце строк.
    reg = /a$/;
    str = 'aaa aaa';
    res = reg.exec(str);
    if(res) console.log(res['index']);            // 6
    else console.log('Совпадение не найдено');

// .        - матчится с любым символом, кроме символов начала новой строки: \n \r \u2028 \u2029
    reg = /.ов/gi;
    str = 'Овцов и Петров';  // найдет 'цов' и 'ров'
    while((res = reg.exec(str))) {
        console.log('Метасимвол . (десятичная точка): '+res['index']);  // 2, 11
    }

// *         - жадный квантификатор - аналог {0,} - 0 или более повторений; ставится после символа, символьного класса или группы.
    reg = /colou*r/g;
    str = 'color colour colouuur';  // color матчится, потому что '*u' может повторяться 0 раз (отсутстствовать)
    while((res = reg.exec(str))) {
        console.log('Квантификатор *: '+res['index']);  // 0, 6, 13
    }

// +        - жадный квантификатор - аналог {1,} - 1 или более повторений; ставится после символа, символьного класса или группы.
    reg = /colou+r/g;
    str = 'color colour colouuur';  // color уже не матчится.
    while((res = reg.exec(str))) {
        console.log('Квантификатор +: '+res['index']);  // 6, 13
    }

// ?        - квантификатор - аналог {0,1} - 0 или 1 повторение; ставится после символа, символьного класса или группы.
    reg = /colou?r/g;
    str = 'color colour colouuur';  // coluuur не матчится, тут 3 повторения - а МАХ может быть 1-но
    while((res = reg.exec(str))) {
        console.log('Квантификатор ?: '+res['index']);  // 0, 6
    }

// *?       - ленивый квантификатор, аналог * (0 или более повторений) - но матчит самый короткий результат; ставится после символа, символьного класса или группы.
    reg = /<.*?>/g;
    str = '<p><b>Википедия</b></p>';
    while((res = reg.exec(str))) {
        console.log('Ленивый квантификатор *?: '+res['index']);  // 0, 3, 15, 19
    }

// +?       - ленивый квантификатор, аналог + (1 или более повторений) - но матчит самый короткий результат; ставится после символа, символьного класса или группы.
    reg = /<.+?>/g;
    str = '<p><b>Википедия</b></p>';
    while((res = reg.exec(str))) {
        console.log('Ленивый квантификатор +?: '+res['index']);  // 0, 3, 15, 19
    }

// {n}        | квантификатор; ровно n раз; ставится после...
    reg = /colou{2}r/g;  // u повторяется ровно 2 раза
    str = 'color colouur colouuur';
    while((res = reg.exec(str))) {
        console.log('Квантификатор {2}: '+res['index']);  // 6
    }

// {n,m}      | квантификатор; от n до m раз; ставится после...
    reg = /colou{2,3}r/g;  // u повторяется от 2 до 3 раз
    str = 'color colouur colouuur';
    while((res = reg.exec(str))) {
        console.log('Квантификатор {2,3}: '+res['index']);  // 6, 14
    }

// {m,}       | квантификатор; от m раз; ставится после...
    reg = /colou{2,}r/g;  // u повторяется от 2 раз
    str = 'color colouur colouuur';
    while((res = reg.exec(str))) {
        console.log('Квантификатор {2,}}: '+res['index']);  // 6, 14
    }

// (x)        | Группировка. Запоминающие скобки - сохраняют значения в $1 ... $9
// > Например: /(a)(b)(c)/   $1 = 'a', $2 = 'b', $3 = 'c'
// > Круглые скобки также определяют приоритет операций
// > Ко всему выражению в круглых скобках можно применять квантификацию
//   > При этом одинаковые значения не запоминаются в разные переменные, а только первое вхождение
    reg = /a(b|x)cc/g;
    str = 'abccaxcc';
    while((res = reg.exec(str))) {
        console.log('Группировка. Запоминающие скобки: '+res['index']);  // 1, 5
        if(!!res[1])
            console.log('Группировка. Запоминающие скобки. $1 = '+res[1]);   // 'b'
        if(!!res[2])
            console.log('Группировка. Запоминающие скобки. $2 = '+res[2]);   // 'x'
    }

// (?:x)      | Группировка. Не запоминающие скобки. Аналог (x), только не запоминает значения.
    reg = /a(?:b|x)cc/g;
    str = 'abccaxcc';
    while((res = reg.exec(str))) {
        console.log('Группировка. Не запоминающие скобки: '+res['index']);  // 1, 5
        if(!!res[1])
            console.log('Группировка. Не запоминающие скобки. $1 = '+res[1]);   // undefined
        if(!!res[2])
            console.log('Группировка. Не запоминающие скобки. $2 = '+res[2]);   // undefined
    }

// x(?=y)     | Группировка. Матчит x, только если за ним следует y.
    reg = /Иван(?= Петров| Сидоров)/g;
    str = 'Иван Иванов, Иван Петров, Иван Сидоров';
    while((res = reg.exec(str))) {
        console.log('Группировка типа x(?=y): '+res['index']);  // 13, 26
    }

// x(?!y)     | Группировка. Матчит x, только если за ним НЕ следует y.
    reg = /Иван(?! Петров| Сидоров)( |,)/g;
    str = 'Иван Иванов, Иван Петров, Иван Сидоров';
    while((res = reg.exec(str))) {
        console.log('Группировка типа x(?!y): '+res['index']);  // 0
    }

// x|y       | матчит либо x, либо y
    reg = /(Зеленое|Красное) яблоко/g;
    str = 'Зеленое яблоко, Красное яблоко';
    while((res = reg.exec(str))) {
        console.log('(x|y): '+res['index']);  // 0, 16
    }

// [xyz]     | Набор. Матчит любой из символов из набора
// > если буквы идут подряд как по алфавиту, то можно написать как в примере ниже через тире
    reg = /(м|ф)[абвгд]/gi;   // можно еще так написать: /(м|ф)[а-д]/gi;
    str = 'Малус Фалус Фдул';
    while((res = reg.exec(str))) {
        console.log('[xyz]: '+res['index']);  // 0, 6, 12     нашел 'Ма' и 'Фа' и 'Фд'
    }

// [^xyz]    | Набор. Матчит любой из символов НЕ из набора
    reg = /N[^defgi]/gi;
    str = 'Протоколы NG1045 и NA234';
    while((res = reg.exec(str))) {
        console.log('[^xyz]: '+res['index']);  // 19    заматчил 'NA'
    }

// [\b]           | Находит символ backspace (\b)
    reg = /[\b]/gi;
    str = 'Привет\b';
    while((res = reg.exec(str))) {
        console.log('[\\b]: '+res['index']);  // 6
    }

// x\b, \bx       | Матчит, если x - правая или левая граница слова соответственно
// > \b не включает в себя кириллические символы, а только: [A-Za-z0-9_]
// > подробнее здесь: http://stackoverflow.com/questions/280712/javascript-unicode
    reg = /\bno/gi;
    str = 'after Noon';
    while((res = reg.exec(str))) {
        console.log('x\\b, \\bx: '+res['index']);  //
    }

// x\B, \Bx       | Матчит, если справа или слева от x соответственно не граница слова
    reg = /\Bно/gi;
    str = 'Давно';
    while((res = reg.exec(str))) {
        console.log('x\\B, \\Bx: '+res['index']);  // 3
    }

// \cX       | Ищет CTRL-ные символы, где X == [A-Z].


// \d        | любая цифра == [0-9]
    reg = /\d+/gi;
    str = 'На гавайях 35 градусов по цельсию';
    while((res = reg.exec(str))) {
        console.log('\\d: '+res['index']);  // 11
    }

// \D        | любой символ, который НЕ цифра == [0-9]
    reg = /\D/gi;
    str = '1945Х2054Y';
    while((res = reg.exec(str))) {
        console.log('\\D: '+res['index']);  // 4, 9
    }

// \f        | символ form feed (\f)
    reg = /\f/gi;
    str = 'Привет\f';
    while((res = reg.exec(str))) {
        console.log('\\f: '+res['index']);  // 6
    }

// \n        | символ новой строки
    reg = /\n/gi;
    str = 'Привет\n';
    while((res = reg.exec(str))) {
        console.log('\\n: '+res['index']);  // 6
    }

// \r        | символ возврата каретки
    reg = /\r/gi;
    str = 'Привет\r';
    while((res = reg.exec(str))) {
        console.log('\\r: '+res['index']);  // 6
    }

// \s        | матчит 1 символ - пробел, а также \f \n \r \t \v \xA0 \u00A0 \u2028 \u2029
//             > \xA0     - неразрывный пробел
//             > \u00A    - NO-BREAK SPACE
//             > \u2028   - LINE SEPARATOR
//             > \u2029   - PARAGRAPH SEPARATOR
    reg = /\sП/gi;
    str = 'Иван Петров';
    while((res = reg.exec(str))) {
        console.log('\\s: '+res['index']);  // 4
    }

// \S         | матчит 1 символ - антипод \s. Аналог [^ \t\r\n]
    reg = /\Sва|ро\S/gi;
    str = 'Иван Петров';
    while((res = reg.exec(str))) {
        console.log('\\S: '+res['index']);  // 0, 8
    }

// \t         | символ табуляции
    reg = /\t/gi;
    str = 'Привет\t';
    while((res = reg.exec(str))) {
        console.log('\\t: '+res['index']);  // 6
    }

// \v         | символ вертикальной табуляции
    reg = /\v/gi;
    str = 'Привет\v';
    while((res = reg.exec(str))) {
        console.log('\\v: '+res['index']);  // 6
    }

// \w         |  матчит 1 символ из набора [A-Za-z0-9_]
//               > Работает только с латиницей, с русским не сработает.
    reg = /S\w+\s\d\d/gi;
    str = 'John Smith 19';
    while((res = reg.exec(str))) {
        console.log('\\w: '+res['index']);  // 5
    }


// \W          | матчит 1 символ - антипод \w. Аналог [^A-Za-z0-9_]
    reg = /hn\Wsm/gi;
    str = 'John$smith';
    while((res = reg.exec(str))) {
        console.log('\\W: '+res['index']);  // 2
    }

// \n          | обратная ссылка на n-ную запомненную ()-ми подстроку
    reg = /apple(,)\sorange\1/gi;
    str = 'apple, orange, cherry, peach';
    while((res = reg.exec(str))) {
        console.log('\\n: '+res['index']);  // 0
    }

// \0         | найдет символ NUL. Не добавлять в конец другие цифры.

// \xhh       | найдет символ с кодом из 2-х шестнадцатеричных цифр

// \uhhhh     | найдет символ с кодом из 4-х шестнадцатеричных цифр



// ############################################################
// --------------> Функции для работы с PCRE <-------------- //


// boolean test( [string, optional] str )
// > быстро проверить, подходит ли строка под рег. выражение
// > если паттерн str найден в RegExp, возвращает TRUE; иначе FALSE;
    reg = /\d/;
    str = 'Шел 2138 год';
    res = reg.test(str);   // true

    reg = /[byg]/;
    res = reg.test(str);   // false

// array exec( [string, optional] str )
// > возвращает массив с результатами поиска в строке с помощью регулярного выражения
//   > А именно, состоящий из 3-х значений:
//     > Индекс: 0;        Значение: переданное регулярное выражение для поиска
//     > Индекс: 'index';  Значение: индекс начала 1-й найденной подстроки
//     > Индекс: 'input';  Значение: строка, в которой производился поиск
//   > Если совпадений не найдень, возвращает NULL
    regExp = /ов/;
    arr = regExp.exec('Иван Иванов набрал Иваныча');
    r = arr['index'];   // 9

// array match([ RegExp ] regexp)
// > возвращает массив с результатами поиска в строке с помощью регулярного выражения
//   > А именно, состоящий из 3-х значений:
//     > Индекс: 0;        Значение: переданное регулярное выражение для поиска
//     > Индекс: 'index';  Значение: индекс начала 1-й найденной подстроки
//     > Индекс: 'input';  Значение: строка, в которой производился поиск
//   > Если совпадений не найдень, возвращает NULL
    var regExp = /ов/;
    arr = 'Иван Иванов набрал Иваныча'.match(regExp);
    r = arr['index'];  // 9    Первое вхождение подстроки 'ов' происходит с 9-го индекса

// string replace( [RegExp | string] searchValue, [string | Function] replaceValue )
// > заменяет все вхождения подстроки в строку другой подстрокой
    r = 'Иван Иванов набрал Иваныча'.replace('Иван', 'Петр');        // Петр Иванов набрал Иваныча
    r = 'Иван Иванов набрал Иваныча'.replace(/набрал/, 'напал на');  // Иван Иванов напал на Иваныча
    r = 'Петру X лет'.replace(/X/, function() {return 10;});         // Петру 10 лет

// number search([*] regExp)
// > ищет вхождение регулярного выражения в строку, возвращает индекс
// > ищет вхождение регулярного выражения в строку слева направо
// > возвращает индекс начала вхождения включительно
// > если передано не регулярное выражение, преобразует переданный параметр к нему с помощью new RegExp(obj)
// > возвращает -1, если ничего не найдено
    r = 'Красная труба'.search(/труба/);   // 8
    r = 'Красная труба'.search(/иван/);    // -1



/* --------------------------------------------------
 ---------------- И Н Ф О Р М А Ц И Я ----------------

Ссылки


	Основное
		> О регулярных выражения от команды Mozilla:
				https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FRegExp

		> О регулярных выражениях от Ильи Кантора - старая статья:
				http://javascript.ru/basic/regular-expression

		> О регулярных выражениях от Ильи Кантора (новая статья не закончена):
				http://learn.javascript.ru/regexp-introduction

	Дополнительно

		> Онлайн тест регулярных выражений:
				http://www.regexpr.ru/

		> Википедия о регулярных выражениях:
				ru.wikipedia.org/wiki/Регулярные_выражения

		> Шпаргалка по синтаксису регулярных выражений:
				http://www.javascripter.net/faq/regularexpressionsyntax.htm

		> Визуализатор регулярных выражений
				http://www.regexper.com/





*****************************************************************


 О регулярных выражениях в общем
 > Регулярные выражения в широком смысле - это язык поиска и осуществления
   манипуляций с подстроками в тексте, основанный на использовании метасимволов.
 > Регулярное выражение - это строка. Которая является
                          ( паттерном | шаблоном | маской ) для поиска в другой строке.
   > Она состоит из:
     > Символов     - буквы, цифры, вообщел юбые символы.
     > Метасимволы  - зарезервированные сочетания символов, по сути языковые
                      конструкции, задающие правила поиска.
 > Например, при помощи регулярных выражений можно задать паттерны, позволяющие:
   > найти все последовательности символов «кот» в любом контексте, как то: «кот», «котлета», «терракотовый»;
   > найти отдельно стоящее слово «кот» и заменить его на «кошка»;
   > найти слово «кот», которому предшествует слово «персидский» или «чеширский»;
   > убрать из текста все предложения, в которых упоминается слово кот или кошка.
   > ... и еще много чего.

 Регулярные выражения в JavaScript
 > JavaScript имеет встроенную поддержку регулярных выражений
   > Как и в PHP, в JS регулярные выражения имеют PCRE-синтаксис.
     PCRE - Perl Compatible Regular Expressions
     > Их оф. сайт: http://www.pcre.org/, с него можно скачать сам дистрибутив PCRE
 > В JS регулярные выражения представлены классом RegExp.
 > Можно создать объект класса RegExp, содержащий строку-паттерн,
   и искать вхождение этого паттерна в целевую строку.
   > Вот строковые фукнции JS, работающие с регулярными выражениями:
     > match()
     > exec()
     > replace()
     > search()
 > Есть 2 способа создать объект класса RegExp:
   1) r = new RegExp( pattern, [, flags] )
     > Например: r = new RegExp('ab+c', 'i');
   2) r = /pattern/flags
     > Например: r = /ab+c/i
 > Флаги регулярных выражений
   > Флаг 'g'
     > Искать все совпадения
   > Флаг 'm'
     >
   > Флаг 'i'
     > Регистронезависимый поиск
 > Регулярные выражения чувствительны к регистру. Поэтому для регистронезависимого
   поиска обязательно используй флаг i.

Специальные символы в регулярных выражениях:




 -------------------------------------------------- */
























