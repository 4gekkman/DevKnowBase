=============================================================
RequireJS


Ссылки:

	> Официальный сайт:
				http://requirejs.org/

  > AMD - Asynchronous Module Definition - сайт с описанием этого механизма:
        https://github.com/amdjs/amdjs-api/wiki/AMD

  > AMD - обоснование преимуществ подхона на сайте requireJS:
        http://requirejs.org/docs/whyamd.html#today




*****************************************************
Оглавление:

  > Вводная информация о модульной архитектуре в JS
    > Суть в нескольких словах
    > Преимущества модульной архитектуры

	> Вводная информация о requireJS
    > Суть в нескольких словах
    > RequireJS состоит из 2-х файлов
    > Поддержка браузерами require.js

  > Установка (windows)
    > Установка require.js
    > Установка r.js
    > Установка NodeJS

  > Рекомендации по структуре приложения
    > Структура папок и файлов
    > Пояснения

  > Создание модуля, подключение и использование зависимостей. Функция define().
    > Основные сведения о модулях в RequireJS
    > Некоторые особенности работы с модулями
      > Правило 1:1
      > Относительные пути внутри define()
      > Сгенерировать URL относительно модуля
      > Отладка в консоли
    > Способы определения модуля функцией define()
      > Введение и примечания
      > Способ №1: простой (в виде пар ключ/значение)
      > Способ №2: стандартный (без зависимостей)
      > Способ №3: стандартный (определение зависимостей через массив и аргументы)
      > Способ №4: стандартный (определение зависимостей в коде модуля)

  > Сборка: top-level-файл. Варианты подключения к документу. Конфиг.
    > Сборка это top-level файл.
    > Варианты подключения сборки к документу
      > Вариант №1: через атрибут data-main тега script (НЕ минифицированная сборка)
      > Вариант №2: через атрибут src тега script (минифицированная сборка)
    > Конфиг сборки: require.config()
      > Конфигурационный объект с параметрами сборки
      > Варианты передачи конфигурационного объекта
      > Параметры конфига (некоторые)

  > Минификация
    > Введение в минификацию
    > Пошаговое описание процесса минификации
    > Конфиг для минификации




*****************************************************


> Вводная информация о модульной архитектуре в JS

  > Суть в нескольких словах:
    - JS-код можно разбить на куски.
    - Каждый кусок назвать модулем.
    - Каждый модуль положить в отдельный файл.
    - Каждый модуль изолирован. Это позволит не засорять глобальноее пр.имён,
      и избежать конфликтов имён с другими модулями и с другими глоб.переменными.
    - На входе каждого модуля можно указать его зависимости - т.е. какие модули должны
      подгрузиться, чтобы этот конкретный модуль мог правильно работать.
    - На выходе каждого модуля - объект с функционалом и данными.
    - Логику, использующую модульное приложение, помещать в так называемый
      "top level" файл. Например, html-документ (в теге script) или js-файл-не-модуль.
    - С помощью require, в этом "top level" файле подключается вся цепочка
      зависимостей, а логика реализуется в callback-функции.

  > Преимущества модульной архитектуры:

    > Легко поддерживать и развивать
      - Код можно разбивать на небольшие модули, не превышающие определённый
        предел по размеру.
      - Поддерживать и развивать простой маленький модуль легче, чем большой
        и сложный.

    > Гибкость
      - У одного модуля может быть много версий.
      - Часто требуется подстроить готовое JS-приложение под реальный проект.
      - Берём и создаём новые подстроенные версии нужных модулей.
      - А затем делаем новую сборку.

    > Масштабируемость
      - Легко масштабировать.
      - Создал новый модуль. Подключил ему зависимости. Подключел его
        к другому модулю. Дописал в этом другом модуле код, использующий
        новый модуль, и так далее по цепочке (в зависимости от приложения).
        И дело в шляпе.


> Вводная информация о RequireJS

  > Суть в нескольких словах:
    - Можно организовать код в модули.
    - Можно каждому модулю присвоить уникальный ID.
    - Каждому ID можно назначить любой путь к любому JS-файлу с модулем.
    - Можно каждому модулю указать его зависимости - список ID других модулей.
    - RequireJS автоматически подгружает всю цепочку зависимостей.
    - Каждый модуль может вернуть объект с функционалом и данынми.
    - Можно в каждом модуле получить доступ к объектам, которые вернули
      его модули-зависимости.
    - Логику приложения, использующую цепочку взмимозависимых модулей, надо
      реализовывать в "top level" файле (js-файл-не-модуль).
    - Одной командой в консоли, r.js может собрать указанный top-level-файл
      и всю его цепочку зависимостей в верной последовательности в один файл,
      минифицировать его и сохранить куда указано.
    - Этот файл можно деплоить на боевом сервере.

  > RequireJS состоит из 2-х файлов:
    - require.js              // управление модулями и их зависимостями
    - r.js                    // минификация

  > Поддержка браузерами require.js?
    > Поддерживаются следующие версии браузеров:
      - >=IE6
      - >=Firefox 2
      - >=Safari 3.2
      - >=Chrome 3
      - >=Opera 10


> Установка (windows)


  > Установка require.js

    > Пошаговый процесс установки:
      1.  Зайти на официальный сайт require.js в раздел "download":
              http://requirejs.org/docs/download.html
      2.  Скачать последнюю версию require.js.
      3.  Положить файл require.js в проект.


  > Установка r.js

    > Требует nodeJS
      > Перед установкой r.js установить nodeJS.

    > Пошаговый процесс установки:
      1.  Ввести в консоль следующую команду, которая установит r.js,
          как модуль для nodeJS:

            npm install reqiurejs

    > Проверка:
      > Проверить работоспособность r.js можно, введя в консоли следующую
        команду. Должна появиться его версия.

         r.js.cmd -v


  > Установка NodeJS

    > Пошаговый процесс установки:
      1.  Зайти на официальный сайт NodeJS и скачать файл .msi, который
          позволит установить NodeJS на Windows:
              http://nodejs.org/
      2.  Установить nodeJS. Будет сделано сделующее (v0.10.25):
          - Установлена среда выполнения nodeJS
          - Устанвлен менеджер пакетов NPM (типа композера)
          - Установлена документация
          - Путь к "node.exe" будет добавлен в переменную PATH операционной системы Windows.

    > Проверка:
      > Проверить работоспособность NodeJS можно, введя в консоли следующую
        команду. Должна появиться его версия.

            node -v


> Рекомендации по структуре приложения

  > Структура папок и файлов


          ******************************

            ->  app

              ->  css

                ->  style1.css
                ->  style2.css

              ->  modules

                ->  module1
                  ->  module1_v1.js
                  ->  module1_v2.js

                ->  module2
                  ->  module1_v1.js
                  ->  module1_v2.js

              ->  builds

                ->  app_build1
                  ->  app_build1.js
                  ->  build1_min_config.js

                ->  app_build2
                  ->  app_build2.js
                  ->  build2_min_config.js

              ->  demos

                -> test of build1
                  ->  build1_test1.html

                -> test of build2
                  ->  build2_test1.html

              ->  vendors

                ->  vendor1
                  ->  vendor1.js

                ->  vendor2
                  ->  vendor2.js

              ->  info
                ->  описание.txt
                ->  модули.txt
                ->  сборки.txt

          ******************************

    > Пояснения к вышеописанной структуре:

      > css                     // папка с css-файлами приложения
      > style1.css              // файл со стилями №1
      > style2.css              // файл со стилями №1

      > app                     // папка с приложением

      > modules                 // папка c папками модулей
      > module1                 // папка модуля module1
      > module2                 // папка модуля module2
      > module1_v1.js           // модуль module1, версия 1
      > module1_v2.js           // модуль module1, версия 2
      > module2_v1.js           // модуль module2, версия 1
      > module2_v2.js           // модуль module2, версия 2

      > builds                  // папка со сборками
      > app_build1              // папка сборки build1
      > app_build2              // папка сборки build2
      > app_build1.js           // файл-сборка сборки build1
      > app_build2.js           // файл-сборка сборки build2
      > build1_min_config.js    // конфиг для минификации сборки build1
      > build2_min_config.js    // конфиг для минификации сборки build2

      > Demos                   // папка с демками работы различных сборок
      > build1_test1.html       // документ для тестирования
      > build1_test1.html       // документ для тестирования

      > vendors                 // папка с задействованными приложением другими приложениями
      > vendor1                 // папка с приложением от vendor1
      > vendor2                 // папка с приложением от vendor2
      > vendor1.js              // файл приложения от vendor1
      > vendor2.js              // файл приложения от vendor2

      > info                    // папка с информационными файлами приложения
      > описание.txt            // файл с общим описанием преложения
      > модули.txt              // файл с актуальным списком и описанием всех модулей приложения
      > сборки.txt              // файл с актуальным списком и описанием всех сборок приложения


> Создание модуля, подключение и использование зависимостей. Функция define().

  > Основные сведения о модулях в RequireJS
    - Каждый модуль изолирован в своём пространстве имён.
    - Для каждого модуля можно явно указать список его зависимостей в виде
      списка ID других модулей. При этом не требуется ссылаться на глобальные объекты.
    - Получить доступ к объектам, возвращаемым зависимостями модуля, можно через
      аргументы функции, в которой определён модуль.
    - Каждая зависимость модуля подгружается MAX быстро. Порядог подгрузки
      зависит от её скорости. Но выполняюся они в итоге всегда в правильном
      (указанном) порядке.

  > Некоторые особенности работы с модулями

    > Правило 1:1
      > В одном JS-файле должно быть определение только 1-го модуля.
      > Исключение: JS-файл, получающийся в результате минимизации.

    > Относительные пути внутри define()
      > Если понадобится использовать относительный путь в функции
        внутри define(), то в качестве обязательно должен быть подключен
        require.js.
      > Неправильно:

            define(["./relative/name"], function() {
                var mod = require("./relative/name");
            });

      > Правильно:

            define(["require", "./relative/name"], function(require) {
                var mod = require("./relative/name");
            });

    > Сгенерировать URL относительно модуля
      > Если понадобится внутри define() сгенерировать URL относительно
        модуля, то это можно сделать так:

            define(["require"], function(require) {
                var cssUrl = require.toUrl("./style.css");
            });

    > Отладка в консоли
      > Допустим, ты открыл консоль и подгрузил в неё модуль "module/name",
        выполнив следующий код:

          require(["module/name"], function(){})

      > Теперь в консоли получить доступ к модулю "module/name" можно так:

          require("module/name").callSomeFunction()

  > Способы определения модуля функцией define()

    > Введение и примечания
      > Способы 2,3,4 отличаются только тем, как указывать зависимости
        модуля и получать к ним доступ.

    > Способ №1: простой (в виде пар ключ/значение)
      > [вход]:   нет
      > [выход]:  объект с парами ключ/значение
      > Пример определения:

        my/shirt.js
        -----
            define({
                color: "black",
                size: "unisize"
            });

      > Пример использования в другом модуле (стандартном с зависимостями):

        module1.js
        -----
            define([my/shirt], function(shirt) {
              console.log(shirt.color);   // 'black'
              console.log(shirt.size);    // 'unisize'
            });


    > Способ №2: стандартный (без зависимостей)
      > [вход]:   нет
      > [выход]:  объект с функционалом и данными
      > Пример определения:

        my/shirt.js
        -----
            define(function () {
                //Do setup work here

                return {
                    color: "black",
                    size: "unisize"
                }
            });

      > Пример использования:
          Тоже самое, что для способа №1 (см.выше).


    > Способ №3: стандартный (определение зависимостей через массив и аргументы)
      > [вход]:   зависимости модуля, доступны через аргументы
      > [выход]:  объект с функционалом и данными
      > Пример определения:
        - В данном примере все файлы - shirt.js, cart.js, inventory.js -
          лежат в одной папке my.
        - Для модуля shirt.js указаны 2 зависимости: cart.js и inventory.js.
        - Из определения модуля shirt.js доступ к этим зависимостям можно
          получить через аргументы - cart и inventory - функции с определением.

        my/shirt.js
        -----
            define(["./cart", "./inventory"], function(cart, inventory) {

              return {
                  color: "blue",
                  size: "large",
                  addToCart: function() {
                      inventory.decrement(this);
                      cart.add(this);
                  }
              }
            });

      > Пример использования
            Тоже самое, что для способа №1 (см.выше).


    > Способ №4: стандартный (определение зависимостей в коде модуля)
      > Особенности:
        - По сути, это тоже самое, что способ №2.
        - Отличие в способе указания зависимостей модуля и получения к ним
          доступа. В этом способе это делается прямо в коде модуля.
        - Этот способ используют тогда, когда зависимостей очень много,
          и если указывать их как в способе №3, код станет плохо читаемым.
        - Важная особенность

      > [вход]:   зависимости модуля, доступны через аргументы
      > [выход]:  объект с функционалом и данными
      > Пример определения:

        my/shirt.js
        -----
            define(function (require) {
                var foo = require('foo');

                //Define this module as exporting a function
                return {
                  func1:  function () {
                            foo.doSomething();
                          }
                };



            });

      > Пример использования
            Аналогично, что для способа №1 (см.выше).


> Сборка: top-level-файл. Варианты подключения к документу. Конфиг.

  > Сборка это top-level файл.
    - Логику приложения, использующую цепочку взмимозависимых модулей, надо
      реализовывать в "top level" файле (js-файл-не-модуль).
    - Такой top-level-файл будет называть термином "Сборка". Потому что
      фактически к одному JS-файлу-не-модулю подключается некий набор
      модулей с их цепочками зависимостей, и с использованием всего этого
      добра выполняется накая логика.
    - Сборку можно подключить к документу, используя так называемую
      "data-main Entry Point". А именно, используя HTML-тег script,
      в атрибуте src которого указать путь к require.js, а в атрибуте
      data-main - путь к сборке.
    - Одной командой в консоли, r.js может собрать указанный top-level-файл
      (читай указанную Сборку) и всю его цепочку зависимостей в верной
      последовательности в один файл, минифицировать его и сохранить куда
      указано.
    - Этот файл можно деплоить на боевом сервере.

  > Варианты подключения сборки к документу

    > *Примечание:
      - Указанное применяется в том случае, если сборка оформлена в виде
        отдельного JS-файла.
      - Если же сборка оформлена в теге <script> внутри самого документа,
        то ничего и подключать не надо.

    > Вариант №1: через атрибут data-main тега script (НЕ минифицированная сборка)
      - Этот вариант подключения используют для подключения НЕ
        минифицированной сборки к документу.
      - Пример:

          <script data-main="build1.js" src="require.js"></script>

    > Вариант №2: через атрибут src тега script (минифицированная сборка)
      - Этот вариант подключения используют для подключения минифицированной
        сборки к документу, которая представляет из себя 1 ужатый js-файл,
        содержащий сборку и все её зависимости.
      - Примечание*: если в минифицированной сборке не прописана зависимость
                     от require.js, то перед её подключением к документу,
                     надо сначала к нему поключить require.js тоже тегом script.
      - Пример:

        Если в сборке была прописаза зависимость от require.js до сжатия:
        -----
          <script src="build1.min.js"></script>

        Если в сборке НЕ была прописаза зависимость от require.js до сжатия:
        -----
          <script src="require.js"></script>
          <script src="build1.min.js"></script>


  > Конфиг сборки: require.config()

    > Конфигурационный объект с параметрами сборки
      - В сборке для require.js можно передать конфигурационный объект
        с набором параметров, которые будут действовать для этой сборки.

    > Варианты передачи конфигурационного объекта

      > Вариант №1: передать конфиг через require.config()

        Сборка в отдельном JS-файле-не-модуле (build1.js):
        -----
            require.config({

              ... тут параметры ...

            });

            require(["build1.js"], function(shirt) {

              ... тут логика сборки ...

            });

      > Вариант №2: объявить глоб.переменную require до загрузки require

        Сборка в теге <script> в документе:
        -----

        <script>
            var require = {

              deps: ["module1", "module2"],
              callback: function(module1, module2) {

                ... тут логика сборки ...

              }

            };
        </script>
        <script src="require.js"></script>

    > Параметры конфига (некоторые):
      > Все параметры можно посмотреть здесь:
          http://requirejs.org/docs/api.html#config
      > Некоторые параметры:

        # baseUrl         // корневой URL, в котором искать все модули
          > Корневой URL - это тот, относительно которых requireJS будет
            искать все модули, для которых указан относительный путь.
          > 3 фактора, влияющих на то, как requireJS будет разрешать
            относительные пути к модулям:
            - Подключена ли сборка к документу через data-min.
            - Указан ли явно параметр baseUrl явно в конфиге сборки.
            - Если baseUrl указано, содержит ли от хотя бы 1 из 3 признаков:
              -> Заканчивается на ".js"
              -> Начинается с "/"
              -> Содержит протокол, как "http" или "https"
          > Итак. Вот как requireJS вычисляет корневой URL:
            1.  Если baseUrl явно НЕ указан в конфиге, а сборка подключена
                к документу НЕ через data-main, то корневой URL:
                - это URL HTML-документа, в который загружен require.js
            2.  Если baseUrl явно НЕ указан в конфиге, а сборка подключена
                к документу через data-main, то корневой URL:
                - это URL, указанный в значении data-main, т.е. URL сборки.
            3.  Если baseURL явно указан, НО содержит хотя бы 1 из 3
                вышеуказанных признаков (абсолютный путь), то корневой URL:
                - определяется по правилам 1 и 2 пунктов.
            4.  Если baseURL явно указан, и НЕ содержит ни одного из
                вышеуказанных признаков, то корневой URL:
                - Это URL HTML-документа, в который загружен require.js
                  + с приставкой в виде значения baseURL

        # paths           // добавка справа к корневому URL (можно указать каждому модулю отдельно)\
          > Описание:
            - Позволяет для каждого модуля отдельно указать "добавку" справа
              от корневого URL в виде относительного пути.

        # bundles         // [отложено]
        # deps            // указать модули, которые надо подгрузить
          - Используется при способе передачи конфигурационного объекта
            "Вариант №2" (см.выше) - т.е. передача до загрузки require.js
          - Данные зависимости будут подгружены, как только будет загружен
            require.js.
          - Пример использовани см.выше.

        # callback        // колбэк-функция, выполнится после загрузки deps-зависимостей
          - Используется при способе передачи конфигурационного объекта
            "Вариант №2" (см.выше) - т.е. передача до загрузки require.js

        # waitSeconds     // время в секундах на загрузку каждого из модулей


> Минификация перед деплоем: r.js


  > Введение в минификацию

    > Что понадобится для проведения минификации:
      - NodeJS
      - RequireJS (включающий r.js), установленный через NPM как модуль NodeJS
      - Готовый валидный js-файл-сборка

    > Когда и для чего используют минификацию?
      - Процесс минификаци применяют для сжатия сборки со всей её цепочкой
        зависимостей в 1 JS-файл минимального веса.
      - Минификацию сборки поводят перед деплоем. Сжатый файл используют на
        "боевом сервере". Минимальный вес даёт выигрыш в скорости загрузки
        документа у пользователя.

    > Что происходит при минификации?
      - Сборка и вся её цепочка зависимостей комбинируется в 1 js-файл.
      - Комбинация производится в верном с точки зрения зависимостй порядке.
      - Получившийся js-файл минифицируется с помощью uglifyJS (по умолчанию)
        или Closure Compiler. Удаляются комментарии, пробелы и табы, сокращаются
        имена переменных и т.д. Цель - снизить вес файла до самого минимума.

    > Особенности минификатора
      - Минификатор комбинирует только те модули-зависимости, имена которых
        указаны явно в качестве литералов, а не переменных. И только те,
        что указаны на "top level require and difine calls".

    > Подготовка сборки к минификации
      > Мы знаем, что сборка может находиться как в отдельном js-файле, так
        и в теге script документа. Какой вариант подходит для минификации?
        - Ответ: только в отдельном js-файле.


  > Пошаговое описание процесса минификации

    > Вариант 1: параметры минификации передаются через файл-конфиг
      1.  Подготовить сборку. Она должна быть в отдельном js-файле.
      2.  Подготовить конфиг для минификации. Это должен быть отдельный
          JS-файл в определённом формате, содержащий параметры для минификации.
      3.  В консоли перейти в папку с конфигом и выполнить команду:
          - В этом примере имя конфига: "min_config.js".

            r.js.cmd -o min_config.js

    > Вариант 2: параметры минификации передаются в командной строке
      1.  Подготовить сборку. Она должна быть в отдельном js-файле.
      2.  В консоли перейти в папку с конфигом и выполнить команду:
          - В этом примере имя конфига: "min_config.js".

            r.js.cmd -o param1=value1 param2=value2

    > *Примечание:
      - Эти способы можно комбинировать.
      - Приоритет у параметров, переданных через командную строку.


  > Конфиг для минификации

    > Формат конфига

      min_config.js
      -----
          ({

            ... здесь параметры минификации ...

          }}

    > Параметры конфига (некоторые)
      > Весь список и описания можно найти по адресу:
            https://github.com/jrburke/r.js/blob/master/build/example.build.js

      # appDir      // корневой URL, к которому справа добавляется baseUrl
      # baseUrl     // корневой URL, относ.которого разрешаются относительные пути к модулям
        - baseUrl - это добавка справа для его корневого URL
        - Если appDir не указан, а параметры переданы через конфиг.файл,
          то корневой URL для baseDir - папка, в которой лежит конфиг.
        - Если appDir не указан, параметры переданы через консоль, и
          конфиг не передан, то корневой URL для baseDir - текущий
          путь в консоли.

      # name        // путь к сборке, которую надо оптимизировать
      # out         // путь и имя файла, который появится после минификации как результат
      # optimize    // выбор инструмента для минификации
        > Доступны 3 варианта значений (31.01.2014)
          - "uglify"    (по умолчанию)
          - "uglify2"
          - "closure"
        > Рекомендуется использовать uglify2.

      # uglify2     // конфигурационный объект для настройки uglify2





