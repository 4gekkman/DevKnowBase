/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript -> 5. AJAX, Comet
AJAX, Comet

	>




-------------------------------------------------- */










/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


	> Раздел 'AJAX' учебника по JavaScript от Ильи Кантора:
				http://learn.javascript.ru/ajax

	> Спецификация XMLHttpRequest от W3:
				http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method


	> WebSocket - стандарт RFC 6455:
				http://tools.ietf.org/html/rfc6455

	> Ratchet - WebSockets for PHP
				http://socketo.me/

	> Пример работы с WebSocket и Ratchet
				http://habrahabr.ru/post/198954/


	> Реализация WebSocket на PHP с нуля:
				http://habrahabr.ru/post/209864/


*****************************************************
Оглавление:

	> Общая информация
		> Про AJAX
			> Где смотреть доп. информацию об AJAX и COMET?
			> Что такое AJAX?
			> Что можно сделать спомощью AJAX?

		> Про Comet
			> Что такое Comet?
			> Что можно сделать с помощью Comet?
			> Проблемы реализации Comet с PHP на сервере

		> Таблица транспортов

	> Ссылки примеры на AJAX и Comet

	> Реализация AJAX с помощью XMLHttpRequest
		> Основы
			> Что такое XMLHttpRequest (XHR)
			> Методы open, send и abort
			> XHR HTTP-запросы бывают Асинхронные и Синхронные
				> В чем основная разница между асинхронным и синхронным запросами?
				> Асинхронные запросы
					> Как сделать запрос асинхронным?
					> Почему асинхронные запросы труднее обрабатывать, чем синхронные?
					> Пример отправки асинхронного запроса
				> Синхронные запросы
					> Чем плохи синхронные запросы
					> Как сделать запрос синхронным?
					> Пример отправки синхронного запроса
			> Получение HTTP-ответа от сервера
				> Где получать HTTP-ответ?
				> Из чего состоит HTTP-ответ?
				> Как получить HTTP-ответ на синхронный HTTP-запрос?
					> Пример получения тела ответа на синхронный HTTP-запрос.
				> Как получить HTTP-ответ на асинхронный HTTP-запрос?
					> Пример получения тела ответа на асинхронный HTTP-запрос.
				> Получение тела ответа: responseText/responseXML
				> Назначение HTTP-заголовков запросу, получение HTTP-заголовков ответа
			> Кэширование HTTP-ответа браузером
			> Свойство и событие timeout
			> Другие события загрузки
			> Живые примеры
				> Синхронный HTTP-запрос методом GET на сервер
				> Асинхронный HTTP-запрос методом GET на сервер

		> AJAX: в каком формате ждёт он ответ с сервера?
			> Основная информация
			> Какой из вышеуказанных форматов в каком случае лучше выбрать?

		> Оформление тела XRH-запроса перед отправкой его на сервер
			> Зачем нужно оформлять тело запроса перед отпавкой его на сервер?
			> Как сообщить серверу, что это AJAX-запрос?
			> Для оформления тела следует сделать 2 вещи
			> "Автоматические" и "ручные" форматы
			> Формат "по умолчанию" - urlencoded
			> Подробнее о формате x-www-form-urlencoded
				> Общая информация
				> Формирование тела в формате urlencoded для отправки на сервер GET-запросом
				> Формирование тела в формате urlencoded для отправки на сервер POST-запросом
			> Подробнее о формате multipart/form-data
				> Общая информация
				> Как выглядит строка в формате "multipart/form-data"?
				> Как сформировать строку в формате "multipart/form-data"?
					> Общая информация
					> Как сделать это вручную
					> Как сделать это с помощью FormData

		> Получение и парсинг тела XHR-запроса на сервере
			> Общая информация
			> "Автоматические" и "ручные" форматы
			> Получение/парсинг на сервере строки-тела в формате urlencoded
				> Если запрос был методом GET
					> "Автоматическое" получение
					> "Ручное" получение
				> Если запрос был методом POST
					> "Автоматическое" получение
					> "Ручное" получение
			> Получение/парсинг на сервере строки-тела в формате multipart/form-data
				> Если запрос был методом POST (а метод GET с этим форматом не работает)
					> "Автоматическое" получение
					> "Ручное" получение
			> Получение/парсинг на сервере строки-тела в произвольном формате

		> Кросс-доменные XHR-запросы

	> Реализация Comet с помощью XMLHttpRequest (длинные опросы)
		> 2 способа организовать Comet с помощью XMLHttpRequest: частые и длинные опросы
		> О длинных опросах
			> Архитектура длинного опроса
			> Область применения

	> Реализация AJAX через <script>: формат JSONP
		> О формате JSONP
		> Принцип работы SCRIPT-запросов
		> Преимущества script, как AJAX-транспорта
		> Осуществление SCRIPT-запроса методом GET
		> Получение ответа сервера на SCRIPT-запрос
		> Аспекты безопасности
		> Временные именя для callback-функции
		> Обработка ошибок
		> Итого, готовый полный код для работы со SCRIPT-запросами

	> Реализация Comet через <script> (длинные опросы)
		> Осущетвляется также, как описано для XMLHttpRequest

	> WebSocket
		> Общая информация
		> Как работает протокол WebSocket?
		> Как открыть соединение?
		> Как получать ответ от сервера?
		> Как обрабатывать возможные ошибки?
		> Настройка 4-х функций-колбэков объекта WebSocket
		> Как отправить данные на сервер?
		> Поддержка протокола WebSocket на сервере









*****************************************************



> Общая информация

	> Про AJAX

		> Где смотреть доп. информацию об AJAX и Comet?
			> AJAX и Comet я уже описал в своём справочнике по клиентскому
				JavaScript по адресу:

					3. JavaScript ->
					2. Клиентский JS ->
					Клиентский браузерный JS - справочник + оглавление по объектам ->
					AJAX - работа с протоколом HTTP

		> Что такое AJAX?
			> AJAX - Asynchronous Javascript And Xml - технология обращения к серверу
				без перезагрузки страницы.
			> За счет отсутствия перезагрузки страницы уменьшается время отклика, и
				веб-приложение по интерактивности становится похожим на десктопное.
			> Не смотря на наличие в названии слова XML, использовать его нет никакой
				нужды. Под AJAX подразумевается любое общение с сервером без перезагрузки
				страницы, основанное на JavaScript.

		> Что можно сделать спомощью AJAX?

			> Элементы интерфейса
				- Кнопка "подписаться", работающая без перезагрузки страницы.
				- Кнопка "положить в корзину", работающая без перезагрузки страницы.
				- Голосовалка, работающая без перезагрузки страницы.

			> Динамическая подргузка данных
				- Дерево, которое при раскрытии узла запрашивает данные у сервера.

			> Живой поиск
				> Классический пример использования AJAX.
				> Пользователь начинает печатать поисковую фразу, а JS предлагает возможные
					варианты, получая список самых вероятных дополнений с сервера.

			> И т.д., и т.п. элементы, работающие без перезагрузки страницы.

	> Про Comet

		> Что такое Comet?
			> Comet - термин, описывающий различные техники получения данных клиентом
				по инициативе сервера.
			> Можно сказать, что AJAX - это "нажал на кнопку - получил результат",
				а Comet - "просто сижу и наблюдаю за результатами".
			> В настоящий момент технология Comet удобно реализуется во всех
				браузерах.

		> Что можно сделать с помощью Comet?
			- Чат - пользователь сидит и смотрит, что пишут другие. При этом новые
				сообщения приходят "сами по себе", он не должен нажимать на кнопку для
				обновления чата.
			- Аукцион - пользователь смотрит на экран и видит, как обновляется
				текущая ставка на товар.
			- Интерфейс редактирования - когда один пользователь начинает изменять
				документ, другие видят информацию об этом. Возможно совместное
				редактирование, когда редакторы видят изменения друг друга.
			- И так далее.

		> Проблемы реализации Comet с PHP на сервере

			> Проблема:  1 пользователь - 1 процесс
				> Когда пользователь устанавливает comet-соединение с сервером,
					сервер выделяет на это 1 поток, который (в соотв. с архитектурой
					"длинных опросов" не закрывается).
				> А если подключится 500 пользователей, то одновременно сервер
					будет выполнить 500 PHP-потоков.
				> Как следствие:
					- Падение производительности веб-сервера и СУБД.
					- Когда кол-во потоков достигнет максимума, сервер вообще
						перестанет отвечать на какие-либо запросы, и всё умрет.

			> Решение
				> Использовать для Comet-целей не PHP.
				> Например, можно использовать node.js, который запущен в виде
					фонового сервера, и обслуживает все comet-запросы.
				> Вот ссылки на 3 JS-библиотеки, реализующие comet через
					node.js:
					- socket.io
					- cometd.org
					- SockJS library:
								https://github.com/sockjs/sockjs-client


	> Таблица транспортов
		> Есть несколько способов реализации AJAX и Comet. Эти реализации
			иногда называют "транспортами".
		> Всего есть 5 AJAX-транспортов, как показано в таблице ниже.
			Они разнятся по следующим 4-ём основным показателям:
			- Поддержка кросс-доменных запросов.
			- Поддерживаемые методы и протоколы
			- Способ организации Comet
			- Поддержка браузерами


											XMLHttpRequest			iFrame							Script						EventSource				WebSocket
	----------------------------------------------------------------------------------------------------------------------------------------
	Кросс-доменность	|	кроме IE<=9				|	да, слож. в IE<=7	|	да							|	да							|	да
	Методы						|	GET/POST					|	GET/POST					|	GET							|	GET							|	свой протокол
	Comet							|	Длинные опросы		|	непрерыв. соед.		|	длинные опросы	|	непрерыв. соед.	|	непрерыв. соед. в обе стороны
	Поддержка					|	все, огр. в IE<=9	|	все браузеры			|	все браузеры		|	Кроме IE				| IE10, FF11, Chrome16, Safari6, Opera12.5



> Ссылки примеры на AJAX и Comet
	> Все примеры находтся по адресу:

			3. JavaScript ->
			0. Practical samples and techniques ->
			1. AJAX, COMET


> Реализация AJAX с помощью XMLHttpRequest

	> Основы

		> Что такое XMLHttpRequest (XHR)
			> Объект XMLHttpRequest (сокращенно XHR) даёт возможность браузеру
				делать HTTP-запросы к серверу без перезагрузки страницы.
			> Не смотря на 'XML' в названии, объект XMLHttpRequest может работать
				с данными в любом текстовом формате, и даже с бинарными данными.

		> Методы open, send и abort

			> open(method, URL, async, user, password)
				> Задаёт основные параметры запроса:
					- method					| каким методом будет осуществлён запрос:
															- GET
															- POST
															- др. методы
					- URL							| адрес запроса
															> Можно указать эти и другие протоколы:
																- http://
																- https://
																- ftp://
																- file://
															> Также есть ограничение "Same Origin Policy":
																> Запрос со страницы X можно отправлять только
																	на тот же протокол://домен:порт, на которых
																	и базируется эта страница X.
					- async						| позволяет выбрать, как будет происходить запрос:
															- (по умолчанию) если true - запрос производится асинхронно
															- если false - запрос производится синхронно
					- user, password 	| логин и пароль для HTTP-авторизации

			> send(body)
				> Отправляет запрос на сервер.
				> body - это тело запроса.
					> У POST-запроса есть тело, им может быть любая строка. Например:

							send('Привет!');

					> У GET-запроса тела нет, Т.Ч. отправляют либо ничего, либо
						пустую строку, либо null:

							send();
							send('');
							send(null);

			> abort()
				> Прерывает выполнение запроса.

		> XHR HTTP-запросы бывают Асинхронные и Синхронные

			> В чем основная разница между асинхронным и синхронным запросами?
				> Чтобы отправить запрос, вызывают метод send().
				> Затем с сервера должен прийти ответ. Но это займет некоторое
					время. Вот тут то и кроется разница между асинхронным и синхронным
					запросами:
					- При асинхронном запросе, скрипт продолжит выполняться, не дожидаясь
						ответа сервера.
					- При синхронном запросе, скрипт "зависнет", пока ответ с сервера
						не придёт.

			> Асинхронные запросы

				> Как сделать запрос асинхронным?
					> По умолчанию отправка HTTP-запроса неявно происходит в асинхронном
						режиме.
					> Чтобы явно сделать запрос асинхронным, требуется передать
						значение true параметру async метода send().
					> В 99% случаев используют асинхронные запросы.

				> Почему асинхронные запросы труднее обрабатывать, чем синхронные?
					> При синхронном запросе к тому моменту, как начнет выполняться
						следующая после send() строка кода, ответ сервера уже лежит
						в объекте соотв. объекте XMLHttpRequest. И к этому ответу уже
						можно обращаться.
					> А вот при асинхронном запросе ситуация иная. Т.К. при нём
						код после send() продолжает выполняться, не дожидаясь ответа
						сервера, то в большинстве случаев к тому моменту, как весь
						скрипт уже выполнится, ответ сервера еще не придёт, и его
						просто еще не будет в объекте XMLHttpRequest.
						> Т.О. поймать ответ сервера можно будет только в функции-
							обработчике события onreadystatechange. Событие readystatechange
							возбуждается в объекте XMLHttpRequest при каждой смене состояния
							запроса, которое можно получить в св-ве xhr.readyState.

				> Пример отправки асинхронного запроса:

						var xhr = new XMLHttpRequest();
						xhr.open('POST', 'file.php', true);
						xhr.send('Привет!');

			> Синхронные запросы

				> Чем плохи синхронные запросы
					> Страница и весь интерфейс при синхронном запросе могут надолго
						подвисать, что может взбесить пользователей.
						> А если процесс окажется слишком долгим (обычно > 20 секунд),
							то большинство браузеров предложит посетителю "убить" процесс
							с "зависшим" скриптом.
					> Многие продвинутые возможности XMLHttpRequest не работают при
						синхронном запросе. В частности:
						- Не работают кросс-доменные запросы.
						- Нельзя указать таймаут.

				> Как сделать запрос синхронным?
					> Чтобы сделать запрос синхронным, требуется передать значение
						false параметру async метода send().
					> Синхронные запросы в веб-приложениях используют очень редко,
						только в каких-то особых случаях.

				> Пример отправки синхронного запроса:

						var xhr = new XMLHttpRequest();
						xhr.open('POST', 'file.php', false);
						xhr.send('Привет!');

		> Получение HTTP-ответа от сервера

			> Где получать HTTP-ответ?
				> В объекте XHR, с помощью которого был осуществлён запрос -
					в виде его свойств и их значений.

			> Из чего состоит HTTP-ответ?
				> Из 3-х основных частей:
					- Код и текст состояния ответа.
					- Заголовки ответа.
					- Тело ответа.
				> С помощью каких свойств и методов всё это получить из объекта XHR?
					- status								| код состояния   (например: 404)
					- statusText						| текст состояния (например: 'Not Found')
					- getResponceHeader()		| получить заголовок ответа
					- AllResponceHeader()		| получить все заголовки ответа
						> Причем обработка cookies выполняется объектом XMLHttpRequest
							автоматически: он исключает загловки 'Cookie' из множества,
							возвращаемго этим методом. И возвращает null, если передать
							аргумент 'Set-Cookie' или 'Set-Cookie2' методу getResponseHeader().
					- responseText					| тело ответа в текстовом виде
																		> В современных браузерах оно доступно даже
																			до окончания запроса, и содержит текст,
																			полученный к текущему моменту.
					- responseXML						| тело ответа в виде объекта Document
																		> Если ответ пришел с заголовком:
																			"Content-Type: text/xml", то
																			браузер превращает его полноценный
																			XML document (не путать с нашим привычным
																			HTML document).

			> Как получить HTTP-ответ на синхронный HTTP-запрос?
				> При синхронном запросе к тому моменту, как начнет выполняться
					следующая после send() строка кода, ответ сервера уже лежит
					в объекте соотв. объекте XMLHttpRequest. И к этому ответу уже
					можно обращаться.
				> Т.О. можно сразу после вызова send(), хоть в следующей строке,
					обращаться к вышеуказанным св-вам и методам объекта XHR, и получать
					нужные компоненты ответа.
				> Пример получения тела ответа на синхронный HTTP-запрос:

					Сделать синхронный HTTP-запрос:
					-----
						var xhr = new XMLHttpRequest();
						xhr.open('POST', 'file.php', false);
						xhr.send('Привет!');

					... Ответ уже лежит в xhr, можно получать:
					-----
						var body = xhr.responseText;


			> Как получить HTTP-ответ на асинхронный HTTP-запрос?
				> Т.К. JS-код после вызова send() продолжает выполняться,
					не дожидаясь ответа сервера, то в большинстве случаев к тому
					моменту, как весь скрипт уже выполнится, ответ сервера еще не
					придёт, и его просто напросто еще не будет в объекте XHR.
					И соответствующие свойства и методы будут возвращать пустоту.
				> Поэтому надо сначала дождаться, пока в XHR придёт ответ с сервера,
					а уже после этого обращаться к этому самому ответу. Но как узнать,
					что ответ уже пришел?
				> В этом нам помогут событие readystatechange и свойство xhr.readyState.

					> О xhr.readyState
						> В этом свойстве лежит текущее состояние запроса.
						> Оно может принимать 5 возможных значений, от 0 до 4:
							- 0		| запрос еще не отправлен
							- 1		| запрос отправлен с помощью send()
							- 2		| получены заголовки ответа
							- 3		| загружается тело ответа
							- 4		| запрос завершён
						> Но! Учти, что когда запрос будет завершен (xhr.readyState == 4),
							то он может быть завершен как успешно, так и неудачно. Проверить
							это можно получив код статуса ответа.

					> О readystatechange
						> Это событие должно возбуждаться в объекте xhr каждый раз, когда
							изменяется его состояние в xhr.readyState.
						> Однако, надёжно и кроссбраузерно работает только последнее
							состояние: 4 (запрос завершен)
							> Остальные состояния:
								- В Firefox работают хорошо
								- В IE, Старой Opera не работают, браузеры пропускают состояни.
								- В Chrome частично работают, но браузер буферизует ответ,
									вызывая onreadystatechange, как только получен достаточно
									большой пакет данных.

				> Пример получения тела ответа на асинхронный HTTP-запрос.
					> Вот как выглядит функция-обработчик события readystatechange,
						позволяющая надёжно получить и обработать HTTP-ответ на асинхронный
						HTTP-запрос:

						Сделать асинхронный HTTP-запрос:
						-----
							var xhr = new XMLHttpRequest();
							xhr.open('POST', 'file.php', true);
							xhr.send('Привет!');

						... Получить ответ можно будет, когда сработает событие readystatechange
								со статусом xhr.readyState == 4:
						-----
							xhr.onreadystatechange = function() {
								if (xhr.readyState != 4) return; // запрос ещё не завершён

								... здесь можно получить HTTP-ответ, обработать
										завершение запроса, проверить ошибки 					...

							}

			> Получение тела ответа: responseText/responseXML
				> Получить тело ответа можно с помощью следующих свойств:
					- xhr.responseText
					- xhr.responseXML
				> Подробнее о responseText
					> Это строка. Либо в каком-нибудь формате (например, JSON), либо
						просто обычный текст.
					> В современных браузерах оно доступно даже до окончания запроса,
						и содержит текст, полученный к текущему моменту.
				> Подробнее о responseXML
					> Если ответ пришел с заголовком "Content-Type: text/xml", то
						браузер превращает его в полноценный XML-документ.
					> Т.Е. ответ поступает в виде XML-документа.

			> Назначение HTTP-заголовков запросу, получение HTTP-заголовков ответа
				> Для работы с заголовками у объекта xhr есть 3 метода:
					- setRequestHeader(name, value)	| установить заголовок с именем name и значением value
																						(перед отправкой запроса)
					- getResponseHeader(name)				| получить значение заголовка с именем name
					- getAllResponseHeaders()				| получтиь строку со всеми заголовками
																						> Кроме Set-Cookie и Set-Cookie2
				> Подробнее о setRequestHeader(name, value)
					> Установить объекту XHR HTTP-заголовок с именем name и значением
						value, который будет отправлен вместе с HTTP-запросом.
					> Заголовков можно установить сколько угодно.
					> Если заголовок с таким name уже есть - он заменяется.
					> Нельзя установить заголовки, которые контролирует браузер,
						например Referer или Host, и ряд других.
					> Особенностью XMLHttpRequest является то, что нельзя отменить
						заголовок, установленный с помощью метода setRequestHeader.
						> Повторные вызовы добавляют информацию к заголовку:

								xhr.setRequestHeader('X-Auth', '123');
								xhr.setRequestHeader('X-Auth', '456');

								// в результате будет заголовок:
								// X-Auth: 123, 456

					> Пример использования:

							xhr.setRequestHeader(	'Content-Type',
																		'application/x-www-form-urlencoded');

				> Подробнее о getResponseHeader(name)
					> Возвращает значение value заголовка HTTP-ответа с именем name.
					> Пример использования:

							if(xhr.getResponseHeader('Content-Type') == 'text/plain') {

							}

				> Подробнее о getAllResponseHeaders()
					> Возвращает все заголовки ответа.
					> Кроме "Set-Coolie" и "Set-Coolie2".
					> Заголовки возвращаются в виде единой строки.
						> Каждая пара имя/значение отделена друг от друга символами
							"\r\n" (в данном случае не зависит от ОС).
						> Пример такой строки:

								 "Cache-Control: max-age=31536000\r\n
									Content-Length: 4260\r\n
									Content-Type: image/png\r\n
									Date: Sat, 08 Sep 2012 16:53:16 GMT\r\n"

						> Т.О. чтобы получить объект с парами заголовок/значение, то
							вышеприведенную строку надо разбить и обработать.


		> Кэширование HTTP-ответа браузером

			> В XHR кэширование работает не корректно
				> Поэтому от него надо избавлятсья.
				> При кэшировании XHR многие заголовки игнорируются или работают
					некорректно, поэтому полагаться на них не следует. Это касается:
					- Cache-Control
					- Last-Modified
					- Expires
					- и другие, по этой ссылке есть набор онлайн-тестов:
							http://www.mnot.net/javascript/xmlhttprequest/cache.html

			> Описание проблемы
				> Ответ на XHR-запрос может быть закэширован браузером.
				> Некоторые браузеры автоматически делают это. Например:
					- IE <= 9.
				> Т.О. повторные запросы осуществляться не будут, а вместо этого
					информация будет браться из кэша.
					> В 99% случаев нам это будет не нужно. В этом и состоит проблема.

			> Решение - вариант 1.
				> Сервер в ответ на XHR-запросы должен посылать HTTP-заголовки,
					запрещающие кэширование браузеру. А именно:

						"Cache-Control: no-store, no-cache, must-revalidate"

			> Решение - вариант 2.
				> Можно добавить в URL запроса случайный параметр, предотвращающий
					кэширование. Например:

						xhr.open('GET', '/xhr/vote?r=' + Math.random())


		> Свойство и событие timeout
			> Максимальную продолжительность запроса в миллисекундах можно
				задать с помощью свойства xhr.timeout.
			> При привышении этого времени запрос будет оборван, и у объекта
				xhr будет сгенерировано событие timeout.
			> Эта возможность не работает в IE<=7.
			> Пример:

				Установить MAX продолжительность запроса в мс:
				-----
					xhr.timeout = 30000;

				Функция-обработчик, сработает в случае "таймаута" запроса:
				-----
					xhr.ontimeout = function() {
						console.log('запрос превысил максимальное время');
					};


		> Другие события загрузки
			> Частично поддерживаются в IE<=9.
			> Полностью поддерживаются с IE>=10.
			> События:
				- onerror				| ошибка при выполнении запроса
				- onload				| запрос успешно завершен
				- onprogress		| браузер получил очередной пакет данных, можно
													прочитать текущие полученные данные в responseText
				- onabort				| запрос отменен вызовом abort()
				- onloadstart		| запрос начат
				- onloadend			| запрос окончен, возможно с ошибкой


		> Живые примеры
			> Синхронный HTTP-запрос методом GET на сервер
				> В этом примере при нажатии на кнопку осуществляется синхронный
					HTTP-запрос на сервер с помощью объекта XHR методом GET.
					А именно - запрос производитсяк PHP-скрипту.
				> В теле ответа сервер присылает строку с серверным временем.
				> Эта строка выводится у клиента в качестве текста кнопки.
				> Для демонстрации "зависания" скрипта во время ожидани ответа
					на синхронный запрос, сервер намеренно делате задержку в 3 секунды
					перед отправкой ответа. А скрипт замеряет эту задержку и выводит
					её на экран после запроса.
				> Ссылка на живой рабочий пример:

						3. JavaScript ->
						0. Practical samples and techniques ->
						1. AJAX, COMET ->
						1. Sync XHR-request


			> Асинхронный HTTP-запрос методом GET на сервер
				> В этом примере при нажатии на кнопку осуществляется асинхронный
					HTTP-запрос на сервер с помощью объекта XHR методом GET.
					А именно - запрос производитсяк PHP-скрипту.
				> В теле ответа сервер присылает строку с серверным временем.
				> Эта строка выводится у клиента в качестве текста кнопки.
				> Ссылка на живой рабочий пример:

						3. JavaScript ->
						0. Practical samples and techniques ->
						1. AJAX, COMET ->
						1. Async XHR-request


	> AJAX: в каком формате ждёт он ответ с сервера?

		> Основная информация
			> В любом случае, в ответе с сервера клиенту передается текстовая
				строка, которая и содержит полезную информационную нагрузку.
				Получить эту строку можно в объекте XMLHttpRequest, который и
				посылал запрос:

				Вывести на экран строку-тело ответа сервера:
				-----
					console.log(xhr.responseText);

			> Эта текстовая строка может быть представлена абсолютно в любом
				формате, коих придумать можно бесконечное множество. Потому что
				в отличие от PHP, в JS в каком бы формате не поступила строка
				responseText, программисту придётся парсить её вручную.
			> Вот 3 наиболее распространённых формата:
				- Текст / HTML
				- XML
				- JSON

		> Какой из вышеуказанных форматов в каком случае лучше выбрать?
			По наблюдениям Ильи Кантора:
			- HTML 		| когда надо ответ с сервера просто внедрить в документ, тогда
									формат HTML то что надо.
			- JSON		| когда надо передать массив каких-то данных, то JSON один
									из лучших вариантов
			- XML			| > когда надо выбрать и отобразить большое кол-во данных,
										XML+XSLT работает быстрее, чем JS-шаблонизатор.
									> XML является стандартом для многих приложений, и при
										взаимодействии с ними придётся работать с XML.


	> Оформление тела XRH-запроса перед отправкой его на сервер

		> Зачем нужно оформлять тело запроса перед отпавкой его на сервер?
			> От того, в каком формате оформлено тело, зависит то, каким способом
				при получении на сервере его надо будет распарсить и извлечь
				из него информацию.

		> Как сообщить серверу, что это AJAX-запрос?
			> Иногда серверу полезно знать, что за запрос он получил: AJAX
				или НЕ AJAX.
			> В зависимости от этого сервер может и отвечать по разному. И тогда
				получается, что 1 серверный файл (например, server.php) может как
				отвечать на AJAX-запросы, так и формировать HTML-документ.
			> Можно придумать много способов сообщать серверу, что это AJAX-запрос.
				Но есть один, который использует большинство фреймворков и программистов.
				Он приведён ниже.
			> Итак, сказать серверу о том, что это AJAX-запрос, можно, отправив
				следующий HTTP-заголовок:

					xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");

				> Сервер может у себя в коде проверять этот заголовок, и по результатам
					проверки принимать решение, AJAX это запрос, или НЕ AJAX.

		> Для оформления тела следует сделать 2 вещи:
			- Выбрать формат и привести строку тела запроса к этому формату.
			- Добавить в запрос HTTP-заголовок, сообщающий серверу, в каком
				формате к нему придёт тело.

		> "Автоматические" и "ручные" форматы
			> Все форматы можно разделить на 2 группы - в зависимости от того,
				при получении тела в таком формате, сможет ли сервер "автоматически"
				распарсить его, или программисту придётся делать это "вручную".
			> Дело в том, что PHP, в отличие от JS, может автоматически распарсить
				и распихать по суперглобальным массивам $_GET, $_POST, $_FILES
				2 нижеуказанных формата. А вот если тело в любом другом формате,
				то программист должен парсить его вручную.
			> К "автоматическим" форматам относятся:
				- x-www-form-urlencoded
				- multipart/form-data
			> К "ручным" форматам относятся все остальные:
				- text/plain
				- application/json
				- и т.д.

		> Формат "по умолчанию" - urlencoded
			> Форматом "по умолчанию" является "x-www-form-urlencoded".
			> Это значит, что если при формировании XHR-запроса не указать
				никаких заголовков, сообщающих серверу о том, в каком формате
				к нему отправляется тело, то по умолчанию будет указан заголовок
				"x-www-form-urlencoded".
			> А вот если требуется отправить тело на сервер в каком-нибудь
				другом формате, то соответствующий заголовок требуется указать
				обязательно.
				Например, если мы хотим отправить на сервер строку-тело в формате
				text/plain, то надо указато такой заголовок::

					xhr.setRequestHeader(	'Content-Type',
																'text/plain;charset=UTF-8');

		> Подробнее о формате x-www-form-urlencoded

			> Общая информация
				> Это формат "по умолчанию" для всех запросов.
				> В этом формате:
					- Пробел кодируется, как: %20
					- Русские буквы и большинство спецсимволов тоже кодируются.
					- Английские буквы и дефис оставляются как есть.
					- Пары параметр/значения отделены друг от друга символом "&"
				> Подробно о формае urlencoded можно прочитать по ссылке:
						http://www.w3schools.com/tags/ref_urlencode.asp
				> В HTML-атрибуте form формат urlencoded также является форматом
					"по умолчанию". Например, во всех представленных ниже случаях
					будет использована кодировка urlencoded:

						<form method="get">  метод GET с кодировкой по умолчанию
						<form method="post"> метод POST с кодировкой по умолчанию
						<form method="post" enctype="application/x-www-form-urlencoded">

				> Примеры строк, закодированных в формате urlencoded:

					Вот простой для восприятия пример только с английскими символами:
					-----
						"name=ivan&age=18"

					А вот так будет выглядеть строка "name=Виктор&surname=Цой":
					-----
						"name=%D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80&surname=%D0%A6%D0%BE%D0%B9"

			> Формирование тела в формате urlencoded для отправки на сервер GET-запросом
				1. Допустим, нам надо отправить на сервер следующие данные:

						var name = "Иван";
						var surname = "Петров";

				2. Сформируем из них тело для GET запроса в формате urlencoded.
					 Для этого нам потребуется кодировать значения с помощью
					 функции encodeURIComponent:

						var body = 'name=' + encodeURIComponent(name) + '&' +
											 'surname=' + encodeURIComponent(surname);

		    3. И теперь можно отправить тело из п.2 на сервер, делав XHR-запрос
		    	 на сервер методом GET (тело отправляется, как query string):

		    	 	var xhr = new XMLHttpRequest();
		    	 	xhr.open('GET', 'server.php' + '?' + body, true);		// !! Ключевой момент !!
		    	 	xhr.onreadystatechange = function(event) {
		    	 		... здесь обработать ответ ...
		    	 	};
		    	 	xhr.send('');


			> Формирование тела в формате urlencoded для отправки на сервер POST-запросом
				1. Допустим, нам надо отправить на сервер следующие данные:

						var name = "Иван";
						var surname = "Петров";

				2. Сформируем из них тело для POST запроса в формате urlencoded.
					 Для этого нам потребуется кодировать значения с помощью
					 функции encodeURIComponent:

						var body = 'name=' + encodeURIComponent(name) + '&' +
											 'surname=' + encodeURIComponent(surname);

		    3. И теперь можно отправить тело из п.2, сделав XHR-запрос
		    	 на сервер методом GET (тело отправляется в теле запроса):

		    	 	var xhr = new XMLHttpRequest();
		    	 	xhr.open('POST', 'server.php', true);
		    	 	xhr.onreadystatechange = function(event) {
		    	 		... здесь обработать ответ ...
		    	 	};
		    	 	xhr.send(body);		// !! Ключевой момент !!


		> Подробнее о формате multipart/form-data

			> Общая информация
			  > Формат "multipart/form-data" сложнее, чем urlencoded.
			  > Данные в формате "multipart/form-data" могут быть отправлены
			  	только методом POST, и НЕ могут быть отправлены методом GET.
			  > Преимущество формата "multipart/form-data" перед urlencoded в том,
			  	что с его помощью можно передавать также и файлы, который пользователь
			  	загрузил через форму.
			  	> Именно поэтому при наличии в форме возможности загрузить файл,
			  		всегду указывают следующие значения в атрибутах method и enctype:

			  			<form method="post" enctype="multipart/form-data">

			> Как выглядит строка в формате "multipart/form-data"?
				- Как показано в примере ниже.
				- Поля разделены случайно сгенерированной строкой boundary.
				- Само содержимое полей остаётся "как есть", поэтому такой формат
					и используется в 1-ю очередь для пересылки файла.

						...Заголовки...
						Content-Type: multipart/form-data; boundary=RaNdOmDeLiMiTeR

						--RaNdOmDeLiMiTeR
						Content-Disposition: form-data; name="name"

						Виктор
						--RaNdOmDeLiMiTeR
						Content-Disposition: form-data; name="surname"

						Цой
						--RaNdOmDeLiMiTeR--


			> Как сформировать строку в формате "multipart/form-data"?

				> Общая информация
					> Выше нам легко удалось вручную сформировать строку в формате
						urlencoded. Можно ли подобным образом сформировать строку
						с формате "multipart/form-data"?
						> Да, можно. Но, но достаточно трудоёмко.
					> Итак, сформировать строку в формате "multipart/form-data"
						можно 3-мя способами:
						- Автоматически при заполнении пользователем формы.
						- Вручную.
						- С помощью объекта FormData (новая возможность).

				> Как сделать это вручную:
					1. Допустим, нам надо отправить на сервер вот эти данные:

							var data = {
								name: 'Виктор';
								surname: 'Цой'
							};

					2.  Сформируем строку тела запроса в формате "multipart/form-data":

							// Формирование boundary
								// Формируем случайное числовое значение для boundary
								var boundary = String( Math.random() ).slice(2);

								// Формируем среднюю часть boundary
								var boundaryMiddle = '--' + boundary + '\r\n';

								// Формируем заключительную часть boundary
								var boundaryEnd = '--' + boundary + '--\r\n';

							// Формирование тела в виде массива

								var body = ['\r\n'];
								for( var key in data ) {

									// Добавление поля
									body.push('Content-Disposition: form-data; name=' + key +
														'\r\n\r\n'+data[key]+'\r\n');

								}

								// Добавить файл (его код должен быть доступен JS-у) в body
								// можно так:

									body.push('Content-Disposition: form-data; ' +
														'name="'+key+'"; ' +
														'filename="pic.jpg"\r\n' +
														'Content-Type: image/jpeg\r\n\r\n'+data[key]+'\r\n');

							// Соединить все эл-ты массива в строку с разделителем
							// boundaryMiddle, а в конце добавить boundaryEnd
								body = body.join(boundaryMiddle) + boundaryEnd;

					3. И теперь можно отправить тело из п.2, сделав XHR-запрос
						 на сервер методом POST
						 - При этом тело-строку отправляем в теле запроса
						 - Указываем HTTP-заголовок "multipart/form-data" и в нём
						 	 использованное значение boundary.

								var xhr = new XMLHttpRequest();
								xhr.open('POST', '/submit', true);
								xhr.setRequestHeader('Content-Type','multipart/form-data; boundary=' + boundary);
								xhr.onreadystatechange = function() {
									if (this.readyState != 4) return;

									console.lgo(this.responseText);
								}

								xhr.send(body);

				> Как сделать это с помощью FormData:
					> Интерфейс FormData появился в спецификации XHR2.
					> FormData - это объект, который позволяет объединить несколько
						кусков данных в 1, в формате "multipart/form-data".
					> И этот самый итоговый объект можно передать при осуществлении
						XHR-запроса методом POST методу send в качестве тела запроса.
					> Пример:

							// подготовка данных к отправке
							var f = new FormData();
							f.append('1 кусок');
							f.append('2 кусок');
							f.append('3 кусок');

							// отправка данных в теле AJAX-запроса методом POST
							var xhr = new XMLHttpRequest();
							xhr.open('POST', url);
							xhr.setRequestHeader('Content-Type', 'multipart/form-data');
							xhr.send(f);

					> Причём заголовок Content-Type можно вручную не устанавливать,
						поскольку метод send, когда ему передается объект FormData,
						сам автоматически его устанавливает.


	> Получение и парсинг тела XHR-запроса на сервере

		> Общая информация
			> В этом описании предполагается, что на серверной стороне
				используется язык PHP.
			> Все примеры серверного кода также будут опираться на это
				предположение.

		> "Автоматические" и "ручные" форматы
			> Все форматы можно разделить на 2 группы - в зависимости от того,
				при получении тела в таком формате, сможет ли сервер "автоматически"
				распарсить его, или программисту придётся делать это "вручную".
			> Дело в том, что PHP, в отличие от JS, может автоматически распарсить
				и распихать по суперглобальным массивам $_GET, $_POST, $_FILES
				2 нижеуказанных формата. А вот если тело в любом другом формате,
				то программист должен парсить его вручную.
			> К "автоматическим" форматам относятся:
				- x-www-form-urlencoded
				- multipart/form-data
			> К "ручным" форматам относятся все остальные:
				- text/plain
				- application/json
				- и т.д.

		> Получение/парсинг на сервере строки-тела в формате urlencoded

			> Если запрос был методом GET

				> "Автоматическое" получение
					> PHP автоматически распарсит полученную строку-тело в формате
						urlencoded, и запихнет пары параметр/значение в суперглобальный
						массив $_GET.
					> В нём они будут доступны по ключам, совпадающим с именами полученных
						параметров.
					> Пример:

						Допустим, пришла на сервер такая строка:
						-----
							"name=John&surname=Smith"

						На сервере получить доступ к к указанным значениям можно так:
						-----
							$name = $_GET['name'];
							$surname = $_GET['surname'];

				> "Ручное" получение
					> Если по какой-то причине понадобится получить и распарсить
						строку-тело вручную, то это можно сделать так:

						Допустим, пришла на сервер такая строка:
						-----
							"name=John&surname=Smith"

						Сначала извлечём query string - которая и есть переданное тело-строка
						-----
							$body = $_SERVER['QUERY_STRING'];

						Теперь надо к каждому значению в $body применить ф-ию urldecode,
						чтобы перевести его из формата urlencoded в обычный текстовый
						-----
							$decoded_body;			// это будет массив имя/значение декодированных параметров из $body


							// Разбить $body на массив пар "имя=значение" с разд. '&' $body,
							// в нашем случае в итоге получится всего всего 2 эл-та:
							// [0]: 'name=John'
							// [1]: 'surname=Smith'
							$body_array_pare = explode('&', $body);


							// Пройтись циклом по эл-там $body_array_pare
							foreach($body_array_pare as $pare) {


								// Каждый из эл-тов массива $body_array_pare также разбивается
								// на массив с разделителем '=', и таким образом отделяются имя параметра
								// от его значения, что позволяет:
								// - Применить к значению функцию urldecode
								// - Сохранить пары имя/декодированное_значение в $decoded_body
								$body_array_param = explode('=', $pare);

								// Если в нём что-то есть, записать пару имя/декодированное_значение в $decoded_body
								if($body_array_param) {
									$decoded_body[$body_array_param[0]] = urldecode($body_array_param[1]);
								}

							}


			> Если запрос был методом POST

				> "Автоматическое" получение
					> Тоже самое, что для запроса методом GET, но с 1-им отличием:
						заселён будет не $_GET, а вместо него суперглобальный массив
						$_POST.

				> "Ручное" получение
					> Тоже самое, что для запроса методом GET, но с 1-им исключением (ниже).
					> В POST-запросе строка-тело передаётся на сервер не в query string,
						а в теле запроса. Т.О. и получать её надо не в query string.
						А где?
					> Есть 2 варианта, где можно получить эти необработанные POST-данные:
						- Прямо из входного буфера:

								$body = file_get_contents('php://input');

						- Из переменной $HTTP_RAW_POST_DATA
							(но только если в php.ini директива always_populate_raw_post_data = true)

								$body = $HTTP_RAW_POST_DATA;

		> Получение/парсинг на сервере строки-тела в формате multipart/form-data

			> Если запрос был методом POST (а метод GET с этим форматом не работает)

				> "Автоматическое" получение
					> PHP автоматически распарсит полученную строку-тело в формате
						multipart/form-data, и запихнет пары параметр/значение в
						суперглобальный массив $_POST, а файлы (если таковые тоже
						имелись в теле), запихнет в суперглобальный массив $_FILES.
					> Переданные значения будут доступны в массиве $_POST по ключам,
						совпадающим с именами параметров.
					> Переданные файлы будут доступны в массиве $_FILES аналогично,
					 	по имени параметра, в котором лежал файл. А это имя он может
					 	получить 2-мя способами:
						- Если перед отправкой запроса тело было подготовлено автоматически,
							при заполнении пользователем формы, то имя параметра, по которому
							будет досутпен файл в $_FILES - будет значением атрибута name
							HTML-элемента <input type='file'>, через который и был загружен
							этот файл.
						- Если же перед отправкой запроса его тело формировалось программистом
							вручную, то тут уже какое имя он присвоил параметру с файлом в
							своём коде, такое оно и будет.
					> Пример кода здесь приводить не буду, потому что вы можете обратиться
						к примерам выше - для urlencoded (методом POST).


				> "Ручное" получение
					> Можно получить строку с необработанными POST-данными точно
						таким же образом, как это описано выше, где речь идет о
						получении строки-тела в формате urlencoded.
					> После этого, воспользовавшись описанным выше пунктом:
						"Как сформировать строку в формате "multipart/form-data"?",
						можно написать код, который распарсит эту строку, и извлечёт
						все необходимые данные.
					> Напоминаю, что данные в строке этого формата никак не шифруются,
					 	поэтому надо просто эту строку распарсить и просто их извлечь.
					> Здесь конкретный код пока за ненадобностью не приводится, но если
						вдруг он понадобится, то его легко можно найти в интернете или
						написать самому, и заменить им вот этот абзац.


		> Получение/парсинг на сервере строки-тела в произвольном формате
			> В этом случае речи об "автоматическом" парсинге не идёт.
			> Общая архитектура решения такова:
				1. Получить необработанные POST-данные. Как это сделать описано
					 в примерах для urlencoded выше.
				2. Узнать, в каком формате пришли данные. Тут возможны варианты:
					 - Если ты сам программируешь и клиентскую, и серверную части,
					 	 то ты и так знаешь, в каком формате оно пришло. Но даже в этом
					 	 случае не поленись послать заголовок 'Content-Type' с верным значением.
					 - Если клиентскую часть программировал не ты, то ты можешь на удачу
					 	 проверить, что указано в HTTP-заголовке 'Content-Type', и попробовать
					 	 распарсить данные в соответствии с ним. Или заглянуть в код клиента.
					 	 Или спросить у того, кто программировал клиента. Короче, надо это узнать.
				3. Зная формат (п.2), распарсить полученные в п.1 данные, извлечь и
					 структурировать информацию.
			> Пример получения/парсинга JSON-строки
				> Допустим, нам надо получить и распарсить JSON-строку. И мы заранее знаем,
					что формат строки-тела в запросе будет именно JSON.
				> Вот, как может выглядеть серверная часть:

					// Получить необработанные POST-данные (а мы знаем, что это JSON-строка)
					$body = file_get_contents('php://input');

					// Преобразовать JSON-строку в массив ключ/значение:
					// - Воспользоваться функцией json_decode, чтобы это сделать
					$body_array = json_decode($input,true);

					... всё, данные извлечены, делай с ними что хочешь ...


	> Кросс-доменные XHR-запросы

		> Краткая общая информация
			> IE <= 9 ограниченно поддерживает XMLHttpRequest.
			> А именно, в IE <= 9 используется XDomainRequest, представляющий
				собой урезанный XMLHttpRequest.
			> Поэтому чтобы не париться, на практике кроссдоменные XHR-запросы
				используют редко, предпочитая иные способы.

		> Итог:
			- Для кроссдоменных запросов лучше не использовать XHR-запросы.
			- Лучше использовать либо SCRIPT-запросы (если нужна поддержка
				старых браузеров), либо WebSockets (без поддержки старых браузеров,
				но зато очень удобно пользоваться0.


> Реализация Comet с помощью XMLHttpRequest (длинные опросы)

	> 2 способа организовать Comet с помощью XMLHttpRequest: частые и длинные опросы

		> Архитектуру Comet с помощью объекта XMLHttpRequest можно организовать
			2-мя способами:
			- Частые опросы
			- Длинные опросы

		> О частых опросах
			> Такой подход используют редко из-за его недостатков (см. ниже).
				Только в особых случаях.
			> Суть - периодически посылать на сервер запрос в стиле:
				"Эй, изменилось что-нибудь?". Например, 1 раз в 10 секунд.
			> В ответ сервер:
				- Помечает у себя, что клиент онлайн.
				- Посылает клиенту сообщение, в котором содержится информация
					обо всех произошедших изменениях.
			> Ключевые проблемы такого подхода
				1. Задержка
					> В больших задержках между наступлением изменений на сервере
						и тем моментом, когда о них узнаёт клиент.
					> Например, если сделать чат на этой технологии, с опросом 1 раз
						в 10 секунд, то после того, как пользователь X отправит сообщение,
						остальным придётся ждать до 10 секунд прежде, чем они его увидят.
				2. Трафик
					> Много лишнего (холостого) трафика.
				3. Гигантская нагрузка на сервер
					> Если даже клиент ушёл пить чай, его браузер продолжает "долбить"
						сервер запросами (напр., 1 раз в 10 секунд)
					> А что, если таких клиентов много? Сотни, тысячи, десятки тысяч?

		> О длинных опросах

			> Архитектура длинного опроса:
				1. Клиент отправляет запрос на сервер.
				2. Сервер НЕ закрывает соединение, пока не появится сообщение.
				3. Когда появляется сообщение, сервер посылает его клиенту, и
					 закрывает соединение.
					 > Если соединение рвётся само (напр., закрыто прокси-сервером), то
						 клиент тут же посылает новый запрос.
				4. Клиент получает сообщение, и тут же открывает новое, т.е. делает
					 новый запрос.

			> Область применения
				> Такой подход подходит в 90% случаев, когда требуется организация
					Comet-архитектуры.
				> При каких условиях стоит применять такой подход?
					> Когда сообщения приходят редко.
					> Например:
						- Чат
				> При каких условиях НЕ стоит применять такой подход?
					> Когда сообщения приходят очень часто.
					> Причина: каждое сообщение - это отдельный запрос. Каждый запрос
						имеет накладные расходы. Поэтому не выгодно для каждой крупицы
						информации создавать новый запрос, это:
						- Увеличивает нагрузку на сервер.
						- Создаёт лишний трафик.
					> В таких условиях лучше использовать другой AJAX-транспорт,
						с помощью которого можно установить с сервером постоянное
						соединение. Т.Е. один из остальных 4-х транспортов:
						- iFrame
						- Script
						- EventSource
						- WebSocket


> Реализация AJAX через <script>: формат JSONP

	> О формате JSONP
		- JSONP - формат запроса, в котором ответ в формате JSON заворачивается
			в callback-функцию.

	> Принцип работы SCRIPT-запросов
		> Если создать узел script со ссылкой на внешний источник, то
			при добавлении этого узла в документ клиент пошлёт серверу запрос
			методом GET (SCRIPT-запрос может быть отправлен только методом GET).
		> Запрос будет отправлен по адресу, указаному в атрибуте src
			HTML-элемента script. Например:

				<script src="server.php?id=123"></script>

			В этом запросе есть query string = 'id=123'

		> В ответ сервер может прислать JS-скрипт, содержащий нужные данные.


	> Преимущества script, как AJAX-транспорта
		> Кроссбраузерность - этот способ поддерживают все, даже старые браузеры.
		> Кроссдоменность - не действует политика "same origin policy".


	> Осуществление SCRIPT-запроса методом GET:

			// Функция, осуществляющая SCRIPT-запрос методом GET
			// - src - адрес запроса
			// - qu - подготовленная query string запроса в формате URLEncoded
			var attachScript = function(url, qs) {

				// Создать HTML-элемент SCRIPT
				var element = document.createElement('script');

				// Назначить его атруибуту src адрес url
				element.src = url + '?' + qs;

				// Вставить созданный эл-т в элемент HEAD документа
				document.getElementByTagName('head')[0].appendChild(element);

			}

			// Осуществить запрос к server.php
			attachScript('server.php', '');


	> Получение ответа сервера на SCRIPT-запрос
		> Происходит оно в 3 этапа:
			1. Подготовить функцию с именем X, которая принимает 1 аргумент -
				 JS-объект.
			2. При осуществлении SCRIPT-запроса передать одним из аргументов
				 имя функции из п.1
			3. Сервер в ответ пришлёт JS-код, в котором:
				 - Осуществляется вызов функции с именем X.
				 - Она вызывается с аргументом - JS-объектом, который содержит
				 	 те данные, которые сервер хотел передать клиенту.
		> Пример:

			1. Подготовим callback-функцию:
			-----
				var myFunction = function(object) {
					... здесь что-то делаем с object ...
				}

			2. Осуществим SCRIPT-запрос к серверу
				 - В реальном мире надо еще будет закодировать query string в формат
				   URLEncoeded, но в этом примере для простоты это опущено, да и
				   здесь в QS используются только английские символы и цифры, так
				   что здесь кодирование не требуется
			-----
				attachScript('server.php', 'id=123&callback=myFunction');

			3. Сервер в качестве ответа присылает нижеуказанную строку, в результате
				 чего callback-функция из п.1. срабатывает, и клиент получает данные:

					 "myFunction({
							name: "Вася",
							age: 25,
							isAdmin: false
						});"


	> Аспекты безопасности

		> 2 основных аспакта
			- При кросс-доменном получении ответа-скрипта JavaScript не имеет
				доступа к его тексту.
			- Клиенту, который использует SCRIPT-запросы, приходится доверять
				серверу. Ведь последний может прислать клиенту абсолютно любой
				скрипт, который тут же выполнится, и это очень опасно.

		> Итого о безопасности SCRIPT-запросов
			> Использовать можно только при 100%-м доверии серверу.


	> Временные именя для callback-функции

		> Описание проблемы
			> Имя callback-функции должно быть глобальным, иначе HTML-элемент
				script её не увидит.
			> Иногда надо осуществлять много SCRIPT-запросов. И для каждого
				надо создавать отдельную функцию, засоряя глобальное пространство
				имён.

		> Решение проблемы
			> Автоматически генерировать уникальное имя (имя + номер) для
				callback-функции.
			> Удалять callback-функцию (очищать память) после исполнения её
				своего долга.
			> Пример:


	> Обработка ошибок

		> При SCRIPT-запросе возможные следующие ошибки:
			- Скрипт может не загрузиться: отказ в соединении, разрыв связи…
			- Ошибка HTTP, например 500.
			- Скрипт загрузился, но внутри некорректен и не вызывает функцию.
				Например, на сервере произошла ошибка и в ответе передан её текст,
				а вовсе не данные.

		> Алгоритм отлова всех ошибок "одним махом":
			1. Назначить эл-ту script обработчики ошибок:
			 	 - onload/onerror (для современных браузеров)
			 	 - onreadystatechange (для старых IE)
			2. В callback-функцию добавить переключение переменной-флага.
			3. И дальше её проверить:
				 - Если флаг был включён, значит ответ с сервера получен, т.к.
				 	 callback-функция выполнена.
				 - Если флаг НЕ был включён, значит ответа с сервера нет из-за
				 	 какой-то ошибки.


	> Итого, готовый полный код для работы со SCRIPT-запросами


			var CallbackRegistry = {}; // реестр

			// при успехе вызовет onSuccess, при ошибке onError
			function scriptRequest(url, onSuccess, onError) {

				var scriptOk = false; // флаг, что вызов прошел успешно

				// сгенерировать имя JSONP-функции для запроса
				var callbackName = 'f'+String(Math.random()).slice(2);

				// укажем это имя в URL запроса
				url += ~url.indexOf('?') ? '&' : '?';
				url += 'callback=CallbackRegistry.'+callbackName;

				// ..и создадим саму функцию в реестре
				CallbackRegistry[callbackName] = function(data) {
					scriptOk = true; // обработчик вызвался, указать что всё ок
					delete CallbackRegistry[callbackName]; // можно очистить реестр
					onSuccess(data); // и вызвать onSuccess
				};

				// эта функция сработает при любом результате запроса
				// важно: при успешном результате - всегда после JSONP-обработчика
				function checkCallback() {
					if (scriptOk) return; // сработал обработчик?
					delete CallbackRegistry[callbackName];
					onError(url);  // нет - вызвать onError
				}

				var script = document.createElement('script');

				// в старых IE поддерживается только событие, а не onload/onerror
				// в теории 'readyState=loaded' означает "скрипт загрузился",
				// а 'readyState=complete' -- "скрипт выполнился", но иногда
				// почему-то случается только одно из них, поэтому проверяем оба
				script.onreadystatechange = function() {
					if (this.readyState == 'complete' || this.readyState == 'loaded'){
						this.onreadystatechange = null;
						setTimeout(checkCallback, 0); // Вызвать checkCallback - после скрипта
					}
				}

				// события script.onload/onerror срабатывают всегда после выполнения скрипта
				script.onload = script.onerror = checkCallback;
				script.src = url;

				document.body.appendChild(script);
			}



> Реализация Comet через <script> (длинные опросы)
	> Осущетвляется также, как описано для XMLHttpRequest
		- Весь механизм "длинных опросов" тот же самый, что описан
			выше для XMLHttpRequest.


> WebSocket

	> Общая информация
		> Протокол WebSocket предназначен для решения любых задач и
			снятия ограничений обмена данными между браузером и сервером.
		> Он позволяет пересылать любые данные, на любой домен, безопасно
			и почти без лишнего сетевого трафика.

	> Как работает протокол WebSocket?
		> Протокол WebSocket работает над HTTP:
			- При соединении браузер отправляет HTTP-заголовки, спрашивая
				у сервера: "Поддерживаешь ли ты протокол WebSocket?".
			- Если сервер в ответных HTTP-заголовках отвечает: "Да,
				поддерживаю" - то дальше HTTP-взаимодействие прекращается
				и начинается взаимодействие с использованием протокола
				WebSocket, который уже не имеет с протоколом HTTP ничего общего.


	> Как открыть соединение?
		> Для открытия соединения достаточно создать объект WebSocket,
			указав в нём специальный протокол ws.
		> Пример:

				var socket = new WebSocket('ws://server');

	> Как получать ответ от сервера?
		> В функции, ссылку на которую нужно присвоить свойству
			socket.onmessage (см. ниже).

	> Как обрабатывать возможные ошибки?
		> В функции, ссылку на которую нужно присвоить свойству
			socket.onerror (см. ниже).

	> Настройка 4-х функций-колбэков объекта WebSocket

		> Всего их 4:
			- onopen			| срабатывает при открытии соединения
			- onclose			| срабатывает при закрытии соединения
			- onmessage		|	срабатывает при получении сообщения от сервера
			- onerror			|	срабатывает в случае возникновения ошибки

		> Примеры:
			- onopen:

					socket.onopen = function() {
						console.log('Соединение установлено');
					}

			- onclose:

					socket.onclose = function(event) {

						if(event.wasClean)
							console.log('Соединение закрыто чисто');
						else
							console.log('обрыв соединения');

					}

			- onmessage:

					socket.onmessage = function(event) {

						// Сохранить полученные данные в переменную data
						var data = event.data;

					}

			- onerror:

					socket.onerror = function(error) {

						console.log('Ошибка: '+error.message);

					}

	> Как отправить данные на сервер?
		> С помощью метода socket.send(data).
		> Данные могут быть любые: строка, файл и пр.
		> Примеры:

			Отправим на сервер строку:
			-----
				socket.send('Привет!');

			Отправим на сервер файл из формы (предположим, что она есть):
			-----
				socket.send(form.elements[0].file);


	> Поддержка протокола WebSocket на сервере
		> Чтобы установить WebSocket-соединение с сервером, последний должен
			поддерживать протокол WebSocket.
		> Для PHP есть много различных библиотек, позволяющие реализовать
			поддержку WebSockets. Одна из них - Ratchet. Для её установки
			требуется Composer.







-------------------------------------------------- */


















