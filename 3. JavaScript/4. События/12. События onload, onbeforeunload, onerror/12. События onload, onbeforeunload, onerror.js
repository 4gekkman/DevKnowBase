/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript -> События
12. События onload, onbeforeunload, onerror


	>




-------------------------------------------------- */










/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


	> Глава 'События "onload", "onbeforeunload" и "onerror"'
		учебника по JavaScript от Ильи Кантора:
				http://learn.javascript.ru/onload-onerror



*****************************************************
Оглавление:


	> Введение
		> Отслеживание загрузки внешних ресурсов
		> Способы отслеживания загрузки во всех браузерах (кроме IE<=8)
		> Способ отслеживания загрузки в IE<=8

	> Загрузка script - отслеживание успеха/ошибок
		> Постановка задачи
		> Решение задачи (для всех браузеров, кроме IE<=8)
		> Решение задачи (для IE<=8)
		> Решение задачи (кроссбраузерное)

	> Window - отслеживание загрузки/ошибок документа
		> window.onerror				| в случае ошибке вне try...catch
		> window.onload					| после полной загрузки всей страницы со всеми ресурсами
		> window.onunload				| при уходе со страницы или закрытии окна (переход отменить нельзя)
		> window.onbeforeunload	| при уходе со страницы или закрытии окна (переход отменить можно)

	> Поддержка событий load/error для других типов ресурсов
		> IMG
		> IFRAME
		> LINK

	> Событие onDOMContentLoaded - аналог onload, но не ждет загрузки всех ресурсов
		> Введение
		> Тонкости события onDOMContentLoaded
		> Поддержка в IE<=8 и кроссбраузерная реализация



*****************************************************


> Введение

	> Отслеживание загрузки внешних ресурсов
		> Браузер позволяет осуществлять загрузку внешних ресурсов - скриптов,
			iframe'ов, картинок и других - с помощью JavaScript.
		> Загрузку (её успешность, ошибки) можно отслеживать.

	> Способы отслеживания загрузки во всех браузерах (кроме IE<=8)
		> Для этого есть 2 события:
			- load			| возбуждается, если загрузка завершилась успешно
			- error			| возбуждается, если при загрузке произошла ошибка, а также
										при ошибках в JS, которые не были пойманы с помощью try ...

	> Способ отслеживания загрузки в IE<=8
		> Для этого есть 1 событие - onreadystatechange
		> Подрбнее о нем и об отслеживании ниже.


> Загрузка script - отслеживание успеха/ошибок

	> Постановка задачи
		> Допустим, в браузере работает сложный интерфейс.
		> И чтобы создать очередной компонент, надо загрузить скрипт с сервера:

				var script = document.createElement('script');
				script.src = 'my.js';
				document.documentElement.appendChild(script);

		> Но как достоверно убедиться, что скрипт загрузился без ошибок?


	> Решение задачи (для всех браузеров, кроме IE<=8)

		> Событие onload будет возбуждено, сразу после того, как скрипт
			загрузился и выполнился. Пример:

			Загрузить скрипт
			-----
				script.onload = function() {
					var script = document.createElement('script');
					script.src = 'http://code.jquery.com/jquery-1.10.2.min.js';
					document.documentElement.appendChild(script);
				}

			Убедиться, что он загрузился и выполнился
			-----
				script.onload = function() {
					console.log(jQuery);
				}


		> Событие onerror будет возбуждено при возникновении любых ошибок
			при загрузке (но не выполнении) скрипта. Пример:

			Попытаться загрузить скрипт с заведомо неправильного адреса
			-----
				script.onload = function() {
					var script = document.createElement('script');
					script.src = 'http://code.jquery.com/jquery-1.10.2.min.js';
					document.documentElement.appendChild(script);
				}

			Перехватить возбужденное сообщение об ошибке
			-----
				script.onerror = function() {
					console.log('Ошибка: ' + this.src);
				}


	> Решение задачи (для IE<=8)
		> В IE<=8 для отслеживание загрузки используют событие readystatechange.
		> Оно срабатывает каждый раз при изменении стадии процесса.
			> Стадия процесса загрузки лежит в свойстве script.readyStage.
			> Есть 3 стадии:
				- loading		| загрузка в процессе
				- loaded		| получен ответ с сервера - успех или ошибка, причем в этой
												фазе скрипт может быть еще не выполнен.
				- complete	| скрипт выполнен
		> Т.О. эволюция стадий для рабочего и не рабочего скриптов будет такая:
			> Рабочий:

					var script = document.createElement('script');
					script.src = "http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js";
					document.documentElement.appendChild(script);


					script.onreadystatechange = function() {
						alert(this.readyState); // loading -> loaded -> complete
					}

			> Не рабочий:

					var script = document.createElement('script');
					script.src = "http://ajax.googleapis.com/404.js";
					document.documentElement.appendChild(script);


					script.onreadystatechange = function() {
						alert(this.readyState);  // loading -> loaded
					}

		> Стадии могут быть пропущены. Например, если скрипт в кэше браузера,
			то может быть сразу дана стадия complete.
		> Итак, самый надежный способ в IE<=8 поймать загрузку/ошибку, это
			назначить обработчик события onreadystatechange, который будет делать
			следующее:
			- Отслеживать стадию loaded. И для неё выполнять код, который отложен
				функцией setImmediate(), т.к. если без него, то скрипт к этому
				моменту может быть еще не выполнен.
			- Отслеживать также стадию complete - на тот случай, если все
				остальные стадии будут пропущены.
		> Пример:


				var script = document.createElement('script');
				script.src = "http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js";
				document.documentElement.appendChild(script);

				function afterLoad() {
					alert("Загрузка завершена: " + typeof(jQuery));
				}


				script.onreadystatechange = function() {
					if (this.readyState == "complete") { // на случай пропуска loaded
						afterLoad(); // (2)
					}

					if (this.readyState == "loaded") {
						setTimeout(afterLoad, 0);  // (1)

						// убираем обработчик, чтобы не сработал на complete
						this.onreadystatechange = null;
					}
				}



	> Решение задачи (кроссбраузерное)
		- Пример ниже выполняет функцию afterLoad() после загрузки скрипта.


		Загрузить скрипт
		-----
			var script = document.createElement('script');
			script.src = "http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js";
			document.documentElement.appendChild(script);

		Функция, которая выполнится после загрузки скрипта
		-----
			function afterLoad() {
				alert("Загрузка завершена: " + typeof(jQuery));
			}


		Для всех браузеров (кроме IE<=8)
		-----
			script.onload = script.onerror = function() {

				// Функция afterLoad будет выполнена только 1 раз
				if( !this.executed ) {
					this.executed = true;
					afterLoad();
				}

			};

		Для IE<=8
		-----
			script.onreadystatechange = function() {
				var self = this;
				if (this.readyState == "complete" || this.readyState == "loaded") {
					setTimeout(function() { self.onload() }, 0);// сохранить "this" для onload
				}
			};


> Window - отслеживание загрузки/ошибок документа

	> window.onerror				| в случае ошибке вне try...catch
		> Функция-обработчик window.onerror вызывается в случае возникновения
			ошибки в скрипте на странице вне любого блока try...catch.
		> Аргументы обработчика:
			- message		| сообщение об ошибке
			- source		| файл
			- lineno		| номер строки с ошибкой
		> Пример:

			Назначить функцию-обработчик
			-----
				window.onerror = function(message, source, lineno) {
					alert("Ошибка:"+message +"\n" +
						"файл:" + source + "\n" +
						"строка:" + lineno);
				};

			Специально допустить ошибку, и сработает вышеназначенный обработчик:
			-----
				alert(abcde);


	> window.onload					| после полной загрузки всей страницы со всеми ресурсами
		> Функция-обработчик window.onload вызывается сразу после загрузки
			всей страницы, включая все ресурсы на ней - стили, картинки, ifreme'ы
			и так далее.
		> Функция-обработчик в примере ниже исполнится лишь после полной
			загрузки страницы:

				window.onload = function() {
					console.log('Документ и все ресурсы загружены');
				}


	> window.onunload				| при уходе со страницы или закрытии окна (переход отменить нельзя)
		> Функция-обработчик window.onunload срабатывает тогда, когда пользователь
			уходит со страницы, или закрывает окно. Т.Е. непосредственно перед этим.
		> Отменить переход в этой функции-обработчике нельзя.


	> window.onbeforeunload	| при уходе со страницы или закрытии окна (переход отменить можно)
		> Функция-обработчик window.onbeforeunload срабатывает тогда, когда пользователь
			уходит со страницы, или закрывает окно. Т.Е. непосредственно перед этим.
		> В отличие от onunload, функция-обработчик onbeforeunload может приостановить
			процесс перехода и запросить подтверждение у пользователя.
			> Для этого функции-обработчику onbeforeunload надо вернуть строку,
				которую браузеры покажут посетителю, спрашивая - нужно ли
				переходить.
			> Например:

					window.onbeforeunload = function() {
						return '*********************************************************\r\n'+
						'Вы точно уверены, что не хотите купить мой супер-пупер-курс!??!?!\n\r'+
						'*********************************************************';
					};

		> Особенности события beforeunload:
			- Не поддерживается старой Opera (до перехода на Webkit)
			- Firefox игнорирует возвращаемый текст, и показывает своё
				сообщение (это сделано в целях безопасности).
		> Примеры применения:
			> Часто это событие используется на недобросовестных сайтах, которые
				пытаются впарить тебе чудо-товар. Как в примере выше. Делать так
				считается дурным тоном.
			> Это событие можно использовать и в положительном ключе - если какой-то
				процесс - например, сохранение данных - не завершился, и пользователь
				пытается закрыть страницу, то можно его остановить, чтобы данные не были
				потеряны - как это сделано в google документах.



> Поддержка событий load/error для других типов ресурсов

	> IMG
		> Поддерживает onload/onerror во всех браузерах.

	> IFRAME
		> Поддерживает onload во всех браузерах. Это событие срабатывает
			как при успешной загрузке, так и при ошибке.

	> LINK
		> Поддерживает onload/onerror в НЕКОТОРЫХ браузерах.
		> Замечательная статья, в которой рассказывается, как загружать
			CSS-стили из внешнего файла "на лету" средствами JS, и достоверно
			убеждаться в том, что эти стили были загружены:
					http://www.phpied.com/when-is-a-stylesheet-really-loaded/



> Событие onDOMContentLoaded - аналог onload, но не ждет загрузки всех ресурсов

	> Введение
		> Событие onDOMContentLoaded возбуждается при загрузке документа, после
			выполнения всех тегов script.
		> Поддерживается всеми браузерами, кроме IE<=9.
		> В отличие от window.onload оно не ждёт загрузки доп. ресурсов, поэтому
			наступает гораздо раньше.
		> На момент наступления onDOMContentLoaded дерево DOM полностью построено,
			и все элементы доступны.
			> Поэтому это событие часто используется для инициализации интерфейса.
				Во фреймворках для него отводят специальные функции. Например,
				в jQuery: $(ready).
			> Однако, ниже описаны ныкоторые особенности события onDOMContentLoaded,
				которые делают вышеописанный способ применения не таким уж привлекательным.
		> Пример назначения функции-обработчика:

				document.addEventListener('DOMContentLoaded', function(){

					console.log(DOM готов);

				});


	> Тонкости события onDOMContentLoaded

		> Особенность работы в старой Opera (до перехода на webkit)
			> Во всех браузерах, кроме старой Opera, DOMContentLoaded не ждет
				скриптов с атрибутами async/defer. А также скриптов, добавленных
				через DOM.
			> А старый браузер Opera ждет любые скрипты.

		> Задержка onDOMContentLoaded из-за задержки внешних скриптов
			> Допустим, ты инициализируешь интерфейс при наступлении события
				onDOMContentLoaded.
			> А еще на сайте присутствуют эл-ты script, загружающие скрипты
				с внешних ресурсов. Например - рекламные.
			> Т.О. если эти внешние скрипты будут загружены с задержкой, то
				задержится и событие onDOMContentLoaded. Как следствие, задержится
				отображение интерфейса.

		> onDOMContentLoaded и CSS-стили
			> Для всех браузеров, кроме старого Opera
				> Событие onDOMContentLoaded будет ждать загрузки всех внешних
					CSS-стилей, подключенных с помощью эл-та link, после которых
					есть хотя бы 1 элемент script. Это поведение прописано в стандарте.
				> Смысл такой - скрипту для работы могут понадобиться стили, поэтому
					надо подождать, пока они загрузятся, а затем выполнять скрипт.
			> В старом Opera (до перехода на webkit)
				> Старый Opera не ждёт стили.

		> Автозаполнение форм
			> В браузерах Firefox/Chrome автозаполнение формы происходит при
				наступлении события onDOMContentLoaded.
			> Например, если на странице есть форма для ввода логина-пароля, то
				браузер введёт в неё запомненные значения только по onDOMContentLoaded.
			> Т.О., если на странице много всяких скриптов/стилей, и событие
				onDOMContentLoaded будет долго их всех ждать, то и пользователь
				в течение этого времени ожадания не сможет воспользоваться автозаполнением
				в формах.
				> Решение: сделать так, чтобы onDOMContentLoaded происходило
									 как можно раньше. Для этого:
									 - Использовать атрибуты defer/async эл-та script.
									 - Добавлять скрипты через DOM.


	> Поддержка в IE<=8 и кроссбраузерная реализация
		> Описана здесь:
					http://javascript.ru/tutorial/events/ondomcontentloaded




-------------------------------------------------- */


















