/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript -> События
5. События мыши

	> Получение клиентских и документных координат курсора мыши
	> Демонстрация работы событий mouseover и mouseout при переходе курсора
		мыши с одного элемента DOM на другой






-------------------------------------------------- */




//Получение клиентских и документных координат курсора мыши


	//FIX функция для IE (при работе с pageX/pageY)
	function fixPageXY(e) {
		if (e.pageX == null && e.clientX != null ) { // если нет pageX..
			var html = document.documentElement;
			var body = document.body;

			e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
			e.pageX -= html.clientLeft || 0;

			e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
			e.pageY -= html.clientTop || 0;
		}
	}


	// Функция-обработчик, при клике выводит координаты клика
	document.onclick = function(event) {

		//Клиентские координаты курсора мыши относительно окна браузера:
		document.getElementById('clientX').innerHTML = event.clientX;
		document.getElementById('clientY').innerHTML = event.clientY;

		//Документные координаты мыши
		fixPageXY(event);
		document.getElementById('docX').innerHTML = event.pageX;
		document.getElementById('docY').innerHTML = event.pageY;

	};




//Демонстрация работы событий mouseover и mouseout при переходе курсора
// мыши с одного элемента DOM на другой


	// FIX функция для IE (при работе с relatedTarget)
	// > Если это IE, то добавляе объекту event свойство relatedTarget с правильным содержанием
		function fixRelatedTarget(e) {
			if (!e.relatedTarget) {
				if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
				if (e.type == 'mouseout') e.relatedTarget = e.toElement;
			}
		}

	// Функция, которая возвращает строковое представление элемента
  function str(el) {
    return el ? (el.id || el.nodeName) : 'null';
  }

	// Функция-обработчик для отлавливания собятия mouseover
	document.getElementById('move').addEventListener('mouseover',function(e){

		// Кроссбраузерно получить ссылки на объект-событие event, а также
		// на целевой объект target, в котором изначально произошло событие.

				// Кроссбраузерно получить событие
				e = e || window.event;

				// Кроссбраузерно получить target-элемент
				var target = 	e && e.target || e.srcElement;

		// FIX проблемы relatedTarget (для IE)
		fixRelatedTarget(e);	// FIX

		// Записать в элемент mouseoverSpan, с какого и на какой элемент пришел курсор
		document.getElementById('mouseoverSpan').innerHTML =
				'Переход с '+str(e.relatedTarget)+' на '+ str(e.target);


	});

	// Функция-обработчик для отлавливания собятия mouseout
	document.getElementById('move').addEventListener('mouseout',function(e){

		// Кроссбраузерно получить ссылки на объект-событие event, а также
		// на целевой объект target, в котором изначально произошло событие.

				// Кроссбраузерно получить событие
				e = e || window.event;

				// Кроссбраузерно получить target-элемент
				var target = 	e && e.target || e.srcElement;

		// FIX проблемы relatedTarget (для IE)
		fixRelatedTarget(e);	// FIX

		// Записать в элемент mouseoverSpan, с какого и на какой элемент пришел курсор
		document.getElementById('mouseoutSpan').innerHTML =
				'Переход с '+str(e.relatedTarget)+' на '+ str(e.target);

	});







/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


	> Глава "Введение: клики, кнопка, координаты" учебника по JavaScript
		от Ильи Кантора:
				http://learn.javascript.ru/mouse-clicks

	> Глава "События движения: "mouseover/out/move/leave/enter"" учебника по JavaScript
		от Ильи Кантора:
				http://learn.javascript.ru/mousemove-events

	> Глава "Колёсико мыши: "wheel" и аналоги" учебника по JavaScript
		от Ильи Кантора:
				http://learn.javascript.ru/mousewheel

	> Глава "Устранение IE-несовместимостей: "fixEvent"" учебника по JavaScript
		от Ильи Кантора:
				http://learn.javascript.ru/fixevent


*****************************************************
Оглавление:

	Клики, клавиши-модификаторы, координаты курсора

		> Последовательность событий при кликах мышкой
		> Особенности dblclick в IE<=8
		> FIX функция для IE (при работе с which)
		> Контекстное меню - событие oncontextmenu.
		> Клавиши-модификаторы: shift, alt, ctrl и meta
		> Координаты мыши
			> Клиентские
			> Документные
			> FIX функция для IE (при работе с pageX/pageY)
			> Живой пример


	Движение курсора мыши

		> Переход курсора с одного элемента на другой
			> Общая информация
			> Подробнее о mouseover
			> Подробнее о mouseout
			> FIX функция для IE (при работе с relatedTarget)
			> Проблема "срабатывания на потомках" при работе с mouseover/mouseout
			> Живой пример
		> Частота событий






*****************************************************



Клики, клавиши-модификаторы, координаты курсора
================================



> Последовательность событий при кликах мышкой
	> Если 2 раза быстро кликнуть ЛК мыши, то последовательность возникающих
		событий будет, как описано ниже.
	> Для всех браузеров, кроме IE<=8

			1 mousedown
			2 mouseup
			3 click
			4 mousedown
			5 mouseup
			6 click
			7 dblclick

	> Для IE<=8

			1 mousedown
			2 mouseup
			3 click
			4 mouseup
			5 dblclick


> Особенности dblclick в IE<=8
	> В IE<=8 событию dblclick предшествует 1 событие click, как это видно из
		приведенной выше последовательности событий при клике.
	> Т.О., чтобы отследить 2-ной клик, лучше отслеживать именно событие dblclick,
		а не 2 последовательных события click.


> FIX функция для IE (при работе с which)

	> Во всех браузерах, кроме IE<=8
		> С помощью свойства event.which можно узнать, какая кнопка была нажата.
		> Значения:

				which == 1 	| была нажата левая кнопка
				which == 2 	| была нажата средняя кнопка
				which == 3 	| была нажата правая кнопка

	> В IE<=8 узнать, какая кнопка мыши была нажата, можно с помощью свойства button.
		В нем лежит 3 бита, которые обозначают, была ли нажата соответствующая кнопка.
		При этом можно даже узнать, были ли нажаты 2 кнопки одновременно. В современном
		IE поддерживаются оба способа.

				!!(button & 1) == true	| была нажата левая кнопка
				!!(button & 2) == true	| была нажата правая кнопка
				!!(button & 4) == true	| была нажата средняя кнопка

	> FIX функция для IE (при работе с which)
		> Если её использовать, позволяет забыть о том, что при работе с IE надо
			использовать свойство button вместо which.
		> Эта функция просто создает у объекта события свойство which, если его нет
			(т.е. если это IE), и кладет туда значение, беря его из button, как показано
			ниже.
		> FIX функция:

			//FIX функция для IE (при работе с which)
			// > Если это IE, добавляет объекту события св-во which с правильным содержимым
				element.onclick = function(event) {

					if(!event.which && e.button) {
						if(event.button & 1) event.which = 1;		// левая кнопка
						if(event.button & 4) event.which = 2;		// средняя кнопка
						if(event.button & 2) event.which = 3;		// правая кнопка
					}

				};


> Контекстное меню - событие oncontextmenu.
	> При клике правой кнопкой мыши возбуждается событие oncontextmenu.
	> Действия браузера по умолчанию - показать контекстное меню.
	> Действия браузера по умолчанию можно отменить
		> Как - см.: "2. Всплытие, перехват, действ. брауз. по умолч"
		> Это может понадобиться, если тебе требуется сделать, например,
			чтобы возникало не стандартное контекстное меню при клике ПК мыши по
			элементу E, а нестандартное - твоей разработки.


> Клавиши-модификаторы: shift, alt, ctrl и meta
	> Среди свойств объекта-события для событий мыши есть свойства, в которых
		содержится информация - была ли зажата какая-либо клавиша модификатор:
		- shiftKey	| если во время появления события мыши была зажата клавиша shift
		- altKey		| если во время появления события мыши была зажата клавиша alt
		- ctrlKey		| если во время появления события мыши была зажата клавиша ctrl
		- metaKey 	| если во время появления события мыши была зажата клавиша meta (macOS)
	> Пример использования:

			element.onclick = function(event) {
				if( !event.ctrlKey || !event.shiftKey ) return;
				console.log('При клике были зажаты CTRL и SHIFT');
			};
	> Работающий пример работы с клавишами-модификаторами, в котором можно
	 	с помощью курсора мыши и клавиш-модификаторов выделать элементы списка,
	 	можно найти по адресу:

	 		'0. Practical samples and techniques' ->
	 		'2. Events' ->
	 		'14. Cursor selection of UL elements'


> Координаты мыши

	> Клиентские координаты курсора мыши относительно окна браузера
		> MouseEvent.clientX		| по оси X
		> MouseEvent.clientY		| по оси Y


	> Документные координаты курсора мыши относительно document

		> Для всех браузеров, кроме IE<=8
			> MouseEvent.pageX			| по оси X
			> MouseEvent.pageY			| по оси Y

	> FIX функция для IE (при работе с pageX/pageY)
		> Если её применять, то можно забыть о том, что у объектов событий в IE нет
			свойств pageX/pageY.
		> Применение этой функции просто создает (если дело происходит в IE, в котором
			таких свойств нет) свойства pageX и pageY с правильными значениями.
		> FIX функция:

				//FIX функция для IE (при работе с pageX/pageY)
				function fixPageXY(e) {
					if (e.pageX == null && e.clientX != null ) { // если нет pageX..
						var html = document.documentElement;
						var body = document.body;

						e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
						e.pageX -= html.clientLeft || 0;

						e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
						e.pageY -= html.clientTop || 0;
					}
				}

	> Живой пример

			См. выше в примерах










Движение курсора мыши
================================



> Переход курсора с одного элемента на другой

	> Общая информация

		> Когда курсор пересекает границу между элементами от X к Y, то:
			> У элемента X возбуждаются событие:
				- mouseout
			> А у элемента Y возбуждается событие:
				- mouseover

		> relatedTarget (fromElement/toElement) может быть === null, если курсор пришел
			из области за пределами окна.

	> Подробнее о mouseover
		- event.target 				| элемент под курсором (все браузеры, кроме IE)
		- event.srcElement		| (IE)
		- event.relatedTarget | элемент, с которого курсор пришел (все браузеры, кроме IE)
		- event.fromElement		| (IE)

	> Подробнее о mouseout
		- event.target				| элемент, с которого курсор пришел (все браузеры, кроме IE)
		- event.srcElement		| (IE)
		- event.relatedTarget	| элемент под курсором (все браузеры, кроме IE)
		- event.toElement			| (IE)

	> FIX функция для IE (при работе с relatedTarget)
		> Если её применять, то можно забыть о том, что у объектов событий mouseout и
		 	mouseover в IE нет свойства relatedTarget, а есть fromElement/toElement.
		> Применение этой функции просто создает у объекта события свойство relatedTarget,
			и кладет в нее значение свойства fromElement - если это событие mouseover, или
			свойство toElement - если это событие mouseout.
		> FIX функция:

				// FIX функция для IE (при работе с relatedTarget)
				// > Если это IE, то добавляе объекту event свойство relatedTarget с правильным содержанием
				function fixRelatedTarget(e) {
					if (!e.relatedTarget) {
						if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
						if (e.type == 'mouseout') e.relatedTarget = e.toElement;
					}
				}



	> Проблема "срабатывания на потомках" при работе с mouseover/mouseout

		> Проблема из сабжа заключается в следующем:
			1 Допустим, есть 2 элемента, X и Y.
			2 Y - это потомок элемента X.
			3 Обработчик mouseover назначен элементу X.
			4 Когда курсор заходит на X, срабатывает mouseover.
			5 Когда курсор после этого заходит на Y, там возбуждается еще одно
				событие mouseover, которое всплывает от Y к X, где и перехватывается
				обработчиком из п.3.

		> Негативные последствия проблемы "срабатывания на потомках"
			> Например, если мы делаем всплывающую подсказку, то она моргнет
				лишний раз перерисовываясь.
			> Но главная проблема в том, что трудно становится отследить по событию
				mouseout, когда элемент вышел за пределы объекта X.

		> Возможны 2 решения проблемы "срабатывания на потомках"

			> 1 решение
				> Сделать события mouseover/mouseout для элемента X не всплывающими.
				> Недостаток - если они не всплывают, то нельзя их перехватить в обработчике
					на элементе выше по DOM - ведь события то не всплывают.

			> 2 решение (наш выбор)
				> Воспользоваться событиями mouseenter и mouseleave.
				> Работают во всех браузерах и IE>=6.
				> Не всплывают по умолчанию.
				> Позволяют однозначно отследить вход курсора на элемент и выход с него.
				> Не срабатывают на потомках, т.к. не всплывают.
				> Можно использовать параллельно с mouseover/mouseout



	> Живой пример

			См. выше в примерах


> Частота событий mousemove и mouseover

	> Некоторые события mousemove и mouseover могут быть пропущены (не возникнуть)
		> События mousemove и mouseover/mouseout срабатывают с такой частотой, с которой
			это позволяет внутренний таймер браузера.
		> Если двигать мышью с большой скоростью, то DOM элементы, через которые проходит
			курсор мыши, могут быть пропущены.

	> Надежный способ контролировать заход/выход курсора в/за пределы элемента
		> Это позволяет надежно делать связка mouseover/mouseout. Потому что если
			первое возникло, то неизбежно возникнет и второе.












-------------------------------------------------- */





















