/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
JavaScript -> События
4. Отлож. обраб-ка соб-ия, шаблон проект-ия Поведение

	> setImmediate

	> Демонстрация последовательной "по очереди" обработки АСИНХронных событий

	> Демонстрация того, как выполнение СИНХронного события всегда "лезет без очереди"
	> Сделать синхронное событие асинхронным, отложив исполнение его обработчика

	> Пропустить вперед все задачи в стеке, и только затем выполнить указанный код
		> Позволить родителю обработать событие раньше, чем потомку
		> Позволить действию браузера "по умолчанию" завершиться раньше, чем сработает обработчик



-------------------------------------------------- */


//setImmediate
	// Проверить cледующее:
	// > Если это IE>=10, и ф-ия setImmediate есть, то ничего не добавлять.
	// > В ином случае, добавить объекту window метод setImmediate:
	if (!window.setImmediate) window.setImmediate = (function() {
		var head = { }, tail = head; // очередь вызовов, 1-связный список

		var ID = Math.random(); // уникальный идентификатор

		// Подготовка функции-перехватчика события message из другого документа
		function onmessage(e) {
			if(e.data != ID) return; // не наше сообщение
			head = head.next;
			var func = head.func;
			delete head.func;
			func();
		}

		// Кросдоменное назначение обработчика событий onmessage
		if(window.addEventListener) { // IE9+, другие браузеры
			window.addEventListener('message', onmessage, false);
		} else { // IE8
			window.attachEvent( 'onmessage', onmessage );
		}

		// > Если это не IE<=7, то поставить func в конец текущей очереди
		// > Если это IE<=7, то вызвать для func обычный setTimeout.
		return window.postMessage ? function(func) {
			tail = tail.next = { func: func };
			window.postMessage(ID, "*");
		} :
		function(func) { // IE<8
			setTimeout(func, 0);
		};
	}());





//Демонстрация последовательной "по очереди" обработки АСИНХронных событий

	// Получить ссылку на элемент area
	var area = document.getElementsByTagName('textarea')[0];

	// Назначить 3 функции-перехватчика событий для area
	// > Эти асинхронные события будут выполнены в порядке их появления
	//   в стеке задач главного потока.
	area.onmousedown = function() { this.value += 'mousedown\n'; };
	area.onmouseup = function() {  this.value += 'mouseup\n'; };
	area.onclick = function() {  this.value += 'click\n'; };



//Демонстрация того, как выполнение СИНХронного события всегда "лезет без очереди"


	// Получить ссылки на наши подопытные элементы input
  var button = document.getElementById('i1');
  var text = document.getElementById('i2');

	// Назначить кнопке функцию-обработчик для АСИНхронного события click
  button.onclick = function() {

		// Демонстрация того, как выполнение focus поставит его обработчик в начало
		// стека задач без очереди, и он впихнет свою надпись "!focus!" в текстовое
		// поле между этими 2-мя надписями:
		text.value += ' 1-й  ';
    text.focus(); 								// вызов инициирует событие onfocus
    text.value += '  2-й  ';
  };

	// Назначить текстовому полю функцию-обработчик для СИНХронного события focus
  text.onfocus = function() {
    text.value += '  3-й (focus) - всегда лезет без очереди  ';
  };



//Сделать синхронное событие асинхронным, отложив исполнение его обработчика

	// Получить ссылки на наши подопытные элементы input
  var button1 = document.getElementById('i3');
  var text1 = document.getElementById('i4');

	// Назначить кнопке функцию-обработчик для АСИНхронного события click
  button1.onclick = function() {

		// Демонстрация того, как выполнение focus поставит его обработчик в начало
		// стека задач без очереди, и он впихнет свою надпись "!focus!" в текстовое
		// поле между этими 2-мя надписями:
		text1.value += ' 1-й  ';

			// Вызов focus поместим в конец стека с помощью setImmediate:
			setImmediate(function() {
				text1.focus(); 								// вызов инициирует событие onfocus
			});

		text1.value += '  2-й  ';
  };

	// Назначить текстовому полю функцию-обработчик для СИНХронного события focus
  text1.onfocus = function() {
    text1.value += '  3-й (focus) - всегда лезет без очереди  ';
  };






//Пропустить вперед все задачи в стеке, и только затем выполнить указанный код


	// Позволить родителю обработать событие раньше, чем потомку
	// > 	Для этого мы откладываем выполнение обработчика события на элементе input
	// 		в конец стека.
	// > 	Так мы пропускаем вперед в стеке задач выполнение обработчика на элементе
	//   	document. Событие всплывает до этого элемента, и обработчик на нем выполняется.
	// 		А обработчик на input выполняется уже после него.


		//> Обработчик, выполнение которого мы откладываем
		var input = document.getElementById('b1');

			// Вот, как это делается в обработчике событий:
			input.onclick = function() {

				function handle() {
					input.value += ' -> input';
				}


				setTimeout(handle, 0); // отложить обработку

			};

			// Назначить обработчик onclick родителю элемента input - объекту document
			// > Обработчик, который выше, пропустит этот обработчик вперед в стеке задач
			//	 главного потока JS, так что этот выполнится раньше того, который выше.
			document.onclick = function() {
				input.value += ' -> document';
			};



	// Позволить действию браузера "по умолчанию" завершиться раньше, чем сработает обработчик
	// > 	Есть ряд событий, для которых при их возникновении порядок такой:
	//  	1. Сначала выполняется функция-обработчик события
	//    2. Затем выполняются действия браузера по умолчанию
	// > Иногда, как в примере ниже, хочется поменять порядок наоборот.
	// > В примере ниже надо сделать так, чтобы все вводимые в input символы были
	//   в верхнем регистре. Для этого нужен следующий порядок обработки:
	//   	1. Сначала должны выполниться действия браузера по умолчанию - т.е.
	//       символ должен появиться в input.
	//    2. Затем должен выполниться обработчик событий onkeydown, который
	//       и должен преобразовать этот символ к верхнему регистру
	// *Примечение: причем преобразование должно произойти так быстро, чтобы пользователь
	//  						вообще не успел заметить, что символ был в нижнем регистре. Вот здесь то
	//   						и проявляется преимущество setImmediate над setTimeout.


		document.getElementById('my').onkeydown = function() {

			var self = this;
			function handle() {
				self.value = self.value.toUpperCase()
			}
			setImmediate(handle);

		};










/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


	> Глава "Шаблон проектирования "поведение" (behavior)" учебника по JavaScript
		от Ильи Кантора:
				http://learn.javascript.ru/behavior

	> Глава "Управление порядком обработки, setTimeout(...0)" учебника по JavaScript
		от Ильи Кантора:
				http://learn.javascript.ru/events-and-timing-depth




*****************************************************
Оглавление:


	Шаблон проектирования "Поведение"

		> Что такое шаблон проектирования "Поведение"
		> Область применения шаблона "Поведение" (на примерах)
		> Работающий пример использования шаблона "Поведение"


	Использование отложенного исполнения функции-обработчика события

		> Главный поток браузера
		> Асинхронные события
		> Синхронные события
		> Использование setImmediate чтобы отложить вып-нение обработчика события:
			> Общая информация
			> Сделать синхронное событие асинхронным, отложив исполнение его обработчика
			> Отложить обработку в дочернем эл-те, чтобы обработать сначала в элементе-родителе
			> Позволить дейс-ям бра-ра "по умолч." зав-иться, а затем уже обработать событие



*****************************************************




Шаблон проектирования "Поведение"
================================



> Что такое шаблон проектирования "Поведение"

	> Состоит из 2-х частей:
		1. Элементу ставится пользовательский атрибут, описывающий его поведение.
		2. При помощи делегирования ставится обработчик на документ, который ловит
			 все клики и, если элемент имеет нужный атрибут, производит нужное действие.

	> Удобен тем, что сколь угодно сложное JS-поведение можно задать элементу
		всего-лишь при помощи 1-го пользовательского атрибута.
		> Например, можно для элементов с атрибутом data-tooltip показывать при
			наведении курсора мыши текстовую подсказку, тексто которо будет
			браться из этого самого атрибута.


> Область применения шаблона "Поведение" (на примерах):

	> Можно показывать подсказку при наведении, если есть атрибут:

			<div data-tooltip='Подсказка при наведении'>
				... содержимое элемента ...
			</div>

	> Можно проверять на валидность значение поля формы. Причем в зависимости
		от значения атрибута, проверять по разному. Например, в одном поле надо
		проверить на валидность введенный email, в другом это должно быть положительное
		целое число меньше равно 150:

			<form>
				<input data-validate='email'>
				<input data-validate='integer positive <= 150'>
			</form>

	> Можно, если присутствует определенный атрибут, отправлять форму на сервер
		через AJAX:

			<form data-ajax='1'>
				...
			</form>

	> И так далее...


> Работающий пример использования шаблона "Поведение"
	> Для кнопки задаем пользовательский атрибут data-toogleID.
	> Значение этого атрибута - ID какого-то значения на странице.
	> При нажатии на кнопку обработчик события onclick, прикрепленный к документу,
		скрывает элемент с таким ID, если он не скрыт. А если скрыт - показывает.





Использование отложенного исполнения функции-обработчика события
================================



> Главный поток браузера

	> Общая информация о главном потоке
		> В каждом окне выполняется только 1 ГЛАВНЫЙ ПОТОК.
		> Он занимается выполнением JS, отрисовкой и работой с DOM.
		> Он выполняет команды по очереди.
		> Он блокируется при выводе модальных окон (например, alert).

	> Другие потоки
		> Есть и другие потоки. Например, сетевых коммуникаций. Поэтому браузер может
			продолжать скачивание файлов, даже если главный поток блокирован модальным окном.

	> Спецификация Web Workers
		> Существует спецификация HTML5 Web Workers, которая позволяет запускать
			дополнительные JS-потоки. Их называют "Рабочие потоки", или просто "Workers".
		> Ссылка на доп. сведения:
					http://www.w3schools.com/html/html5_webworkers.asp
		> Они могут обмениваться сообщениями с главным потоком.
		> В каждом рабочем потоке своё собственное пространство имен, не пересекающееся
			никак с пространствами имен других рабочих потоков.
		> Рабочие потоки не имеют доступа к DOM.
		> Они полезны в основном для вычислений, тогда можно задействовать несколько
			процессоров одновременно.


> Асинхронные события
	> Функция-обработчик асинхронного события выполняется не сразу, как только событие
		было перехвачено. Она попадает в общий стек задач главного потока. И выполняется
		тогда, когда до нее доходит очередь.
	> Выполнение функций-обработчиков асинхронных событий добавляются в очередь
		в порядке поступления. И обрабатываются по очереди.
	> Пример:

		См. пример выше в примерах:
				"Демонстрация последовательной "по очереди" обработки АСИНХронных событий"


> Синхронные события
	> Функция-обработчик синхронного события попадает не в конец, а в начало стека
		главного потока. Т.О. она по сути лезет без очереди, и выполняется сразу.
	> Т.Е. если функции-обработчику асинхронного события, выполнение которой попало бы
		в конец стека задач главного поткоа, пришлось бы ждать своей очереди - пока выполнятся
		все задачи перед ней - то функция-обработчик синхронного события, попавшая в
		стек, всегда лезет без очереди.
	> Пример:

		См. пример выше в примерах:
				"Демонстрация того, как выполнение СИНХронного события всегда "лезет без очереди"



> Использование setImmediate чтобы отложить вып-нение обработчика события

	> Общая информация

		> setImmediate, а не setTimeout, используется потому, что последний не просто ставит
			отложенное выполнение обработчика события в конец стека задач главного потока,
			но еще и откладывает его минимум на 1 тик (4мс - 1000мс). А вот setImmediate
			такого недостатка лишен - просто ставит в конец стека.
			> setImmediate это пользовательская функция, её можно найти в
					"Ядро JS" -> "6. Таймеры".

		> Использовать этот приём можно в таких ситуациях:

			- Сделать так, чтобы выполнение функции-обработчика СИНХронного события
				проходило также, как у асинхронного.

			- Пропустить какой-нибудь другой JS-код в очереди. Для того, чтобы потом
				воспользоваться результатами этой обработки.

			- Аналог предыдущего пункта - пропустить действия браузера по умолчанию
				в очереди, чтобы потом воспользоваться результатами этих действий.


	> Сделать синхронное событие асинхронным, отложив исполнение его обработчика
		> Как описано выше, задача по выполнению функции-обработчика осинхронного
			события ставится без очереди в самое начало стека задач главного потока.
		> Чтобы это предотвратить, и поставить его в конец стека, как у синхронного
			события, надо воспользоваться функцией setImmediate.
		> На примере вызова СИНХронного события focus:

			Можно обернуть вызов этого события в setImmediate:
			-----
				...
				setImmediate(function(){
					text.focus();
				});
				...


	> Отложить обработку в дочернем эл-те, чтобы обработать сначала в элементе-родителе
		> Обычно сначала событие можно обработать в целевом элементе-потомке. Затем,
			по мере его всплытия, собятие можно отлавливать и обрабатывать в элементах-
			родителях целевого элемента события.
		> Но что, если сначала требуется обработать события в каком-нибудь элементе-родителе
			целевого элемента события, а уже затем, полагаясь на полученные при этой
			обработке данные, обработать его в целевом элементе события?
		> Или вообще, требуется пропустить для тех же самых целей, в очереди вперед
			какой-нибудь любой JS-код?
		> И тут на помощь нам приходит setImmediate. Используя приём как в примере ниже,
		 	можно "любезно пропустить вперед" в очереди задач стека главного потока
		 	выполнение функции-обработчика на родителе, а выполнение функции-обработчика
		 	на целевом элементе события поставить в конец очереди:

		 	Архитектура функции-обработчика событий с отложенным исполнением:
		 		-----
		 		e.onclick = function(event) {

		 			// Внутри ф-ии-обработчика создаем другую ф-ию-обработчик
		 			var handler = function() {
		 				... обработка ...
		 			};

		 			// Помещаем выполнение функции handler в конец очереди задач стека главного потока
		 			setImmediate(handler);

		 		};
		> Пример №1:

			См. пример выше в примерах:
				"Позволить родителю обработать событие раньше, чем потомку"

		> Пример №2:

			См. пример выше в примерах:
				"Позволить действию браузера "по умолчанию" завершиться раньше, чем сработает обработчик"



-------------------------------------------------- */





















