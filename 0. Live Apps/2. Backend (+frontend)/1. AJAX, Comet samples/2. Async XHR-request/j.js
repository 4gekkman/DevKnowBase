/**
 * Задача:
 *
 * > Сделать демонстрацию работы асинхронного XHR-запроса:
 * 	 - Запрос должен осуществляться при нажатии на кнопку.
 * 	 - В ответ сервер должен послать серверные дату и время.
 * 	 - Последние должны быть записаны в innerHTML кнопки, когда поступит ответ.
 * 	 - JS-скрипт должен по клиентскому времени замерить время ожидания
 * 	 	 ответа и вывести на экран.
 * 	 	 - Причем время начала замера он должен вывести до отправки XHR-запроса.
 * 	 	 - А время окончания замера и зазор в секундах - после получения ответа
 * 	 	 	 от сервера.
 *
 *
 *
 * Архитектура решения:
 *
 * 1. Подготовить необходимый HTML и CSS.
 *
 * 2. Подготовить серверный скрипт p.php:
 * 		- Он должен специально сделать задержку в 3 секунды перед отправкой
 * 			ответа, в демонстрационных целях.
 * 		- Он должен	послать в выходной буфер серверные дату и время.
 *
 * 3. Получить ссылки и сохранить их в переменные на следующие элементы:
 * 		1 Кнопка, при нажатии на которую осуществляется XHR-запрос.
 * 		2 Эл-т span, в который выводится дата и время начала запроса.
 * 		3 Эл-т span, в который выводится дата и время получения ответа.
 * 		4 Эл-т span, в который выводится разница в секундах между началом
 * 			запроса и получением ответа.
 *
 * 4. Назначить функцию-обработчик события onclick для кнопки (1) из п.3.
 * 		В ней выполнить следующее: [5-7]
 *
 * 5. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
 * 		Также, кроссбраузерно получить target-элемент
 *
 * 6. Записать:
 * 	 - в span.innerHTML (2) из п.3 текущую дату и время клиента
 * 	 - в span.innerHTML (3) и (4) пустую строку ''
 *
 * 7. Выполнить асинхронный XHR-запрос методом GET к скрипту p.php.
 *
 * 8. Назначить функцию-обработчик события onreadystatechange для объекта
 * 		XHR из п.7. В ней выполнить следующее: [5,9-12]
 *
 * 9. Проверить, если xhr.readyState != 4, завершить работу функции-обработчика.
 *
 * 10. Получить тело ответа, и записать его в innerHTML кнопки (1) из п.3.
 *
 * 11. Записать в span.innerHTML (3) из п.3 текущую дату и время клиента.
 *
 * 12. Записать в span.innerHTML (4) из п.4 разницу между временами из
 * 		 п.9 и п.6 в секундах по модулю.
 *
 *
 *
 */


// Задействованные переменные
var button,				// Кнопка, при нажатии на которую осуществляется XHR-запрос.
		spanStart,		// Эл-т span, в который выводится дата и время начала запроса.
		spanEnd,			// Эл-т span, в который выводится дата и время получения ответа.
		spanDiff,			// Эл-т span, в который выводится разница в секундах между началом
		xhr,					// ссылка на объект XMLHttpRequest
		target;				// целевой элемент события



//3. Получить ссылки и сохранить их в переменные на следующие элементы:
//		1 Кнопка, при нажатии на которую осуществляется XHR-запрос.
//		2 Эл-т span, в который выводится дата и время начала запроса.
//		3 Эл-т span, в который выводится дата и время получения ответа.
//		4 Эл-т span, в который выводится разница в секундах между началом
//			запроса и получением ответа.
button = document.getElementById('button');
spanStart = document.getElementById('start');
spanEnd = document.getElementById('end');
spanDiff = document.getElementById('diff');



//4. Назначить функцию-обработчик события onclick для кнопки (1) из п.3.
//		В ней выполнить следующее: [5-7]
button.onclick = function(event) {


	//5. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
	//		Также, кроссбраузерно получить target-элемент

		//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
		event = fixEvent(event);

		//Кроссбраузерно получить target-элемент
		target = 	event && event.target ||
									event.srcElement;


	//6. Записать:
	// 	 - в span.innerHTML (2) из п.3 текущую дату и время клиента
	//	 - в span.innerHTML (3) и (4) пустую строку ''
	spanStart.innerHTML = new Date();
	spanEnd.innerHTML = '';
	spanDiff.innerHTML = '';

	console.log('До отправки запроса');


	//7. Выполнить асинхронный XHR-запрос методом GET к скрипту p.php.
	xhr = new XMLHttpRequest();
	xhr.open('GET','p.php',true);
	xhr.send();
	console.log('После отправки запроса');


	//8. Назначить функцию-обработчик события onreadystatechange для объекта
	//		XHR из п.7. В ней выполнить следующее: [5,9-12]
	xhr.onreadystatechange = function(event) {


		//5. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
		//		Также, кроссбраузерно получить target-элемент

			//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
			event = fixEvent(event);

			//Кроссбраузерно получить target-элемент
			target = 	event && event.target ||
										event.srcElement;


		//9. Проверить, если xhr.readyState != 4, завершить работу функции-обработчика.
		if(xhr.readyState != 4) return;


		//10. Получить тело ответа, и записать его в innerHTML кнопки (1) из п.3.
		button.innerHTML = xhr.responseText;


		//11. Записать в span.innerHTML (3) из п.3 текущую дату и время клиента.
		spanEnd.innerHTML = new Date();


		//12. Записать в span.innerHTML (4) из п.4 разницу между временами из
		//		 п.9 и п.6 в секундах по модулю.
		spanDiff.innerHTML = 	((Date.parse(spanEnd.innerHTML) -
														Date.parse(spanStart.innerHTML))
														/1000).toFixed(2) + ' сек.';




	};




};













// Вспомогательные функции



	//FixEvent - FIX всех IE-несовместимостей при работе с событиями
	// в 1-й функции
	function fixEvent(e, _this) {
		e = e || window.event;

		if (!e.currentTarget) e.currentTarget = _this;
		if (!e.target) e.target = e.srcElement;

		if (!e.relatedTarget) {
			if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
			if (e.type == 'mouseout') e.relatedTarget = e.toElement;
		}

		if (e.pageX == null && e.clientX != null ) {
			var html = document.documentElement;
			var body = document.body;

			e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
			e.pageX -= html.clientLeft || 0;

			e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
			e.pageY -= html.clientTop || 0;
		}

		if (!e.which && e.button) {
			e.which = e.button & 1 ? 1 : ( e.button & 2 ? 3 : (e.button & 4 ? 2 : 0) );
		}

		return e;
	}