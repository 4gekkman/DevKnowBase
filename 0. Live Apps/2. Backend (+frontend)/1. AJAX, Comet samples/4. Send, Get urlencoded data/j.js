/**
 *
 * Задача:
 *
 * > Сделать приложение, которое демонстрирует живой пример
 * 	 XHR-отправки клиентом и получения на сервере данных
 * 	 в формате urlencoded. В примере должны рассматриваться:
 * 	 - Запросы как методом GET, так и методом POST.
 * 	 - Формирование тела вручную.
 * 	 - На сервере, для методов GET и POST, как ручное получение,
 * 	 	 так и автоматическое через массивы $_GET и $_POST
 *
 * > Таким образом получается следующее:
 * 	 - Тело надо формировать 1-м способом - вручную.
 * 	 - Запросы надо делать 2-мя методами - GET и POST.
 * 	 - На сервере принимать/парсить посылку надо 3-мя способами:
 * 	 	 вручную, $_GET, $_POST.
 *
 * 	 В итоге получается:
 * 	 - 3 варианта отправки данных
 * 	 - 3 варианта получения данных
 *
 * > Итого, ниже полный список задач, которые нужно решить в
 * 	 этом приложении:
 *
 * 	 1. Отправка:
 * 	 		- Формирование тела: вручную.
 * 	 		- Метод: GET
 * 	 	  Получение:
 * 	 	  - Вручную
 * 	 	  - В $_GET
 *
 * 	 2. Отправка:
 * 	 		- Формирование тела: вручную.
 * 	 		- Метод: POST
 * 	 	  Получение:
 * 	 	  - Вручную
 * 	 	  - В $_POST

 *
 * > Как визуально будет выглядеть решение, какой у него будет интерфейс?
 *	 Будут следующие элементы интерфейса:
 *
 *	 1. Форма с 3-мя текстовыми полями без кнопок.
 *	 	  - Под формой будет отображатсья итоговая строка в формате
 *	 	  	urlencoded, сформированная из значений полей этой формы.
 *	 	  - На каждом из текстовых полей формы будет висеть обработчик
 *	 	  	события onkeydown, и при каждом вводе/удалении буквы
 *	 	  	в любом из текстовых полей будет меняться и итоговая
 *	 	   	строка под формой.
 *
 *	 2. Кнопка "отправить методом GET", и под ней div.
 *	 		- Позиционирование с помощью таблицы.
 *	 		- При нажатии на кнопку сформированная в п.1 строка
 *	 			отправляется с XHR-запросом на сервер методом GET.
 *	 	  - Ответ сервера - HTML-страница, в которой он показывает
 *	 	  	результат ручного извлечения данных, и результат
 *	 	  	автоматического (с помощью $_GET).
 *	 	  - Эта самая HTML-страница отобразится в этом div.
 *
 *	 3. Кнопка "отправить методом POST", и под ней div.
 *	 		- Позиционирование с помощью таблицы, справа от
 *	 			кнопки и div из п.2.
 *	 		- При нажатии на кнопку сформированная в п.1 строка
 *	 			отправляется с XHR-запросом на сервер методом POST.
 *	 	  - Ответ сервера - HTML-страница, в которой он показывает
 *	 	  	результат ручного извлечения данных, и результат
 *	 	  	автоматического (с помощью $_POST).
 *	 	  - Эта самая HTML-страница отобразится в этом div.
 *
 *
 *
 *
 * Архитектура решения (клиент):
 *
 * 1. Подготовить весь необходимый HTML и CSS:
 * 		- Форму с 3-мя текстовыми полями input type='text'.
 * 		- Поле p для отображения подготовленной тела-строки
 * 		- Таблица 2х2, содержащая 2 кнопки, и 2 div.
 *
 * 2. Получить ссылки на нижеуказанные элементы, и сохранить их
 * 		все в объекте refs.
 * 		- На саму форму form
 * 		- На все элементы формы с помощью form.elements.
 * 		- На поле p
 * 		- На кнопку "отправить методом GET"
 * 		- На кнопку "отправить методом POST"
 * 		- На div для получения ответа от отправки методом GET
 * 		- На div для получения ответа от отправки методом POST
 *
 *
 * [Шаг 1 и Шаг 2]
 *
 * 3. Написать функцию, которая принимает 3 пары имя/значение, всего 6 параметров,
 * 		формирует из них строку в формате urlencoded, и возвращает её.
 *
 * 4. Применить функцию из п.3, используя стартовые значения из формы,
 * 		после загрузки всего документа (после события onload)
 *
 *
 * 5. Назначить форме form функцию-обработчик события onkeydown.
 * 		Цель - отслеживать нажатие клавиш на каждом из 3-х элементов
 * 		input. И выполнить в ней следующее: [6-8]
 *
 * 6. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
 * 		Также, кроссбраузерно получить target-элемент
 *
 * 7. Проверить, если target - это не один из input-элементов формы, то
 * 		завершить работу функции-обработчика.
 *
 * 8. Записать в innerHTML элемента p строку в формате urlencoded, которую вернёт
 * 		функция из п.6, которой в качестве значений переданы значения, введённые
 * 		в элементы input формы.
 *		- Причём здесь надо пропустить действия браузера по умолчанию вперёд в
 *			стеке задач, т.к. иначе в input.value всё еще будут старые значения
 *      на текущий момент. Сделать это с помощью польз. ф-ии setImmediate.
 *
 *
 * [Шаг 3]
 *
 * 9. Назначить функцию-обработчик события onclick для кнопки, которая
 * 		должна отправить запрос на сервер методом GET. В ней выполнить
 * 		следующее: [10]
 *
 * 10. Отправить на сервер XHR-запрос:
 * 		 - Методом GET
 * 		 - В качестве query string послать подготовленную на шаге 2 строку-тело.
 * 		 - Подготовить функцию-обработчик события onreadystatechange для
 * 		 	 приёма ответа, и в ней выполнить следующе: [11]
 *
 * 11. Получить ответ с сервера и записать его в innerHTML блока div под
 * 		 нажатой кнопкой.
 *
 *
 *
 * 12. Назначить функцию-обработчик события onclick для кнопки, которая
 * 		 должна отправить запрос на сервер методом POST. В ней выполнить
 * 		 следующее: [13]
 *
 * 13. Отправить на сервер XHR-запрос:
 * 		 - Методом POST
 * 		 - Обязательно послать заголовок:
 * 			 "Content-Type: application/x-www-form-urlencoded",
 * 			 > Если этого не сделать, "по умолчанию" при отправке этого POST-
 *				 запроса будет отправлен заголовок "Content-Type: text/plain",
 * 				 Т.О. сервер неправильно поймёт формат полученного тела, не сможет
 * 				 его распарсить, и массив $_POST будет пуст.
 * 		 - В качестве тела послать подготовленную на шаге 2 строку-тело.
 * 		 - Подготовить функцию-обработчик события onreadystatechange для
 * 		 	 приёма ответа, и в ней выполнить следующе: [14]
 *
 *
 * 14. Получить ответ с сервера и записать его в innerHTML блока div под
 * 		 нажатой кнопкой.
 *
 *
 *
 *
 *
 *
 *
 *
 * Архитектура решения (сервер):
 *
 * 1. Написать функцию, которая принимает строку в формате urldecoded,
 * 		а на выходе возвращает массив декодированных пар имя/значение.
 *
 * 2. Проверить с помощью функции empty():
 * 		- если суперглобальный массив $_GET не пуст, то выполнить
 * 			следующее: [2,3,]
 * 	 	- если суперглобальный массив $_POST не пуст, то выполнить
 * 	 		следующее: [2]
 *
 *
 * 3. Вывести в выходной поток следующую информацию:
 * 		- Пары имя-значение, извлечённые из query string вручную
 * 		- Пары имя-значения из массива $_GET
 * 		> Причём, каждая из этих груб должна быть соответствующе помечена,
 * 			и отделена от другой.
 *
 *
 * 4. Вывести в выходной поток следующую информацию:
 * 		- Пары имя-значение, извлечённые из query string вручную
 * 		- Пары имя-значения из массива $_POST
 * 		> Причём, каждая из этих груб должна быть соответствующе помечена,
 * 			и отделена от другой.
 *
 *
 *
 *
 *
 *
 *
 */


// Задействованные переменные
var target,					// целевой элемент события
		refs,						// в этом объекте лежат ссылки на все нужные объекты
		makeUrlencoded,	// функция, которая возвращает строку в формате urlencoded
		xhr;						// объект XMLHttpRequest




//2. Получить ссылки на нижеуказанные элементы, и сохранить их
//		все в объекте refs.
//		- На саму форму form
//		- На все элементы формы с помощью form.elements.
//		- На поле p
//		- На кнопку "отправить методом GET"
//		- На кнопку "отправить методом POST"
//		- На div для получения ответа от отправки методом GET
//		- На div для получения ответа от отправки методом POST
refs = {};
refs.form = document.getElementById('myForm');
refs.nameInput = document.getElementById('name');
refs.surnameInput = document.getElementById('surname');
refs.ageInput = document.getElementById('age');
refs.stringBody = document.getElementById('stringBody');

refs.getButton = document.getElementById('get');
refs.postButton = document.getElementById('post');
refs.getDiv = document.getElementById('getDiv');
refs.postDiv = document.getElementById('postDiv');



//3. Написать функцию, которая принимает 3 пары имя/значение, всего 6 параметров,
//		формирует из них строку в формате urlencoded, и возвращает её.
makeUrlencoded = function(a1,a2, b1,b2, c1,c2) {

	var body = a1 + '=' + encodeURIComponent(a2) + '&' +
						 b1 + '=' + encodeURIComponent(b2) + '&' +
						 c1 + '=' + encodeURIComponent(c2);

	return body;

};



//4. Применить функцию из п.3, используя стартовые значения из формы,
//		после загрузки всего документа (после события onload)
window.onload = function() {

	refs.stringBody.innerHTML =
			makeUrlencoded(	'name', refs.nameInput.value,
											'surname', refs.surnameInput.value,
											'age', refs.ageInput.value );

};






//5. Назначить форме form функцию-обработчик события onkeydown.
//		Цель - отслеживать нажатие клавиш на каждом из 3-х элементов
//		input. И выполнить в ней следующее: [4-7]
refs.form.onkeypress = function(event) {


	//6. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
	//		Также, кроссбраузерно получить target-элемент

		//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
		event = fixEvent(event);

		//Кроссбраузерно получить target-элемент
		target = 	event && event.target ||
									event.srcElement;




	//7. Проверить, если target - это не один из input-элементов формы, то
	//		завершить работу функции-обработчика.
	if(target === refs.nameInput ||
		 target === refs.surnameInput ||
		 target === refs.ageInput) {}
	else return;




	//8. Записать в innerHTML элемента p строку в формате urlencoded, которую вернёт
	//		функция из п.6, которой в качестве значений переданы значения, введённые
	//		в элементы input формы.
	//		- Приём здесь надо пропустить действия браузера по умолчанию вперёд в
	//			стеке задач, т.к. иначе в input.value всё еще будут старые значения
	//      на текущий момент. Сделать это с помощью польз. ф-ии setImmediate.
	setImmediate(function() {
		refs.stringBody.innerHTML =
				makeUrlencoded(	'name', refs.nameInput.value,
												'surname', refs.surnameInput.value,
												'age', refs.ageInput.value );
	});



};




//9. Назначить функцию-обработчик события onclick для кнопки, которая
//		должна отправить запрос на сервер методом GET. В ней выполнить
//		следующее: [10]
refs.getButton.onclick = function() {


	//10. Отправить на сервер XHR-запрос:
	//		 - Методом GET
	//		 - В качестве query string послать подготовленную на шаге 2 строку-тело.
	//		 - Подготовить функцию-обработчик события onreadystatechange для
	//		 	 приёма ответа, и в ней выполнить следующе: [11]

		// Подготовить XHR-запрос
		xhr = new XMLHttpRequest();
		xhr.open('GET','server.php?' +
				makeUrlencoded(	'name', refs.nameInput.value,
												'surname', refs.surnameInput.value,
												'age', refs.ageInput.value )
				,true);
		xhr.onreadystatechange = function(event) {

			//Проверить, если xhr.readyState != 4, завершить работу функции-обработчика.
			if(xhr.readyState != 4) return;


			//11. Получить ответ с сервера и записать его в innerHTML блока div под
			//		 нажатой кнопкой.
			refs.getDiv.innerHTML = xhr.responseText;


		};

		// Отправить XHR-запрос на сервер
		xhr.send('');

};



//12. Назначить функцию-обработчик события onclick для кнопки, которая
//		должна отправить запрос на сервер методом POST. В ней выполнить
//		следующее: [13]
refs.postButton.onclick = function() {


	//13. Отправить на сервер XHR-запрос:
	//		 - Методом POST
	//		 - Обязательно послать заголовок:
	//			 "Content-Type: application/x-www-form-urlencoded",
	//			 > Если этого не сделать, "по умолчанию" при отправке этого POST-
	//				 запроса будет отправлен заголовок "Content-Type: text/plain",
	//				 Т.О. сервер неправильно поймёт формат полученного тела, не сможет
	//				 его распарсить, и массив $_POST будет пуст.
	//		 - В качестве тела послать подготовленную на шаге 2 строку-тело.
	//		 - Подготовить функцию-обработчик события onreadystatechange для
	//		 	 приёма ответа, и в ней выполнить следующе: [14]

		// Подготовить XHR-запрос
		xhr = new XMLHttpRequest();
		xhr.open('POST','server.php',true);

			// Отправить необходимый заголовок
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');

			// Подготовить функцию-обработчик события onreadystatechange
			xhr.onreadystatechange = function(event) {

				//Проверить, если xhr.readyState != 4, завершить работу функции-обработчика.
				if(xhr.readyState != 4) return;


				//14. Получить ответ с сервера и записать его в innerHTML блока div под
				//		 нажатой кнопкой.
				refs.postDiv.innerHTML = xhr.responseText;


			};


		// Отправить XHR-запрос на сервер
		xhr.send(
			makeUrlencoded(	'name', refs.nameInput.value,
											'surname', refs.surnameInput.value,
											'age', refs.ageInput.value )
		);

};














// Вспомогательные функции



	//FixEvent - FIX всех IE-несовместимостей при работе с событиями
	// в 1-й функции
	function fixEvent(e, _this) {
		e = e || window.event;

		if (!e.currentTarget) e.currentTarget = _this;
		if (!e.target) e.target = e.srcElement;

		if (!e.relatedTarget) {
			if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
			if (e.type == 'mouseout') e.relatedTarget = e.toElement;
		}

		if (e.pageX == null && e.clientX != null ) {
			var html = document.documentElement;
			var body = document.body;

			e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
			e.pageX -= html.clientLeft || 0;

			e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
			e.pageY -= html.clientTop || 0;
		}

		if (!e.which && e.button) {
			e.which = e.button & 1 ? 1 : ( e.button & 2 ? 3 : (e.button & 4 ? 2 : 0) );
		}

		return e;
	}



//setImmediate				| (пользовательская функция) позволяет поставить выполнение
//											func в очередь на ближайшее время после текущего кода, и без задержек
// > Это эмуляция ф-ии setImmediate
// > Добавляется как метод window (а если дело происходит в IE>=10, где такая
//   функция уже есть, то не добавляется)
// > Здесь используется прием cross-domain-messaging:
//		> Позволяет скрипту из одного документа передавать текстовые сообщения
//			скрипту в другом документе, не взирая на ПОП.
//		> Отправить сообщение можно методом Window.postMessage(). Он производит
//			асинхронную отправку сообщения.
//		> Получить сообщение можно обработчиком события onmessage.
// > Работает во всех браузерах, кроме IE<=7


	// Проверить cледующее:
	// > Если это IE>=10, и ф-ия setImmediate есть, то ничего не добавлять.
	// > В ином случае, добавить объекту window метод setImmediate:
	if (!window.setImmediate) window.setImmediate = (function() {
		var head = { }, tail = head; // очередь вызовов, 1-связный список

		var ID = Math.random(); // уникальный идентификатор

		// Подготовка функции-перехватчика события message из другого документа
		function onmessage(e) {
			if(e.data != ID) return; // не наше сообщение
			head = head.next;
			var func = head.func;
			delete head.func;
			func();
		}

		// Кросдоменное назначение обработчика событий onmessage
		if(window.addEventListener) { // IE9+, другие браузеры
			window.addEventListener('message', onmessage, false);
		} else { // IE8
			window.attachEvent( 'onmessage', onmessage );
		}

		// > Если это не IE<=7, то поставить func в конец текущей очереди
		// > Если это IE<=7, то вызвать для func обычный setTimeout.
		return window.postMessage ? function(func) {
			tail = tail.next = { func: func };
			window.postMessage(ID, "*");
		} :
		function(func) { // IE<8
			setTimeout(func, 0);
		};
	}());


