/**
 * Задача:
 *
 * > Написать приложение, которое обладает следующими свойствами:
 * 	 > Есть файл server.php, который представляет в этом приложении сервер.
 * 	 > При получении запроса сервер должен действовать по разному, в зависимости
 * 	 	 от того, является ли этот запрос AJAX-запросом:
 * 	 	 - Если является, то он должен просто вернуть серверное время
 * 	 	 - Если не является, то он должен вернуть HTML-документ.
 *
 * > Как сервер будет узнавать, AJAX это запрос, или нет?
 * 	 - Для этого клиент если это AJAX-запрос, должен посылать серверу
 * 	 	 специальный заголовок:
 *
 * 	 	  xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
 *
 * 	 	 Сервер будет его проверять и решать:
 * 	 	 - Если такого заголовка нет, значит это не AJAX-запрос
 * 	 	 - Если такой заголовок есть, значит это AJAX-запрос
 *
 * > Сделать 2 кнопки.
 * 	 > При нажатии на 1-ю происходит XHR-запрос на сервер,
 * 	 	 отсылается соотв. заголовок, и сервер возвращает
 * 	 	 ответ в виде серверного времени, которое и отображается
 * 	 	 в тексте кнопки.
 * 	 > При нажатии на 2-ю кнопку идёт обычный запрос к серверу,
 * 	 	 и в iframe выводится его ответ - HTML-документ со списком,
 * 	 	 в котором перечислены цифры от 0 до 100.
 *
 *
 * Архитектура решения (клиент):
 *
 * 1. Подготовить HTML и CSS. В т.ч.:
 * 		- кнопки
 * 	 	- iframe
 *
 * 2. Получить ссылки на следующие эл-ты:
 * 		- Кнопку №1 - для отправки XHR-запроса
 * 	 	- Кнопку №2 - для отправки НЕ XHR-запроса
 * 	 	- iframe
 *
 *
 *
 * 3. Назначить для кнопки №1 из п.2 функцию-обработчик onclick.
 * 		В ней выполнить следующее: [4,5]
 *
 * 4. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
 * 		Также, кроссбраузерно получить target-элемент
 *
 * 5. Выполнить асинхронный XHR-запрос методом POST на сервер:
 * 		- Тело запросу пусто
 * 		- С запросом послать HTTP-заголовок:
 * 			setRequestHeader("X-Requested-With", "XMLHttpRequest");
 * 	  - Назначить объекта xhr стандартную функцию-обработчик для
 * 	  	события onreadystatechange с проверкой на xhr.readyState != 4
 * 	  	для получения ответа сервера.	В этом обработчике выполнить
 * 	  	следующее: [6]
 *
 * 6. Записать в innerHTML кнопки полученный с сервера ответ
 * 		(серверные дату и время)
 *
 *
 *
 * 7. Назначить для кнопки №2 из п.2 функцию-обработчик onclick.
 * 		В ней выполнить следующее: [4,8]
 *
 * 8. Назначить атрибуту iframe.src значение-адрес файла server.php.
 * 		Это будет равнозначно тому, чтобы послать на сервер обычный
 * 		запрос GET.
 *
 *
 *
 * Архитектура решения (сервер):
 *
 * 1. Проверить значение HTTP-заголовка "X-Requested-With".
 * 		- Если оно равно "XMLHttpRequest", то выполнить: [2]
 * 		- Если оно НЕ равно "XMLHttpRequest", то выполнить: [3]
 *
 * 2. Послать в выходной буфер серверную дату и время.
 *
 * 3. Послать в выходной буфер HTML-страницу со списком,
 * 		в котором перечислены все цифры от 0 до 100.
 *
 *
 *
 *
 */


// Задействованные переменные
var target,		// целевой эл-т события
		button1,	// ссылка на кнопку 1
		button2,	// ссылка кнопку 2
		iframe,		// ссылка на iframe
		xhr;			// объект XMLHttpRequest



//2. Получить ссылки на следующие эл-ты:
//		- Кнопку №1 - для отправки XHR-запроса
//	 	- Кнопку №2 - для отправки НЕ XHR-запроса
//	 	- iframe
button1 = document.getElementById('ajax');
button2 = document.getElementById('noajax');
iframe = document.getElementById('iframe');



//3. Назначить для кнопки №1 из п.2 функцию-обработчик onclick.
//		В ней выполнить следующее: [4,5]
button1.onclick = function(event) {


	//4. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
	//		Также, кроссбраузерно получить target-элемент

		//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
		event = fixEvent(event);

		//Кроссбраузерно получить target-элемент
		target = 	event && event.target ||
									event.srcElement;



	//5. Выполнить асинхронный XHR-запрос методом POST на сервер:
	//		- Тело запросу пусто
	//		- С запросом послать HTTP-заголовок:
	//			setRequestHeader("X-Requested-With", "XMLHttpRequest");
	//	  - Назначить объекта xhr стандартную функцию-обработчик для
	//	  	события onreadystatechange с проверкой на xhr.readyState != 4
	//	  	для получения ответа сервера.	В этом обработчике выполнить
	//	  	следующее: [6]

		// Подготовить XHR-запрос
		xhr = new XMLHttpRequest();
		xhr.open('POST','server.php',true);
		xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
		xhr.onreadystatechange = function(event) {


			//Проверить, если xhr.readyState != 4, завершить работу функции-обработчика.
			if(xhr.readyState != 4) return;

			console.log('123');

			//6. Записать в innerHTML кнопки полученный с сервера ответ
			//		(серверные дату и время)
			button1.innerHTML = xhr.responseText;


		};

		// Отправить XHR-запрос на сервер
		xhr.send('');


};



//7. Назначить для кнопки №2 из п.2 функцию-обработчик onclick.
//		В ней выполнить следующее: [4,8]
button2.onclick = function(event) {


	//4. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами.
	//		Также, кроссбраузерно получить target-элемент

		//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
		event = fixEvent(event);

		//Кроссбраузерно получить target-элемент
		target = 	event && event.target ||
									event.srcElement;



	//8. Назначить атрибуту iframe.src значение-адрес файла server.php.
	//		Это будет равнозначно тому, чтобы послать на сервер обычный
	//		запрос GET.
	iframe.src = 'server.php';




};






// Вспомогательные функции



	//FixEvent - FIX всех IE-несовместимостей при работе с событиями
	// в 1-й функции
	function fixEvent(e, _this) {
		e = e || window.event;

		if (!e.currentTarget) e.currentTarget = _this;
		if (!e.target) e.target = e.srcElement;

		if (!e.relatedTarget) {
			if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
			if (e.type == 'mouseout') e.relatedTarget = e.toElement;
		}

		if (e.pageX == null && e.clientX != null ) {
			var html = document.documentElement;
			var body = document.body;

			e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
			e.pageX -= html.clientLeft || 0;

			e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
			e.pageY -= html.clientTop || 0;
		}

		if (!e.which && e.button) {
			e.which = e.button & 1 ? 1 : ( e.button & 2 ? 3 : (e.button & 4 ? 2 : 0) );
		}

		return e;
	}










