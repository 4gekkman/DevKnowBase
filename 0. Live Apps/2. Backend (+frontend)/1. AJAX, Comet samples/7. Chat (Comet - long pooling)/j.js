/**
 * Задача:
 *
 * > Для демонстрации живого примера архитектуры Comet, организованной
 * 	 с помощью объекта XMLHttpRequest на основе длинных опросов, создать
 * 	 простейшее приложение типа "ЧАТ". Оно должно обеспечивать следующее:
 * 	 - Возможность указать свой nickname.
 * 	 - Возможность написать сообщение и отправить его нажатием на кнопку.
 * 	 - Возможность наблюдать окно с отправленными сообщениями:
 * 	 	 - Новые сообщение должны появлятсья сверху.
 * 	 	 - При появлении нового сообщения все старые сообщения съезжают вниз.
 * 	 	 - Каждое сообщение содержит:
 * 	 	 	 - Дату и время отправки
 * 	 	 	 - Nickname отправителя
 * 	 	 	 - Само, собственно, сообщение.
 *
 *
 *
 * > Как построена архитектура серверной части.
 *
 * 	 > Серверная часть (в лице PHP-файлов) включает в себя также
 * 	 	 взаимодействие с базой данных.
 *
 * 	 > С этом приложении серверная часть состоит из 4-х php-файлов:
 * 	 	 - install.php
 * 	 	 - init.php
 * 	 	 - addMessage.php
 * 	 	 - update.php
 *
 * 	 > Про install.php
 * 	 	 > Это установочный файл.
 * 	 	 > Его нужно запустить перед началом эксплуатации приложения.
 * 	 	 > Этот файл настраивает необходимую для приложения структуру БД.
 *
 * 	 > Про init.php
 * 	 	 > Этот файл отправляет клиенту историю сообщений чата, когда
 * 	 	 	 клиент открывает страницу с чатом.
 *
 * 	 > Про addMessage.php
 * 		 > Когда клиент нажимает на кнопку "отправить", этот файл
 * 		 	 принимает от него данные, и записывает их в базу данных.
 *
 * 	 > Про update.php
 * 	 	 > Этот файл - серверная часть архитектуры "длинных опросов".
 * 		 > Когда любой клиент посылает сообщение в чат, оно сохраняется
 * 		 	 файлоа addMessage.php в БД, то update.php отслеживает это,
 * 		 	 и посылает всем клиентам запрос с данными о новом сообщении
 * 		 	 (а клиенты уже отображают его в окне чата).
 * 		 > Этот файл реализует архитектуру "длинных опросов" по следующему
 * 		 	 основному принципу:
 * 		 	 - Сервер фиксирует timestamp при получении запроса от клиента.
 * 		 	 - Сервер оставляет соединение открытым, периодически опрашивая
 * 		 	 	 базу данных - не обновилась ли она, сравнивая дату и время
 * 		 	 	 её последнего обновления и сохранённый в предыдущем пункте
 * 		 	 	 timestamp.
 * 		 	 - Когда он фиксирует обновление базы данных, то упаковывает
 * 		 	 	 новую информацию в JSON-стрку и отправляет клиенту.
 *
 * > Какова будет структура таблицы с сообщениями в базе данных:
 *	 > Столбцы:
 *
 * 	 		id		timestamp 	nickname		message
 *
 *	 	> id    | int  | auto_increment
 *	 	> timestamp		| timestamp |
 *	 	> nickname		| varchar	|
 *	 	> message			|	varchar |
 *
 *
 *
 *
 *
 * > Архитектура решения (клиент):
 *
 *
 * [Подготовка]
 *
 * 1. Подготовить весь необходимый HTML и CSS.
 *
 * 2. Получить ссылки на нижеуказанные элементы, и сохранить их
 * 		все в объекте refs:
 * 	  - На окно с опубликованными сообщениями
 * 	  - На поле, куда пользователь должен ввести свой nickname
 * 	  - На поле, куда пользователь должен ввести своё сообщение
 * 	  - На кнопку "отправить"
 *
 * 3. Написать функцию, которая добавляет новое сообщение в самый верх
 * 		окна с сообщениями. Она должна принимать следующие аргументы:
 * 	 	- Никнэйм
 * 	 	- Дату и время
 * 	 	- Текст сообщения
 *
 *
 * [Первоначальное наполнение чата - при загрузке страницы]
 *
 * 4. Отправить на сервер (в файл init.php) XHR-запрос методом GET.
 *
 * 5. Получить ответ в виде JSON-строки со всеми сообщениями чата, имеющимися
 * 		на данный момент в базе данных.
 * 		- С помощью функции JSON.parse преобразовать эту JSON-строку в объект.
 *
 * 6. Пробежаться по собственным св-вам объекта, полученного в п.6,
 *  	и с помощью функции из п.3 вывести все все полученные сообщения
 *  	в окно чата. Т.О. когда человек откроет HTML-страницу с чатом,
 *  	то он увидит все сообщения, которые были отправлены другими людьми
 * 		в этот чат.
 *
 *
 * [Сохранение нового введённого сообщения в базе данных]
 *
 * 7. Назначить функцию-обработчик события onclick кнопке "Отправить".
 * 		В ней выполнить следующее: [8]
 *
 * 8. Подготовить для отправки в теле запроса строку в формате
 * 		urlencoded, которая должна содержать nickname и message.
 *
 * 9. Отправить на сервер (в файл addMessage.php) XHR-запрос методом POST,
 * 		в теле которого передать подготовленную в п.8 строку в формате
 * 		urlencoded.
 *
 *
 * [Реализация архитектуры "длинные опросы" - чтобы чат обновлялся, когда приходят новые сообщения]
 *
 * 10. Написать функцию, которая реализует клиентскую часть архитектуры
 * 		 "длинные опросы". Она должна делать следующее (ключевые моменты):
 * 		 - Принимать в кач-ве аргумента URL-адрес серверного файла.
 * 		 - Осущетсвлять XHR-запрос методом GET к серверу без передачи данных.
 * 		 - В конце кода функции-обработчика, которая ловит ответ, рекурсивно
 * 		 	 запускать саму себя.
 * 		 - А также в этой функции-обработчике выполнять следующее: [11,12]
 *
 * 11. Получить ответ в виде JSON-строки с новыми сообщениями чата, имеющимися
 * 		 на данный момент в базе данных.
 * 		 - С помощью функции JSON.parse преобразовать эту JSON-строку в объект.
 *
 * 12. Пробежаться по собственным св-вам объекта, полученного в п.6,
 *  	 и с помощью функции из п.3 вывести все все полученные сообщения
 *  	 в окно чата. Т.О. когда любой пользователь будет посылать новое
 *  	 сообщение в чат, у всех пользователей оно будет тут же появляться
 *  	 в окне чата.
 *
 * 13. Запустить функцию из п.10 с URL равным update.php
 *
 *
 *
 *
 *
 *
 *
 * > Архитектура решения (сервер и база данных):
 *
 *
 * [Создание "установочного" PHP-файла]
 * install.php
 *
 * 1. Создать "установочный" PHP-файл для приложения ЧАТ.
 * 		Этот файл надо будет запустить вручную перед эксплуатацией
 * 		приложения с конкретным сервером MySQL.
 * 		Выполнить в нём следующее: [2-6]
 *
 * 2. Подключиться к серверу MySQL.
 *
 * 3. Если еще не существует, создать базу данных forRefDB.
 * 		И использовать её по умолчанию.
 *
 * 4. Если еще не существует, создать таблицу forRefDB.forChat
 * 		В таблице должно быть 4 столбца:
 * 		- id				 	тип: INT 				| с автоинкрементом
 * 		- timestamp		тип: TIMESTAMP
 * 		- nickname		тип: varchar(30)
 * 		- message			тип: varchar(256)
 *
 * 5. Удалить хранимую процедуру populateTable, если существует.
 * 		Создать хранимую процедуру populateTable, выполнить её, а затем удалить.
 * 		Она должна делать следующее:
 * 		- Если кол-во строк в таблице = 0, то добавит в таблицу
 * 			3 демо-строки, просто чтобы она не пустовала.
 * 	  - Если > 0, то ничего не будет делать.
 *
 * 6. Удалить хранимую процедуру addMessage, если существует.
 * 		Создать хранимую процедуру addMessage.
 * 		Она должна принимать 3 параметра - timestamp, nickname и message.
 * 		Она должна делать следующее:
 * 		- Добавлять в базу данных новую запись:
 * 			(NULL, timestamp, nickname, message).
 *
 * 7. Отключиться от MySQL.
 *
 *
 * [Создание PHP-файла для инициации чата при 1-м подключении]
 * init.php
 *
 * 1. Подключиться к серверу MySQL.
 *
 * 2. Извлечь все данные из таблицы forRefDB.forChat в массив.
 *
 * 3. Отключиться от MySQL.
 *
 * 4. Сформировать из массива из п.2 JSON-строку указанного формата.
 * 		Формат соответствует формату, который возвращает PHP-функция
 *    json_encode().
 *
 * 5. Отправить в выходной буфер подготовленную в п.4 JSON-строку
 *
 *
 *
 * [Создание PHP-файла, принимающего и сохраняющего новое сообщение в БД]
 * addMessage.php
 *
 * 1. Проверить, если переменные $_POST['nickname'] и $_POST['message']
 * 		не пусты, то выполнить следующее: [2,3,4]
 *
 * 2. Подключиться к серверу MySQL.
 *
 * 3. Выполнить процедуру addMessage с параметрами из п.1
 *
 * 4. Отключиться от MySQL.
 *
 *
 * [Создание PHP-файла, посылающего клиенту данные при обновлении БД]
 * update.php
 *
 * 0. Установить опцию ini_set("max_execution_time", "0") - это значит,
 * 		что скрипт сможет бесконечно выполняться, и не будет таймаута.
 * 		- В этом приложении это нужно, потому что используется архитектура
 * 			"длинных опросов", где соединение клиента с сервером остаётся
 * 			открытым довольно долгое время (пока никто не пишет в чат).
 *
 * 1. Сохранить текущий timestamp в переменную.
 * 		Сохранить также текущую дату и время в формате Y-m-d H:i:s в переменную.
 *
 * 2. Подключиться к серверу MySQL.
 *
 * 3. Устроить цикл while. В цикле делать следующее: [3,4]
 *
 * 4. Получить timestamp последнего изменения таблицы forChat из БД.
 *
 * 5. Сравнить timestampы из п.1 и п.4.
 * 		- Если п3 >= п1, то сделать: [6-10]
 * 		- Если п3	< п1, то сделать: [11,12]
 *
 * 6. Извлечь все данные из таблицы forRefDB.forChat в массив, для которых
 * 		timestamp из п.3 >= timestamp из п.1.
 *
 * 7. Сформировать из массива из п.6 JSON-строку указанного формата.
 * 		Формат соответствует формату, который возвращает PHP-функция
 *    json_encode().
 *
 * 8. Отправить в выходной буфер подготовленную в п.8 JSON-строку
 *
 * 9. Применить функцию usleep, чтобы программа "заснула" на 1 секунду,
 *     и завершить цикл while.
 *     - Ждать нужно для того, чтобы данные успели записаться в
 *       базу данных до следующего запроса.
 *
 * 10. Применить функцию usleep, чтобы программа "заснула" на 1 секунду.
 *
 * 11. Перейти на следующую итерацию цикла с помощью continue
 *
 * 12. Отключиться от MySQL.
 *
 *
 *
 *
 *
 *
 *
 */



/* Подготовка
================================*/


// Задействованные переменные
var target,				// целевой элемент события
		addMessage,		// функция, которая добавляет новое сообщение в самый верх окна с сообщениями
		subscribe,		// функция, которая отправляет на сервер запрос, и архитектура которой соответствует архитектуре техники "длинные опросы".
		JSONToArray,	// функция, которая принимает JSON-строку, парсит её, и возвращает массив
		xhr;					// объекр XMLHttpRequest

//2. Получить ссылки на нижеуказанные элементы, и сохранить их
//		все в объекте refs:
//	  - На окно с опубликованными сообщениями
//	  - На поле, куда пользователь должен ввести свой nickname
//	  - На поле, куда пользователь должен ввести своё сообщение
//	  - На кнопку "отправить"
var refs = {};
refs.mesWin = document.getElementById('messagesWindow');
refs.nickname = document.getElementById('nickname');
refs.message = document.getElementById('message');
refs.sendButton = document.getElementById('sendButton');





//3. Написать функцию, которая добавляет новое сообщение в самый верх
//		окна с сообщениями. Она должна принимать следующие аргументы:
//	 	- Никнэйм
//	 	- Дату и время
//	 	- Текст сообщения
addMessage = function(timestamp, nickname, message) {

	// Получить строку с датой и временем
	var timeDate = new Date(timestamp).toLocaleString();

	// Опубликовать сообщение
	refs.mesWin.insertAdjacentHTML('afterBegin',
			'<p class="messageBox">' +
			'<span class="messageHeader">'+nickname+' ('+timeDate+') '+'</span><br>' +
			'<span>'+message+'</span>' +
			'</p>');

};
		/*
		// Тест функции addMessage
		addMessage(new Date(),'John','Всем привет!');
		addMessage(new Date(),'John','Как дела?');
		addMessage(new Date(),'John','Lorem ipsum dolor sit amet, consectetur adipisicing elit. Architecto beatae culpa cumque eaque eligendi et excepturi fugiat harum mollitia nobis perferendis praesentium quo rem, sunt vero voluptates voluptatum. Blanditiis, expedita?');
		*/



/* Первоначальное наполнение чата - при загрузке страницы
================================*/


//4. Отправить на сервер (в файл init.php) XHR-запрос методом GET.

	// Создать новый объект XMLHttpRequest
	xhr = new XMLHttpRequest();

	// Настроить XHR-запрос
	xhr.open("GET", 'init.php', true);

	// Назначить функцию-обработчик для того, чтобы поймать ответ сервера
	xhr.onreadystatechange = function() {

		// Если состояние запроса не 4, завершить работу функции-обработчика
		if (this.readyState != 4) return;


		// Если ответ от сервера пришел с кодом 200 (завершился удачей):
		if (this.status == 200) {

			console.log(xhr.responseText);
			//5. Получить ответ в виде JSON-строки со всеми сообщениями чата, имеющимися
			//		на данный момент в базе данных.
			//		- С помощью функции JSON.parse преобразовать эту JSON-строку в объект.
			var responseObject = JSON.parse(xhr.responseText);



			//6.  Пробежаться по собственным св-вам объекта, полученного в п.6,
			// 		и с помощью функции из п.3 вывести все все полученные сообщения
			// 		в окно чата. Т.О. когда человек откроет HTML-страницу с чатом,
			// 		то он увидит все сообщения, которые были отправлены другими людьми
			// 		в этот чат.

			for(var key in responseObject) {
				if (responseObject.hasOwnProperty(key)) {

					addMessage( responseObject[key]['timestamp'],
											responseObject[key]['nickname'],
											responseObject[key]['message'] );

				}
			}




		}

		// Если ответ от сервера прешел НЕ с кодом 200 (завершился неудачей):
		else {
			console.log('Инициация чата: ошибка при обращении к серверу!');
			console.log('Статус: '+this.status);
		}

	};

	// Отправить XHR-запрос на сервер
	xhr.send('');






/* Сохранение нового введённого сообщения в базе данных
================================*/



//7. Назначить функцию-обработчик события onclick кнопке "Отправить".
//		В ней выполнить следующее: [8]
refs.sendButton.onclick = function(event) {


	//8. Подготовить для отправки в теле запроса строку в формате
	//		urlencoded, которая должна содержать nickname и message.
	var body =
			'nickname' + '=' + encodeURIComponent(refs.nickname.value) + '&' +
			'message' + '=' + encodeURIComponent(refs.message.value);


	//9. Отправить на сервер (в файл addMessage.php) XHR-запрос методом POST,
	//		в теле которого передать подготовленную в п.8 строку в формате
	//		urlencoded.

		// Создать новый объект XMLHttpRequest
		var xhrSend = new XMLHttpRequest();

		// Настроить XHR-запрос
		xhrSend.open("POST", 'addMessage.php', true);

		// Отправить необходимый заголовок
		xhrSend.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');

		// Отправить XHR-запрос на сервер
		xhrSend.send(body);

};






/* Реализация архитектуры "длинные опросы" - чтобы чат обновлялся, когда приходят новые сообщения
================================*/


//10. Написать функцию, которая реализует клиентскую часть архитектуры
//		 "длинные опросы". Она должна делать следующее (ключевые моменты):
//		 - Принимать в кач-ве аргумента URL-адрес серверного файла.
//		 - Осущетсвлять XHR-запрос методом GET к серверу без передачи данных.
//		 - В конце кода функции-обработчика, которая ловит ответ, рекурсивно
//		 	 запускать саму себя.
//		 - А также в этой функции-обработчике выполнять следующее: [11,12]
subscribe = function(url) {
	console.log('Подписка на update.php');
	var xhrLong;

	// Создать новый объект XMLHttpRequest
	xhrLong = new XMLHttpRequest();

	// Настроить XHR-запрос
	xhrLong.open("GET", url, true);

	// Подготовить функцию-обработчик события onreadystatechange
	xhrLong.onreadystatechange = function(event) {

		console.log('Пришел ответ!');

		//Проверить, если xhr.readyState != 4, завершить работу функции-обработчика.
		if(xhrLong.readyState != 4) return;

		// Если ответ пришёл со статусом 200 OK (без ошибок)
		if (this.status == 200) {

			console.log('Пришел ответ со статусом 200 OK!');
			console.log(xhrLong.responseText);


			//11. Получить ответ в виде JSON-строки с новыми сообщениями чата, имеющимися
			//		 на данный момент в базе данных.
			//		 - С помощью функции JSON.parse преобразовать эту JSON-строку в объект.
			var responseObject = JSON.parse(xhrLong.responseText);

			console.log(responseObject);

			//12. Пробежаться по собственным св-вам объекта, полученного в п.6,
			// 	 и с помощью функции из п.3 вывести все все полученные сообщения
			// 	 в окно чата. Т.О. когда любой пользователь будет посылать новое
			// 	 сообщение в чат, у всех пользователей оно будет тут же появляться
			// 	 в окне чата.
			for(var key in responseObject) {
				if (responseObject.hasOwnProperty(key)) {

					addMessage( responseObject[key]['timestamp'],
											responseObject[key]['nickname'],
											responseObject[key]['message'] );

				}
			}

			// Очистить память
			xhrLong = null;

			// Рекурсивно запустить саму себя
			subscribe('update.php');

		}

		// Если ответ пришёл НЕ со статусом 200 OK (с ошибками)
		else {
			console.log('Возникла ошибка при соединении с сервером XHR-запроса "длинного опроса"');
		}

	};

	// Отправить XHR-запрос на сервер
	xhrLong.send('');

};



//13. Запустить функцию из п.10 с URL равным update.php
subscribe('update.php');










// Вспомогательные функции



	//FixEvent - FIX всех IE-несовместимостей при работе с событиями
	// в 1-й функции
	function fixEvent(e, _this) {
		e = e || window.event;

		if (!e.currentTarget) e.currentTarget = _this;
		if (!e.target) e.target = e.srcElement;

		if (!e.relatedTarget) {
			if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
			if (e.type == 'mouseout') e.relatedTarget = e.toElement;
		}

		if (e.pageX == null && e.clientX != null ) {
			var html = document.documentElement;
			var body = document.body;

			e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
			e.pageX -= html.clientLeft || 0;

			e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
			e.pageY -= html.clientTop || 0;
		}

		if (!e.which && e.button) {
			e.which = e.button & 1 ? 1 : ( e.button & 2 ? 3 : (e.button & 4 ? 2 : 0) );
		}

		return e;
	}




//Преобразовать JSON-строку в массив
// > Сделать это можно в 2 этапа:
//   - Сначала с помощью функции JSON.parse преобразовать JSON-строку
//		 и все её вложенные (любой глубины) JSON-строки в массив.
//   - Затем преобразовать полученный объект в массив.
// > Аргументы:
//	 - json - json-строка, которую надо преобразовать в массив
// > Функция возвращает массив, который имеет такую же структуру, как
//	 JSON-строка.
function jsonToArray(json) {

	// Преобразовать JSON-строку в объект
	var data = JSON.parse(json);

	// Преобразовать объект и все его собственные вложенные объекты в массив

		// Эта функция обходит все собственные свойства объекта obj.
		// > Если тип свойства оказывается "Object", то функция рекурсивно
		//   вызывается, и этот объект тоже обходится.
		// > Если тип свойства оказываенся НЕ "Object", то данные
		//	 записываются в массив dataArray.
		// > Аргументы:
		//   - obj - объект, который надо обойти, и преобразовать в массив.
		//   - dataArray - массив, который населяется данными.
		// > Функция ничего не возвращает, а лишь населяед данными массив
		//	 dataArray. Причем последний будет иметь такую же структуру,
		//	 как объект obj, включая всевозможные вложенности. Например:
		//	 - Вложенные в св-ва объекта объекты превращаются во вложенные
		// 		 массивы.
		//	 - Литералы так и остаются литералами
		var makeArray = function(obj, dataArray) {

			// Если это собственное свойство объекта (а не наследованное):
			for( var i in obj ) {
				if (obj.hasOwnProperty(i)) {
					console.log('obj['+i+'] = '+obj[i]);
					// Если obj[i] не является объектом, то:
					if(Object.prototype.toString.call(obj[i]).slice(8,-1) !== 'Object') {

						dataArray[i] = obj[i];

					}

					// Иначе:
					else {
						dataArray[i] = [];
						makeArray(obj[i],dataArray[i]);
					}

				}
			}

		};

		// Создать массив
		var dataArray = [];

		// Использовать функцию makeArray
		makeArray(data,dataArray);

		// вернуть результат
		return dataArray;

}


