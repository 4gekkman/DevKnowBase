/**
 * Задача:
 *
 * > Сделать input, который переводить все вводимые символы в
 * 	 верхний регистр.
 *
 * > Учесть возможность ввода командой "вставить" или с мобильных устройств.
 *
 *
 *
 *
 * Обсуждение решения:
 *
 * > В этой задаче требуется проверять только вводимые данные. Никаких
 * 	 проверок при удалении символов делать не надо. Значит события
 * 	 cut и keyup не понадобятся.
 *
 * > Какие есть подходы к задаче фильтрации:
 *
 * 	 Подход 1 (более сложный, тяжелый, но лучше выглядит)
 * 	 > До действий браузера по умолчанию - с помощью события keydown. В этом
 * 	 	 случае понадобится отменить действия браузера по умолчанию, и самому
 * 	 	 обеспечивать попадание вводимых символов в значение текстового поля.
 * 	 	 > Минусы этого подхода:
 * 	 	 	 - Очень трудоёмок. Поскольку отменив действия браузера "по умолчанию",
 * 	 	 	 	 придется эмулировать ряд сложных функций, иначе решение будет не
 * 	 	 	 	 полноценным.
 * 	 	 	 	 Например, когда пользователь выделяет мышкой все содержимое
 * 	 	 	 	 input и вводит новый символ - старое должно удалиться, а новый символ
 * 	 	 	 	 появиться. Если удалить стандартное поведение браузера, то это приедтся
 * 	 	 	 	 эмулировать самостоятельно.
 * 	 	 	 - Кушает больше памяти, чем другой подход.
 * 	 	 	 - Позволяет обрабатывать ТОЛЬКО ввод с клавиатуры. А ввод другими
 * 	 	 	 	 способами - нет.
 * 		 > Плюсы этого подхода:
 * 		 	 + Фильтрует ввод еще до того, как вводимые данные попадают на экран.
 * 		 	   И, в отличие от другого подхода, пользователь не видит, как сначала
 * 		 	   появляются на экране какие-то данные, а затем удаляются фильтром.
 * 		 	 + Иногда без него не обойтись, как в задаче №19. Этот подход можно
 * 		 	   реализовывать в учеченном виде, без эмуляции ф-ий браузера по умолчанию,
 * 		 	   когда нужно просто отфильтровать вводимые символы по какому-то признаку.
 * 		 	   Например, пропускать только цифры. А если не цифра - отменяем действия
 * 		 	   бравзера по умолчанию, и эти символы не появляются в текстовом поле.
 *
 * 	 Подход 2 (легкий, но похуже смотрится, чем подход 1)
 * 	 > После действий браузера по умолчанию, с помощью событий input и paste.
 * 	   А если потребуется отслеживать и удаление символов (не в этой задаче),
 * 	   то еще и keyup и cut.
 * 	   > Минусы этого подхода:
 * 	   	 - Этот подход НЕ позволяет никак отменить действия браузера по умолчанию
 * 	   	   по размещению вводимых символов.
 * 	   	 - Для обработчика всех этих событий приходится с помощью пользовательской
 * 	   	   функции setImmediate пропускать в стеке задач выполнение действий
 * 	   	   браузера по умолчанию вперед, а выполнение обработчика наоборот -
 * 	   	   ставить после первого.
 * 	   	   Иначе - невозможно будет получить доступ к новому значению текстового поля,
 * 	   	   а значит и фильтровать его.
 * 	   	 - Смотрится хуже, чем подход 1
 * 	   > Плюсы этого подхода:
 * 	   	 + Проще в реализации, чем с подход 1.
 * 	   	 + Позволяет обрабатывать ввод НЕ только с клавиатуры, но и вообще
 * 	   	   любыми другими методами.
 *
 * > В этой задаче я буду использовать подход №2.
 *
 *
 *
 * Архитектура решения:
 *
 * 1. Получить ссылку на элемент input с id='upper'. Сохранить в переменную.
 *
 * 2. Создать функцию для фильтрации результата и изменения значения input.
 * 		Она должна привести значение input.value в соответствие требованиям.
 * 	  input.value должен быть:
 * 	 	- переведено в верхний регистр
 *
 * 3. Назначить функцию из п.2 элементу value в качестве функции-обработчика
 * 		следующих событий: input, paste.
 * 	  - Причем, с помощью пользовательской функции setImmediate сделать так,
 * 	  	чтобы задача выполнения этого обработчика в стеке задач потока
 * 	  	пропустила вперед себя действия браузера "по умолчанию" для всех
 * 	  	вышеуказанных событий.
 *
 *
 *
 *
 */


// Задействованные переменные
var inputUpper,		// ссылка на элемент input с id='upper'
		filterFunc,		// функция для фильтрации для п.2
		curInput;			// текущее значение input в функции filterFunc


//1. 	Получить ссылку на элемент input с id='upper'. Сохранить в переменную.
inputUpper = document.getElementById('upper');



//2. 	Создать функцию для фильтрации результата и изменения значения input.
//		Она должна привести значение input.value в соответствие требованиям.
//	  input.value должен быть:
//	 	- Длина строки его значения должна быть не более 25 символов.
filterFunc = function() {

	// Получить текущее значение input
	curInput = inputUpper.value;

	// Если длина curInput больше 25, обрезать её справа так, чтобы стало 25
	inputUpper.value = inputUpper.value.toUpperCase();


};



//3. Назначить функцию из п.2 элементу value в качестве функции-обработчика
//		следующих событий: input, paste.
//	  - Причем, с помощью пользовательской функции setImmediate сделать так,
//	  	чтобы задача выполнения этого обработчика в стеке задач потока
//	  	пропустила вперед себя действия браузера "по умолчанию" для всех
//	  	вышеуказанных событий.
inputUpper.oninput =
inputUpper.onpaste = function(event) {

	setImmediate(filterFunc);

};













// Вспомогательные функции





	//setImmediate				| (пользовательская функция) позволяет поставить выполнение
	//											func в очередь на ближайшее время после текущего кода, и без задержек
	// > Это эмуляция ф-ии setImmediate
	// > Добавляется как метод window (а если дело происходит в IE>=10, где такая
	//   функция уже есть, то не добавляется)
	// > Здесь используется прием cross-domain-messaging:
	//		> Позволяет скрипту из одного документа передавать текстовые сообщения
	//			скрипту в другом документе, не взирая на ПОП.
	//		> Отправить сообщение можно методом Window.postMessage(). Он производит
	//			асинхронную отправку сообщения.
	//		> Получить сообщение можно обработчиком события onmessage.
	// > Работает во всех браузерах, кроме IE<=7


		// Проверить cледующее:
		// > Если это IE>=10, и ф-ия setImmediate есть, то ничего не добавлять.
		// > В ином случае, добавить объекту window метод setImmediate:
		if (!window.setImmediate) window.setImmediate = (function() {
			var head = { }, tail = head; // очередь вызовов, 1-связный список

			var ID = Math.random(); // уникальный идентификатор

			// Подготовка функции-перехватчика события message из другого документа
			function onmessage(e) {
				if(e.data != ID) return; // не наше сообщение
				head = head.next;
				var func = head.func;
				delete head.func;
				func();
			}

			// Кросдоменное назначение обработчика событий onmessage
			if(window.addEventListener) { // IE9+, другие браузеры
				window.addEventListener('message', onmessage, false);
			} else { // IE8
				window.attachEvent( 'onmessage', onmessage );
			}

			// > Если это не IE<=7, то поставить func в конец текущей очереди
			// > Если это IE<=7, то вызвать для func обычный setTimeout.
			return window.postMessage ? function(func) {
				tail = tail.next = { func: func };
				window.postMessage(ID, "*");
			} :
			function(func) { // IE<8
				setTimeout(func, 0);
			};
		}());




