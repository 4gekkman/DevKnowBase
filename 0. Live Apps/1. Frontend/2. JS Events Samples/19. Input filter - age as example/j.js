/**
 * Задача:
 *
 * > Создать "умное" поле для ввода возраста
 *
 * > Сделать так, чтобы вводить в него можно было только цифры. Для этого:
 * 	 - Получить введенный символ в функции-обработчике события keydown
 * 	 - Проверить цифра ли это.
 * 	 - Если это не цифра, предотвратить действие браузера "по умолчанию",
 * 	 	 тем самым предотвратив ввод этого символа в поле input.
 *
 * > При попытке ввода цифры меньше минимальной, или больше максимальной
 * 	 допустимой, результат автоматически должен быть изменен на ближайший
 * 	 допустимый:
 * 	 > Отслеживать значения value после каждого изменения:
 * 	 	 - input (любое изменение кроме вставки командой "вставки" в старых Opera,
 * 	 	 					а также удаления символов в IE<=9)
 * 	 	 - keyup (отслеживать удаление символов в IE<=9)
 * 	 	 - paste (ввод командой "вставка")
 * 	 	 - cut (удаление командой "вырезать")
 * 	 > Если результирующая цифра < 0 или > 150, изменить её на ближайшую
 * 	 	 допустимую:
 * 	 		- MIN: 0 лет.
 * 	 		- MAX: 150 лет.
 *
 * > В решении предудущий пункт учитывает следующие 2 момента:
 * 	 - Что данные могут быть вставлены не нажатием клавиши на клавиатуре,
 * 	 	 а еще и другими способами: операцией "вставить", мобильным вводом и т.д.
 * 	 	 Для этого использовать события:
 * 	 - Что данные могут быть удалены не только нажатием клавиши на клавиатуре,
 * 	 	 а еще и другими способами: операцией "вырезать", с моб. устройства и т.д.
 *
 *
 *
 *
 * Задействованные пользовательские функции:
 *
 * > isNumeric
 * > FixEvent
 * > getChar
 * > setImmediate
 *
 *
 *
 * Обсуждение решения:
 *
 * > Какие есть подходы к задаче фильтрации:
 *
 * 	 Подход 1 (более сложный, тяжелый, но лучше выглядит)
 * 	 > До действий браузера по умолчанию - с помощью события keydown. В этом
 * 	 	 случае понадобится отменить действия браузера по умолчанию, и самому
 * 	 	 обеспечивать попадание вводимых символов в значение текстового поля.
 * 	 	 > Минусы этого подхода:
 * 	 	 	 - Очень трудоёмок. Поскольку отменив действия браузера "по умолчанию",
 * 	 	 	 	 придется эмулировать ряд сложных функций, иначе решение будет не
 * 	 	 	 	 полноценным.
 * 	 	 	 	 Например, когда пользователь выделяет мышкой все содержимое
 * 	 	 	 	 input и вводит новый символ - старое должно удалиться, а новый символ
 * 	 	 	 	 появиться. Если удалить стандартное поведение браузера, то это приедтся
 * 	 	 	 	 эмулировать самостоятельно.
 * 	 	 	 - Кушает больше памяти, чем другой подход.
 * 	 	 	 - Позволяет обрабатывать ТОЛЬКО ввод с клавиатуры. А ввод другими
 * 	 	 	 	 способами - нет.
 * 		 > Плюсы этого подхода:
 * 		 	 + Фильтрует ввод еще до того, как вводимые данные попадают на экран.
 * 		 	   И, в отличие от другого подхода, пользователь не видит, как сначала
 * 		 	   появляются на экране какие-то данные, а затем удаляются фильтром.
 * 		 	 + Иногда без него не обойтись, как в задаче №19. Этот подход можно
 * 		 	   реализовывать в учеченном виде, без эмуляции ф-ий браузера по умолчанию,
 * 		 	   когда нужно просто отфильтровать вводимые символы по какому-то признаку.
 * 		 	   Например, пропускать только цифры. А если не цифра - отменяем действия
 * 		 	   бравзера по умолчанию, и эти символы не появляются в текстовом поле.
 *
 * 	 Подход 2 (легкий, но похуже смотрится, чем подход 1)
 * 	 > После действий браузера по умолчанию, с помощью событий input и paste.
 * 	   А если потребуется отслеживать и удаление символов (не в этой задаче),
 * 	   то еще и keyup и cut.
 * 	   > Минусы этого подхода:
 * 	   	 - Этот подход НЕ позволяет никак отменить действия браузера по умолчанию
 * 	   	   по размещению вводимых символов.
 * 	   	 - Для обработчика всех этих событий приходится с помощью пользовательской
 * 	   	   функции setImmediate пропускать в стеке задач выполнение действий
 * 	   	   браузера по умолчанию вперед, а выполнение обработчика наоборот -
 * 	   	   ставить после первого.
 * 	   	   Иначе - невозможно будет получить доступ к новому значению текстового поля,
 * 	   	   а значит и фильтровать его.
 * 	   	 - Смотрится хуже, чем подход 1
 * 	   > Плюсы этого подхода:
 * 	   	 + Проще в реализации, чем с подход 1.
 * 	   	 + Позволяет обрабатывать ввод НЕ только с клавиатуры, но и вообще
 * 	   	   любыми другими методами.
 *
 * > В этой задаче я буду использовать оба подхода:
 *   - подход №2, как основной
 *   - подход №1 - для фильтрации НЕ цифр. Без этого можно было бы и обойтись,
 *   							 но так получится красивее.
 *   							 > Без применения этого подхода не-цифры сначала бы появлялись
 *   							   в текстовом поле, а потом (почти мгновенно) удалялись бы
 *   							   реализацией подхода №2. И было бы видно такое мигание.
 *   							 > А если реализовать еще и этот подход, то не-цифры, введенные
 *   							   с клавиатуры, просто не будут появляться в текстовом поле.
 *
 *
 *
 *
 * Архитектура решения:
 *
 *
 * ----- [Реализация подхода №2]
 *
 * 1. Получить ссылку на элемент input с id='age'. Сохранить в переменную.
 *
 * 2. Создать функцию для фильтрации результата и изменения значения input.
 * 		Она должна привести значение input.value в соответствие требованиям.
 * 	  input.value должен быть:
 * 	 	- Числом. Если нет, то изменить на 0.
 * 	 	- Числом больше 0. Если нет, то изменить на 0.
 * 	 	- Числом меньше 150. Если нет, то изменить на 150.
 *
 * 3. Назначить функцию из п.2 элементу value в качестве функции-обработчика
 * 		следующих событий: input, keyup, paste, cut.
 * 	  - Причем, с помощью пользовательской функции setImmediate сделать так,
 * 	  	чтобы задача выполнения этого обработчика в стеке задач потока
 * 	  	пропустила вперед себя действия браузера "по умолчанию" для всех
 * 	  	вышеуказанных событий.
 *
 *
 * ----- [Реализация подхода №1]
 *
 * 4. Назначить функцию-обработчик onkeypress элементу inputAge. Она будет
 * 		перехватывать на этом элементе все события keypress.
 *
 * 5. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
 *
 * 6. Кроссбраузерно получить введенный в input символ
 *
 * 7. Если была введена не цифра, отменить действия браузера по умолчанию
 *
 */



// Задействованные переменные
var inputAge,		// ссылка на эл-т input с id='age'
		filterFunc,	// функция для фильтрации результата из п.2
		char,				// введенный в input символ, полученный в п.6
		curInput;		// текущее значение input для функции filterFunc




// ----- [Реализация подхода №2]


//1. Получить ссылку на элемент input с id='age'. Сохранить в переменную.
inputAge = document.getElementById('age');




//2. Создать функцию для фильтрации результата и изменения значения input.
//		Она должна привести значение input.value в соответствие требованиям.
//	  input.value должен быть:
//	 	- Числом. Если нет, то изменить на 0.
//	 	- Числом больше 0. Если нет, то изменить на 0.
//	 	- Числом меньше 150. Если нет, то изменить на 150.
var filterFunc = function() {

	// Получить текущее значение input
	curInput = inputAge.value;

	// Если curInput не число, изменить значение inputAge.value на ''.
	if(!isNumeric(curInput)) inputAge.value = '';

	// Если curInput < 0, присвоить св-ву inputAge.value значение 0
	if(curInput < 0) inputAge.value = 0;

	// Если curInput > 150, присвоить св-ву inputAge.value значение 150
	if(curInput > 150) inputAge.value = 150;

};





//3. Назначить функцию из п.2 элементу value в качестве функции-обработчика
//		следующих событий: input, keyup, paste, cut.
//	  - Причем, с помощью пользовательской функции setImmediate сделать так,
//	  	чтобы задача выполнения этого обработчика в стеке задач потока
//	  	пропустила вперед себя действия браузера "по умолчанию" для всех
//	  	вышеуказанных событий.
inputAge.oninput =
inputAge.onkeyup =
inputAge.onpaste =
inputAge.oncut = function(event) {

	setImmediate(filterFunc);

};





// ----- [Реализация подхода №1]



//4. Назначить функцию-обработчик onkeypress элементу inputAge. Она будет
//	 перехватывать на этом элементе все события keypress.
inputAge.addEventListener('keypress',function(event){


		//5. Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
		event = fixEvent(event);



		//6. Кроссбраузерно получить введенный в input символ
		var char = getChar(event);



		//7. Если была введена не цифра, отменить действия браузера по умолчанию
		if(!isNumeric(char)) {

			// Кроссбраузерно отменить действия браузера "по умолчанию" в ответ
			// на возникновение события:
			event.preventDefault ? event.preventDefault() :
														(event.returnValue=false);

		}



	});













// Вспомогательные функции




	// boolean isNumeric(n)
	// > Пользовательская функция
	// > Проверяет, является ли аргумент числом
	// > Возвращает true, если аргумент - число; иначе false
			function isNumeric(n) {
					return !isNaN(parseFloat(n)) && isFinite(n);
			}



	//FixEvent - FIX всех IE-несовместимостей при работе с событиями
	// в 1-й функции
	function fixEvent(e, _this) {
		e = e || window.event;

		if (!e.currentTarget) e.currentTarget = _this;
		if (!e.target) e.target = e.srcElement;

		if (!e.relatedTarget) {
			if (e.type == 'mouseover') e.relatedTarget = e.fromElement;
			if (e.type == 'mouseout') e.relatedTarget = e.toElement;
		}

		if (e.pageX == null && e.clientX != null ) {
			var html = document.documentElement;
			var body = document.body;

			e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
			e.pageX -= html.clientLeft || 0;

			e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
			e.pageY -= html.clientTop || 0;
		}

		if (!e.which && e.button) {
			e.which = e.button & 1 ? 1 : ( e.button & 2 ? 3 : (e.button & 4 ? 2 : 0) );
		}

		return e;
	}


	// Кроссбраузерная функция для получения символа из события keypress
	// > event.type должен быть keypress
	function getChar(event) {
		if (event.which == null) {  // IE
			if (event.keyCode < 32) return null; // спец. символ
			return String.fromCharCode(event.keyCode)
		}

		if (event.which!=0 && event.charCode!=0) { // все кроме IE
			if (event.which < 32) return null; // спец. символ
			return String.fromCharCode(event.which); // остальные
		}

		return null; // спец. символ
	}



	//setImmediate				| (пользовательская функция) позволяет поставить выполнение
	//											func в очередь на ближайшее время после текущего кода, и без задержек
	// > Это эмуляция ф-ии setImmediate
	// > Добавляется как метод window (а если дело происходит в IE>=10, где такая
	//   функция уже есть, то не добавляется)
	// > Здесь используется прием cross-domain-messaging:
	//		> Позволяет скрипту из одного документа передавать текстовые сообщения
	//			скрипту в другом документе, не взирая на ПОП.
	//		> Отправить сообщение можно методом Window.postMessage(). Он производит
	//			асинхронную отправку сообщения.
	//		> Получить сообщение можно обработчиком события onmessage.
	// > Работает во всех браузерах, кроме IE<=7


		// Проверить cледующее:
		// > Если это IE>=10, и ф-ия setImmediate есть, то ничего не добавлять.
		// > В ином случае, добавить объекту window метод setImmediate:
		if (!window.setImmediate) window.setImmediate = (function() {
			var head = { }, tail = head; // очередь вызовов, 1-связный список

			var ID = Math.random(); // уникальный идентификатор

			// Подготовка функции-перехватчика события message из другого документа
			function onmessage(e) {
				if(e.data != ID) return; // не наше сообщение
				head = head.next;
				var func = head.func;
				delete head.func;
				func();
			}

			// Кросдоменное назначение обработчика событий onmessage
			if(window.addEventListener) { // IE9+, другие браузеры
				window.addEventListener('message', onmessage, false);
			} else { // IE8
				window.attachEvent( 'onmessage', onmessage );
			}

			// > Если это не IE<=7, то поставить func в конец текущей очереди
			// > Если это IE<=7, то вызвать для func обычный setTimeout.
			return window.postMessage ? function(func) {
				tail = tail.next = { func: func };
				window.postMessage(ID, "*");
			} :
			function(func) { // IE<8
				setTimeout(func, 0);
			};
		}());