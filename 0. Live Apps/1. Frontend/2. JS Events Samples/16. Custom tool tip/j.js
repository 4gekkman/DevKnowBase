/**
 * Задача:
 *
 * > Написать код, который будет показывать всплывающую подсказку над элементом, если
 * 	 у него есть атрибут data-tooltip
 *
 * > При наведении должна показываться самая вложенная подсказка. Например:
 * 		> Например:
 * 		  Если есть 2 элемента - X и Y, причем Y вложен в X, и у обоих есть атрибут
 *		  data-tooltip, и курсор наведен на Y, то должна показываться подсказка для
 *		  Y, а не для X.
 *
 * > Подсказка должна появляться при наведении на элемент по центру и на небольшом
 * 		расстоянии сверху. А при уходе курсора с элемента - исчезать.
 *
 * > Текст подсказки нужно брать из значения атрибута data-tooltip. Там может быть
 * 		и произвольный HTML.
 *
 * > Оформление подсказки должно задаваться CSS.
 *
 * > Размер всплывющей подсказки рассчитывается автоматически по содержимому HTML
 *
 * > Подсказка не должна вылазить за границы экрана:
 * 	 > Если не влезает по оси X, то скорректировать её координату X так, чтобы влезла.
 * 	 > Если не влезает сверху по оси Y, потому что страница прокручена, то показать не
 * 	 	 сверху, а снизу.
 *
 * > Одновременно на экране должна быть только 1 подсказка.
 *
 *
 *
 * Архитектура решения:
 *
 *
 * 0. Добавить в HTML-код тех элементов, для которых будут работать подсказки, польз.
 * 		атрибут data-tooltip, в значении которого разместить текст подсказки.
 *
 *
 * 1. Создать CSS-стиль для блока-подсказки.
 * 		> Размеры не должны быть жестко заданы, потому что размер этого блока должен
 * 			зависеть от его содержимого.
 * 		> Он должен иметь padding не менее 10px.
 * 		> Его позиция должна быть absolute.
 * 		> Его visibility должно быть hidden.
 * 		> Этот блок будет позиционироваться относительно document.
 *
 * 		Будем использовать для скрытия элемента-подсказки CSS-свойство visibility: hidden,
 * 		а не display: none. Причина - когда display элемента = none, то все его метрики
 * 	 	и координаты тоже = 0. А вот когда visibility элемента = hidden, то его метрики
 * 	 	и координаты можно вычислить - т.е. этот элемент есть и занимает место, просто он
 * 	 	невидим.
 *
 * 2. Элементу document.documentElement назначить 2 функции-обработчика событий:
 * 		> onmouseover	| внутри этого обработчика выполнить пункты: [3-15 включ.]
 * 		> onmouseout	| внутри этого обработчика выполнить пункты: [3,16]
 *
 *
 *
 * 3. Кроссбраузерно получить ссылки на объект-событие event, а также
 *		на целевой объект target, в котором изначально произошло событие.
 *
 * 4. Проверить, содержит ли элемент target пользовательский атрибут data-tooltip
 * 		с непустым значением.
 * 		> Если нет, то завершить работу функции-обработчика.
 *
 * 5. Динамически создать в DOM элемент div.
 * 		> Он должен быть дочерним элементом элемента body.
 * 		> Применить к нему стиль из п.1. (т.е. он будет изначально невидим)
 * 			- Для этого присвоить его атрибуту id значение tooltip.
 * 		> Сохранить ссылку на этот элемент в переменную.
 * 	  > Записать значение атрибута data-tooltip в качестве innerHTML для элемента
 * 	  	div из п.4.
 *
 * 6. Получить объект с документными координатами относительно document и размерами
 * 		для внешней зоны элемента target. Сохранить его в переменную.
 * 		> Здесь коорд. ЛВ и ПН углов, а также ширина и высота.
 * 		> Получить с помощью польз. фукнции getBoundingDocRect()
 *
 * 7. Получить объект с документными координатами относительно document и размерами
 * 		для внешней зоны элемента div из п.4. Сохранить его в переменную.
 * 		> Здесь коорд. ЛВ и ПН углов, а также ширина и высота.
 * 		> Получить с помощью польз. фукнции getBoundingDocRect()
 *
 * 8. Получить объект с документными координатами и размерами текущей видимой клиентской
 * 		области браузара относительно document.
 * 		> Найти размер прокрученной по Y области - и Т.О. координаты верхней левой точки
 * 			видимого окна браузера.
 * 		> Прибавить к ним размеры видимой области браузера, и Т.О. найти координаты
 * 			правой нижней точки видимого окна браузера.
 * 		> Сохранить все эти координаты и размеры в переменную в объекте.
 *
 * 9. Найти такие документные координаты ЛВ угла div с подсказкой относ. document,
 * 		чтобы:
 * 		> по оси X центр подсказки совпадал с центром target.
 * 		> по оси Y низ подсказки был выше верха target на 10px
 * 	 	> по оси Y верх подсказки был ниже низа target на 10px
 * 		Сохранить эти кооридинаты в переменную в объект.
 *
 * 10. Сделать проверку - если ширина или высота видимой области окна браузера меньше,
 * 		 соответственно, внешней ширины или высоты div с подсказкой из п.7, то завершить
 * 		 работу функции-обработчика.
 * 		 > Т.О. в этом моменте нам известно, что размер видимого окна браузера меньше,
 * 		 	 чем размер div с подсказкой, и он в любом случае поместится.
 *
 * 11. Подготовить переменную, в которой в итоге будут лежать документные координаты
 * 		 (X,Y) для ЛВ угла элемента div относ. document, которые можно будет использовать,
 * 		 чтобы с помощью CSS-свойств left и top задать её положение.
 *
 * 12. Вычислить координату X для объекта из п.11
 *
 * 		 1) Проверить, не выпирает ли X ЛВ угла из п.9 левее X ЛВ точки видимого
 * 		 		окна браузера из п.8.
 * 		 		- Если нет, то ничего не делать.
 * 		 	  - Если да, то присвоить координате X из п.11 следующее значение:
 * 		 	  	координата X из п.9 + модуль выпирающей разницы.
 * 		 	  	И завершить п.12 на этом.
 *
 * 		 2) Проверить, не выпирает ли X ПН угла из п.9 правее ПН точки видимого окна браузера из п.8.
 * 		 		- Если нет, то присвоить координате X из п.11 значение X из. п.9.
 * 		 	  - Если да, то присвоить координате X из п.11 следующее значение:
 * 		 	  	координата X из п.9 - модуль выпирающей разницы.
 *
 * 13. Вычислить координату Y для объекта из п.11
 *
 *		 1) Проверить, не выпирает ли Y ЛВ угла из п.9 (тот вариант, когда div выше target)
 *		 		выше Y ЛВ точки видимого окна браузера из п.8.
 *		 		- Если не выпирает, то присвоить координате Y из п.11 значение Y из проверки.
 *		 			И завершить п.13.
 *		 		- Если да, ничего не делать.
 *
 *		 2) Проверить, не выпирает ли Y ПН угла из п.9 (тот вариант, когда div ниже target,
 *		 		также придется прибавить высоту div) ниже Y ПН точки видимого окна браузера
 *		 		из п.8.
 *		 		- Если не выпирает, то присвоить координате Y из п.11 значение Y из проверки.
 *		 			И завершить п.13.
 *		 		- Если да, ничего не делать.
 *
 * 		 3) Если мы дошли до этого пункта в п.13, значит подсказка не помещается ни
 * 		 		под target, ни над target, так, чтобы не выпирать за границы видимой области
 * 		 		окна браузера. В этом случае размещаем подсказку внутри элемента, но делаем
 * 		 	  её полупрозрачной:
 * 		 	  - Сделать div полупрозрачным (opacity: .5)
 * 		 	  - Присвоить координате Y из п.11 координату Y ЛВ угла target из п.6.
 *
 * 14. Позиционировать div с помощью объекта из п.12 и CSS-свойств left и top.
 *
 * 15. Сделать div видимым с помощью CSS-свойства visibility: visible.
 *
 *
 *
 *
 * 16. Удалить из DOM элемент div c ID='tooltip'.
 *
 *
 *
 *
 *
 *
 *
 */




// Использованные переменные

var target,		// целевой элемент, в котором изначально произошло событие
		documentEl,		// document.documentElement
		targetDocCoordsAndSizes,	// объект с док. коорд. относ. document внеш. зоны target и его размеры
		divDocCoordsAndSizes,			// объект с док. коорд. относ. document внеш. зоны div с подсказкой и его размеры
		clientRectCoordsAndSize,	// объект с док. коорд. относ. document клиентской зоны window и его размеры
		divCoordObjForPoint9,			// объект для п.9 (см. его)
		divCoordObjForPoint11;		// объект для п.11 (см. его)

// Получить ссылку на document.documentElement
documentEl = document.documentElement;



//2. Элементу document.documentElement назначить 2 функции-обработчика событий:
//		> onmouseover	| внутри этого обработчика выполнить пункты: [3-15 включ.]
//		> onmouseout	| внутри этого обработчика выполнить пункты: [3,16]


// Назначение функции-обработчика для onmouseover
// > внутри этого обработчика выполнить пункты: [3-15 включ.]
documentEl.addEventListener('mouseover',function(event){



	//3. 	Кроссбраузерно получить ссылки на объект-событие event, а также
	//		на целевой объект target, в котором изначально произошло событие.

			// Кроссбраузерно получить событие
			event = event || window.event;

			// Кроссбраузерно получить target-элемент
			target = 	event && event.target ||
										event.srcElement;


	//4. Проверить, содержит ли элемент target пользовательский атрибут data-tooltip
	//		с непустым значением.
	//		> Если нет, то завершить работу функции-обработчика.
	if(!target.getAttribute('data-tooltip')) return;



	//5. Динамически создать в DOM элемент div.
	//		> Он должен быть дочерним элементом элемента body.
	//		> Применить к нему стиль из п.1. (т.е. он будет изначально невидим)
	//			- Для этого присвоить его атрибуту id значение tooltip.
	//		> Сохранить ссылку на этот элемент в переменную.
	//  	> Записать значение атрибута data-tooltip в качестве innerHTML для элемента
	//			div из п.4.

		// Создать элемент div
		var div = document.createElement('div');

		// Назначить ему id
		div.id = 'tooltip';

		// Записать значение атрибута data-tooltip в качестве innerHTML для div
		div.innerHTML = target.getAttribute('data-tooltip');

		// Добавить в DOM как дочерний элемент body, в конец
		document.body.appendChild(div);



	//6. 	Получить объект с документными координатами относительно document и размерами
	//		для внешней зоны элемента target. Сохранить его в переменную.
	//		> Здесь коорд. ЛВ и ПН углов, а также ширина и высота.
	//		> Получить с помощью польз. фукнции getBoundingDocRect()
	targetDocCoordsAndSizes = getBoundingDocRect(target);




	//7. 	Получить объект с документными координатами относительно document и размерами
	//		для внешней зоны элемента div из п.4. Сохранить его в переменную.
	//		> Здесь коорд. ЛВ и ПН углов, а также ширина и высота.
	//		> Получить с помощью польз. фукнции getBoundingDocRect()
	divDocCoordsAndSizes = getBoundingDocRect(div);



	//8. 	Получить объект с документными координатами и размерами текущей видимой клиентской
	//		области браузара относительно document.
	//		> Найти размер прокрученной по Y области - и Т.О. координаты верхней левой точки
	//			видимого окна браузера.
	//		> Прибавить к ним размеры видимой области браузера, и Т.О. найти координаты
	//			правой нижней точки видимого окна браузера.
	//		> Сохранить все эти координаты и размеры в переменную в объекте.
	clientRectCoordsAndSize = {};


		// Кроссбраузерно получить размер прокручЕННой по Y области, это и есть
		// координата Y ЛВ угла.
		clientRectCoordsAndSize.top = window.pageYOffset ||
																	documentEl.scrollTop ||
																	document.body.scrollTop;

		// Координата X ЛВ угла равна 0
		clientRectCoordsAndSize.left = 0;

		// Ширина видимой области окна браузера
		clientRectCoordsAndSize.width = documentEl.clientWidth;

		// Высота видимой области окна браузера
		clientRectCoordsAndSize.height = documentEl.clientHeight;



	//9. Найти такие документные координаты ЛВ угла div с подсказкой относ. document,
	//		чтобы:
	//		> по оси X центр подсказки совпадал с центром target.
	//		> Y v1:  по оси Y низ подсказки был выше верха target на 10px
	//	 	> Y v2:  по оси Y верх подсказки был ниже низа target на 10px
	//		Сохранить эти кооридинаты в переменную в объект.
	divCoordObjForPoint9 = {};
		// Координата X

			// Найти расстояние по X между центрами по X div и target. Использовать
			// координаты из п.6 и п.7
			var divTargetRangeX;
			divTargetRangeX = (targetDocCoordsAndSizes.left + targetDocCoordsAndSizes.right)/2 -
														 (divDocCoordsAndSizes.left + divDocCoordsAndSizes.right)/2;
			// Искомый X:
			divCoordObjForPoint9.left = divDocCoordsAndSizes.left + divTargetRangeX;

		// Координата Y версия 1:
		divCoordObjForPoint9.top1 = targetDocCoordsAndSizes.top - 10 -
																divDocCoordsAndSizes.height;


		// Координата Y версия 2:
		divCoordObjForPoint9.top2 = targetDocCoordsAndSizes.bottom + 10;





	//10. Сделать проверку - если ширина или высота видимой области окна браузера меньше,
	//		 соответственно, внешней ширины или высоты div с подсказкой из п.7, то завершить
	//		 работу функции-обработчика.
	//		 > Т.О. в этом моменте нам известно, что размер видимого окна браузера меньше,
	//		 	 чем размер div с подсказкой, и он в любом случае поместится.

		// Проверка ширины
		if(clientRectCoordsAndSize.width < divDocCoordsAndSizes.width) return;

		// Проверка высоты
		if(clientRectCoordsAndSize.height < divDocCoordsAndSizes.height) return;




	//11. Подготовить переменную, в которой в итоге будут лежать документные координаты
	//		 (X,Y) для ЛВ угла элемента div относ. document, которые можно будет использовать,
	//		 чтобы с помощью CSS-свойств left и top задать её положение.
	divCoordObjForPoint11 = {};




	//12. Вычислить координату X для объекта из п.11
	//
	//		 1) Проверить, не выпирает ли X ЛВ угла из п.9 левее X ЛВ точки видимого
	//		 		окна браузера из п.8.
	//		 		- Если нет, то ничего не делать.
	//		 	  - Если да, то присвоить координате X из п.11 следующее значение:
	//		 	  	координата X из п.9 + модуль выпирающей разницы.
	//		 	  	И завершить п.12 на этом.
	//
	//		 2) Проверить, не выпирает ли X ПН угла из п.9 правее ПН точки видимого окна браузера из п.8.
	//		 		- Если нет, то присвоить координате X из п.11 значение X из. п.9.
	//		 	  - Если да, то присвоить координате X из п.11 следующее значение:
	//		 	  	координата X из п.9 - модуль выпирающей разницы.

		// Проверка 1
		if(divCoordObjForPoint9.left < clientRectCoordsAndSize.left) {
			divCoordObjForPoint11.left = divCoordObjForPoint9.left +
																	 Math.abs(divCoordObjForPoint9.left -
																	 clientRectCoordsAndSize.left);

		} else {


			// Проверка 2
			if( (divCoordObjForPoint9.left + divDocCoordsAndSizes.width) >
					(clientRectCoordsAndSize.left + clientRectCoordsAndSize.width)			){
				// Если выпирает
				divCoordObjForPoint11.left = divCoordObjForPoint9.left -
																		 Math.abs((divCoordObjForPoint9.left + divDocCoordsAndSizes.width) -
																		 (clientRectCoordsAndSize.left + clientRectCoordsAndSize.width));

			} else {

				// Если не выпирает
				divCoordObjForPoint11.left = divCoordObjForPoint9.left;

			}
		}







	//13. Вычислить координату Y для объекта из п.11
	//
	//		 1) Проверить, не выпирает ли Y ЛВ угла из п.9 (тот вариант, когда div выше target)
	//		 		выше Y ЛВ точки видимого окна браузера из п.8.
	//		 		- Если не выпирает, то присвоить координате Y из п.11 значение Y из проверки.
	//		 			И завершить п.13.
	//		 		- Если да, ничего не делать.
	//
	//		 2) Проверить, не выпирает ли Y ПН угла из п.9 (тот вариант, когда div ниже target,
	//		 		также придется прибавить высоту div) ниже Y ПН точки видимого окна браузера
	//		 		из п.8.
	//		 		- Если не выпирает, то присвоить координате Y из п.11 значение Y из проверки.
	//		 			И завершить п.13.
	//		 		- Если да, ничего не делать.
	//
	//		 3) Если мы дошли до этого пункта в п.13, значит подсказка не помещается ни
	//		 		под target, ни над target, так, чтобы не выпирать за границы видимой области
	//		 		окна браузера. В этом случае подсказку не показываем, и завершаем работу
	//        функции-обработчика.
	var check = {};


		// Проверка 1
		if(divCoordObjForPoint9.top1 < clientRectCoordsAndSize.top) {
			check.check1 = true;
		} else {
			divCoordObjForPoint11.top = divCoordObjForPoint9.top1;
			check.check1 = false;
		}

		// Проверка 2
		if(check.check1 === true) {
			if( (divCoordObjForPoint9.top2 + divDocCoordsAndSizes.height) >
					(clientRectCoordsAndSize.top + clientRectCoordsAndSize.height)  ){
				check.check2 = true;
			} else {
				divCoordObjForPoint11.top = divCoordObjForPoint9.top2;
				check.check2 = false;
			}
		}

		// Проверка 3
		if(check.check1 === true && check.check2 === true) {

			// Завершить работу функции-обработчика
			return;

		}



	//14. Позиционировать div с помощью объекта из п.12 и CSS-свойств left и top.
	div.style.left = divCoordObjForPoint11.left + 'px';
	div.style.top =  divCoordObjForPoint11.top + 'px';




	//15. Сделать div видимым с помощью CSS-свойства visibility: display.
	div.style.visibility = 'visible';





});


// Назначение функции-обработчика для onmouseout
// > внутри этого обработчика выполнить пункты: [3,16]
documentEl.addEventListener('mouseout',function(event){


	//3. 	Кроссбраузерно получить ссылки на объект-событие event, а также
	//		на целевой объект target, в котором изначально произошло событие.

			// Кроссбраузерно получить событие
			event = event || window.event;

			// Кроссбраузерно получить target-элемент
			target = 	event && event.target ||
										event.srcElement;


	//16. Удалить из DOM элемент div c ID='tooltip'.
  var div = document.getElementById('tooltip');
	if(div) div.parentNode.removeChild(div);


});






/* Получить объект с документными координатами относительно document
		 > getBoundingDocRect(e)
																	> Координаты верхнего левого угла элемента:
																		- top			| координата Y
																		- left		| координата X
																	> Координаты правого нижнего угла элемента:
																		- bottom	| координата Y
																		- right		| координата X
																	> Размеры элемента:
																		- width		| ширина, включая границы и padding, не включая margin
																		- height	| высота, включая границы и padding, не включая margin
																	> Особенности:
																		- Координаты и размеры - для внешней зоны элемента.
																		- НЕ меняются при прокрутке
																		- Используются при позиционировании элементов
																			с position: absolute
																		- Если у элемента display: none, то все значения,
																			которые вернет функция - будут 0.
																			А вот если у элементе visibility: hidden, то
																			все значения будут нормально вычисляться.
================================*/


function getBoundingDocRect(e) {
	var rect,
			body,
			docElem,
			scrollTop,
			scrollLeft,
			clientTop,
			clientLeft,
			top,
			left,
			bottom,
			right,
			width,
			height;

	rect = e.getBoundingClientRect();
	body = document.body;
	docElem = document.documentElement;

	// Размеры прокручЕННой области
	scrollTop = window.pageYOffset 	|| docElem.scrollTop || body.scrollTop;
	scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

	// Размеры рамок элемента
	clientTop = docElem.clientTop || body.clientTop || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;

	// Документные координаты левого верхнего угла элемента (на внеш. стороне
	top  = rect.top +  scrollTop - clientTop;
	left = rect.left + scrollLeft - clientLeft;

	// Документные координаты правого нижнего угла элемента
	bottom = rect.bottom + scrollTop - clientTop;
	right = rect.right + scrollLeft - clientLeft;

	// Внешние размеры элемента
	width = e.getBoundingClientRect().width;
	height = e.getBoundingClientRect().height;

	// Вернуть объект с координатами и размерами
	return {
		top: Math.round(top),
		left: Math.round(left),
		bottom: Math.round(bottom),
		right: Math.round(right),
		width: Math.round(width),
		height: Math.round(height)
	};
}


















