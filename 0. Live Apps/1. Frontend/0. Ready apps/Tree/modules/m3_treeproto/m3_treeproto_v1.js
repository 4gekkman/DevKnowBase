// ==========================================
// Модуль "m3_treeproto_v1" приложения "tree"
// ==========================================


/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:





*****************************************************
Оглавление:

	> О модуле
		> Описание модуля
		> Вход: зависимости модуля
		> Выход: что возвращает модуль

	> Прототипы: общие сведения
	> Каковы принципы формирования ID для "деревьев" и "узлов дерева"?
	> Хранение всех созданных объектов-деревьев в коллекции в прототипе

	> Инструкция по применению
		> Внимание! Необходимые зависимости.
		> У этого компонента нет версий
		> Как использовать

	> Параметры узла
	> Подробное описание некоторых параметров
	> Связи между параметрами узла и HTML-разметкой
	> Архитектура функции-прототипа



*****************************************************


> О модуле

	> Описание модуля
		- Это главный модуль приложения tree.
		- Вся работа с приложением происходит через объект-прототип дерева.
		- Весь функционал всех модулей приложения "tree", который должен быть
			доступен, доступен через глобальную переменную tree.
		- Переменная tree должна быть создана в глобальной области в сборке.
		- К сборке следует подключить только модуль m3_treeproto. Потому
			что весь остальной функционал приложения подключается к m3_treeproto.

	> Вход: зависимости модуля
		- m1_library_v1
		- m2_nodeproto_v1
		- m4_selection_v1
		- m5_closeopen_v1
		- m6_2clickcancel_v1
		- m8_treemakedom_v1

	> Выход: что возвращает модуль
		- Возвращает ссылку на объект-прототип дерева приложения "tree".


> Прототипы: общие сведения

	> Что такое прототип?
		> Это объект.
		> У него есть метод-конструктор.

	> Зачем нужен прототип?
		> Чтобы на его основе создавать объекты.
		> Используется, когда нужно создать много похожих объектов.
			Использование прототипов уменьшает объём кода.

	> Что такое функция-конструктор?
		> Это свойство объекта-прототипа, в котором лежит функция.
		> Эта фукнция запускается автоматически при создании нового объекта
			на основе прототипа.
		> Функции-конструктору можно передавать аргументы.
		> Код конструктора может быть таков, что в зависимости переданных
			аргументов результирующий объект может конструироваться по-разному.

	> О гарантированной валидности
		> Создание нового объекта из прототипа с помощью его метода-конструктора
			гарантирует, что этот объект будет именно таков, каков он был задуман
			(если в конструкторе нет ошибок).


> Каковы принципы формирования ID для "деревьев" и "узлов дерева"?

	> Принципы формирования ID дерева

		> Что такое ID дерева?
			- Это уникальный идентификатор дерева в текущем документе.

		> Каков формат ID дерева?
					"treeUID" + цифра

		> Статическое свойство treeCount
			> Определно в прототипе дерева.
			> Обозначает кол-во созданных в данном документе экземпляров деревьев.
			> Обычно используется в качестве "цифры" при автоматическом формировании
				ID дерева.

		> Автоматическое и ручное формирование ID нового дерева

			> Вручную
				> Можно указать ID вручную.
				> Тогда ID проходит 2 проверки:
					- На соответствие формату.
					- На уникальность в данном документе.
				> В зависимости от того, пройдены ли проверки:
					- Если проверки пройдены, то указанный ID используется.
					- Если проверки не пройдены, то указанный ID отклоняется,
						а вместо него автоматически формируется другой.

			> Автоматически
				> Если при создании нового экземпляра дерева:
					- Его ID не указан
					- Указан не валидный ID (который не может пройти проверки)
					То ID дерева формируется автоматически.
				> Процесс выглядит так:
					1.	Получить список ID всех деревьев в документе.
					2. 	Запустить цикл. В нём:
							- Формировать новый ID в формате: "treeUID" + (treeCount + N)
								Где N начинается с 0, и с каждой итерацией цикла инкрементируется на 1.
							- Цикл заканчивается тогда, когда сформированный новый ID
								не совпадёт ни с 1-им из существующих из п.1. Тогда этот
								ID и используют для нового дерева, убедившись в его уникальности.

		> При создании HTML-разметки дерева, какому эл-ту присваивается его ID?
			> Элементу DIV, в котором находится дерево.
			> ID дерева элементу DIV будет добавляться при создании
				HTML-разметки дерева функцией addTree.


	> Принципы формирования ID узла

		> Что такое ID узла?
			- Это уникальный идентификатор узла в своём дереве.

		> Каков формат ID узла?
				"nodeUID" + цифра

		> Как обеспечивается уникальность ID узла в текущем документе?

			> Проблема уникальности и её решение:
				> В документе может быть >= 2 деревьев. Как исключить возможность
					появления в 2-х и более деревьях узлов с одинаковыми ID (что
					вызовет ошибку)?
				> Решение: при добавлении ID узла в атрибуте ID эл-та LI добавлять
					к нему приставку в виде ID дерева.

			> Есть 2 вида ID узла:
				- Без приставки: ID узла в объекте "узел дерева".
				- С приставкой: ID узла в HTML-разметке в атрибуте id эл-та LI.

			> Каков формат строки с

			> Каков формат строки с ID узла в атрибуте id эл-та LI (с приставкой)?
					ID дерева + '-' + ID узла

		> Автоматическое и ручное формирование ID узлов нового дерева

			> При парсинге HTML-кода
				> При парсинге HTML-кода, в случае отсутствия у LI атрибута id,
					либо отсутствия в нём валидного ID узла, он будет сгенерирован
					автоматически. А в случае присутствия валидного значения id,
					он будет присвоен. ID узла в объекте (без приставки)?
					"nodeUID" + цифра

			> При приёме массива узлов
				> Автоматической генерации не происходит. Потому что все узлы
					находятся в одноранговом списке, и чтобы установить их иерархию,
					parent и id должны присутствовать обязательно.
				> Узлы, у которых не указан id или parent, будут проигнорированы.

			> Вручную
				> Можно указать ID вручную.
				> Тогда ID проходит 2 проверки:
					- На соответствие формату.
					- На уникальность в данном дереве.
				> В зависимости от того, пройдены ли проверки:
					- Если проверки пройдены, то указанный ID используется.
					- Если проверки не пройдены, то указанный ID отклоняется,
						а вместо него автоматически формируется другой.

			> Автоматически
				> Если при создании нового экземпляра узла дерева:
					- Его ID не указан
					- Указан не валидный ID (который не может пройти проверки)
					- Данные извлекаются из HTML-разметки (а не массива узлов-объектов)
					То ID узла формируется автоматически.
				> Процесс выглядит так:
					1.	Получить список ID всех узлов дерева.
					2. 	Запустить цикл. В нём:
							- Формировать новый ID в формате: "nodeUID" + N"
								Где N начинается с 0, и с каждой итерацией цикла инкрементируется на 1.
							- Цикл заканчивается тогда, когда сформированный новый ID
								не совпадёт ни с 1-им из существующих из п.1. Тогда этот
								ID и используют для нового узла, убедившись в его уникальности.

		> При создании HTML-разметки дерева, каким эл-там присваиваются ID узлов?
			> Эл-ту LI каждого из узлов в качестве значения атрибута id, в формате:
					ID дерева + '-' + ID узла
			> ID узлов элементам LI будут добавляться при создании
				HTML-разметки дерева функцией addTree.


> Хранение всех созданных объектов-деревьев в коллекции в прототипе

	> Проблема:
		- В приложении соблюдается принцип 100% синхронизации между объектом-деревом
			и его DOM-представлением.
		- Если доступ к DOM-объектам легко получить по ID, то зачастую доступ
			к объектам-деревьям получить по ID невозможно.

	> Решение:
		- В объекте-прототипе должен существовать объект-коллекция, используя
			который должно быть можно получить доступ к объекту-дереву по его ID.
		- В этом объекте-коллекции ключ - это ID дерева, значение - это ссылка
			на его объект.


> Инструкция по применению

	> Создать новый объект-дерево:

			Новый способ (использован синтаксический сахар):
			-----
				var tree = tree.create({

					... конфигурационный объект дерева ...

				});

			Старый способ:
			-----
				var tree = Object.create(tree).constructor({

					... конфигурационный объект дерева ...

				});


	> Создать DOM-элемент дерева

		> Создать готовый DOM-элемент дерева (DIV) со всеми узлами,
			классами, атрибутами.
			- ID каждого узла подписать префиксом в виде ID данного
				экземпляра дерева.

					var div = tree.treemakedom();

		> Создать готовый DOM-элемент дерева (DIV) со всеми узлами,
			классами, атрибутами.
			- ID каждого узла подписать префиксом "treeUID10":

					var div = tree.treemakedom("treeUID10");

		> Создать готовый DOM-элемент поддерева (UL) со всеми узлами,
			классами, атрибутами.
			- ID каждого узла подписать префиксом в виде ID данного
				экземпляра дерева.

					var div = tree.treemakedom('', true);

		> Создать готовый DOM-элемент поддерева (UL) со всеми узлами,
			классами, атрибутами.
			- ID каждого узла подписать префиксом "treeUID10":

					var div = tree.treemakedom('treeUID10', true);




> Параметры узла:


		Имя:						Тип:			Обязат-		Значение по		Краткое описание
															ельность:	умолчанию
		-----------------------------------------------------------------------------------
		{
a1		id        	: "string"	нет				авто					Уникальный ID дерева в этом документе
a2		description	: "string"	нет				''						Описание дерева
b			components {:	{}				нет											Настроечный объект компонентов дерева
b1	 	 selection {:	{}				нет											Настроечный объект компонента "выделение"
b1.1	  enable		:	boolean		нет				true					Включить ли компонент "выделение"
			 }
b2		 closeopen {:						нет											Настроечный объект компонента "открыть/закрыть"
b2.1	  enable		:	boolean		нет				true					Включить ли компонент "открыть/закрыть"
b2.2		animation :	number		нет				200						Скорость анимации в мс
			 }
b3		 unselect { :	{}				нет											Настроечный объект компонента "отменять выделение при 2x щелчке"
b3.1	 	enable		:	boolean		нет				true					Включить ли компонент "отменять выделение при 2x щелчке"?
			 {
c			data				: []				нет											Массив объектов-узлов
d			theme	{			: {}				нет											Настроечный объект внешнего вида дерева
d1			dots			:	boolean		нет				true					Включить ли "точечные линии"
d2			strips		: boolean		нет				false					Включить ли выделение полосами узлов через один
			}

		}


> Подробное описание некоторых параметров

	# a1. id
		> Обозначает уникальный ID дерева в документе.
		> В этот параметр можно передать ID для нового дерева.
		> В 99% случаев это не обязательно, и он будет автоматически сгенерирован.
		> Если всё же его передать, то нет гарантий, что он пройдет проверки.
			Если он не пройдёт проверки, то автоматически будет сгенерирован и
			использован другой. Переданный вручную ID проходит следующие проверки:
			- Проверка на соответствие шаблону.
			- Проверка на уникальность в документе.

	# b. components
		> Содержит настроечный объект с настроечными объектами всех доступных
			компонентов дерева.

	# c. data
		> Общая информация
			> В этот параметр надо передать массив объектов с индексами-номерами,
				созданных из прототипа узла дерева (обязательно).



> Связи между параметрами дерева и HTML-разметкой


	> HTML разметка дерева

		> HTML-разметка с плейсхолдерами, указывающими на связь с параметрами

			<div id={1} data-tree='{animation:{b2.2}}' class="{b1.1} {b2.1} {b3.1}">

				<ul class="tree-container-root-ul">

					... [внутри LI в случае, если у него есть дочерние узлы]

						<ul class="tree-container-subtree-ul">

						</ul>

					...

				</ul>

			</div>

    > Пример готовой HTML-разметки дерева:

			<div id="treeUID1" data-animation="200"
				class="tree-nodes-selectable tree-nodes-close_open tree-dblclick-unselectable">

				<ul class="tree-container-root-ul">

					<li id="treeUID1-nodeUID1" class="tree-node tree-node-opened">

						<i class="tree-icon tree-icon-opened"></i>

						<a class="tree-anchor tree-selected">
							<i class="tree-icon tree-icon-theme"></i>
							Текст узла
						</a>

						<ul class="tree-container-subtree-ul">

							... другие узлы LI ...

						</ul>

					</li>

				</ul>

			</div>


	> HTML-разметка поддерева

		> HTML-разметка с плейсхолдерами, указывающими на связь с параметрами
			(в этом вариенте построения HTML-разметки параметры дерева вообще не задействованы)

			<ul class="tree-container-root-ul">

				... узлы LI ...

			</ul>

    > Пример готовой HTML-разметки дерева:
			> Тоже самое.



	> Параметры и связи (только для разметки, которая для всего дерева, а не поддерева)

		> {a1}: id
			- В элементе DIV надо добавить атрибут ID со значением this.id
				(предварительно проверив его и если надо, сгенерировав автоматически)

		> {b1.1}: components.selection.enable
			- В DIV надо вставить класс tree-nodes-selectable

		> {b2.1}: components.closeopen.enable
			- В DIV надо вставить класс tree-nodes-close_open

		> {b2.2}: components.closeopen.animation
			- В DIV в атрибут "data-tree" надо вставить объект, в который
				вставить свойство animation со значением this.components.closeopen.animation

		> {b3.1}: components.unselect.enable
			- В DIV надо вставить класс tree-dblclick-unselectable

		> {d1}: theme.dots	[!в разработке!]

		> {d2}: theme.strips [!в разработке!]



> Архитектура функции-прототипа


[-----IN. Входы модуля]

IN1.	С помощью функции define определить модуль.
			> Внутри callback-функции модуля выполнить: [].
			> Подключить на вход модуля следующие зависимости:
				- m1_library_v1
				- m2_nodeproto_v1
				- m4_selection_v1
				- m5_closeopen_v1
				- m6_2clickcancel_v1
				- m8_treemakedom_v1


[-----X1. Создание и подготовка объекта-прототипа и функции-конструктора]

x1.1.	Создать объект treeProto, который и будет представлять собой
			прототип.

x1.2.	Создать в объекте treeProto статическое свойство treeCount, и
			инициировать его 0.

x1.3.	Создать объект-коллекцию trees, который будет хранить ссылки на все
			созданные в этом документе объекты-деревья. Ключ - это ID дерева,
			значение - ссылка на объект-дерево

x1.4.	В объекте treeProto создать свойство constructor, а в нём анонимную
			функцию. Эта функция должна принимать настроечный объект obj.
			Внутри этой функции выполнить следующее: [x1.4, A1, A2, A3, B, C, D]

x1.5.	Раз запущен конструктор, значит в этом документе будет создан еще
			один экземпляр дерева. Увеличить значение св-ва treeCount на 1.



[-----A1. Инициация параметра ID]

a1.1.	Инициировать this.id самовыполняющейся анонимной функцией, внутри
			которой выполнить следующее: [a1.1 - a1.5]

	a1.2.	Получить список всех div документа, в которых созданы деревья
				- Он понадобится, чтобы убедиться, что ID нового дерева уникален,
					и не совпадает с ID одного из уже существующих в документе деревьев.
				- Использовать функцию getTrees() из библиотеки.

	a1.3.	Написать фукнцию, которая делает проверку на уникальность.
				Аргументы:
					-	str		| строка, которую планируется использовать в качестве
										значения ID нового дерева
				Особенности:
					- Для работы требует функцию getTrees() из библиотеки приложения "дерево"
				Эта функция делает следующее:
					- Проверяет, не совпадает ли str с ID существующих в документе деревьев.
					- Проверяет, является ли номер у ID равным или большим, чем treeCount.
				Возвращает:
					- 0			| проверку не прошёл, использовать str нельзя
					- 1			| проверку прошёл, использовать str можно

	a1.4.	Если obj.id передан, проверить его на соответствие шаблону и
				уникальность.
				-	Если он пройдет 2 проверки, вернуть его.
				- Если он не пройдёт хотя бы 1 проверку, ничего не делать.

	a1.5.	Автоматически сгенерировать ID для нового дерева
				- Сгенерированное значение: "treeUID" + treeCount
				- Проверить сгенерированное значение функцией checkID.
					Если она вернёт 0, то попробовать: "treeUID" + (treeCount + 1).
					И так далее по циклу, пока checkID не вернёт 1.
				- Вернуть итоговое значение.


[-----X1.3. Добавить в коллекцию trees свежесозданный объект-дерево]

x1.3.1. Добавить в коллекцию trees элемент с ключём this.id.
				И присвоить ему ссылку this на свежесозданный объект-дерево.


[-----A2. Инициация параметра description]

a2.1.	Инициировать this.description самовыполняющейся анонимной функцией,
			внутри которой выполнить следующее: [a2.2 - a2.5]

	a2.2.	Проверить, если obj.description не передан, то вернуть значение
				по умолчанию.

	a2.3.	Проверить, если obj.description - не строка, вернуть значение
				по умолчанию.

	a2.4.	Обрезать у строки obj.description все теги и другие подозрительные
				символы с помощью регулярного выражения.

	a2.5.	Вернуть obj.description.



[-----B. Инициация параметра components]

b.	Инициировать this.components объектом, внутри которого выполнить
 		следующее: [B1]


	[-----B1. Инициация параметра components.selection]

	b1.	Инициировать this.components.selection объектом, внутри которого
			выполнить следующее: [B1.1]


		[-----B1.1. Инициация параметра components.selection.enable]

		b1.1.	Инициировать this.components.selection.enable самовыполняющейся
					анонимной функцией, внутри которой выполнить следующее:
					[b1.1.1 - b1.1.3]

		b1.1.1. Если obj.components.selection.enable не передан, то вернуть
						значение по умолчанию.

		b1.1.2. Если obj.components.selection.enable не boolean, то вернуть
						значение по умолчанию.

		b1.1.3.	Вернуть obj.components.selection.enable


	[-----B2. Инициация параметра components.closeopen]

	b2.	Инициировать this.components.closeopen объектом, внутри которого
			выполнить следующее: [B2.1]


		[-----B2.1. Инициация параметра components.closeopen.enable]

		b2.1.	Инициировать this.components.closeopen.enable самовыполняющейся
					анонимной функцией, внутри которой выполнить следующее:
					[b2.1.1 - b2.1.3]

		b2.1.1. Если obj.components.closeopen.enable не передан, то вернуть
						значение по умолчанию.

		b2.1.2. Если obj.components.closeopen.enable не boolean, то вернуть
						значение по умолчанию.

		b2.1.3.	Вернуть obj.components.closeopen.enable


		[-----B2.2. Инициация параметра components.closeopen.animation]

		b2.2.	Инициировать this.components.closeopen.animation самовыполняющейся
					анонимной функцией, внутри которой выполнить следующее:
					[b2.2.1 - b2.2.]

		b2.2.1. Если obj.components.closeopen.animation не передан, то вернуть
						значение по умолчанию.

		b2.2.2. Если obj.components.closeopen.animation не number и не string,
						то вернуть значение по умолчанию.

		b2.2.3.	Если obj.components.closeopen.animation, то провести
						parseInt. Если результат не number, то присвоить
						значение по умолчанию. Иначе - присвоить результат.

		b2.2.4. Проверить, чтобы obj.components.closeopen.animation
						находился в диапазоне от 50 до 1000.
						- Если нет, то установить ближайшее допустимое значен

		b2.2.5. Если выполнение дошло досюда, вернуть значение
						по умолчанию.

	[-----B3. Инициация параметра components.unselect]

	b3.	Инициировать this.components.unselect объектом, внутри которого
			выполнить следующее: [B3.1]


		[-----B3.1. Инициация параметра components.unselect.enable]

		b3.1.	Инициировать this.components.unselect.enable самовыполняющейся
					анонимной функцией, внутри которой выполнить следующее:
					[b3.1.1 - b3.1.3]

		b3.1.1. Если obj.components.unselect.enable не передан, то вернуть
						значение по умолчанию.

		b3.1.2. Если obj.components.unselect.enable не boolean, то вернуть
						значение по умолчанию.

		b3.1.3.	Вернуть obj.components.unselect.enable


[-----C. Инициация параметра data]

c1.	Инициировать this.data самовыполняющейся анонимной функцией, внутри
		которой выполнить следующее: [c1.1 - c1.5]

	c1.1. Создать пустой массив, и сохранить его в переменную. В него
				будут отобраны узлы, отвечающие требованиям.

	c1.2.	Если obj.data не передан, то вернуть значение по умолчанию.

	c1.3. Если obj.data не массив, то вернуть значение по умолчанию.

	c1.4.	Пройтись циклом по всем элементам массива obj.data, и сделать следующее:
				- Если элемент имеет среди своих предков treeNodeProto, то добавить
					его в массив из c1.1. А если не имеет, переходить к след. итерации.

	c1.5.	Вернуть массив из c1.1.



[-----D. Инициация параметра theme]

d.	Инициировать this.theme объектом, внутри которого выполнить
 		следующее: [D1]


	[-----D1. Инициация параметра theme.dots]

	d1.	Инициировать this.theme.dots самовыполняющейся анонимной функцией,
			внутри которой выполнить следующее: [d1.1 - d1.3]

	d1.1. Если obj.theme.dots не передан, то вернуть значение по умолчанию.

	d1.2. Если obj.theme.dots не boolean, то вернуть значение по умолчанию.

	d1.3.	Вернуть obj.theme.dots


	[-----D2. Инициация параметра theme.strips]

	d2.	Инициировать this.theme.strips самовыполняющейся анонимной функцией,
			внутри которой выполнить следующее: [d2.1 - d2.3]

	d2.1. Если obj.theme.strips не передан, то вернуть значение по умолчанию.

	d2.2. Если obj.theme.strips не boolean, то вернуть значение по умолчанию.

	d2.3.	Вернуть obj.theme.strips


[-----SEL.	Инициация функционала модуля m4_selection]

	sel1.		Получить и сохранить в переменную ссылку на создаваемый
				этим конструктором объект. Он понадобится ниже, чтобы в
				сделать обёртки для функций модуля m4, которые должны
				запускаться именно в этом контексте.

	sel2.	Создать в объекте-дереве новое свойство this.selection,
				и инициировать его пустым объектом.

	sel3.	Инициировать this.selection.handler функцией-обработчиком
				selection.handler из переданного на вход этого модуля
				объекта из модуля m4_selection.

	sel4.	Инициировать this.selection.on анонимной функцией, которая
 				выполняет функцию selection.on в контексте создаваемого
 				конструктором объекта дерева с помощью apply.

	sel5.	Инициировать this.selection.off анонимной функцией, которая
 				выполняет функцию selection.off в контексте создаваемого
 				конструктором объекта дерева с помощью apply.

	sel6.	Инициировать this.selection.getSelected анонимной функцией,
				которая выполняет функцию selection.getSelected в контексте
				создаваемого конструктором объекта дерева с помощью apply.

	sel7.	Инициировать this.selection.getUnselected анонимной функцией,
	 			которая выполняет функцию selection.getUnselected в контексте
	 			создаваемого конструктором объекта дерева с помощью apply.

	sel8.	Инициировать this.selection.select анонимной функцией,
	 			которая выполняет функцию selection.select в контексте
	 			создаваемого конструктором объекта дерева с помощью apply.

	sel9.	Инициировать this.selection.unselect анонимной функцией,
	 			которая выполняет функцию selection.unselect в контексте
	 			создаваемого конструктором объекта дерева с помощью apply.

	sel10.	Инициировать this.selection.selectAll анонимной функцией,
	 				которая выполняет функцию selection.selectAll в контексте
	 				создаваемого конструктором объекта дерева с помощью apply.

	sel11.	Инициировать this.selection.unselectAll анонимной функцией,
	 				которая выполняет функцию selection.unselectAll в контексте
	 				создаваемого конструктором объекта дерева с помощью apply.


[-----ClOp.	Инициация функционала модуля m5_closeopen]

	ClOp1.	Получить и сохранить в переменную ссылку на создаваемый
					этим конструктором объект. Он понадобится ниже, чтобы в
					сделать обёртки для функций модуля m5, которые должны
					запускаться именно в этом контексте.

	ClOp3.	Создать в объекте-дереве новое свойство this.closeopen,
					и инициировать его пустым объектом.

	ClOp3.	Инициировать this.closeopen.handler функцией-обработчиком
					closeopen.handler из переданного на вход этого модуля
					объекта из модуля m5_selection.

	ClOp4.	Инициировать this.closeopen.on анонимной функцией, которая
 					выполняет функцию closeopen.on в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp5.	Инициировать this.closeopen.off анонимной функцией, которая
 					выполняет функцию closeopen.off в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp6.	Инициировать this.closeopen.setAnimationspeed анонимной функцией, которая
 					выполняет функцию closeopen.setAnimationspeed в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp7.	Инициировать this.closeopen.open анонимной функцией, которая
 					выполняет функцию closeopen.open в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp8.	Инициировать this.closeopen.close анонимной функцией, которая
 					выполняет функцию closeopen.close в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp9.	Инициировать this.closeopen.openAll анонимной функцией, которая
 					выполняет функцию closeopen.openAll в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp10.	Инициировать this.closeopen.closeAll анонимной функцией, которая
 					выполняет функцию closeopen.closeAll в контексте создаваемого
 					конструктором объекта дерева с помощью apply.

	ClOp11.	Инициировать this.closeopen.animate анонимной функцией, которая
 					выполняет функцию closeopen.animate в контексте создаваемого
 					конструктором объекта дерева с помощью apply.


[-----Y. Инициация функции treemakedom]

y1.	Проверить, если переменная treemakedom существует, и её значение -
		это функция, то инициировать this.treemakedom этим значением.
		В противном случае, инициировать значением false.


[-----E. Создать и присвоить прототипу функцию create]

	e1.	Создать у прототипа свойство create. Этому свойству присвоить
			анонимную функцию:
			> Аргументы:
				- obj: конфигурационный объект для создания объекта-узла
			> Возвращает:
				- Ссылку на свежесозданный объект-дерево в случае успеха
			> Описание функции:
				- Эта функци - синтаксический сахар.
				- Без неё для создания нового узла приходилось писать так:
							var node = Object.create(tree.node).constructor(obj);
				- С неё же это гораздо короче и понятнее:
							var node = tree.node.create(obj);


[-----F. Создать и присвоить прототипу свойство node]

	f1.	Создать у прототипа свойство node. Этому свойству присвоить
			ссылку на объект-прототип узла дерева, которая была передана
			данному модулю на входе.



[-----OUT. Выходы модуля]

OUT1.	Вернуть ссылку на прототип дерева






*/

/* --------------------------------------------------
---------------- Р Е А Л И З А Ц И Я ----------------*/


//[-----IN. Входы модуля]

//IN1.	С помощью функции define определить модуль.
//			> Внутри callback-функции модуля выполнить: [].
//			> Подключить на вход модуля следующие зависимости:
//				- m1_library_v1
//				- m2_nodeproto_v1
//				- m4_selection_v1
//				- m5_closeopen_v1
//				- m6_2clickcancel_v1
//				- m8_treemakedom_v1
define([
	"m1_library/m1_library_v1",
	"m2_nodeproto/m2_nodeproto_v1",
	"m4_selection/m4_selection_v1",
	"m5_closeopen/m5_closeopen_v1",
//	"m6_2clickcancel/m6_2clickcancel_v1",
	"m8_treemakedom/m8_treemakedom_v1"
	], function(library, treeNodeProto, selection, closeopen, treemakedom){

		console.log('Загрузился модуль "m3_treeproto_v1"');



//[-----X1. Создание и подготовка объекта-прототипа и функции-конструктора]

//x1.1.	Создать объект treeProto, который и будет представлять собой
//			прототип.
var treeProto = {


	//x1.2.	Создать в объекте treeProto статическое свойство treeCount, и
	//			инициировать его 0.
	treeCount : 0,


	//x1.3.	Создать объект-коллекцию trees, который будет хранить ссылки на все
	//			созданные в этом документе объекты-деревья. Ключ - это ID дерева,
	//			значение - ссылка на объект-дерево
	trees : {},

	//x1.4.	В объекте treeProto создать свойство constructor, а в нём анонимную
	//			функцию. Эта функция должна принимать настроечный объект obj.
	//			Внутри этой функции выполнить следующее: [x1.4, A1, A2, A3, B, C, D]
	constructor : function(obj) {

		//x1.5.	Раз запущен конструктор, значит в этом документе будет создан еще
		//			один экземпляр дерева. Увеличить значение св-ва treeCount на 1.
		treeProto.treeCount++;

		//x1.6.	Создать свойство self, которое


		//[-----A1. Инициация параметра ID]

		//a1.1.	Инициировать this.id самовыполняющейся анонимной функцией, внутри
		//			которой выполнить следующее: [a1.1 - a1.5]
		this.id = (function(){

			//	a1.2.	Получить список всех div документа, в которых созданы деревья
			//				- Он понадобится, чтобы убедиться, что ID нового дерева уникален,
			//					и не совпадает с ID одного из уже существующих в документе деревьев.
			//				- Использовать функцию getTrees() из библиотеки.
			var trees = library.getTrees();

			//	a1.3.	Написать фукнцию, которая делает проверку на уникальность.
			//				Аргументы:
			//					-	str		| строка, которую планируется использовать в качестве
			//										значения ID нового дерева
			//				Особенности:
			//					- Для работы требует функцию getTrees() из библиотеки приложения "дерево"
			//				Эта функция делает следующее:
			//					- Проверяет, не совпадает ли str с ID существующих в документе деревьев.
			//					- Проверяет, является ли номер у ID равным или большим, чем treeCount.
			//				Возвращает:
			//					- 0			| проверку не прошёл, использовать str нельзя
			//					- 1			| проверку прошёл, использовать str можно
			var checkID = function(str) {

				// Проверка, не совпадает ли str с ID существующих в документе деревьев.
				for(var i=0; i<trees.length; i++) {

					// Если найдено хоть 1 совпадение, вернуть 0
					if( trees[i].id == str ) return 0;

				}

				// Проверяет, является ли номер у ID равным или большим, чем treeCount.
				if(parseInt(str.replace(/treeUID/i, '')) < treeProto.treeCount)
					return 0;

				// Если выполнение кода дошло досюда, значит проверки пройдены, вернуть 1
				return 1;

			};

			//	a1.4.	Если obj.id передан, проверить его на соответствие шаблону и
			//				уникальность.
			//				-	Если он пройдет 2 проверки, вернуть его.
			//				- Если он не пройдёт хотя бы 1 проверку, ничего не делать.
			if(obj && obj.id) {

				// Регулярное выражение для проверки на соответствие шаблону
				var reg = /^treeUID\d{1,}/i;

				// Если obj.id пройдет 2 проверки, вернуть его;
				if(reg.test(obj.id) && checkID(obj.id)) return obj.id;

			}

			//	a1.5.	Автоматически сгенерировать ID для нового дерева
			//				- Сгенерированное значение: "treeUID" + treeCount
			//				- Проверить сгенерированное значение функцией checkID.
			//					Если она вернёт 0, то попробовать: "treeUID" + (treeCount + 1).
			//					И так далее по циклу, пока checkID не вернёт 1.
			//				- Вернуть итоговое значение.
				var i = treeProto.treeCount;
				for(;;) {

					// Сгенерировать новый ID
					var newID = "treeUID" + i;

					// Инкрементировать i
					i++;

					// Если newID пройдёт проверку на уникальность, использовать его:
					if(checkID(newID)) return newID;
				}

		})();


		//[-----X1.3. Добавить в коллекцию trees свежесозданный объект-дерево]

		//x1.3.1. Добавить в коллекцию trees элемент с ключём this.id.
		//				И присвоить ему ссылку this на свежесозданный объект-дерево.
		treeProto.trees[this.id] = this;


		//[-----A2. Инициация параметра description]

		//a2.1.	Инициировать this.description самовыполняющейся анонимной функцией,
		//			внутри которой выполнить следующее: [a2.2 - a2.5]
		this.description = (function() {

			//	a2.2.	Проверить, если obj.description не передан, то вернуть значение
			//				по умолчанию.
			if(!obj || !obj.description) return '';

			//	a2.3.	Проверить, если obj.description - не строка, вернуть значение
			//				по умолчанию.
			if(typeof obj.description !== 'string') return '';

			//	a2.4.	Обрезать у строки obj.description все теги и другие подозрительные
			//				символы с помощью регулярного выражения.
			//	a2.5.	Вернуть obj.description.
			return obj.description.replace(/<\/?[^>]+>/g,'');

		})();



		//[-----B. Инициация параметра components]

		//b.	Инициировать this.components объектом, внутри которого выполнить
		// 		следующее: [B1]
		this.components = {

			//	[-----B1. Инициация параметра components.selection]

			//	b1.	Инициировать this.components.selection объектом, внутри которого
			//			выполнить следующее: [B1.1]
			selection : {

				//		[-----B1.1. Инициация параметра components.selection.enable]

				//		b1.1.	Инициировать this.components.selection.enable самовыполняющейся
				//					анонимной функцией, внутри которой выполнить следующее:
				//					[b1.1.1 - b1.1.3]
				enable : (function(){

					//		b1.1.1. Если obj.components.selection.enable не передан, то вернуть
					//						значение по умолчанию.
					if(!obj || !obj.components || !obj.components.selection || obj.components.selection.enable == undefined)
					return true;

					//		b1.1.2. Если obj.components.selection.enable не boolean, то вернуть
					//						значение по умолчанию.
					if(typeof obj.components.selection.enable !== 'boolean') return true;

					//		b1.1.3.	Вернуть obj.components.selection.enable
					return obj.components.selection.enable;

				})()

			},

			//	[-----B2. Инициация параметра components.closeopen]

			//	b2.	Инициировать this.components.closeopen объектом, внутри которого
			//			выполнить следующее: [B2.1]
			closeopen : {

				//		[-----B2.1. Инициация параметра components.closeopen.enable]

				//		b2.1.	Инициировать this.components.closeopen.enable самовыполняющейся
				//					анонимной функцией, внутри которой выполнить следующее:
				//					[b2.1.1 - b2.1.3]
				enable : (function(){

					//		b2.1.1. Если obj.components.closeopen.enable не передан, то вернуть
					//						значение по умолчанию.
					if(!obj || !obj.components || !obj.components.closeopen || obj.components.closeopen.enable == undefined)
					return true;

					//		b2.1.2. Если obj.components.closeopen.enable не boolean, то вернуть
					//						значение по умолчанию.
					if(typeof obj.components.closeopen.enable !== 'boolean') return true;

					//		b2.1.3.	Вернуть obj.components.closeopen.enable
					return obj.components.closeopen.enable;

				})(),

				//		[-----B2.2. Инициация параметра components.closeopen.animation]

				//		b2.2.	Инициировать this.components.closeopen.animation самовыполняющейся
				//					анонимной функцией, внутри которой выполнить следующее:
				//					[b2.2.1 - b2.2.]
				animation : (function(){

					//		b2.2.1. Если obj.components.closeopen.animation не передан, то вернуть
					//						значение по умолчанию.
					if(!obj || !obj.components || !obj.components.closeopen || !obj.components.closeopen.animation)
					return 200;

					//		b2.2.2. Если obj.components.closeopen.animation не number и не string,
					//						то вернуть значение по умолчанию.
					if(typeof obj.components.closeopen.animation !== 'number' &&
						 typeof obj.components.closeopen.animation !== 'string') return 200;

					//		b2.2.3.	Если obj.components.closeopen.animation, то провести
					//						parseInt. Если результат не number, то присвоить
					//						значение по умолчанию. Иначе - присвоить результат.
					if( typeof obj.components.closeopen.animation === 'string' ||
							typeof obj.components.closeopen.animation === 'number') {

						if(typeof parseInt(obj.components.closeopen.animation) !== 'number')
							return 200;
						else {

							//		b2.2.4. Проверить, чтобы obj.components.closeopen.animation
							// 						находился в диапазоне от 50 до 1000.
							//						- Если нет, то установить ближайшее допустимое значение
							if(obj.components.closeopen.animation < 50)
								return 50;
							else if(obj.components.closeopen.animation > 1000)
								return 1000;
							else return obj.components.closeopen.animation;

						}
					}

					//		b2.2.5. Если выполнение дошло досюда, вернуть значение
					//						по умолчанию.
					return 200;

				})()

			},

			//	[-----B3. Инициация параметра components.unselect]

			//	b3.	Инициировать this.components.unselect объектом, внутри которого
			//			выполнить следующее: [B3.1]
			unselect : {

				//		[-----B3.1. Инициация параметра components.unselect.enable]

				//		b3.1.	Инициировать this.components.unselect.enable самовыполняющейся
				//					анонимной функцией, внутри которой выполнить следующее:
				//					[b3.1.1 - b3.1.3]
				enable : (function(){

					//		b3.1.1. Если obj.components.unselect.enable не передан, то вернуть
					//						значение по умолчанию.
					if(!obj || !obj.components || !obj.components.unselect || obj.components.unselect.enable == undefined)
					return true;

					//		b3.1.2. Если obj.components.unselect.enable не boolean, то вернуть
					//						значение по умолчанию.
					if(typeof obj.components.unselect.enable !== 'boolean' ) return true;

					//		b3.1.3.	Вернуть obj.components.unselect.enable
					return obj.components.unselect.enable;

				})()

			}

		};


		//[-----C. Инициация параметра data]

		//c1.	Инициировать this.data самовыполняющейся анонимной функцией, внутри
		//		которой выполнить следующее: [c1.1 - c1.5]
		this.data = (function(){

			//	c1.1. Создать пустой массив, и сохранить его в переменную. В него
			//				будут отобраны узлы, отвечающие требованиям.
			var dataArray = [];

			//	c1.2.	Если obj.data не передан, то вернуть значение по умолчанию.
			if(!obj || !obj.data) return [];

			//	c1.3. Если obj.data не массив, то вернуть значение по умолчанию.
			var toStringOrigin = {}.toString;
			if(toStringOrigin.call(obj.data).slice(8,-1) !== "Array") return [];

			//	c1.4.	Пройтись циклом по всем элементам массива obj.data, и сделать следующее:
			//				- Если элемент имеет среди своих предков treeNodeProto, то добавить
			//					его в массив из c1.1. А если не имеет, переходить к след. итерации.
			for(var i=0; i<obj.data.length; i++) {

				if(treeNodeProto.isPrototypeOf(obj.data[i]))
					dataArray.push(obj.data[i]);

			}

			//	c1.5.	Вернуть массив из c1.1.
			return dataArray;

		})();



		//[-----D. Инициация параметра theme]

		//d.	Инициировать this.theme объектом, внутри которого выполнить
		// 		следующее: [D1]
		this.theme = {

			//	[-----D1. Инициация параметра theme.dots]

			//	d1.	Инициировать this.theme.dots самовыполняющейся анонимной функцией,
			//			внутри которой выполнить следующее: [d1.1 - d1.3]
			dots : (function(){

				//	d1.1. Если obj.theme.dots не передан, то вернуть значение по умолчанию.
				if(!obj || !obj.theme || obj.theme.dots == undefined) return true;

				//	d1.2. Если obj.theme.dots не boolean, то вернуть значение по умолчанию.
				if(typeof obj.theme.dots !== 'boolean') return true;

				//	d1.3.	Вернуть obj.theme.dots
				return obj.theme.dots;

			})(),

			//	[-----D2. Инициация параметра theme.strips]

			//	d2.	Инициировать this.theme.strips самовыполняющейся анонимной функцией,
			//			внутри которой выполнить следующее: [d2.1 - d2.3]
			strips : (function(){

				//	d2.1. Если obj.theme.strips не передан, то вернуть значение по умолчанию.
				if(!obj || !obj.theme || obj.theme.strips == undefined) return false;

				//	d2.2. Если obj.theme.strips не boolean, то вернуть значение по умолчанию.
				if(typeof obj.theme.strips !== 'boolean') return false;

				//	d2.3.	Вернуть obj.theme.strips
				return obj.theme.strips;

			})()

		};


		//[-----SEL.	Инициация функционала модуля m4_selection]

		//sel1.	Получить и сохранить в переменную ссылку на создаваемый
		//			этим конструктором объект. Он понадобится ниже, чтобы в
		//			сделать обёртки для функций модуля m4, которые должны
		//			запускаться именно в этом контексте.
		var _this = this;

		//sel2.	Создать в объекте-дереве новое свойство selection,
		//			и инициировать его пустым объектом.
		this.selection = {};

		//sel3.	Инициировать this.selection.handler функцией-обработчиком
		//			selection.handler из переданного на вход этого модуля
		//			объекта из модуля m4_selection.
		this.selection.handler = selection.handler;

		//sel4.	Инициировать this.selection.on анонимной функцией, которая
		// 			выполняет функцию selection.on в контексте создаваемого
		// 			конструктором объекта дерева с помощью apply.
		this.selection.on = function() {
			return selection.on.apply(_this);
		};

		//sel5.	Инициировать this.selection.off анонимной функцией, которая
		// 			выполняет функцию selection.off в контексте создаваемого
		// 			конструктором объекта дерева с помощью apply.
		this.selection.off = function() {
			return selection.off.apply(_this);
		};

		//sel6.	Инициировать this.selection.getSelected анонимной функцией,
		// 			которая выполняет функцию selection.getSelected в контексте
		// 			создаваемого конструктором объекта дерева с помощью apply.
		this.selection.getSelected = function() {
			return selection.getSelected.apply(_this);
		};

		//sel7.	Инициировать this.selection.getUnselected анонимной функцией,
		// 			которая выполняет функцию selection.getUnselected в контексте
		// 			создаваемого конструктором объекта дерева с помощью apply.
		this.selection.getUnselected = function() {
			return selection.getUnselected.apply(_this);
		};

		//sel8.	Инициировать this.selection.select анонимной функцией,
		//			которая выполняет функцию selection.select в контексте
		//			создаваемого конструктором объекта дерева с помощью apply.
		this.selection.select = function(nodeID) {
			return selection.select.apply(_this, [nodeID]);
		};

		//sel9.	Инициировать this.selection.unselect анонимной функцией,
		//			которая выполняет функцию selection.unselect в контексте
		//			создаваемого конструктором объекта дерева с помощью apply.
		this.selection.unselect = function(nodeID) {
			return selection.unselect.apply(_this, [nodeID]);
		};

		//sel10.	Инициировать this.selection.selectAll анонимной функцией,
		//				которая выполняет функцию selection.selectAll в контексте
		//				создаваемого конструктором объекта дерева с помощью apply.
		this.selection.selectAll = function() {
			return selection.selectAll.apply(_this);
		};

		//sel11.	Инициировать this.selection.unselectAll анонимной функцией,
		//				которая выполняет функцию selection.unselectAll в контексте
		//				создаваемого конструктором объекта дерева с помощью apply.
		this.selection.unselectAll = function() {
			return selection.unselectAll.apply(_this);
		};


		//[-----ClOp.	Инициация функционала модуля m5_closeopen]

		//ClOp1.	Получить и сохранить в переменную ссылку на создаваемый
		//				этим конструктором объект. Он понадобится ниже, чтобы в
		//				сделать обёртки для функций модуля m5, которые должны
		//				запускаться именно в этом контексте.
		var _this = this;

		//ClOp2.	Создать в объекте-дереве новое свойство closeopen,
		//				и инициировать его пустым объектом.
		this.closeopen = {};

		//ClOp3.	Инициировать this.closeopen.handler функцией-обработчиком
		//				closeopen.handler из переданного на вход этого модуля
		//				объекта из модуля m5_selection.
		this.closeopen.handler = closeopen.handler;

		//ClOp4.	Инициировать this.closeopen.on анонимной функцией, которая
		//				выполняет функцию closeopen.on в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.on = function() {
			return closeopen.on.apply(_this);
		};

		//ClOp5.	Инициировать this.closeopen.off анонимной функцией, которая
		//				выполняет функцию closeopen.off в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.off = function() {
			return closeopen.off.apply(_this);
		};

		//ClOp6.	Инициировать this.closeopen.setAnimationspeed анонимной функцией, которая
		//				выполняет функцию closeopen.setAnimationspeed в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.setAnimationspeed = function(s) {
			return closeopen.setAnimationspeed.apply(_this, [s]);
		};

		//ClOp7.	Инициировать this.closeopen.open анонимной функцией, которая
		//				выполняет функцию closeopen.open в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.open = function(nodeID) {
			return closeopen.open.apply(_this, [nodeID]);
		};

		//ClOp8.	Инициировать this.closeopen.close анонимной функцией, которая
		//				выполняет функцию closeopen.close в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.close = function(nodeID) {
			return closeopen.close.apply(_this, [nodeID]);
		};

		//ClOp9.	Инициировать this.closeopen.openAll анонимной функцией, которая
		//				выполняет функцию closeopen.openAll в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.openAll = function() {
			return closeopen.openAll.apply(_this);
		};

		//ClOp10.	Инициировать this.closeopen.closeAll анонимной функцией, которая
		//				выполняет функцию closeopen.closeAll в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.closeAll = function() {
			return closeopen.closeAll.apply(_this);
		};

		//ClOp11.	Инициировать this.closeopen.animate анонимной функцией, которая
		//				выполняет функцию closeopen.animate в контексте создаваемого
		//				конструктором объекта дерева с помощью apply.
		this.closeopen.animate = function(element, speed) {
			return closeopen.animate.apply(_this, [element, speed]);
		};


		//[-----Y. Инициация функции treemakedom]

		//y1.	Проверить, если переменная treemakedom существует, и её значение -
		//		это функция, то инициировать this.treemakedom этим значением.
		//		В противном случае, инициировать значением false.
		var toStringOrigin = {}.toString;
		if(treemakedom !== undefined &&
			 toStringOrigin.call(treemakedom).slice(8,-1) == "Function") {

				this.treemakedom = treemakedom;

		}
		else this.treemakedom = false;


		//Вернуть this
		return this;

	},


	//[-----E. Создать и присвоить прототипу функцию create]

	//e1.	Создать у прототипа свойство create. Этому свойству присвоить
	//		анонимную функцию:
	//		> Аргументы:
	//			- obj: конфигурационный объект для создания объекта-узла
	//		> Возвращает:
	//			- Ссылку на свежесозданный объект-дерево в случае успеха
	//		> Описание функции:
	//			- Эта функци - синтаксический сахар.
	//			- Без неё для создания нового узла приходилось писать так:
	//						var node = Object.create(tree.node).constructor(obj);
	//			- С неё же это гораздо короче и понятнее:
	//						var node = tree.node.create(obj);
	create : function(obj) {

		return Object.create(this).constructor(obj);

	},

	//[-----F. Создать и присвоить прототипу свойство node]

	//f1.	Создать у прототипа свойство node. Этому свойству присвоить
	//		ссылку на объект-прототип узла дерева, которая была передана
	//		данному модулю на входе.
	node: treeNodeProto






};



	//[-----OUT. Выходы модуля]

	//OUT1.	Вернуть ссылку на прототип дерева
	return treeProto;

});		// конец определения модуля с помощью define
























