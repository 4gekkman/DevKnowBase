// ============================================
// Модуль "m5_closeopen_v1" приложения "tree"
// ============================================






/*-----------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ------------------

Ссылки:

	> Как делать CSS3 transition от/к "auto"-значениям
				http://n12v.com/css-transition-to-from-auto/



*****************************************************
Оглавление:

	> О модуле
		> Описание модуля
		> Вход: зависимости модуля
		> Выход: что возвращает модуль

	> Синхронизация объекта-экземпляра и его DOM-структуры
	> Параметры экземпляра-приложения для синхронизации с его DOM-представлением
	> CSS и атрибуты модуля
	> !Для работы требует наличие глобальной tree
	> !Контекст вызова функций модуля
	> Функционал. Принипы организации и список.
	> Система учёта добавленных модулем дереву обработчиков событий
	> Прочие данные о работе модуля

	> Использование

	> Архитектура: масштабный взгляд
	> Архитектура кода модуля


*****************************************************


> О модуле

	> Описание модуля
		- Этот модуль реализует функционал, связанный с закрытием/раскрытием
			узлов и анимацией этих процессов.

	> Вход: зависимости модуля
		- m1_library_v1

	> Выход: что возвращает модуль
		- Объект, содержащий функционал, позволяющий управлять вещами, связынными
			с закрытием/раскрытием узлов и их анимацией.


> Синхронизация объекта-экземпляра и его DOM-структуры

	> Введение
		- Часто у приложения-интерфейса есть объект-прототип.
		- Из прототипа можно создавать объекты-экземпляры приложения.
		- Из экземпляра можно создать его DOM-представление.
		- DOM-представление можно публиковать в документе
		- Параметры объекта-экземпляра связаны со свойстваи DOM-структуры:
			классами, атрибутами и чем угодно.
		- Работать всегда удобнее с объектом-экземпляром.
		- Поэтому направление связи должно быть от экземпляра к DOM. Т.Е. меняешь
			значение параметра в объекте-экземпляре, и как следствие меняется
			DOM. А не наоборот.

	> Главные принципы синхронизации:

		> Принцип 100% синхронизации
			- Объект-экземпляр и его DOM-структура всегда должны быть
				синхронизированы на 100%
			- Это значит, что значения параметров объекта-экземпляра всегда
				должны на 100% соответствовать (как задумано) его DOM-структуре.

		> Направление синхронизации: от экземпляра к DOM
			- При изменении значения параметра объекта-экземпляра, автомитически
				соотв.образом должна изменяться DOM-структура. Но не наоборот.
			- В случае обнаружения рассинхронизации, её надо восстанавливать
				в пользу объекта-экземпляра.

		> Ведение работы только через объект-экземпляр
			- Управлять приложением следует только путём изменения значений
				параметров объекта-экземпляра приложения. Приложения должно
				быть разработано так, чтобы DOM менялся как следствие этих
				изменений.
			- Вести работу напрямую с DOM-представлением приложения, а не с
				его объектом-экземпляром не следует.


> Параметры экземпляра-приложения для синхронизации с его DOM-представлением

	> [объект-дерево].components.closeopen.enable
			# Цели синхронизации в DOM:
				- Наличие/отсутствие CSS-класса "tree-nodes-close_open" у
					элемента DIV, который представляет дерево.
			# Описание синхронизации:
				- Если closeopen.enable == true, то tree-nodes-close_open должен
					присутствовать у эл-та DIV дерева, и функционал модуля m5_closeopen
					у дерева включён.
				- Если closeopen.enable == false, то tree-nodes-close_open должен
					отсутствовать у эл-та DIV дерева, и функционал модуля m5_closeopen
					у дерева выключен.

	> [объект-дерево].components.closeopen.animation
			# Цели синхронизации в DOM:
				- Значение свойства {animation: [значение]} в объекте в объекте,
				  который является значением атрибута data-tree элемента DIV дерева.
			# Описание синхронизации:
				- При изменении значения components.selection.animation оно
					должно автоматически менятсья и в свойстве animation в объекте
					в атрибуте data-tree элемента DIV дерева.

	> [объект-узел дерева].state.opened
			# Цели синхронизации в DOM:
				- Присутствие либо класса "tree-node-opened", либо класса
					"tree-node-closed" у элемента LI объекта-узла. Одновременно
					может присутствовать только один из них.
				- Присутствие либо класса "tree-icon-opened", либо класса
					"tree-icon-closed" у элемента LI>I объекта-узла. Одновременно
					может присутствовать только один из них.
			# Описание синхронизации:
				> С "tree-node*"
					- Если state.opened == true, то у элемента LI объекта-узла
						должен присутствовать класс "tree-node-opened", и отсутствовать
						класс "tree-node-closed".
					- Если state.opened == false, то у элемента LI объекта-узла
						должен присутствовать класс "tree-node-closed", и отсутствовать
						класс "tree-node-opened".
				> С "tree-icon*"
					- Если state.opened == true, то у элемента LI>I объекта-узла
						должен присутствовать класс "tree-icon-opened", и отсутствовать
						класс "tree-icon-closed".
					- Если state.opened == false, то у элемента LI>I объекта-узла
						должен присутствовать класс "tree-icon-closed", и отсутствовать
						класс "tree-icon-opened".


> CSS и атрибуты модуля

	> Где хранится CSS модуля?
		- Весь CSS хранится в главном CSS-файле приложения "tree", в отдельном
			его разделе.

	> Класс "tree-nodes-close_open"
		- Присваивается элементу DIV дерева, если в этом дереве включён
			функционал модуля m5_closeopen. В противном случае - отсутствует.

	> Класс "tree-node-opened"
		- Присваивается элементу LI объекта-узла, если он раскрыт.

	> Класс "tree-node-closed"
		- Присваивается элементу LI объекта-узла, если он закрыт.

	> Класс "tree-icon-opened"
		- Присваивается элементу LI>I объекта-узла, если он раскрыт.

	> Класс "tree-icon-closed"
		- Присваивается элементу LI>I объекта-узла, если он закрыт.

	> Свойство animation значения-объекта атрибута data-tree
		- Присваивается объекту-значению узла data-tree.


> !Для работы требует наличие глобальной tree
	- Чтобы этот модуль работал без ошибок, сборка должна создавать в
		глобальном объекте свойство tree, и записывать в него ссылку на
		объект-прототип дерева.
	- В принципе, она и так должна была это делать. Иначе зачем нужно
		дерево, если нельзя получить доступ к его функционалу? А весь
		функционал как раз и находится в объекте-прототипе tree.


> !Контекст вызова функций модуля

	> Проблема:
		- Функционал модуля находится в объекте.
		- Конструктор дерева создаст дереву-объекту свойство, куда и засунет
			объект с функционалом этого модуля.
		- Проблема в том, что нам надо, чтобы все функции из этого модуля
			выполнялись в контексте объекта-дерева, а не объекта, вкотором
			они лежат в виде свойств.

	> Решение:
		- При написании всех функций этого модуля считаем, что они выполняюстя
			в контексте объекта-дерева.
		- В конструкторе объекта дерева инициализировать функционал этого модуля,
			используя функции-обёртки, внутри которых с помощью apply вызывать
			функционал данного модуля в контексте объекта-дерева.


> Функционал. Принипы организации и список.

	> Главные принципы организации функционала в модуле

		> Принцип "весь код разбить на функции"
			- Подавляющее большинство кода модуля должно быть разбито на функции.
			- Функция по сути своей - тот же модуль. Некая единица кода, которая
				имеет входы и выходы. И раз мы используем модули, то логично применить
				тот же подход и внутри модуля.

		> Принцип "простые и мелкие"
			- Все и каждая функция должна быть простая и мелкая.
			- По возможности, лучше разбить крупные функции на мелкие.
			- Это позволит легко поддерживать код и понимать, что происходит.

		> Весь функционал поступает на выход модуля
			- Он поступает на выход модуля, и доступен извне.

	> Функционал модуля:
		- closeopen.handler()								// функция-обработчик пользовательских кликов
		- closeopen.on()										// включить
		-	closeopen.off()										// выключить
		- closeopen.setAnimationspeed(s)		// установить скорость анимации в мс: [50 ... 1000]
		- closeopen.open(id)								// раскрыть указанный узел
		- closeopen.close(id)								// закрыть указанный узел
		- closeopen.openAll()								// развернуть разом все узлы дерева
		- closeopen.closeAll()							// свернуть разом все узлы дерева
		- closeopen.animate(element, speed)	// анимировать закрытие/открытие узла


> Система учёта добавленных модулем дереву обработчиков событий

	> Проблема:
		- При включении закрытия/открытия у дерева ему должен быть добавлен
			соотв. обработчик событий. А при выключении - он должен быть убран.
		- Чтобы убрать функцию-обработчик, надо иметь ссылку на неё.
			Следовательно, надо где-то сохранять её.

	> Особенности:
		- У одного дерева может быть только одна подобная функция-обработчик.
			Потому что выделение у дерева либо включено (обрабтчик добавлен),
			либо выключено (обработчика нет).

	> Решение:
		- В объект closeopen, который возвращает модуль, добавить свойство
			handler, и инициировать его значением ссылкой на функцию-обработчик.
		- Ссылка на эту функцию будет доступна из любого объекта-дерева,
			как следствие, всегда можно будет снять обработчик событий в лице
			этой функции с любого DOM-элемента.


> Прочие данные о работе модуля

	> Корректная работа выделения 2-х и более экземплярах
		- Если на 1 странице присутствуют 2 и более экземпляров деревьев,
			выделение в каждом из них должно работать корректно.

	> Анимация

		> На какой технологии сделана
			- Анимация сделана с помощью CSS3-свойства transition.

		> Возникшие сложности
		  - CSS3-свойство transition не предназначено для анимации auto-значений.
		  	А предназначено только для анимации типа "fixed-fixed".
		  - А в этом модуле требуется анимация типа "fixed-auto" и "auto-fixed".

		> Решение сложностей
		  - Таким образом, чтобы анимация работала, требуется применять небольшую
		  	хитрость. А именно, перед анимацией превращать auto-значение в
		  	fixed-значение, проводить анимацию, и затем делать обратное
		  	преобразование от fixed к auto.
			- Все эти вещи реализованы в отдельных функциях.


> Использование
	- Весь функционал модуля доступен в объекте-дереве по адресу:
			[объект-дерево].closeopen.[функци модуля].
	- Список доступных функций и описание см. выше.


> Архитектура: масштабный взгляд

	> Взгляд на модуль в приложении
		- В сборке в глобальное пр.имён должно быть помещено свойство tree,
			содержащее ссылку на объект-прототип дерева.
		- При создании нового экземпляра дерева срабатывает конструктор.
		- В конструкторе объекту-дереву присваивается свойство closeopen,
			которое и содержит весь функционал модуля m5_closeopen.
		- Каждая функция модуля m5_closeopen при вызове выполняется НЕ в контексте
			объекта closeopen, а в контексте объекта-дерева.
		- При создании DOM-представления объекта-дерева, функционал closeopen
			автоматически может включиться у дерева, если это было указано в
			его конфигурационном объекте.
		- Или же его можно включить вручную, используя соответствующие функции.
		- Раскрытие/закрытие узлов может осуществляться

	> Взгляд на механику раскрытия/закрытия узлов
		- Воздийствие производится на дочерний элемент UL того узла LI,
			который требуется закрыть/открыть.
		- Если без анимации, то достаточно переключать CSS-свойство "display"
			этого между значениями "none" и "block".
		- Для анимации, перед переключением значения display, надо анимировать
			CSS-свойство height.


> Архитектура кода модуля

[-----IN. Входы модуля]

IN1.	С помощью функции define определить модуль.
			> Внутри callback-функции модуля выполнить: [].
			> Подключить на вход модуля следующие зависимости:
				- m1_library_v1

IN2.	Создать и подготовить объект closeopen для аккумуляции
			функционала модуля.


[-----F. Создание функционала модуля]

	[-----F1.	Функция on()]
	 		> Описание: включает функционал модуля для дерева
	 		> Аргументы: нет
	 		> Возвращает: нет

		F1.1.	Изменить значение свойства [объект-дерево].components.
					closeopen.enable на true.

		F1.2.	Попробовать найти DOM-элемент дерева DIV с помощью
					getElementById по ID дерева. Сохранить в переменную.

		F1.3.	Если элемент DIV в F1.2 найден не был, завершить
					работу функции.

		F1.4.	Если элемент DIV в F1.2 был найден, то добавить ему
					класс "tree-nodes-close_open".

		F1.5.	Назначить экземпляру-дереву функцию-обработчик
		 			this.closeopen.handler события 'click'


	[-----F2.	Функция off()]
	 		> Описание: выключает функционал модуля для дерева
	 		> Аргументы: нет
	 		> Возвращает: нет

		F2.1.	Изменить значение свойства [объект-дерево].components.
					closeopen.enable на false.

		F2.2.	Попробовать найти DOM-элемент дерева DIV с помощью
					getElementById по ID дерева. Сохранить в переменную.

		F2.3.	Если элемент DIV в F2.2 найден не был, завершить
					работу функции.

		F2.4.	Если элемент DIV в F2.2 был найден, то убрать у него
					класс "tree-nodes-close_open".

		F2.5.	Убрать e экземпляра-дерева функцию-обработчик
		 			this.closeopen.handler события 'click'


	[-----F3.	Функция open(nodeID)]
			> Описание: открывает указанный узел
			> Аргументы:
				- nodeID: id узла без префикса, который надо раскрыть
			> Возвращает: нет

		F3.1.	Изменить значение свойства state.opened эл-та nodeID на true.

		F3.2.	Попробовать найти DOM-элемент узла LI по nodeID с
					префиксом в виде ID дерева и с помощью функции
					getElementById. Сохранить в переменную.

		F3.3.	Если элемент LI в F3.2 найден не был, завершить
					работу функции.

		F3.4.	Если элемент LI в F3.2 был найден, то присвоить
					эл-ту LI из 3.2 класс "tree-node-opened", и удалить
					у него класс 'tree-node-closed'

		F3.5.	Если элемент LI в F3.2 был найден, то присвоить
					эл-ту LI>I класс "tree-icon-opened", и удалить у него
					класс "tree-icon-closed"

		F3.6. Осуществить анимацию открытия узла с помощью функции
					this.closeopen.animate.


	[-----F4.	Функция close(nodeID)]
			> Описание: закрывает указанный узел
			> Аргументы:
				- nodeID: id узла без префикса, который надо закрыть
			> Возвращает: нет

		F4.1.	Изменить значение свойства state.opened эл-та nodeID на false.

		F4.2.	Попробовать найти DOM-элемент узла LI по nodeID с
					префиксом в виде ID дерева и с помощью функции
					getElementById. Сохранить в переменную.

		F4.3.	Если элемент LI в F4.2 найден не был, завершить
					работу функции.

		F4.4.	Если элемент LI в F4.2 был найден, то присвоить
					эл-ту LI из 3.2 класс "tree-node-closed", и удалить
					у него класс 'tree-node-opened'

		F4.5	Если элемент LI в F4.2 был найден, то присвоить
					эл-ту LI>I класс "tree-icon-closed", и удалить у него
					класс "tree-icon-opened"

		F4.6. Осуществить анимацию закрытия узла с помощью функции
					this.closeopen.animate.


	[-----F5.	Функция openAll]
			> Описание: открывает все узлы дерева
			> Аргументы: нет
			> Возвращает: нет

		F5.1.	Устроить цикл по всем узлам массива this.data.
					В этом цикле к каждому из них применить функцию
					this.closeopen.open([id узла]).


	[-----F6.	Функция closeAll]
			> Описание: закрывает все узлы дерева
			> Аргументы: нет
			> Возвращает: нет

		F6.1.	Устроить цикл по всем узлам массива this.data.
					В этом цикле к каждому из них применить функцию
					this.closeopen.close([id узла]).


	[-----F7.	Функция setAnimationspeed(s)]
	 		> Описание:
				- Позволяет назначить скорость анимации закрытия/раскрытия узлов
					для конкретного дерева в миллисекундах.
				- Значение передаётся в аргументе s, и оно должно быть числом в
					диапазоне от 50 до 1000. В случае выпадения из диапазона в меньшую
					сторону будет установлено 50, а в большую - 1000.
	 		> Аргументы:
	 			- s: число, обозначающее скорость анимации в мс. Должно быть от 50 до 1000.
	 		> Возвращает: нет

		F7.1.	Назначить значение аргумента s по умолчанию, равное 100,
					на случай, если он не передан, или если он не число.
					- Применить parseInt

		F7.2.	Проверить, если s < 50, назначить ему значение 50.

		F7.3.	Проверить, если s > 1000, назначить ему значение 1000.

		F7.4.	Изменить значение свойства [объект-дерево].components.
					closeopen.animation на s.

		F7.5.	Попробовать найти DOM-элемент дерева DIV с помощью
					getElementById по ID дерева. Сохранить в переменную.

		F7.6.	Если элемент DIV в F7.5 найден не был, завершить
					работу функции.

		F7.7.	Если элемент DIV в F1.2 был найден, то проверить,
					есть ли у него пользовательский атрибут data-tree,
					и пуст ли он. Если пуст, то присвоить ему строку в
					вормате JSON следующего содержания:
					"{animation: [здесь значение s]}"

		F7.8.	Если элемент DIV в F1.2 был найден, то проверить
					есть ли у него пользовательский атрибут data-tree,
					и не пуст ли он. Если НЕ пуст, то извлечь из него
					значение, перевести из JSON-в строку, добавить в
					извлечённый объект св-во animation со значением s,
					сформировать обратно в JSON, и присвоить в кач-ве значения
					атрибуту.


	[-----F8.	Функция handler]
			> Описание: функция-обработчик события click для DOM-эл-та LI>I узла
			> Аргументы:
				- event: объект-событие
			> Возвращает: стандартное для обработчиков значение

		F8.1.	Кроссбраузерно получить ссылки на объект-событие event,
					а также на целевой объект target, в котором изначально
					произошло событие.

    F8.2.	Проверить, если target - это не элемент I с классом "tree-icon",
    			и если у него нет одного из классов "tree-icon-closed"/"tree-icon-opened",
    			то завершить работу функции-обработчика.

		F8.3.	Если у target есть класс "tree-icon-closed", то выполнить
					функцию [объект-дерево].closeopen.open(target.parentNode.id).

		F8.4.	Если у target есть класс "tree-icon-opened", то выполнить
					функцию this.closeopen.close(target.parentNode.id).


	[-----F9.	Функция animate(element, speed)]
			> Описание:
				- Когда узел закрывается в приложении "tree", то CSS-свойству display
					его дочернего эл-та UL писваивается значение 'null'.
				- Чтобы анимировать закрытие, надо быстро переключить display обратно
					на block, провести анимацию, и вернуть всё, как было. Всё это и
					выполняет данная функция.
				- Её надо применять в функциях closeopen.open и closeopen.close
					в конце.
			> Аргументы:
				- element: ссылка на эл-т UL внутри закрываемого/открываемого узла
				- speed: скорость анимации, число, в мс
			> Возвращает: стандартное для обработчиков значение

		f9.1. Вычислить стартовое значение для трансформации, и присвоить
					его CSS-свойству 'height' элемента element. Также убедиться
					что значение его display не 'none'.

			f9.1.1.	Если element.style.display == 'none', то значит это
							будет анимация закрытия узла. Поэтому стартовое значение
							не нулевое. Выполнить следующее:
							- Установить element.style.display == 'block'
							- Присвоить значение getComputedStyle(element,'')['height']
								элементу element.style['height'].
							- Сохранить в переменную type значение 'close'.

			f9.1.2.	Если element.style.display !== 'none', то значит это
							будет анимация открытия узла. Поэтому стартовое значение
							нулевое.
							- Установить element.style['height'] = 0
							- Сохранить в переменную type значение 'open'.

		f9.2.	Вычислить конечное значение для трансформации, и записать его
					в переменную end.

			f9.2.1.	Если type == 'close', значи это будет анимация закрытия
							узла. Записать end = 0.

			f9.2.2. Если type == 'open', значит это будет анимация открытия
							узла. Выполнить следующее:
							- Установить element.style['height'] = auto.
							- Записать в end значение getComputedStyle(element,'')['height']
							- Установить element.style['height'] = 0.

		f9.3. Тронуть свойство offsetWidth элемента element. Это заставит
					DOM перерисоваться, и является необходимым шагом.

		f9.4.	Установить параметры анимационного CSS3-свойства transition
					у элемента element для свойства 'height' с учётом вендорных
					префиксов, а также скорости анимации speed.

		f9.5. На время анимации отключить функционал модуля m5_closeopen,
					тем самым предотвратив "глюк", который возникает, если во
					время анимации кликнуть по переключателю.
					- Его легко увидеть, если поставить большое время анимации.

		f9.6.	Запустить процесс анимации. Для этого:
					- Установить element.style['height'] = end;

		f9.7.	Назначить анонимную именованную функцию-обработчик события
					transitionend, которая сработает по окончании анимации, и 
					подчистит все следы работы функции animate.
					- Для назначения воспользоватсья функцией library.addEvent
					- Внутри обработчика выполнить: []

			f9.7.1.	Если событие transitionend сработало при завершении
							анимации у свойства 'height' (event.propertyName = 'height'),
							то подчистить следы:
							- Убрать transition у элемента element.
							- Установить значение CSS-свойства 'height' у элемент равным 'auto'
							- Установить e.style.display = ''
							- Удалить у элемента element этот обработчик событий


[-----OUT. Выходы модуля]

OUT1.	Вернуть ссылку на объект closeopen с функционалом модуля




/* --------------------------------------------------
---------------- Р Е А Л И З А Ц И Я ----------------*/


//[-----IN. Входы модуля]

//IN1.	С помощью функции define определить модуль.
//			> Внутри callback-функции модуля выполнить: [].
//			> Подключить на вход модуля следующие зависимости:
//				- m1_library_v1
define([
	"m1_library/m1_library_v1"
	], function(library){

		console.log('Загрузился модуль "m5_closeopen_v1"');

//IN2.	Создать и подготовить объект closeopen для аккумуляции
//			функционала модуля.
var closeopen = {};


//[-----F. Создание функционала модуля]

	//[-----F1.	Функция on]
	// 	> Аргументы: нет
	// 	> Возвращает: нет
	closeopen.on = function() {

		//F1.1.	Изменить значение свойства [объект-дерево].components.
		//			closeopen.enable на true.
		this.components.closeopen.enable = true;

		//F1.2.	Попробовать найти DOM-элемент дерева DIV с помощью
		//			getElementById по ID дерева. Сохранить в переменную.
		var div = document.getElementById(this.id);

		//F1.3.	Если элемент DIV в F1.2 найден не был, завершить
		//			работу функции.
		if(!div) return;

		//F1.4.	Если элемент DIV в F1.2 был найден, то добавить ему
		//			класс "tree-nodes-close_open".
		if(div) {
			library.addClass('', 'tree-nodes-close_open', div);
		}

		//F1.5.	Назначить экземпляру-дереву функцию-обработчик
		// 			this.closeopen.handler события 'click'
		library.addEvent(
				document.getElementById(this.id),
				'click',
				false,
				this.closeopen.handler
		);

	};


	//[-----F2.	Функция off]
	//	> Описание: выключает функционал модуля для дерева
	//	> Аргументы: нет
	//	> Возвращает: нет
	closeopen.off = function() {

		//F2.1.	Изменить значение свойства [объект-дерево].components.
		//			closeopen.enable на false.
		this.components.closeopen.enable = false;

		//F2.2.	Попробовать найти DOM-элемент дерева DIV с помощью
		//			getElementById по ID дерева. Сохранить в переменную.
		var div = document.getElementById(this.id);

		//F2.3.	Если элемент DIV в F2.2 найден не был, завершить
		//			работу функции.
		if(!div) return;

		//F2.4.	Если элемент DIV в F2.2 был найден, то убрать у него
		//			класс "tree-nodes-close_open".
		if(div) {
			library.removeClass('', 'tree-nodes-close_open', div);
		}

		//F2.5.	Убрать e экземпляра-дерева функцию-обработчик
		// 			this.closeopen.handler события 'click'
		library.removeEvent(
				document.getElementById(this.id),
				'click',
				false,
				this.closeopen.handler
		);

	};


	//[-----F3.	Функция open]
	//	> Описание: открывает указанный узел
	//	> Аргументы:
	//		- nodeID: id узла без префикса, который надо раскрыть
	//	> Возвращает: нет
	closeopen.open = function(nodeID) {

		//F3.1.	Изменить значение свойства state.opened эл-та nodeID на true.
		this.hierarchyObject.index[nodeID].reference.state.opened = true;

		//F3.2.	Попробовать найти DOM-элемент узла LI по nodeID с
		//			префиксом в виде ID дерева и с помощью функции
		//			getElementById. Сохранить в переменную.
		var li = document.getElementById(this.id+'-'+nodeID);

		//F3.3.	Если элемент LI в F3.2 найден не был, завершить
		//			работу функции.
		if(!li) return;

		//F3.4.	Если элемент LI в F3.2 был найден, то присвоить
		//			эл-ту LI из 3.2 класс "tree-node-opened", и удалить
		//			у него класс 'tree-node-closed'
		if(li) {
			library.addClass('', 'tree-node-opened', li);
			library.removeClass('', 'tree-node-closed', li);
		}

		//F3.5.	Если элемент LI в F3.2 был найден, то присвоить
		//			эл-ту LI>I класс "tree-icon-opened", и удалить у него
		//			класс "tree-icon-closed"
		if(li) {

			// Получить ссылку на элемент I с классом "tree-icon", который
			// является дочерним элементом элемента LI
			var i = li.querySelector('i.tree-icon');

			// Произвести манипуляции
			library.addClass('', 'tree-icon-opened', i);
			library.removeClass('', 'tree-icon-closed', i);

		}

		//F3.6. Осуществить анимацию открытия узла с помощью функции
		//			this.closeopen.animate.
		this.closeopen.animate(
				li.querySelector('ul.tree-container-subtree-ul'),
				this.components.closeopen.animation
		);

	};

	//[-----F4.	Функция close]
	closeopen.close = function(nodeID) {

		//F4.1.	Изменить значение свойства state.opened эл-та с nodeID на false.
		this.hierarchyObject.index[nodeID].reference.state.opened = false;

		//F4.2.	Попробовать найти DOM-элемент узла LI по nodeID с
		//			префиксом в виде ID дерева и с помощью функции
		//			getElementById. Сохранить в переменную.
		var li = document.getElementById(this.id+'-'+nodeID);

		//F4.3.	Если элемент LI в F4.2 найден не был, завершить
		//			работу функции.
		if(!li) return;

		//F4.4.	Если элемент LI в F4.2 был найден, то присвоить
		//				эл-ту LI из 3.2 класс "tree-node-closed", и удалить
		//			у него класс 'tree-node-opened'
		if(li) {
			library.addClass('', 'tree-node-closed', li);
			library.removeClass('', 'tree-node-opened', li);
		}

		//F4.5		Если элемент LI в F4.2 был найден, то присвоить
		//				эл-ту LI>I класс "tree-icon-closed", и удалить у него
		//				класс "tree-icon-opened"
		if(li) {

			// Получить ссылку на элемент I с классом "tree-icon", который
			// является дочерним элементом элемента LI
			var i = li.querySelector('i.tree-icon');

			// Произвести манипуляции
			library.addClass('', 'tree-icon-closed', i);
			library.removeClass('', 'tree-icon-opened', i);

		}

		//F4.6. Осуществить анимацию закрытия узла с помощью функции
		//			this.closeopen.animate.
		this.closeopen.animate(
				li.querySelector('ul.tree-container-subtree-ul'),
				this.components.closeopen.animation
		);

	};


	//[-----F5.	Функция openAll()]
	//	> Описание: открывает все узлы дерева
	//	> Аргументы: нет
	//	> Возвращает: нет
	closeopen.openAll = function() {

		//F5.1.	Устроить цикл по всем узлам массива this.data.
		//			В этом цикле к каждому из них применить функцию
		//			this.closeopen.open([id узла]).
		for(var i=0; i<this.data[i].length; i++) {
			this.closeopen.open(this.data[i].id);
		}

	};


	//[-----F6.	Функция closeAll]
	//	> Описание: открывает все узлы дерева
	//	> Аргументы: нет
	//	> Возвращает: нет
	closeopen.closeAll = function() {

		//F6.1.	Устроить цикл по всем узлам массива this.data.
		//			В этом цикле к каждому из них применить функцию
		//			this.closeopen.close([id узла]).
		for(var i=0; i<this.data[i].length; i++) {
			this.closeopen.close(this.data[i].id);
		}

	};


	//[-----F7.	Функция setAnimationspeed(s)]
	//	> Описание:
	//		- Позволяет назначить скорость анимации закрытия/раскрытия узлов
	//			для конкретного дерева в миллисекундах.
	//		- Значение передаётся в аргументе s, и оно должно быть числом в
	//			диапазоне от 50 до 1000. В случае выпадения из диапазона в меньшую
	//			сторону будет установлено 50, а в большую - 1000.
	//	> Аргументы:
	//		- s: число, обозначающее скорость анимации в мс. Должно быть от 50 до 1000.
	//	> Возвращает: нет
	closeopen.setAnimationspeed = function(s) {

		//F7.1.	Назначить значение аргумента s по умолчанию, равное 100,
		//			на случай, если он не передан, или если он не число.
		//			- Применить parseInt
		if(!s || typeof parseInt(s) !== 'number') s = 100;

		//F7.2.	Проверить, если s < 50, назначить ему значение 50.
		if(s < 50) s = 50;

		//F7.3.	Проверить, если s > 1000, назначить ему значение 1000.
		if(s > 1000) s = 1000;

		//F7.4.	Изменить значение свойства [объект-дерево].components.
		//			closeopen.animation на s.
		this.components.closeopen.animation = s;

		//F7.5.	Попробовать найти DOM-элемент дерева DIV с помощью
		//			getElementById по ID дерева. Сохранить в переменную.
		var div = document.getElementById(this.id);

		//F7.6.	Если элемент DIV в F7.5 найден не был, завершить
		//			работу функции.
		if(!div) return;

		//F7.7.	Если элемент DIV в F1.2 был найден, то проверить,
		//			есть ли у него пользовательский атрибут data-tree,
		//			и пуст ли он. Если пуст, то присвоить ему строку в
		//			вормате JSON следующего содержания:
		//			"{animation: [здесь значение s]}"
		if(div) {
			if(!div.getAttribute('data-tree')) {
				div.setAttribute('data-tree', JSON.stringify({"animation": s}));
			}
		}

		//F7.8.	Если элемент DIV в F1.2 был найден, то проверить
		//			есть ли у него пользовательский атрибут data-tree,
		//			и не пуст ли он. Если НЕ пуст, то извлечь из него
		//			значение, перевести из JSON-в строку, добавить в
		//			извлечённый объект св-во animation со значением s,
		//			сформировать обратно в JSON, и присвоить в кач-ве значения
		//			атрибуту.
		if(div) {
			if(div.getAttribute('data-tree')) {
				var tempObj = JSON.parse(div.getAttribute('data-tree'));
				tempObj.animation = s;
				div.setAttribute('data-tree', JSON.stringify(tempObj));
			}
		}


	};


	//[-----F8.	Функция handler(event)]
	//	> Описание:
	//		- Она предназначена для того, чтобы быть назначенной DOM-элементу DIV,
	//			представляющему объект-дерево, и отлавливать щелчки пользователя
	//			по эл-там i с классом "tree-icon" в узлах этого дерева.
	//		- Принцип действия, как у переключателя. Если узел закрыт, открыть его.
	//			Если узел открыт, закрыть его.
	//		> Аргументы:
	//			- event: объект-событие
	//		> Возвращает: стандартное для обработчиков значение
	closeopen.handler = function(event) {

		//F8.1.	Кроссбраузерно получить ссылки на объект-событие event,
		//			а также на целевой объект target, в котором изначально
		//			произошло событие.

			//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
			event = library.fixEvent(event);

			//Кроссбраузерно получить target-элемент
			var target = 	event && event.target ||
										event.srcElement;

		//F8.2.	Проверить, если target - это не элемент I с классом "tree-icon",
		//			и если у него нет одного из классов "tree-icon-closed"/"tree-icon-opened",
		//			то завершить работу функции-обработчика.
		if(target.tagName !== 'I' || library.checkClass('', 'tree-icon', target) !== 1) {

			if(	library.checkClass('', 'tree-icon-closed', target) !== 1 &&
					library.checkClass('', 'tree-icon-opened', target) !== 1)

						return;
		}


		//F8.3.	Если у target есть класс "tree-icon-closed", то выполнить
		//			функцию [объект-дерево].closeopen.open(target.parentNode.id).
		if(library.checkClass('', 'tree-icon-closed', target) == 1) {

			// Получить ссылку на экземпляр-дерево, к которому относится DOM-элемент,
			// в котором сработал обработчик
			var t = tree.trees[this.id];

			// Получить id узла без префикса,в котором сработал обработчик
			var id = target.parentNode.id.match(/nodeUID\d{1,}/)[0];

			// Выполнить функцию closeopen.open
			t.closeopen.open(id);

			// Завершить выполнение обработчика
			return;

		}


		//F8.4.	Если у target есть класс "tree-icon-opened", то выполнить
		//			функцию this.closeopen.close(target.parentNode.id).
		if(library.checkClass('', 'tree-icon-opened', target) == 1) {

			// Получить ссылку на экземпляр-дерево, к которому относится DOM-элемент,
			// в котором сработал обработчик
			var t = tree.trees[this.id];

			// Получить id узла без префикса,в котором сработал обработчик
			var id = target.parentNode.id.match(/nodeUID\d{1,}/)[0];

			// Выполнить функцию closeopen.open
			t.closeopen.close(id);

			// Завершить выполнение обработчика
			return;

		}

	};


	//[-----F9.	Функция closeopen.animate(element, speed)]
	//		> Описание:
	//			- Когда узел закрывается в приложении "tree", то CSS-свойству display
	//				его дочернего эл-та UL писваивается значение 'null'.
	//			- Чтобы анимировать закрытие, надо быстро переключить display обратно
	//				на block, провести анимацию, и вернуть всё, как было. Всё это и
	//				выполняет данная функция.
	//			- Её надо применять в функциях closeopen.open и closeopen.close
	//				в конце.
	//		> Аргументы:
	//			- element: ссылка на эл-т UL внутри закрываемого/открываемого узла
	//			- speed: скорость анимации, число, в мс
	//		> Возвращает: стандартное для обработчиков значение
	closeopen.animate = function(element, speed) {

		//f9.1. Вычислить стартовое значение для трансформации, и присвоить
		//			его CSS-свойству 'height' элемента element. Также убедиться
		//			что значение его display не 'none'.

		var type = function() {

			//f9.1.1.	Если у element display == 'none', то значит это
			//				будет анимация закрытия узла. Поэтому стартовое значение
			//				не нулевое. Выполнить следующее:
			//				- Установить element.style.display == 'block'
			//				- Присвоить значение getComputedStyle(element,'')['height']
			//					элементу element.style['height'].
			//				- Сохранить в переменную type значение 'close'.
			if(getComputedStyle(element,'')['display'] == 'none') {

				//Установить element.style.display == 'block'
				element.style.display = 'block';

				//Присвоить значение getComputedStyle(element,'')['height']
				//элементу element.style['height'].
				element.style['height'] = getComputedStyle(element,'')['height'];

				// Сохранить в переменную type значение 'close'
				return 'close';

			}

			//f9.1.2.	Если element.style.display !== 'none', то значит это
			//				будет анимация открытия узла. Поэтому стартовое значение
			//				нулевое.
			//				- Установить element.style['height'] = 0
			//				- Сохранить в переменную type значение 'open'.
			if(getComputedStyle(element,'')['display'] !== 'none') {

				//Установить element.style['height'] = 0
				element.style['height'] = 0;

				// Сохранить в переменную type значение 'open'
				return 'open';

			}

		}();

		
		//f9.2.	Вычислить конечное значение для трансформации, и записать его
		//			в переменную end.
	
			//f9.2.1.	Если type == 'close', значи это будет анимация закрытия
			//				узла. Записать end = 0.
			if(type === 'close') var end = 0;

			//f9.2.2. Если type == 'open', значит это будет анимация открытия
			//				узла. Выполнить следующее:
			//				- Установить element.style['height'] = auto.
			//				- Записать в end значение getComputedStyle(element,'')['height']
			//				- Установить element.style['height'] = 0.
			if(type === 'open') {
				
				//Установить element.style['height'] = auto.
				element.style['height'] = 'auto';
				
				//Записать в end значение getComputedStyle(element,'')['height']
				var end = getComputedStyle(element,'')['height'];
				
				// Установить element.style['height'] = 0.
				element.style['height'] = 0;
				
			}
		
		
		//f9.3. Тронуть свойство offsetWidth элемента element. Это заставит
		//			DOM перерисоваться, и является необходимым шагом.
		element.offsetWidth;
		

		//f9.4.	Установить параметры анимационного CSS3-свойства transition
		//			у элемента element для свойства 'height' с учётом вендорных
		//			префиксов, а также скорости анимации speed.
		element.style['-webkit-transition'] = 'height'+' '+speed/1000+'s'+' '+'ease-in-out';
		element.style['-moz-transition'] = 'height'+' '+speed/1000+'s'+' '+'ease-in-out';
		element.style['-ms-transition'] = 'height'+' '+speed/1000+'s'+' '+'ease-in-out';
		element.style['-o-transition'] = 'height'+' '+speed/1000+'s'+' '+'ease-in-out';
		element.style['transition'] = 'height'+' '+speed/1000+'s'+' '+'ease-in-out';	
		

		//f9.5. На время анимации отключить функционал модуля m5_closeopen,
		//			тем самым предотвратив "глюк", который возникает, если во
		//			время анимации кликнуть по переключателю.
		//			- Его легко увидеть, если поставить большое время анимации.
		this.closeopen.off();


		//f9.6.	Запустить процесс анимации. Для этого:
		//			- Установить element.style['height'] = end;
		element.style['height'] = end;
		
		
		//f9.7.	Назначить анонимную именованную функцию-обработчик события
		//			transitionend, которая сработает по окончании анимации, и 
		//			подчистит все следы работы функции animate.
		//			- Для назначения воспользоватсья функцией library.addEvent
		//			- Внутри обработчика выполнить: []
		library.addEvent(element, 'transitionend', false, function animHandler(event){
			
			//f9.7.1.	Если событие transitionend сработало при завершении
			//				анимации у свойства 'height' (event.propertyName = 'height'),
			//				то подчистить следы:
			//				- Убрать transition у элемента element.
			//				- Установить значение CSS-свойства 'height' у элемент равным 'auto'
			//				- Установить e.style.display = ''
			//				- Удалить у элемента element этот обработчик событий			

				//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
				event = library.fixEvent(event);

				//Кроссбраузерно получить target-элемент
				var target = 	event && event.target ||
											event.srcElement;

				if(event.propertyName = 'height') {
					
					// Убрать transition у элемента element.
					element.style.transition = '';
					
					// Установить значение CSS-свойства 'height' у элемент равным 'auto'
					element.style['height'] = 'auto';
					
					// Установить e.style.display = ''
					library.removeEvent(element, 'transitionend', false, animHandler);
					
					// Удалить у элемента element этот обработчик событий	
					element.style.display = '';

					// Включить отключённый перед анимацией функционал модуля m5_closeopen
					tree.trees[target.parentNode.id.match(/treeUID\d{1,}/)[0]].closeopen.on();

				}			
			
		});
	
	};
	


//[-----OUT. Выходы модуля]

//OUT1.	Вернуть ссылку на объект closeopen с функционалом модуля
return closeopen;


});		// конец определения модуля с помощью define









