// ============================================
// Модуль "m8_treemakedom_v1" приложения "tree"
// ============================================



/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:




*****************************************************
Оглавление:

	> О модуле
		> Описание модуля
		> Вход: зависимости модуля
		> Выход: что возвращает модуль

	> Что произойдёт, если применить функцию >= 2 раз подряд?
	> Алгоритм построения HTML-разметки дерева

	> Архитектура модуля


*****************************************************



> О модуле

	> Описание модуля

		> Общая информация
			- Этот модуль является доп. функционалом для модуля "m3_treeproto".
			- Модуль реализует функцию treemakedom.
			- Эта функция должна применяться в контексте this объекта-дерева,
				созданного из прототипа "m3_treeproto".

		> Что возвращает функция treemakedom
			> У функции есть параметр subtree.
			> Если subtree == false, функция сформирует DOM-структуру,
				как для целого дерева.
			> Если subtree == true, функция сформирует DOM-структуру,
				как для поддерева.

	> Вход: зависимости модуля
		- m1_library_v1

	> Выход: что возвращает модуль
		- Ссылку на функцию treemakedom
		- Эта функция должна применяться в контексте this объекта-дерева,
			созданного из прототипа "m3_treeproto".


> Что произойдёт, если применить функцию >= 2 раз подряд?

	> Проблема
		- Применив функцию к объекту-дереву в 1-й раз, мы получим DOM-элемент,
		 	у которого будет уникальный ID + содержимое.
		- Применив функцию к объекту-дереву во 2-й раз, мы получим ошибку -
			функция не сможет создать второй DOM-элемент с таким же ID, потому
			что не может быть 2-х одинаковых ID в документе.

	> Решение
		1.	В самом начале функции проверить, существует ли уже элемент
				DIV с таким же ID. Если да, и subtree == false, то вернуть false,
				сообщив таким образом об этом.
		2.	Если subtree == true, то поддерево вполне можно построить, ведь
				у элемента UL поддерева нет никакого ID, и таких эл-тов может быть
				в документе сколько угодно.



> Алгоритм построения HTML-разметки дерева

	> Задача
		> Имеется объект дерево. Чтобы разместить его в HTML-документе,
			надо из этого объекта получить HTML-разметку.

	> Решение
		> У прототипа дерева должна быть функция getTreeHTML.
		> getTreeHTML - это свойство объекта-прототипа дерева treeProto.
		> Эта функция должна возвращать HTML-разметку. А точнее,
			ссылку на HTML-элемент, который достаточно будет вставить
			в нужное место HTML-документа.

	> Дерево или поддерево?
		> У функции getTreeHTML должен быть параметр subtree, который
			позволял бы выбрать, какую разметку вернёт функция:
			> Если subtree == true, функция вернёт поддерево.
				- Это будет ссылка на эл-т UL с классом "tree-container-subtree-ul".
				- Его можно вставить в конец HTML-разметки любого эл-та LI любого дерева.
			> Если subtree == false, функция вернёт дерево.
				- Это будет ссылка на эл-т DIV.
				- Его можно будет вставить в любое место документы, ведь это целое дерево.

	> Какие узлы считать корневыми?
		- Корневые узлы те, у которых parent == '#'.

	> Как найти все корневые узлы?
		- Пробежаться по всем узлам дерева из this.data и найти их.

	> Префиксы
		- При построении HTML-разметки, в атрибут ID узлов LI следует
			записывать не просто ID узла. А с префиксом в виде ID дерева.
			Например:
			- ID узла: "nodeUID5"
			- ID дерева: "treeUID2"
			- Значение атрибута ID у эл-та LI: "treeUID2-nodeUID2"

	> Алгоритм построения HTML-разметки (дерево)
		1.	Пробежаться циклом по всем узлам дерева из this.data.
				Во время этого сделать следующее:
				- Создать новый объект.
				- Он должен содержать 2 объекта. Условно говоря, массив
					"корневые узлы", и объект "иерархический индекс".
					Выглядеть это должно так:

						hierarchyObject = {
							root : [],
							index : {}
						};

				- В root лежит массив строк, содержащий ID корневых узлов.
						Такой ID потом можно легко использовать как для получения
						ссылки на сам корневой узел:

							hierarchyObject.index['id корневого узла'].reference

						Так и для получения объекта с ID и ссылками на все
						дочерние для этого корневого узла узлы:

							hierarchyObject.index['id корневого узла'].children

				- В index лежит объект.
					- Каждый ключ - это ID одного из узлов дерева, перечислены все они.
					-	Каждое значение - это объект. В этом объекте лежат
						2 свойства: "reference" и "children".
						- "reference" - это ссылка на данный узел.
						- "children" - здесь лежит объект. В этом объекте перечислены
													 все дочерние узлы этого узла. Ключ - id, значение -
													 ссылка.
					- Выглядит всё это так:

						index : {

							[ID узла №1] : {
								reference : [ссылка на узел №1],
								children : {
									[ID доч.узла №1 для узла №1] : [ссылка на него],
									[ID доч.узла №2 для узла №1] : [ссылка на него],
									...
								}
							},

							[ID узла №2] : {
								...
							},

							...

						}

		2. Построить базовую разметку для дерева, содержащую 2 элемента -
			 div и UL (корневой) со всеми их классами и атрибутами.
		3. Добавить в UL из п.3 все LI корневых узлов (воспользоваться
			 методом getNodeHTML).
			 - Не забыть про префиксы
		4. Далее, используя построенный в п.1 индекс, для каждого из корневых
			 узлов сверху вниз выстроить HTML-разметку.
			 - Не забыть про префиксы
		5. Вернуть ссылку на DIV из п.2.

	> Алгоритм построения HTML-разметки (поддерево)
		1.	Тоже самое, что описано выше для дерева.
		2.	Создать элемент UL (не корневой).
		3.	Добавить в UL из п.2 все LI корневых узлов.
				- Не забыть про префиксы
		4.	Далее, используя построенный в п.1 индекс, для каждого из корневых
				узлов сверху вниз выстроить HTML-разметку.
				- Не забыть про префиксы
		5.	Вернуть ссылку на DIV из п.2



> Архитектура модуля


//[-----IN. Входы модуля]

IN1.	С помощью функции define определить модуль.
			> Внутри callback-функции модуля выполнить: [A,HI,HT,HS,OUT].
			> Подключить на вход модуля следующие зависимости:
				- m1_library_v1


[-----A. Создание функции treemakedom]

A1.	Создать переменную treemakedom и в ней анонимную функцию:
		Аргументы:
			- prefix: (по умолчанию '') можно указать альтернативный префикс.
				> По умолчанию каждое ID узла подписывается префиксом в виде
					ID дерева, в котором он находится.
				> В prefix можно указать альтернативный вариант префикса, которым
					вместо стандартного префикса (ID дерева) будет подписан ID каждого
					узла.
					> Используется, когда надо получить поддерево, и подписать его
						узлы, используя в кач-ве префикса ID другого дерева.
					> В строке prefix символ "-" указывать не надо.
			- subtree: [true/false (по умолчанию)] - вернуть HTML-разметку как для
				 					целого дерева (true), или как для поддерева?
		Возвращает:
			- Если subtree == false, а эл-т DIV с таким ID уже существует в
				документе, то функция вернёт false.
			- Если subtree==false, а эл-та DIV с таким ID еще не существует в
				документе, то функция вернёт ссылку на созданнйй элемент DIV.
			- Если subtree==true, то функция вернёт ссылку на созданный
				элемент поддерева UL.
		Реализация:
			- Внутри этой функции выполнить следующее: [A2,A3,A4,HI,HT,HS]

A2. Определить значение по умолчанию для атрибута subtree.
		- Если он не передан, то должен быть равен false.
		- Если передано не boolean-значение, тоже присвоить ему false.

A3.	Определить значение атрибута prefix по умолчанию
		(ID этого дерева):

A4.	Если subtree == false, проверить - существует ли уже элемент DIV с таким
 		же ID, как у объекта-дерева. Если да, то вернуть false (продолжать нет
 		смысла, поскольку создать ещё 1-ин div с таким id не выйдет).



	[-----HI. Создание и заселение иерархического объекта this.hierarchyObject]

	HI.1.	Создать пустой объект this.hierarchyObject. В него в следующих
				пунктах будет собрана вся необходимая для построения HTML-размкетки
				иерархическая информация об узлах:
				- Ссылки на корневые узлы.
				- Для всех узлов дерева индек ссылок на дочерние узлы.

	HI.2.	Организовать цикл по всем объектам-узлам этого дерева в data.
				В этом цикле на каждой итерации выполнить следующее: [HI.3 - HI.11]

		HI.3. Сделать следующее:
					- Проверить, если св-ва hierarchyObject.index ещё не существует,
						то создать его и инициировать пустым объектом.
					- Записать все данные об этом узле, а также о его родителе
						в hierarchyObject.index. А именно выполнить: [HI.4 - HI.8]

			HI.4.	Если в hierarchyObject.index ещё не существует свойства
						с именем, равным ID этого узла, то создать такое свойство,
						и инициировать его объектом.

			HI.5.	Если в hierarchyObject.index ещё не существует свойства
						с именем, равным PARENT этого узла, и если этот PARENT !== "#",
						то создать такое свойство, и инициировать его объектом.

			HI.6.	Проверить, существует ли свойство
						hierarchyObject.index['id св-ва из HI.4'].reference. Если нет, то
						создать его и присвоить ему ссылку на текущий узел.

			HI.7. Если у узла PARENT !== "#", проверить существует ли свойство
						hierarchyObject.index['id св-ва из HI.5'].children. Если нет,
						создать его и присвоить ему пустой объект.

			HI.8. Если у узла PARENT !== "#", проверить, сущствует ли свойство
						hierarchyObject.index['id св-ва из HI.5'].children['id св-ва из HI.4']
						Если нет, то создать его, и присвоить ему значение, которое представляет
						собой ссылку на текущий узел.

		HI.9.		Проверить, если для текущего узла parent == "#", то записать id
						этого узла в массив hierarchyObject.root.
						А именно выполнить следующее: [HI.10 - HI.11]

			HI.10.	Проверить, существует ли свойство hierarchyObject.root.
							Если нет, инициировать его пустым массивом.

			HI.11.	Добавить в конец массива из HI.10 значение ID текущего узла.


	[-----HT.	Создание HTML-разметки как для дерева]

	HT1.	Если subtree == false, построить HTML-разметку как для целого дерева.
				А именно выполнить следующее: [HT2 - HT10]

		HT2.	Создать HTML-структуру дерева (без узлов):
					- Создать новый HTML-элемент DIV.
					- Создать новый HTML-элемент UL, и положить его в конец DIV.

		HT3.	Присвоить эл-ту DIV все нужные классы и атрибуты.
					Для этого выполнить следующее: [HT3.1 - HT3.5]

			HT3.1.	Присвоить эл-ту DIV атрибут ID со значением this.id

			HT3.2.	Присвоить эл-ту DIV атрибут data-tree со значением,
							представляющим собой JSON-строку, который был объектом,
							который содержал свойство animation со значением
							this.components.closeopen.animation

			HT3.3 	Проверить значение свойства this.components.selection.enable.
							- Если true, то присвоить эл-ту DIV класс "tree-nodes-selectable"
							- Если false, то ничего не делать.

			HT3.4		Проверить значение свойства this.components.closeopen.enable
							- Если true, то то присвоить эл-ту DIV класс "tree-nodes-close_open"
							- Если false, то ничего не делать.

			HT3.5		Проверить значение свойства this.components.unselect.enable
							- Если true, то то присвоить эл-ту DIV класс "tree-dblclick-unselectable"
							- Если false, то ничего не делать.

		HT4.	Присвоить эл-ту UL все нужные классы и атрибуты.
					Для этого выполнить следующее: [HT4.1]

			HT4.1.	Присвоить эл-ту UL класс "tree-container-root-ul".

		HT5. 	Проверить, если:
					- hierarchyObject.root не существует,
					- или если он существует, то это не массив,
					- или если он существует и это массив, и его length == 0,
					... то вернуть ссылку на элемент DIV.

		HT6. 	Проверить, если:
					- hierarchyObject.index не существует,
					- или если он существует, то это не объект,
					- или если он существует и это объект, но он пуст,
					... то вернуть ссылку на элемент DIV.

		HT7.	Добавить в конец UL все корневые узлы LI дерева. И с помощью
					функции buildDownwardDOM из HT8, заполнить каждый из этих LI
					HTML-разметкой, содержащей все его дочерние эл-ты.
					А именно сделать следующее:
					- Устроить цикл по всем элементам "X" массива hierarchyObject.root.
					- На каждой итерации выполнять следующее:
						- Получить ссылку rootLI на эл-т LI данного корневого узла
						- с помощью appendChild вставлять в конец элемента UL
							элемент rootLI
						- Выполнить функцию из HT8, передав в неё LI

		HT8.	Написать функцию, которая рекурсивно отстраивает под переданным
					ей в качестве аргумента узлом (ссылка на него) DOM-структуру для
					всех узлов, которая являются его потомками.
					Аргументы:
						- nodeRef: ссылка на узел
						- rootObjRef: ссылка на объект-узел (а не на эл-т LI)
						- hierarchyObject: ссылка на this.hierarchyObject
						- treeID: id этого дерева
					Возвращает:
						- 0, если nodeRef не передан.
						- 1, если всё ОК.

		HT9.	В конце функции из HT8 выполнить следующее:	[HT9.1 - HT9.3]

			HT9.1.	Добавить атрибуту ID эл-та LI, переданного функции (nodeRef),
							префикс. Для этого значение, вычисленное в x2.3.

			HT9.2.	Проверить, является ли данный эл-т LI (nodeRef) последним
							узлом своего родителя. Если да, то добавить ему класс "tree-last".

			HT9.3.	Проверить, содержит ли данный эл-т LI (nodeRef)
							>= 1 элементов-детей. Если нет, то добавить первому
							его дочернему эл-ту I класс "tree-icon-without-children"

		HT10.	Вернуть ссылку на элемент DIV.


	[-----HS.	Создание HTML-разметки как для поддерева]

	HS1	Если subtree == false, построить HTML-разметку как для поддерева.
			А именно выполнить следующее: []

		HS2.	Создать HTML-структуру поддерева (без узлов):
					- Создать новый HTML-элемент UL.

		HS3.	Присвоить эл-ту UL все нужные классы и атрибуты.
					Для этого выполнить следующее: [HS3.1]

			HS3.1.	Присвоить эл-ту UL класс "tree-container-subtree-ul".

		HS4. 	Проверить, если:
					- hierarchyObject.root не существует,
					- или если он существует, то это не массив,
					- или если он существует и это массив, и его length == 0,
					... то вернуть ссылку на элемент UL.

		HS5. 	Проверить, если:
					- hierarchyObject.index не существует,
					- или если он существует, то это не объект,
					- или если он существует и это объект, но он пуст,
					... то вернуть ссылку на элемент UL.

		HS6.	Добавить в конец UL все корневые узлы LI дерева. И с помощью
					функции buildDownwardDOM из HT8, заполнить каждый из этих LI
					HTML-разметкой, содержащей все его дочерние эл-ты.
					А именно сделать следующее:
					- Устроить цикл по всем элементам "X" массива hierarchyObject.root.
					- На каждой итерации выполнять следующее:
						- Получить ссылку rootLI на эл-т LI данного корневого узла
						- с помощью appendChild вставлять в конец элемента UL
							элемент rootLI
						- Выполнить функцию из HT8, передав в неё LI

		HS7.	Вернуть ссылку на элемент UL.


//[-----OUT. Выходы модуля]

//OUT1.	Вернуть ссылку на функцию treemakedom







*/

/* --------------------------------------------------
---------------- Р Е А Л И З А Ц И Я ----------------*/


//[-----IN. Входы модуля]

//IN1.	С помощью функции define определить модуль.
//			> Внутри callback-функции модуля выполнить: [A,HI,HT,HS,OUT].
//			> Подключить на вход модуля следующие зависимости:
//				- m1_library_v1
define(["m1_library/m1_library_v1"],
		function(library){

		console.log('Загрузился модуль "m8_treemakedom_v1"');


//[-----A. Создание функции treemakedom]

//A1.	Создать переменную treemakedom и в ней анонимную функцию:
//		Аргументы:
//			- prefix: (по умолчанию '') можно указать альтернативный префикс.
//				> По умолчанию каждое ID узла подписывается префиксом в виде
//					ID дерева, в котором он находится.
//				> В prefix можно указать альтернативный вариант префикса, которым
//					вместо стандартного префикса (ID дерева) будет подписан ID каждого
//					узла.
//					> Используется, когда надо получить поддерево, и подписать его
//						узлы, используя в кач-ве префикса ID другого дерева.
//					> В строке prefix символ "-" указывать не надо.
//			- subtree: [true/false (по умолчанию)] - вернуть HTML-разметку как для
//				 					целого дерева (true), или как для поддерева?
//		Возвращает:
//			- Если subtree == false, а эл-т DIV с таким ID уже существует в
//				документе, то функция вернёт false.
//			- Если subtree==false, а эл-та DIV с таким ID еще не существует в
//				документе, то функция вернёт ссылку на созданнйй элемент DIV.
//			- Если subtree==true, то функция вернёт ссылку на созданный
//				элемент поддерева UL.
//		Реализация:
//			- Внутри этой функции выполнить следующее: [A2,A3,A4,HI,HT,HS]
var treemakedom = function(prefix, subtree) {


	//A2. Определить значение по умолчанию для атрибута subtree.
	//		- Если он не передан, то должен быть равен false.
	//		- Если передано не boolean-значение, тоже присвоить ему false.
	if(subtree == undefined) 					subtree = false;
	if(typeof subtree !== 'boolean') 	subtree = false;


	//A3.	Определить значение атрибута prefix по умолчанию
	//		(ID этого дерева):
	if(!prefix) prefix = this.id;


	//A4.	Если subtree == false, проверить - существует ли уже элемент DIV с таким
	//	же ID, как у объекта-дерева. Если да, то вернуть false (продолжать нет
	//	смысла, поскольку создать ещё 1-ин div с таким id не выйдет).
	if(subtree == false) {
		if(document.getElementById(this.id)) {
			return false;
		}
	}



		//	[-----HI. Создание и заселение иерархического объекта this.hierarchyObject]

		//	HI.1.	Создать пустой объект this.hierarchyObject. В него в следующих
		//				пунктах будет собрана вся необходимая для построения HTML-размкетки
		//				иерархическая информация об узлах:
		//				- Ссылки на корневые узлы.
		//				- Для всех узлов дерева индек ссылок на дочерние узлы.
		this.hierarchyObject = {};


		//	HI.2.	Организовать цикл по всем объектам-узлам этого дерева в data.
		//				В этом цикле на каждой итерации выполнить следующее: [HI.3 - HI.11]
		for(var i=0; i<this.data.length; i++) {

			//			HI.3. Сделать следующее:
			//						- Проверить, если св-ва hierarchyObject.index ещё не существует,
			//							то создать его и инициировать пустым объектом.
			//						- Записать все данные об этом узле, а также о его родителе
			//							в hierarchyObject.index. А именно выполнить: [HI.4 - HI.8]
			if(this.hierarchyObject.index == undefined)
				this.hierarchyObject.index = {};

				//			HI.4.	Если в hierarchyObject.index ещё не существует свойства
				//						с именем, равным ID этого узла, то создать такое свойство
				//						и инициировать его объектом.
				if(this.hierarchyObject.index[this.data[i].id] == undefined)
					this.hierarchyObject.index[this.data[i].id] = {};

				//			HI.5.	Если в hierarchyObject.index ещё не существует свойства
				//						с именем, равным PARENT этого узла, и если этот PARENT !== "#",
				//						то создать такое свойство, и инициировать его объектом.
				if(this.hierarchyObject.index[this.data[i].parent] == undefined &&
					 this.data[i].parent !== '#')
					this.hierarchyObject.index[this.data[i].parent] = {};

				//			HI.6.	Проверить, существует ли свойство
				//						hierarchyObject.index['id св-ва из HI.4'].reference. Если нет, то
				//						создать его и присвоить ему ссылку на текущий узел.
				if(this.hierarchyObject.index[this.data[i].id].reference == undefined)
					this.hierarchyObject.index[this.data[i].id].reference = this.data[i];

				//			HI.7. Если у узла PARENT !== "#", проверить существует ли свойство
				//						hierarchyObject.index['id св-ва из HI.5'].children. Если нет,
				//						создать его и присвоить ему пустой объект.
				if(this.data[i].parent !== '#') {
					if(this.hierarchyObject.index[this.data[i].parent].children == undefined)
						this.hierarchyObject.index[this.data[i].parent].children = {};
				}

				//			HI.8. Если у узла PARENT !== "#", проверить, сущствует ли свойство
				//						hierarchyObject.index['id св-ва из HI.5'].children['id св-ва из HI.4']
				//						Если нет, то создать его, и присвоить ему значение, которое представляет
				//						собой ссылку на текущий узел.
				if(this.data[i].parent !== '#') {
					if(this.hierarchyObject.index[this.data[i].parent].children[this.data[i].id] == undefined)
						this.hierarchyObject.index[this.data[i].parent].children[this.data[i].id] = this.data[i];
				}


			//		HI.9.		Проверить, если для текущего узла parent == "#", то записать id
			//						этого узла в массив hierarchyObject.root.
			//						А именно выполнить следующее: [HI.10 - HI.11]
			if(this.data[i].parent == '#') {

				//			HI.10.	Проверить, существует ли свойство hierarchyObject.root.
				//							Если нет, инициировать его пустым массивом.
				if(this.hierarchyObject.root == undefined)
					this.hierarchyObject.root = [];

				//			HI.11.	Добавить в конец массива из HI.10 значение ID текущего узла.
				this.hierarchyObject.root.push(this.data[i].id);

			}

		}


		//	[-----HT.	Создание HTML-разметки как для дерева]

		//	HT1.	Если subtree == false, построить HTML-разметку как для целого дерева.
		//				А именно выполнить следующее: [HT2 - HT10]
		if(subtree == false) {

			//		HT2.	Создать HTML-структуру дерева (без узлов):
			//					- Создать новый HTML-элемент DIV.
			//					- Создать новый HTML-элемент UL, и положить его в конец DIV.

				// Создать новый HTML-элемент DIV
				var DIV = document.createElement('DIV');

				// Создать новый HTML-элемент UL, и положить его в конец DIV
				var UL = document.createElement('UL');
				DIV.appendChild(UL);

			//		HT3.	Присвоить эл-ту DIV все нужные классы и атрибуты.
			//					Для этого выполнить следующее: [HT3.1 - HT3.5]

				//			HT3.1.	Присвоить эл-ту DIV атрибут ID со значением this.id
				DIV.id = this.id;

				//			HT3.2.	Присвоить эл-ту DIV атрибут data-tree со значением,
				//							представляющим собой JSON-строку, который был объектом,
				//							который содержал свойство animation со значением
				//							this.components.closeopen.animation
				DIV.setAttribute('data-tree', JSON.stringify({
					animation: this.components.closeopen.animation
				}));

				//			HT3.3 	Проверить значение свойства this.components.selection.enable.
				//							- Если true, то присвоить эл-ту DIV класс "tree-nodes-selectable"
				//							- Если false, то ничего не делать.
				if(this.components.selection.enable) {

					library.addClass('', 'tree-nodes-selectable', DIV);
				}

				//			HT3.4		Проверить значение свойства this.components.closeopen.enable
				//							- Если true, то то присвоить эл-ту DIV класс "tree-nodes-close_open"
				//							- Если false, то ничего не делать.
				if(this.components.closeopen.enable) {
					library.addClass('', 'tree-nodes-close_open', DIV);
				}

				//			HT3.5		Проверить значение свойства this.components.unselect.enable
				//							- Если true, то то присвоить эл-ту DIV класс "tree-dblclick-unselectable"
				//							- Если false, то ничего не делать.
				if(this.components.unselect.enable) {
					library.addClass('', 'tree-dblclick-unselectable', DIV);
				}


			//		HT4.	Присвоить эл-ту UL все нужные классы и атрибуты.
			//					Для этого выполнить следующее: [HT4.1]

				//			HT4.1.	Присвоить эл-ту UL класс "tree-container-root-ul".
				library.addClass('', 'tree-container-root-ul', UL);


			//		HT5. 	Проверить, если:
			//					- hierarchyObject.root не существует,
			//					- или если он существует, то это не массив,
			//					- или если он существует и это массив, и его length == 0,
			//					... то вернуть ссылку на элемент DIV.
			var toStringOrigin = {}.toString;
			if(	this.hierarchyObject.root == undefined ||
					toStringOrigin.call(this.hierarchyObject.root).slice(8,-1) !== "Array" ||
					this.hierarchyObject.root.length == 0) return DIV;


			//		HT6. 	Проверить, если:
			//					- hierarchyObject.index не существует,
			//					- или если он существует, то это не объект,
			//					- или если он существует и это объект, но он пуст,
			//					... то вернуть ссылку на элемент DIV.
			var toStringOrigin = {}.toString;
			if(	this.hierarchyObject.index == undefined ||
					toStringOrigin.call(this.hierarchyObject.index).slice(8,-1) !== "Object" ||
					this.hierarchyObject.index.length == 0) return DIV;


			//		HT7.	Добавить в конец UL все корневые узлы LI дерева. И с помощью
			//					функции buildDownwardDOM из HT8, заполнить каждый из этих LI
			//					HTML-разметкой, содержащей все его дочерние эл-ты.
			//					А именно сделать следующее:
			//					- Устроить цикл по всем элементам "X" массива hierarchyObject.root.
			//					- На каждой итерации выполнять следующее:
			// 						- Получить ссылку rootLI на эл-т LI данного корневого узла
			//						- с помощью appendChild вставлять в конец элемента UL
			//							элемент rootLI
			//						- Выполнить функцию из HT8, передав в неё LI
			for(var i=0; i<this.hierarchyObject.root.length; i++) {

				// Получить ссылку на данный объект-узел
				var rootObjRef = this.hierarchyObject.index[this.hierarchyObject.root[i]].reference;

				// Получить ссылку на эл-т LI данного корневого узла
				var rootLI = rootObjRef.nodemakedom();

				// Добавить этот корневой узел в конец эл-та UL
				UL.appendChild(rootLI);

				// Выполнить функцию из HT8, передав в неё LI
				buildDownwardDOM(rootLI, rootObjRef, this.hierarchyObject, this.id);

			}


			//		HT8.	Написать функцию, которая рекурсивно отстраивает под переданным
			//					ей в качестве аргумента узлом (ссылка на него) DOM-структуру для
			//					всех узлов, которая являются его потомками.
			//					Аргументы:
			//						- nodeRef: ссылка на эл-т LI (а не на узел-объект)
			//						- rootObjRef: ссылка на объект-узел (а не на эл-т LI)
			//						- hierarchyObject: ссылка на this.hierarchyObject
			//						- treeID: id этого дерева
			//					Возвращает:
			//						- 0, если nodeRef не передан.
			//						- 1, если всё ОК.
			function buildDownwardDOM(nodeRef, nodeObjRef, hierarchyObject, treeID) {

				// Проверить, если nodeRef не передан, вернуть 0.
				if(nodeRef == undefined) return 0;

				// Вычислить кол-во элементов-детей у данного узла LI (nodeRef)
				// - И сохранить его в переменную numOfChildren

					// Подготовить переменную
					var numOfChildren = 0;

					// Сохранить ссылку на объект с детьми данного узла LI
					var children = hierarchyObject.index[nodeObjRef.id].children;

					// Пересчитать кол-во этих самых детей
					for(var node in children) {
							// Нас интересуют только собственные свойства children
							if(children.hasOwnProperty(node)) {
								numOfChildren++;
							}
					}


				// Если кол-во детей у этого эл-та > 0, то:
				// - Создать в нём не корневой UL.
				// - С помощью функции buildDownwardDOM() рекурсивно заселить
				//	 UL потомками данного узла.
				if(numOfChildren > 0) {

					// Создать новый HTML-элемент UL, и положить его в конец nodeRef
					var newUL = document.createElement('UL');
					nodeRef.appendChild(newUL);

					// Присвоить эл-ту newUL класс "tree-container-subtree-ul"
					library.addClass('', 'tree-container-subtree-ul', newUL);

					// Пробежаться по всем дочерним узлам nodeRef
					// - На каждой итерации добавлять в newUL эл-т LI с текущим узлом.
					var children = hierarchyObject.index[nodeRef.id].children;
					var LI;
					for(var node in children) {

						// Нас интересуют только собственные узлы объекта children
						if(children.hasOwnProperty(node)) {

							// Получить ссылку на узел LI с готовой HTML-структурой
							LI = children[node].nodemakedom();

							// Добавить этот узел дерева LI в конец newUL
							newUL.appendChild(LI);

							// Рекурсивно выполнить для него функцию buildDownwardDOM
							buildDownwardDOM(LI, children[node], hierarchyObject, treeID);

						}

					}

				}



				// 	HT9.	В конце функции из HT8 выполнить следующее:	[HT9.1 - HT9.3]

					//	HT9.1.	Добавить атрибуту ID эл-та LI, переданного функции (nodeRef),
					//					префикс в виде ID данного дерева.
					nodeRef.id = prefix + '-' + nodeRef.id;

					//	HT9.2.	Проверить, является ли данный эл-т LI (nodeRef) последним
					//					узлом своего родителя. Если да, то добавить ему класс "tree-last".

						// Если nodeRef - это корневой LI, и он последний корневой LI,
						// то добавить ему класс "tree-last"
						if(	nodeObjRef.parent == '#' &&
								nodeObjRef.id == hierarchyObject.root[hierarchyObject.root.length - 1])
							library.addClass('', 'tree-last', nodeRef);

						// Если nodeRef - не корневой LI, и он последний не корневой LI
						// у своего родителя, то добавить ему класс "tree-last"
						if(	nodeObjRef.parent !== '#') {

							// Найти ID последнего дочернего эл-та у родителя эл-та nodeRef

								// Здесь будет результат
								var lastChildID = '';

								// Получить ссылку на объект с дочерними элементами эл-та nodeObjRef
								var children = hierarchyObject.index[nodeObjRef.parent].children;

								// Найти ID последнего дочернего эл-та
								for(var node in children) {

									// Нас интересуют только собственные свойства children
									if(children.hasOwnProperty(node)) {
										lastChildID = children[node].id;
									}

								}

							// Если nodeRef.id и lastChildID совпадают, то добавить эл-ту
							// nodeRef класс "tree-last"
							if(nodeObjRef.id == lastChildID)
								library.addClass('', 'tree-last', nodeRef);

						}

					//	HT9.3.	Проверить, содержит ли данный эл-т LI (nodeRef)
					//					>= 1 элементов-детей. Если нет, то добавить первому
					//					его дочернему эл-ту I класс "tree-icon-without-children"

						// Если nodeRef не содержит в себе детей то добавить ему
						// класс "tree-icon-without-children"

							// Если кол-во потомков у данного узла numOfChildren == 0,
							// то найти у nodeRef первый дочерний эл-т I,
							// и добавить ему класс "tree-icon-without-children"
							if(numOfChildren == 0) {

								// Найти первый дочерний I (взять первый дочерний эл-т)
								var firstI = nodeRef.children[0];

								// Добавить ему класс "tree-icon-without-children"
								library.addClass('', 'tree-icon-without-children', firstI);

							}


				// Вернуть 1 - значит функция выполнилась успешно
				return 1;

			}

			//		HT10.	Вернуть ссылку на элемент DIV.
			return DIV;

		}


		//	[-----HS.	Создание HTML-разметки как для поддерева]

		//	HS1	Если subtree == false, построить HTML-разметку как для поддерева.
		//			А именно выполнить следующее: [HS2 - HS9]
		if(subtree == true) {

			//		HS2.	Создать HTML-структуру поддерева (без узлов):
			//					- Создать новый HTML-элемент UL.
			var UL = document.createElement('UL');


			//		HS3.	Присвоить эл-ту UL все нужные классы и атрибуты.
			//					Для этого выполнить следующее: [HS3.1]

			//			HS3.1.	Присвоить эл-ту UL класс "tree-container-subtree-ul".
			library.addClass('', 'tree-container-subtree-ul', UL)


			//		HS4. 	Проверить, если:
			//					- hierarchyObject.root не существует,
			//					- или если он существует, то это не массив,
			//					- или если он существует и это массив, и его length == 0,
			//					... то вернуть ссылку на элемент UL.
			var toStringOrigin = {}.toString;
			if(	this.hierarchyObject.root == undefined ||
					toStringOrigin.call(this.hierarchyObject.root).slice(8,-1) !== "Array" ||
					this.hierarchyObject.root.length == 0) return UL;


			//		HS5. 	Проверить, если:
			//					- hierarchyObject.index не существует,
			//					- или если он существует, то это не объект,
			//					- или если он существует и это объект, но он пуст,
			//					... то вернуть ссылку на элемент UL.
			var toStringOrigin = {}.toString;
			if(	this.hierarchyObject.index == undefined ||
					toStringOrigin.call(this.hierarchyObject.index).slice(8,-1) !== "Object" ||
					this.hierarchyObject.index.length == 0) return UL;


			//		HS6.	Добавить в конец UL все корневые узлы LI дерева. И с помощью
			//					функции buildDownwardDOM из HT8, заполнить каждый из этих LI
			//					HTML-разметкой, содержащей все его дочерние эл-ты.
			//					А именно сделать следующее:
			//					- Устроить цикл по всем элементам "X" массива hierarchyObject.root.
			//					- На каждой итерации выполнять следующее:
			// 						- Получить ссылку rootLI на эл-т LI данного корневого узла
			//						- с помощью appendChild вставлять в конец элемента UL
			//							элемент rootLI
			//						- Выполнить функцию из HT8, передав в неё LI
			for(var i=0; i<this.hierarchyObject.root.length; i++) {

				// Получить ссылку на данный объект-узел
				var rootObjRef = this.hierarchyObject.index[this.hierarchyObject.root[i]].reference;

				// Получить ссылку на эл-т LI данного корневого узла
				var rootLI = rootObjRef.nodemakedom();

				// Добавить этот корневой узел в конец эл-та UL
				UL.appendChild(rootLI);

				// Выполнить функцию из HT8, передав в неё LI
				buildDownwardDOM(rootLI, rootObjRef, this.hierarchyObject, this.id);

			}


			//	HS7.	Вернуть ссылку на элемент UL.
			return UL;

		}


};






//[-----OUT. Выходы модуля]

//OUT1.	Вернуть ссылку на функцию treemakedom
	return treemakedom;



});		// конец определения модуля с помощью define















