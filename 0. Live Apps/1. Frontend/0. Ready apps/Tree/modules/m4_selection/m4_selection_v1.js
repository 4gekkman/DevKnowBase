// ============================================
// Модуль "m4_selection_v1" приложения "tree"
// ============================================




/*-----------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ------------------

Ссылки:







*****************************************************
Оглавление:

	> О модуле
		> Описание модуля
		> Вход: зависимости модуля
		> Выход: что возвращает модуль

	> Синхронизация объекта-экземпляра и его DOM-структуры
	> Параметры экземпляра-приложения для синхронизации с его DOM-представлением
	> CSS и атрибуты модуля
	> !Для работы требует наличие глобальной tree
	> !Контекст вызова функций модуля
	> Функционал модуля
	> Система учёта добавленных модулем дереву обработчиков событий
	> Прочие данные о работе модуля

	> Использование

	> Архитектура: масштабный взгляд
	> Архитектура кода модуля


*****************************************************


> О модуле

	> Описание модуля
		- Этот модуль реализует работу с выделением узлов в приложении "tree".

	> Вход: зависимости модуля
		- m1_library_v1

	> Выход: что возвращает модуль
		- Объект, содержащий функционал для работы с выделением в данном
			конкретном экземпляре дерева.


> Синхронизация объекта-экземпляра и его DOM-структуры

	> Введение
		- Часто у приложения-интерфейса есть объект-прототип.
		- Из прототипа можно создавать объекты-экземпляры приложения.
		- Из экземпляра можно создать его DOM-представление.
		- DOM-представление можно публиковать в документе
		- Параметры объекта-экземпляра связаны со свойстваи DOM-структуры:
			классами, атрибутами и чем угодно.
		- Работать всегда удобнее с объектом-экземпляром.
		- Поэтому направление связи должно быть от экземпляра к DOM. Т.Е. меняешь
			значение параметра в объекте-экземпляре, и как следствие меняется
			DOM. А не наоборот.

	> Главные принципы синхронизации:

		> Принцип 100% синхронизации
			- Объект-экземпляр и его DOM-структура всегда должны быть
				синхронизированы на 100%
			- Это значит, что значения параметров объекта-экземпляра всегда
				должны на 100% соответствовать (как задумано) его DOM-структуре.

		> Направление синхронизации: от экземпляра к DOM
			- При изменении значения параметра объекта-экземпляра, автомитически
				соотв.образом должна изменяться DOM-структура. Но не наоборот.
			- В случае обнаружения рассинхронизации, её надо восстанавливать
				в пользу объекта-экземпляра.

		> Ведение работы только через объект-экземпляр
			- Управлять приложением следует только путём изменения значений
				параметров объекта-экземпляра приложения. Приложения должно
				быть разработано так, чтобы DOM менялся как следствие этих
				изменений.
			- Вести работу напрямую с DOM-представлением приложения, а не с
				его объектом-экземпляром не следует.


> Параметры экземпляра-приложения для синхронизации с его DOM-представлением

	> [объект-дерево].components.selection.enable
			# Цели синхронизации в DOM:
				- Наличие/отсутствие CSS-класса "tree-nodes-selectable" у
					элемента DIV, который представляет дерево.
			# Описание синхронизации:
				- Если selection.enable == true, то tree-nodes-selectable должен
					присутствовать у эл-та DIV дерева, и функционал модуля m4_selection
					у дерева включён.
				- Если selection.enable == false, то tree-nodes-selectable должен
					отсутствовать у эл-та DIV дерева, и функционал модуля m4_selection
					у дерева выключен.

	> [объект-узел дерева].state.selected
			# Цели синхронизации в DOM:
				- Наличие/отсутствие CSS-класса	"tree-selected" у элемента A
					узла дерева.
			# Описание синхронизации:
				- Если state.selected == true, то у элемента A должен присутствовать
					класс "tree-selected".
				- Если state.selected == false у элемента A должен отсутствовать
					класс "tree-selected".

> CSS и атрибуты модуля

	> Где хранится CSS модуля?
		- Весь CSS хранится в главном CSS-файле приложения "tree", в отдельном
			его разделе.

	> Класс "tree-nodes-selectable"
		- Присваивается элементу DIV дерева, если в этом дереве включён
			функционал модуля m4_selection. В противном случае - отсутствует.

	> Класс "tree-selected"
		- Присваивается элементу A узла-дерева, если этот узел выделен.
			В противном случае - отсутствует.


> !Для работы требует наличие глобальной tree
	- Чтобы этот модуль работал без ошибок, сборка должна создавать в
		глобальном объекте свойство tree, и записывать в него ссылку на
		объект-прототип дерева.
	- В принципе, она и так должна была это делать. Иначе зачем нужно
		дерево, если нельзя получить доступ к его функционалу? А весь
		функционал как раз и находится в объекте-прототипе tree.


> !Контекст вызова функций модуля

	> Проблема:
		- Функционал модуля находится в объекте.
		- Конструктор дерева создаст дереву-объекту свойство, куда и засунет
			объект с функционалом этого модуля.
		- Проблема в том, что нам надо, чтобы все функции из этого модуля
			выполнялись в контексте объекта-дерева, а не объекта, вкотором
			они лежат в виде свойств.

	> Решение:
		- При написании всех функций этого модуля считаем, что они выполняюстя
			в контексте объекта-дерева.
		- В конструкторе объекта дерева инициализировать функционал этого модуля,
			используя функции-обёртки, внутри которых с помощью apply вызывать
			функционал данного модуля в контексте объекта-дерева.


> Функционал. Принипы организации и список.

	> Главные принципы организации функционала в модуле

		> Принцип "весь код разбить на функции"
			- Подавляющее большинство кода модуля должно быть разбито на функции.
			- Функция по сути своей - тот же модуль. Некая единица кода, которая
				имеет входы и выходы. И раз мы используем модули, то логично применить
				тот же подход и внутри модуля.

		> Принцип "простые и мелкие"
			- Все и каждая функция должна быть простая и мелкая.
			- По возможности, лучше разбить крупные функции на мелкие.
			- Это позволит легко поддерживать код и понимать, что происходит.

		> Весь функционал поступает на выход модуля
			- Он поступает на выход модуля, и доступен извне.

	> Функционал модуля:
		- closeopen.handler()							// функция-обработчик пользовательских кликов
		- selection.on()									// включить
		- selection.off()									// выключить
		- selection.select(nodeID)				// выделяет указанный модуль
		- selection.unselect(nodeID)			// развыделяет указанный модуль
		- selection.selectAll							// выделить все узлы
		- selection.unselectAll						// развыделить все узлы
		- selection.getSelected()					// получить массив ссылок на все выделеныне элементы
		- selection.getUnselected()				// получить массив ссылок на все НЕ выделенные элементы


> Система учёта добавленных модулем дереву обработчиков событий

	> Проблема:
		- При включении выделения у дерева ему должен быть добавлен соотв.
			обработчик событий. А при выключении - он должен быть убран.
		- Чтобы убрать функцию-обработчик, надо иметь ссылку на неё.
			Следовательно, надо где-то сохранять её.

	> Особенности:
		- У одного дерева может быть только одна подобная функция-обработчик.
			Потому что выделение у дерева либо включено (обрабтчик добавлен),
			либо выключено (обработчика нет).

	> Решение:
		- В объект selection, который возвращает модуль, добавить свойство
			handler, и инициировать его значением ссылкой на функцию-обработчик.
		- Ссылка на эту функцию будет доступна из любого объекта-дерева,
			как следствие, всегда можно будет снять обработчик событий в лице
			этой функции с любого DOM-элемента.


> Прочие данные о работе модуля

	> Мультивыделение
		> Должна быть возможность одновременно выделить от 0 до всех узлов
			дерева.

	> Корректная работа выделения 2-х и более экземплярах
		> Если на 1 странице присутствуют 2 и более экземпляров деревьев,
			выделение в каждом из них должно работать корректно.

	> Какие есть способы выделить/развыделить узел?

		> Делать это можно щелчком мыши 2-мя способами:
			- Без зажатого CTRL.
			- С зажатым CTRL.

		> Поведение без зажатого CTRL:
			> Когда выделено 0 узлов дерева, если щелкнуть ЛК-мыши по любому
				узлу, он выделится.
			> Когда выделен 1 узел дерева, если щелкнуть ЛК-мыши по этому узлу,
				он развыделится.
			> Когда выделен 1 узел дерева, если щелкнуть ЛК-мыши по любому другому
				узлу дерева, то первый развыделится, а последний выделится.

		> Поведение с зажатым CTRL:
			> Когда выделено 0 узлов дерева, если щелкнуть ЛК-мыши по любому
				узлу, он выделится.
			> Когда выделено >=1 узлов дерева, если щелкнуть ЛК-мыши по любому
				из выделенных узлов, он развыделится.
			> Когда выделено >=1 узлов дерева, если щелкнуть ЛК-мыши по любому
				из НЕ выделенных узлов, он выделится.
			> Когда выделено >=1 узлов дерева, если щелкнуть ЛК-мыши БЕЗ зажатого
				CTRL по любому из выделенных узлов, развыделятся все узлы, кроме этого.
			> Когда выделено >=1 узлов дерева, если щелкнуть ЛК-мыши БЕЗ зажатого
				CTRL по любому из НЕ выделенных узлов, развыделятся все узлы,
				а этот выделится.


> Использование
	- Весь функционал модуля доступен в объекте-дереве по адресу:
			[объект-дерево].selection.[функци модуля].
	- Список доступных функций и описание см. выше.


> Архитектура: масштабный взгляд

	> Взгляд на модуль в приложении
		- В сборке в глобальное пр.имён должно быть помещено свойство tree,
			содержащее ссылку на объект-прототип дерева.
		- При создании нового экземпляра дерева срабатывает конструктор.
		- В конструкторе объекту-дереву присваивается свойство closeopen,
			которое и содержит весь функционал модуля m5_closeopen.
		- Каждая функция модуля m5_closeopen при вызове выполняется НЕ в контексте
			объекта closeopen, а в контексте объекта-дерева.
		- При создании DOM-представления объекта-дерева, функционал closeopen
			автоматически может включиться у дерева, если это было указано в
			его конфигурационном объекте.
		- Или же его можно включить вручную, используя соответствующие функции.
		- Раскрытие/закрытие узлов может осуществляться

	> Взгляд на механику визуализации выделения узлов
		- Воздийствие производится на дочерний элемент A того узла LI,
			который требуется выделить/развыделить.
		- Ему просто присваивается соответствующий стиль, и он начинает
			выглядеть выделенным.


> Архитектура модуля


[-----IN. Входы модуля]

IN1.	С помощью функции define определить модуль.
			> Подключить на вход модуля следующие зависимости:
				- m1_library_v1

IN2.	Создать и подготовить объект selection для аккумуляции
			функционала модуля.


[-----F. Создание функционала модуля]

	[-----F1.	Функция on()]
			> Описание: включает функционал модуля для дерева

		F1.1.	Изменить значение свойства [объект-дерево].components.
					selection.enable на true.

		F1.2.	Попробовать найти DOM-элемент дерева DIV с помощью
					getElementById по ID дерева. Сохранить в переменную.

		F1.3.	Если элемент DIV в F1.2 найден не был, завершить
					работу функции.

		F1.4.	Если элемент DIV в F1.2 был найден, то добавить ему
					класс "tree-nodes-selectable".

		F1.5.	Назначить экземпляру-дереву функцию-обработчик
		 			this.selection.handler события 'click'


	[-----F2.	Функция off()]
			> Описание: выключает функционал модуля для дерева

		F2.1.	Изменить значение свойства [объект-дерево].components.
					selection.enable на false.

		F2.2.	Попробовать найти DOM-элемент дерева DIV с помощью
					getElementById по ID дерева. Сохранить в переменную.

		F2.3.	Если элемент DIV в F2.2 найден не был, завершить
					работу функции.

		F2.4.	Если элемент DIV в F2.2 был найден, то убрать у него
					класс "tree-nodes-selectable".

		F2.5.	Убрать e экземпляра-дерева функцию-обработчик
		 			this.selection.handler события 'click'


	[-----F3.	Функция select(nodeID)]
			> Описание: выделяет указанный узел
			> Аргументы:
				- nodeID: id узла без префикса, который надо раскрыть
			> Возвращает: нет

		F3.1.	Изменить значение свойства state.selected эл-та nodeID на true.

		F3.2.	Попробовать найти DOM-элемент узла LI по nodeID с
					префиксом в виде ID дерева и с помощью функции
					getElementById. Сохранить в переменную.

		F3.3.	Если элемент LI в F3.2 найден не был, завершить
					работу функции.

		F3.4.	Если элемент LI в F3.2 был найден, то найти его
					дочерний элемент A и сохранить в переменную. Если
					он не был найден, то завершать работу функции.

		F3.5.	Присвоить эл-ту A из F3.4 класс "tree-selected".


	[-----F4.	Функция unselect(nodeID)]
			> Описание: развыделяет указанный узел
			> Аргументы:
				- nodeID: id узла без префикса, который надо раскрыть
			> Возвращает: нет

		F4.1.	Изменить значение свойства state.selected эл-та nodeID на false.

		F4.2.	Попробовать найти DOM-элемент узла LI по nodeID с
					префиксом в виде ID дерева и с помощью функции
					getElementById. Сохранить в переменную.

		F4.3.	Если элемент LI в F4.2 найден не был, завершить
					работу функции.

		F4.4.	Если элемент LI в F4.2 был найден, то найти его
					дочерний элемент A и сохранить в переменную. Если
					он не был найден, то завершать работу функции.

		F4.5.	Убрать у эл-та A из F4.4 класс "tree-selected".


	[-----F5.	Функция getSelected()]
			> Описание: получить массив объектов с данными по всем выделенным узлам
			> Аргументы: нет
			> Возвращает: все выделенные элементы дерева в виде массива объектов,
										где каждый объект представляет 1 из них.
			> Формат объектов:
					{
						id: "string",						// id выделенного узла без префикса
						objRef: [ссылка],				// ссылка на объект-узел в объекте-дереве
						prefixedId: "string",		// id выделенного узла с префиксом
						domRef: ссылка					// ссылка на DOM-элемент узла
					}

		F5.1.	Создать массив selectedNodesArr, который ниже будет заполнен
					данными о выделенных объектах.

		F5.2.	Устроить цикл по всем узлам дерева. Внутри проверять свойство
					[узел дерева].state.selected. Если false, переходить к следующей
					итерации. Если true, то формировать объект в указанном выше
					формате, и с помощью push добавлять его в конец массива F5.1.

		F5.3.	Вернуть selectedNodesArr.


	[-----F6.	Функция getUnselected()]
			> Описание: получить массив объектов с данными по всем НЕ выделенным узлам
			> Аргументы: нет
			> Возвращает: все НЕ выделенные элементы дерева в виде массива объектов,
										где каждый объект представляет 1 из них.
			> Формат объектов:
					{
						id: "string",						// id выделенного узла без префикса
						objRef: [ссылка],				// ссылка на объект-узел в объекте-дереве
						prefixedId: "string",		// id выделенного узла с префиксом
						domRef: ссылка					// ссылка на DOM-элемент узла
					}

		F6.1.	Создать массив unselectedNodesArr, который ниже будет заполнен
					данными о выделенных объектах.

		F6.2.	Устроить цикл по всем узлам дерева. Внутри проверять свойство
					[узел дерева].state.selected. Если true, переходить к следующей
					итерации. Если false, то формировать объект в указанном выше
					формате, и с помощью push добавлять его в конец массива F6.1.

		F6.3.	Вернуть unselectedNodesArr.


	[-----F7.	Функция selectAll()]
			> Описание: выделить все узлы дерева
			> Аргументы: нет
			> Возвращает: нет

		F7.1. Устроить цикл по всем узлам дерева. На каждой итерации
					применять к узлу функцию select.


	[-----F8.	Функция unselectAll()]
			> Описание: развыделить все узлы дерева
			> Аргументы: нет
			> Возвращает: нет

		F8.1. Устроить цикл по всем узлам дерева. На каждой итерации
					применять к узлу функцию unselect.


	[-----F9.	Функция handler()]
			> Описание:
				- Она предназначена для того, чтобы быть назначенной DOM-элементу DIV,
					представляющему объект-дерево, и отлавливать щелчки пользователя
					по эл-там A с классом "tree-anchor" в узлах этого дерева.
				- Принцип действия, как у переключателя. Если узел не выделен -
					выделить его. Если узел выделен - развыделить его.
			> Аргументы:
				- event: объект-событие
			> Возвращает: стандартное для обработчиков значение

		F9.1.	Кроссбраузерно получить ссылки на объект-событие event,
					а также на целевой объект target, в котором изначально
					произошло событие.

    F9.2.	Проверить, если target - это не элемент A с классом "tree-anchor",
    			то завершить работу функции-обработчика.

		F9.3.	Проверить, какая кнопка мыши была нажата. Если любая, кроме левой,
					завершить работу функции-обработчика.

		F9.4.	Получить ссылки на объект-дерево и объект-узел, по DOM-представлению
					которого щёлкнули. И сохранить их в переменные:

			F9.4.1. Получить ссылку на объект-дерево, в котором был клик.

			F9.4.2. Получить ссылку на объект-узел, в котором был клик.

		F9.5.	Проверить, если во время щелчка не была нажата ни одна
					клавиша-модификатор (CTRL, SHIFT, ALT, CMD), то:

			F9.5.1.	Используя getSelected().length получить кол-во выделенных
							в дереве узлов на текущий момент. Сохранить в переменную.

			F9.5.2.	Если щёлкнутый пользователем узел выделен, и F9.5.1 == 1, то:
							- Развыделить этот узел функцией unselect.
							- Завершить работу обработчика.

			F9.5.3. Если щёлкнутый пользователем узел выделен, и F9.5.1 > 1, то:
							- Развыделить все узлы функцией unselectAll
							- Выделить щёлкнутый узел функцией select
							- Завершить работу обработчика.

			F9.5.4. Если щелкнутый пользователем узел не выделен, и F9.5.1 == 0, то:
							- Выделить этот узел функцией select.
							- Завершить работу обработчика.

			F9.5.5.	Если щелкнутый пользователем узел не выделен, и F9.5.1 > 0, то:
							- Развыделить все узлы функцией unselectAll
							- Выделить этот узел функцией select.
							- Завершить работу обработчика.

		F9.6.	Проверить, если во время щелчка была нажата клавиша-модификатр
					CTRL, то:

			F9.6.1.	Если щёлкнутый пользователем узел выделен, то:
			 				- С помощью функции unselect развыделить его.
				- Завершить работу обработчика.

			F9.6.2.	Если щёлкнутый пользователем узел не выделен, то:
			 				- С помощью функции select выделить его.
							- Завершить работу обработчика.



[-----OUT. Выходы модуля]

OUT1.	Вернуть ссылку на объект selection с функционалом модуля




/* --------------------------------------------------
---------------- Р Е А Л И З А Ц И Я ----------------*/


//[-----IN. Входы модуля]

//IN1.	С помощью функции define определить модуль.
//			> Подключить на вход модуля следующие зависимости:
//				- m1_library_v1
define([
	"m1_library/m1_library_v1"
	], function(library){

		console.log('Загрузился модуль "m4_selection_v1"');

//IN2.	Создать и подготовить объект selection для аккумуляции
//			функционала модуля.
var selection = {};


//[-----F. Создание функционала модуля]

	//[-----F1.	Функция on()]
	//		> Описание: включает функционал модуля для дерева
	selection.on = function() {

		//F1.1.	Изменить значение свойства [объект-дерево].components.
		//			selection.enable на true.
		this.components.selection.enable = true;

		//F1.2.	Попробовать найти DOM-элемент дерева DIV с помощью
		//			getElementById по ID дерева. Сохранить в переменную.
		var div = document.getElementById(this.id);

		//F1.3.	Если элемент DIV в F1.2 найден не был, завершить
		//			работу функции.
		if(!div) return;

		//F1.4.	Если элемент DIV в F1.2 был найден, то добавить ему
		//			класс "tree-nodes-selectable".
		if(div) {
			library.addClass('', 'tree-nodes-selectable', div);
		}

		//F1.5.	Назначить экземпляру-дереву функцию-обработчик
		// 			this.selection.handler события 'click'
		library.addEvent(
				div,
				'click',
				false,
				this.selection.handler
		);

	};

	//[-----F2.	Функция off()]
	//		> Описание: выключает функционал модуля для дерева
	selection.off = function() {

		//F2.1.	Изменить значение свойства [объект-дерево].components.
		//			selection.enable на false.
		this.components.selection.enable = false;

		//F2.2.	Попробовать найти DOM-элемент дерева DIV с помощью
		//			getElementById по ID дерева. Сохранить в переменную.
		var div = document.getElementById(this.id);

		//F2.3.	Если элемент DIV в F2.2 найден не был, завершить
		//			работу функции.
		if(!div) return;

		//F2.4.	Если элемент DIV в F2.2 был найден, то убрать у него
		//			класс "tree-nodes-selectable".
		if(div) {
			library.removeClass('', 'tree-nodes-selectable', div);
		}

		//F2.5.	Убрать e экземпляра-дерева функцию-обработчик
		//			this.selection.handler события 'click'
		library.removeEvent(
				div,
				'click',
				false,
				this.selection.handler
		);

	};


	//[-----F3.	Функция select(id)]
	//		> Описание: выделяет указанный узел
	//		> Аргументы:
	//			- nodeID: id узла без префикса, который надо раскрыть
	//		> Возвращает: нет
	selection.select = function(nodeID) {

		//F3.1.	Изменить значение свойства state.selected эл-та nodeID на true.
		this.hierarchyObject.index[nodeID].reference.state.selected = true;

		//F3.2.	Попробовать найти DOM-элемент узла LI по nodeID с
		//			префиксом в виде ID дерева и с помощью функции
		//			getElementById. Сохранить в переменную.
		var li = document.getElementById(this.id+'-'+nodeID);

		//F3.3.	Если элемент LI в F3.2 найден не был, завершить
		//			работу функции.
		if(!li) return;

		//F3.4.	Если элемент LI в F3.2 был найден, то найти его
		//			дочерний элемент A и сохранить в переменную. Если
		//			он не был найден, то завершать работу функции.
		if(li) {
			var a = li.querySelector('a.tree-anchor');
			if(!a) return;
		}

		//F3.5.	Присвоить эл-ту A из F3.4 класс "tree-selected".
		library.addClass('', 'tree-selected', a);

	};


	//[-----F4.	Функция unselect(nodeID)]
	//		> Описание: развыделяет указанный узел
	//		> Аргументы:
	//			- nodeID: id узла без префикса, который надо раскрыть
	//		> Возвращает: нет
	selection.unselect = function(nodeID) {

		//F4.1.	Изменить значение свойства state.selected эл-та nodeID на false.
		this.hierarchyObject.index[nodeID].reference.state.selected = false;

		//F4.2.	Попробовать найти DOM-элемент узла LI по nodeID с
		//			префиксом в виде ID дерева и с помощью функции
		//			getElementById. Сохранить в переменную.
		var li = document.getElementById(this.id+'-'+nodeID);

		//F4.3.	Если элемент LI в F4.2 найден не был, завершить
		//			работу функции.
		if(!li) return;

		//F4.4.	Если элемент LI в F4.2 был найден, то найти его
		//			дочерний элемент A и сохранить в переменную. Если
		//			он не был найден, то завершать работу функции.
		if(li) {
			var a = li.querySelector('a.tree-anchor');
			if(!a) return;
		}

		//F4.5.	Убрать у эл-та A из F4.4 класс "tree-selected".
		library.removeClass('', 'tree-selected', a);

	};


	//[-----F5.	Функция getSelected()]
	//		> Описание: получить массив объектов с данными по всем выделенным узлам
	//		> Аргументы: нет
	//		> Возвращает: все выделенные элементы дерева в виде массива объектов,
	//									где каждый объект представляет 1 из них.
	//		> Формат объектов:
	//				{
	//					id: "string",						// id выделенного узла без префикса
	//					objRef: [ссылка],				// ссылка на объект-узел в объекте-дереве
	//					prefixedId: "string",		// id выделенного узла с префиксом
	//					domRef: ссылка					// ссылка на DOM-элемент узла
	//				}
	selection.getSelected = function() {

		//F5.1.	Создать массив selectedNodesArr, который ниже будет заполнен
		//			данными о выделенных объектах.
		var selectedNodesArr = [];

		//F5.2.	Устроить цикл по всем узлам дерева. Внутри проверять свойство
		//			[узел дерева].state.selected. Если false, переходить к следующей
		//			итерации. Если true, то формировать объект в указанном выше
		//			формате, и с помощью push добавлять его в конец массива F5.1.
		for(var i=0; i<this.data.length; i++) {

			if(this.data[i].state.selected) {

				selectedNodesArr.push({
					id: this.data[i].id,
					objRef: this.data[i],
					prefixedId: this.id+'-'+this.data[i].id,
					domRef: document.getElementById(this.id+'-'+this.data[i].id)
				});

			}

		}

		//F5.3.	Вернуть selectedNodesArr.
		return selectedNodesArr;

	};


	//[-----F6.	Функция getUnselected()]
	//		> Описание: получить массив объектов с данными по всем НЕ выделенным узлам
	//		> Аргументы: нет
	//		> Возвращает: все НЕ выделенные элементы дерева в виде массива объектов,
	//									где каждый объект представляет 1 из них.
	//		> Формат объектов:
	//				{
	//					id: "string",						// id выделенного узла без префикса
	//					objRef: [ссылка],				// ссылка на объект-узел в объекте-дереве
	//					prefixedId: "string",		// id выделенного узла с префиксом
	//					domRef: ссылка					// ссылка на DOM-элемент узла
	//				}
	selection.getUnselected = function() {

		//F6.1.	Создать массив unselectedNodesArr, который ниже будет заполнен
		//			данными о выделенных объектах.
		var selectedNodesArr = [];

		//F6.2.	Устроить цикл по всем узлам дерева. Внутри проверять свойство
		//			[узел дерева].state.selected. Если true, переходить к следующей
		//			итерации. Если false, то формировать объект в указанном выше
		//			формате, и с помощью push добавлять его в конец массива F6.1.
		for(var i=0; i<this.data.length; i++) {

			if(!this.data[i].state.selected) {

				selectedNodesArr.push({
					id: this.data[i].id,
					objRef: this.data[i],
					prefixedId: this.id+'-'+this.data[i].id,
					domRef: document.getElementById(this.id+'-'+this.data[i].id)
				});

			}

		}


		//F6.3.	Вернуть unselectedNodesArr.
		return selectedNodesArr;

	};


	//[-----F7.	Функция selectAll()]
	//		> Описание: выделить все узлы дерева
	//		> Аргументы: нет
	//		> Возвращает: нет
	selection.selectAll = function() {
	
		//F7.1. Устроить цикл по всем узлам дерева. На каждой итерации
		//			применять к узлу функцию select.
		for(var i=0; i<this.data.length; i++) {
			this.selection.select(this.data[i].id);
		}
		
	};
	
	
	//[-----F8.	Функция unselectAll()]
	//		> Описание: развыделить все узлы дерева
	//		> Аргументы: нет
	//		> Возвращает: нет
	selection.unselectAll = function() {
		
		//F8.1. Устроить цикл по всем узлам дерева. На каждой итерации
		//			применять к узлу функцию unselect.	
		for(var i=0; i<this.data.length; i++) {
			this.selection.unselect(this.data[i].id);
		}		
	
	};
	
	
	//[-----F9.	Функция handler()]
	//		> Описание:
	//			- Она предназначена для того, чтобы быть назначенной DOM-элементу DIV,
	//				представляющему объект-дерево, и отлавливать щелчки пользователя
	//				по эл-там A с классом "tree-anchor" в узлах этого дерева.
	//			- Принцип действия, как у переключателя. Если узел не выделен -
	//				выделить его. Если узел выделен - развыделить его.
	//		> Аргументы:
	//			- event: объект-событие
	//		> Возвращает: стандартное для обработчиков значение
	selection.handler = function(event) {

		//F9.1.	Кроссбраузерно получить ссылки на объект-событие event,
		//			а также на целевой объект target, в котором изначально
		//			произошло событие.

			//Кроссбраузерно получить объект-событие с уже примененными IE FIX-ами
			event = library.fixEvent(event);

			//Кроссбраузерно получить target-элемент
			var target = 	event && event.target ||
										event.srcElement;		
		
    //F9.2.	Проверить, если target - это не элемент A с классом "tree-anchor",
    //			то завершить работу функции-обработчика.
		if(target.tagName !== 'A' || library.checkClass('', 'tree-anchor', target) !== 1)
			return;
	
		//F9.3.	Проверить, какая кнопка мыши была нажата. Если любая, кроме левой,
		//			завершить работу функции-обработчика.
		if(event.which !== 1) return;	
		
		//F9.4.	Получить ссылки на объект-дерево и объект-узел, по DOM-представлению
		// 			которого щёлкнули. И сохранить их в переменные:

			//F9.4.1. Получить ссылку на объект-дерево, в котором был клик.
			var t = tree.trees[target.parentNode.id.match(/treeUID\d{1,}/)[0]];

			//F9.4.2. Получить ссылку на объект-узел, в котором был клик.
			var n = t.hierarchyObject.
					index[target.parentNode.id.match(/nodeUID\d{1,}/)[0]].reference;


		//F9.5.	Проверить, если во время щелчка не была нажата ни одна
		//			клавиша-модификатор (CTRL, SHIFT, ALT, CMD), то:
		if( !event.ctrlKey && 
				!event.shiftKey && 
				!event.altKey && 
				!event.metaKey) {

			//F9.5.1.	Используя getSelected().length получить кол-во выделенных
			//				в дереве узлов на текущий момент. Сохранить в переменную.
			var numOfSelectedNodes = t.selection.getSelected().length;

			//F9.5.2.	Если щёлкнутый пользователем узел выделен, и F9.5.1 == 1, то:
			//				- Развыделить этот узел функцией unselect.
			//				- Завершить работу обработчика.
			if(n.state.selected && numOfSelectedNodes == 1) {
				t.selection.unselect(n.id);
				return;
			}

			//F9.5.3. Если щёлкнутый пользователем узел выделен, и F9.5.1 > 1, то:
			//				- Развыделить все узлы функцией unselectAll
			//				- Выделить щёлкнутый узел функцией select
			//				- Завершить работу обработчика.
			if(n.state.selected && numOfSelectedNodes > 1) {
				t.selection.unselectAll();
				t.selection.select(n.id);
				return;
			}

			//F9.5.4. Если щелкнутый пользователем узел не выделен, и F9.5.1 == 0, то:
			//				- Выделить этот узел функцией select.
			//				- Завершить работу обработчика.
			if(!n.state.selected && numOfSelectedNodes == 0) {
				t.selection.select(n.id);
				return;
			}

			//F9.5.5.	Если щелкнутый пользователем узел не выделен, и F9.5.1 > 0, то:
			//				- Развыделить все узлы функцией unselectAll
			//				- Выделить этот узел функцией select.
			//				- Завершить работу обработчика.
			if(!n.state.selected && numOfSelectedNodes > 0) {

				t.selection.unselectAll();
				t.selection.select(n.id);
				return;
			}

		}
			
		//F9.6.	Проверить, если во время щелчка была нажата клавиша-модификатр
		//			CTRL, то:
		if( event.ctrlKey &&
				!event.shiftKey &&
				!event.altKey &&
				!event.metaKey) {

			//F9.6.1.	Если щёлкнутый пользователем узел выделен, то:
			// 				- С помощью функции unselect развыделить его.
			//				- Завершить работу обработчика.
			if(n.state.selected) {
				t.selection.unselect(n.id);
				return;
			}

			//F9.6.2.	Если щёлкнутый пользователем узел не выделен, то:
			// 				- С помощью функции select выделить его.
			//				- Завершить работу обработчика.
			if(!n.state.selected) {
				t.selection.select(n.id);
				return;
			}


		}

	};
	

//[-----OUT. Выходы модуля]

//OUT1.	Вернуть ссылку на объект selection с функционалом модуля
return selection;


});		// конец определения модуля с помощью define












