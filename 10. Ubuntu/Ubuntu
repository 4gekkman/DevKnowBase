////==========================================================////
////																													////
////             Методичка по GNU/Linux - Ubuntu						  ////
////																													////
////==========================================================////
//// 			        		 		   ////
//// 			    Ссылки  			 ////
//// 			         				   ////
////=========================////


	> Официальный сайт Ubuntu:
	      http://www.ubuntu.com/

  > Сайт русскоязычного сообщества Ubuntu:
        http://www.ubuntu.ru/

	> Статья на wiki про Ubuntu:
	      https://ru.wikipedia.org/wiki/Ubuntu

  > Ссылки на учебные материалы на оф.сайте (En):
        https://help.ubuntu.com/community/ExternalGuides

  > Пользовательское руководство по Ubuntu:
        http://help.ubuntu.ru/wiki/руководство_по_ubuntu_desktop_14_04/введение

  > Пользовательская документация Ubuntu по разделам:
        http://help.ubuntu.ru/wiki/главная

  > Cheet Sheets:
        1. http://files.fosswire.com/2007/08/fwunixref.pdf
        2. http://forum.ubuntu.ru/?topic=124998.0   (часто используемые команды)

  > Горячие клавиши Unity:
        http://help.ubuntu.ru/wiki/горячие_клавиши_в_unity

  > "Введение в POSIX'ивизм", Алексей Федорчук, 2005
    (живым и доходчивым языком объясняются основы UNIX-подобных систем)
        http://www.linuxcenter.ru/lib/books/posixbook/


////==========================================================////
//// 			        		 		     ////
//// 			   Оглавление  		   ////
//// 			         				     ////
////===========================////


  А. Прикладная информация

    А1. Моя библиотека команд и горячих клавиш
    А2. Горячие клавиши Unity
    А3. Где искать документацию по Linux
    А4. Установка Ubuntu
    А5. Работа с Ubuntu через VirtualBox
    А6. Работа с виртуальными терминалами
    А7. Работа с командами в окне терминала
    А8. Оболочка bash
    А9. Как заставить новые окна в Ubuntu открываться, как укажешь
    А10. Файлы и каталоги: необходимые для работы основы
    А11. Структура каталогов в Ubuntu
    А12. Работа с процессами
    А13. Сеть
    А14. Управление пользователями, группами, паролями
    А15. Логи
    А16. Управление программами и пакетами (APT)
    А17. Автозапуск bash-скриптов при старте системы
    А18. Дата, время, NTP-сервер, NTP-демон

  Б. Теоретические основы

    Б1. История POSIX-совместимых ОС
    Б2. Операционная система, ядро ОС, ОС Linux, дистрибутивы
    Б3. Терминалы
    Б4. Пользователи
    Б5. Процессы
    Б6. Файлы
    Б7. Физика файловых систем
    Б8. X Window System

  В. Настройка сервера на DigitalOcean

    В1. Общие сведения про DigitalOcean
    В2. Инструкция по созданию нового дроплета на DigitalOcean
    В3. Cоздание SSH-ключа на DigitalOcean, и подключение к дроплету с помощью PuTTY
    В4. Инструкция по подготовке сервера к работе
    B5. Работа с Iptables, настройка фаервола для MySQL
    В6. Как смонтировать ФС удалённого Linux в ФС Windows
    В7. Настройка DNS на DigitalOcean
    В8. Настройка электронной почты


////==========================================================////
//// 			        		 		                    ////
//// 			   А. Прикладная информация  		    ////
//// 			         				                    ////
////==========================================////

//--------------------------------------------//
// А1. Моя библиотека команд и горячих клавиш //
//--------------------------------------------//
//                     //
//    Подоглавление    //
//                     //
//---------------------//


    L. Ссылки и часто используемые программы
    ----------------------------------------

      L1. Чужие подборки программ
      L2. Часто используемые программы


    P. Программы
    ------------

      P1. Выполнение команд от имени другого пользователя
      P2. Каталоги и файлы
      P3. Жесткие и символьные ссылки
      P4. Размер дисков и файлов
      P5. Поиск файлов
      P6. Права доступа к файлам/каталогам
      P7. Процессы
      P8. Программы для мониторинга системы, ресурсов, сети и т.д.
      P9. Выполнение программ в фоновом режиме
      P10. Команды для работы с локальными и глобальными переменными оболочки bash
      P11. Работа с демонами
      P12. Работа с демоном cron
      P13. Определение состояния сети
      P14. Работа с SSH
      Р15. Управление пользователями, группами, паролями
      Р16. Журналирование (logs)
      P17. Управление программами и пакетами (APT)
      P18. Время, дата, NTP


    H. Горячие клавиши
    ------------------

      H1. Текстовые и графические виртуальные терминалы
      H2. Окно терминала
      H3. Less: просмотр и редактирование txt-файлов
      H4. Nano: просмотр и редактирование txt-файлов
      H5. Горячие клавиши bash


    T. Механизмы подстановки, шаблоны и прочее
    ------------------------------------------

      T1. Механизмы подстановки в bash
      T2. Шаблоны выполнения программ в bash
      T3. Шаблоны переадресации ввода/вывода программ в bash
      T4. Важнейшие оболочковые переменные bash


    X. Команды, не попавшие в другие разделы
    ----------------------------------------


//--------------------------------------------//


  L1. Чужие подборки программ
  ---------------------------

    - http://www.freesource.info/wiki/Stat'i/KratkoOboVsjom/Linux#h1590-4
    - http://rute.2038bug.com/index.html.gz
    - http://ryanstutorials.net/linuxtutorial/
    - http://linuxcommand.org/lc3_learning_the_shell.php
    - http://ss64.com/bash/


  L2. Часто используемые программы
  ----------------------------------------

    - clear                         | полностью очистить окно терминала
    - man [команда]                 | показывает справку о приложении [команда]
    - poweroff                      | выключить компьютер


  P1. Выполнение команд от имени другого пользователя
  ---------------------------------------------------

    su -l [user]      | временно перейти в режим пользователя [user] (потребуется ввести пароль)
    sudo su -l        | временно перейти в режим администратора (пароль не требуется)

    sudo [программа]  | выполнить программу [программа] с root-правами, если это разрешено в sudoers
    gksudo [команда]  | выполнить X-программу [программа] с root-правами, если это разрешено в sudoers
    sudo -s           | включить режим "применять sudo ко всем последующим командам" (без смены домашнего каталога на /root)
    sudo -s -H        | включить режим "применять sudo ко всем последующим командам" (со сменой домашнего каталога на /root)

    visudo            | настройка конфига команды sudo
    exit / CTRL + D   | вернуться в обычный режим из любого другого


  P2. Каталоги и файлы
  --------------------

    pwd                     | показать абсолютный путь к текущему каталогу
    cd [путь]               | изменить текущий каталог на [путь]
      cd                      - перейти в домашний каталог
      cd -                    - вернуться в предыдущий текущий каталог
      cd ..                   - перейти в родительский для текущего каталог
    ls                      | посмотреть содержимое текущего каталога (сортируются по имени автоматом)
      -a                      - показать в т.ч. и скрытые файлы (начинающиеся с точки)
      -l                      - показать файлы в столбик и с доп.инфой (права и т.д.)
      -t                      - отсортировать вывод по времени послед.изменения
      -S                      - отсортировать вывод по размеру
      -X                      - отсортировать вывод по расширению
      -r                      - сортировать в обратном порядке
      ls -lR | less         - рекурсивно просмотреть содержимое текущего каталога, включая скрытые файлы, через less
    du [путь]               | посмотреть размер файла/каталога по адресу [путь] в килобайтах
      -h                      - отображать размер в человеко-понятных единицах
      du -hr *                - посмотреть размер всех файлов и папок в текущем каталоге
    touch [путь]            | создать файл по адресу [путь]
    >[путь]                 | создать файл по адресу [путь]
    mkdir [путь]            | создать каталог по адресу [путь]
    rm [путь]               | удалить файл/каталог по адресу [путь]
      -f                      - удалить файл, не смотря ни на что
      -rf                     - удалить, даже если каталог не пуст
    rmdir [путь]            | удалить каталог по адресу [путь], но лишь если он пуст
    cp [что] [куда]         | скопировать файл из [что] в [куда]
      cp -r [что] [куда]    | скопировать каталог из [что] в [куда]
      cp -a [что] [куда]    | скопировать каталог из [что] в [куда], сохранив инфу о правах и времени посл.изменения
    mv [что] [куда]         | переименовать/переместить файл/каталог [что] в [куда]


  P3. Жесткие и символьные ссылки
  -------------------------------

    ln [файл] [ссылка]      | создать жёсткую ссылку с именем [ссылка] на [файл]
      -s [файл] [ссылка]      - создать символьную ссылку с именем [ссылка] на [файл]


  P4. Размер дисков и файлов
  --------------------------

    baobab                  | (в gnome) графический интерфейс дерева каталогов с размерами дисков и файлов
    df                      | посмотреть размеры всех сегментов файловой системы в байтах
      -h                      - ...в человекопонятных единицах
      -h [путь]               - узнать, в каком сегменте ФС находится файл [путь]
    du [путь]               | посмотреть размер файла/каталога по адресу [путь] в килобайтах
      -h                      - отображать размер в человеко-понятных единицах
      du -hr *                - посмотреть размер всех файлов и папок в текущем каталоге


  P5. Поиск файлов
  ----------------

    which [команда]         | в PATH ищет абсолютный путь к приложению [команда]
    whereis [команда]       | ищет информацию о расположении файлов приложения [команда]
      -b                      - ищет только исполняемые файлы
      -m                      - ищет только файлы руководства
      -s                      - ищет только исходные файлы
    locate [паттерн]        | поиск абс.путей, в которые входит [паттерн] (м.б. рег.выр.), быстро (по индексу)
      -b                      - поиск по имени файла, а не по абс.пути
      -w                      - поиск по абс.пути, включающем имя файла
      -c                      - вместо найденных абс.путей, вернёт цифру - кол-во найденных результатов
      -i                      - регистронезависимый поиск
      -regex                  - рассматривать паттерн, как рег.выражение
    find [паттерн]          | искать файл по имени, содержащему [паттерн], в текущем и всех каталогах потомках
      -name                   - искать по имени файла, при использовании подстановочных образцов параметр заключается в кавычки
      -type                   - тип искомого: f=файл, d=каталог, l=ссылка (link), p=канал (pipe), s=сокет
      -user                   - владелец: имя пользователя или UID
      -group                  - владелец: группа пользователя или GID
      -perm                   - указываются права доступа
      -size                   - размер: указывается в 512-байтных блоках или байтах (признак байтов — символ «c» за числом)
      -atime                  - время последнего обращения к файлу
      -ctime                  - время последнего изменения владельца или прав доступа к файлу
      -mtime                  - время последнего изменения файла
      -delete                 - удалять найденные файлы
      -ls                     - генерирует вывод как команда ls -dgils
      -d                      - начинать поиск с самых глубоких уровней вложенности, а не с корня каталога
      -maxdepth               - максимальный уровень вложенности для поиска. «-maxdepth 0» ограничивает поиск текущим каталогом
      -maxdepth 0             - искать только в текущем каталоге
      -regex                  - искать по имени файла используя ргулярные выражения
      -P                      - не разворачивать символические ссылки (поведение по умолчанию)
      -L                      - разворачивать символические ссылки
      -exec command {} \;     - выполняет над найденным файлом указанную команду; обратите внимание на синтаксис
    grep [рег.выр] [где]    | искать паттерн [рег.выр] в текстовых файлах [где]


  P6. Права доступа к файлам/каталогам
  ------------------------------------

    chmod [права] [файл]    | изменить права доступа к файлу
    chown [польз] [файл]    | [только root] изменить владельца файла [файл] на пользователя [польз]
    chgrp [групп] [файл]    | [только root или владелец] изменить группу файла [файл] на пользователя [групп]


  P7. Процессы
  ------------

    ps                    | вывести список проц-ов текущ.поль-ля (но лишь запущенных через окно терминала)
      -e                    - вывести список ВСЕХ проц-ов
      -ejH                  - вывести дерево процессов
      -U root -u root u     - вывести список всех действующих процессов админа
    nice [программа]      | запустить [программа] с приоритетом 10
      -n 19 [программа]     - запустить [программа] с приоритетом 19
    renice [PR] [PID]     | изменить приоритет исполняющегося процесса с id == [PID] на [PR]
      [PR] -u [польз]       - изменить приоритеты всех исполняющихся процессов пользователя [польз] на [PR]
    pidof [программа]     | вывести список id через пробел исполняющихся процессов программы [программа]
    fuser [файл]/[кат]    | вывести список id через пробел процессов, обращающихся к файлу [файл] или каталогу [кат] (программ, запущенных в каталоге)
    pstree                | вывести иерархическое дерево процессов
    kill [PID]            | завершить процесс с id == [PID]
    killall [программа]   | завершает все исполняющиеся процессы, относящиеся к программе [программа].
    xkill                 | щёлкнуть мышкой по окну процесса, который надо завершить


  P8. Программы для мониторинга системы, ресурсов, сети и т.д.
  ------------------------------------------------------------
    top                   | вывести обновляемый раз в 2 сек.список процессов, отсортированный по потреблению ресурсов системы
    htop                  | приятная альтернатива команде top (пакет htop), красивее, имеет доп.функционал (поиск, сортировка, nice, kill)
    gnome-system-monitor  | графическая альтернатива для top в gnome
    iotop                 | аналог top, но отслеживается нагрузка на жесткие диски
    iftop                 | наблюдение за трафиком в сети в режиме online
    vmstat [сек]          | выводить статистику ресурсов системы, обновляющуюся каждые [сек] секунд
    apachetop             | мониторинг веб-сервера apache
    mytop                 | мониторинг сервера mysql
    iptstate              | мониторинг ip-соединений (IPTState знает, кто к вам подключился, и откуда, и какой объем данных шлет)
    runlevel              | узнать текущий уровень выполнения системы


  P9. Выполнение программ в фоновом режиме
  ----------------------------------------
    [программа] &           | выполнить [программа] в фоновом режиме
    CTRL + Z, bg            | переключить режим выполня-ся в приор.режиме программы с приор. на фоновый
    CTRL + Z, fg            | поставить выполняющ-ся в приор.режиме программу на паузу, а затем продолжить её выполнение также в приор.режиме


  P10. Команды для работы с локальными и глобальными переменными оболочки bash
  ----------------------------------------------------------------------------
    a=3             | краткий способ записи let, a - локальная переменная
    declare a=3     | присваивает локальной переменной a значение 3 (как let)
    declare -x a=3  | присваивает локальной переменной a значение 3 (как export)
    export          | отображает все глобальные переменные
    export a        | делает переменную a глобальной
    export a=3      | присваивает глобальной переменной a значение 3
    let a=3         | присваивает глобальной переменной a значение 3
    local a=3       | делает переменную a локальной
    printenv        | синоним export, отображает все локальные переменные
    set             | отображает все переменные (и локальные, и глобальные)
    unset a         | удаляет переменную a


  P11. Работа с демонами
  ----------------------
    /etc/init.d             | посмотреть неполный список демонов

    service [имя] start     | запустить вручную демон [имя]
    start [имя]             | запустить вручную демон [имя]

    service [имя] stop      | остановить вручную демон [имя]
    stop [имя]              | остановить вручную демон [имя]

    service [имя] reload    | перезапуск демона [имя] вручную
    service [имя] restart   | перезапуск демона [имя] вручную
    reload [имя]            | перезапуск демона [имя] вручную
    restart [имя]           | перезапуск демона [имя] вручную

    sudo sysv-rc-conf       | настройка работы демонов на разных уровнях работы системы (надо установить однимённый пакет)


  P12. Работа с демоном cron
  --------------------------

    crontab -e                          | отредактировать файл crontab
    run-parts --test /etc/cron.hourly   | посмотреть список ежечасно запускаемых cron'ом скриптов
    run-parts --test /etc/cron.daily    | посмотреть список ежедневно запускаемых cron'ом скриптов
    run-parts --test /etc/cron.weekly   | посмотреть список еженедельно запускаемых cron'ом скриптов
    run-parts --test /etc/cron.monthly  | посмотреть список ежемесячно запускаемых cron'ом скриптов


  P13. Определение состояния сети
  -------------------------------

    ifconfig            | возвращает список работающих сетевых интерфейсов.
    ping [хост]         | каждую секунду отсылает пакет на [хост], и получает (или не получает) ответ
      -c [кол-во]         - посылает ровно [кол-во] пакетов, и завершает работу
    traceroute [хост]   | отслеживает путь пакета на всех отрезках до [хост]
    mtr [host]          | комбинация traceroute + ping
    gnome-nettool       | это X-программа для Gnome, может заменить все прочие программы из этого раздела


  P14. Работа с SSH
  -----------------

    ssh [логин]@[хост]                                    | аутентифицироваться на [хост] (его ip) как [логин]
    ssh [логин]@[хост] [команда]                          | --//--, выполнить команда, завершить работу ssh
      -X                                                    - включить X11 forwarding
    scp [[user1]@host1]:[file1] [[user2]@host2]:[file2]   | скопировать файл/каталог с host1 на host2 через SSH
      -r                                                    - использовать при копировании каталогов


  Р15. Управление пользователями, группами, паролями
  --------------------------------------------------

    Пользователи
    ------------

      w               | информация обо всех залогиненых в системе пользователях
      who             | --//--, что и w, но без имён столбцов
      users           | вывести имена залогиненых пользователей
        [имя]           - для пользователя [имя]
      groups          | вы список имён групп, в которых состоит текущий пользователь
        [имя]           - для пользователя [имя]

      id              | вывести id текущего пользователя и всех групп, в которых он состоит
        [имя]           - для пользователя [имя]
      whoami          | вывести имя текущего пользователя
      who am i        | вывести имя, псевдотерминал, дату аутентификации текущего пользователя

      useradd -D      | посмотреть настройки по умолчанию при создании пользователя
      useradd [имя]   | создать нового пользователя без учета /etc/adduser.conf
      adduser [имя]   | [Ubuntu] создать нового пользователя с учетом /etc/adduser.conf
        -m              - Создать домашний каталог пользователя, если он не существует (по умолчанию он не создаётся)
        -b              - Где создать дом.кат.пользователю (по умолчанию, /home)
        -d              - Название дом.кат. (по умолчанию, имя пользователя)
        -e              - Дата, когда пользователь будет отключен (гггг-мм-дд)
        -g              - Первичная группа пользователя (по умолчанию, создаётся новая с именем пользователя)
        -G              - Список, где ещё будет состоять пользователь
        -s              - Оболочка пользователя по умолчанию (по умолчанию, /bin/sh)
        -u              - Вручную задать UID пользователю

      userdel [имя]   |
      deluser [имя]   |
        -f              - принудительно удалить поль-ля, даже если он сейчас в системе
        -r              - удалить в т.ч. и домашний каталого пользователя

      usermod [что] [кому]  | изменить аккаунт пользователя
        -m                    - [только вместе с -d] переместить содержимое старого дом.кат. в новый
        -d                    - изменить дом.кат. (если указан -m, то содержимое старого дом.кат. переместится в новый)
        -s                    - изменить оболочку по умолчанию пользователя
        -u                    - установить новый uid пользователю
        -l                    - изменить имя пользователя (имя дом.кат. не меняется)
        -g                    - изменить id или имя первичной группы пользователя
        -G                    - изменить список доп.групп через запятую, в которых числится пользователь

      passwd          | изменить пароль текущего пользователя
      passwd [имя]    | изменить пароль пользователя [имя]
        -d              - удалить пароль пользователю [имя]
        -e              - сделать пароль устаревшим пользователю [имя] (при след.входе он должен будет его сменить)
        -i              - заблокировать пользователя через N дней
        -l              - заблокировать пользователя
        -u              - разблокировать пользователя

      faillog -u [имя]  | показать инфу по неудачным попыткам входа пользователя [имя]
        -a                - инфа по всем пользователям
        -m [раз]          - для [имя] задать MAX число неуд.попыток, после чего [имя] блокируется

    Группы
    ------

      groupadd        | создать новую группу без учета /etc/addgroup.conf
      addgroup        | [Ubuntu] создать новую группу с учетом /etc/addgroup.conf
        -g              - установить собственный gid
        -p              - установить пароль группы
        -r              - создать системную группу

      groupmod        | изменить имя, gid или пароль группы
        -g              - изменить gid
        -n              - изменить имя
        -p              - изменить пароль


      delgroup [имя]  | удалить группу [имя] без учета /etc/addgroup.conf
      groupdel [имя]  | [Ubuntu] удалить группу [имя] с учетом /etc/addgroup.conf


    Прочее
    ------

      chmod       | изменить биты доступа к файлу
      chgrp       | изменить групповую отнесённость файла
      chown       | передать файл другому владельцу
      chsh        | изменить стандартную оболочку, применяемую при работе с данным пользователем
      newgrp      | изменяет активную группу определенного пользователя
      newusers    | создаёт несколько новых пользовательских учетных записей


  Р16. Журналирование (logs)
  --------------------------

    dmesg                 | просмотреть лог ядра


  P17. Управление программами и пакетами (APT)
  --------------------------------------------

    apt-cdrom           | добавить CD в качестве репозитория в sources.list
    apt-key             | настроить общедоступный ключ APT
      apt-key add [n]         | добавление ключа в базу доверенных
      apt-key del [n]         | удаление ключа из базы доверенных
    apt-get             | осуществление управления пакетами
      apt-get update          | загрузить новейшую инфу (описания пакетов) из репозиториев
      apt-get install [n]     | установить пакет с именем [n]
      apt-get remove [n]      | удалить пакет с именем [n]
      apt-get autoremove      | удалить "осиротевшие" пакеты (пакеты-зависимости, которые больше никем не используются)
      apt-get dist-upgrade    | обновить все пакеты и их зависимости (установить новые/удалить старые если надо)
      apt-get upgrade         | обновить все пакеты и их зависимости (но не устанавливать новые/не удалять старые)
      apt-get source [n]      | установить пакет из исходного кода, в каталог [n]
    tasksel install [g] | установить группу пакетов, имя которой [g]
    apt-cache           | узнать данные о доступных/установленных пакетах
      apt-cache search [n]    | искать пакеты по содержанию [n] в имени и названии
      apt-cache depends [n]   | показать список зависимостей пакета [n]
      apt-cache rdepends [n]  | показать список обратных зависимостей пакета [n]
      apt-cache show [n]      | просмотреть описание пакета [n]
      apt-cache dump > ~/apt  | список установленных пакетов (лучше загружать в файл, ибо велик)

      apt-cache pkgnames      | список всех доступных пакетов
      apt-cache pkgnames [n]  | искать пакеты, имя которых начинается с [n]
      apt-cache showpkg [n]   | просмотреть список зависимостей пакета
      apt-cache stats         | показать полную статистику о кэше apt


  P18. Время, дата, NTP
  ---------------------

    date                      | узнать дату и время
    timedatectl                 - тоже самое
    sudo hwclock --show         - тоже самое

    ntpdate -s ntp.ubuntu.com | синхронизировать время системы с NTP-сервером
    sudo ntpq -p              | просмотр статистики работы ntp-демона (периодически корректирует время по NTP-серверу)

  H1. Текстовые и графические виртуальные терминалы
  ------------------------------------------------

    - Ctrl + Alt + F[число]         | переключение между виртуальными терминалами
    - ALT + F[1 .. 6]               | переключение между текстовыми виртуальными терминалами
    - ALT + →, ALT + ←              | переключение между текстовыми виртуальными терминалами
    - SHIFT + PgUp, SHIFT + PgDown  | пролистывание текста вверх/вниз в текстовых виртуальных терминалах
    - CTRL + ALT + DEL              | перезагрузка Ubuntu из текстового виртуального терминала
    - gpm                           | запустить "сервер мыши" (мышь в текстовой консоли заработает)


  H2. Окно терминала
  ------------------

    - CTRL + a    | поставить курсор в начало строки
    - CTRL + e    | поставить курсор в конец строки
    - CTRL + c    | отменить работу текстовой программы
    - CTRL + k    | удалить часть строки под курсором и правее
    - CTRL + y    | вставить удалённый с помощью ctrl + k текст
    - CTRL + z    | остановить программу (можно возобновить с помощью fg или bg)
    - Tab         | автозавершение названия файла или команды
    - ↑ / ↓       | перелистывание команд, введённых в окно терминала ранее
    - Enter       | выполнить введённую команду


  H3. Less: просмотр и редактирование txt-файлов
  ----------------------------------------------

    less [файл]           | открыть файл командой less
    - h                     | показать справку по всем горячим клавишам
    - ↑↓←→                  | перемещение по документу
    - home, end             | курсор в начало/конец документа
    - g, SHIFT + g          | курсор в начало/конец документа
    - f                     | пролистать на 1 страницу вниз
    - b                     | пролистать на 1 страницу вниз
    - /[строка поиска]Enter | поиск вперед от курсора
    - ?[строка поиска]Enter | поиск назад от курсора
    - n                     | повтор поиск вперед (next)
    - Shift + n             | повтор поиска назад
    - q                     | выйти из less


  H4. Nano: просмотр и редактирование txt-файлов
  ----------------------------------------------

    nano [файл]           | открыть файл командой nano
    - CTRL + G              | показать справку по всем горячим клавишам
    - esc + [клавиша]       | эмуляция ALT + [клавиша]
    - esc + esc + [клавиша] | эмуляция CTRL + [клавиша]
    - ↑↓←→                  | перемещение по документу
    - home, end             | курсор в начало/конец строки
    - PgUp, PgDn            | страница вверх/вниз
    - CTRL + SPACE          | курсор на 1 слово вперёд
    - ALT + SPACE           | курсор на 1 слово назад
    - ALT + \ (или |)       | курсор в начало документа
    - ALT + / (или ?)       | курсор в конец документа
    - ALT + 0               | до первой пустой строки вниз
    - ALT + 9               | до первой пустой строки вверх


  H5. Горячие клавиши bash
  ------------------------

    ↑ ↓                 | переключение последних введенных команд
    ← →                 | передвинуть курсор назад/вперед
    Home, End           | переместить курсор в начало/конец строки
    CTRL + A, CTRL + F  | переместить курсор в начало/конец строки
    ALT + B, ALT + F    | переместить курсор на 1 слово вперед/назад
    Backspace, Delete   | удалить 1 символ слева/справа от курсора
    ALT + D             | удалить слово
    CTRL + K            | удалить текст до конца строки
    CTRL + Y            | вставить последний удалённый CTRL + D текст
    CTRL + T            | поменять местами 2 предыдущие стрки
    ALT + T             | поменять местами 2 предыдущих слова
    TAB                 | автодополнение имени команды/файла
    CTRL + I            | [не работает в X] погасить экран
    CTRL + R            | найти ранее введенные команды
    ALT + .             | вставить последний примененный параметр
    CTRL + _            | [не работает в X] отменить последнее изменение


  T1. Механизмы подстановки в bash
  --------------------------------
    ?                 | любой 1 символ
    *                 | от 0 и более любых символов
    **                | любые файлы и каталоги, в т.ч. из всех подкаталогов
    [abc]             | 1 из указанных в скобках символов
    [a-f]             | 1 из указанного в скобках диапазона символов
    [!abc]            | любой символ, кроме указанных в скобках
    [^abc]            | любой символ, кроме указанных в скобках
    ~                 | ссылка на домашний каталог
    .                 | ссылка на текущий каталог
    ..                | ссылка на родительский для текущего каталог
    ab{1,2,3}         | вернёт ab1 ab2 ab3
    a{1..4}           | вернёт a1 a2 a3 a4
    $[3*4]            | вернёт 12 (производит арифметич.вычисление)
    `команда`         | замена команды результатом её выполнения
    $(команда)        | замена команды результатом её выполнения
    Команда "символ"  | отмена интерпретации любых спец.символов, кроме $
    Команда 'символ'  | отмена интерпретации любых спец.символов, в т.ч. $


  T2. Шаблоны выполнения программ в bash
  --------------------------------------
    [команда1] ;  [команда 2]   | выполняет команды одна за другой
    [команда1] && [команда 2]   | выполняет команду2, если команда 1 была выполнена успешно
    [команда1] || [команда 2]   | выполняет команду2, если команда1 возвращает ошибку
    [команда] &                 | запускает команду в фоновом режиме
    [команда1] &  [команда 2]   | запускает команду1 в фоновом режиме, команду 2 - на виду
    ([команда1] ; [команда 2])  | выполняет обе команды в одной и той же оболочке


  T3. Шаблоны переадресации ввода/вывода программ в bash
  ------------------------------------------------------
    [команда]   > /dev/null       | переадресация вывода [команда] в никуда (чтобы не мешался в окне терминала)
    [команда]   >   [файл]        | вывод в файл (старое содержимое удаляется)
    [команда]   <   [файл]        | файл в стандартный ввод
    [команда]   2>  [файл]        | ошибки в файл (старое содержимое удаляется)
    [команда]   >&  [файл]        | вывод и ошибки в файл (старое содержимое удаляется)
    [команда]   &>  [файл]        | вывод и ошибки в файл (старое содержимое удаляется)
    [команда]   >>  [файл]        | вывод в файл (дописывает в конце файла)
    [команда]   &>> [файл]        | вывод и ошибки в файл (дописывает в конце файла)
    [команда1]  |   [команда2]    | вывод команды №1 на ввод команды №2
    [команда1]  |   tee [файл]    | вывод в окно терминала, и одновременно в файл


  T4. Важнейшие оболочковые переменные bash
  -----------------------------------------
    printenv | sort         | посмотреть все оболочковые переменные
    BASH                    | путь к файлу bash
    HOME                    | путь к домашнему каталогу
    LOGNAME                 | логин польозвателя
    HOSTNAME                | хост-имя компьютера
    MAIL                    | путь к каталогу, в котором сохраняется входящая почта
    PWD                     | путь к текущему каталогу
    OLDPWD                  | путь к предыдущему использовавшемуся каталогу
    PATH                    | список каталогов, в которых bash ищет команду, если её имя задано без пути
    PS1                     | шаблон "приглашения №1" - ожидание ввода команды
    PS2                     | шаблон "приглашения №2" - ввод многострочной команды (на >= 2 сроках)
    PS3                     | шаблон "приглашения №3" - когда нужно сделать выбор в операторе select
    PS4                     | шаблон "приглашения №4" - при отладке скриптов, выводится в начале строки перед исполняющейся командой
    PROMPT_COMMAND          | скрипт, который будет выполняться перед каждым выводом приглашения №1


  X. Команды, не попавшие в другие разделы
  ----------------------------------------

    wget
    curl
    rsync
    mirror
    sitecopy
    nc -zv 127.0.0.1 80     | проверить доступность ресурса по IP и PORT




А2. Горячие клавиши Unity

  --------------------------------------
  Подоглавление:

    1) Ссылки
    2) Наиболее часто используемые
    3) Панель запуска
    4) Переключение
    5) Главное меню
    6) Рабочие места (столы)
    7) Окна
    8) Верхнее меню приложения
    9) Рабочие места

  --------------------------------------

  1) Ссылки
  ---------
    help.ubuntu.ru/wiki/горячие_клавиши_в_unity

  2) Наиболее часто используемые
  ------------------------------

    Ctrl + Alt + T          | Открыть окно терминала
    Super + S               | Посмотреть все рабочие столы (Expo Mode)

    Ctrl + Super + ↑        | Развернуть окно на весь экран
    Ctrl + Super + ↓        | Вернуть исходный размер экрана (не на весь экран)
    Ctrl + Super + ← →      | Развернуть окно на всю левую/правую половину экрана

    Alt + Tab               | Переключиться между приложениями
    Alt + `                 | Переключить окна текущего приложения

  3) Панель запуска
  -----------------
    Super (держать)         | Посмотреть номера программ на панели запуска (ПЗ)
    Alt + F1                | Вкл/выкл навигацию по ПЗ стрелочками клавиатуры
    Super + Tab             | Нажимая tab, выбрать и запустить программу с ПЗ
    Super + 0 ... 9         | Запустить программу с указанным номером с ПЗ
    Super + shift + 0 ... 9 | Запустить ещё экземеляр программы с указанным номером с ПЗ
    Super + T               | Открыть корзину

  4) Переключение
  ---------------
    Alt + Tab               | Переключиться между приложениями
    Alt + `                 | Переключить окна текущего приложения
    ← →                     | Переместить фокус

  5) Главное меню
  ---------------
    Super (не держать)      | Открыть главное меню
    Super + A               | Открыть подменю "Приложения"
    Super + F               | Открыть подменю "Файлы"
    Super + M               | Открыть подменю "Музыка"
    Super + V               | Открыть подменю "Видео"
    Ctrl + Tab              | Переключаться между линзами
    ← → ↑ ↓                 | Переместить фокус

  6) Рабочие места (столы)
  ------------------------
    Super + S                     | Посмотреть все рабочие столы (Expo Mode)
    Ctrl + Alt + ← → ↑ ↓          | Переключение между рабочими столами
    Shift + Ctrl + Alt + ← → ↑ ↓  | Переместить окно на другое рабочее место

  7) Окна
  -------
    Super + W               | Показать все окна
    Ctrl + Super + D        | Свернуть все окна
    Ctrl + Super + ↑        | Развернуть окно на весь экран
    Ctrl + Super + ↓        | Вернуть исходный размер экрана (не на весь экран)
    Ctrl + Super + ← →      | Развернуть окно на всю левую/правую половину экрана
    Alt + F4                | Закрыть текущее окно
    Alt + space             | Контекстное меню возможных действий с окном
    Ctrl + Alt + Num        | Разместить окно в указанной части экрана
    Alt + левая кнопка      | Перетащить окно
    Alt + средняя кнопка    | Изменить размер окна

  8) Верхнее меню приложения
  --------------------------
    Alt (не держать)        | Открыть строку поиска по меню приложения
    Alt (держать)           | Показать меню приложения (но не отдавать ему фокус)
    Alt + F10               | Показать меню приложения (и отдать ему фокус)
    ← →                     | Перемещение по меню приложения, имеющему фокус

  9) Рабочие места
  ----------------

    - В Unity есть встроенная фича "Рабочие места".
    - Вкл/выкл её можно по адресу:
        "Настройки" -> "Оформление" -> "Режим" -> галочка "Задействовать рабочие места".
    - Горячие клавиши для работы с "рабочими местами" см. выше.
    - Основная по полезности фишка этой фичи при работе с 2-мя экранами:

      1) Допустим, изображение выводится на 2 экрана одновременно.
      2) Изображения на этих 2-х экранах не пересекается.
      3) Допустим, у нас 1 экран включен (ноут), а 1 выключен (большой).
      4) При запуске приложения, его окно может появиться и там, и там.
      5) Если оно появляется на выключенном экране, как его оттуда перетащить на включенный?
      6) Нажимаем - Super + S - включается Expo Mode - мы видим рабочие области обоих экранов.
      7) Просто перетаскиваем мышью окно из области выключенного экрана в область включенного.


А3. Где искать документацию по Linux

  --------------------------------------
  Подоглавление:

    - Предисловие
    - Список важнейших источников документации по Linux

  --------------------------------------

  > Предисловие
    - По Linux имеется практически необъятное кол-во документации.
    - Частично она поставляется вместе с системой, частично лежит в интернете.
    - Эксперты могут глянуть исходный код, который, как правило, хорошо документирован.
    - Подавляющая часть всей документации на английском языке.

  > Список важнейших источников документации по Linux

    # Онлайновая справка
      - Почти все программы, имеющие графич.интерфейс, имеют онлайновую спрвку.
      - Чтобы открыть её, когда программа в фокусе, нужно нажать F1.
      - Если не работают, то, возможно, не установлены файлы справки для неё.

    # Man и info
      - Особенно полезны при работе с текстовыми программами.
      - Man [имя] или info [имя] обычно выводят справку по программе [имя].
      - Эта справка обычно содержит точное описание программы, синтаксическую справку.

    # Поисковики
      - Поисковик, как обычно - один из важнейших источников информации.

    # Документация по пакетам
      - В Linux программы устанавливаются в виде пакетов.
      - Пакет часто содержит не только саму программу, но и документацию к ней.
      - Эта документация в Ubuntu устанавливается в следующий каталог:
          /usr/share/doc/[имя пакета]
      - Что делать, если нужна док-ция по команде, но неизвестно, из какого она пакета?
      - В первую очередь узнать точное имя файла этой команды:
          which -a [имя командв]    | вернет [имя файла]
      - Выяснить, к какому пакету относится этот файл.
      - В Ubuntu используются формат пакетов DPKG. Так что:
          dpkg -S [имя файла]

    # Проект Linux Documentation
      - The Linux Documentation Project (LDP), www.tldp.org
      - Ставит задачу создать MAX полную документацию по Linux.
      - Многие тексты LDP не поддерживаются, и устаревают.
      - Все больше проектов переносят документацию в wiki-формат.
      - Чтобы сообщество могло принимать участие в доработке документации.

    # Документация ядра Linux
      - В ней содержится много инфы, связанной с оборудованием.
      - Она является частью кода ядра.
      - Документация наиболее актуальной версии ядра находится здесь:
          http://www.kernel.org/doc/Documentation

    # RFC
      - RFC - Request For Comment - Запрос Комментариев.
      - Так обозначаются документы, подробно описывающие разные протоколы:
          В частности: TCP, IP, FTP, PPP и т.д.
      - Эти источники содержат, как правило, сложную техническую информацию.
      - Хорошей подборкой таких документов является сайт:
          http://www.faqs.org/rfcs


А4. Установка Ubuntu

  --------------------------------------
  Подоглавление:

    - Предисловие
    - Пошаговая инструкция по установке

  --------------------------------------

  > Предисловие

  > Пошаговая инструкция по установке

    1) Скачать требуемый образ Ubuntu с оф.сайта
      - http://www.ubuntu.com/download
      - Можно выбрать Desktop- или Server-вид дистрибутива.

    2) Подготовить загрузочную USB-флешку к установке с неё Ubuntu
      - Процесс подробно описан на оф.сайте:
          http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows
      - Качаем программу Pen Drive Linux's USB Installer отсюда:
          http://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/#button
      - Вставляем флешку в USB.
      - Запускаем программу, указываем образ с Ubuntu и диск USB, и создаём загрузочный USB.

    3) Запланировать, на какой диск будем устанавливать Ubuntu
      - Например, есть следующие варианты:
        - Новый отформатированный диск.
        - Выделить место для Ubuntu на существующем диске.
        - Установить Ubuntu на флэшку.
      - Заранее готовить диск, создавать разделы, нет необходимости:
          Установщик Ubuntu обеспечивает соотв. функционал.

    4) Установить Ubuntu
      - Вставить загрузочную USB-флешку с Ubuntu.
      - Перезагрузить компьютер, открыть биос (F12).
      - Указать, чтобы загрузка происходила с этой флешки. Перезагрузить.
      - Начать установку Ubuntu.
      - Выбрать тот диск (раздел), куда было запланировано установить Ubuntu.
      - Для самой Ubuntu (\) рекомендуется выделить 20gb.
      - Для раздела подкачки рекомендуется выделить столько же, сколько есть памяти.
      - Для (\home) рекомендуется выделить как можно больше (всё остальное место на диске).


А5. Работа с Ubuntu через VirtualBox

  --------------------------------------
  Подоглавление:

    - О виртуализации
    - Технологии виртуализации
    - Работа с Ubuntu через VirtualBox

  --------------------------------------

  > О виртуализации
    - Виртуализация позволяет параллельно использовать на 1 компьютере несколько ОС.
    - Основную систему называют "Хозяин", а работающие на ней виртуальные машины: "Гости".

  > Технологии виртуализации

    > Предисловие
      - Существуют различные методы виртуализации ОС.
      - Подробно будем рассматривать работу с VirtualBox (полная виртуализация) в этой главе.

    > Краткий обзор некоторых методов виртуализации

      # Полная виртуализация (виртуальные машины)
        - Программа эмулирует работу виртуального аппаратного обеспечения.
        - Гостевые системы "считают", что эмулируемое апп.обесп. настоящее.
        - На хозяине долен работать "гипервизор", отслеживающий и координирующий гостей.
        - Преимущества:
          - На вирт.маш. может работать практически любая ОС.
          - При этом не требуется вносить никаких изменений в гостевые ОС.
        - Недостатки:
          - Работает медленно.
        - Наиболее популярные программы, реализующие эту технологию виртуализации:
          VMware, QEMU, Parallels, VirtualBox, Microsoft Virtual PC.

      # Паравиртуализация
        - Принцип тот же самый, что и при полной виртуализации.
        - Но в данном случае ОС-Гости общаются с "гипервизором" напрямую.
        - Преимущества:
          - Работает быстрее, чем полная виртуализация.
        - Недостатки:
          - Требует модификации ОС. А у ком.ОС закрытый код.
        - Программы:
          Xen, UML

      # Паравиртуализация с поддержкой аппаратного обеспечения
        - Принцип тот же самый, что и при паравиртуализации.
        - Современные процессоры Intel и AMD содержат аппар.функции для виртуализации.
        - Т.О. не требуется модифицировать ОС.
        - Преимущества:
          - Высокая эффективность.
        - Недостатки:
          - Необходимы специальные процессоры.
        - Программы:
          KVM, Xen

      # Виртуализация на уровне ОС (контейнеры)
        - В этой технологии настоящие виртуальные машины не применяются.
        - Вместо этого гости используют общее ядро хозяина.
        - Преимущества:
          - Очень эффективна, сберегает ресурсы.
        - Недостатки:
          - Может использоваться только если хозяин и гости используют в точности одну и ту же ОС.
        - Программы:
          OpenVZ, Virtuozzo, Linux-VServer.

  > Работа с Ubuntu через VirtualBox

    > Видеоинструкции

      - Установка виртуальной машины Oracle VirtualBox 4
          http://www.youtube.com/watch?v=PyXchgxaLO4&t=55m16s

      - Подготовка VirtualBox 4 к установке Ubuntu
          http://www.youtube.com/watch?v=PyXchgxaLO4&t=59m22s

      - Установка Ubuntu на VirtualBox 4
          http://www.youtube.com/watch?v=PyXchgxaLO4&t=1h12m14s

      - Установка драйверов, ускоряющих работу Ubuntu через VirtualBox 4
          http://www.youtube.com/watch?v=PyXchgxaLO4&t=1h57m10s

    > Об Oracle VirtualBox4
      - Скачать VirtualBox можно с официального сайта, он бесплатен:
          https://www.virtualbox.org
      - Программа позволяет создавать не ограниченное кол-во виртуальных машин.
      - При создании виртуальной машины можно выбрать ОС и версию.
      - Из коробки доступны следующие системы:

        1) Windows (от 3.1 и выше)
        2) Linux (>10 наиболее популярных дистрибутивов, в т.ч. Ubuntu)
        3) Solaris
        4) BSD
        5) IBM OS/2
        6) MAX OS X

    > Пара советов

      # Раздел подкачки делать == объёму оперативки
        - Это понадобится, если мы собираемся “усыплять” систему.
        - Тогда все данные будут сохраняться в раздел подскачки.

      # Не забыть установить VBoxAdditions
        - Для улучшения взаимодействия между хозяином и гостями.


А6. Работа с виртуальными терминалами

  --------------------------------------
  Подоглавление:

    - Теоретическая база про терминалы
    - Горячие клавиши для работы с виртуальными терминалами
    - Активация дополнительных терминалов
    - Включить работу мыши в текстовом виртуальном терминале

  --------------------------------------

  > Теоретическая база про терминалы
    - Теоретическую базу про терминалы см. в главе "А3. Терминалы".

  > Горячие клавиши для работы с виртуальными терминалами

    ● Ctrl + Alt + F[число]
      - Переключение между виртуальными терминалами.
      - Работает как из текстовых терминалов, так и из графических.
      - Текстовыми (F1 ... F6) и графическими (F7 ... F12).
      - Причем, по умолчанию, работают терминалы F1 ... F7.
      - Места же F8 ... F12 зарезервированы под доп. графические терминалы.

    ● ALT + F[1 .. 6]
      - Переключение между текстовыми виртуальными терминалами.
      - Работает только, если уже находишься в текстовом виртуальном терминале.

    ● ALT + →, ALT + ←
      - Переключение между текстовыми виртуальными терминалами.
      - Переход, соответственно, к следующему/предудыщему текстовому терминалу.
      - Работает только, если уже находишься в текстовом виртуальном терминале.

    ● SHIFT + PgUp, SHIFT + PgDown
      - Пролистывание текста в текстовом терминале.
      - Соответственно, вверх/вниз.

    ● CTRL + ALT + DEL
      - Перезагружает Ubuntu.
      - Работает только, если уже находишься в текстовом виртуальном терминале.

  > Активация дополнительных терминалов
    - В Ubuntu по умолчанию активированы лишь 7 терминалов.
    - Текстовые терминалы с 1 по 6, и GUI-терминал на 7-й позиции.
    - При переключении на терминалы с 8 по 63 мы увидим лишь чёрный экран с курсором.
    - Но любой из них можно активировать. Тогда на нём мы увидим приглашение ввести логин/пароль.
    - Для активации достаточно запустить на желаемом терминале любой процесс.
    - Сделать это можно, например, в следующих местах:
      1] Из другого терминала
        - Например, запустим getty на желаемом терминале tty12:
            sudo /sbin/getty -8 38400 tty12
        - Она запрашивает логин и выполняет программу /bin/login.
        - В результате, при переходе на tty12 мы видим приглашение ввести логин/пароль.
        - Минус: после входа/выхода getty не запускается снова, и мы опять видим чёрный экран с курсором.
      2] В скрипте, который срабатывает при запуске системы
        - Допустим, нам надо активировать терминалы с 13 по 63.
        - Тогда в данном скрипте, в каждом из них запускаем какой-нибудь процесс.
        - Например, тот же getty.

  > Включить работу мыши в текстовом виртуальном терминале
    - Для этого надо запустить программу gpm.
    - По умолчанию, в Ubuntu эта программа не установлена.


А7. Работа с командами в окне терминала

  --------------------------------------
  Подоглавление:

    - Разбить 1 команду на N строк можно с помощью \
    - Выполнение команд в фоновом режиме
    - Выполнение команд от имени администратора

  --------------------------------------

  > Разбить 1 команду на N строк можно с помощью \
    - Иногда команда слишком длинная, и не удается её уместить в 1 строку.
    - В этом случае её можно разбить на 2 или более строк.
    - Для этого в месте разбиения надо поставить символ \
    - Например:

        gconftool -2  --set "/apps/panel/toplevels/top_panel_screen0/monitor" \
                      --type integer "0"

  > Выполнение команд в фоновом режиме

    > Не в фоновом режиме
      - По умолчанию команда из окна терминала запускается не в фоновом режиме.
      - Например, эта команда запустит firefox не в фоновом режиме:

          firefox

      - Это значит, что окно терминала будет "ждать" завершения запущенного процесса.
      - И пока этого не произойдёт, оно будет находитсья в "подвисшем" состоянии.
      - То есть, никакие другие команды выполнить будет нельзя.
      - Если при этом нажать CTRL + C, процесс завершится, и окно терминала "развиснет".

    > В фоновом режиме
      - Иногда хочется запустить программу из окна терминала.
      - И, при этом, продолжить работать с этим же окном терминала.
      - Не дожидаясь, пока процесс программы завершится, и не открывая другого окна терминала.
      - Для этого, после имени команды надо указать символ &

          firefox &

    > Выполнение команд от имени администратора

      > Ссылка на подробную русскоязычную справку
          help.ubuntu.ru/wiki/суперпользователь_в_ubuntu

      > В режиме администратора приветствие заканчивается символом #
        - Таким образом можно понять, что включен режим администратора.
        - Примет того, как может выглядеть приветствие:

            root@gekkman:~#

      > Команда sudo
        - Позволяет выполнить клюбую команду с правами администратора:

            sudo [команда]    | запустить [команда] с правами администратора
              -K                - гарантированно прекратить сессию sudo (не дожидаясь истечения 15 минут)


      > Конфиг sudoers
        - В нём можно настроить, кто какие программы может выполнять с sudo (с правами администратора).
        - Первый пользователь (при установке) системы автоматически получает все права в sudoers.
        - Справку по этому поводу можно почитать в: /etc/sudoers.d/README.
        - Редактировать конфиг рекомендуется специальной программой visudo:

            visudo    | открыть конфиг sudoers для редактирования
              -c        - проверить конфиг sudoers на наличие синтаксических ошибок

        - Конфиг хорошо документирован, разобраться в нем не составляет труда.

      > Запуск графических программ с правами администратора
        - Это можно сделать либо в графическом режиме, нажав ALT + F2
        - Либо из окна терминала, использовав gksudo вместо sudo.
        - Например:

            gksudo firefox

        - В Ubuntu (14.04) gksu по умолчанию не установлена.

      > Переход в режим администратора командой sudo
        - С помощью команды sudo можно перейти в режим администратора.
        - Для перехода в режим админа без смены домашнего каталога на /root, надо ввести:

            sudo -s

        - Для перехода в режим админа со сменой домашнего каталога на /root, надо ввести:

            sudo -s -H

        - Для выхода из режима администратора, надо ввести:

            CTRL + D

      > Переход в режим администратора командой su
        - Команда su позволяет 1-му пользователю стать другим в текущем сеансе.
        - Если su вызывается без имени пользователя, то это делает его суперпользователем.
        - При этом домашний каталог изменяетсяна /root
        - По умолчанию, команд su не спрашивает пароль суперпользователя, когда её запускает суперпользователь.
        - Это значит, что введя sudo su -, можно стать суперпользователем, и его пароль даже не спросят.
        - Нажав CTRL + D, можно выйти из режима суперпользователя.

      > Использование традиционного root-аккаунта
        - В Ubuntu, при входе в систему, по умолчанию, нет возможности выбрать логин root (суперпользователь).
        - Но это можно поправить.
        - Это описание действительно для Ubuntu 11.10+.
        - Поскольку с этой версии присутствует входа lightdm.
        - Инструкция:

          1) Устанавливаем root (суперпользователя) пароль
            sudo passwd root

          2) Включаем пункт "Введите логин"
            - Чтобы такой пункт при входе в систему был.
            - Для этого надо ввести в окне терминала:

                gksu gedit /etc/lightdm/lightdm.conf

            - И в конце файла дописать:

                greeter-show-manual-login=true

          3) Перезагружить lightdm

              sudo service lightdm restart

        - Все, на экране входа появится пункт "Введите логин".
        - В поле логина вводим "root", а в поле пароля заданный пароль.


А8. Оболочка bash

  --------------------------------------
  Подоглавление:

    Введение в bash
    ---------------

    Что такое оболочка
    ------------------

      - Общая информация об оболочках
      - Узнать имя выбранной по умолчанию оболочки
      - Узнать версию bash
      - Как оболочка обрабатывает введенную команду
      - Как выбрать другую оболочку
        - Есть и другие оболочки, кроме bash
        - Как опробовать другую оболочку
        - Как установить другую оболочку на постоянной основе
        - Выбор оболочки при исполнении скрипта

    Базовая конфигурация
    --------------------

      - Настройка обработки ввода в клавиатуры (bash-функции readline)
      - Настройка строки-приветствия

    Ввод команд
    -----------

      - История введённых в bash команд хранится в ~/.bash_histiry
      - Использование автодополнения имен команд и файлов
      - Выполнение программ из текущего каталога
      - Узнать путь к программе
      - Использование псевдонимов

    Переадресация ввода/вывода
    --------------------------

      - Файловые дескрипторы
      - О стандартных потоках
      - Как переадресовывать стандартные потоки
      - Использование программных каналов
      - Использование FIFO-файлов
      - Размножение вывода командой tee

    Выполнение команд
    -----------------

      - Обзор шаблонов выполнения команд
      - Разнообразные примеры выполнения команд
        - Запуск команды в фоновом режиме
        - Перевод выполнения команды в фоновый режим
        - Выполнение 1-й команды в фоновом, а 2-й в обычном режиме
        - Поочередное выполнение 2-х команд в фоновом режиме
        - Выполнение 2-х команд в фоновом режиме, с перенаправлением их выводов

    Механизмы подстановки
    ---------------------

      - Суть идеи механизмов подстановки
      - Обзор механизмов подстановки
      - Разнообразные примеры применения механизмов подстановки
        - Образование имен файлов с помощью * и ?
        - Образование имен файлов с помощью **
        - Образование последовательностей с помощью {}
        - Вычисление арифметических выражений с помощью []
        - Замена команды её результатом
        - Экранирование спец.символов
      - Как увидеть, как выглядит команда после обработки всех спец.символов в ней

    Оболочковые переменные
    ----------------------

      - Что такое переменные оболочки
      - Чтение и запись переменных оболочки
      - Нельзя ставить пробелы при записи переменных
      - Как дописать в $PATH новое значение
      - Проведение вычислений с переменными окружения
      - Сохранение результата выполнения команды в переменную
      - Сохранить содержимое переменной в файл
      - Задание переменных оболочки на постоянной основе
      - Локальные и глобальные переменные оболочки
      - Важнейшие переменные оболочки

    Скрипты bash
    ------------

      - Общая информация о скриптах bash
      - В Ubuntu по умолчанию скрипты обрабатывает Dash, а не Bash
      - Синтаксис скриптов bash
      - Переменные в сценариях bash
        - Область определения переменных
        - Стандартные переменные оболочки
      - Массивы в сценариях bash
      - Спец.функции bash для обработки последовательностей символов
      - Функция read: обработка пользовательского ввода
      - Условные выражения bash

    Справка по важнейшим специальным символам bash
    ----------------------------------------------


  --------------------------------------

  > Введение в bash
    - Bash, это оболочка, позволяющая выполнять команды в окне терминала.
    - Кроме того, оболочка является интерпретатором команд.
    - Также bash обладает собственным языком программирования.
    - С помощью последнего можно создавать bash-скрипты.
    - А вообще, кроме bash, существует и много других оболочек.
    - Но bash является наиболее популярной.
    - Bash - Bourne Again SHell - снова оболочка Борна.
    - Здесь bash будет рассмотрен и как интерпретатор, и как инструмент програмирования.


  > Что такое оболочка

    > Общая информация об оболочках
      - Оболочка предназначена для вызов и интерпретации программ Linux.
      - Оболочка выполняется в любом окне терминала после входа в систему.
      - Оболочка (bash) также содержит собственный язык программирования.
      - Что позволяет писать скрипты, т.о. автоматизируя нужные процессы.
      - Скрипт представляет txt-файл с кодом, который интерпретируется оболочкой.

    > Узнать имя выбранной по умолчанию оболочки
      - Для этого надо ввести:

          $0

    > Узнать версию bash
      - В том случае, если bash является выбранной по умолчанию оболочкой.
      - Для этого надо ввести:

          $BASH_VERSION

    > Как оболочка обрабатывает введенную команду

      1) Проверяет её на наличие синтаксических ошибок.
      2) Заменяет переменные окружения в команде на их значения.
      3) Заменяет все найденные шаблоны (типа * или ?).
        - Если shell не может найти шаблон, он просто его возвращает, как есть.
      4) Производит перенаправление стандартных потоков ввода-вывода.
      5) Выясняет, что за команду мы ему передали.

    > Другие оболочки
      - Почти во всех дистрибутивах bash считается стандартной оболочкой.
      - Однако существуют и другие оболочки:
        # zsh         | Z-оболочка, которую особенно любят профессионалы
        # ksh, pdksh  | оболочка Корна
        # csh, tcsh   | C-оболочка
      - Чтобы опробовать другую оболочку, надо ввести её имя в окне терминала:

          zsh

      - Командой exib можно вернуться обратно в стандартную оболочку.

    > Как выбрать другую оболочку

      > Есть и другие оболочки, кроме bash
        - Почти во всех дистрибутивах bash считается стандартной оболочкой.
        - Однако существуют и другие оболочки:
          # zsh         | Z-оболочка, которую особенно любят профессионалы
          # ksh, pdksh  | оболочка Корна
          # csh, tcsh   | C-оболочка

      > Как опробовать другую оболочку
        - Чтобы опробовать другую оболочку, надо ввести её имя в окне терминала:

            zsh

        - Командой exib можно вернуться обратно в стандартную оболочку.

      > Как установить другую оболочку на постоянной основе
        - У каждого пользователя Linux указана своя стандартная оболочка.
        - Путь к стандартной оболочке пользователя хранится в /etc/passwd
        - Он указывается в самом конце учетной записи кажодго пользователя.
        - Выбрать другую оболочку по умолчанию можно командой chsh (change shell):

            chsh csh

      > Выбор оболочки при исполнении скрипта
        - Каждый скрипт должен начинаться со строки вида:

            #!/bin/sh

        - Это указывает, какая оболочка должна интерпретировать этот скрипт.
        - В старыд дистрибутивах ссылка /bin/sh чаще всего указывала на bash.
        - Однако, разработчики посчитали bash слишком медленным именно для интерпретации скриптов.
        - И, в Ubuntu, заменили его на dash (Debian-Almquist).
        - В Ubuntu 14.04 /bin/sh по умолчанию указывает на dash.
        - Проверить, на что указывает /bin/sh, можно так:

            ls -l /bin/sh       | -> dash

        - dash не полностью совместим с bash.
        - Поэтому, если всё же нужно, чтобы скрипт интерпретировался bash'ем, то пишем в его начале:

            #!/bin/bash


  > Базовая конфигурация

    > Настройка обработки ввода в клавиатуры (bash-функции readline)
      - У bash есть функция readline для обработки ввода с клавиатуры.
      - Её настройки должны лежать в файле ~/.inputrc
      - В Ubuntu 14.04 этот файл по умолчанию не создан, но этом можно поправить:

          touch ~/.inputrc                        | создать
          chmod 644 ~/.inputrc                    | задать нужные права

      - Допустим, мы хотим, чтобы при нажатии "CTRL + t" срабатывала команда top -Ss
      - Для этого открываем в nano файл inputrc:

          nano ~/.inputrc

      - И вписываем туда первой строкой:

          Control-t: "top -Ss \C-m"

      - Любые изменения в нем вступают в силу после перезагрузки оболочки.
      - Теперь, нажатие CTRL + t вызывает запуск в оболочке команды top -Ss

    > Настройка строки-приветствия

      > Ссылки

        - Статья на archlinux по теме:
            https://wiki.archlinux.org/index.php/Color_Bash_Prompt_(Русский)

        - Статья на убонтологии по теме:
            http://ubuntologia.ru/blog/console-scripting/88.html#prompt_command

      > Предисловие
        - В оболочке, в начале каждой строки, отображается т.н. "приветствие".
        - Например, в Ubuntu 14.04:

            gekkman@gekkman:~$          | приветствие в домашнем каталоге
            gekkman@gekkman:~/Видео$    | приветствие в каталоге /Видео

        - Формат его таков: [имя компа]@[имя польз.]:~[имя каталога][режим]
        - И это является форматом "по умолчанию" для данной версии Ubuntu.
        - В разных дистрибутивах разных версий, оно может быть другим.
        - Что обозначают разные режимы:
          $   | приглашение выполнить команду с правами обычного пользователя
          #   | приглашение выполнить команду с правами администратора
          >   | идет ввод многострочной команды, и он ещё не закончился

      > PS1, PS2, PS3, PS4
        - Есть 4 вида приглашений приглашений для разных случаев.
        - Вот они:
          # PS1   | ожидание ввода команды
          # PS2   | ввод многострочной команды (на >= 2 сроках)
          # PS3   | когда нужно сделать выбор в операторе select
          # PS4   | при отладке скриптов, выводится в начале строки перед исполняющейся командой
        - Посмотреть их можно в переменных среды $PS1, $PS2, $PS3, $PS4.
        - Допустим, чтобы посмотреть значение PS1, вводим:

            $PS1

      > PROMPT_COMMAND
        - Это переменная среды. В ней содержится скрипт.
        - Он будет выполняться перед каждым выводом приглашения PS1.
        - Используется для расширения возможностей первичного приглашения.
        - Допустим, я хочу, чтобы перед каждым первичным приглашением выводился календарь.
        - Для этого я задаю:

            PROMPT_COMMAND = 'cal;'

        - В принципе, этой переменной можно вообще полностью заменить первичное приглашение.
        - Для этого надо обнулить PS1, а первичное приглашение реализовать в PROMPT_COMMAND.

      > Как изменить значение переменной среды
        - PS1, PS2, PS3, PS4 и PROMPT_COMMAND - переменные среды.
        - Значит, чтобы изменить приветствия, нужно изменить значения этих переменных среды.
        - Для этого есть 2 варианта:

          1) Работает только до тех пор, пока текущий процесс не завершится
            - Изменить значение переменной среды прямо в окне терминала.
            - Допустим, мы хотим изменить значение PROMPT_COMMAND.
            - Для этого в окне терминала пишем:

                PROMPT_COMMAND='cal;'

            - Будет работать до тех пор, пока не закроешь окно терминала (завершение процесса).

          2) На постоянной основе
            - Когда запускаешь окно терминала, новый процесс получает стандартные значения переменных среды.
            - Он берет их из конфига оболочки bash по адресу:
              # ~/.bashrc       | для обычного пользователя
              # /root/.bashrc   | для админа
            - Допуситм, в конец файла можно дописать:

                # Показывать календарь перед показом каждого первичного приветствия
                PROMPT_COMMAND='cal;'

                # Настроить первичное приглашение PS1
                PS1='\[\e[0;34m\]\u@\h:\w\$\[\e[0;37m\] ';

            - После этого перезапускаем термила, и вуаля.

      > Синтаксис приглашения

        > Предисловие
          - Для указания значения приглашения используется специальный формат.
          - Он состоит из смеси обычных символов и спец.символов.
          - Каждый спец.символ начинается с обратной косой черты \

        > Спискок спец.символов

          ******************* Печатные символы *********************************
          \d   Дата в формате "День, месяц, число", например, Срд, Окт, 17.
          \h   Имя хоста (hostname) до первой точки
          \H   Полное имя хоста
          \t   Текущее время в 24-часовом формате: HH:MM:SS (часы:минуты:секунды)
          \T   Текущее время в 12-часовом формате: HH:MM:SS
          \@   Текущее время в 12-часовом формате am/pm
          \u   Имя пользователя, запустившего оболочку
          \w   Полное имя текущего рабочего каталога (начиная с корня)
          \W   Текущий рабочий каталог (без указания пути)
          \$   Символ #, если оболочка запущена суперпользователем, и символ $, если оболочка запущена обычным пользователем.
          \n   Новая строка (перевод строки)
          \s   Имя оболочки
          \#   Текущий номер команды
          \!   Порядковый номер данной команды в истории команд
          \\   Обратный слэш (a backslash)

          ******************* Непечатные символы *******************************
          \nnn   Непечатный символ, имеющий восьмеричный код nnn (к примеру esc)
          \a   Звуковой сигнал (ASCII-код 007)
          \e   escape (ASCII-код 033)
          \[   Начало последовательности не печатаемых символов (этот символ может быть использован для того, чтобы включить в текст подсказки последовательность управляющих символов терминала)
          \]   Конец последовательности не печатаемых символов

        > Решение проблемы непечатаемых символов

          > Проблема
            - Bash считает кол-во символов в значении переменной среды приглашения.
            - И выводит именно такое кол-во символов в окне терминала в виде приглашения.
            - Но проблема в том, что в этом значении могут быть и не печатаемые символы.
            - Например, такие, которые обозначают цвет.
            - Это приводит к тому, что bash неправильно подсчитывает кол-во символов.

          > Решение
            - Заключать непечатаемые символы в скобки \[  \]
            - Тогда они не будут учитываться при подсчете

        > Как управлять цветом текста и фона приветствия

          > Форматы:

            \[\е[#;##;#;##m\]   | управлением цветами фона и текста
            \[\е[#;##m\]        | управление цветом текста

          > Здесь

            #     | номер свойства текста
            ##    | номер цвета

          > Доступные свойства цвета:

            - 0     | значение по умолчанию
            - 1     | повышенная яркость
            - 2     | пониженная яркость
            - 4     | подчеркнутый
            - 5     | нормальная яркость
            - 7     | инвертированный
            - 8     | скрытый

          > Доступные цвета

            - Цвет          Текст     Фон
            - Черный        30        40
            - Красный       31        41
            - Зеленый       32        42
            - Желтый        33        43
            - Синий         34        44
            - Фиолетовый    35        45
            - Голубой       36        46
            - Белый         37        47

        > Разберем пример
          - В качестве примера используем следующее значение:

              PS1='\[\e[0;34m\]\u@\h:\w\$\[\e[0;37m\] ';

          - Разложем его на кусочки:

                     1        2  3   4  5   6   7      8       9
              '\[\e[0;34m\]  \u  @  \h  :  \W  \$  \[\e[0;37m\] '

          - Пояснения к каждому кусочку

              1) Назначить цвет синий цвет текста, идущего далее.
              2) Имя пользователя, запустившего оболочку.
              3) Просто символ "собака"
              4) Имя хоста (hostname) до первой точки
              5) Просто символ "двоеточие"
              6) Текущий рабочий каталог (без указания пути)
              7) Символ #, если оболочка запущена суперпользователем, и символ $, если оболочка запущена обычным пользователем.
              8) Назначить цвет белый цвет текста, идущего далее.
              9) Установить 1 пробел между приветствием и текстом команды.


  > Ввод команд

    > История введённых в bash команд хранится в ~/.bash_histiry
      - Оболочка bash сохраняет историю введенных команд.
      - Пока процесс работает, bash держит их в своей памяти.
      - При завершении процесса сохраняет в файлик ~/.bash_histiry.
      - А при создании нового процесса, загружает из этого файлика.
      - Нажимая клавиши ↑↓ в окне терминала, можно просматривать сохраненные команды.
      - И не только просматривать, но и изменять, и исполнять.

    > Использование автодополнения имен команд и файлов

      > Общая информация
        - Можно ввести начало команды и нажать TAB.
        - Bash автоматически сообразит, что за команда, и допишет до конца сам.

      > Нюансы работы автодополнения
        - Если название команды/файла можно 1-значно идентиф., оно дописывается полностью.
        - Если имеется >=2 названий, начинающихся одинаково, имя будет дополнено не до конца.
          - Например, есть файл "myvidEos" и команда "myvidOses".
          - Если написать "myv" и нажать TAB, то дополнится до "myvid".
          - При этом будет издан звуковой сигнал, обозначающий, что имя дополнено не до конца.

      > 2x TAB
        - Если нажал TAB, но имеется >=2 названий, начинающихся одинаково.
        - Тогда можно ещё раз нажать TAB.
        - И все возможные варианты имен будут выведены на экран.
        - Для теста введи:

            e [нажми TAB] [нажми TAB]

      > Где автодополнение ищет имена
        - Имена программ по всем каталогам, указанным в переменной PATH.
        - Имена файлов только в текущем каталоге.

    > Выполнение программ из текущего каталога
      - Допустим, мы находимся в каталоге /users/me
      - И тут у нас лежит программа "my_prog".
      - Мы вводим в окно терминала:

          my_prog

      - Программа выполнится, только если /users/me есть в PATH.
      - А если нет, то не выполнится.
      - В большинстве дистрибутивов текущего каталога в PATH нет из соображений безопасности.
      - Поэтому, чтобы выполнить команду из текущего каталога, надо ввести:

          ./my_prog

    > Узнать путь к программе

      > Предисловие
        - Допустим, программа лежит в каталоге, который фигурирует в $PATH.
        - Например, команда ls лежит в /bin/ls
        - Убедиться, что этот каталоге есть в $PATH можно, введя:

            echo $PATH

        - Поэтому, для вызова программы ls мы можем писать просто:

            ls

        - Но что, если не знаем путь к программе, и хотим его узнать?

      > Способы узнать путь к программе [имя]
        1. whereis [имя]
          - Просматривает все стандартные каталоги.
        2. which [имя]
          - Просматривает все каталоги в $PATH.
          - Определяет команду, которая выполнялась бы при вводе команды без указания пути.
          - Оч.полезна, если в системе есть несколько версий программы.
        3. type [имя]
          - Аналог which.
          - Но учитывает и в строенные в bash команды.
          - А также псевдонимы.

    > Использование псевдонимов

      > Общая информация
        - Для команд (в т.ч. и с параметрами) можно задавать псевдонимы.
        - Бывают очень длинные команды, с массой парамтеров, которые каждый раз вводить вручную утомительно.
        - Для них можно задавать короткие удобные вседонимы.

      > Посмотреть все действующие псевдонимы
        - Для этого надо ввести команду alias без параметров.

      > Задать/удалить псевдоним не на постоянной основе

        > Задать
          - То есть, задать его не на постоянной основе.
          - Можно в окне терминала с помощью команды alias.
          - Например, зададим такой псевдоним:

            alias my='ls /home/gekkman -l'

          - Теперь при вводе команды my выводится содержимое домашнего каталога пользователя gekkman.
          - Псевдоним будет работать до тех пор, пока не завершен процесс оболочки.

        > Удалить
          - Удалить заданный псевдоним можно командой unalias.
          - Например, удалим псевдоним my:

              unalias my

          - Убедимся, что псевдоним удален, просмотрев список действующих псевдонимов:

              alias

      > Задать псевдоним на постоянной основе

        > Задать
          - Сделать это можно в конфиге оболочки bash.
          - Либо в глобальном (/etc/bashrc), либо пользовательском (~/.bashrc).
          - Нужно просто в конце конфига дописать команду создания псевдонима.
          - При каждом запуске bash конфиг выполняется, и указанный псевдоним создается.

      > Приоритет псевдонима над одноименной командой
        - Псевдонимы имеют приоритет над одноименными командами.
        - Это часто используют, чтобы воспрепятствовать нежелательному вызову.
        - Например, есть устаревшая команда more. А есть более свежая less.
        - И мы хотим, чтобы при вызове more вызывалась less.
        - Для этого просто создаем псевдоним по имени more:

            alias more=less

        - При наличии псевдонима, запустить команду more можно так:

            \more         | поставить перед ней обратный слэш
            /bin/more     | использовать полный путь к ней

    > Переадресация ввода/вывода

      > Файловые дескрипторы
        - Что такое файловый дескриптор описано в теор.части по адресу:
            "Обзор категорий св-в структуры "task_struct" процесса" -> "Файлы"
        - При создании процесса он сразу получает 3 файловых дескриптора:
          0   | поток стандартного ввода
          1   | поток стандартного вывода
          2   | поток стандартных ошибок
        - Как мы знаем, при выполнении любой команды в bash создается новый процесс.
        - Так, что каждая выполняющаяся команда имеет эти 3 файловых дескриптора.

      > О стандартных потоках

        > Поток стандартного ввода
          - Исполныющаяся программа (процесс) считывает весь стандартный ввод.
          - Источником стандартного ввода обычно является клавиатура.

        > Поток стандартного вывода
          - Сюда переадресовывается весь стандартный вывод процесса.
          - Стандартный вывод обычно отображается в окне терминала.

        > Поток стандартных ошибок
          - Сюда переадресовываются все сообщения об ошибках.
          - Ошибки также обычно отображаются в окне терминала.

      > Как переадресовывать стандартные потоки

        > Таблица шаблонов для переадресации

          [команда]   >   [файл]        | вывод в файл (старое содержимое удаляется)
          [команда]   <   [файл]        | файл в стандартный ввод
          [команда]   2>  [файл]        | ошибки в файл (старое содержимое удаляется)
          [команда]   >&  [файл]        | вывод и ошибки в файл (старое содержимое удаляется)
          [команда]   &>  [файл]        | вывод и ошибки в файл (старое содержимое удаляется)
          [команда]   >>  [файл]        | вывод в файл (дописывает в конце файла)
          [команда]   &>> [файл]        | вывод и ошибки в файл (дописывает в конце файла)
          [команда1]  |   [команда2]    | вывод команды №1 на ввод команды №2
          [команда1]  |   tee [файл]    | вывод в окно терминала, и одновременно в файл

        > Одновременная обработка и запись в файл запрещены
          - Невозможно одновременно обрабатывать и записывать в файл.
          - Скажем, нельзя одновременно сортировать файл и писать в него:
          - Например, такое выражение приведет к удалению файла dat:

              sort [файл] > [файл]

      > Использование программных каналов
        - Программный канал (pipe) создается с помощью символа |
        - Он переадресует вывод 1-го процесса на ввод 2-го процесса.
        - Пример:

            ls -l | less

      > Использование FIFO-файлов
        - Вместо программных канало могут быть использованы FIFO-файлы.
        - Они реализуют идею программных каналогв в форме файла.
        - FIFO - First In First Out - первый вошёл, первый вышел.
        - Работать с FIFO значительно сложнее, чем с программными каналами.
        - На практике применяются для того, чтобы 2 процесса могла обмениваться данными.
        - Например:

            mkfifo fifo       | создать FIFO-файл
            ls -l > fifo &    | запустить фон.процесс, вывод направлять в fifo
            less < fifo       | less будет считывать данные из fifo и выводить в окно терминала

      > Размножение вывода командой tee
        - Иногда требуется отправить вывод и в файл, и в окно терминала, и ещё куда-то.
        - То есть, по сути, размножить его. В этом нам поможет команда tee.
        - Например, вывод в окно терминала и в [файл1], и в [файл2]:

            ls -l | tee [файл1] > [файл2]

  > Выполнение команд

    > Обзор шаблонов выполнения команд

      - [команда1] ;  [команда 2]   | выполняет команды одна за другой
      - [команда1] && [команда 2]   | выполняет команду2, если команда 1 была выполнена успешно
      - [команда1] || [команда 2]   | выполняет команду2, если команда1 возвращает ошибку
      - [команда] &                 | запускает команду в фоновом режиме
      - [команда1] &  [команда 2]   | запускает команду1 в фоновом режиме, команду 2 - на виду
      - ([команда1] ; [команда 2])  | выполняет обе команды в одной и той же оболочке

    > Разнообразные примеры выполнения команд

      # Запуск команды в фоновом режиме
        - Это имеет смысл, если выполнение команды занимает много времени.
        - Если запустить такую команду не в фоновом режиме, окно терминала будет заблокировано до завершения процесса.
        - А если запустить в фоновом режиме, то можно продолжать работу с окном терминала, не дожидаясь завершения работы команды.
        - Пример:

            find / -name '*sh' > result &

        - Эта команда ищет по всей ФС файлы, заканчивающиеся на '*sh'.
        - Как видно, здесь применяется джокерный символ * (0 и более любых символов).
        - Список имен найденных файлов записывается в файл result.
        - Очевидно, команда долгая, поэтому запускается в фоновом режиме.

      # Перевод выполнения команды в фоновый режим
        - Допустим, запустили такую команду, не в фоновом режиме (а хотели в фоновом):

            find / -name '*sh' > result

        - Конечно, можно остановить её - CTRL + C - и перезапустить в фоновом.
        - Но лучше поставить её на паузу - CTRL + Z - и возобновить в фоновом командой bg.

      # Выполнение 1-й команды в фоновом, а 2-й в обычном режиме
        - Команда после & выполнится в обычном режиме.
        - Например:

            find / -name '*sh' > result & ls

      # Поочередное выполнение 2-х команд в фоновом режиме
        - Допустим, надо выполнить 2 команды в фоновом режиме.
        - Пример:

            ls; top

      # Выполнение 2-х команд в фоновом режиме, с перенаправлением их выводов
        - Допустим, надо сохранить списки имен файлов из 2-х каталогов в файл.
        - Из корневого каталога, и из домашнего каталога.
        - И все это надо сделать в фоновом режиме.
        - Вот, как это делается:

            (ls /; ls ~) > file


  > Механизмы подстановки

    > Суть идеи механизмов подстановки
      - В командах можно использовать специальные символы.
      - Оболочка перед выполнением команды ищет все эти спец.символы.
      - И проводит изменение команды в соотв. со значением этих спец.символов.
      - В целом, данный механизм напоминает регулярные выражения.
      - И по синтаксису похоже.

    > Обзор механизмов подстановки

        ?                 | любой 1 символ
        *                 | от 0 и более любых символов
        **                | любые файлы и каталоги, в т.ч. из всех подкаталогов
        [abc]             | 1 из указанных в скобках символов
        [a-f]             | 1 из указанного в скобках диапазона символов
        [!abc]            | любой символ, кроме указанных в скобках
        [^abc]            | любой символ, кроме указанных в скобках
        ~                 | ссылка на домашний каталог
        .                 | ссылка на текущий каталог
        ..                | ссылка на родительский для текущего каталог
        ab{1,2,3}         | вернёт ab1 ab2 ab3
        a{1..4}           | вернёт a1 a2 a3 a4
        $[3*4]            | вернёт 12 (производит арифметич.вычисление)
        `команда`         | замена команды результатом её выполнения
        $(команда)        | замена команды результатом её выполнения
        Команда "символ"  | отмена интерпретации любых спец.символов, кроме $
        Команда 'символ'  | отмена интерпретации любых спец.символов, в т.ч. $

    > Разнообразные примеры применения механизмов подстановки

      # Образование имен файлов с помощью * и ?
        - Рассмотрим ряд примеров:

            rm *.bak          | удалить все файлы, заканчивающиеся на '.bak', из текущего каталога
            echo /*           | вывести на экран список имен всех файлов (и каталогов) из корневого каталога
            echo /[abc]*      | вывести на экран список имен всех файлов (и каталогов) из корневого каталога, начинающихся на буквы a, b или c
            echo /[a-c]*      | вывести на экран список имен всех файлов (и каталогов) из корневого каталога, начинающихся на буквы a, b или c
            echo /[!a-c]*     | вывести на экран список имен всех файлов (и каталогов) из корневого каталога, начинающихся на любые буквы, кроме: a, b или c
            echo /???         | вывести на экран список имен всех файлов (и каталогов) из корневого каталога, состоящих из 3 любых символов
            ls *              | вывести список ВСЕХ имен файлов и каталогов в ФС

      # Образование имен файлов с помощью **
        - Начиная с bash 4.0, ** рекурсивно охватывает все файлы и каталоги.
        - Но ** по умолчанию деактивировано из соображенй совместимости.
        - Чтобы включить:

            shopt -s globstar

        - Отобразить имена всех файлов и каталогов в системе:

            echo **

      # Образование последовательностей с помощью {}
        - Оф. название этого механизма подстановки: "раскрытие скобок".
        - Позволяет облегчить рутинную работу, когда много однотипных имен.
        - Рассмотрим несколько примеров:

            echo part{1,2,3a,3b}    | part1 part2 part3a part3b
            echo {a,b}{1,2,3}       | a1 a2 a3 b1 b2 b3
            echo {1..5}             | 1 2 3 4 5
            echo {a..e}             | a b c d e

        - Более сложный пример:

            echo {ab,cd}{123,456,789}-{I,II}

        - Результат:

            ab123-I ab123-II ab456-I ab456-II ab789-I ab789-II
            cd123-I cd123-II cd456-I cd456-II cd789-I cd789-II

      # Вычисление арифметических выражений с помощью []
        - Обычно в bash нельзя производить вычисления, как в консоли Chrome, например.
        - Если просто написть "2 + 3", оболочка не сообразит, что к чему.
        - Для вычисления с помощью оболочки надо использовать шаблон: $[выражение]
        - Диапазон чисел INT: +- 2 147 483 648
        - Примеры:

            $[2+3]      | 5
            $[2*3]      | 6
            $[2==2]     | 1
            $[2==3]     | 0
            $[2!=3]     | 1

      # Замена команды её результатом
        - Можно заменить команду её результатом в команде.
        - Для этого есть 2 шаблона: `команда` и $(команда).
        - Второй предпочтительнее, т.к. исключается путаница 3-х разных кавычек: ` ' "
        - Позволяет осуществлять вложенный вызов команд с передачей результата выполнения.
        - Пример:

            ls -l $(find / -name ???)

        - Команда находит в корневом каталоге все файлы и каталоги с именем из 3 букв.
        - И передают результат команде ls, которая выводит их с доп.инфой (правами доступа и т.д.)
        - Достичь такого результата с помощью | не получится, т.к. ls не ожидает никакого ввода.
        - Другое решение, с помощью xargs:

            find / -name ??? | xargs ls -l

        - Достоинство xargs в том, что объём передаваемых данных ничем не ограничен.
        - Если имена файлов содержат пробелы, xargs будет работать не правильно.
        - Чтобы исправить, вводить командут так:

            find / -name ??? -print0 | xargs -null ls -l

      # Экранирование спец.символов
        - Способы экранирования:

            \   | экранирование 1-го спец.символа
            ''  | экранирование всех спец.символов, включая $, \ и '
            ""  | экранирование всех спец.символов, кроме $, \ и '

        - Примеры:

            echo 'Выведем это: $PATH'   | выводит строку 'Выведем это: $PATH'
            rm 'ab* $cd'                | удаляет из текущ.директории все файлы с именами 'ab* $cd'



    > Как увидеть, как выглядит команда после обработки всех спец.символов в ней
      - Для этого надо выполнить команду: set -x
      - Тогда любая команда перед выполнением будет отображаться в окне терминала.
      - Причем, уже после применения всех спец.символов механизмов подстановки. В конечном виде.
      - Например:

          Вводим:       Перед выполнением отображается результирующая команда:
          ab{1,2,3}     ab1 ab2 ab3


  > Оболочковые переменные

    > Что такое переменные оболочки
      - Это переменные с настройками экземпляра оболочки.
      - Они похожи на переменные для программирования, но в них можно хранить лишь послед.символов.

    > Чтение и запись переменных оболочки
      - Записанные переменные сохраняются до завершения процесса оболочки.
      - При создании нового процесса оболочки, создается набор переменных окружения по умолчанию.

        var=abc               | запись
        var='привет, bash!'   | запись строки, содержащей пробелы
        echo $var             | чтение

    > Нельзя ставить пробелы при записи переменных

        var = abc   | как НЕЛЬЗЯ (работать не будет)
        var=abc     | как МОЖНО

    > Как дописать в $PATH новое значение
      - Прочитаем содержимое $PATH:

          $PATH     | /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

      - Добавим в $PATH такую строку: ':/home/gekkman/bin'

          PATH=$PATH':/home/gekkman/bin'

      - Снова прочитаем содержимое $PATH, и убедимся, что все добавилось:

          /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/gekkman/bin

    > Проведение вычислений с переменными окружения
      - Это можно делать с помощью [].
      - Например:

          a=3
          b=5
          c=$[$a+$b]
          echo $c       | 8

    > Сохранение результата выполнения команды в переменную
      - Сохраним в меременную результат выполнения команды pwd:

          pwd_res=$(pwd)
          echo $pwd_res       | /usr/games

    > Сохранить содержимое переменной в файл
      - Это делается через перенаправление потока вывода.
      - Сохраним содержимое $pwd_res в файл file1:

          $pwd_res > file1

    > Задание переменных оболочки на постоянной основе
      - Записанные переменные сохраняются до завершения процесса оболочки.
      - И действительны только для того экземпляра оболочки, в котором заданы.
      - При создании нового процесса оболочки, создается набор переменных окружения по умолчанию.
      - Задать переменные окружения на постоянной основе можно в:

          /etc/profile    | глобальный профиль bash
          ~/.profile      | пользовательский профиль bash

      - Эти 2 файла выполняются при создании нового экземпляра bash.

    > Локальные и глобальные переменные оболочки

      > Локальные
        - Переменные, задаваемые описанным выше образом, называются локальными.
        - Локальные переменные не видны в коде программ, запускаемых в оболочке.
        - А видны лишь только в самой оболочке, её функциям.
        - Пример задания локальной переменной:

            abc=10

      > Глобальные, или переменные окружения
        - Глобальные переменные видны программам, запускаемым в оболочке.
        - Глобальные переменные часто называют "переменными окружения".
        - Задать глобальную переменную можно с помощью export или declare -x:

            export abc=10
            declare -x abc=10

      > Для управления переменными существует ряд команд
        - Многие из них дублируют друг-друга.
        - В примерах ниже важна их последовательность, сверху-вниз.
        - Несколько примеров для прояснения ситуации:

          a=3             | краткий способ записи let, a - локальная переменная
          declare a=3     | присваивает локальной переменной a значение 3 (как let)
          declare -x a=3  | присваивает локальной переменной a значение 3 (как export)
          export          | отображает все глобальные переменные
          export a        | делает переменную a глобальной
          export a=3      | присваивает глобальной переменной a значение 3
          let a=3         | присваивает глобальной переменной a значение 3
          local a=3       | делает переменную a локальной
          printenv        | синоним export, отображает все локальные переменные
          set             | отображает все переменные (и локальные, и глобальные)
          unset a         | удаляет переменную a

      > Сначала определять, как локальную, а потом делать глобальной
        - Чтобы можно было, с одной стороны, использовать переменную в механизмах подстановки оболочки.
        - А, с другой стороны, использовать переменную в коде программ.
        - Следует сначала создавать эти переменные, как локальные (x=...).
        - А затем дополнительно определять их как глобальные с помощью export x.

    > Важнейшие переменные оболочки
      - По умолчанию в оболочке уже существует ряд переменных.
      - При создании своих переменных не следует называть их именами уже существующих.
      - Иначе можно повредить механизм обработки команд Linux.
      - Например, он вдруг разучится находить файлы и т.д.
      - Список важнейших оболочковых переменных:

        BASH            | путь к файлу bash
        HOME            | путь к домашнему каталогу
        LOGNAME         | логин польозвателя
        HOSTNAME        | хост-имя компьютера
        MAIL            | путь к каталогу, в котором сохраняется входящая почта
        PWD             | путь к текущему каталогу
        OLDPWD          | путь к предыдущему использовавшемуся каталогу
        PATH            | список каталогов, в которых bash ищет команду, если её имя задано без пути
        PS1             | шаблон "приглашения №1" - ожидание ввода команды
        PS2             | шаблон "приглашения №2" - ввод многострочной команды (на >= 2 сроках)
        PS3             | шаблон "приглашения №3" - когда нужно сделать выбор в операторе select
        PS4             | шаблон "приглашения №4" - при отладке скриптов, выводится в начале строки перед исполняющейся командой
        PROMPT_COMMAND  | скрипт, который будет выполняться перед каждым выводом приглашения №1

      - Это далеко не все. Посмотреть все в отсорт. виде можно командой:

          printenv | sort


  > Скрипты bash

    > Общая информация о скриптах bash

      > Что такое скрипт оболочки
        - Скрипт оболочки представляет собой обычный txt-файл.
        - Он содержит последовательность команд Linux/Bash.
        - Эти команды должны быть выполнены в порядке сверху-вниз.

      > Скрипт принимает параметры
        - Скрипту оболочки при вызове можно передавать параметры.
        - Эти параметры будут доступны в коде скрипта.
        - Напоминает передачу параметров функции в языках программирования.

      > Bash поддерживает элементы языка программирования
        - Такие, например, как условия и циклы.
        - Так что bash - не только оболочка, но и скриптовый язык программирования.

      > Для чего нужно bash-программирование
        - Чтобы создавать новый востребованный фунционал.
        - И благодаря ему автоматизировать соответствующую работу.
        - Пример организации автоматизации:
          1) Пишем bash-скрипт.
          2) Делаем так, чтобы cron запускал его 1 раз в час.

      > Ссылка на ресурс с подробным справочником по bash-программированию
        - http://bash-hackers.org/

    > В Ubuntu по умолчанию скрипты обрабатывает Dash, а не Bash
      - Речь идет о программе, которая по умолчанию выполняет скрипты.
      - В 1-й строке скрипта надо указывать, какая программа будет его выполнять.
      - Обычно, указывают:

          #!/bin/sh

      - Так вот, в Ubuntu /bin/sh является символьной ссылкой на dash.
      - Убедитсья в этом, можно введя:

          ls -l /bin/sh

      - Программа dash лежит в /bin, а /bin есть в $PATH.
      - Так что dash доступен без указания пути, просто по имени.
      - Ну так вот, dash не полностью совместим с bash. Но работает шустрее.
      - В любом случае, лучше для интерпретации bash-скриптов использовать bash, а не dash.
      - Для этого в 1-й строке скрипта надо указать:

          #!/bin/bash

    > Синтаксис скриптов bash

      > Все файлы-скрипты должны начинатсья с #!
        - В 1-й строке скрипта должна быть указана программа для его обработки.
        - Эта запись должна быть в 1-й строке, с её 1-го символа.
        - Для обработки bash-скриптов рекомендуется указывать:

            #!/bin/bash

      > Ограничения на символы в 1-й строке скрипта
        - В ней нельзя использовать специфические спец.символы.
        - В ней нельзя использовать символы национальных алфавитов.
        - В противном случае оболочка bash откажется выполнять скрипт.
        - И выдаст ошибку: 'cannot execute binary file'.

      > Файл-скрипт должен иметь биты доступа 'r' и 'x'
        - То есть, биты доступа на чтение и исполнение.
        - Если сприпт на внеш.носителе, к дер.кат-ов д.б. подкл.параметр exec.
        - В противном случае, скрипт оболочки не может быть выполнен.

      > В bash-скриптах нельзя использовать Windows'овский перевод строки
        - Типа \r\n: возврат катерки и переход на новую строку.
        - Такой перевод может в них оказатсья, если файл перенесен из Windows.
        - В противном случае bash вернет ошибку: 'bad interpreter'.
        - Ситуацию можно исправить, обработав Windows'овский UTF8-файл командой:

            recode u8/cr-lf..u8 < windowsfile > \ linuxfile

      > Рекомендуется хранить все свои скрипты в 1-м каталоге
        - Это удобно, и легко можно их в нем найти.
        - Например, для этого подойдёт каталог ~/bin.
        - Чтобы скрипты выполнялись чисто по имени (без пути), надо внести его в $PATH.
        - На постоянной основе это можно сделать, добавив соотв. код в ~/.profile
        - Либо в /etc/profile (тогда будет действовать для всех пользователей).
        - Вот код:

            # Добавить каталог с моими bash-скриптами в $PATH
            PATH=$PATH':~/bin'

    > Переменные в сценариях bash

      > Область определения переменных

        > Как выполняются команды и программы bash
          - Для выполнения команды или программы bash создает новый процесс.
          - В процесс передаются только глобальные переменные (переменные окружения).
          - Если процесс создан приоритетном режиме, bash ожидает, пока она выполнится.
          - Если процесс создан в фоновом режиме, bash продолжает выполняться, и не ждёт окончания выполнения команды.

        > Особым случаем являются программы оболочки
          - Они выполняются не в работающей оболочке.
          - А в специально запускаемом для этого командном подпроцессоре.
          - Итак, что происходит, когда в окне терминала запускают выполение скрипта в фоновом режиме:

            1) Процесс bash продолжает функционировать и готов принимать программы.
            2) Специально для выполнения скрипта создается 2-й процесс bash.
              - А когда скрипт заканчивает работу, то и 2-й процесс bash тоже.

          - Т.О. одновременное выполняющиеся программы не влияют друг на друга.

        > Переменные оболочки и командного подпроцессора полностью независимы
          - Рассмотрим это утверждение на примере.
          - Допустим, запускаем скрипт bash в окне терминала.
          - Рассмотрим, что происходит с переменными:

            1) Создается 2-й процесс bash (подпроцессор) для выполнения скрипта.
            2) Он получает копии всех глобальных переменных из 1-го процесса bash.
              - Это именно копии, а не ссылки на них.

        > Как выполнить скрипт bash без создания 2-го процесса?

          > В чем проблема с созданием 2-го процесса?
            - В том, что переменные в 1 и 2 процессах независимы.
            - И вность изменения в глоб.пер. 2го процесса бессмысленно.
            - Ведь после завершения скрипта, 2-й процесс завершится, и переменные будут стерты.
            - А глоб.переменные в 1-м процессе никак не будут этим затронуты.
            - А что, если наш скрипт должен как раз изменить значение глоб.переменных?
            - И сделать это именно в том процессе bash, который работает в окне терминала.
            - Например, изменить значение $PATH.

          > Решение
            - Возможно запускать скрипт без создания для него 2-го процесса.
            - Иначе говоря, скрипт будет запущен в том процессе bash, в котормо вызван.
            - Если он вызван в окне терминала, то и исполнится в том же процессе bash, который работает в этом окне.
            - Это позволит скрипту изменить значения глобальных переменных этого процесса.
            - Чтобы это произошло, надо при запуске скрипта оболочки:

                1) Поставить перед его именем точку '.'
                2) Поставить перед его именем пробел ' '

            - Пример скрипта, изменяющего значение глоб.переменной PATH.
            - Именно того процесса bash, который исполняется в окне терминала, в котором будет запущен этот скрипт.

                add2path
                --------------
                #!/bin/bash
                # Добавляет в PATH текущего процесса текущий каталог
                #
                PATH=$PATH":"$(pwd)

            - При запуске ставим перед именем точку или пробел:

                .add2path
                 add2path

      > Стандартные переменные оболочки

        > Суть
          - При выполнении скрипта ему доступен набор стандартных bash-переменных.
          - Их нельзя изменять, а можно только считывать.

        > Список стандартных bash-переменных

          $?      | возвращаемое значение последней команды
          $!      | номер PID последнего запущенного фонового процесса
          $$      | PID текущей оболочки
          $0      | имя файла (символьной ссылки) только что выполненного скрипта оболочки
          $#      | кол-во параметров, переданных скрипту оболочки
          $1-$9   | параметры от 1 до 9, переданные скрипту оболочки
          $*      | массив переданных скрипту оболочки параметров
          $@      | массив переданных скрипту оболочки параметров

          > Комментарий к $1-$9
            - Есть команда shift, которая "смещает" параметры на 1 вправо:
                $1 -> перезаписывается значением $2
                $2 -> перезаписывается значением $3
                $3 -> перезаписывается значением $4
                ...
            - При этом старое значение $1 становится потеряно.
            - Правда, эта фишка особо не нужна, т.к. можно получить массив всех параметров с помощью $* или $@.

          > Комментарий к $?
            - Можно, например, подставить $? в if, как результат последней команды.
            - Хотя в if можно подставить, собственно, и саму команду.
            - Так что фишка тоже не особо нужна.

    > Массивы в сценариях bash

      > Bash >= 4 поддерживает как простые, так и ассоциативные массивы
        - Сабж.

      > Синтаксис для работы с простыми массивами

        x=()              | определить пустой простой массив
        x[0]='a'          | присвоить 0-й элемент массива
        x[1]='b'          | присвоить 1-й элемент массива
        x[2]='c'          | присвоить 2-й элемент массива
        x=('a' 'b' 'c')   | определить массив и инициализировать 3-мя значениями
        echo ${x[1]}      | считать 1-й элемент массива
        echo ${x[@]}      | считать все элементы массива

      > Синтаксис для работы с ассоциативными массивами

        declare -A y              | определить пустой ассоциативный массив
        y[abc]=123                | добавить в ассоц.массив пару ключ-значение
        y[efg]=xxx                | добавить в ассоц.массив пару ключ-значение
        y=( [abc]=123 [efg]=xxx ) | определить ассоц.массив и добавить в него 2 пары ключ-значение
        echo ${y[abc]}            | считать значение ассоц.массива по его ключу

      > Команда mapfile
        - Позволяет построчно преобразовать файл в обычный массив.
        - Например, создадим простой массив z из текстового файла:

            mapfile z < [текстовый файл]

    > Спец.функции bash для обработки последовательностей символов

        1. ${var:-default}
        ------------------
        - if(!var) { return default; }
        - Если var пуста, возвращает default.
        - Пример:

            echo ${x:-123}      | x нет, вернёт 123

        2. ${var:=default}
        ------------------
        - if(!var) { var = default; return default }
        - Если var пуста, назначает var = default, и возвращает default.
        - Пример:

            echo $x             | ''
            echo ${x:=222}      | x нет, вернёт 222
            echo $x             | 222

        3. ${var:+new} [!!!почему то не работает!!!]
        --------------
        - if(var) var = new; if(!var) {}
        - Если var не пуста, заменить её значение на new, и вернуть new.
        - Пример:

            x=10
            ${x:+20}
            echo $x             | 20

        4. ${var:? Error_message}
        -------------------------
        - if(!var) {вывести var и Error_message, и заверш.процесс оболочки} if(var) return var;
        - Если var пуста, вывести имя переменной и сообщение об ошибке. И завершить.
        - Если var не пуста, вернуть содержимое переменной.

            err='сообщение об ошибке'
            echo ${abc:?$err}              | bash: abc: сообщение об ошибке

        5. ${#var}
        ----------
        - Возвращает кол-во символов в переменной.
        - Что-то вроде length или count для переменных.
        - Пример:

            var='Салат'
            echo ${#var}      | 5

        6. ${var#pattern}
        -----------------
        - Вырезать из var начало, которое матчится с pattern, и вернуть оставшуюся часть.
        - Удаляется самый мелкий фрагмент var, содержащий pattern.
        - Можно использовать джокерные символы: * ? [abc].
        - Исходная var при этом не меняется.
        - Пример:

            var=прииивет
            echo ${var#п*и}   | иивет

        7. ${var##pattern}
        -----------------
        - Вырезать из var начало, которое матчится с pattern, и вернуть оставшуюся часть.
        - Удаляется самый крупный фрагмент var, содержащий pattern.
        - Можно использовать джокерные символы: * ? [abc].
        - Исходная var при этом не меняется.
        - Пример:

            var=прииивет
            echo ${var##п*и}   | вет

        8. ${var%pattern}
        -----------------
        - Вырезать из var конец, который матчится с pattern, и вернуть оставшуюся часть.
        - Удаляется самый мелкий фрагмент var, содержащий pattern.
        - Можно использовать джокерные символы: * ? [abc].
        - Исходная var при этом не меняется.
        - Пример:

            var=прииивет
            echo ${var%и*т}   | прии

        8. ${var%%pattern}
        -----------------
        - Вырезать из var конец, который матчится с pattern, и вернуть оставшуюся часть.
        - Удаляется самый крупный фрагмент var, содержащий pattern.
        - Можно использовать джокерные символы: * ? [abc].
        - Исходная var при этом не меняется.
        - Пример:

            var=прииивет
            echo ${var%%и*т}   | пр

        9. ${var/find/replace}
        ----------------------
        - Поиск в var 1-го совпадения с шаблоном find, и замена его на replace.
        - Можно использовать джокерные символы: * ? [abc].
        - Исходная var при этом не меняется.
        - Пример:

            var='абв абв абв абв'
            echo ${var/абв/ууу}     | ууу абв абв абв

        10. ${var//find/replace}
        ----------------------
        - Поиск в var всех совпадений с шаблоном find, и замена их на replace.
        - Можно использовать джокерные символы: * ? [abc].
        - Исходная var при этом не меняется.
        - Пример:

            var='абв абв абв абв'
            echo ${var//абв/ууу}     | ууу ууу ууу ууу

        11. ${!var}
        - Вернуть значение переменной, имя которой является значением var.
        - Пример:

            abc=10
            xyz=abc
            echo ${!xyz}      | 10

    > Функция read: обработка пользовательского ввода
      - С помощью read можно обрабатывать пользовательский ввод.
      - Это такой местный аналог prompt из javascript.
      - Пример bash-скрипта, использующего read:

        testread
        -------------------

          #!/bin/bash
          # Пример bash-скрипта, использующего read

          # Удаление содержимого переменной a
          a=

          # пока a пуста, повторять следующее
          while [ -z "$a" ]: do

            # Вывести пользователю вопрос
            echo -n "Введите число: "

            # Запросить у пользователя ввод в переменную a
            read a

            # Удалить из a все послед.символов, кроме цифр от 0 до 9, пробела и дефиса
            a=${a##*[^0-9.' '.-]*}

            # Если после этого a окажется пуста, вывести сообщение об ошибке
            if [ -z "$a" ]: then
              echo "Ввод может содержать лишь цифры от 0 до 9, пробелы и дефисы."
            fi

          # Завершить цикл while
          done

          # Вывести на экран значение переменной $a
          echo #a

    > Условные выражения bash

      http://www.faqs.org/docs/bashman/bashref_68.html


  > Справка по важнейшим специальным символам bash

    Программирование
    ----------------
    #!/bin/bash | идентификация оболочки, в которой будет выполняться скрипт (идет 1-й строкой)
    ;           | отделение команд друг от друга
    #           | комментарий
    $           | обозначение переменных
    $!          | номер PID последнего процесса, запущенного в фоновом режиме
    $$          | PID актуальной оболочки
    $0          | имя выполняемого в данный момент файла-скрипта
    $1-$9       | первые 9 параметров, переданных команде
    $#          | кол-во параметров, переданных программе
    $*          | совокупность всех переданных параметров
    $@          | совокупность всех переданных параметров
    $?          | возвращаемое значение послед.команды (0 = OK, или номер ошибки)
    ${...}      | различные спец.функции для обработки последовательностей символов
    [выражение] | сокращённый вариант записи test [выражение]

    Перенаправление потоков и каналы
    --------------------------------
    >           | [команда]   >   [файл]     | вывод в файл (старое содержимое удаляется)
    <           | [команда]   <   [файл]     | файл в стандартный ввод
    2>          | [команда]   2>  [файл]     | ошибки в файл (старое содержимое удаляется)
    >&          | [команда]   >&  [файл]     | вывод и ошибки в файл (старое содержимое удаляется)
    &>          | [команда]   &>  [файл]     | вывод и ошибки в файл (старое содержимое удаляется)
    >>          | [команда]   >>  [файл]     | вывод в файл (дописывает в конце файла)
    &>>         | [команда]   &>> [файл]     | вывод и ошибки в файл (дописывает в конце файла)
    |           | [команда1]  |   [команда2] | вывод команды №1 на ввод команды №2
    | tee       | [команда1]  |   tee [файл] | вывод в окно терминала, и одновременно в файл

    Механизмы подстановки
    ---------------------
    ?                 | любой 1 символ
    *                 | от 0 и более любых символов
    **                | любые файлы и каталоги, в т.ч. из всех подкаталогов
    [abc]             | 1 из указанных в скобках символов
    [a-f]             | 1 из указанного в скобках диапазона символов
    [!abc]            | любой символ, кроме указанных в скобках
    [^abc]            | любой символ, кроме указанных в скобках
    ~                 | ссылка на домашний каталог
    .                 | ссылка на текущий каталог
    ..                | ссылка на родительский для текущего каталог
    ab{1,2,3}         | вернёт ab1 ab2 ab3
    a{1..4}           | вернёт a1 a2 a3 a4
    $[3*4]            | вернёт 12 (производит арифметич.вычисление)
    `команда`         | замена команды результатом её выполнения
    $(команда)        | замена команды результатом её выполнения
    Команда "символ"  | отмена интерпретации любых спец.символов, кроме $
    Команда 'символ'  | отмена интерпретации любых спец.символов, в т.ч. $

    Прочее
    ------
    :           | выполняющаяся команда ничего сейчас не делает
    .           | запуск оболочки без собственного командного подпроцессора (.file соотв.исходному файлу)
    &           | выполнение команды в фоновом режиме
    &&          | выполнение одной команды в завис. от результата другой (к1 && к1)
    ||          | выполнение одной команды в завис. от результата другой (к1 || к2)
    (...)       | выполнение сгрупп.команд в отдельной копии процесса оболочки
    {...}       | группировка команд ( funciton() { ..команды.. } )
    <<end       | переадресация вывода из активного файла до завершения


А9. Как заставить новые окна в Ubuntu открываться, как укажешь

  --------------------------------------
  Подоглавление:

    - Введение
    - Пошаговая инструкция

  --------------------------------------

  > Введение
    - Здесь описано, как заставить новые окна в Ubuntu открываться укажешь.
    - Например, в левом верхнем углу.

  > Пошаговая инструкция

    1. Установить программу CompizConfig
      - Для этого ввести команду:

          sudo apt-get install compizconfig-settings-manager

    2. Открыть программу CompizConfig
      - Это графическая программа.
      - Чтобы её запустить, надо ввести в окне терминала:

          ccsm

    3. Перейти в "Управление окнами" → "Размещение окон"
      - И здесь изменить "Режим множественного вывода".
      - По умолчанию установлено значение "Использовать активное устройство вывода".
      - А надо установить "Использовать устройство вывода с курсором".
      - Тогда окно будет открыто в развернутом виде на том экране, где курсор.


А10. Файлы и каталоги: необходимые для работы основы

  ======================================
  Подоглавление:

    - Основные факты о файлах в Linux
    - Корневой каталог / , личный каталог ~ , Каталоги . и ..
    - Джокерные символы
    - Скрытые файлы
    - Особые виды файлов
    - Ссылки на файлы
    - Как определяется MIME-тип файла
    - Поиск файлов
    - Права доступа к файлам
    - Файлы-устройства

  ======================================

  Основные факты о файлах в Linux
  ---------------------------------

    - В Linux почти всё является файлами.
    - Каталоги также являются файлами.
    - MAX длина имени файла 255 символов.
    - Имена файлов чувствительны к регистру.
    - В имени файла может содержатьс сколько угодно точек.
    - Файлы, имена которых начинаются с точки, считаются скрытыми.
    - Размер файлов зависит от ФС, практически не ограничен, может составлять терабайты.


  Корневой каталог / , личный каталог ~ , Каталоги . и ..
  -------------------------------------------------------

    > Корневой каталог /
      - Адрес корневого каталога файловой системы в Linux: /
      - Перейти к нему можно так:

          cd /

    > Личный каталог ~
      - Каждый пользователь в Linux имеет личный каталог.
      - Личные каталоги находятся по адресу: /home/[логин пользователя]
      - У пользователя "Администратор" также есть свой личный каталог.
      - Перейти в свой ЛК можно так:

          cd ~

    > Каталоги . и ..
      - В каждом каталоге есть подкаталоги . и ..
      - Файл . ссылается на текущий, а .. на каталог-родитель.
      - Таким образом, перейти к каталогу-родителю можно так:

          cd ..

      - А скопировать файл /home/gekkman/file в текущий каталог можно так:

          cp /home/gekkman/file .


  Джокерные символы
  -----------------

    Основы
    ------

      > Обрабатываются оболочкой
        - Интерпретацие джокерных символом занимается командная оболочка, а не запускаемая команда.

      > Собственно, сами джокерные символы

        *         | от 0 и больше любых символов (кроме точки, с которой может начинаться имя файла)
        ?         | ровно 1 любой символ (кроме точки, с которой может начинаться имя файла)
        [abc]     | ровно 1 любой символ из перечисленных в квадратных скобках
        [!abc]    | ровно 1 любой символ, кроме перечисленных в квадратных скобках

      > Примеры

        *         | все файлы
        *graf*    | файлы, содержащие в имени строку "graf"
        [a-d]*    | файлы, начинающиеся с буквы от a / b / c / d
        *.[ch]    | файлы, заканчивающиеся на .c или .h
        */*.tex   | файлы, заканчивающиеся на .tex, и находящиеся в любом подкаталоге текущего каталога

      > Пример использования
        - Скопировать все файлы, заканчивающиеся на .c из каталога project в текущий каталог.

          cp project/*.c .

    Обработка каталогов с помощью */.
    ---------------------------------
      - Обработать все каталоги в текущем каталоге не рекурсивно (но не файлы) можно с помощью комбинации */.
      - Она охватывает все "файлы", содержащие ссылку . на самих себя, а это и есть каталоги.
      - Вывести все каталоги в текущем (не рекурсивно):

          echo */.

      - Поиск файла, оканчивающегося на ".tex", в текущем каталоге рекурсивно:

          find . -name '*.tex'

    Массовое переименование файлов невозможно
    -----------------------------------------
      - Допустим, требуется переименовать все *.x файлы в *.y
      - Такая команда НЕ сработает:

          mv *.x *.y

      - Потому что за интерпретацию джокерных символов отвечает оболочка, а не команда mv.
      - В итоге вместо *.x она подставит все такие найденные файлы, и вместо *.y аналогично.
      - Получится что-то вроде: mv a.x b.x c.d d.y e.y f.y
      - Это не соответствует синтаксису команды, и не сработает.
      - Итого, команда mv в принципе не может переименовать более 1 файла за 1 раз.
      - Решить эту проблему можно с помощью небольшой программки на bash.

    Проблема с поиском скрытых файлов посредством .*
    ------------------------------------------------
      - Проблема в том, что в выборку будут включены не только лишь скрытые файлы.
      - Но и ссылки на каталоги . и ..
      - Эту проблему можно обойти, задав следующую схему поиска:

          .[!.]*    | все файлы, начинающиеся с точки, далее следует MIN 1 символ-не-точка, и далее любое кол-во символов

      - Универсальным вариантом является команда find. Найти все скрытые файлы в текущем каталоге:

          find -maxdepth 1 -type f -name '.*'


  Скрытые файлы
  -------------

    - Файлы, имя которых начинается с точки, являются скрытыми.
    - Джокерный символ * игнорирует скрытые файлы.


  Особые виды файлов
  ------------------

    Суть
    ----
      - Кроме обычных, в Linux есть ещё и ряд специфических файлов.
      - В выводе команды ls -lF они обозначаются дополнительным символом в конце их имён.

    Дополнительные символы
    ----------------------

      /   | каталог
      *   | исполняемый файл
      @   | символьная ссылка
      -   | символьное устройство
      +   | блочное устройство
      =   | Pipe, FIFO


  Ссылки на файлы
  ---------------

    Суть
    ----
      - Ссылки, это указания на файлы. Они помогают избежать избыточности в системе.
      - Есть 2 вида ссылок: жёсткие и символьные

    Жёсткие ссылки
    --------------
      - Ссылаются на ID файла во внутренней БД Linux.
      - Работают лишь в пределах одной файловой системы (т.к. у разных ФС разные БД).
      - При удалении ссылки, удаляется и файл из этой БД.
      - Все остальные ссылки при этом начинают указывать в пустоту.

    Символьные ссылки
    -----------------
      - Указывают на исходный файл, используя для этого путь к нему.
      - При удалении символьной ссылки, исходный файл не пострадает.
      - Преимущество перед жёсткими: можно ссылаться на файл в другой ФС, и даже на другом диске.

    Советы при создании символьной ссылки
    -------------------------------------

      Совет №1
      --------
      - Перед созданием символьной ссылки всегда надо перейти в тот каталог, где она будет содержаться.
      - Иначе, она может указать не туда, куда вы ожидали.

      Совет №2
      --------
      - При создании СС лучше избегать абсолютных путей, и использовать относительные.
      - Это позволит избежать проблем при перемещении каталогов.


  Как определяется MIME-тип файла
  -------------------------------

    Суть
    ----
      - Linux и приложения могут различать MIME-типы файлов.
      - Здесь будет описано, как они это делают.
      - Что такое MIME-конфигурация: соответствие между типами файлов и их расширениями.
      - Например:

          .pdf  | application/pdf
          .zip  | application/zip

    Распределенная система
    ----------------------

      Общие файлы конфигурации MIME
      -----------------------------
        - Это центральное место в Linux для MIME-конфигурации.
        - Приложения могут использовать эту конфигурацию, а могут и нет, смотря как запрограммированы.
        - Как правило, приложения, у которых нет собственной MIME-конфигурации, используют центральную.
        - Адреса этих конфигов:

          /etc/mime.types     | глобальная MIME-конфигурация
          /etc/mailcap        | глобальная MIME-конфигурация для программ
          ~/.mime.types       | локальная MIME-конфигурация
          ~/.mailcap          | локальная MIME-конфигурация для программ

      Файлы конфигурации MIME в приложениях
      -------------------------------------
        - Многие приложения имеют свои файлы MIME-конфигурации.

    Как Gnome определяет тип файла
    ------------------------------

      Вариант №1
      ----------
        - По его расширению, используя доступные MIME-конфигурации.

      Вариант №2
      ----------
        - С помощью первого байта.
        - Он знает, какому типу файлов какого формата первый байт соответствует.
        - Эта информация встраивается в команду file при компиляции.
        - В некоторых дистрибутифах стандартную конфигурацию можно изменять с помощью файлов /etc/magic и ~/magic


  Поиск файлов
  ------------

    Инструменты для поиска файлов
    -----------------------------

      which       | поиск программ в PATH-каталогах
      whereis     | поиск файлов в заданных каталогах
      locate      | поиск файлов по имени
      find        | поиск файлов по имени, дате, размеру и т.д.
      grep        | поиск текста в текстовом файле

    Про which
    ---------
      - Ищет указанную команду, т.е. только среди исполняемых файлов.
      - Ищет только в каталогах, указанных в PATH.
      - Следует участь, что PATH админа содержит больше каталогов, чем PATH пользователя.
      - Пример:

          which emacs     | /usr/bin/emacs

    Про whereis
    -----------
      - Ищет информацию о расположении файлов указанного приложения.
      - Просматривает все каталоги, обычно используемые для:
          двоичных файлов, файлов конфигурации, man-страниц, исходного кода.
      - Пример:

          whereis ls       | /bin/ls /usr/share/man/man1/ls.1.gz

      - В примере whereis нашёл исполняемый файл /bin/ls и справочный файл для этой программы.

    Про locate
    ----------

      В общем
      -------
        - Ищет файл по шаблону, который должен содержатсья в его абсолютном пути.
        - Ищет быстро, т.к. ищет не по ФС, а по специальному индексу всех путей ФС.
        - Этот индекс обновляется автоматически, каждое утро (обновить вручную: updatedb).

      Формат паттерна
      ---------------
        - Если --regex не указан, паттерн может содержать джокерные символы.
        - Если паттерн не содержит джок.символы, то ведёт себя как: *ПАТТЕРН*

      Команда НЕ проверяет, существует ли в ФС файл из индекса
      --------------------------------------------------------
        - В индексе файл может ещё существовать, а в ФС уже нет.
        - Это происходит из-за того, что индекс обновляется 1 раз в день, по утрам.

      Индекс и updatedb в Ubuntu
      --------------------------
        - Команды locate и updatedb входят в состав пакета mlocate.
        - Индекс находится в файле /var/lib/mlocate/mlocate.db
        - Индекс ежедневно обновляется cron'ом: /etc/cron.daily/mlocate
        - Конфиг /etc/updatedb.conf определяет, какие каталоги и ФС не будут учитываться при поиске
            (например, CD / DVD / различные буферные каталоги)

      Примеры
      -------

        locate xorg.conf    | искать файлы по паттерну *xorg.conf*
        locate *.conf       | искать файлы по паттерну *.conf

    Про find
    --------

      В общем
      -------
        - Ищет файлы по заданному критерию в файловой системе.
        - Работает медленно, т.к. перебирает файлы в ФС, а не использует индекс.

      Примеры
      -------
      Ряд примеров ещё можно посмотреть здесь:
        https://ru.wikipedia.org/wiki/Find

        1. Искать в текущем и подкаталогах файлы, начинающиеся с .e

            find . -name '.e*'

        2. Искать в /home/gekkman и подкаталогах:
          - Все файлы, заканчивающиеся на .tex
          - Лежащие в каталогах, заканчивающихся на latex

            find /home/gekkman -path '*latex/*.tex'

        3. Найти в /home/gekkman и подкаталогах:
          - Все каталоги.
          - Отсортировать результат в алфавитном порядке.

            find /home/gekkman -type d | sort

        4. Найти в /home/gekkman и подкаталогах:
          - Все файлы, принадлежащие пользователям группы users.
          - Которые были каким-либо образом изменены в течение последних 5 дней:

            find /home/gekkman -group users -mtime -5

          - Которые были каким-либо образом изменены более, чем 5 дней назад:

            find /home/gekkman -group users -mtime +5

          - Которые были каким-либо образом изменены ровно 5 дней назад:

            find /home/gekkman -group users -mtime 5

        5. Удалить все найденные командой find каталоги
          - Только из текущего каталога, но не его каталогов.
          - Имена каталогов должны начинаться с 'po'

            rm -rf $(find . -name -maxdepth 0 'po*')

        6. Произвести поиск по всей файловой системе
          - Искать, начиная с корневого, и во всех подкаталогах.
          - Найти все каталоги, заканчивающиеся на 'ult1'.

            find / -name '*ult1'

        7. Поиск только в конкретном каталоге, но не в подкаталогах
          - Произвести поиск только в каталоге /home/gekkman
          - Искать файлы, начинающиеся с 'my'.

            find /home/gekkman -name -maxdepth 0 'my*'

        8. Поиск по нескольким каталогам и их подкаталогам
          - Произвести поиск в каталоге /home/gekkman/cat1 и его подкаталогах.
          - Произвести поиск в каталоге /home/gekkman/cat2 и его подкаталогах.
          - Искать файл, начинающийся с 're'.

            find /home/gekkman/cat1 /home/gekkman/cat2 -name 're*'

    Про grep
    --------

      В общем
      -------
        - Ищет указанный шаблон в указанных каталогах.
        - Паттерн является регулярным выражением.

      Примеры
      -------
      Ряд примеров ещё можно посмотреть здесь:
        https://ru.wikipedia.org/wiki/Grep

        1. Вывести все строки, начинающиеся с буквы а из файла words.txt

          grep '^a' 'words.txt'

        2. Вывести имена файлов
          - Из каталога etc.
          - Имена которых начинаются на а.

          grep '^a' /etc/*

  Права доступа к файлам
  ----------------------

    - В каждом файле/каталоге сохраняются следующие данные доступа
    - Основные факты
    - Интерпретация вывода команды ls -l
    - Значения битов доступа
    - Специальные биты (SUID, SGID, Sticky)
    - Обозначения типов файлов
    - Права по умолчанию
    - Команда chmod - изменить права доступа к файлу
    - Права доступа к устройствам

  ----------------------

    В каждом файле/каталоге сохраняются следующие данные доступа
    ------------------------------------------------------------
      - Владелец файла.
      - Группа, к которой относится файл.
      - 9 битов доступа к файлу rwxrwxrwx:

        Первые rwx: права владельца файла
        Вторые rwx: права членов группы владельца
        Третьи rwx: права всех остальных

    Основные факты
    --------------
      - Как правило, владельцем файла является его создатель.
      - В качестве группы файла используется основная группа владельца.
      - Значения битов доступа: r - чтение, w - изменение, x - исполнение.
      - Узнать права доступа к файлу можно с помощью команды: ls -l

    Интерпретация вывода команды ls -l
    ----------------------------------
      - Допустим, требуется узнать права доступа и другую информацию о файле /home/gekkman/info.txt
      - Исполняем следующую команду: ls -l /home/gekkman/info.txt
      - Далее представлен её вывод и его интерпретация:


      1   2      2    3      4     5       6        7           8
      ------------------------------------------------------------------------
      -rw-r--r-- 1 kofler kofler 30113 2012-05-11 09:09 /home/gekkman/info.txt
      ------------------------------------------------------------------------

        1. Тип файла (см. обозначения ниже)
        2. Права доступа
        3. Сколько жестких ссылок имеется на файл
        4. Владелец файла
        5. Группа, к которой относится файл
        6. Размер файла в байтах
        7. Дата последнего изменения файла
        8. Имя файла

    Значения битов доступа
    ----------------------

      Для файлов
      ----------

        r   | чтение файла
        w   | изменение файла
        x   | исполнение файла

      Для каталогов
      -------------

        r   | просмотр содержимого каталога командой ls
        w   | (если установлен и бит x) возможность создания файлов в каталоге
        x   | возможность перейти в каталог командой cd

    Специальные биты (SUID, SGID, Sticky)
    -------------------------------------

      SUID
      ----
        - Имеет смысл устанавливать лишь для исполняемых файлов.
        - При исполнении, программа выполняется с правами владельца файла.
        - Например, если владелец - админ, то она будет исполнятсья с его правами.
        - Если установлен, то в программе ls -l для user будет отображаться s вместо x: rws rwx rwx

      SGID
      ----
        - Имеет смысл как для исполняемых файлов, так и для каталогов.
        - Для файлов является аналогом SUID:
            но при выполнении программы используется ID группы, к которой относится файл
            (а не GUID пользователя, работающего с программой)
        - Для каталогов действует так:
            новые файлы, создаваемые в том или ином каталоге, сразу же относятся к той же группе,
            что и этот каталог (а не к группе пользователя, создавшего файл, как происходит обычно)
        - Если установлен, то в программе ls -l для group будет отображаться s вместо x: rwx rws rwx

      Sticky
      ------
        - Имеет смысл для каталогов.
        - Является специфичным именно для Linux (а не других UNIX-систем).
        - Суть:
            в каталогах, в которых файлы может изменять любой пользователь, бит sticky гарантирует,
            что каждый пользователь может удалять только свои файлы, но не файлы коллег.
        - Если установлен, то в программе ls -l для others будет отображаться t вместо x: rwx rws rwt

      Предупрежденя об ошибках - спец.биты использованы не правильно
      --------------------------------------------------------------

        S     | бит SUID или SGID поставлен, но не поставлен бит доступа x (без него работать не будут)
        T     | бит Sticky поставлен, но не поставлен бит доступа x для группы others


    Обозначения типов файлов
    ------------------------

        -   | обычный файл
        d   | каталог (от directory)
        c   | символьное устройство
        b   | блочное устройство
        s   | файл локального сокета (от socket)
        p   | именованный канал (от pipe)
        |   | символическая ссылка

    Права по умолчанию
    ------------------

      - Для файлов:     644 (-rw-r--r--)
      - Для каталогов:  755 (drwxr-xr-x)

    Команда chmod - изменить права доступа к файлу
    ----------------------------------------------

      Синтаксис
      ---------

        chmod [права] [файл]
          -R                  | изменять права файлов/каталогов рекурсивно

      Популярные значения прав доступа
      --------------------------------
      400 (-r--------)    | Владелец имеет право чтения; никто другой не имеет права выполнять никакие действия
      644 (-rw-r--r--)    | Все пользователи имеют право чтения; владелец может редактировать
      660 (-rw-rw----)    | Владелец и группа могут читать и редактировать; остальные не имеют права выполнять никаких действий
      664 (-rw-rw-r--)    | Все пользователи имеют право чтения; владелец и группа могут редактировать
      666 (-rw-rw-rw-)    | Все пользователи могут читать и редактировать
      700 (-rwx------)    | Владелец может читать, записывать и запускать на выполнение; никто другой не имеет права выполнять никакие действия
      744 (-rwxr--r--)    | Каждый пользователь может читать, владелец имеет право редактировать и запускать на выполнение
      755 (-rwxr-xr-x)    | Каждый пользователь имеет право читать и запускать на выполнение; владелец может редактировать
      777 (-rwxrwxrwx)    | Каждый пользователь может читать, редактировать и запускать на выполнение
      1555 (-r-xr-xr-t)   | Каждый пользователь имеет право читать и запускать на выполнение; удалить файл может только владелец этого файла
      2555 (-r-xr-sr-x)   | Каждый пользователь имеет право читать и запускать на выполнение с правами группы(user group) владельца файла
      4555 (-r-sr-xr-x)   | Каждый пользователь имеет право читать и запускать на выполнение с правами владельца файла

      Специальные обозначения при установке прав не 8-ричными значениями
      ------------------------------------------------------------------

        u       | владелец файла (от слова user)
        g       | пользователи, входящие в группу владельца файла (от слова group)
        o       | остальные пользователи (от слова others)
        a       | все пользователи (от слова all)

        +       | добавить указанные права
        -       | убрать указанные права
        =       | установить указанные права

        r       | чтение файла или содержимого каталога
        w       | запись в файл или в каталог
        x       | выполнение файла или чтение содержимого каталога
        X       | выполнение, если файл является каталогом или уже имеет право на выполнение для какого-нибудь пользователя
        s       | установленные атрибуты SUID или SGID позволяют запускать файл на выполнение с правами владельца файла или группы соответственно
        t       | устанавливая t-бит на директорию, мы меняем это правило таким образом, что удалить файл может только владелец этого файла

      Примеры
      -------

        chmod м /home/gekkman/file.txt                | установить права 755
        chmod u=rwx,g=rx,o=rx /home/gekkman/file.txt  | установить права 755 (rwxr-xr-x)

    Права доступа к устройствам
    ---------------------------

  Файлы-устройства
  ----------------

    ... написать по требованию ...






А11. Структура каталогов в Ubuntu

  Введение
  --------
    - В ОС Linux файловая система имеет организованную, конкретную структуру.
    - Каждый каталог имеет своё предназначение, задуманное авторами.
    - В этой граве будет описано предназначение каждого из каталогов в корне ФС.

  Дерево каталогов в корне файловой системы Ubuntu 14.04
  ------------------------------------------------------

    /
      bin             | ссылка на usr/bin
      boot            | ядро, файлы для загрузки ОС (обычно с помощью GRUB), конфиги загрузчиков
      cdroom          | сюда монтируется диск, вставленный в CD-ROM
      dev             | файлы устройств (создаются "на лету" системой udev), содержатся в оперативке и не сохраняются после перезагрузки
      etc             | место для конфигов
      home            | файлы пользователей
      lib             | библиотеки для программ или символьные ссылки на них
      lib64           | аналог lib, только 64-битные
       lib64/modules  | модули ядра, подключаемые "на лету"
      media           | сюда монтируются файловые системы
      mnt             | сюда монтируются временные ФС на съёмных носителях (CD, USB, внешние жесткие диски)
      opt             | каталог для доп.программного обеспечения (используется редка, т.к. не понятно, какое ПО считать доп.)
      proc            | подкаталоги для всех процессов, выполняемых в настоящий момент (не настоящих файлах), отражает внутреннее управление процессами в Linux
      root            | содержит файлы root-пользователя (админа)
      run             | файлы с ID процессов, доп.инфа по некоторым системным службам
      sbin            | команды для управл.системой, могут выполняться лишь админом
      srv             | данные по серверным процессам (/srv/www - apache, /srv/ftp - для FTP, и т.д.)
      sys             | файловая система sysfs, сообщает инфу о состоянии компьютера
      tmp             | содержит временные файлы запущенных программ и процессов, самоочищается при перезагрузке системы
      usr             | включает все польз.программы, полноценную X-систему, исходные коды Linux и т.д. Содержимое изменяется при установке пакетов и выполнение обновлений.
       usr/bin        | исполняемые программы
      var             | содержит изменяющиеся файлы
       var/adm        | административные файлы
       var/lock       | блокирующие файлы, предотвращающие доступ к устройствам для пользователей, не имеющих на это права
       var/log        | логи
       var/mail       | файлы электронных сообщений
       var/spool      | сохранённые в буфере файлы для вывода на печать, новостные файлы и т.д.


А12. Работа с процессами

  ======================================
  Подоглавление:

    - Основные факты о процессах в Linux
    - Старт программ в Linux
    - Приоритетные и фоновые программы
    - Приоритет процесса
    - Команда top
    - Принудительное завершение процессов
    - Выполнение процессов от имени другого пользователя (su, sudo)
    - Системные процессы (демоны)
    - Автоматический запуск процессов (cron)

  ======================================

  Основные факты о процессах в Linux
  ----------------------------------
    - В Linux термины 'Команда', 'Программа' и 'Задача' являются синонимами.
    - Программный файл отличается от остальных только битом доступа x (является исполняемым).
    - Процесс - исполняющаяся программа, он управляется ядром Linux.

  Старт программ в Linux
  ----------------------
    - Запустить программу можно, написав её имя в окне терминала.
    - Оболочка ищет её во всех каталогах, указанных в PATH.
    - Например, запустим программу myprog:

        myprog

    - А что, если надо запустить программу из каталога, которого нет в PATH?
    - Для этого надо указать абсолютный путь к этой программе.
    - Например, запустим программу /cat1/cat2/myprog

        /cat1/cat2/myprog

  Приоритетные и фоновые программы
  --------------------------------

    Приоритетные
    ------------
      - По умолчанию команда из окна терминала запускается не в фоновом режиме.
      - Например, эта команда запустит firefox не в фоновом режиме:

          firefox

      - Это значит, что окно терминала будет "ждать" завершения запущенного процесса.
      - И пока этого не произойдёт, оно будет находитсья в "подвисшем" состоянии.
      - То есть, никакие другие команды выполнить будет нельзя.
      - Если при этом нажать CTRL + C, процесс завершится, и окно терминала "развиснет".

    Фоновые
    -------
      - Иногда хочется запустить программу из окна терминала.
      - И, при этом, продолжить работать с этим же окном терминала.
      - Не дожидаясь, пока процесс программы завершится, и не открывая другого окна терминала.
      - Для этого, после имени команды надо указать символ &

          firefox &

    Перевод выполнения команды в фоновый режим
    ------------------------------------------
      - Допустим, запустили такую команду, не в фоновом режиме (а хотели в фоновом):

          firefox

      - Конечно, можно остановить её - CTRL + C - и перезапустить в фоновом режиме: firefox &
      - Но лучше поставить её на паузу - CTRL + Z - и возобновить в фоновом командой bg.
      - А если использовать команду fg, то команда продолжит выполнятьсяв приоритетном режиме.

  Приоритет процесса
  ------------------
    - Это число от -20 (наивысший) до 19 (наинизший).
    - Посмотреть приоритет процесса можно командой top в столбце PR.
    - Чем выше PR, тем больше вероятность, что он получит ресурсы, когда они ему понадобятся.
    - Есть также приоритет "rt", он считается наивысшим, даже выше -20.
    - Запустить программу с указанным приоритетом позволяет команда nice.
    - Изменить приоритет уже выполнящейся программы можно командой renice.

  Команда top
  -----------

    Суть
    ----
      - Мониторинг выполняющихся процессов, обновляется автоматически каждые 2 секунды.
      - Процессы сортируются обратно пропорционально тому, сколько потребляют ресурсов.
      - Также имеется дополнительная информация о системе.

    Альтернативы
    ------------

      htop
      ----
        - Лучшая альтернатива для окна терминала - htop.
        - Для её применения требуется установить пакет htop.
        - красивее, имеет доп.функционал (поиск, сортировка, nice, kill).

      gnome-system-monitor
      --------------------
        - Аналог панели задач в windows для gnome.
        - Данная команда просто позволяет запустить оную из окна терминала.

    Значение столбцов
    -----------------

        pid		      | ID процесса (Process ID - PID)
        user	      | Пользователь, с чьими правами выполняется процес
        pr		      | Приоритет процесса. Возможные значения: от -19 до 20.
        ni		      | Верхний предел приоритета программы (по умолчанию 0).
        virt	      | Виртуальная память
        res		      | Резидентная памать (то, что реально процесс занимает)
        shr		      | Совместно используемая память (сколько используют библиотеки программы)
        s		        | Статус
        %cpu	      | % использования CPU
        %mem	      | % использования памяти
        time+		    | Время, которое праграмма уже работает
        command	    | Имя команды

    Статистика системы
    ------------------

        up		        | сколько времени (ЧЧ:ММ) система запущена
        users	        | сколько пользователей в системе
        load average  | средний показатель загрузки системы за последние: 5м, 10м, 15м.

    Статистика процессов
    --------------------

        total		      | сколько всего процессов запущено
	      running	      | сколько выполняется сейчас
	      sleeping	    | сколько в режиме ожидания сейчас
	      stopped	      | сколько остановлено
	      zombie	      | сколько процессов-зомби

    Статистика процессора
    ---------------------

	      us	          | сколько процентов используется в userland
	      sy	          | сколько процентов используется системой (ядром)
	      ni	          | сколько процентов используют процессы, обработанные командой nice
	      id	          | сколько процентов свободно
	      wa	          | сколько процентов затрачивается на ожидание ввода-вывода
	      hi	          | [что-то связанное с виртуальной машиной]
	      si	          | [что-то связанное с виртуальной машиной]
	      st	          | [что-то связанное с виртуальной машиной]

    Статистика памяти
    -----------------

        total		      | всего оперативки есть
	      used		      | оперативки используется
	      free		      | оперативки свободно
	      buffer	      | ?

    Статистика раздела подкачки (swap-раздела)
    ------------------------------------------

        total		      | всего размер раздела подкачки
        used		      | всего задействовано раздела подкачки
        free		      | всего свободно раздела подкачки
        cached	      | ?

  Принудительное завершение процессов
  -----------------------------------

    CTRL + C
    --------
      - Сработает, если надо завершить процесс, запущенный в окне терминала.

    Программы top, htop
    -------------------
      - Имеют функционал для завершения процесса.
      - Т.Е., выполняют kill для указанного в интерфейсе исполняющегося процесса.

    Команда kill [pid]
    ------------------
      - Завершает исполняющийся процесс с id == [pid]

    Команда killall [программа]
    ---------------------------
      - Завершает все исполняющиеся процессы, относящиеся к программе [программа].

    Команда xkill
    -------------
      - Надо ввести в окне терминала команду xkill.
      - А затем щелкнуть мышкой в X по окну, которое надо закрыть.
      - Соотв.процессу будет послан сигнал 9 (завершиться).

  Выполнение процессов от имени другого пользователя (su, sudo)
  -------------------------------------------------------------

    При выполнении программы обычным пользователем есть 2 ограничения
    -----------------------------------------------------------------

      Первое
      ------
        - Рядовые пользователи могут выполнять только такие процессы,
          в которых это допускается в соответствии с правами доступа
          (пользователь, группа, биты доступа r и x)

      Второе
      ------
        - Процессы принадлежат тому пользователю, который их запустил.
        - Они имеют доступ к тем же файлам, что и пользователь.
        - Новые файлы, созданные процессом, также принадлежат пользователю,
          запустившему процесс.

      Вывод
      -----
        - Рядовой пользователь не может от своего имени выполнять многие административные задачи.
        - Однако, есть способы обычному пользователю их выполнять с помощью su, sudo, ssh.

    Ограничения на вход в систему от имени root
    -------------------------------------------

      Root может войти в систему только через вирт. терминал
      ------------------------------------------------------
        - Традиционно в UNIX суперпользователь может войти в систему только с виртуального терминала.
        - То есть, через ssh войти в систему от имени root нельзя.

      В Ubuntu root-аккаунт по умолчанию отключен
      -------------------------------------------
        - Но его можно включить.

    Как включить root-аккаунт в ubuntu
    ----------------------------------
      1. Устанавливаем root пароль. Введите в терминал:
          sudo passwd root
      2. Включаем пункт «Введите логин». Введите в терминал:
          gksu gedit /etc/lightdm/lightdm.conf
         В конце файла допишите:
          greeter-show-manual-login=true
      3. Перезагружаем lightdm. Введите в терминал:
         sudo service lightdm restart

    Команда su
    ---------

      Суть
      ----
        - Изменяет ID пользователя в текущей сессии.
        - Так можно стать любым пользователем, если:

            1. Это разрешено нашему основному пользователю.
            2. Известны пароль и логин пользователя, которым требуется стать.

        - В большинстве дистрибутивов работает только с текстовыми командами.

      О важности использования параметра -l
      -------------------------------------
        - Внимание! Необходимо использовать параметр -l.
        - Т.О. гарантируется, что стартовые файлы, обеспечивающие вход в систему (определяющие PATH), будут прочитаны.

      Пример использования
      --------------------

        - Например, станем пользователем с логином mike и паролем 123:

              su -l mike      | хотим стать пользователем mike
              123		          | в ответ на запрос вводим пароль от аккаунта

    Команды gksu
    ------------
      - Как было указано выше, su действует в основном для консольных программ.
      - А для запуска X-программ в Gnome следует использовать gksu.

    Команда sudo в Ubuntu
    ---------------------

      Суть
      ----
        - Предоставляет опред.пользователям опред.права администратора.
        - Каким пользователям какие root-права даны описано в /etc/sudoers.
        - В итоге:
          1. Соотв.программы выполняются при применении sudo от имени администратора.
          2. Обычные польз-ли могут выполнять ряд админ.задач, не зная root-пароля.

      Чей пароль надо вводить при использовании sudo
      ----------------------------------------------
        - Пользователь должен вводить пароль от своего аккаунта, а не root-пароль.
        - Программа sudo запоминает пароль на 15 минут.

      Sudo ведёт логи
      ---------------
        - Логи всех удачных и не очень попыток выполнить с её помощью команды.
        - ПОсмотреть их можно в файле: /var/log/messages.

      Настройка sudo
      --------------

        Основное
        --------
          - Осуществляется в файле sudoers.
          - В нём есть 3 столбца, которые обозначают:
            1. Имя пользователя
            2. Имя компьютера
            3. Имя команды, которую пользователю даётс право выполнять.
          - Например:

              kathrin uranus=(ALL) /sbin/fdisk

          - Многочисленные варианты синтаксиса смотри в: man sudoers

        Настройка с помощью visudo
        --------------------------
          - Из соображений безопасности sudoers лучше редактировать программой visudo.
          - Перед сохранением visudo проверяет синтаксис и гарантирует его правильность.
          - Это особенно важно в Ubuntu, где по умолчанию root-пользователь отключен.
          - И если накосячить в sudoers, то будет неприятно.

      Sudo без пароля
      ---------------
        - Можно позволить опред.пользователю выполнять программу без ввода пароля.
        - Это помогает сэкономить время, и не вводить пароль для выполнения часто используемых программ.
        - Пример, как это сделать в sudoers:

            kofler ALL=(ALL) NOPASSD: ALL

        - Это будет работать, если в sudoers отсутствую другие строки, требующие указать пароль.

  Системные процессы (демоны)
  ---------------------------

    Суть
    ----
      - Демоны (daemons) - фоновые процессы, предназначенные для управления системой.
      - Демоны в Linux соответствуют службам в Windows.

    Потоки ядра
    -----------
      - Кроме обычных демонов, существуют так называемые "потоки ядра".
      - Они не являются настоящими программами.
      - Опознать их можно по тому, что рядом с их названиями указано [px axu].
      - Большинство из них занимаются выполнением низкоуровневых задач.

    Запуск демона вручную в Ubuntu
    ------------------------------
      service [имя] start
      start [имя]

    Остановка демона вручную в Ubuntu
    ---------------------------------
      service [имя] stop
      stop [имя]

    Перезапуск демона вручную в Ubuntu
    ----------------------------------
      service [имя] reload
      service [имя] restart
      reload [имя]
      restart [имя]

    Автоматический старт демонов при запуске компьютера
    ---------------------------------------------------

      Основное
      --------
      - В Ubuntu службы сконфигурируются нужным образом уже при установке пакетов.
      - Управлять автостартом демонов удобно программой sysv-rc-conf из одноимённого пакета.
      - Для кажодого демона можно указать, на каком из уровней работы системы он будет работать.
      - Рекомендуется отключать лишние демоны, чтобы они не отъедали лишние ресурсы у системы.

      Какие бывают уровни выполнения системы бывают в Ubuntu
      ------------------------------------------------------

        1	      | Однопользовательский режим работы. Система инициализирует
                  минимум служб и даёт единственному пользователю (как правило,
                  суперпользователю) без проведения аутентификации командную строку.
                  Как правило, этот режим используется для восстановления системы.
                  Запускаются все процессы из /etc/rc1.d

        2	      | Многопользовательский режим. Пользователи могут работать
                  на разных терминалах, вход в систему с процессом аутентификации

        3	      | Многопользовательский сетевой режим. В отличие от предыдущего
                  уровня, осуществляется настройка сети и запускаются различные
                  сетевые службы

        4	      | Не имеет стандартного толкования и практически не используется

        5	      | Запуск графической подсистемы. По сравнению с уровнем 3 производится
                  также старт графической подсистемы X11. Вход в систему осуществляется
                  уже в графическом режиме

        6	      | Перезагрузка системы. При включении этого режима останавливаются все
                  запущенные программы и производится перезагрузка

        0	      | Остановка системы (halt). Работа системы должна быть прекращена

        S	      | Первый уровень в процессе загрузки. Будет запущен скрипт
                  /etc/init.d/rcS и все процессы в /etc/rcS.d.

      Где располагаются скрипты запускаемых демонов
      ---------------------------------------------
        - В каталогах: /etc/rc[номер уровня].d/
        - Где [номер уровня] надо заменить на оный.



  Автоматический запуск процессов (cron)
  --------------------------------------

    Суть
    ----
      - Это демон, который автоматически запускает процессы.
      - Вот, что он делает:
        1. Активируется 1 раз в минуту.
        2. Анализирует все файлы crontab.
        3. Запускает указанные в них программы, если настало их время.

    Как всё работает
    ----------------

      Глобальная настройка
      --------------------
        - Производится в файле /etc/crontab
        - Чтобы его отредактировать, команда: chrontab -e
        - В Ubuntu здесь по умолчанию указано следующее:

          SHELL=/bin/bash                             | в какой оболочке выполнять команды
          PATH= ...                                   | в каких каталогах искать команды

          17 * * * *      ...     /etc/cron.hourly    | [каждый час] запускает все скрипты из этого каталога на 17-й минуте каждого часа
          25 6 * * *      ...     /etc/cron.daily     | [лишь однажды, если установлен Anacron] запускает все скрипты из этого каталога ежедневно в 6:25
          47 6 * * 7      ...     /etc/cron.weekly    | [лишь однажды, если установлен Anacron] запускает все скрипты из этого каталога еженедельно, в воскресенье, в 6:47
          52 6 1 * *      ...     /etc/cron.monthly   | [лишь однажды, если установлен Anacron] запускает все скрипты из этого каталога в первое число каждого месяца, в 6:52

        - Разумеется, можно отредактировать эти строки, удалить, или добавить новые.
        - Столбцы файлов типа crontab и их значение:

            1      2   3    4     5      6            7
            -------------------------------------------------
            минута час день месяц неделя пользователь команда

          1. [0-59] Указывает, в какую минуту часа должна выполнятьсья программа.
          2. [0-23] Указывает, в какой час дня должна выполняться программа.
          3. [1-31] Указывает, в какой день месяца должна выполняться программа.
          4. [1-12] Указывает, в какой месяц года должна выполняться программа.
          5. [0-7] Указывает день недели, в который должна выполняться программа (0 и 7 соответствуют воскресенью)
          6. [имя пользователя] Указывает, от имени какого пользователя выполнять программу (обычно: root)
          7. [команда] Указывает команду, которую требуется выполнить.

      Каталоги /etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly
      -------------------------------------------------------------------------------

        Основное
        --------
          - Они по умолчанию указаны в Ubuntu в /etc/crontab.
          - Также в Ubuntu по умолчанию установлен Anacron.
          - Это означате следующее:
            1. Скрипты из cron.hourly будут выполняться регулярно на 17-й минуте каждого часа.
            2. Скрипты из cron.daily, cron.weekly, cron.monthly будут выполняться лишь
               единожды, в соответствии с расписанием.

        Требования к именам файлов скриптов в указанных каталогах
        ---------------------------------------------------------
          - Они могут состоять из букв, цифр, дефисов и нижних подчеркиваний.
          - Внимание! Если в имени будет точка, run-parts проигнорирует такой сценарий!

        Планировщик задач Anacron
        -------------------------

          Суть
          ----
            - Наряду с Cron в большинстве дистрибутивов установлен Anacron.
            - Задача Anacron обеспечить ежедневное, еженедельное, ежемесячное выполнение задач.
            - Полезен, когда компьютер используется с перерывами (выключается).
            - Благодаря Anacron, "пропущенные" при выкл.компе задачи будут выполнены при его включении.

          Выполняет задачу лишь единожды, в отличие от Cron'а
          ---------------------------------------------------
            - Выполнил 1 раз, и больше не выполняет.
            - Anacron сохраняет факт выполнения задачи в /var/spool/anacron.
            - Т.О. исключается ситуация, когда одна и та же задача будет выполнена дважды.
            - Управляется из каталога /etc/anacrontab.
            - Конфигурация по умолчанию вполне подходит.

          Применение на сервере не целесообразно
          --------------------------------------
            - Поскольку сервер может работать неделями без перерывов.

          Настройка по умолчанию в Ubuntu
          -------------------------------
            - Вообще, настраивается в /etc/crontab.
            - По умолчанию установлен для каталогов /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly.
            - Для каталога же /etc/cron.hourly настроен обычный Cron.
            - На сервере целесообразно отключить Anacron, и поставить обычный Cron для всех каталогов.
            - Вот как выглядит строка из /etc/crontab для Cron:

              17 * * * *   root   cd / && run-parts --report /etc/cron.hourly

            - А вот как выглядит строка из /etc/crontab для Anacron:

              25 6 * * *   root   test -x /usr/sbin/anacron || ( cd / && run-parts -- report /etc/cron.daily )


А13. Сеть

  ======================================
  Подоглавление:

    - Набор команд для определения состояния сети
    - SSH: работа с удалённым компьютером

  ======================================

  Набор команд для определения состояния сети
  -------------------------------------------

    Команда ifconfig - показать все сетевые интерфейсы
    --------------------------------------------------
      - Возвращает список работающих сетевых интерфейсов.
      - Обозначения важнейших сетевых интерфейсов:

          eth[№]    | Ethernet
          wlan[№]   | Wireless
          ppp[№]    | Модем, ADSL или VPN
          io        | Позволяет локальным программам обмениваться инфой через сетевой протокол

    Команда ping - "прозвонить" указанный хост
    ------------------------------------------
      - Каждую секунду отсылает пакет на [хост], и получает (или не получает) ответ.
      - Указав в качестве хоста какой-нибудь "точно работающий" сайт (google.com), можно протестировать доступ к интернету.

    Команда traceroute - отслеживание пути пакетов
    ----------------------------------------------
      - Отслеживает и показывает путь, который преодолевает пакет с нашего компьютера до указанного хоста.
      - По умолчанию программа предпринимает 3 попытки.
      - Команда не работает, если на пути пакета стоит брандмауэр, блокирующий порт UDP 33434, и возвращает для всех последующих этапов лишь звёздочки.

    Команда mtr - комбинирует ping и traceroute
    -------------------------------------------
      - Выводит результат, похожий на результат команды traceroute.
      - Но обновляет его каждую секунду, как команда ping.


  SSH: работа с удалённым компьютером
  -----------------------------------
  -- Подоглавление
  ----------------

    - Основные факты
    - Установка SSH-сервера на Ubuntu
    - Конфигурация и защита

      - Базовая информация
      - Автоматические инструменты взлома общедоступных SSH-серверов
      - Лучше отключить возможность войти в систему через SSH от имени администратора
      - Рекомендуется изменить стандартный SSH-порт с 22 на любой другой
      - Автоматический бан по IP при попытке взлома пароля брутфорсом

    - Использование ключей для аутентификации, отказ от оной через логин/пароль

      - Суть вкратце
      - Подробная инструкция

    - Работа с SSH с точки зрения клиента

  ----------------


    Основные факты
    --------------
      - SSH (Secure Shell) позволяет управлять удалённым компьютером через сеть.
      - SSH позволяет выполнять как текстовые команды, так и X-команды.
      - Для работы через SSH с компьютером-сервером, на нём должен быть становлен SSH-сервер.

    Установка SSH-сервера на Ubuntu
    -------------------------------
      - Требуется установить пакет openssh-server:
          sudo apt-get install openssh-server
      - После этого демон sshd сразу запустится автоматически.

    Установка SSH-клиента на Ubuntu
    -------------------------------
      - Требуется установить пакет openssh-client:
          sudo apt-get install openssh-client

    Конфигурация и защита
    ---------------------

      Базовая информация
      ------------------
        - Конфиги лежат в /etc/ssh.
        - За конфигурацию SSH-сервера отвечает конфиг sshd_config.
        - SSH-сервер должен работать "с ходу", так что можно конфиг не трогать.
        - По умолчанию SSH-сервер работает через IP-порт 22.

      Несколько советов по конфигурации
      ---------------------------------

        1. Инфа по конфигурационным директивам в /etc/ssh/sshd_config:
          - man sshd_config
          - С комментариями на русском языке (версия Ubuntu 9.10):
              http://help.ubuntu.ru/wiki/ssh

        2. Перед редактированием файла sshd_config надо создать его резервную копию
          - И защитить эту копию оригинального конфига от записи.
          - Её можно использовать, или для восстановления повреждённого конфига.

              sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.original
              sudo chmod a-w /etc/ssh/sshd_config.original

        3. Примеры конфигурационных директив, которые можно изменить:
          - После изменений надо сохранить файл и перезагрузить sshd:
              sudo /etc/init.d/ssh restart
          - Примеры директив:

            Port 2222                     | изменить SSH-порт на 2222
            PubkeyAuthentication yes      | разрешить аутентификацию через ключ
            Banner /etc/issue.net         | показывать содержимое /etc/issue.net в качестве шапки перед аутентификацией

        4. Если доступ к серверу только через SSH, надо ОЧЕНЬ осторожно редактировать конфиг
          - Если допустить ошибку /etc/ssh/sshd_config, сервер может заблокироваться.
          - И не факт, что удастся получить к нему доступ после перезагрузки.
          - Поэтому нужно быть очень осторожным, редактируя sshd_config на удалённом сервере.

      Автоматические инструменты взлома общедоступных SSH-серверов
      ------------------------------------------------------------
        - Их могут применять злоумышленники.
        - Такие инструменты могут автоматически искать в сети общедоступные SSH-сервера.
        - А найдя, автоматически подбирать к ним пароли.
        - Подобные действия регистрируются в /var/log/auth_log.
        - Как следствие:

          1. Применять простые пароли не безопасно.
            - Их можно взломать быстро, даже имея мощность обычного компьютера.

          2. Применять аутентификацию с помощью паролей вообще не безопасно
            - Ведь скорость подбора пароля зависит от мощности компьютера злоумышленника.
            - А что, если ему доступен целый вычислительный кластер, или суперкомпьютер?
            - Поэтому, лучше применять аутентификацию с помощью ключей.

      Лучше отключить возможность войти в систему через SSH от имени администратора
      -----------------------------------------------------------------------------
        - Потому что имя учётной записи администратора известно: root.
        - И злоумышленнику остаётся угадать лишь пароль.
        - Отключить можно в /etc/ssh/sshd_config:

            PermitRootLogin = no

        - Чтобы изменения вступили в силу, sshd должен заново считать конфиги:

            service ssh reload

      Рекомендуется изменить стандартный SSH-порт с 22 на любой другой
      ----------------------------------------------------------------
        - Большинство автоматических программ взлома SSH-серверов отслеживают лишь порт 22.
        - Поэтому, смена 22 на любой другой не используемый порт, существенно повышает безопасность.
        - Недостатки этого метода:
          1. При серьёзной атаке, злодей всё равно просканирует все порты.
          2. Большинство брандмауэров не блокируют порт 22, и, скорее всего, будут блокировать порт, который вы поставите.
            - Так что придётся в брандмауэре дополнительно указать, чтобы не блокировал новый порт.

      Автоматический бан по IP при попытке взлома пароля брутфорсом
      -------------------------------------------------------------
        - Есть готовый скрипт DenyHosts.
        - При попытке брутфорса он добавляет IP злодея в /etc/hosts.deny
        - В зависимости от конфига, IP остаётся там вечно или на указанное время.

    Использование ключей для аутентификации, отказ от оной через логин/пароль
    -------------------------------------------------------------------------

      Суть вкратце
      ------------
        - Аутентификация по ключам SSH использует два ключа: секретный и открытый.
        - Их можно создать текстовой командой ssh-keygen на машине клиента.
          - По умолчанию открытый ключ сохраняется в "~/.ssh/id_dsa.pub".
          - По умолчанию секетный ключ сохраняется в "~/.ssh/id_dsa".
        - Секретный ключ шифруется фразой-паролем.
          - В будущем при выполнении любой команды через SSH придётся её указывать.
          - Если при создании оставить её пустой, то секретный ключ зашифрован не будет, и пароль при выполнении команд указывать не придётся.
          - Опасность заключается в том, что если злодей получит не зашифрованный секретный файл-ключ, он получит доступ к серверу.
        - Затем надо воспользоваться командой ssh-copy-id:
          - Она копирует ключ id_dsa.pub на указанный сервер.
          - И добавляет его в файл ~/.ssh/authorized_keys.
          - Но она не сработает, если сервер допускает аутентификацию только через ключ (т.к. она ещё не настроена).
          - Поэтому, в этот момент, должна быть доступна аутентификация через пароль.
        - В конце рекомендуется изменить права доступа к authorized_keys на 600
          - Читать и изменять его должны иметь возможность лишь авторизованные пользователи.

      Подробная инструкция
      --------------------

        1. Создать открытый и секретный ключи на машине-клиенте.
          - Использовать криптографический алгоритм DSA (Digital Signature Algorithm)
          - Ввести команду:

              ssh-keygen -t dsa

          - При запросе пароля просто нажать enter.
          - По умолчанию открытый ключ сохраняется в "~/.ssh/id_dsa.pub".
          - По умолчанию секетный ключ сохраняется в "~/.ssh/id_dsa".

        2. Записать открытый ключ в файл authorized_keys сервера.
          - В этот момент аутентификация по логину/паролю на сервере должна работать.
          - Ввести команду (заменив значения в кв.скобках на актуальные):

              ssh-copy-id [имя пользователя]@[удалённый хост]

        3. На сервере изменить права доступа к authorized_keys на 600
          - Для этого ввести команду:

              chmod 700 ~/.ssh
              chmod 600 ~/.ssh/authorized_keys

          - Если этого не сделать, м.б. проблемы с входом в систему через ключи.
          - Это объясняется различными настройками системы безопасности.
          - Если SSH-сервер работает в режиме STRICT-mode (по умолчанию),
            то файл authorized_keys учитывается лишь в том случае, если
            достаточно жёстко заданы права доступа.
          - А при создании файла ключей комендой ssh-copy-id, права задаются не
            достаточно жёстко.

    Работа с SSH с точки зрения клиента
    -----------------------------------

      Установить соединение с сервером
      --------------------------------
        - Можно с помощью команды ssh по шаблону: ssh [логин]@[хост]
        - В результате будет установлено интерактивное соединение.
        - Подробнее о ssh см. в man ssh.
        - Пример:

            ssh root@195.24.24.12

      Выполнить 1 команду через ssh
      -----------------------------
        - Иногда интерактивное соединение не нужно.
        - А требуется выполнить всего-лишь одну команду.
        - Это можно сделать по шаблону: ssh [логин]@[хост] [команда]
        - Например, скопируем дерево каталогов htdocs с сервера serv.ru
          в локальный каталог ~/mycat, используя команду tar:

            ssh root@serv.ru tar -cf - htdocs | tar -xC ~/mycat/ -f -

      SSH и X
      -------
        - Соединение SSH позволяет выполнять и X-программы.
        - Для этого либо/либо:

          1. X-программу надо запускать с параметром -X.
          2. /etc/ssh_config содержит "ForwardXll yes" (тогда параметром -X можно пренебречь)

        - Окно программы откроется у клиента, и он сможет с ним работать так,
          как будто программа запущена на машине клиента, а не сервера.
        - Пример (запусу X-emacs на сервере с клиента):

            ssh -X root@serv.ru
            xemacs &

      Копирование файлов через SSH с помощью scp
      ------------------------------------------

        Общая информация
        ----------------
          - Для копирования фалов через SSH применяют команду scp.
          - SCP: Secure CoPy.
          - Её синтаксис таков (скопировать file1 с host1 в file2 на host2):
              scp [[user1]@host1]:[file1] [[user2]@host2]:[file2]

        Замечания по опциональным составляющим команды копирования
        ----------------------------------------------------------
          1. Указывать host1 и host2 не нужно, когда имеется в виду localhost.
          2. Не следует задавать user1, когда имеется в виду текущий пользователь.
          3. Не следует задавать user2, когда на компьютере host2:
            - Должно использоваться текущее имя пользователя с host1.
            - Или имя пользователя user1.
          4. file1 может быть каталогом, в таком случае:
            - Следует задать параметр -r, чтобы можно было скопировать каталог и все его подкаталоги.
          5. file2 не следует указывать, если:
            - Имя файла должно остаться прежним.
            - И файл должен скопироваться в домашний каталог пользователя user2.
          6. Вместо file2 также можно задать целевой каталог:
            - Например, указать домашний каталог ~ пользователя user2.

        Примеры
        -------

          Пример 1
          --------
            - Копируем файл "file.txt" из удаленного сервера на локальный компьютер.
            - Код:

                scp user@remote.host:file.txt /some/local/directory

          Пример 2
          --------
            - Копируем файл "file.txt" с локального компьютера на удаленный сервер.
            - Код:

                scp file.txt user@remote.host:/some/remote/directory

          Пример 3
          --------
            - Копируем папку "dir1" с локального хоста в директорию "dir2" на удаленном хосте.
            - Код:

                scp -r dir1 user@remote.host:/some/remote/directory/dir2

          Пример 4
          --------
            - Копируем файл "file.txt" с одного удаленного сервера "remote.host1" на другой удаленный сервер "remote.host2".
            - Код:

                scp user@remote.host1:/directory/file.txt user@remote.host2:/some/directory/

          Пример 5
          --------
            - Копируем файлы "file1.txt" и "file2.txt" с локального компьютера в Ваш домашний каталог на удаленном сервере.
            - Код:

                scp file1.txt file2.txt user@remote.host:~

          Пример 6
          --------
            - Копируем файл "file.txt" с локального хоста на удаленный хост, используя порт 2222.
            - Код:

                scp -P 2222 file.txt user@remote.host:/some/remote/directory

          Пример 7
          --------
            - Копируем файл "file.txt" с локального компьютера в Ваш домашний каталог на удаленном сервере.
              Сохраняем время изменения и время доступа и права копируемого фала.
            - Код:

                scp -p file.txt user@remote.host:~

          Пример 8
          --------
            - Копируем файл "file.txt" с локального компьютера в Ваш домашний каталог на удаленном сервере.
              Увеличиваем скорость работы SCP изменяя алгоритм шифрования с AES-128 (по умолчанию) на Blowfish.
            - Код:

                scp -c blowfish file.txt user@remote.host:~

          Пример 9
          --------
            - Копируем файл "file.txt" с локального компьютера в Ваш домашний каталог на удаленном сервере.
              Ограничиваем ширину канала используемого командой SCP до 100 Kbit/s.
            - Код:

                scp -l 100 file.txt user@remote.host:~

          Пример 10
          ---------
            - Копируем несколько файлов с удаленного хост в текущую директорию на Вашем локальном хосте.
            - Код:

                scp user@remote.host:~/\{file1,file2,file3\} .


А14. Управление пользователями, группами, паролями

  ======================================
  Подоглавление:

    - Общая информация
    - Как осуществляется управление правами доступа к файлам
    - Способы управления пользователями, группами, паролями
    - 3 типа пользователей в Linux
    - Конфигурационные файлы
    - Что делать, если забыл пароль администратора

  ======================================

  Общая информация
  ----------------
    - В Linux на 1 компьютере могут работать несколько разных пользователей.
    - Существуют БД пользователей и групп пользователей в системе.
    - Каждый пользователь состоит min в 1 группе, имени самого себя.
    - Можно настраивать, какой пользователь к каким файлам какой доступ имеет.


  Как осуществляется управление правами доступа к файлам
  ------------------------------------------------------
    - Вместе с каждым файлом сохраняется вся необходимая для этого инфа.
    - А именно: id владельца; список id групп, где он состоит; биты доступа.


  Способы управления пользователями, группами, паролями
  -----------------------------------------------------

    Вариант 1: использовать стандартные графические инструменты Gnome
    -----------------------------------------------------------------
      - Удобный способ управлять пользователями в графическом режиме.

    Вариант 2: с помощью текстовых команд
    -------------------------------------
      - Актуален, если иксы в системе не установлены.
      - А также при автоматизации управления через скрипты.
      - Список программ смотри в библиотеке команд.


  3 типа пользователей в Linux
  ----------------------------

    1. Суперпользователь root
      - Имеет в системе имя root.
      - Имеет не ограниченные права.

    2. Обычный пользователь
      - Это пользователи-люди в системе linux.
      - Имеют неогр.доступ к своим файлам, и огр.доступ к прочему.

    3. Системный пользователь (демоны и служебные программы)
      - Это пользователи-программы в системе linux.
      - Например, за работу Apache отвечает пользователь apache (или httpd).


  Конфигурационные файлы
  ----------------------

    /etc/passwd
    -----------
      - Хранить всю инфу о пользователях, кроме их паролей.
      - Пример строки из этого файла:

          vasyapupkin:x:1000:1000:Vasya Pupkin:/home/vpupkin:/bin/bash

    /etc/group
    ----------
      - Хранит всю инфу о группах пользователей.
      - Пример строки из этого файла:

          vasyapupkin:x:1000:vasyapupkin,petya

    /etc/shadow
    -----------
      - Хранит хэши паролей пользователей.
      - Недоступен для чтения обычным пользователям.
      - Пример строки из этого файла:

        vasyapupkin:$6$Yvp9VO2s$VfI0t.o754QB3HcvVbz5hlOafmO.LaHXwfavJHniHNzq/bCI3AEo562hhiWLoBSqxLy7RJJNm3fwz.sdhEhHL0:15803:0:99999:7:::


  Что делать, если забыл пароль администратора
  --------------------------------------------

    1. Загрузить компьютер другого диска
      - Например: установочного, восстановительного, "живого" диска knoppix

    2. Создать новый каталог на псевдодиске, и смонтировать в него сегмент с Linux
      - Создать новый каталог можно командой mkdir.
      - Смонтировать можно так (пример): mount -t ext4 /dev/xxx /dir

    3. Удалить из /dir/etc/shadow пароль администратора
      - Войти в систему с правами админа без заданного пароля можно лишь из txt-консоли.
      - Такие настройки заданы в /etc/pam.d/commonauth
      - Изменить пароль администратора с помощью passwd.


А15. Логи

  ======================================
  Подоглавление:

    - Общая информация
    - Программа sysklogd (rsyslogd)
    - Журналирование ядра
    - Программа logrotate

  ======================================

  Общая информация
  ----------------

    Ядро, различные инструменты администрирования (PAM, APT, dpkg)
    и большинство сетевых служб протоколируют любые мыслимяе события
    в многочисленных файлах, расположенных в каталоге /var/log.

    Эти логи исплючительно удобны при запуске в эксплуатацию новой
    службы, т.к. помогают обнаружить ошибку конфигурации.

    В ходе эксплуатации сервера такие файлы журналирования часто
    позволяют распознать проблемы с безопасностью.

  Программа sysklogd (rsyslogd)
  -----------------------------

    Предисловие
    -----------

      > Центральный функционал журналирования rsyslogd
        - В системе предусмотрен центральный функционал журналирования.
        - Он обозначается термином Syslog, а программа rsyslogd его реализует.
        - Программу rsyslogd широко использует другие программы системы.
        - В основном, ядро и некоторые инструменты администрирования.
        - Но далеко не все программы используют rsyslogd.

      > Не все программы используют rsyslogd
        - Скажем, Apache, CUPS, Samba используют собственные функции журналирования.
        - И на них, Т.О., глобальный конфиг rsyslogd syslog.conf не влияет.
        - Вместо этого, у каждой из таких программ собственные настройки журналирования.

      > Получить список всех логов, управляемых rsyslog
        - Сначала перейти в каталог: cd /var/log
        - Затем выполнить: ls $(find -user syslog)

    Конфигурация rsyslogd
    ---------------------

      Где лежат конфиги
      -----------------
        - /etc/rsyslogd.conf
        - /etc/rsyslog.d/*.conf
        - /etc/rsyslog.d/50-default.conf  // здесь большая часть настроек в Ubuntu

      Селектор, действие, приоритет
      -----------------------------

        > Общее
          - В конфиге каждое правило занимает 1 строку.
          - Каждое правило состоит из селектора и действия.
          - Каждоый селектор может быть разделен точкой на 2 части:
              [служба].[уровень_приоритета]
          - В одном селекторе можно объединить несколько служб, разделяя запятой.
          - Все программы, использующие syslog, обязаны присваивать своим
            сообщениям службу и приоритет.

        > Селектор, приоритет
          - При указании степени приоритета в селекторе учитываются также
            все степени, находящиеся в иерархии выше.
          - Если требуются уведомления только с определённой степерью
            приоритета, надо ставить перед приоритетом символ =
            Например: mail.=err

        > Действие
          - В качестве действия чаще всего указывают имя одного из логов.
          - Обычно, логи синхронизируются после каждого вывода.
          - Если перед именем файла стоит символ '-', syslog не производит синхронизацию.
          - Это экономир ресурсы машины, но при аварийном завершении некоторые данные можно потерять.

        > Переадресация уведомления к файлам FIFO или каналам
          - Syslog также может переадресовывать данные уведомления.
          - Для этого перед файлом надо поставить символ пайп '|'.

        > Символ * - переадресация на все консоли и всем SSH-пользователям
          - Обычно применяют лишь для критически важных сообщений.

      Какие службы известны syslog
      ----------------------------
        - uth
        - authpriv
        - cron
        - daemon
        - ftp
        - kern
        - lpr
        - mail
        - news
        - syslog
        - user
        - uucp
        - local0 .. local17
        - *                 // означает все службы

      Какие степени приоритета известны syslog (по возрастанию)
      ---------------------------------------------------------
        - none    // без приоритета
        - debug
        - info
        - notice
        - warning
        - err
        - crit
        - alert
        - emerg
        - *       // объединяет все степени приоритета

      Пример конфигурации
      -------------------
        - См. на стр. 278 книги "Linux: установка, настойка, администрирование"


  Журналирование ядра
  -------------------
    - Сообщения ядра записываются в кольцевой буфер 16кб в памяти.
    - При заполнении, работает паттернт первый вошёл, последний вышел.
    - Просмотреть его содержимое можно так:

        dmesg   | просмотреть буфер сообщений ядра
          -c      - и опустошить буфер


  Программа logrotate
  -------------------

    > Суть
      - Как правило, логи постепенно начинают разрастаться.
      - Чтобы контролировать их размер, пользуйтесь программой logrotate.
      - Она ежедневно вызывается скриптом /etc/cron.daily/logrotate
      - Он обрабатывает все логи, описанные в конфиге /etc/logrotate.d
      - Что именно logrotate делает с каждым из логов, зависит от конфига.

    > Процесс работы logrotate

      1. Переименование архивов логов
        - Допустим, есть в архиве 5 файлов-архивов с логами.
        - С индексами от 0 до 4. - Вот как logrotate их переименовывает:

            [имя].4.gz -> [имя].5.gz
            [имя].3.gz -> [имя].4.gz
            [имя].2.gz -> [имя].3.gz
            [имя].1.gz -> [имя].2.gz
            [имя].0.gz -> [имя].1.gz

        - Этот процесс назывют "ротацией".

      2. Удаление старых архивов при привышении опред.лимитов
        - В конфиге задаётся MAX размер архивов с логами.
        - Если он превышается, то старые, не влезшие архивы удаляются.

      3. Переименование актуального лога в [имя].0
        - Сабж.

      4. Создание гового, пустого лога.
        - Сабж.

      5. Перезагрузка демона
        - logrotate заставляет демона заново считать конфиг.
        - Для этого использует команду: /etc/init.d/[имя] reload
        - В результате чего, он "цепляет" новый лог, и пишет уже в него.
        - Демон понимает, что появился новый конфиг, и работает именно с ним.

      6. Программа logrotate архивирует [имя].0
        - Она может сделать это и с некоторой задержкой.
        - Это позволяет избежать конфликта между gz и демоном.

    > Конфигурация
      - Пример конфигурации см. на стр. 280 книги "Linux: установка, настойка, администрирование".


      /etc/logrotate.conf
      -------------------
        - В /etc/logrotate.conf содержатся некоторые установки, действующие
          для logrotate по умолчанию. Эти настройки действительны, если
          программно-специфичные конфиги не содержат иных данных.


      /etc/logrotate.d
      ----------------
        - В /etc/logrotate.d содержатся стандартные настройки для различных
          программ, создающих логи. Эти файлы относятся не к пакету logrotate,
          а к пакетам соответсвующих программ.
        - Например, конфиг для пакета samba лежит в /etc/logrotate.d/samba
        - Это позволяет гарантировать, что файлы установленной версии
          программы подходят, и logrotate информирует каждую службу о переименовании
          файлов регистрации, либо запускает её заново.


А16. Управление программами и пакетами (APT)

  ======================================
  Подоглавление:

    - Ссылки про APT
    - Введение в APT
    - Команды apt-get и aptitude
    - Конфигурация APT
    - Декларирование CD в качестве репозитория
    - Установка APT-ключа
    - Управление пакетами: команда apt-get

      - apt-get update          | загрузить новейшую инфу (описания пакетов) из репозиториев
      - apt-get install [n]     | установить пакет с именем [n]
      - apt-get remove [n]      | удалить пакет с именем [n]
      - apt-get autoremove      | удалить "осиротевшие" пакеты (пакеты-зависимости, которые больше никем не используются)
      - apt-get dist-upgrade    | обновить все пакеты и их зависимости (установить новые/удалить старые если надо)
      - apt-get upgrade         | обновить все пакеты и их зависимости (но не устанавливать новые/не удалять старые)
      - apt-get source [n]      | установить пакет из исходного кода, в каталог [n]

    - Информация о пакетах: команда apt-cache

  ======================================

  Ссылки про APT
  --------------

    # Информация по APT:
        http://apt-rpm.org/


  Введение в APT
  --------------
    - APT, это высокоуровневая система управления для пакетов Debian.
    - На сегодня (2015), представляется наиболее проработанной для Linux.
    - В Ubuntu APT применяется в качестве стандартной СУ пакетами.


  Команды apt-get и aptitude
  --------------------------
    - Для управления пакетами применяются 2 команды из сабжа.
    - Они очень похожи, синтаксис практически одинаковый.
    - В Ubuntu и Debian установлены обе команды.
    - Apt-get по умолчанию применяется в Ubuntu, а aptitude - в Debian.


  Конфигурация APT
  ----------------
    - Производится в 3 файлах:

        /etc/apt/apt.conf.d/*
        /etc/apt/sources.list
        /etc/apt/sources.list.d

    - Про файл /etc/apt/apt.conf.d/*

      - Подробнее можно посмотреть: man apt.conf
      - Содержит немногие базовые настройки.
      - Которые лучше оставить как есть, по умолчанию.

    - Про файл /etc/apt/sources.list

      - Подробнее можно посмотреть: man sources.list
      - Включает построчное опичание репозиториев APT.
      - При необходимости, можно добавлять сюда новые репозитории.
      - Синтаксис каждой строки таков:

            1     2        3            4           5
        -------------------------------------------------------
        pakettyp uri distribution [компонент1] [компонент2] ...

      - Пример:

         1                   2                     3     4       5
        ---------------------------------------------------------------
        deb http://us.archive.ubuntu.com/ubuntu/ utopic main restricted

      - Пояснения:

          1. Тип пакета
            - Тип обычных пакетов Debian: deb
            - А для пакетов с исходным кодом: deb-src

          2. Адрес репозитория
            - APT поддерживает следующие источники и протоколы:

                HTTP
                FTP
                RSH
                SSH
                Обычные каталоги
                CD                | особый случай (команда apt-cdrom)
                DVD               | особый случай (команда apt-cdrom)

          3. Название дистрибутива ОС
            - Ведь на сервере могут быть пакеты для разных дистрибутивов.
            - И даже для разных версий одних и тех же дистрибутивов.

          4,5,... Компоненты дистрибутива
            - Которые можно учитывать.
            - Названия компонентов зависят от конкретного дистрибутива/пакета.
            - Например, в Ubuntu различаются пакеты:

                Название       Приоритет
                -------------------------------
                main          | 4                 высший приоритет
                restricted    | 3
                universe      | 2
                multiverse    | 1                 низший приоритет

            - Скачивается всегда пакет, который в наличии с наивысшим приоритетом.
            - Чем больше число приоритета, тем выше приоритет.


  Декларирование CD в качестве репозитория
  ----------------------------------------
    - В качестве источника данных для APT можно использовать CD.
    - В таком случае, для каждого CD надо выполнить: apt-cdrom add
    - Она считывает метаданные APT-cd и заносит доступные пакеты в файлы кэша.
    - Кроме того, автоматически обновляется файл /etc/apt/sources.list
    - Если apt-cdrom жалуется, что не может найти CD/DVD:

      - Укажите каталог с параметром -d
      - Например: apt-cdrom -d /media/dvd add

  Установка APT-ключа
  -------------------
    - Метафайлы для описания репозиториев зашифрованы крипто-ключами.
    - И так в большинстве APT-источников в интернете.
    - Также, файлы-оглавления APT содержат контрольные суммы для всех пакетов.
    - Такие механизмы контроля позволяют обеспечить постепенное изменение пакета.
    - Однако, механизм действует, исли APT'у известна общедоступная часть ключа.
    - Она позволяет определить происхождение пакета.
    - Чтобы настроить ключ для APT, надо использовать команду apt-key:

        apt-key add [имя файла с ключём].gpg

  Управление пакетами: команда apt-get
  ------------------------------------

    // apt-get update
    //--------------------------//
    // - Загрузить новейшую информацию (описания пакетов) из репозиториев.
    // - Пакеты при этом ни устанавливаются, ни обновляются.
    // - Лучше всего выполнять перед любой установкой/обновлением пакетов.

      apt-get update


    // apt-get install [n]
    //--------------------------//
    // - установить пакет с именем [n]

      Пример
      ------

        apt-get update
        apt-get install apache2

      Пакеты-зависимости
      ------------------
        - Большинство пакетов имеют пакеты-зависимости.
        - Если оные не установлены, то и даннй пакет работать не будет.
        - Команда install перед установкой проверяет наличие всех пакетов-зависимостей.
        - Если каких-то не хватает, то она предложит их также установить.


    // apt-get remove [n]
    //--------------------------//
    // - удалить пакет с именем [n]

      Пример
      ------

        apt-get remove apache2

      Пакеты-зависимости удаляемого пакета НЕ УДАЛЯЮТСЯ
      -------------------------------------------------
        - Сабж.
        - Чтобы и зависимости удалились, использовать autoremove


    // apt-get autoremove
    //--------------------------//
    // - удалить "осиротевшие" пакеты (пакеты-зависимости, которые больше никем не используются)

      Пример
      ------

        apt-get autoremove


    // apt-get dist-upgrade
    //--------------------------//
    // - обновить все пакеты и их зависимости (установить новые/удалить старые если надо)

      Пример
      ------

        apt-get dist-upgrade

      Отличие от upgrade
      ------------------
        - Допустим, изменились межпакетные взаимосвязи.
        - И требуется установить новые пакеты, или удалить старые.
        - Эти операции также выполняются.
        - А вот при upgrade они не выполняются.


    // apt-get upgrade
    //--------------------------//
    // - обновить все пакеты и их зависимости (но не устанавливать новые/не удалять старые)

      Пример
      ------

        apt-get upgrade

      Отличие от dist-upgrade
      -----------------------
        - Допустим, изменились межпакетные взаимосвязи.
        - И требуется установить новые пакеты, или удалить старые.
        - Эти операции также выполняются.
        - А вот при upgrade они не выполняются.


    // apt-get source [n]
    //--------------------------//
    // - установка пакета из исходного кода

      apt-get source [абсолютный путь к пакету]

  Информация о пакетах: команда apt-cache
  ---------------------------------------
    - Позволяет искать пакеты, смотреть инфу о них.
    - Просматривать список доступных/установленных пакетов, и т.д.
    - Список команд смотри в библиотеке команд в начале этого документа.

  Автоматизация обновлений пакетов
  --------------------------------
    - Cron ежедневно выполняет скрипт /etc/cron.daily/apt
    - Скрипт же интерпретирует конфиг /etc/apt/apt.conf.d/*
    - И при необходимости выполняет команду обновления unattended-upgrade
    - Чтобы активизировать автообновления, нужно вручную изменить конфиги:

      /etc/apt/apt.conf.d/10periodic
      ------------------------------

        // Активизировать ежедневные обновления
        APT::Periodic::Unattended-Upgrade "1";


      /etc/apt/apt.conf.d/50unattended-upgrades
      -----------------------------------------

        // Проводить стандартные обновления и обновления системы безопасности
        Unattended-Upgrade::Allowed-Origins {
          "${distro_id} stable";
          "${distro_id} ${distro_codename}-security";
          "${distro_id} ${distro_codename}-updates";
        }

        // Не обновлять следующие пакеты
        Unattended-Upgrade::Package-Blacklist {

        }

        // Прислать электронное сообщение о статусе обновления
        // Unattended-Upgrade::Mail "root@localhost";

    - Минус автообновлений в том, что сервер может перестать работать.
    - Поэтому, лучше уж от них, наверное, отказаться.


А17. Автозапуск bash-скриптов при старте системы

  ======================================
  Подоглавление:

    - Введение
    - Простая инструкция

  ======================================

  > Введение
    - Здесь описана организация автозапуска bash-скриптов при запуске системы.
    - Это полезно, скажем, чтобы запускать всякие сервера.
    - Например, websocket-сервер, или artisan queue:listen.

  > Простая инструкция

    1. Открыть окно терминала сервера

    2. Открыть файл /etc/rc.local
      - Для этого выполнить команду:

          sudo nano /etc/rc.local

    3. В конце, но перед exit 0, дописать следующий код (пример):

        cd "/home/vagrant/projects/zaste.ru"
        php artisan queue:listen &

        # Запустить websocket-сервер
        cd "/home/vagrant/projects/zaste.ru/app/Websocket"
        nohup node socket.js > /dev/null 2>&1 &


А18. Дата, время, NTP-сервер, NTP-демон

  ======================================
  Подоглавление:

    - Введение
    - Что такое NTP-сервер
    - Синхронзировать часы Ubuntu c NTP-сервером
    - 

  ======================================

  > Введение
    - В системе Linux есть часы.
    - Часто точность этих часов играет большую роль.
    - Хотелось бы, чтобы эти часы всегда оставались точными.
    - Для этого их надо синхронизировать с NTP-сервером.

  > Что такое NTP-сервер

    # Общая информация
      - NTP - Network Time Protocol.
      - Сетевой протокол для синхронизации внутренних часов компьютера.
      - NTP использует для своей работы протокол UDP.
      - NTP использует алгоритм Марзулло, предложен Китом Марзулло (Keith Marzullo) из Университета Калифорнии, Сан-Диего.
      - Учитывает даже такую особенность, как время передачи.
      - В версии 4 способен достигать точности 10 мс (1/100 с) при работе через Интернет.
      - NTP — один из старейших используемых протоколов
      - NTP разработан Дэвидом Л. Миллсом (David L. Mills) из университета Дэлавера в 1985 году.
      - Текущая версия (05.08.2015) — NTP 4.
    
    # Часовые слои
      - Слой 0    // высокоточные эталонные приборы (атомные часы, GPS, ГЛОНАСС)
      - Слой 1    // NTP-сервер, соединённые проводом со слоем 0
      - Слой 2    // компьютеры, получающие время по протоколу NTP с NTP-сервера (слой 1)
      - Слой 3    // компьютеры, получающие время от компьютеров слоя 2

  > Синхронзировать часы Ubuntu c NTP-сервером
    - Можно такой командой:

        ntpdate -s ntp.ubuntu.com


  > NTP-демон в Ubuntu
    
    # Общая информация
      - Из коробки в Ubuntu не устанавливается.
      - Периодически запускается и синхронизирует время с NTP-сервером.
      - Пишет отчёты в журнал.

    # Установка
      - Выполнить команду:

          sudo apt-get install ntp

    # Настройка
      - Производится в файле /etc/ntp.conf.
      - Для этого можно использовать nano:

          sudo nano /etc/ntp.conf

      - В этом файле содержится список используемых NTP-серверов.
      - После изменения конфига, надо перезапустить ntpd:

          sudo service ntp restart

      - Просмотреть статус ntpd можно так:

          sudo ntpq -p


////==========================================================////
//// 			        		 		                    ////
//// 			    Б. Теоретические основы  		    ////
//// 			         				                    ////
////==========================================////

Б1. История POSIX-совместимых ОС

  --------------------------------------
  Подоглавление:

    - Введение
    - Bell-прелюдия: 1969 - 1974 гг.
    - Развитие UNIX в Университете Беркли: 1974 г. - ...
    - Расползание UNIX по миру: конец 70-х, 80-е годы
    - Стандартизация и упорядочивание: конец 80-х ...
    - Создание Linux: начало 90-x

  --------------------------------------

  > Введение
    - В этой главе речь пойдёт о UNIX-подобных ОС.
    - Хотя наиболее строгий титул им всем будет - POSIX-совместмые ОС.

  > Bell-прелюдия: 1969 - 1974 гг.
    - Началось всё с того, что:
        1  Bell Labs (подразделение AT&T),
        2  General Electric
        3  Массачуссетски Технологический Институт
    - .. стали разрабатывать многопользовательскую многозадачную ОС под названием Multics.
      ● Причём - безуспешно, по определённым причинам.
      ● Зато один из участников проекта - Кен Томпсон - написал по неё игру Space Travel.
    - В 1969 г. проект Multics был закрыт, и играть Кену стало не на чем и не под чем.
    - Благо в закромах Bell была найдена завалящая машина PDP-7.
      ● Которую Кен решил окучить под игровые цели.
      ● Правда, игра Кена под её родной ОС не работала. Пришлось написать свою, на ассемблере.
      ● Созданная на базе Multics, она получила название Unics, и была его урезанной версией.
      ● UNICS расшифровывался, как UNiplexed Information and Computing Service.
      ● Вообще UNIcs это аналог MULTIcs. UNIcs Кен её назвал потому, что пользователь у ОС был только 1.
      ● Позднее к Кену присоединился Денис Ритчи, в честь чего UNICS переименовали в UNIX.
    - В 1972 г. UNIX был полностью переписан на языке C.
      ● Это важный шаг - переход на более высокоуровневый С с ассемблера.
      ● В будущем это привело к появлению большого кол-ва приложений для ОС.
    - На судьбу UNIX с 1969 по 1974 гг. существенно повлияли юридические коллизии того момента:
      ● Компания AT&T подвергласть антимонопольному преследованию, и была существенно поражена в правах.
      ● Ей запретили торговать программными продуктами, в число коих и попадала UNIX.
      ● Так что последняя на протяжении 5 лет после своего создания существовала сугубо внутри компании.
    - Правда, эта 5-летка не проходила даром, UNIX развивали. Возникли:
      ● Понятие файла, как универсального интерфейса ко всему на свете.
      ● Командный интерпретатор (shell), как универсальное средство взаимодействия пользователя с системой.
      ● Набор запускаемых из shell программ, комбинации которых позволяли решать весьма сложные задачи.
      ● Простая файловая система (в ней отсутствовало понятие тип файла, а файл воспринимался просто, как набор байтов).
      ● И главное, системы была написана на высокоуровневом С
        - Что создавало предпосылки для её переноса на любые аппаратные платформы.
        - А сам язык Си, что примечательно, и был специально создан под эту систему.
      ● Тем не менее, до настоящего UNIX, каким мы его знаем теперь, было ещё далеко.
    - В 1974 г. AT&T получило возможность хоть как-то монетизировать наработки по UNIX:
      ● UNIX с исходниками бесплатно передавался в университеты (преимущественно США) и другие учереждения в "образовательных целях".
      ● Но чтобы его модифицировать, надо было купить лицензию у AT&T, как говорят, "за символические деньги".
      ● Однако, это не было свободным распространением в современном смысле Open Source.
      ● Ограничение было в том, что лицензии не допускали дальнейшего распространения ни системы, ни её компонентов.
      ● Тем временем, система расползалась по универам и прочим учереждением, которые активно её осваивали.

  > Развитие UNIX в Университете Беркли: 1974 г. - ...
    - Одним из первых, получивших от AT&T доступ к исходникам UNIX, стал Университет Беркли.
    - Именно здесь UNIX "хорошо вписался", и стал бурно развиваться, выполняя свои "научно-образовательные" цели.
      ● Здесь, в условиях открытого общения проф.специалистов в области зарождающегося Computer Science, UNIX медленно превращался в то, чем она стала ныне.
      ● И в значительной мере усилиями трудящихся университета, объединённых в Computer System Research Group (CSRG).
      ● CSRG же финансировалась министерством обороны США. Сугубо в мирных целях, как не трудно догадаться.
    - Среди всего, что сделали "Берклианцы" для UNIX, можно выделить 2 вещи:
      1) Интеграция в ядро системы сетевого протокола TCP/IP.
        - Того самого, на котором работает сегодняшний интернет.
        - Последний же задумывался, как отказоустойчивая система правительственной связи на случай советского ядерного удара.
      2) Реализация файловой системы
    - Остановимся поподробнее на том, какие работы были проведены над файловой системой:

        Что было сделано в Университете Беркли для улучшения файловой системы UNIX
      -------------------------------------------------------------------------------

        > Файловая система s5fs, и её 3 кита
          - Основные характеристики ФС были сформированы в UNIX уже в её первоначальном виде.
          - Эта файловая система получила впоследствии название s5fs.
          - Она базировалась на 3-х китах:
            1) Суперблок
              - Часть ФС, содержащая её основные свойства:
                ● Положение на физическом носителе.
                ● Размер логического блока (минимального кванта информации).
                ● Суммарное кол-во логических блоков.
                ● Число свободных и занятых блоков.
                ● И т.д.
            2) Таблица inodes
              - Имеется в виду таблица индексных (информационных) узлов.
              - Она содержит данные о файлах в ФС. Как некий центр их учёта.
              - Для каждого файла она содержит:
                ● Уникальный ID файла, по которому он может быть однозначно идентифицирован системой.
                ● Число ссылок. По сути, кол-во имён файла (каждый файл может иметь много имён).
                ● Размер файла в байтах.
                ● Атрибуты файла:
                  - Принадлежность (владелец, группы и т.д.).
                  - Доступ (права чтения, изменения, исполнения).
                  - Время (последнего чтения, последнего изменения).
                  - И ещё несколько.
            3) Адреса блоков данных файла
              - То есть, их адреса их физического расположения на физическом жёстком диске.
              - Содержатся в таблице inodes.
          - В устройство ФС s5fs изначально были заложены 3 существенных ограничения с точки зрения надёжности, экономичности (места на диске) и быстродействия:
            1) [Надёжность] Суперблок имелся в единственном экземпляре
              - В случае его утери получить доступ к данным становилось невозможно.
              - Поскольку адреса блоков данных становились неизвестны.
            2) [Место на диске] ФС s5fs состояла из блоков, имевших минимальный размер
              - Размер блоков в s5fs был от 512 до 2048 байт.
              - Увеличение размера блока, очевидно, вело бы к ускорению дисковых операций.
              - Но также очевидно, вело бы и к неэффективному расходу места на жестких дисках.
              - Поскольку файл размером много меньше MIN блока занимал бы столько же места, сколько MIN блок.
            3) [Быстродействие] Когда винчестеры стали большими, обнаружилась проблема быстродействия
              - В ФС s5fs таблица inodes была одна, и занимала непрерывную область где-то на винчестере.
              - Суть проблемы заключалось в том, что головке винчестера приходилось преодолевать много лишних расстояний.
              - Ведь перед тем, как считать файл, ей надо было сначала найти его адрес в inodes по его UID.
              - Таким образом головка постоянно металась между inodes и теми местами на диске, где хранились файлы, к которым обращались.
          - С логической же точки зрения ФС s5fs выглядела так:
            ● Имела древовидную, иерархическую структуру.
            ● Узлами в ней служили каталоги, а в каталогах могли "лежать" файлы.
            ● Каждый каталог содержал только UID и имена файлов, которые в нём гранятся.
            ● Причём имя файла ограничивалось всего 14 символами (как это не покажется странным современным польозвателям Linux).
              - По сути, каталог был как таблица в БД, для хранения записей-файлов (их UID и имени).
              - И под каждую такую запись отводилось всего 16 байт.
              - 2 первых байта хранили UID файла, а на имя отводилось всего 14 байт.
              - Это всего 14 латинских символов (по 1 байту). Или 7 русских в формате UTF (по 2 байта каждый).

        > ФС FFS: улучшения, внесённые в ФС в Университете Беркли
          - Разработки Беркли сняли многие ограничения, описанные выше:
            1) Во-первых, единое пространство ФС было разбито на части
              - Каждая такая часть имела:
                ● Свою копию суперблока.
                ● Самостоятельную таблицу inodes.
                ● Свою область данных на диске.
              - Это снимало вопрос по надёжности, т.к. теперь все данные были разбиты на части
                ● И при утрате одной части данных (например, при повреждении диска), другая часть сохранялась.
                ● Ведь теперь у каждой части данных был свой inodes, содержащий адреса данных на диске для своей части.
                ● И эти inodes располагались не в 1-й части диска, а были размазаны ровным слоем по диску.
              - Также это снимало вопрос по быстродействию.
                ● Теперь inodes каждой части данных находился в непосредственной близости от самих данных.
                ● Благодаря чему путь головки диска от inodes до данных был минимизирован.
            2) Во-вторых, была введена фрагментация логических блоков
              - Каждый логический блок разделялся на фрагменты, каждый из которых также имел свой адрес на диске.
              - И это решало проблему не рационального использования дискового пространства.
              - Поскольку даже если файл имел размер меньше логического блока, то теперь он не занимал его целиком.
                ● Теперь нерациональное использование было ограничено размерами фрагмента логического блока.
                ● А они существенно меньше, чем размеры логического блока. А значит и потери меньше.
                ● Но при этом дисковые операции продолжали осуществляться по логическим блокам.
                ● В результате чего фрагментация логических блоков не сказалась на скорости дисковых операций.
            3) В третьих, несколько изменили формат каталога
              - Два вышеописанных изменения привели к несовместимости изначальной ФС UNIX и изменённой.
              - Поэтому режили уж до кучи изменить и формат каталога, чтобы увеличить кол-во символов в имени.
              - Каждую запись о файле теперь делили на 2 части:
                1) Постоянную
                  - Уникальный ID файла.
                  - Размер переменной части в байтах (был равен 256 байт).
                2) Переменную
                  - Имя файла.
              - Таким образом максимальный размер имени файла возрос до 256 1-байтовых символов.
          - Новая файловая система получила имя FFS - Fast File System.
          - ФС современных разновидностей UNIX до сих пор используют описанные принципы, применённые в FFS.

        > Обратная совместимость FFS и s5fs
          - Под UNIX с s5fs уже было написано много приложений к моменту появления FFS.
          - Все они тем или иным образом взаимодействовали с ФС, и были рассчитаны на ФС s5fs.
          - Поэтому, в случае простой замены ФС с s5fs на FFS, эти приложения просто перестали бы работать.
          - В беркли это учли, и написали "драйвер", позволявший "старым" приложениям работать с новой FFS.
          - В нём описывались процедуры, как нужно читать данные из ФС в изменившихся условиях.
          - Позднее в UNIX появилось множество альтернативных ФС.
            ● Однако программы работали на любой из них, по тем же принципам.
            ● Посколько данный функционал был заботливо предусмотрен и заложен в Беркли.

      -------------------------------------------------------------------------------

    - Университет Беркли, это не какая-нибудь коммерческая фирма, потому никакой тайны из доработок UNIX никто не делал.
      ● Все достижения публиковались в открытых источниках, их мог использовать кто угодно.
      ● Эти принипы и легли в основу современных лицензий "свободного программного обеспечения".
      ● Такие лицензии в народе называют "лицензии типа BSD".
      ● Тот же Ричард Столмен, вероятно, опираясь на эти данные, изобрёл свой "велосипед" - лицензию GPL.
    - Распространялась и сама берклианская разновидность UNIX, как программный продукт:
      ● Группа CSRG, начиная с 1976 г., внедряла в народе свои достижения.
      ● Под названием Berkely Software Distribution (BSD), изначально на магнитных лентах.
      ● Собственно, эта расшифровка и лежит в основе названия BSD-ветки UNIX-систем.

  > Расползание UNIX по миру: конец 70-х, 80-е годы
    - AT&T открыла доступ к исходникаю UNIX, как упоминалось ранее, многим учереждениям. В т.ч. за пределами США.
    - Поэтому UNIX развивался не только в Университете Беркли, но и во многих других местах:
    - UNIX продолжат развиваться в недрах самой AT&T:
      ● Последовательно выходят System III, System V, System V Release 2 (SVR2) и, наконец, System V Release 3 (SVR3)
      ● SVR3 выходит в 1987 г., и становится последним представителем "чистого первозданного" UNIX.
      ● В 1989 г. появляется System V Release 4 (SVR4), которая включает в себя множество наработок из 4BSD:
        - Интеграция TCP/IP.
        - Поддержка ФС FFS.
        - Берклианская реализация механизма виртуальной памяти.
        - И многое другое...
    - Портируемость UNIX оценили производители специфического оборудования:
      ● IBM, Sun, Hewlett-Packard, DEC и ещё несколько уже забытых.
      ● Базируясь на SVR3, а позднее и на SVR4, они адаптировали систему под собственные архитектуры.
      ● И создали такие системы, как - AIX, SunOS, HP-UX, Digital Unix - соответственно.
      ● Всё это были коммерческие системы, заточенные лишь под оборудование фирм, создавших их.
      ● Поэтому широкого распространения они не получили.
    - По мере набора популярности UNIX, на этом решили подзаработать и чисто софтверные фирмы:
      ● Стали появляться чисто коммерческие UNIXы от таких фирм.
      ● В частности: Interactive Systems и Santa Cruz Operations.
      ● Не имея своих аппаратных платформ, они адаптировали UNIX под общедоступные.
        - В те времена, это были сначала PDP, а затем и IBM PC.
      ● На этом поприще отметилась и Microsoft, выпустив свой "велосипед" XENIX.
        - Первые версии работали на PDP.
        - Затем она была портирована на процессоры Intel i386.
    - Работа над UNIX велась и в других (кроме Беркли) университатах, и даже странах:
      ● Наибольшую известность из них преобрела деятельность Университета Карнеги-Меллона.
      ● Результатом их работы стала микроядерная UNIX-система Mach.
      ● Именно Mach нынче составляет сердце операционной системы MacOS X.
      ● Кроме того, под воздействием Mack Энди Танненбаум написал свою игрушечную MINIX.
      ● А MINIX, в свою очередь, вдохновила Линуса Торвальдса на написание Linux.
    - Т.О. кроме 2 существенно различающихся систем BSD и Systev V в конце 70-х и 80-х годах появилось ещё не менее дюжины различных вариантов UNIX.

  > Стандартизация и упорядочивание: конец 80-х ...
    - Итак, к концу 80-х годов различных модификаций UNIX уже были десятки.
    - В основе существовавших вариантов UNIX лежали базовые системы: SVR3, SVR4, 4BSD.
    - Авторы каждой из них развивали свою систему так, как считали нужным.
    - Как следствие, с течением времени различия между клонами UNIX становились всё более существенными.
    - Возникла угроза для 1-го из краеугольных камней UNIX-идеологии: портируемости приложений.
    - Это стало предпосылкой для начала процесса стандартизации в мире UNIXов.
    - Начала процесс стандартизации, на правах создателя UNIX, компания AT&T:
      ● Они в 1984 г. создали стандарт System V Interface Definition (SVID).
      ● По мнению AT&T, система, претендующая на звание UNIX-образной, должна была соответствовать стандарту SVID.
      ● Как нетрудно догадаться, стандарт был ориентирован на System V, и игнорировал BSD.
      ● А BSD, что характеро, нимел большой вес в мире Unix, на его основе были созданы многие версии системы.
      ● Поэтому народ из лагеря BSD был недоволен таким положением вещей.
    - Стандарт POSIX
      ● Недовольные создали несколько своих версий стандартов (с блекджеком и куртизанками).
      ● Наибольшее признание из которых и получил стандарт POSIX (Portable Operation System Interface based on uniX).
      ● Набор соглашений POSIX был разработан международной организацией IEEE, и увидил свет в 1988 г.
      ● Слово "Portable" означало, что согласно спецификации, система могла быть перенесена на любое "железо".
      ● Однако со временем оказался важным смысл этого слова и нескольк под другим углом:
        - Любая программа, написанная в соотв. с POSIX, могла быть перенесена (подчас без переделок) на любую POSIX-систему.
        - Причём это один из тех редких случаев, когда теоретические ожидание блестаще подтвердились практикой.
      ● Название "POSIX" было предложено Ричардом Столменом.
        - Термин, по задумке авторов, происходит от слова "позитив".
        - И произносится, как "поЗикс", а не как "посикс".
      ● Последнюю версию POSIX можно посмотреть здесь:
          http://standards.ieee.org/develop/wg/POSIX.html
    - Суть стандара POSIX была в следующем:
      ● Он жёстко определяет базовый функционал систем и приложений.
      ● Но допускает расширение функционала сверх базового.
      ● Но при этом сам базовый функционал должен жёстко соответствовать стандарту.
    - Именно на стандарт POSIX опирался Линус Торвальдс, когда создавал ядро Линкус.

  > Создание Linux: начало 90-x
    - Как было сказано, UNIX распространился по университетам всего мира.
    - Более того, он стал основой бозового академического образования в области Computer Science.
    - Однако обучаться системе без самой системы было неудобно, и не так интересно:
    - А система UNIX не сказать, чтобы в то время была прямо таки общедоступной:
      ● Как упоминалось ранее, были ограничения на распространение.
      ● Большая часть вариантов UNIX была привазана к дорогому "железу".
      ● И наконец, UNIX был сложен, и обучиться ему и понять было не просто в принципе.
    - Спрос рождает предложение, и Энди Танненбаум из Амстердамского Университета решил проблему:
      ● Он создал "пионерский" вариант UNIX - "MINIX" - специально в образовательных целях.
      ● И распространял её на дискетах вместе со своим учебникам по теории ОС.
      ● По свидетельству очевидцев, в ней было всё, как в настоящем UNIX, за исключением одного:
        - Она была не способна к выполнению реальных пользовательских задач.
        - Таненбаум полагал их слишком сложными для неокрепших студенческих умов.
    - Довольно быстро соложилось общество любителей MINIX.
    - Недовольство "обрезанностью" системы среди них наростало:
      ● А спрос рождает предложения, и система обрастала добарботками, патчами.
      ● Но был один существенный недостаток: MINIX распространялся не как Free Software.
      ● Иначе говоря, доработанные версии нельзя было распространять, как самостоятельную
      ● Каждый должен был приобретать книгу Таненбаума, брать с дискеты чистый MINIX, и устанавливать самостоятельно все сторонние патчи.
    - Именно так, как описано выше, поступил некий студент Хельсинского Университета - Линус Торвальдс:
      ● Он купил книгу Таненбауму, установил чистый MINIX, и поставил на неё все необходимые патчи.
      ● Однажды ему понадобился функционал, которого не оказалось в MINIX, и он написал свою программу.
      ● Но тут обнаружилось, что функционала ядра MINIX не хватает для решения задач, которые ставил себе Линус.
      ● Пришлось ему на основе ядра MINIX написать своё собственное ядро.
      ● Видоизменил он и файловую систему MINIX, создав ФС ext (как бы расширенная ФС MINIX). В неё и поместил своё новое ядро.
      ● Чтобы не работать с голым виртуальным терминалом, прикрутил сюда ещё и программу bash.
        - Которая в то время разрабатывалась в недрах GNU.
      ● Ну и всё это дело надо было как-то собирать.
        - На то время единственны свободным компилятором Си был "GNU C Compiler" (gcc).
        - Который и использовал Линус.
    - В конце концов, в августе 1991 г., было объявлено о создании новой ОС.
      ● Она получила название Linux в определённой степени случайно.
      ● Так назывался личный каталог Линуса на том ftp-сервере, куда она была впервые выложена в свободный доступ.
      ● Сначала Linux был выложен под лицензией, сочинённой Линусом собственноручно.
        - Но вскоре он изменил её на GPL.
        - Под GPL распространялись также такие важные её компоненты, как bash и gcc.
    - Следует подчеркнуть 3 вещи, относительно Linux:
      1) Linux не является чистым клоном UNIX
        - Линус не занимался адаптаций MINIX или какой-то другой версии UNIX.
        - В своей работе он руководствовался описаниями системных вызовов, описанными в POSIX.
        - Поэтому Linux можно считать первой настоящей реализацией POSIX-системы в полном смысле этого слова.
      2) Linux изначально создавался для процессора Intel i386
        - Следование стандарту POSIX было не для переноса системы как таковой на другое "железо".
        - А возможность портирования на Linux программ, уже написанных для других UNIX-образных ОС.
      3) Линус оказался создателем уникального метода разработки Open Source проектов
        - Того самого, который Эрик Раймонд назовёт потом "методом большого базара".
        - Линус выложил Linux в открытый доступ и пригласил всех желающих приять участие в её совершенствовании.
        - И тем самым обеспечил своему проекту практическое бессмертие и непрерывное развитие.
        - А соответствие системы POSIX-стандарту привлекло к проекту многочисленных UNIX-программистов.
          ● Ведь всё равно их усилия не пропадут даром, ведь любая написанная программа может быть портирована на любую POSIX-совместимую ОС.
    - В результате деятельности всей этой "аморфной толпы" разработчиков Linux быстро обрастал функционалом:
      ● Появилась поддержка сетей и протокола TCP/IP.
      ● Оконная система X.
      ● На неё были портированы все аналоги классических UNIX-утилит.
      ● Затем настал черёд и пользовательских приложений. В т.ч. офисных, графических, мультимедийных.
    - Следствием такого бурного развития было привлечение большого числа пользователей Linux:
      ● В настоящее время кол-во пользователей Linux превосходит суммарное кол-во других POSIX-совместимых систем вместе взятых.
      ● Причём среди пользователей Linux с каждым годом всё больше "обычных юзеров".
      ● По функционалу и качеству такие дистрибутивы, как Ubuntu, быстро догоняют таких лидеров рынка настольных ОС для "юзеров", как "Windows" и "MacOS X".


Б2. Операционная система, ядро ОС, ОС Linux, дистрибутивы

  --------------------------------------
  Подоглавление:

    - Что такое операционная система: 3 мнения
    - Минимальный и достаточный состав ОС
    - ОС Linux
    - Дистрибутивы Linux

  --------------------------------------

  > Что такое операционная система?

    - Мнение №1: минималистское
      ● ОС - программа, именуемая ядром ОС.
      ● В дистрибутивах всё, что не относится к ядру (программы, утилиты), не относится к ОС.

    - Мнение №2: максималистское
      ● ОС - ядро, его системное окружение, графический интерфейс, и даже некоторые программы.
      ● Например, Microsoft считает IE частью ОС.

    - Мнение №3: взвешенное
      ● ОС - ядро и самодостаточный комлекс средств, необходимый для его функционирования на благо пользователя.
      ● Пользователь, загрузив ОС, должен иметь возможность без сторонних инструментов установить требуемые приложения, запускать их и работать с ними.

  > Минимальный и достаточный состав ОС

    1. Ядро ОС
      - Любая ОС не способна фукционировать без ядра.
      - Ядро является сердцем любой ОС.
      - Оно отвечает за взаимодействие польз.приложений с аппаратурой компьютера.
      - В функции ядра большинства POSIX-систем входят:
        ● Распределение процессорного времени между задачами.
        ● Управление памятью, как физической, так и виртуальной.
        ● Взаимодействие с устройствами.
        ● Доступ к файловым системам.
        ● Обеспечение ввода/вывода данных.
        ● Сетевая поддержка.
      - От всех остальных программ ядро ещё отличается 2-мя важными особенностями:
        1) Функционирует в отдельной области памяти
          - Эта область памяти так и называется: "kernelland".
          - Пользовательские процессы не имеют к ней доступа.
          - Все же прочие программы располагаются в т.н. "userland".
        2) Всегда должно находиться в оперативной памяти физически
          - Kernelland не может свопироваться в раздел подкачки.
          - Так как само ядро и управляет данной виртуальной памятью.
          - И если часть ядра окажется в разделе подкачки, то высвободить это место окажется невозможно.
          - Userland распределяется между физ.памятью и виртуальной (подкачка на жёстком диске).
      - Как обеспечить MAX функционал ядра, который занимает MIN памяти?
        ● Общее решение этой проблемы было найдено в виде поддержки загружаемых модулей.
        ● Это фрагменты кода, каждый обеспечивает определённую функциональность ядра.
        ● Эти модули, как часть ядра, предназначены для функционирования в памяти в Kernelland.
        ● Но они не все разом функционируют. А подгружаются по мере надобности, и выгружаются по мене не надобности.
        ● Это и позволяет обеспечить MAX функционал ядра при MIN затратах памяти.

    2. Инициирующая программа и стартовые скрипты
      - Чтобы ядро начало работать, его надо загрузить в память (в Kernelland).
      - Практика показывает, что ядро способно сделать это само, так что загрузчик не является частью ОС.
      - Но загрузиться в Kernelland недостаточно. Надо ещё запустить некий стартовый процесс.
      - В UNIX-системах стартовый процесс имеет единое название "Init".
        ● За его запуск отвечает одноимённый исполняемый файл /sbin/init.
      - Плюс, в процессе загрузки следует выполнить некий комплекс подготовительных мероприятий.
        ● Он определяется набором так называемых "стартовых скриптов".

    3. Утилиты поддержки функций ядра ОС
      - Они обеспечивают работу с устройствами, файловыми системами, сетевыми протоколами.
      - Без них пользователю не удастся воспользоваться соответствующим функционалом ядра.
      - Поэтому данные утилиты также являются частью ОС.

    4. Средства работы с физическими носителями
      - А именно:
        ● Средства обращения к физическим носителям.
        ● Создания на них разделов и файловых систем.
        ● Их проверки, монтирования и т.д.
        ● Средства загрузки и выгрузки модулей ядра.

    5. Инструментарий для работы с файловыми системами, средства сетевого доступа
      - Рассмотренные выше части ядра необходимы ему для самообеспечения.
      - Однако целью ОС является выполнение пользовательских задач.
      - Поэтому инструментарий для работы с файловыми системами также необходимый компонент ОС.
      - А поспольку файлы могут находитсья на удалённых машинах, сюда же примыкают средства сетевого доступа.

    6. Системные библиотеки
      - Для своего функционирования как ядро, так и системные/пользовательские утилиты нуждаются в системных библиотеках.
      - Из них главной оказывается "libc" - библиотека функций языка Си.
      - А язык Си, напомню, является главным средством разработки в UNIX-системах.
      - Однако, и другие библиотеки не менее важны.

    7. Интерпретатор языка команд (шелл - shell)
      - Любое действия в ОС осуществляются путём отдачи команд.
      - Интегрирующей надстройкой над всем выше описанным является shell.
        ● Роль его невозможно переоценить.
        ● Те же инициирующие скрипты являются лишь набором сценариве шелла.
        ● А всякие навороченные интерфейсы лишь надстройки над элементарными шелл-командами.

    8. Внутренняя документация
      - Даёт пользователю возможность изучения ОС.
      - Таковой испокон веков в UNIX выступает система man-страниц (Manual Pages).
      - По сей день эта система остаётся простым и быстрым способом получения информации.

    9. Пакетный менеджмент
      - Комплекс инструментов для наращивания системы дополнительными программами.
      - Установка пакетов, отслеживание зависимостей, удаление пакетов.
      - Эти действия могут выполнятсья как вручную, так и с помощью специальных приложений.

    10. Средства обеспечения работы в графическом режиме
      - Эта функция возлагается на кроссплатформенную систему X Window System.
      - Хотя у неё имеются и конкуренты. Скажем, Canonical (Ubuntu) продвигает свою систему Mir.

  > ОС Linux
    - Набор вышеописанных базовых компонет для ОС с ядром Linux будем называть Base Linux.
    - Base Linux, собственно, и образует базовую комплектацию ОС Linux.
    - Многие компоненты Base Linux были разработаны до того, как Линус разработал ядро:
      ● Они были разработаны в рамках проекта GNU.
      ● Это такие компоненты, как например:
        - Компилятор gcc.
        - Общесистемная библиотека glibc.
        - Командная оболочка bash.
      ● Столлмену не хватало только ядра для создания полноценной ОС.
    - Для большинства наиболее важных компонент Base Linux есть много альтенатив:
      ● И эта особенность - альтернативность - является ключевой особенностью ОС Linux.
      ● Причём альтернативые есть даже для самых ключевых компонентов системы:
        - Командной оболочки, главной системной библиотеки, средств работы с файловыми системами.
    - Поэтому ОС Linux не столько ядро и набор базовых программ:
      ● Но и алгоритм для построения такого набора.
      ● Когда можно взять и собрать его из "кирпичиков", для каждого из которых есть много альтернатив.
      ● Возможно, именно этим - возможностью быть сопричастным к созданию ОС - он и привлекает определённую категорию пользователей.
      ● Как говорил дедушка русского линуксописания Владимир Водолазский:
        "Быть просто пользователем Linux - скучно".
      ● И действительно, рано или поздно любой линуксоид становится творцом.

  > Дистрибутивы Linux
    - Невозможно построить 1 идеальную ОС, которая будет одинакова хороша на все случаи жизни.
    - Рассмотрим, скажем, Base Linux:
      ● Для каких-то пользовательских задач ему будет не хватать функционала
      ● Для каких-нибудь других же его функционал будет избыточным.
    - Таким образом, построить близкую к идеалу ОС можно лишь для заранее заданного круга задач.
      ● То есть нужно заранее знать, что это за задачи.
      ● И тогда можно будет собрать свою "версию" ОС Linux, именно под эти задачи.
      ● Такие "сборки", заточенные под конкретные задачи, и называются "дистрибутивами Linux".
    - Если круг задач широк, создают дистрибутив с расширенным функционалом:
      ● Допустим, хотим мы создать дистрибутив с графической системой и набором программ "как в windows".
      ● Такого рода дистрибутивы, которые "могут всё понемножку", называют "полнофункциональными".
      ● Тогда берём и дополняем Base Linux доп.функционалом:
        - Программные средства для работы в графическом режиме.
        - Графический пользовательский интерфейс (оконные менеджеры и интегрированные рабочие среды).
        - Инструментарий для работы с графическими и мультемедийными данными.
        - Офисные пакеты для работы с документами.
        - И т.д.
      ● В результате получаем дистрибутив для настольного PC.
        - Пример такого дистрибутива: Ubuntu Desctop.
      ● Различные полнофункциональные дистрибутивы могут отличаться друг от друга по следующим параметрам:
        - Комплектация
        - Программа установки/конфигурирования
        - Система инициализации и стартовые скрипты
        - Вид иерархии файлов/каталогов
        - Система управления пакетами
    - Если круг задач узок, наоборот, создают дистрибутив с урезанным функционалом:
      ● В результате kernelland занимает min необходимое кол-во места в памяти.
      ● Это позволяет экономит ресурсы системы: память, процессорное время, I/O операции, и прочие.
      ● Допустим, хотим мы сделать дистрибутив для веб-сервера.
      ● Тогда берём и урезаем из Base Linux всё, что нам не надо:
        - Графическую систему (нам хватит и виртуального терминала).
        - И т.д.
      ● Бывают даже дистрибутивы для стиральных машин, телевизоров и т.д.
        - У них функционал кардинально отличается, скажем, от Ubuntu Desctop.
      ● Количество специализированных дистрибутивов не поддаётся пересчёту, и постоянно растёт.


Б3. Терминалы

  --------------------------------------
  Подоглавление:

    - Что такое "терминал"
    - Историческая справка
    - "Управляющий" и "Текущий" виртуальные терминалы
    - X Window System и псевдотерминалы
    - Переключение между виртуальными терминалами в Ubuntu

  --------------------------------------

  > Что такое "терминал"
    - В Linux есть общее понятие "терминал".
    - Терминал = устройство ввода информации + устройство вывода информации.

  > Историческая справка

    > История понятия "терминал"

      -- Раньше компы были большие, дорогие и прожорливые.
      -- Владеть ими могли позволить себе лишь крупные, богатые организации.
      -- Они ставили компьютер в "вычислительный центр", куда и приходили пользователи.
      -- Но пользователей было много, а компьютер один, что создавало неудобства.
      -- Требовалось:
        1] Во-первых, обеспечивать возможность одновременной работы для N пользователей.
        2] Во-вторых, разделять ресурсы системы между работающими пользователями.
        3] В-третьих, обеспечить безопасность системы и данных каждого из пользователей.
      -- 1-ю задачу решали N терминалов, 2-ю и 3-ю решала одна из систем разделения ресурсов.
      -- Одной из таких систем разделения ресурсов и была UNIX.
      -- Теоретически, пользователь со своего терминала не мог повредить системи или другим пользователям.
      -- Но среди пользователей был "root-оператор", или просто "root".
      -- У него был особый "системный терминал", как кольцо всевластия, дающий ему неограниченные полномочия.
      -- Шло время, и появились PC - Personal Computers. Персональные, а не общие, как раньше.
      -- UNIX мигрировал на PC, но сохранил свою многозадачную, многопользовательскую природу.

    > История понятия "виртуальный терминал"

      -- Изначально 1 терминал мог выполнять 1 задачу в 1 и то же время.
      -- Однако, многозадачность легко реализовать программно, скажем, с помощью оболочки.
      -- Но как реализовать доступ >1 пользователей через на 1-м PC? Прикрутить ещё N клавиатур и мониторов?
      -- Вместо этого решили применить программное решение. Так в UNIX появилось понятие "виртуальный терминал".
      -- На каждом виртуальном терминале может залогиниться пользователь, и выполнять свои задачи.
      -- Все виртуальные терминалы почти полностью изолированы друг от друга (почти, т.к. ресурсы компа общие).
      -- В Linux все виртуальные терминалы являются равноправными.
      -- Виртуальные терминалы в Linux определяются частью ядра под названием "драйвер Linux-консоли".
      -- Каждому виртуальному терминалу соответствует свой файл в каталоге /dev
        ● /dev/tty0 зарезервирован для физического терминала (сейчас явление почти мифическое).
        ● По адресу в Ubuntu /dev/tty[1 .. 63] могут находиться прочие текстовые терминалы.
        ● Файлы виртуальных терминалов существуют на постоянной основе, а не создаются по запросу.
      -- Драйвер UNIX-консоли ограничен 63-мя виртуальными терминалами.
        ● Т.К. терминал (как файл устройств) имеет major- и minor-номера.
        ● Причём для последнего зарезервированы числа от 1 до 63. С этим и связано оганичение.
        ● Традиционно в дистрибутивах Linux активируются первые 6 виртуальных терминалов, с 1 по 6.
        ● Это текстовые терминалы, а дополнительно к ним активируется 7-й терминал, для графической оболочки.

    > История "текстовых" и "графических" виртуальных терминалов

      -- В стародавние времена к компьютерам начали прикручивать устройства для вывода информации.
      -- Эти устройства назвали "дисплеями", и были они разными - "текстовыми" и "графическими".
      -- Причём подавляющее большинство дисплеев в те времена были именно текстовые.
      -- Текстовые могли выводить лишь текст, да и то, "жёстко вшитый" в сам дисплей.
        ● Как на электронных часах, на нём можно было отобразить лишь ограниченный набор символов.
      -- На графических же дисплеях изображение строилось с помощью специальных алгоритмов, попиксельно.
        ● Что давало возможность вывести на дисплей что угодно.
      -- С появлением PC текстовые дисплей вышли из употребления.
        ● Видеосистемы, объединяющие в себе видеоадаптер + дисплей, стали графическими.
      -- Но текстовые виртуальные терминалы сохранились.
        ● Только теперь доступный набор символов прошивался не в "железе", а загружался в видеоадаптер.
      -- Однако сущетсвует понятие и так называемого "графического" терминала.
        ● Его не следует путать с понятиями графических рабочих сред.
        ● Это обычный виртуальный терминал, но символы в нём выводятся графическими средствами.
        ● Это возможно благодаря тому, что все современные видеоадаптеры являются VESA-совместимыми.
        ● Они поддерживают линейный кадровый буфер (Frame Buffer), позволяющий прямое воспроизведение графики без программных средств.
      -- Однако, графические возможности "графического" терминала существенно ограничены.
        ● Не все ОС вообще поддерживают Frame Buffer (хотя Linux поддерживает).
        ● Существует крайне мало приложений, поддерживающих возможности Frame Buffer.
      -- Т.О. графический виртуальный терминал можно рассматривать лишь как расширение возможностей текстового.
      -- Но на практике, в большинстве случаев, делать различия между ними нет смысла.
      -- Поэтому будем будем считать их 1-м явлением, и называть "текстовый виртуальный терминал".

  > "Управляющий" и "Текущий" виртуальные терминалы
    - Каждый процесс (запущенная пользователем программа) связан с каким-либо виртуальным терминалом.
    - "Управляющим" для процесса является виртуальный терминал, с которого он запущен.
    - "Текущим" для процесса является виртуальный терминал, куда выводятся результаты его работы.
    - Чаще всего это 1 и тот же виртуальный терминал, но может быть и не 1 и тот же.

  > X Window System и псевдотерминалы

    > X Window System
      - Как условились выше, "графический" виртуальный терминал не будем рассматривать, как самостоятельный графический режим.
      - Практически единственным универсальным способов сделать это в UNIX-образных системах, это "X Window System".
        ● Или, в просторечии, просто "Иксы".
        ● Ибо X - её имя собственное, возникшее потому, что исторически ей предшествовала другая графическая система - W.
        ● А "Window" в её названии "X Window System", это прилагательное, подчёркивающее, что система оконная, а не полноэкранная.
      - Иксы создавались независимо от каких-либо ОС, и были призваны обеспечить графический режим работы на любых машинах.
      - Существуют как свободные реализации Иксов, так и платные.
      - В Ubuntu, например, используется реализация под назчанием Unity.
      - По слухам, Canonical планирует в будущем перейти с Иксов на собственную разработку Mir.

    > X-сервер
      - Главной частью Иксов является программа, именуемая "X-сервер".
      - Именно X-сервером и различаются различные реализации Иксов.
      - В Ubuntu X-сервер по умолчанию запускается поверх 7-го виртуального терманала.
      - А терминалы с 8 по 12 зарезервированы для запуска дополнительных экземпляров X-сервера.
      - Причём вопреки обычному пониманию клиент-сервер, именно X-сервера могут находиться на удалённых машинах.

    > X-клиенты и "псевдотерминалы"
      - Один из важнейших X-клиентов является "эмулятор терминалов".
        ● Таких эмуляторов существует великое множество.
        ● В штатный комплект любой реализации Иксов входит xterm.
        ● Эмулятор терминалов позволяет эмулировать обычные текстовые виртуальные терминалы.
        ● Такие сэмулированные виртуальные текстовые терминалы называют псевдотерминалами.
        ● Файлы псевдотерминалов создаются по запросу и хранятся в каталоге /dev/ptx

  > Переключение между виртуальными терминалами в Ubuntu

    > Способы перехода между терминалами

      > Переключение между текстовыми виртуальными терминалами от 1 до 6
        - В Ubuntu по умолчанию места с 1 по 6 выделены для текстовых терминалов.
        - Переключиться на них можно нажав: Ctrl + Alt + F[1 .. 6]

      > Переключение между графическими терминалами от 6 до 12
        - В Ubuntu для графических терминалов выделены места от 7 до 12.
        - Обычно, в них запускается "X Window System".
        - По умолчанию на 7-м месте запускается GUI на основе "X Window System".
        - А места с 8 по 12 остаются пустыми, и зарезервированы для других GUI-терминалов.

      > Перейти к следующему/предыдущему текстовому терминалу
        - К следующей:  Alt + →
        - К предыдущей: Alt + ←

    > Активация дополнительных терминалов
      - В Ubuntu по умолчанию активированы лишь 7 терминалов.
      - Текстовые терминалы с 1 по 6, и GUI-терминал на 7-й позиции.
      - При переключении на терминалы с 8 по 63 мы увидим лишь чёрный экран с курсором.
      - Но любой из них можно активировать. Тогда на нём мы увидим приглашение ввести логин/пароль.
      - Для активации достаточно запустить на желаемом терминале любой процесс.
      - Сделать это можно, например, в следующих местах:
        1] Из другого терминала
          - Например, запустим getty на желаемом терминале tty12:
              sudo /sbin/getty -8 38400 tty12
          - Она запрашивает логин и выполняет программу /bin/login.
          - В результате, при переходе на tty12 мы видим приглашение ввести логин/пароль.
          - Минус: после входа/выхода getty не запускается снова, и мы опять видим чёрный экран с курсором.
        2] В скрипте, который срабатывает при запуске системы
          - Допустим, нам надо активировать терминалы с 13 по 63.
          - Тогда в данном скрипте, в каждом из них запускаем какой-нибудь процесс.
          - Например, тот же getty.


Б4. Пользователи

  --------------------------------------
  Подоглавление:

    - Файл, процесс, пользователь
    - Пользователь: определение
    - Атрибуты учётной записи пользователя
    - Доступ к атрибутам
    - Разъяснение значения столбцов базы пользователей /etc/passwd
    - Разъяснение значения столбцов базы групп /etc/groups
    - Где на самом деле хранятся пароли: система защиты "теневые пароли" в Linux

  --------------------------------------

  > Файл, процесс, пользователь
    - Это 3 кита, на которых зиждится весь POSIX-мир.
      ● Всё, что существует в системе в статике, суть есть файл.
      ● Всё, что существует в системе в динамике, суть есть процесс.
      ● Все, кто тем или иным образом взаимодействует с системой - её процессами и файлами - суть есть пользователь.
    - В UNIX всё, кроме ядра и процесса - файлы.
      ● В unix есть ядро, которое всё про всех знает.
      ● Есть процессы, которые изолированы друг от друга.
      ● А всё остальное является файлами.
      ● Поэтому в unix все операции можно свести к 5:
        1] open()	  | открытие
        2] close()	| закрытие
        3] read()	  | чтение
        4] write()	| запись
        5] seek()	  | позиционирование (для “блочных” устройств)
      ● Поэтому при работе с любой сущ-ю в UNIX считаем, что работаем с файлом

  > Пользователь: определение
    - Будем называть "пользователями" записи в соответствующей "базе данных пользователя".
    - То есть 1 строчка в этой базе данных (объект, по сути) представляет из себя 1 пользователя.
    - Причём в Linux пользователями могут быть не только личности, но не личности.
    - Кто вообще может быть пользователем в Linux (примеры):
      ● Человек, зарегистрированный в системе.
      ● Администратор системы, имеющий учётную запись root в системе.
      ● Демоны
      ● Псевдопользователи
    - Пользователей всегда больше 1. Даже среди "человеческих" учёток кроме основного пользователя есть ещё root.
    - Собственно говоря, посмотреть всех пользователей в системе можно в файле /etc/passwd:
        nano /etc/passwd
    - При установки в большинстве дистрибутивов Linux автоматически создаются 2 пользователя:
      ● Супер-пользователь "root" с UID==0.
      ● Первый обычный пользователь.
    - После установки системы создавать/изменять/удалять пользователей может лишь root (супер-пользователь).

  > Атрибуты учётной записи пользователя
    - Каждый пользователь (учётная запись в БД пользователей) имеет некие свойства.
    - Эти свойства будем называть "атрибутами учётной записи пользователя".
    - Эти атрибуты являются общими для всех POSIX-систем:
      ● Уникальный ID (UID)
        - Представляет из себя уникальное число в столбце UID'ов таблицы пользователя.
        - Получается стандартным образом в результате автоинкрементирования при добавлении новой записи.
        - По этому ID система и может однозначно идентифицировать пользователя.
        - В большинстве дистрибутивов Linux (и в Ubuntu) UID обычных пользователей начинается с 1000.
          - Первый зарегистрированный в системе пользователь и имеет UID == 1000.
          - UID'ы < 1000 система резервирует для тех самых демонов и псевдопользователей.
          - А root-пользователь имеет UID == 0, везде в POSIX-мире.
      ● Уникальный логин
        - Логин должен быть уникален, чтобы система могла по нему однозначно найти нужную запись в таблице пользователей.
        - А найдя, получить UID пользователя, и уже дальше совершать нужные ей манипуляции с этим.
      ● Пароль
        - Используется при аутентификации пользователя.
        - Желательно задавать длинный и сложный пароль, в целях безопасности.
        - Пароль система хранит не в открытом виде, а лишь его хэш. Так что даже root не может его узнать.
      ● Рабочая среда по умолчанию
        - Пользователь ведь входит в систему не просто так, а чтобы совершать какие-то действия.
        - А для этого требуется какая-то рабочая среда. Скажем, командная оболочка.
        - Указанная в этом св-ве программа и запускается, как только пользователь аутентифицируется в системе.
        - Скажем, в Ubuntu 14.04, у обычных пользователей по умолчанию установлено "/bin/bash".
        - Посмотреть рабочую среду текущего пользователя можно в переменной окружения $SHELL.
        - А поменять её можно командой chsh.
        - У демонов/псевдопользователей рабочей средой может быть не шелл, а что-то другое.
      ● Домашний каталог
        - Каждый пользователь имеет 1 собственный домашний каталог.
        - Он автоматически создаётся системой при создании учётно записи пользователя.
        - В Ubuntu домашний каталог создаётся по адресу: /home/[логин]
        - Адрес домашнего каталога пользователя имеет псевдоним "~".
          - То есть, чтобы туда перейти, достаточно ввести: cd ~
      ● Основная группа пользователя
        - Каждый пользователь может состоять в 1 или более групп.
        - Каждый пользователь от рождения входит в 1  основную для него группу.
        - В Ubuntu эта группа имеет те же имя и UID, что у пользователя.
        - В этом свойстве пользователя содержится UID этой группы.
        - Каждая группа, также как и пользователь, является по сути строкой в таблице групп, и тоже имеет UID.
        - В Ubuntu UID'ы групп < 1000 система резервирует для тех самых демонов и псевдопользователей.
          - Так что UID'ы реальных пользователей начинаются с 1000.
        - Собственно говоря, посмотреть список всех существующих групп можно здесь:
            nano /etc/groups
        - А посмотреть, в каких группах какой пользователь состоит, можно здесь:
            nano /etc/passwd

  > Доступ к атрибутам
    - Вот несколько команд для этого:

      # Получить имя текущего пользователя (из под которого вводится команда):
          echo $USER        | gekkman

      # Получить путь к шеллу текущего пользователя:
          echo $SHELL       | /bin/bash

      # Получить путь к домашнему каталогу текущего пользователя:
          echo $HOME        | /home/gekkman

      # Просмотреть базу учётных записей пользователей системы:
          nano /etc/passwd

      # Просмотреть базу групп системы:
          nano /etc/group

  > Разъяснение значения столбцов базы пользователей /etc/passwd
    - Выполнив команду nano /etc/passwd можно просмотреть эту базу.
    - Она имеет структуру a:b:c:d:e:f:g - разделитель ':' - и 7 значений в строке.
    - Вот пример, я обозначил каждый столбец номером:

           1    2  3     4     5          6            7
        gekkman:x:1000:1000:gekkman:/home/gekkman:/bin/bash
        root   :x:0   :0   :root   :/root        :/bin/bash

    - Смысл у столбцов следующий:

      1. Имя пользователя
      2. Пароль пользователя
        - Как видно, вместо настоящего пароля из 5 символов стоит буква 'x'.
        - Просто файл passwd, вопреки названию, реальных паролей не содержит.
      3. UID пользователя
      4. UID основной группы, к которой приписан пользователь
      5. Комментарий
        - Может быть любым.
      6. Домашний каталог пользователя
        - У обычных пользователей здесь указан путь типа: /home/[имя пользователя]
        - У root'а также есть домашний каталог: /home/root
          - Но выполнять от его лица какие-то задачи, дела крайне не здоровое.
          - Поэтому домашний каталог суперпользователя заполняется (как правило) лишь его личными конфигурационными файлами.
      7. Программа пользователя по умолчанию (шелл для обычных пользователей)
        - Здесь указан её адрес.
        - Как видно, у gekkman и root указан /bin/bash
        - Если это поле пусто, то будет использована некая заданная по умолчанию среда (в POSIX системах это всегда /bin/sh)
          - В реальности этот путь может указывать на что угодно. Как дышло, куда повернёшь, туда и вышло.

  > Разъяснение значения столбцов базы групп /etc/group
    - Выполнив команду nano /etc/group можно просмотреть эту базу.
    - Она имеет структуру a:b:c:d - разделитель ':' - и 4 значения в строке.
    - Вот пример, я обозначил каждый столбец номером:

          1      2   3      4
        root    :x  :0    :
        users   :x  :100  :
        gekkman :x  :1000 :

    - Смысл у столбцов следующий:

      1. Имя группы
      2. Пароль группы
        - Ни в одной POSIX-системе никогда не использовался по прямому назначению.
      3. UID группы
      4. Список пользователей, входящих в группу
        - Каждый пользователь владеет основной для него группой, и состоит в ней.
        - Но также он может состоять, и владеть, неограниченным кол-вом групп.

  > Где на самом деле хранятся пароли: система защиты "теневые пароли" в Linux
    - Не в /etc/passwd (базе данных пользователей системы), как можно было бы подумать.
      ● Ведь этот файл может просмотреть любой пользователь, и хранить в нём пароли было бы не безопасно.
    - Поэтому пароли храняться отдельно, в скрытом и защищённом файле /etc/shadow
      ● Обычный пользователь не может не то, что его редактировать, но даже и просмотреть.
        - Вот, попробуй: nano /etc/shadow
      ● Однако, с правами суперпользователя, всё-таки можно получить к нему доступ:
        - Вот, попробуй: sudo nano /etc/shadow
    - Выполнив вышеуказанную команду, можно просмотреть базу /etc/shadow.
    - Она имеет структуру a:b:c:d:e:f:g:h - разделитель ':' - и 8 значений в строке.
    - a - имя пользователя, b - хэш его пароля (у реальных пользователей) и пустота у псевдопользователей
    - Вообще, этот механизм "теневых пароле", принят именно в Linux.
      ● Пароли хранятся в системе в виде хэшей (одностороннее шифрование).
      ● И пароли храняться в отдельном файле /etc/shadow, доступ к которому (даже на чтение) имеет лишь root-пользователь.


Б5. Процессы

  --------------------------------------
  Подоглавление:

    - Файл, процесс, пользователь
    - Процесс: определение
    - Структура данных процесса "task_struct"
    - Массив ссылок "task vector" на все объекты-процессы в системе
    - Единое дерево всех процессов системы с корнем-процессом init
    - Изолированность проессов друг от друга
    - Очередь на распределение ресурсов для процессов
    - Как мульти-процессность экономит ресурсы CPU
    - Жизненный цикл процесса: fork(), exec(), exit(), wait()
    - Каким образом получаются процессы-зомби
    - Подробно о том, как создаются процессы (начиная с init)
    - Интерактивные и не интерактивные процессы

    - Категории св-в структуры "task_struct" процесса

  --------------------------------------

  > Файл, процесс, пользователь
    - Это 3 кита, на которых зиждится весь POSIX-мир.
      ● Всё, что существует в системе в статике, суть есть файл.
      ● Всё, что существует в системе в динамике, суть есть процесс.
      ● Все, кто тем или иным образом взаимодействует с системой - её процессами и файлами - суть есть пользователь.
    - В UNIX всё, кроме ядра и процесса - файлы.
      ● В unix есть ядро, которое всё про всех знает.
      ● Есть процессы, которые изолированы друг от друга.
      ● А всё остальное является файлами.
      ● Поэтому в unix все операции можно свести к 5:
        1] open()	  | открытие
        2] close()	| закрытие
        3] read()	  | чтение
        4] write()	| запись
        5] seek()	  | позиционирование (для “блочных” устройств)
      ● Поэтому при работе с любой сущ-ю в UNIX считаем, что работаем с файлом

  > Процесс: определение
    - Термин "процесс" появился ещё во время разработки системы Multix.
    - Процесс - контейнер для экземпляра скрипта, обеспечивающий его выполнение.
      ● Вообще, 1 процесс может обеспечивать выполнение >= 0 скриптов.
        - >= 0, а не >=1, поскольку существуют "процессы-зомби", все скрипты в которых завершились, а процесс так и остался.
      ● Внутри 1 процесса могут работать другие процессы, и внутри них тоже, образуя древообразную структуру.
        - А вообще, все процессы в системе связаны в 1 древообразную структуру, с процессом init в корне - первым запускаемым при старте системы процессом.
      ● Каждый процесс имеет свои права и обязанности.
    - Кстати, термины "процесс" и "задача" в мире Linux, насколько я понимаю, синонимы.

  > Структура данных процесса "task_struct"
    - Процесс, суть - объект особого класса, выполняющий вышеописанную задачу.
    - А раз это объект, то он имеет набор свойств и их значений.
    - Значения этих св-в могут меняться с течением времени...
      ● ...по мере исполнения задач, которое этот процесс обеспечивает.
    - Структуру данных объект-процесс в Linux называют "task_struct".
      ● Но почему "task_", а не "process_"? Как указано выше, в Linux это синонимы.
    - Структура "task_struct" велика и сложна.

  > Массив ссылок "task vector" на все объекты-процессы в системе
    - Массив указателей на все объекты-процессы в Linux называют "task vector".
      ● "Вектор", в смысле "массив", ну вы поняли.
    - MAX количество процессов в системе ограничено размером этого массива.
      ● По умолчанию, у меня в Ubuntu 14.04 Desktop, MAX кол-во процессов: 15757
      ● Узнать MAX кол-во процессов в системе: ulimit -u
      ● Увеличить MAX кол-во процессов в системе можно в /etc/security/limits.conf

  > Единое дерево всех процессов системы с корнем-процессом init
    - В Linux все процессы образуют 1 древообразную стуктуру с корем в процессе init.
      ● Следовательно, в Linux независимых процессов не бывает.
      ● Следовательно, каждый процесс в Linux (кроме init) имеет родительский процесс.
      ● Каждый процесс имеет ссылки на процессы: родителя, соседей, детей.
    - Посмотреть всё текущее дерево процессов можно командой pstree.

  > Изолированность проессов друг от друга
    - Процессы в Linux изолированны друг от друга.
    - Они никак не могут взаимодействовать друг с другом, кроме как через защищённые механизмы ядра.
    - Так что если один процесс падает, то остальным хоть бы хны.

  > Очередь на распределение ресурсов для процессов
    - Самый ценный ресурс системы для распределения, это CPU.
    - CPU в системе может быть один, а может быть много (как в многоядерном сервере).
    - Linux - мультипроцессная система, и может на каждом CPU выполнять по 1 процессу
      ● В каждый момент времени Linux старается загрузить все CPU процессами (чтобы не простаивали).
    - Но сколько бы ядер не было у системы, с вероятностью 99% процессов всё равно будет больше.
    - Как следствие, некоторым процессам приходится ждать, пока какой-нибудь из CPU освободится.
    - В ожидании, они выстраиваются в очередь.
      ● Причём, процессы в этой очереди могут быть не равны в правах.
      ● Для каждого процесса можно задавать приоритет от -19 (наинизший) до 20 (наивысший).
      ● Процессы с большим приоритером "проталкиваются вперёд" процессов с меньшим приоритетом в очереди.
      ● По умолчанию большинство процессов имеют приоритет 0. Но его им можно назначать и вручную. Переназначать (renice), или назначать при запуске (nice).
    - И вот, CPU высвобождается, и тут же переходит к обработки следущего на очереди процесса.

  > Как мульти-процессность экономит ресурсы CPU
    - Есть мульти-процессные системы (как Linux), а есть одно-процессные (как DOS).
    - Мульти-процессные системы характеризуются следующим:
      ● Они держат все не завершённые процессы в памяти.
      ● Каждый процесс может находиться в разных состояниях (в том числе "запущен" или "ждёт").
      ● Если процесс "запущен" - он занимает CPU.
      ● А если "ждёт", то не занимает. А CPU занимается другим процессом, не простаивает.
      ● Т.О., когда процесс ждёт какой-то ресурс, CPU не простаивает впустую.
    - Одно-процессные системы характеризуются следующим:
      ● Они держат в памяти только 1 текущий исполняющийся процесс.
      ● Пока исполняющийся процесс окончательно не завершится, CPU не высвободится.
      ● Даже если исп.проц.ждёт какой-то ресурс, CPU будет тупо простаивать.

  > Возможные состояния процесса
    - Каждый процесс в Linux имеет св-во "состояние".
    - Оно может изменяться с течением времени.
    - Посмотреть состояния процессов можно командой top:
      ● Состояние обозначается той или иной буквой в колонке "S".
      ● Обозначения состояний таковы:
          R   - работает, или котов к работе
          D   - ожидает дискового ввода/вывода (в беспробудном сне)
          T   - остановлен
          S   - ожидает
          Z   - зомби
          <   - с отрицательным значением nice
          N   - с положительным значением nice
    - Возможные состояния:
      1) Running - "Работает"   - R
        - Этот процесс либо сейчас задействует CPU, либо готов это сделать.
      2) Wating  - "Ожидает"    - S
        - Ждёт какое-нибудь событие или ресурс.
        - В Linux бывает 2 типа "ожидающих" процессов:
          1] Прерываемые
            - Прерываемый процесс может быть прерван сигналом.
          2] Не прерываемые
            - Не прерываемый процесс ожидает некого события от "железа".
            - В связи с чем прервать его не представляется возможным.
      3) Stopped - "Остановлен" - T
        - Процесс был остановлен. Обычно, с помощью сигнала.
        - Процесс, который отлаживается, также может быть в этом состоянии.
      4) Zombie  - "Зомби"      - Z
        - "Мёртвый" процесс, все скрипты в котором уже выполнились, и в котором уже никогда ничего не будет происходить.
        - Однако, по какой-то причине, ссылка на task_structure (объект-процесс) которого всё ещё находится в task vector'е.

  > Жизненный цикл процесса: fork(), exec(), exit(), wait()
    - Всё рождается и умирает. Так, и у процесса в Linux есть жизненный цикл.
    - fork() - системный вызов, создающий новый процесс (потомок), путём деления (клонирования себя любимого).
    - Он является практически полной копией процесса-родителя, выполняющего этот вызов.
    - Различия следующие:

      1) PID и PPID процессов различаются (естественно).
      2) Потомок получает собственную таблицу файловых дескрипторов (копию родительской).
      3) Для процесса-потомка очищаются все ожидающие доставки сигналы.
      4) Временная статистика выполнения процесса-потомка в таблицах ОС обнуляется.
      5) Блокировка памяти и записи, установленные в процессе-родителе, не наследуются.

    - После fork() процесс-потомок чаще всего выполняет системный вызов exec().
    - Это загружает в пространство процесса новую прогрумму.
    - Именно так, и только так, в UNIX-системе выполняется запуск программы в отд.процессе.
    - Некоторые прогр. создают доч.проц. не для запуска др.прогр., а для вып.параллельн.задачи.
    - Например, так поступает веб-сервер apache.
    - Он заранее создаёт много доч.процессов, которые потом обслуживают клиентские соединения.
    - По окончании работы внутри доч.процесса, программа зовёт системный вызов exit().
    - В результате чего этот дочерний процесс завершается, память высвобождается.
    - Чтобы полностью вычистить из ядра инфу о процессе, РОДИТЕЛь должен вызвать wait().

  > Каким образом получаются процессы-зомби
    - Если родитель к моменту вызова программой exit() в дочернем процессе уже умер, то в системе появляется процесс-зомби.
    - Проверить наличие процессов-зомби в системе можно командой top.
    - Единственный способ убрать зомби из системы - перезагрузить её.
    - Поэтому количество процессов-зомби в системе (если её не перезагружать) может только расти.
    - Чем бользе зомби в системе, тем меньше ресурсов остаётся у системы для работы.
    - В конечном итоге может наступить коллапс. Так что зомби это плохо.
    - Зомби сделали, как некую сигнальную систему о том, что что-то не в порядке, если они появляюстя.
    - Что либо в коде проблемы, либо в оборудовании (чаще всего в памяти).

  > Подробно о том, как создаются процессы (начиная с init)

    # Начальный процесс
      - Система стартует, и запускается в режиме ядра.
      - В этот момент есть, во пределённом смысле, лишь 1 процесс - начальный (initial).
      - Назначением начального процесса является инициализация системы.
      - Когда система инициализирована, начальный процесс запускает процесс init, который называют "поток ядра".
      - И, в конце, просто переходит в "холостой цикл", ничего не делает.

    # Процесс init
      - Называется "потоком ядра" и имеет ID == 1. Является корнем дерева процессов системы.
      - Осуществляет некоторые начальные настройки системы.
        ● Например, открытие псевдотерминала системы.
        ● Или монтирования корня файловой системы.
      - Процесс init исполняет скрипт /etc/inittab для стартового запуска всех необходимых процессов.
        ● Это новые создаваемые процессы пополняют дерево процессов с корнем в init.
        ● И каждый из них, разумеется, также может продолжить создавать процессы, если это предусмотрено его скриптами.
          - К примеру, getty может запустить процесс login, когда пользователь попытается аутентифицироваться.
      - И в конце, он запускает "стартовую программу" текущего пользователя по умолчанию.
        ● У реальных пользователей это обычно какой-нибудь shell.
        ● В Ubuntu, например, по умолчанию это /bin/bash.

    # Как создаётся новый процесс путём клонирования
      - Новые процессы создаются путём клонирования процесса, который создаёт новый процесс.
      - Осуществляется системный вызов fork(), и внутри ядра (в режиме ядра) осуществляется клонирование процесса.
        ● К моменту завершения fork() процесс уже является склонированным.
        ● Ссылка на объект-процесс (структуру "task_struct") добавляется в task vector.
        ● Содержание процесса-родителя копируется в процесс-потомок.

    # Ресурсы процесса-родителя могут быть расшарены для процесса-потомка
      - Это касается:
        ● Файлов процесса.
        ● Обработчиков сигналов процесса.
        ● Виртуальной памяти процесса.
      - А ведь в виртуальной памяти и содержится исполняемый код процесса, его переменные и многие прочие важные данные.

    # Подробнее о том, как расшаривается виртуальная память между родителем и потомком
      - В Linux для этого используется техника "копировать при изменении".
      - Вот, как это работет:
        ● Вот есть процесс А. Он взял, и создал процесс Б, путем клонирования себя.
        ● На этом этапе у них общая виртуальная память. То есть, они имею одинаковые ссылки на одну и ту же область реальной памяти.
        ● Как только А или Б пытаются изменить что-либо у себя в виртуальной памяти, вот тут то и происходит копирование.
        ● Виртуальная память процесса А копируется в новую область реальной памяти.
        ● Ссылку на эту новую копию и получает процесс Б.
        ● После этого, очевидно, содержимые их виртуальных памятей уже никак не связаны.

  > Интерактивные и не интерактивные процессы
    - Все процессы можно поделить на:
      1) Интерактивные
        - Эти процессы привязаны к конкретному виртуальному терминалу.
        - Посредством этого терминала пользователь и может с ними взаимодействовать.
        -
      2) Неинтерактивные (демоны)
        - Которые не привязаны к какому-либо виртуальному терминалу.
        - И на которые пользователь не может влиять непосредственно.
        - Взаимодействие с ними возможно посредством так называемых сигналов.
        - Неинтерактивные процессы называют также термином "daemon" (Disk And Execution MONitor).
        - Эти процессы функционируют в фоновом режиме.
        - Они активизируется при необходимости совершения какого-либо действия.


  > Обзор категорий св-в структуры "task_struct" процесса

    --------------------------------------
    Подоглавление:

      - Обзор
      - Идентификаторы
      - Планирование
      - Файлы
      - Виртуальная память
      - Счётчики и таймеры
      - Исполняемые программы

    --------------------------------------

    > Обзор

      # Состояние
        - "Запущен" / "Ждёт" / "Остановлен" / "Зомби".

      # Информация для планирования
        - Планировщику ресурсов нужна инфа о приоритетах процессов.
        - Чтобы решить, какой процесс на каком месте стоит в очереди к CPU.

      # Идентификаторы
        - Каждый процесс в системе имеет уникальный ID.
          ● Этот UID не совпадает с индексом в массиве task vector.
        - У каждого процесса также есть UID'ы владеющих им пользователя и группы.
          ● Процесс, в итоге, имеет те же права в системе, что имеет владеющий им пользователь.

      # Межпроцессное взаимодействие
        - Linux поддерживает классические механизмы IPC (Inter Orocess Communication) из UNIX: сингалы, пайпы, семафоры.
        - А также механизмы из System V: расшаренная память и очереди сообщений.

      # Связи
        - В Linux процессы связаны друг с другом, и состоят в 1 общем дереве с корнем в init.
        - Каждый процесс имеет указатель на: родителя, соседей, детей.
        - Посмотреть всё текущее дерево процессов в системе можно командой pstree.

      # Таймеры
        - Ядро отслеживает время создания процессов, а также ведёт статистику потребления им CPU.
        - На каждом "тике" ядро обновляет эту статистику.

      # Файловая система
        - Процессы могут работать с файлами. Открывать/изменять/закрывать/удалять.
        - Ссылки на все открытые файлы хранятся в объекте-процессе.

      # Виртуальная память
        - Большая часто процессов имеет некоторую виртуальную память.
        - Однако, потоки ядра и демоны не имеют.
        - Ядро должно отслеживать, как эта виртуальная память соотносится с реальной физической памятью системы.

      # CPU-специфичный контекст

    > Идентификаторы

      > Немного о правах доступа к файлам
        - Linux авторизует пользователей по их ID, а также ID групп, в которых они состоят.
        - Под "авторизует" имею в виду именно то, что это значит - наделяет правами.
        - Каждый файл в Linux имеет владельца и права доступа.
        - Эти права доступа определяют, кто и что может делать с этим файлом.
        - Основные права доступа:
          1) Чтение
          2) Запись
          3) Исполнение
        - Эти права указываются отдельно для 3 классов пользователей:
          1) Пользователь-владелец файла
          2) Пользователи, состоящие в указанных группах
          3) Все прочие пользователи
        - Подробнее о правах см. в разделе про файлы.

      > 4 пары инеднитифкаторов процессов и групп, содержащихся в содержатся в task_struct.
        1) uid, gid
          - User ID (пользователя) и Group ID (группы пользователя). От имени которого запущен процесс.
        2) эффективные uid, gid
          - Есть программы, которые могут изменить UID / GID.
          - Эти программы известны, как "setuid-программы".
          - Они полезные, потому что позволяют запустить процесс пользователю А с правами доступа пользователя Б.
          - Эффективные UID, GID - это и есть значения, назначенные такой программой.
        3) uid, gid файловой системы
          - Обычно тут те же значения, что у эффективных UID, GID.
          - Нужны для NFS сервера по каким-то там причинам безопасности.
        4) сохранённые uid, gid
          - Эти должны существовать в соответствии с POSIX-стандартом.
          - Используются программами, которые меняют UID, GID процесса с помощью системных вызовов.
          - Используются, чтобы сохранить в неизменном виде реальные UID, GID.

    > Планирование

      > Системный вызов
        - Термином "системный вызов" называют обращение процесса к ядру.

      > Системный режим
        - Все системные вызовы процессы осуществляют в "системном режиме" работы.
        - "Системный режим" означает, что в этот момент процесс выполняется от имени ядра системы.
        - Системные вызовы внутри ядра существуют как функции на языке C.
        - Их имена начинаются с префикса sys_.

      > Пользовательский режим
        - Все остальные операции, кроме сист.вызовов, процесс осуществляет в "пользовательском режиме".
        - "Пользовательский режим" означает, что процесс в этот момен выполняется от имени пользователя.

      > Экономия ресурсов CPU процессами
        - Как только процесс начинает ждать чего-то, он "отпускает" CPU.
        - Например, когда он ждёт польз.ввода, CPU не расходуется.

      > Планировщик распределения ресурсов процессам в Linux
        - В Linux каждый процесс имеет приоритет от -19 (наинизший) до 20 (наивысший).
        - Задача планировщика отсортировывать все процессы в очередь, по важности - по убыванию.
        - Иными словами, в каждый момент времени определять, какой процесс больше всего заслуживает быть исполненным следующим.

      > Ещё механизм экономии ресурсов CPU - time-slice
        - В Linux каждый процесс может выполняться в течение MAX 200 мс.
        - Когда эти 200 мс проходят, планировщик запускает следующий в очереди процесс.
        - Этот промежуток времени - 200 мс - и называется time-slice.
        - Данный механизм позволяет избежать ситуации, когда процесс "захавал" ресурсы и долго не отдаёт.
        - Состояние предыдущего процесса сохраняется в структуре task_struct процесса.
        - А состояние текущего извлекается из его структуры task_struct.

      > Готовый к работе процесс (runnable)
        - Так называют процесс, который ожидает, пока планировщик выделит ему процессорное время.
        - То есть он готов стартовать, и ждёт только выделения ему ресурсов CPU.

      > Два вида процессов в Linux: "нормальные" и "реального времени"
        - Процессы "реального времени" имеют больший приоритет, чем "нормальные".
        - Если процесс "реального времени" готов к работе, он всегда будет запущен первее.

      > Какие данные хранятся в task_struct процесса, касаемо планировщика:

        # Политика (policy)
          - Какую политику применяет планировщик к текущему процессу.
          - Действует лишь на процессы реального времени.
          - Есть 2 вида политики:
            1) round robin
              - Процессы запускаются по очереди в соотв. с их приоритетами.
            2) first in first out
              - Процессы всегда запускаются в том порядке, в котором они попали в очередь.
              - И порядок никогда не меняется.
        # Приоритет нормального процесса (priority)
          - Приоритет, который действует среди нормальных процессов.
        # Приоритет процесса реального времени (rt_priority)
          - Приоритет, который действует среди процессов реального времени.
          - А вообще, любой процесс реального времени приоритетнее любого нормального процесса.
        # Счетчик (counter)
          - Кол-во времени, в течение которого процесс может работать (в тиках).
          - Устанавливается при первом запуске процесса равным priority.
          - И декрементируется при каждом тике часов.

      > Что делает планировщик при каждом своём запуске?

        # При каких условиях запускается планировщик
          - При добавлении процесса в очередь.
          - В конце системного вызова (перед возвращением в пользовательский режим из системного).
          - Когда counter (счётчик) процесса становится равным 0.

        # Работа в ядре
          - Обработка задач планировщика.

        # Работа с текущим процессом
          - Прежде, чем переходить к следующему, планировщик должен разобраться с предыдущим процессом:
            1) Если это процесс реального времени, и у него политика round robin
              - Он помещается в конец очереди.
            2) Если задача "INTERRUPTIBLE" он получил сигнал с последнего времени
              - Он становится "готовым к запуску".
            3) Если 200 мс текущего процесса вышли, он становится "готовым к запуску".
            4) Если текущий процесс "готов к запуску", он таковым и остаётся.
            5) Если процесс ни "готов к запуску", ни "INTERRUPTIBLE"
              - Он удаляется из очереди.

        # Выбор процесса
          - Планировщик ищет в очереди процессов наиболее заслуживающий выделения ему времени CPU.
          - Если присутствуют процессы реального времени, планировщик в 1 очередь обращается к ним.
            - Весом каждого нормального процесса является значение его counter.
            - А весом каждого процесса реального времени: его counter + 1000.
          - Среди процессов с равным приоритетом те, кто уже потребил ресурсы CPU, имеют меньший приоритет.
            - Так как их counter уже декрементирован на потреблённое кол-во тиков.
          - Если несколько процессов имеют абсолютно одинаковый приоритет
            - Выбирается ближайший к началу очереди.

        # Своп процесса
          - Допустим, планировщик запустился, и текущий процесс оказался не самым приоритетным.
          - Значит, планировщик должен его отложить в сторонку, и выделить время CPU другому - самому приоритетному.
          - Когда процесс работает, он задействует регистры CPU и физическую память системы.
          - Чтобы "отложить" текущий процесс, надо сохранить его состояние в его task_struct.
          - Чтобы запустить другой процесс, надо загрузить его состояние из его task_struct.
          - Эти вещи и называют свопингом процесса.

    > Файлы

      > 2 структуры данных, описывающих связанную с файлами инфу процессов
        1) fs_struct
        2) files_struct

      > Структура данных fs_struct
        - Содержит указатели на процесса inode'ы в виртуальной файловой системе.
        - А также содержит umask (права по умолчанию при создании файлов).

      > Структура данных files_struct
        - Содержит инфу обо всех файлах, которые использует в настоящий момент процесс.
        - Программы читают из "стандартного входа" и пишут в "стандартный выход".
        - Сообщения об ошибках пишутся в "стандартный выход".
        - Это могут быть: файлы, вход/выход терминала или устройство.
          - Но все они могут быть рассмотрены, как файлы.
        - Каждый файл имеет свой собственный дескрипотор.
        - Структура files_struct содержит до 256 таких указателей на файлы.
        - Каждый раз при открытии файла в пустую ячейку в files_struct добавляется указатель на новую fs_struct этого файла.

      > При создании процесса в files_struct создаётся 3 новых fs_struct
        - Вот они:
          1) Standard input (id == 0 в files_struct)
          2) Standard output (id == 1 в files_struct)
          3) Standard error (id == 2 в files_struct)
        - И обычно они наследуются процессом от своего родителя.

    > Виртуальная память

      > Что содержит
        - Содержит исполняемый код и данные из разных источников.

      > Во-первых
        - Содержит ВП экземпляр запущенной программы.
        - Рассмотрим, например, программу 'ls'.
        - Она, как и большинство, состоит из исполняемого кода и данных.
        - Файл экземпляра содержит всю необходимую инфу для загрузки исполняемого кода и данных программы в виртуальную память процесса.

      > Во-вторых
        - Процесс может выделять виртуальную на разные свои нужды.

      > В-третьих
        - Процессы в Linux часто используют различного рода библиотеки.
        - Эти библиотеки содержат код, который может пригодиться там-сям.
        - И нет смысла пихать копии этих библиотек в память каждого процесса.
        - Вместо этого Linux расшаривает эти библиотеки для каждого из процессов.
        - А у каждого процесса просто есть ссылки на эти библиотеки.

      > Технология demand paging
        - Всё, что в виртуальной памяти процесса, не находится в физ.памяти постоянно.
        - Это было бы расточительно. Ведь не вся инфа из вирт.пам. постоянно используется процессом.
        - Вместо этого данные из вирт.памяти процесса загружаются в физ.память только тогда, когда они нужны процессу.
        - Эта фишка в Linux и называется "demand paging". Она экономит физичискую память системы.

    > Счётчики и таймеры

      > Счётчики
        - Ядро отслеживает дату и время создания каждого процесса.
        - Также ядро отслеживает кол-во времени CPU (в тиках), потреблённого каждым процессом.

      > Интервальные счётчики
        - Процесс может их использовать для отправки себе тех или иных сигналов.
        - Происходит это так:
          1) Устанавливается некий интервальный счётчик (скажем, 100 тиков).
          2) При опред.обстоят-вах (в завис. от типа счётчика) из значения счётчика вычитается 1.
          3) Когда значение счётчика становится == 0, процессу отправляется заданный заранее сигнал.
        - Есть 3 вида счётчиков:
          # Реальный
            - 1 из счётчика вычитается при каждом тике в реальном времени.
            - Когда он истекает, то посылает процессу сигнал SIGALRM.
          # Виртуальный
            - 1 из счётчика вычитается только, когда процесс работает.
            - Когда он истекает, то посылает процессу сигнал SIGVTALRM.
          # Профильный
            - 1 из счётчика вычитается и когда процесс работает, и когда система выполняется от имени процесса.
            - Когда он истекает, то посылает процессу сигнал SIGPROF.
        - Информацая о интервальных счётчиках хранится в task_struct процесса.
        - Для настройки/старта/запуска/чтения интервальных счётчиков следует использовать системные вызовы.

    > Исполняемые программы

      > Командный интерпретатор
        - В Linux программы выполняются командным интерпретатором (КИ).
        - КИ - пользовательский процесс, который называют "оболочкой" (shell).

      > Оболочки
        - Для Linux создано большое количество различных оболочек.
        - Наиболее популярные: sh, bash и tcsh.
        - В Ubuntu, например, по умолчанию установлена оболочка Bash.

      > Программа - исполняемый бинарный файл
        - За исключением нескольких встроенных программ, таких как cd или pwd, программа - исполняемый бинарный файл.

      > Выполнение программы shell'ом. Переменная окружения PATH
        - У каждого процесса есть переменная окружения PATH.
        - При вводе имени программы программы shell ищет её во всех путях, перечисленных в PATH.
        - Если файл программы найден, он загружается и исполняется.
        - Shell осуществляет сист.вызов fork() и в системном режиме клонирует свой процесс.
        - Затем этот процесс-потомок осуществляет сист.вызов exec() и загружает программу в процесс.

      > Перезапустить процесс в фоновом режиме
        - Затем shell ожидает, пока процесс-потомок закончит свою работу.
        - Нажав ctrl+z можно послать выполняющемуся процессу-потомку сигнал SIGSTOP, и остановить его.
        - А введя после этого команду bg, перезапустить его в фоновом режиме.
        - В результате чего shell снова станет доступен.

      > Форматы исполняемого файла
        - Исполняемый файл может иметь самые разные форматы.
        - Он может иметь также формат "скрипт".
        - Чаще всего используемый формат - ELF - Executable and Linkable Format.
        - То, какие форматы исполняемых файлов поддерживаются, вшито в ядро Linux.

      > Формат ELF
        - Наиболее часто используемый формат исполняемого файла в Linux.
        - Расшифровывается, как Executable and Linkable Format.
        - Содержит исполняемый код, который может ссылаться на текст и данные.
        - Содержит инфу о том, как программа должна быть загружена в виртуальную память процессора.

      > Формат "скрипт"
        - Для запуска скрипта необходим интерптератор.
        - Существует большое кол-во интерпретаторов, написанных для Linux.
        - В первой строке файла-скрипта и нужно указать этот интерпретатор.
        - Допустим, мы хотим использовать интерптетатор "bash":

            #!/bin/bash


Б6. Файлы

  --------------------------------------
  Подоглавление:

    - Что такое файл
    - Классификация файлов
    - Каталоги
    - Символические ссылки
    - Файлы устройств
    - Каналы и сокеты
    - Обычные файлы
    - Об именах файлов
    - Файл: принадлежность, доступ, режим
    - Временные атрибуты файла

  --------------------------------------

  > Что такое файл

    > Определение
      - Всё, что существует в POSIX-системе в статич.виде - суть файл.
      - Файловая же системи используется как универсальный интерфейс ко всему в системе.
      - В общем, "файл" - идентифицируемая тем или иным образом последовательность байтов.
      - А то, где эта послед-ть хранится, и какую инфу содержит - дело десятое.
      - Это общее определение, в принципе, годится для любых систем, и для Linux тоже.

    > Файл в Linux состоит из 2-х частей
      1) inode
      2) Область данных

    > Про inodes
      - Это область метаданных файла - есть его служебных данных.
      - В inode файла содержатся такие сведения, как:
        # ID файла / ID устройства (на котором расположен файл)
        # Тип файла
        # Счётчик ссылок
        # Вес файла
        # Атрибуты принадлежности / доступа / режима / времени

    > Про область данных
      - Содержит, собственно, ту инфу, для хранения которой файл и предназначен.
      - Она м.б. различной: текстовые символы, двоичные коды и т.д.
      - Однако, POSIX-системе это безразлично, она воспринимает их как двоичные данные.
      - Стоит отметить, что область данных не является обязательной частью файла.
        - Есть системы, которые могут размещать данные маленьких файлов в метаданных.
        - И такие файлы, соответственно, состоят лишь из области метаданных.
        - Это даёт высокую скорость доступа и экономию дискового пространства.
      - Однако, в 99% случаев в Linux, файлы в основном всё имеют область данных.

    > Идентификация файлов
      - Любой файл однозначно идентифицируется с помощью 2-х идентификаторов:
        1) Идентификатор файла
          - Это целое число, уникальное в файловой системе.
          - Принцип образованя такой же, как при автоинкрементации при добавлении новой строки в таблицу.
          - По этому ID система находит конкретный файл в ФС.
        2) Идентификатор устройства
          - Linux м.б. установлен на несколько дисковых разделов.
          - И каждый из них имеет свою файловую систему.
          - Все эти файловые системы в совокупности образуют ветви единого дерева.
          - Проблема в том, что ID файлов на каждом из разделов строятся независимо от других разделов.
          - Поэтому, чтобы идентифицировать файл по ID, надо также знать и ID устройства, в ФС которого расположен файл.

    > Дескрипторы файлов
      - Работу с файлами осуществляют процессы.
      - Каждый процесс может иметь некий набор открытых им файлов.
      - По мере открытия файлов процессом, им внутри процесса присваиваются ID.
      - Эти уникальные ID и называют файловыми дескрипторами процесса.
      - Особое значение имеют дескрипторы 0, 1 и 2.
        # 0 - /dev/stdin  - файл устройства стандартного ввода.
          - На обычном компьютере это, обычно, клавиатура.
        # 1 - /dev/stdout - файл устройства стандартного вывода.
          - На обычном компьютере это, обычно, монитор.
        # 2 - /dev/stderr - файл устройства стандартного потока ошибок.

  > Классификация файлов

    > В POSIX-системах отсутствует понятие типа файла
      - Например, в Windows, есть т.н. расширения файлов: .exe, .txt, .bat и т.д.
      - Эти расширения указывают на тип файла в системе.
      - Так вот, в POSIX-системах понятие "тип файла" и "расширение" отсутствуют.

    > Классификация
      - Под понятие "файла" в POSIX-системах попадает очень многое.
      - Поэтому требуется, и поэтому существует, некая классификация файлов.
      - Это совсем не тоже самое, что типы файлов, скажем, в Windows.
      - К какому "классу" относится файл описано в его inode.
      - Вот какие классы доступны:
        1) Каталоги
        2) Символические ссылки
        3) Специальные файлы устройств
        4) Именованные каналы и сокеты
        5) Обычные, или регулярные, файлы.
      - С каталогами и обычными файлами приходится иметь дело постоянно.
      - С символическими ссылками приходится иметь дело довольно часто.
      - С файлами устройств приходится иметь дело время от времени.
      - С каналами и сокетами приходится иметь дело очень редко.

  > Каталоги

    > Каталог - это файл
      - Каталог - файл, объединяющий другие файлы.
      - В том числе каталог может рекурсивно содержать другие каталоги.
      - Каталоги, содержащиеся в каталоге X, называют "подкаталогами" по отношению к X.

    > Каталог содержит список ID входящих в него файлов
      - То есть каталог выступает, по сути, как группа по отношению к содержащимся в нём файлам.
      - Метафора "библиотечного каталога" как нельзя лучше отражает смысл каталогов в Linux.

    > Имя файла в ФС UNIX'ов существует только в составе каталога
      - И никак иначе.

    > Что такое жёсткая ссылка
      - Это механизм соотнесения имени файла (в составе каталога) и его метаданных (inode) по ID.
      - Кол-во жёстких ссылок на inode отражено в значение его счётчика.

    > У вышесказанного есть 3 следствия:
      1) Идентификатора устройства, несущего данный файл, в каталоге нет
        - А ведь для однозначной идентификации файла id устройства необходим.
        - Поэтому абсолютное имя файла действительно лишь в той же файловой системе, в которой находится inode, с которым они связаны жёсткой ссылкой.
      2) На 1 inode может быть создано сколько угодно жёстких ссылок
        - Файл с 1 и тем же физ.содержанием может выступать под целым рядом разных имён.
        - И все эти имена будут равноправны между собой, и ссылаться на 1 и тот же файл.
      3) Когда файл в Linux можно считать удалённым?
        - Когда выполнены следующие условия:
          1] Когда уничтожены все жёсткие ссылки на него.
            - Т.Е. из ФС удалены все имена, ссылающиеся на файл.
            - В этот момент в inode файла счётчик жёстких ссылок на него становится == 0.
          2] Когда закрыта последняя программа, обращающаяся к файлу
            - Ведь у процесса программы также есть ссылка на открытый ей файл.
            - Так что 2] по сети является часть 1].
        - Когда ссылок на inode файла не остаётся, то получить доступ к нему становится невозможным.
        - Поэтому система высвобождает дисковые ресурсы, ранее занимаемые файлом.

    > Дерево файловой системы
      - Файл доступен для системы, если он включён в файловую систему.
      - То есть его имя приписано хотя бы к 1-му каталогу.
      - А каталог также является файлом, и он включён в свой родительский файл-каталог.
      - Символически он обозначается ..
      - Текущий же каталог символически обозначается .
      - Каталоги образуют дерево с корневым элементом /.
      - Это дерево и называют деревом файловой системы.
      - Корневому каталогу всегда присваивается ID == 2.
      - Корневой каталог сам является своим родителем (ссылки . и .. указывают на него самого).
      - Отдельные ветви ФС, расположенные на самостоятельных дисковых разделах, также имеют корневой каталог с id == 2.
      - Однако, т.к. они имеют id устройств, по ним их и можно различать.

  > Символические ссылки

    > Ограничения жёстких ссылок
      - Жёсткие ссылки имеют пару неудобных ограничений:
        1) Жёсткая ссылка на файл может существовать лишь в той ФС, где расположен его inode.
        2) Ещё одно ограничение жёстких ссылок - они могут ссылаться лишь на обычные или спец.файлы (устройства), но не на каталоги.
      - Однако, часто возникает потребность ссылаться на файл в одной ФС из другой ФС.
      - Или построить полное дерево ФС со всеми типами файлов, в т.ч. каталогами.

    > Символическая ссылка - это файл
      - Для разрешения вышеописанных проблем был придуман особый тип файла - символическая ссылка.
      - В отличие от жёсткой ссылки (связь имени с inode), символическая ссылка - это именно файл.
      - Полноправный файл со своим inode, областью данных, и всеми атрибутами.
      - Этот файл содержит путь к другому файлу, и указывать на него - и есть его предназначение.
      - В том числе, символическая ссылка может указывать и на каталог, ведь это тоже файл.

    > Символическая ссылка олицетворяет файл, на который ссылается
      - При попытке отредактировать файл-симв.ссылку, в редакторе открывается тот файл, на который она указывает.
      - Если же файл, на который ссылается симв.ссылка не доступен, то при попытке открыть его будет, разумеется, ошибка.

    > Дублирование целых ветвей дерева ФС
      - Символические ссылки позволяют продублировать в разных местах ФС целые ветви дерева ФС.
      - Например, папку /home/gekkman можно продублировать в: /xyz и /xyz/abc
      - И при переходе в эти каталоги мы будем попадать в /home/gekkman, потому что они на него ссылаются.

    > Решение проблемы с программами, требующими устаревшие библиотеки
      - Многие программы для своей работы требуют разнообразные библиотеки кода.
      - Эти библиотеки могут быть разных версий.
      - Например, библиотека "abc" м.б. версии 4 и 5.
      - Многие программы откажутся работать с новой версией 5, и будут требовать версию 4.
      - Однако, по факту, они могут работать с 5-й, но в алгоритме жёстко вшита 4-ая.
      - Т.Е. программа ищет по адресу /x/y/abc4 библиотеку abc 4-й версии.
      - Берём и создаём символическую ссылку по этому адресу, указывающую на /x/y/abc5, и вуаля.

    > Абсолютный и относительный путь
      - Символьную ссылку можно создать по относительному или абсолютному пути.
      - Какой из них использовать, зависит от ситуации.
      - Если планируется перенос в др.файловую систему, то лучше относительный путь.
      - А если не планируется, то лучше абсолютный путь.

  > Файлы устройств

    > Устройства и псевдоустройства
      - Файлы устройств соответствуют различным устройствам, присутствующим в системе.
      - Это могут быть как реальные устройства, так и псевдоустройства.
      - Псевдоустройства - которые не представляют никакого реального "железа".
      - Примеры файлов псевдоустройств: /dev/null и /dev/zero.

    > Символьные и блочные устройства
      1) Файлы символьных устройств:
        - Доступ к ним осущетсвляется только побитный (посимвольный).
        - Примеры: после. и параллел. порты, виртуальные и реальные терминалы.
      2) Файлы блочных устройств:
        - К ним можно осуществлять произвольный доступ.
        - Чаще используются блоки информации фиксированной длинны, реже - переменной.
        - Примеры: жёсткие диски и другие накопители.

    > Система идентификации файлов устройств: старший и младший номера
      - У файлов устройств есть собственная система идентификации.
      - Каждое устройство имеет свои старший и младший номера:
        1) Старший
          - Определяет класс устройства.
          - Например, номер 12 - указывает на класс виртуальных консолей.
        2) Младший
          - Является просто порядковым номером устройства в своём классе.
          - Причём нумерация начинается с 0, далее 1, 2 и т.д.
          - Например, если в системе 3 вирт.консоли (major 12), они имеют младшие номера 0,1,2.

    > Фиксированные и динамические файлы устройств
      - Файлы устройств могут быть фиксированными или динамическими:
        1) Фиксированные
          - Обычно создаются при установке системы и включают в себя всё, что теоретически может быть подключено к системе.
          - Например: 4 файла жёстких дисков, по 4 файла для каждого с первичными разделами, куча файлов терминальных и псевдотерминальных устройств и т.д.
          - Но бывает и так, что для подключённого устройства файла-устройства там не находится.
          - Тогда пользователь может пополнить список, скажем, командой mknode.
        2) Динамические
          - Применяется в системах, которые используют "файловую систему устройств" - devfs, или же механизм udev.
          - Создание файлов устройств происходит каждый раз заново при старте системы.
          - Создаются лишь файлы тех устройств, которые реально присутствуют в системе, и поддерживаются текущей конфигурацией ядра.

    > Философия файлов устройств
      - Файлы устройств позволяют польз-лям взаимодействовать с ними, не вдаваясь в детали о том, как эти устройства устроены.
      - То есть, по сути, файлы устройств - это интерфейсы к этим устройствам, оформленные, как файлы.
      - А раз это файлы, то и ведут они себя, как файлы, в т.ч. работает перенаправление ввода/вывода.
      - Скажем, надо что-то распечатать. Берём, перенаправляем этот текст на файл-устройстов принтера. И вуаля!

  > Каналы и сокеты
    - Существуют специальные виды файлов - именованные каналы и сокеты.
    - Они предназначены для обмена данными между процессами.

  > Обычные файлы

    > Определение обычного файла
      - Дать определение обычному файлу можно только методом исключения.
      - Обычный файл - файл, который не является:

          # каталогом,
          # символич.ссылкой,
          # файлом устройства,
          # каналом и сокетом.

    > Множество обычных файлов охватывает следующие вещи:

        # Исполняемые бинарные файлы
        # Файлы сценариев оболочки
        # Текстовые файлы
        # Файлы изображений
        # Файлы в форматах специальных программ
        # Файлы процессов

    > Что общего у всех обычных файлов
      - Их содержимое всегда может быть просмотрено обычными командами вроде cat, more, less.
      - Ну или с помощью тех программ, с помощью которых они были созданы.
      - Тогда как непосредственный просмотр содержимого прочих типов обычным образом невозможен.
      - Доступ к ним можно получить только косвенными путями.

    > Процессы - обычные файлы
      - Файлы процессов - суть обычные файлы. Для их представления задействуется файловая система procfs.
      - Многие из которых могут быть легко просмотрены обычными инструментами.

    > Вообще файл - не обязательно область на диске
      - ФС процессов с её содержимым никакого места на диске не занимает.
      - А является лишь отображением происходящего в системе, и живёт в памяти.
      - В виде, пригодном для восприятия универсальным интерфейсом файловой системы.

  > Об именах файлов

    > Максимальный размер имени файла
      - Он зависит от формата каталога файловой системы.
      - В большинстве ФС со времён улучшений в Беркли ничего не изменилось.
      - Максимальный размер имени файла в них равен 256 однобайтовым символам.

    > Запрещённые системой в имени символы
      - Их всего 2:
        1) /
          - Зарезервирован как имя собственное корневого каталога.
          - И как элемент пути к файлу.
        2) NULL
          - Имеется в виду, что запрещено отсутствие имени файла.

    > Чувствительность к регистру
      - Имена файлов в POSIX-системах чувствительны к регистру.
      - То есть имена "Readme" и "readme" не равны.

    > Ограничения, накладываемые прикладными программами
      - Например, оболочки, накладывают на имена файлов определённые ограничения.
      - Целый ряд символов, не являющихся алфавитно-цифровыми, они могут интерпретировать по-своему.
      - Например: как коды управления, регулярные выражения и т.д.
      - Конечно, можно изменять параметры оболочек, отключать специальные значения этих символов...
      - Но нужно ли? Проще просто не использовать некоторые символы в именах файлов, будет меньше проблем:
        # Символы верхнего цифрового ряда: ~!@#$%^&*()_-+=
        # Обратный слэш (символ отмены специального значения): \

    > Имя файла может содержать сколько угодно .
      - Имя файла может содержать сколько угодно точек .
      - Ведь такого значения, как в Windows - отделения расширения от имени - в Linux они не имеют.
      - Примеры: "archive.tar.gz", "archive.tar.bz2".
      - Но есть исключение: точка в начале файла (см. ниже dot-файлы).

    > Dot-файлы
      - Так называют файлы, имя которых начинается с точки .
      - Например: ".archive", ".office365".
      - Имена dot-файлов недоступны при просмотре каталогов без специальных средств.
      - Часто dot-файлами делают конфигурационные файлы пользователей.

    > Абсолютный и относительный пути к файлу
      - Одно и то же имя вполне может существовать в разных каталогах.
      - Поэтому имя файла, само по себе, не позволяет однозначно идентифицировать его положение.
      - Отсюда возникает понятие пути к файлу, как цепочки подкаталогов, оканчивающейся именем файла.
      - Путь к файлу может быть:
        1) Абсолютный
          - Начинается в корне / ФС, а заканчивается именем целевого файла.
          - Например: /home/myfile
        2) Относительный
          - Начинается от какого-либо каталога (но не корневого), а заканчивается именем целевого файла.
          - Например, открыт у нас шелл. И вводим мы относительный путь, который не начинается с /.
          - Этот путь рассматривается шеллом относительно текущего активного каталога ..

    > Ограничения на длину пути к файлу
      - В Linux это 4096 1-байтовых символов.

    > Особенности вызова исполняемого файла из текущего каталога .
      - В Windows мы привыкли, что можно запустить исполняемый файл в текущем каталоге, просто вызвав его по имени.
      - В Linux это не так.
      - А чтобы в Linux это сделать, надо ввести: ./execfile (если мы хотим запустить файл execfile из текущего каталога)

  > Файл: принадлежность, доступ, режим

    ------------------
    Подоглавление:

      - Введение
      - Атрибуты принадлежности
      - Атрибуты доступа
      - Атрибуты режима
      - Чтение атрибутов файла
      - Права файла "по умолчанию", umask

    ------------------

    > Введение
      - У файла, помимо всего прочего, есть следующие важнейшие атрибуты:
        1) Принадлежности
        2) Доступа
        3) Режима

    > Атрибуты принадлежности

      > Каждый файл в системе
        а) имеет своего хозяина;
        б) приписан к какой-либо группе пользователей;
        в) находится в неких отношениях со всеми прочими.

      > Кто хозяин файла
        - В качестве хозяина обысно выступает его создатель.
        - Точнее хозяин процесса, этот файл создавшего.
        - Ещё точнее: пользователь, ID которого был унаследован процессом, этот файл создавшим, в качестве эффективного UID.
        - Вот пример того, как обычный пользователь может создать файл, хозяин которого - root (админ):
          # Админ создаёт исполняемый файл "abc" с атрибутом SUID.
          # Скрипт в этом файле при его запуске создаст файл "xyz".
          # Пользователь запускает выполнение файла "abc".
          # При этом создаётся процесс, UID которого унаследован (благодаря атрибуту SGID) не у пользователя, а у админа.
          # И этот процесс создаёт файл "xyz", который в качестве хозяина и получает админа.

      > Отступление про основную группу пользователя
        - Скажем, в Ubuntu, при создании пользователя "xyz" автоматом создаётся и группа "xyz".
        - Она и является основной для этого пользователя, и он в ней состоит.
        - А вообще, любой пользователь должен состоять в >= 1 группе в любой момент времени.

      > К какой группе приписан файл
        - По умолчанию, при создании, он приписывается к основной группе хозяина файла.
        - Однако, его потом можно и перепрописать в другую группу.
        - Помещение файла в группу удобно использовать для разграничения доступа к нему при коллективной работе.
        - Например: файлы в группе "Проект 1" могут редактировать лишь Петя и Вася, а в группе "Проект 2" - лишь Коля и Вова.

    > Атрибуты доступа

      > Есть 2 вида атрибутов доступа к файлам:
        1) Атрибуты доступа для каталогов
        2) Атрибуты доступа для прочих файлов

      > Атрибутов доступа всего 3:
        1) Атрибут чтения
        2) Атрибут изменения
        3) Атрибут исполнения

      > Атрибуты доступа связаны с атрибутами принадлежности
        - Для каждого файла все 3 атрибута доступа задаётся для каждой из 3-х категорий принадлежности:
          1) Для хозяина файла.
          2) Для пользователей, состоящих в группах, в которых состоит файл.
          3) Для всех прочих пользователей.

      > Значения атрибутов доступа к файлам (кроме каталогов)

        > Атрибут чтения
          - Это право просмотреть его содержимое каким-либо образом.
          - Например, командами less или more, программой nano, и прочими текстовыми редакторами.
          - Естественно, всё это касается только обычных файлов:
            # Файлы устройств, сокеты и каналы таким образом просмотреть нельзя.
            # А попытка просмотра файла - символической ссылки - лишь вызовет её источник.

        > Атрибут записи
          - Даёт право изменять содержимое файла. Например, в каком-нибудь текстовом редакторе.
          - Однако, он не даёт право на удаление файла.

        > Атрибут исполнения
          - Даёт право запускать исполняемые файлы (откомпилированные бинарники или скрипты).
          - Именно этот атрибут превращает набранную в txt-редакторе последовательность команд в сценарий оболочки.

      > Значения атрибутов доступа к файлам-каталогам

        > Атрибут чтения
          - Даёт право просматривать содержимое каталога.
          - Например, командой ls, или каким-либо другим способом.
          - А содержимое каталога, суть - список входящих в него файлов.

        > Атрибут записи

          > О сабже
            - Даёт право изменять содержимое каталога.
            - То есть, модифицировать список входящих в каталог файлов.
            - Например, удалить из него ссылку на какой-либо файл, или наоборот - добавить.
            - При удалении, если это была единственная жесткая ссылка на файл, то он удаляется из системы напрочь.

          > MIN достаточный набор прав для удаления файла
            - Никаких прав на сам файл не требуется.
            - Удалить файл "xyz" из каталога "cat" можно, не имея НИКАКИХ прав на сам файл, но имея право записи на каталог.
            - При этом, можно даже не иметь прав на чтение каталога "cat", если мы знаем точный путь к файлу "xyz".

        > Атрибут исполнения
          - Даёт право входить в каталог командой cd.
          - Без этого права какие-либо операции в каталоге становятся затруднительными.
          - Хотя, если знать, что в нём за файлы, и их точные пути, то операции с ними возможны.
          - Например, можно удалить файл из каталога и без этого атрибута доступа, зная путь к нему.

    > Атрибуты режима

      > Преамбула
        - Файл может иметь 3 дополнительных атрибута, называемых иногда "атрибутами режима":
          1) SUID (Set User IDentificator)
          2) SGID (Set Group IDentificator)
          3) sticky
        - 1 и 2 имеют смысл, в основном, для обычных исполняемых файлов.
        - 3 имеет смысл, в основном, для файлов-каталогов.

      > SUID
        - В просторечии, этот атрибут называют "суидным", или "суидным битом".
        - Смысл его заключается в следующем:
            Файл, которому он присвоен, при запуске на выполнение
            (именно поэтому он имеет смысл только для файлов с атрибутом исполнения)
            порождает процесс, наследующий эффективный UID не пользователя, его запустившего,
            а хозяина файла, правами доступа которого и определяются права процесса.
        - Хозяином большинства файлов за пределами пользовательских каталогов является root.
        - Так что при запуске таких файлов с суидным битом, процесс будет получать права админа.
        - Вот пример того, как обычный пользователь может создать файл, хозяин которого - root (админ):
          # Админ создаёт исполняемый файл "abc" с атрибутом SUID.
          # Скрипт в этом файле при его запуске создаст файл "xyz".
          # Пользователь запускает выполнение файла "abc".
          # При этом создаётся процесс, UID которого унаследован (благодаря атрибуту SGID) не у пользователя, а у админа.
          # И этот процесс создаёт файл "xyz", который в качестве хозяина и получает админа.

      > SGID
        - В просторечии, этот атрибут называют "сгидным", или "сгидным битом".
        - Смысл его примерно тот же самый, что для суидного бита.
        - Только здесь процессом наследуется не эфф.UID пользователя, а эффективный GID группы, к которой приписан помеченный файл.

      > sticky
        - В просторечии, этот атрибут называют "стики бит".
        - Обычно присваивется каталогам.
        - В результате чего файл из такого каталога не может удалить никто, кроме его хозяина.
        - Например, стики бит можно устанавливать на каталоги, хранящие всякие временные файлы:
          # Это может быть каталог какой-нибудь программы.
          # И эта программа в данном каталоги хранит всякие свои временные файлы.
          # Было бы не хорошо, если бы какой-нибудь Вася зашёл в него и всё поудалял.
          # Ведь программа такого не ожидает, и в результате может начать работать неправильно.
          # От таких проблем и убережёт установленный на каталог стики бит.

    > Чтение атрибутов файла

      > 2 вида нотации прав доступа к файлу
        1) Мнемонически-понятная
          - Например: -rwxrwxrwx.
          - Пример выше означает полный доступ к файлу.
          - Символ '-' в начале означает обычный класс файла.
        2) Цифровая
          - Например: 777.
          - Пример выше означает полный доступ к файлу.

      > Как получить информацию о правах доступа к файлу
        - С помощью команды: ls -l

      > Подробнее о мнемонически-понятной нотации
        - Проще всего будет рассказать о ней на примере.
        - Первый пример:

          - Рассмотрим такие права доступа:

              -rwxrwxrwx

          - Их можно разделить на 4 смысловые группы:

              1  2   3   4
              - rwx rwx rwx

          - Рассмотрим, какую смысловую нагрузку несёт каждая из них:

              1) Обозначает тип файла
                  -   | обычный файл
                  d   | каталог (от directory)
                  c   | символьное устройство
                  b   | блочное устройство
                  s   | файл локального сокета (от socket)
                  p   | именованный канал (от pipe)
                  |   | символическая ссылка
              2) Атрибуты доступа к файлу для его хозяина.
                  r   | атрибут чтения
                  w   | атрибут изменения
                  x   | атрибут исполнения
              3) Атрибуты доступа к файлу пользователей, состоящих в группе-владельце файла
                  r   | атрибут чтения
                  w   | атрибут изменения
                  x   | атрибут исполнения
              4) Атрибуты доступа для всех остальных пользователей
                  r   | атрибут чтения
                  w   | атрибут изменения
                  x   | атрибут исполнения

          - А ещё вот такой пример:

              drwxr--r--

          - d значит, что это каталог.
          - Хозяин имеет к нему полный доступ, а остальный - только на чтение.

      > Права доступа, содержащие атрибуты SUID, SGID и sticky

        > SUID
          - При наличии SUID x в правах хозяина заменяется на s:
          - Пример: -rwsrwxrwx

        > SGID
          - При наличии SGID x в правах группы-хозяина заменяется на s:
          - Пример: -rwxrwsrwx

        > sticky
          - При наличии sticky x в правах "всех остальных" заменяется на t
          - Пример: -rwxrwxrwt

      > Подробнее о цифровой нотации прав доступа к файлу
        - Наряду с мнемонически-понятной существует и цифровая нотация доступа к файлу.
        - Проще всего будет рассказать о ней на примере.
        - Рассмотрим пример:

            777

        - Разделим эти права на 3 смысловые группы.

            1       2       3
            -----------------
            7       7       7     | в восьмеричной системе счисления
            111     111     111   | в двоичной системе счисления

            rwx     rwx     rwx   | в мнемонически-понятном формате

        - Первая цифра обозначает атрибуты доступа к файлу для его хозяина.
        - Вторая цифра обозначает атрибуты доступа к файлу для его группы-хозяина.
        - Третья цифра обозначает атрибуты доступа к файлу для всех остальных пользователей.
        - Как видно, в двоичной системе значения цифр в каждой группе:
          1) Первая цифра обозначает права доступа на чтение.
          2) Вторая цифра обозначает права доступа на изменение.
          3) Третья цифра обозначает права доступа на исполнение.
        - Но по факту используется восьмеричная система для экономии места.
        - Вот, как цифры из двоичной системы преобразуются в восьмеричную:

            000 001 010 011 100 101 110 111     | двоичная
            0   1   2   3   4   5   6   7       | восьмеричная

        - 1 двоичное число занимает 3 бита информации.
        - Для преобразования 2-го числа в 8-ое нужно разбить двоичное число на группы по 3 цифры.

          - Например: 0010101 разбиваем на 001 010 1.

        - Если в последней группе окажется меньше 3-х цифр, дополняем их нулями слева.

          - Дополняем пример: 001 010 001

        - И теперь каждое из этих числе преобразуем в восьмеричное по формуле:

            x*2^2 + y*2 + z

        - И получаем:

            0*2^2 + 0*1 + 1 = 1    0*2^2 + 1*2 + 0 = 2    0*2^2 + 0*2 + 1 = 1

        - Итого: 121.

    > Права файла "по умолчанию", umask
      - По умолчанию файл получает следующие права: rw-r--r-- или 644.
      - Права "по умолчанию" определяются с помощью команды umask.
      - Её аргумент в численной форме xyz показывает, какие числа должны быть вычтены из полных прав 777.
      - По умолчанию umask выполняется с аргументом 022.
      - Получаем:

          7 - 0 = 6    |                7
          7 - 2 = 4    | а почему не    5    ?!
          7 - 2 = 4    |                5

      - "А почему не: 755?!" - спросит внимательный читатель
      - Потому что ни 1 файл не рождается, как исполняемый.
      - То есть, если umask будет равен 000, то файл родится с правами:

          110 110 110   | в двоичном формате
          6   6   6     | в восьмеричном формате
          rw- rw- rw-   | в мнемонически-понятном формате

      - Но т.к. umask по умолчанию равен 022, то ситуация такова:

          110 100 100   | в двоичном формате
          6   4   4     | в восьмеричном формате
          rw- r-- r--   | в мнемонически-понятном формате

      - Исключение - двоичные файлы, создаваемые компилятором (напирмер, gcc).
      - Они рождаются исполняемыми, с правами 755.

  > Временные атрибуты файла

    > 3 временных атрибута файла
      - Файл имеет 3 временных атрибута:
        1) Время доступа (atime - access time)
          - Фиксирует время последнего обращения к файлу.
          - Например, просмотра его командой less.
          - На практике применяется редко, и отжирает ресурсы.
          - Поэтому часто его вообще отключают.
        2) Время модификации (mtime - modification time)
          - Время последнего изменения области данных файла.
        3) Время изменения (ctime - change time)
          - Время последнего изменения метаданных файла.
          - Например, прав доступа, владельца, группы.

    > Трудности с тем, чтобы узнать время создания файла
      - Ни один из временных атрибутов файла не отражает непосредственно времени его создания.
      - Время создания можно определить по ctime, но только если метаданные файла не изменялись после его создания.
      - В противном случае определить истинное время создания файла невозможно.


Б7. Физика файловых систем

  --------------------------------------
  Подоглавление:

    - Значения термина "файловая система"
    - Дисковые накопители
    - Разделы диска
    - RAID и LVM
    - Реальные и виртуальные файловые системы Linux

  --------------------------------------

  > Значения термина "файловая система"
    - Файловая система (ФС) - очень многозначный термин.
    - В контексте Linux он обозначает одновременно следующее:
      1) Подсистема ядра, отвечающая за управление операциями с файлами.
      2) Способ физической оргаизации данных на носителях.
      3) Логическая структура файлов и каталогов.
    - В этой главе будет подробно рассмотрен пункт 2.

  > Дисковые накопители, как устройства в Linux

    --------------------------------------
    Подоглавление:

      - Реальные и виртуальные файловые системы
      - Файлы устройств - дисковых накопителей
      - HDD и CHS
      - Дисковые разделы
      - Главная загрузочная область HDD (MBR)

    --------------------------------------

    > Реальные и виртуальные файловые системы
      - В современных POSIX-системах поддерживаются множество разных ФС.
      - Условно их можно разделить на 2 группы:
        1) Реальные
          - Базирующиеся на блочных устройствах - дисках и их разделах.
        2) Виртуальные
          - Под которыми никаких реальных физических устройств нет.

    > Файлы устройств - дисковых накопителей
      - Дисковый накопитель является устройством.
      - Взаимодействовать с ним можно через его интерфейс в Linux - файл устройства.
      - Файлы устройств в Linux традиционно располагаются по адресу /dev
      - Выше уже упоминались, что бывают фиксированные и динамические файлы устройств.
        # Динамические Применяется в системах, которые используют механизм udev.
        # Создание файлов устройств происходит каждый раз заново при старте системы.
        # Создаются лишь файлы тех устройств, которые реально присутствуют в системе, и поддерживаются текущей конфигурацией ядра.
        # При добавлении устройства "на лету" (например, флэшки), возникает соответствующий файл устройства. А при удалении - исчезает.
      - Вот где в Ubuntu находятся файлы устройств - дисковых напокпителей:

          /dev/sda    | файл диска
          /dev/sda1   | файл 1-го физического раздела диска
          /dev/sda2   | файл 2-го физического раздела диска
          /dev/sda3   | файл 3-го физического раздела диска
          /dev/sda4   | файл 4-го физического раздела диска
          /dev/sda5   | файл 1-го логического раздела диска (внутри расширенного)
          /dev/sda6   | файл 2-го логического раздела диска (внутри расширенного)
          ...

      - А допустим, втыкаем флешку (с 1-м разделом), и появляется новый диск:

          /dev/sdb    | файл диска (флэшки)
          /dev/sdb1   | файл единого раздела флешки (через него к ней и надо обращаться)

      - Вот таким образом и работает udev.
      - Просмотреть список файлов устройств всех дисков в системе можно командой:
          ls -l /dev/sd*

    > HDD и CHS

      > HDD

        > Устройство для долгосрочного хранения информации
          - Существует потребность для хранения информации на постоянной основе.
          - Для этого люди придумали разнообразные физические устройства.
          - В современном мире наиболее распространённые из них - HDD.

        > Физический принцип хранения информации на HDD
          - HDD - Hard (magnetic) Disc Drive - накопитель на жёстких магнитных дисках.
          - Инфа записывается на жёсткие пластины (диски), покрытые слоем ферромагнитного материала.
          - В HDD могут использоваться 1 или несколько таких пластин на 1-й оси.
          - Для работы с каждой пластиной используется 1 подвижная головка.
          - При записи в сектор, головка подаёт переменный эл.ток, изменяя его вектор намагниченности.
          - При чтении из сектора, головка считывает вектор его намагниченности.
          - Информация записывается в 2-ом коде: да/нет.

        > Сектор, дорожка, цилиндр
          - Сектор является MIN адресуемой единицей хранения инфы на HDD.
          - У старых устройств сектор составляет 512 байт, у новых 4096 байт (известный, как Advanced Format).
          - То есть сектор не является "точкой" с 1 квантом инфы, а, собственно, является сектором с 4096-ю квантами инфы типа (да/нет).
          - 1-й сектор HDD обычно содержит "главную загрузочную запись".
          - Дорожка - совокупность секторов, равноудалённых от центра пластины диска (выглядит, как окружность).
          - Как вы понимаете, в HDD разных производителей, разных моделей, м.б. разное кол-во дорожек/секторов.
          - Но в BIOS есть стандарт: 255 дорожек, по 63 сектора каждая, образуя 16065 блоков на цилиндр.
          - Вообще, реализации могут отличаться от этой теории. Но принцип, думаю, понятен.
          - Картинку можно глянуть здесь: https://ru.wikipedia.org/wiki/CHS

      > Что такое CHS
        - CHS - Cylinder Head Sector - Цилиндр Головка Сектор.
        - Это система адресации секторов на HDD. По аналогии с: Город Улица Дом Квартира.
        - Благодаря CHS можно, зная нужные адреса, как считать инфу из этих секторов, так и записать её туда.

    > Дисковые разделы

      > Один из катализаторов, послуживших появлению дисковых разделов
        - Образующие цилиндры треки создаются при первичном заводском низкоуровневом форматировании диска.
        - На данное форматирование пользователь никак повлиять не может, оно просто всегда имеется.
        - Доступ к данным в соседних цилиндрах осуществляется быстрее, чем в данным (скажем), частью записанных в 1-м, а частью в последнем.
        - Потому что в последнем случае головке придётся часть поворачиваться, что занимает время, и, к тому же, изнашивает её.
        - Такая неприятность не так уж и невероятна. В DOS'е, скажем, она происходила сплошь и рядом.
        - Это послужило одним из катализаторов для того, чтобы придумали дисковые разделы.

      > Что такое дисковый раздел
        - Каждый дисковый раздел объединяет в себе соседние цилиндры.
        - Дисковый раздел описывается номерами 1-го и последнего задействованного в нём цилиндров.

    > Главная загрузочная область HDD (MBR)

      > MBR
        - 1-й сектор HDD резервируется под служебные нужды диска.
        - Его называют MBR - Main Boot Record - главная загрузочная запись.
        - Информация из MBR считывается BIOS'ом при старте машины.
        - Это происходит, если диск в настройках BIOS определён, как загрузочный.
        - Однако, поскольку каждый диск м.б. как загрузочным, так и нет, место под MBR отводится всегда.

      > Таблица разделов
        - В MBR, помимо прочего, отводится место для таблицы разделов (partition table).
        - Под таблицу разделов, испокон веков (со времён 1-й IBM, кажется), отведено 64кб.
        - В эту таблицу записываются данные о разделах в определённом (понимаемом BIOS) формате.

      > Первичные разделы
        - Всего информации по каждому разделу набегает на 16 кб.
        - Соответственно, на диске может быть 64/16 = 4 раздела максимум.
        - Эти разделы и называют первичными (или физическими).
        - Каждый из физических разделов может быть поделен на логические разделы.

      > Идентификатор файловой системы
        - Таблица разделов содержит (для каждого раздела) и ID файловой системы, планируемой к размещению на разделе.
        - Эти ID записываются в 16-ричном (hex) исчеслении.
        - Примеры таких ID и их значений:

            83        Linux             Родной (native) раздел Linux
            fd        Linux raid auto   Раздел для использования в программных RAID
            b         W95 FAT32         Раздел Windows 95 (от OSR2 и выше)
            07        NTFS              Раздел Windows NT

  > Разделы диска

    > Стили разметки разделов диска
      - Стиль размерки, это формат вторичной таблицы разделов, записываемой в 1-й сектор раздела первичного.
      - Эта таблица определяет характер доступных действий над данным первичным разделом.

    > Стиль разметки DOS
      - Стилей разметки существует не мало. Рассмотрим здесь один - DOS.
      - Этот стиль разметки используется как в Windows, так и в Linux.
      - Диск можно разбить на 4 раздела.
      - И лишь 1-му из них можно присвоить ID расширенного раздела.
      - А расширенный раздел можно поделить на логические разделы.

    > Файлы дисков и разделов Linux
      - Интерфейсы разделов в Linux представлены отедльными файлами блочных устройств.
      - Точно также, как и сами диски.
      - Идентификаторы с 1 по 4 зарезервированы за первичными (физическими) разделами.
      - А идентификаторы с 5 и выше - за логическими разделами (нумеруюся с 5 даже, если некоторых физ. разделов нет).
      - Рассмотрим примерную схему дисковой разметки в Linux:

          /dev/sda    | файл диска
          /dev/sda1   | файл 1-го физического раздела диска
          /dev/sda2   | файл 2-го физического раздела диска
          /dev/sda3   | файл 3-го физического раздела диска
          /dev/sda4   | файл 4-го физического раздела диска
          /dev/sda5   | файл 1-го логического раздела диска (внутри расширенного)
          /dev/sda6   | файл 2-го логического раздела диска (внутри расширенного)
          ...

      - А допустим, втыкаем флешку (с 1-м разделом), и появляется новый диск:

          /dev/sdb    | файл диска (флэшки)
          /dev/sdb1   | файл единого раздела флешки (через него к ней и надо обращаться)

  > RAID и LVM

    > Предисловие
      - Дисковые разделы используются не только для размежевания, но и для объединения.
      - Части различных физ.носителей предстают перед системой в качестве непрерываного дискового пространства.
      - И на этом дисковом пространстве может быть создана единая файловая система.
      - Провести подобное объединение позволяют различные технологии, такие, как RAID и LVM.
      - RAID - Redundant Array of Independent Disks - избыточный массив независимых дисков.
      - LVM - Logical Volume Manager - менеджер логических томов.

    > RAID

      > Катализатор появления технологии RAID
        - Имелся набор различных физических дисков.
        - Размер диска всегда ограничен, и часто его просто не хватает.
        - Кроме того, 1 диск может сломаться, и неплохо было бы дублировать важную инфу на другой диск.
        - Поэтому, захотелось представить набор дисков виде единого, непрерывного дискового пространства.
        - На котором может быть создана единая файловая система.
        - Впрочем, объединять можно не только лишь диски, но и разделы на них.

      > Физический RAID
        - Первоначально задуманное было реализовано спец.контроллеров.
        - Эти контроллеры использовали интерфейсы SCSI и ATA (ныне Serial ATA).
        - В физических RAID за объединение, конечно, определяют некие программы.
        - Как правило, эти программы вшиты в микросхемы контроллера, расположенные на материнской плате.

      > Программный RAID
        - Объединение дисков/разделов в единое устройство возможно и при отсутствии специфического "железа".
        - Именно такая реализация и называется программным RAID (Soft RAID).
        - Она требует:
          а) Поддержки ядром ОС.
          б) Наличия соответствующего программного инструментария.
        - Различают RAID-массивы с избыточносью и без оной.

      > RAID-массивы без избыточности

        > Что это такое
          - Их называют "без избыточности", т.к. они не создают избыточных данных.
          - Проще всег объяснить на примере.
          - Допустим, нам надо записать 1 мб данных в RAID-массив.
          - Если это RAID-массив без избыточности, то этот 1 мб столько места и займёт - 1 мб.
          - А есл это RAID-массив с избыточностью (допустим, RAID lvl 1), то данные в нём займут 2 мб, а не 1 мб.

        > Linear RAID (линейный RAID)
          - Последовательное объединение >= 2 дисков.
          - Все объединённые диски представляются, как единое устройство.
          - Запись на них осущ.последовательно. Сначала на 1-й. Когда он заполнится, на 2-й. И т.д.
          - На кол-во дисков и их объём в linear RAID нет никаких ограничений.
          - Linear RAID нужны лишь для удобства. Прироста скорости/надёжности они не дают.

        > RAID level 0 (RAID 0-го уровня)
          - Презназначены для увеличения скорости работы. Проще всего объяснить на примере.
          - Допустим, у нас есть 2 жестких диска. И нам надо увеличить скорость чтения/записи в 2 раза.
          - Для этого мы делаем следующее:

            1) Подключаем каждый диск через отдельный интерфейс (провод)
              - Пропускная способность интерфейса ограничена.
              - Так что если оба диска подключить к 1 интерфейсу, выигрыша в скорости не будет.

            2) Каждую порцию данных делим на два равных по размеру логических блока
              - При записи синхронно записываем один кусок данных на 1 диск, а другой - на другой.
              - А при чтении синхронно считываем их.
              - В теории выигрыш по скорости должен быть до 2 раз.

          - При этом снижается уровень надёжности хранения данных в 2 раза (по сравнению с хранением на 1 диске).
          - Если откажет хотя бы 1 из 2 дисков, данные будут утеряны.
          - P.S. число дисков/разделов в RAID 0-го уровня должно быть чётным.

      > RAID-массивы с избыточностью

        > Для чего нужны
          - В первую очередь призваны повышать надёжность хранения данных.
          - А если при этом ещё и возрастает скорость дисковых операций, это можно рассматривать, как бонус.

        > RAID level 1 (RAID 1-го уровня, или "зеркальный режим")
          - Это простое дублирование записываемых данных на 2-х дисках или разделах.
          - Повышает уровень надёжности хранения данных в 2 раза.
          - Обладает 100%-й избыточностью. Если надо сохранить 1 мб данных, понадобится 2 мб места.
          - Число дисков/разделов в RAID 1-го уровня должно быть чётным.
          - В чистом виде RAID 1-го уровня роста производительности не даёт.
          - Но никто не запрещает комбинировать с RAID 0-го уровня.
          - Правда, для этого MIN надо иметь 4 диска, и 4 отдельных контроллера для них.

        > RAID level 5 (RAID 5-го уровня)
          - Данные распределяются по всем составляющим массив дискам.
          - И дополняются контрольными суммами.
          - Последние используются для восстановления инфы в случае отказа 1-го из дисков.
          - MIN кол-во дисков в таком массиве 3, и объёмы их должны быть примерно равны.
          - Общий объём такого массива примерно равен:

              [Объём наименьшего из них] * ([их число] - 1)

          - Допустим, у нас 3 диска: 100 гб, 80 гб, 90 гб.
          - RAID уровня 5 из них будет иметь объём:

              80 * (3 - 1) = 160 гб.

          - Массивы 5-го уровня считаются весьма надёжными, и в теории обещают даже прирост быстродействия.

    > LVM

      > Суть
        - Основа LVM в выделение 2-х уровней организации дискового пространства.
        - Технология LVM эффективна, если в системе есть более 1 физического диска.

      > Физический уровень
        - Единица физической организации - физический том.
        - Это ни что иное, как обычный раздел диска.
        - Физический том делится на физические блоки - кванты дискового пространства.
        - На размер физических томов и могут изменяться логические устройства.

      > Логический уровень
        - Единица логической организации - группа томов.
        - Она сливает воедино набор физических томов.
        - Так, что для ОС они выглядят, как единое устройство.
        - И, по сути, представляют собой нечто вроде логического аналога жёсткого диска.
        - Как и HDD, группа томов может представлять собой как 1 раздел, так и делиться на много разделов.
        - Эти разделы и называют термином "логические томы".

  > Реальные и виртуальные файловые системы Linux

    > Ключевая разница между реальным и виртуальными ФС
      - Реальные ФС размещаются на реальных блочных устройствах.
      - Виртуальные ФС размещаются в памяти, и (или почти) не занимают места на диске.

    > Журналируемые ФС

      # Предпосылки к появленияю
        - Проблема нарушения целостности ФС при аварийном завершении работы характерна для всех ОС семейства Linux.
        - Для решения этой проблемы, с давних пор разрабатываются т.н. "журналируемые ОС".

      # Суть
        - Термином "журнал" называют нечто, вроде log-файла.
        - В нём фиксируются предстоящие к выполнению дисковые операции (типа плана).
        - Благодаря этому становится возможным самовосстановление ФС в случае аварийного завершения работы.

      # Журналы обеспечивают целостность ОС, а не данных пользователя
        - Сабж.

    > Наиболее популярные ФС для Linux на 17.01.2015
      - EXT4, F2FS, XFS, and Btrfs


Б8. X Window System

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Общая информация об X Window System
    - Клиент-серверная архитектура Иксов
    - Оконные менеджеры
    - X-терминалы (тонкие клиенты), терминальные парки

  --------------------------------------

  > Ссылки

    - Статья про X Window System в wiki:
        https://ru.wikipedia.org/wiki/X_Window_System

    - Проект x.org
        http://www.x.org/wiki/

  > Общая информация об X Window System

    > Иксы - не программа, а набор спецификаций
      - Иксы не являются какой-либо программой, или графическим интерфейсом.
      - Вместо этого, Иксы - набор спецификаций для графических интерфейсов.
      - Конкретная реализация Иксов целиком на совести разработчиков конкретных систем.
      - Поэтому на базе Иксов было построено множество реализаций граф.интерфейсов.
      - Большинство из которых были платные и проприетарные.

    > Независимость от конкретного железа или ОС
      - Иксы изначально были разработаны с упором на универсальность.
      - Они должны работать на любом железе и ОС, поддерживающими растровую графику.

    > О названии
      - X Window System переводится, как оконная система X.
      - Где X, это имя собственное.
      - X является следующей буквой в английском алфавите, после W.
      - Непосредственно по времени оконной системе X предшествовала оконная система W.
      - Поэтому, разработчики решили для обозначения своей новой разработки, просто взять следующую букву алфавита.
      - X Window System не имеет никакого отношения к Microsoft Windows.

    > Кто и когда придумал Иксы
      - У истока Иксов, в 1984 году, трое: Роберт Шейфлер, Джим Геттис и Рон Ньюмен.
      - Далее разработкой занимался Массачусецкий Технологический Институт (MIT) и фирма DEC.
      - В 1987г. разработчики Иксов создали организацию X Consortium.
      - И эта организация приступила к распространению X Window System под своей лицензией, сходной с GPL.
      - Нынешняя (на 18.01.2015) версия протокола - X11 - появилась в сентябре 1987 года.
      - Проект X возглавляет фонд www.x.org
      - Проект X является open source проектом, с соответствующими свободными лицензиями.

    > В чём базовый функционал Иксов
      - Обеспечивает базовые фукнции графической среды:
        # Отрисовку и перемещение окон на экране.
        # Взаимодействие с устройствами ввода (например: мышь, клавиатура).
      - Не определяет детали интерфейса - этим занимаются менеджеры окон (которых множество).
      - По этой причине одна программа может выглядеть по разному, в зависимости от используемого оконного менеджера.

    > Сетевая прозрачность Иксов
      - Графическое приложение может исполняться на машине А в сети.
      - А интерфейс этого приложения может передаваться по сети на машину Б.

  > Клиент-серверная архитектура Иксов

    > X Window System имеет клиент-серверную архитектуру
      - X-сервер обменивается сообщениями с X-клиентами.

    > X-протокол
      - Взаимодействие между ними производится через X-протокол.
      - Через этот протокол происходит взаимодействие между X-клиентами.
      - А также их связь с главной библиотекой Иксов - xlib.

    > Подробнее об X-серверах и X-клиентах
      - X-сервером называют аппаратно зависимую программу.
      - Она непосредственно взаимодействует с железом, таким как:
          # видеоадаптер;
          # монитор;
          # клавиатура;
          # мышь
          # ...и т.д.
      - Именно в ней и заключается главное отличие между разными реализациями Иксов.
      - X-сервер предоставляет свои ресурсы X-клиентам.
      - То есть, прикладным программам, обеспечивающим все остальные функции.
      - В общем случае, x-сервером является локальный виртуальный терминал.

    > X-клиент может исполняться и на удаленной машине
      - Чтобы запустить X-клиент на удаленной машине, обычно делают следующее:
        1. Запускают терминал.
        2. Подключаются к удалённой машине через SSH.
        3. Указывают, на какой дисплей надо выводить графику:
            export DISPLAY=[имя компьютера пользователя]:0
        4. Запускают клиентскую программу.
      - Программа подключается к локальному X-серверу.
      - И будет выводить данные и локальный дисплей.
      - И будет принимать ввод с локальных мыши/клавиатуры.
      - Использование удаленных X-клиентов может быть полезно в т.ч. в следующих ситуациях:
          # Графическое администрирование удаленной машины.
            - Допустим, можно купить сервер на DigitalOcean.
            - Подключиться к нему, и настроить в графическом режиме.
          # Выполнение ресурсоёмких вычислений на удаленной машине.
            - Допустим, наш комп слаб, но есть мощный удалённый комп.
            - Подключаемся к нему, и используем его для вычислений.
            - А результаты выводятся на наш, локальный комп.
          # Выполнение граф.программ одновременно на несколких машинах
            - При этом управление производится только с одного из них.
            - Можно использовать в обучающих целях.

  > Оконные менеджеры, среды рабочего стола

    > Иксы не определяют, как выглядит интерфейс
      - Как выглядят кнопки, меню, заголовки окно и т.д.
      - Это все зависит от:
        # Среды рабочего стола
        # Оконного менеджера
        # Самой программы
        # ...может ещё от чего-то

    > Оконный менеджер
      - Приложение, работающее поверх X Window System.
      - Оно определяет интерфейс и взаимодействие с пользователем.
      - Как следует из названия, оно призвано управлять окнами.
      - Для Linux написаны тонны оконных менеджеров.
      - Список некоторых, наиболее известных из них, можно найти здесь:
          https://ru.wikipedia.org/wiki/Менеджер_окон_X_Window_System

    > Среда рабочего стола

      > В общем
        - Это разновидность графических интерфейсов пользователя.
        - Которая основана на метафоре рабочего стола (как в Windows).
        - Такая среда обеспечивает наличие пространства, называемого "рабочим столом".
        - На рабочем столе могут быть всякие объекты - окна, иконки и прочее.
        - Обычно эти объекты могут взаимодействовать. Например, иконку можно петеращить в окно.

      > Linux не привязан жестко к какой-то одной среде рабочего стола

        > Microsoft Windows
          - Microsoft Windows жестко привязан к среде рабочего стола Explorer.
          - Без существенных переделок встроить в него другую среду нельзя.
          - А т.к. код windows закрыт, то реализовать это может только сам Microsoft.
          - Но делать это они не спешат.

        > Apple OS X
          - Apple OS X жестко привязан к среде рабочего стола Aqua.
          - Без существенных переделок встроить в него другую среду нельзя.
          - А т.к. код OS X закрыт, то реализовать это может только сам Apple.
          - Но делать это они не спешат.

        > Linux
          - Жестно не привязан ни к одной среде рабочего стола.
          - В разных дистрибутивах по умолчанию могут применяться разные среды.
          - Вплоть до полного отсутствия в дистрибутиве среды рабочего стола.
          - Поскольку код Linux открыт, любой желающий может установить себе любую среду.
          - Сред рабочего стола для Linux написано много, можно выбрать любую понравившуюся, и использовать.

      > Что такое "полная среда рабочего стола"
        - Включает в себя:
          # Оконный менеджер
          # Различные дополнительные приложения
          # Единый стиль интерфейса

      > Наиболее популярные среды рабочего стола для Linux

        # KDE
          - Полная среда рабочего стола и набор программ от проекта KDE.
          - Как указано, включает, кроме среды, и набор программ для повседневной работы.
          - Является "тяжелой" и "полнофункциональной" средой, не для слабых машин.
          - Талисман KDE — зелёный дракон Konqi.
          - Является свободным программным обеспечением.
          - Статья на wiki: https://ru.wikipedia.org/wiki/Amarok

        # GNOME
          - Полная среда рабочего стола и набор программ от проекта GNU.
          - Разработчики пытаются сделать среду, доступную всем.
          - Независимо от тех.навыков, языка, физ.ограничений и т.д.
          - GNOME - акроним от "GNU Network Object Model Environment".
          - Является свободным программным обеспечением.
          - В Ubuntu 14.04 GNOME 3 с оболочкой Unity является средой по умолчанию.
          - Этот опрос на habr говорит о том, что GNOME 3 + Unity - самая популярная среда на 2012 год:
              http://habrahabr.ru/post/144274/
          - Статья на wiki: https://ru.wikipedia.org/wiki/GNOME

        # Xfce
          - Среда рабочего стола Linux от Оливера Фордана.
          - Xfce — лёгкое настольное рабочее окружение для различных UNIX-подобных систем.
          - Использует собственный оконный менеджер Xfwm.
          - Является свободным программным обеспечением.
          - Статья на wiki: https://ru.wikipedia.org/wiki/Xfce

        # LXDE
          - Это легковесная, быстрая, не требовательная к ресурсам среда.
          - Подходит для работы с низкопроизводительным оборудованием.
          - Является свободным программным обеспечением.
          - Статья на wiki: https://ru.wikipedia.org/wiki/LXDE

  > X-терминалы (тонкие клиенты), терминальные парки

    > X-терминал (тонкий клиент)
      - Это выделенное аппаратное обеспечение, на котором выполняется X-сервер.
      - Это и есть тонкий клиент, т.е. малощная машина, имеющая отдельный монитор, клавиатуру, мышь.

    > Сервер для тонких клиентов. Терминальный парк
      - Допустим, надо обеспечить 50 рабочих мест в офисе.
      - На каждом рабочем месте долеж быть комп, монитор, мышь, клава.
      - Причем, на каждом рабочем месте должна быть обеспечена хорошая производительность.
      - Покупать 50 мощных компьютеров было бы слишком дорого.
      - Вместо этого покупается 1 мощный сервер, и 50 тонких клиентов.
      - Все клиенты объединяют с сервером в сеть.
      - Все клиенты подключают к серверу через SSH, как описано выше.
      - В результате все приложения, запущенные на клиентах, выполняются на сервере.
      - А результаты отображаются на мониторах клиентов, и ввод принимается от них же.
      - Получается дешево и сердито.
      - Плюс бонус: тонкий клиент намного меньше по размерам, чем обычны системный блок.








1.  Библиотека программ

  --------------------------------------
  Подоглавление:

    1.1. Файлы
    1.2. Процессы
    1.3. Система
    1.4. Архивация
    1.5. Сеть
    1.6.

    1.n. Прочее

  --------------------------------------

  1.1. Файлы
  ----------

    ------------------------------------
    >>> 1) Переходы и просмотры в ФС <<<
    ------------------------------------

      cd               | перейти в домашний каталог
        cd dir         | - перейти в каталог dir
      ls               | содержимое текущего каталога (без скрытых файлов)
        ls -l          | - в столбик (без скрытых файлов)
        ls -al         | - в столбик (со скрытыми файлами)
      pwd              | показать абсолютный путь к текущему каталогу

    -----------------------------------------
    >>> 2) Создать, удалить: файл/каталог <<<
    -----------------------------------------

      touch file       | создать файл file
      rm file          | удалить файл file
       rm -f file      | - удалить файл file (ни смотня ни на что)

      mkdir dir        | создать каталог dir
      rm -r dir        | - удалить каталог dir
       rm -rf dir      | - удалить каталог dir (ни смотня ни на что)

    -------------------------------------------------
    >>> 3) Переместить, скопировать: файл/каталог <<<
    -------------------------------------------------

      mv file1 file2   | переименовать file1 в file2 (или переместить, если file2 в другом каталоге)
      cp file1 file2   | скопировать file1 в file2

      mv cat1 cat2     | переименовать catalog1 в catalog2 (или переместить, если catalog2 в другом каталоге)
      cp -r dir1 dir2  | - скопировать каталог dir1 в dir2; создать dir2, если его нет

    -------------------------------------------
    >>> 4) Просмотр и редактирование файлов <<<
    -------------------------------------------

      more file        | просмотреть содержимое file
      less file        | просмотреть содержимое file (для больших файлов)
      nano file        | открыть файл в простом текстовом редакторе (типа блокнота)

      head file        | вывести первые 10 строк файла
      tail file        | вывести последние 10 строк файла
        tail -f file   | - выводить последние 10 строк файла каждый раз, как в нём появляется 10-ая новая строка

      cat > file       | направить стандартный ввод (из bash) в файл file

    --------------------------------------
    >>> 5) Жёсткие и символьные ссылки <<<
    --------------------------------------

      ln -s file link  | создать символьную ссылку на file


  1.2. Процессы
  -------------

      ps              | статич.инфа о процессах в данном терминале
      top             | обновляемая inrealtime таблица всех процессов системы
      kill [pid]      | завершить процесс с pid
      killall [name]  | завпршить все процессы с именем name
      bg              |
      fg              |
      fg [n]          |

  1.3. Система
  ------------

      date              | текущие дата и время
      cal               | календарь текущего месяца
      uptime            | сколько времени компьютер включён
      w                 | список пользователей системы, которые онлайн
      whoami            | имя текущего пользователя
      finger [user]     | анные о пользователе [user]
      uname -a          | информация о ядре linux
      cat /proc/cpuinfi | информация о процессоре
      cat /proc/meminfo | информация о памяти
      man [command]     | справка для команды [command]
      df -h             | инфа о свободном месте во всех файл.сист-ах
      du [name] -h      | сколько места занимает файл или папка name
      whereis [app]     | места расположения программы с именем app
      which [app]       | какая из программ с именем app при вызове запускается по умолчанию

  1.4. Архивация
  --------------

      tar cf [file.tar] [files]     | заархивировать files используя tar в архив file.tar
      tar czf [file.tar.gz] [files] | заархивировать files используя Gzip в архив file.tar.gz
      tar cjf [file.tar.bz2]        | заархивировать files используя Bzip2 в архив file.tar.bz2
                                    |
      tar xf [file.tar]             | разархивировать file.tar
      tar xzf [file.tar.gz]         | разархивировать file.tar.gz
      tar xjf [file.tar.bz2]        | разархивировать file.tar.bz2
                                    |
      gzip [file]                   | сжать file, и переименовать его в file.gz
      gzip -d [file.gz]             | разжать file.gz, и переименовать его в file

  1.5. Сеть
  ---------

      pint -t [host]  | пинговать указанный хост
      whois [domain]  | получить whois инфу о домене
      dig [domain]    | получить dns инфу о домене
      wget [file]     | скачать file
      wget -c [file]  | продолжить остановленное скачивание файла file


  1.n. Прочее
  -----------

      poweroff        | Выключить систему
      init 0          | Выключить систему
      halt            | Остановить систему, но не выключать питание

      reboot          | Перезагрузить систему
      init 6          | Перезагрузить систему

      tty             | Путь к файлу текущего виртуального терминала

      clear           | Удалить весь вывод из окна терминала



////==========================================================////
////                                                       ////
////          В. Настройка сервера на DigitalOcean         ////
////                                                       ////
////=======================================================////

В1. Общие сведения про DigitalOcean

--------------------------------------
Оглавление:

  # Ссылки, туториалы
  # Введение
  # Преимущества DO
  # Про оплату услуг DO
  # FAQ по аккаунту
  # Технический FAQ

    - Общие вопросы
    - Вопросы настройки
    - Вопросы панели управления
    - Вопросы бэкапов

  # Список полезных туториалов

    - An Introduction to Securing your Linux VPS
    - How To Create Your First DigitalOcean Droplet Virtual Server
    - How To Set Up a Host Name with DigitalOcean (DNS)
    - How To Set Up SSH Keys
    - How To Install Git on Ubuntu 14.04
    - How To Create a SSL Certificate on Apache for Ubuntu 14.04
    - How To Set Up a Firewall Using Iptables on Ubuntu 14.04

--------------------------------------

> Ссылки, туториалы
  
  # Help от DO
      https://www.digitalocean.com/help/getting-started/setting-up-your-server/


> Введение
  - DigitalOcean является облачным провайдером хостинг-услуг.
  - Они сосредоточены на MAX упрощении для конечных пользователей.


> Преимущества DO

  1. Только SSD

  2. Простая панель управления

  3. Цены на хостинг от $5.

  4. Активное сообщество разработчиков
    - https://www.digitalocean.com/community/
    - Там множество туториалов и прикладных знаний.
    - В "поиске" по ключ.слову можно найти, как установить
      то или иное на ubuntu.

  5. Установка вещей в 1 клик
    - Можно установить нужный дистрибутив Linux.
    - И различные программы: LAMP и т.д.


> Про оплату услуг DO

  # Ежечасно
    - Каждый дроплет тарифицируется ежечасно.
    - В месяце 28 дней (672 часа).

  # Кредитка или paypal
    - Оплачивать можно кредиткой или через PayPal.
    - Visa, MasterCard, American Express, Discover, and PayPal.
    - Можно привязать к DO несколько карт, DO будет пробовать списывать с них по очереди.

  # Сколько стоит час
    - Допустим, мы взяли дроплет за $5.
    - Тогда час стоит 5/672 $.

  # Оплата идёт, даже если дроплет выключен
    - Дисковое пространство, CPU, RAM и IP зарезервированы.
    - Так что, даже если сервак вырубить, оплата идёт.
    - И начинает она идти, походу, сразу после создания дроплета.
    - Чтобы она не шла, надо уничтожить дроплет.

  # Снэпшоты
    - Можно сделать снэпшот дроплета, и уничтожить дроплет.
    - После этого, оплата по дроплету идти перестанет.
    - Потом можно создать новый дроплет из снэпшота.

  # Надо ли оплачивать каждый раз при создании сервера?
    - Например, есть тарифный план $5.
    - Надо ли платить по $5 каждый раз при создании сервера?
    - Ответ: нет. Оплата почасовая.

  # Деньги списываются с карты каждое 1 число месяца
    - Либо можно в ЛК вручную оплатить, нажав "Pay Now"

  # Просрочка платежа
    - Если 1-го числа месяца денег для оплаты недостаточно - это просрочка.
    - DO направляет по почте сообщение "Server Termination Urgent notice".
    - После этого надо связаться с тех.поддержкой DO, чтобы снять блок с аккаунта.
    - Если не сделать этого в течение 24 часов, дроплет будет уничтожен.
    - Данные будут доступны для восстановления в течение 72 часов.

  # Возвраты не поддерживаются
    - По единожды оплаченным услугам, деньги не вернуть.

  # Трафик оплачивается отдельно сверх указанного в плане
    - Например, в плане за $5 есть лимит трафика 1ТБ/мес.
    - Если он превышен, то каждый отдельный ГБ оплачивается.
    - 1 ГБ стоит $0.02.


> FAQ по аккаунту

  # Как изменить MAX кол-во дроплетов
    - Изначально даётся возможность создать MAX 10 дроплетов.
    - В настройках аккаунта можно запросить у DO увеличить это число.
    - Придётся объяснить, зачем это надо.

  # Как изменить размер дроплета?
    - Допустим, есть $5-дроплет, а надо $10-дроплет.
    - DO не берёт за это никакой дополнительной платы.
    - Надо просто выключить дроплет, и изменить его размер в настройках.

  # Как открыть несколько аккаунтов?
    - Для себя, или для бизнеса?
    - Надо связаться с тех.поддержкой DO.

  # Почему root-пароль пересылается по email?
    - При создании дроплета пароль высылается по email.
    - Но ведь это не безопасно! Почему DO так делает?
    - Потому что это наиболее быстрый и простой способ передать пароль.
    - После 1 входа необходимо сменить пароль на "очень сильный".
    - А ещё лучше, использовать ssh-ключи, отключив вход по паролю.

  # Как добавить SSH-ключи?
    - Их можно добавить в панели управления.
    - И использовать для доступа ко всем своми дроплетам.
    - При использовании SSH-ключей, DO не назначает root-пароль.

  # Как восстановить пароль от дроплета?
    - Воспользоваться функционалом восстановления пароля.

  # Что делать, если 2-факторная аутентиф.включена, а я потерял телефон?
    - Обратиться в тех.поддержку.

  # В DO есть командные аккаунты
    - Которыми могут пользоваться несколько человек.


> Технический FAQ

  > Общие вопросы

    # Дроплет
      - Это DO так называет виртуальный сервер.
      - Каждый дроплет представляет собой отдельный VPS.

    # Бэкапы
      - DO предлагает снэпшоты и бэкапы.
      - Снэпшоты можно делать в любое время.
      - Авто-бэкапы же делаются раз в несколько дней.

    # API
      - У DO есть API.
      - Оно позволяет управлять дроплетами на DO.
      - https://developers.digitalocean.com/

    # Использует ли DO какой-то общий фаервол?
      - Нет.
      - Каждый сам настраивает себе фаервол на своём дроплете.

    # Есть ли консольный доступ?
      - Да, через VNC.

    # Какую виртуализацию использует DO?
      - KVM.

    # Хостит ли DO windows-сервера?
      - Нет.

    # Какие CPU работают с моими дроплетами у DO?
      - Intel Hexcore processors between 1.8 GHz and 3.0 GHz
      - Это можно глянуть соотв.командой на своём linux-дроплете.

    # Есть ли "кастомные" тарифные планы?
      - Например, надо мне увеличить только RAM.
      - Нет, DO не поддерживает. Только стандартные планы.

  > Вопросы настройки

    # Как создать дроплет? Как к нему подключиться?
      - Об этом можно почитать в разделе comunity.
      - Там собрано много туториалов для начинающих.
      - Вот, например, про то, как создать 1-й дроплет:
          https://www.digitalocean.com/community/articles/how-to-create-your-first-digitalocean-droplet-virtual-server

    # Как настроить DNS?
      - Как подключить свои дроплеты к своим доменным именам?
      - Это можно сделать из панели управления DO.
      - Читай этот туториал:
          https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean
      - DNS-сервера DO:

          ns1.digitalocean.com
          ns2.digitalocean.com
          ns3.digitalocean.com        

    # Настроил DNS, но не работает?
      - Читай этот туториал:
          https://www.digitalocean.com/community/articles/how-to-set-up-a-host-name-with-digitalocean

    # Как настроить VNC на моих дроплетах?
      - VNC - Virtual Network Computing.
      - Позволяет получить удалённый графический доступ к дроплету.
      - Как его настроить, читай этот туториал:
          https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-14-04

    # Как подключиться к дроплету с помощью PuTTY?
      - С помощью PuTTY можно подключиться к дроплету по SSH.
      - Как это сделать, читай этот туториал:
          https://www.digitalocean.com/community/tutorials/how-to-log-into-a-vps-with-putty-windows-users

    # Статический ли IP у моего дроплета?
      - Да, и он зарезервирован для него.
      - При уничтожении дроплета, резерв IP снимается.

    # Как сменить IP своего дроплета?
      - Создать снэпшот дроплета из панели управления.
      - Создать новый дроплет из снэпшота.
      - Уничтожить старый дроплет.

    # Можно ли прикрепить несколько IP к одному дроплету?
      - Нет, DO этого не поддерживает.

    # Как настроить фаервол?
      - Читай этот туториал:
          https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-iptables-on-ubuntu-14-04

    # Доступ к MySQL на дроплете с удалённого компьютера
      - По умолчанию есть лишь локальный доступ к MySQL.
      - Но это можно изменить в /etc/mysql/my.cnf.
      - Нужно изменить строку:

          C:   "bind_address=127.0.0.1"
          На:  "bind_address=0.0.0.0"

      - Но это не безопасно, теперь к mysql может подключиться любой.
      - Поэтому, надо использовать МЕГАКРУТОЙ пароль.
      - И настроить фаервол (типа, что к нему можно подключиться лишь с указанного ip).
      - Подробнее обо всём этом читай туториал:
          https://www.digitalocean.com/community/questions/how-to-allow-remote-mysql-database-connection

    # Неработоспособность MySQL из-за недостатка RAM
      - Бывает, MySQL крашится или не запускается.
      - Одна из причин, ему может не хватать оперативки.
      - Можно посмотреть лог mysql, чтобы уточнить:
          /var/log/mysql/error.log
      - Проблемы с памятью выглядят типа: "mmap can't allocate"
      - Решения:
        1) Перейти на бОльший тариф.
        2) Включить swap.
        3) Уменьшить нагрузку на систему, чтобы высвободить RAM.

  > Вопросы панели управления

    # Как выключить/перезагрузить сервер
      - Подключиться к нему по SSH.
      - Выполнить соотв.команды в окне терминала.
      - !!!Ни в коем случае не выключать сервер из панели управления.
      - Это будет тоже самое, что выдернуть его из розетки.

    # Как включить сервер
      - Зайти в свою панель управления на DO.
      - И оттуда включить сервер.

    # Как перевести мой дроплет в датацентр в другом регионе?
      - Допустим, я создал дроплет в датацентре в США.
      - А теперь мне надо перевести его в Европу.
      - Вот, как это делается:
        1) Выключить дроплет (командой через SSH).
        2) Сделать снэпшот в ЛК: Snapshots > enter your snapshot name > Take Snapshot
        3) Перейти в Images, кликнуть на иконке с планетой.
           Выбрать регион и датацентр, куда требуется перевести снэпшот.
        4) Теперь можно создать новый дроплет в указанном регионе, выбрав тот снэпшот.

    # В чём разница между Flexible и Permanent resizing?

      > Flexible
        - Изменяет лишь CPU и RAM, но не размер диска.
        - Преимущество в скорости, достаточно лишь перезагрузиться.
        - Выключить сервер, изменить план, включить сервер.

      > Засада с Flexible
        - Однажды перейдя на бОльший план, нельзя перейти не мЕньший.
        - Т.К. у мЕньшего плана диск меньше, и туда не влезут данны с бОльшего.
        - Поэтому, лучше выбирать permaent (даёт бОльшую гибкость).

      > Permanent
        - Изменяет CPU, RAM и размер диска.
        - Переход может занять минут 40, в этом и недостаток.

      > Подробнее читай туториал:
          https://www.digitalocean.com/community/tutorials/how-to-resize-your-droplets-on-digitalocean

    # Как передать дроплет другому аккаунту?
      - При этом все данные на дроплете будут уничтожены.
      - Но закреплённый за дроплетом IP сохранится.
      - Никак, но можно передать снэпшот.
      - Сначала надо сделать этот самый снэпшот.
      - Затем в ЛК можно его передать.

    # Как "сбросить" дроплет "до заводских установок"

      1. Зайти в ЛК
        - Перейти к списку дроплетов, и выбрать нужный.

      2. Нажать "Destroy", затем "Rebuild", и следовать инструкциям.

      3. Нажать "Rebuild From Image".

  > Вопросы бэкапов

    # Как включить бэкапы на существующем дроплете?
      - Зайти в ЛК, и нажать "Backups" на странице дроплета.
      - А там нажать "Enable Backups".

    # Сколько стоят бэкапы?
      - 20% от цены тарифного плана дроплета.
      - Например, для плана $5/мес. бэкапы стоят $1/мес.

    # Как скачать бэкап или снэпшот?
      - Никак. В DO нет такого функционала.
      - Чтобы реализовать такое, можно почитать:
          https://www.digitalocean.com/community/tutorials/how-to-choose-an-effective-backup-strategy-for-your-vps
          https://www.digitalocean.com/community/tutorials/how-to-use-backuppc-to-create-a-backup-server-on-an-ubuntu-12-04-vps

    # Как восстановить дроплет, который не загружается?
      - Есть 2 варианта:
        1) Попытаться восстановить с помощью Fsck Kernel.
        2) Попытаться восстановить с помощью Recovery ISO.
      - Читай туториал:
          https://www.digitalocean.com/community/articles/how-to-recover-from-file-system-corruption-using-fsck-and-a-recovery-iso

    # Как починить файловую систему?

      1.  Power off your Droplet and change your kernel to 
          the DO-recovery-static-fsck image.
      2.  Boot your Droplet and access it via the console in 
          he control panel.
      3.  Run the command "fsck /dev/vda"
      4.  Answer yes to any requests to repair errors
      5.  Power off your Droplet, change the kernel back to 
          the original, and reboot

> Список полезных туториалов

  # An Introduction to Securing your Linux VPS
    - https://www.digitalocean.com/community/tutorials/an-introduction-to-securing-your-linux-vps

  # How To Create Your First DigitalOcean Droplet Virtual Server
    - https://www.digitalocean.com/community/tutorials/how-to-create-your-first-digitalocean-droplet-virtual-server

  # How To Set Up a Host Name with DigitalOcean (DNS)
    - https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean

  # How To Set Up SSH Keys
    - https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2

  # How To Install Git on Ubuntu 14.04
    - https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-14-04

  # How To Create a SSL Certificate on Apache for Ubuntu 14.04
    - https://www.digitalocean.com/community/tutorials/how-to-create-a-ssl-certificate-on-apache-for-ubuntu-14-04

  # How To Set Up a Firewall Using Iptables on Ubuntu 14.04
    - https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-iptables-on-ubuntu-14-04


В2. Инструкция по созданию нового дроплета на DigitalOcean

--------------------------------------
Оглавление:

  # Ссылки
  # Введение
  # Создание дроплета, пошаговая инструкция

--------------------------------------

> Ссылки

  # Официальная инструкция на DigitalOcean
      https://www.digitalocean.com/community/tutorials/how-to-create-your-first-digitalocean-droplet-virtual-server


> Введение
  - VPS - Virtual Private Server.
  - На местном сленге DigitalOcean называется дроплетом.
  - Это пошаговая инструкция по созданию дроплета.


> Создание дроплета, пошаговая инструкция

  1. Войдите в свой ЛК
    - Справа сверху нажмите кнопку "Create Droplet".

  2. Выберете Image для дроплета

    2.1. Вариант №1: выбор чистой ОС
      - Например, можно выбрать Ubuntu.
      - Плюс, можно выбрать конкретную версию и разрядность ОС.
      - Для серверов с RAM <= 1GB рекомендуется выбирать 32 разрядную ОС.
      - Для серверов с RAM >= 2GB рекомендуется выбирать 64 разрядную ОС.

    2.2. Вариант №2: выбор ОС с предустановленным набором программ
      - Выбрать можно на вкладке "One-click Apps".
      - Это будет чистая ОС + предустановленный набор программ.

    2.3. Вариант №3: создать дроплет из ранее снятого снэпшота
      - Хорошим решением было бы 1 раз настроить себе сервер-образец.
      - А все новые сервера создавать из снэпшота этого образца.

    2.4. Вариант №4: создать дроплет из бэкапа
      - Из ранее автоматически сгенерированного бэкапа.

  3. Выбор тарифного плана
    - Планы от $5 до $640 в месяц.
    - Для планов $5, $10 надо выбирать 32 разрядную ОС.
    - А для планов от $20 надо выбирать 64 разрядную ОС.

  4. Выбор датацентра
    - Датацентр можно выбирать в разных регионах.
    - В некоторых регионах есть несколько датацентров на выбор.
    - Наверное, лучше выбирать датацентр поближе к целевой аудитории.
    - Для РФ, можно выбрать Германию или Голандию.

  5. Выбор дополнительных опций

    5.1. Private Networking
      - Включает интерфейс для private networking.
      - Через неё дроплеты смогут общаться друг с другом.
      - Но лишь в пределах одного датацентра.

    5.2. Backups
      - Включить автоматические бэкапы.
      - Они делаются раз в 2 дня, и стоят 20% от тарифного плана.

    5.3. IPv6
      - Включить IPv6-доступ для дроплета.

    5.4. User Data
      - Добавить ли доп.метаданные дроплету?

  6. Выбор SSH-ключей
    - Это не обязательно, но желательно выбрать SSH-ключ.
    - Потому что подключение к дроплету по паролю не безопасно.
    - Если SSH-ключа нет, рекомендуется его создать.
    - Как создать SSH-ключ, смотри в главе:
        В3. Cоздание SSH-ключа на DigitalOcean, и подключение к дроплету с помощью PuTTY

  7. Выбор количества и имён дроплетов
    - Можно одновременно создать до 5 дроплетов.
    - У каждого дроплета должно быть уникальное имя.

  8. Создание дроплета и получение root-пароля
    - Нажмите кнопку "Create", и дроплет будет создан.
    - Если SSH-ключи не были указаны, то:
      по почте придёт пароль для подключения к нему 
    - В противном случае, пароль по почте не придёт.
    - Вместо него надо использовать выбранные SSH-ключи.

  9. Подключение к дроплету через SSH с помощью PuTTY
    - Теперь можно подключиться к дроплету через SSH.
    - На Windows, для этого следует использовать PuTTY.
    - Подробную инструкцию читай в главе:
        В3. Cоздание SSH-ключа на DigitalOcean, и подключение к дроплету с помощью PuTTY


В3. Cоздание SSH-ключа на DigitalOcean, и подключение к дроплету с помощью PuTTY

--------------------------------------
Оглавление:

  # Ссылки
  # Введение
  
  # Создание SSH-ключа, пошаговая инструкция
  # Добавление публичной части SSH-ключа на DigitalOcean
  # При создании дроплета теперь можно указать этот ключ
  # Настройка PuTTY для подключения к дроплету по SSH-ключам

--------------------------------------

> Ссылки

  # How to Log In With Windows (см. step nine)
      https://www.digitalocean.com/community/tutorials/how-to-create-your-first-digitalocean-droplet-virtual-server

  # How To Log Into Your Droplet with PuTTY 
      https://www.digitalocean.com/community/tutorials/how-to-log-into-your-droplet-with-putty-for-windows-users

  # How To Use SSH Keys with PuTTY on DigitalOcean Droplets
      https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-putty-on-digitalocean-droplets-windows-users


> Введение
  - В этой главе описано, как создать SSH-ключ для доступа к дрполету.
  - Ведь доступ к дроплету по паролю не безопасен, его можно подобрать.
  - Описание это в формате пошаговой инструкции.


> Создание SSH-ключа, пошаговая инструкция

  1. Скачать PuTTYgen
    - Открыть официальный сайт PuTTY и скачать программу PuTTYgen:
        http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html

  2. Запустить PuTTYgen
    - Никакие параметры не настраивать, и так сойдёт в большинстве случаев.

  3. Нажать кнопку "Generate"
    - Начнётся генерация SSH-ключей.
    - Надо будет двигать мышью туда-сюда.
    - Passphrase использовать не надо, иначе его придётся каждый раз вводить при логине.

  4. Сохранить public и private ключи в отдельный каталог
    - Сабж.
    - Private key надо копировать прямо из PuTTY.
    - Если открыть в notepad и скопировать, будет error в DO.


> Добавление публичной части SSH-ключа на DigitalOcean

  1. Войти в настройки своего ЛК на DO

  2. Выбрать слева раздел Security

  3. Промотать вниз и добавить там новый SSH
    - Ввести имя SSH и сам код публичного ключа.
    - Нажать кнопку "Create SSH Key".


> При создании дроплета теперь можно указать этот ключ
  - При создании дроплета можно выбрать SSH-ключ.
  - Один из тех, что были добавлены в DO ранее.
  - Тогда доступ к дроплету будет только по выбранному SSH-ключу.


> Настройка PuTTY для подключения к дроплету по SSH-ключам

  1. Открываем: Connection > SSH > Auth

  2. Нажимаем "Browse" и указываем путь к приватному ключу
    - Тому самогу, public-ключ от которого назначен дроплету.

  3. Идём в "Session", назначаем IP и порт, и сохраняем сессию
  - IP и порт можно посмотреть у себя в ЛК на DO.
  - А сессии дать имя такое же, как у дроплета.


В4. Инструкция по подготовке сервера к работе

--------------------------------------
Оглавление:

  # Ссылки
  # Введение
  
  # Этап №1: установка необходимых приложений
  
    1. Установка MySQL, NGINX, PHP
      1.1. Ссылка на инструкцию
      1.2. Обновить Apt-Get
      1.3. Установить MySQL
      1.4. Установить NGINX
      1.5. Установить PHP
      1.6. Осуществить первичную настройку PHP
    2. Установка GIT  
    3. Установка Composer
    4. Установка NodeJS
    5. Установка Redis

  # Этап №2: тонкая настройка php
  # Этап №3: тонкая настройка MySQL
  # Этап №4: настройка фаервола
  # Этап №5: настройка удалённого подключения к MySQL с Workbench
  # Этап №6: скопировать web-приложение на сервер
  # Этап №7: настроить cron и автозапуск сервера
  # Этап №8: сменить конфиг проекта на "продакшн"
  # Этап №9: настроить nginx
  # Этап №10: настроить DNS и домены

--------------------------------------

> Ссылки

  # Какие приложения установлены в Homestead
      http://laravel.com/docs/5.1/homestead#introduction

  # How To Install Linux, nginx, MySQL, PHP (LEMP) stack on Ubuntu 12.04
      https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-on-ubuntu-12-04

  # Как установить Git в Ubuntu 14.04
      https://www.digitalocean.com/community/tutorials/git-ubuntu-14-04-ru

  # How To Install and Use Composer on Ubuntu 14.04
      https://www.digitalocean.com/community/tutorials/how-to-install-and-use-composer-on-ubuntu-14-04

  # Как установить Node.js в Ubuntu 14.04
      https://www.digitalocean.com/community/tutorials/node-js-ubuntu-14-04-ru

  # How To Install and Use Redis
      https://www.digitalocean.com/community/tutorials/how-to-install-and-use-redis

  # Redis on Ubuntu 12.04 (Precise Pangolin)
      https://www.linode.com/docs/databases/redis/redis-on-ubuntu-12-04-precise-pangolin


> Введение
  - Мало создать дроплет. Надо его ещё и настроить нужным образом.
  - Здесь описана настройка для Laravel-приложений.
  - Причём, написанных в моём уникальном модульном стиле.
  - Глава выполнена в виде набора лаконичных, чётких инструкций.


> Этап №1: установка необходимых приложений

  1. Установка MySQL, NGINX, PHP

    1.1. Ссылка на инструкцию
      - https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-on-ubuntu-12-04

    1.2. Обновить Apt-Get
      - Выполнить команду: 

        sudo apt-get update

    1.3. Установить MySQL
      - Установить MySQL. Для этого выполнить команду:

        sudo apt-get install mysql-server php5-mysql

      - Во время установки назначить root-пароль для сервера MySQL.
      - После установки, активировать MySQl командой:

        sudo mysql_install_db

      - И наконец, надо выполнить скрипт для настройки конфига.
      - И поотвечать на вопросы, которые по поназадаёт. 
      - Для этого выполнить:

        sudo /usr/bin/mysql_secure_installation

      - Проверить, что MySQL работает, подключившись к нему.
      - Ниже заменить root и password на имя и пароль пользователя mysql.

        mysql -uroot -ppassword

    1.4. Установить NGINX
      - Установить NGINX. Для этого выполнить команду:

        sudo apt-get install nginx

      - Затем, запустить NGINX:

        sudo service nginx start

      - Проверить, что NGINX работает.
      - Для этого ввести ip дроплета в адресную строку брауреза.
      - И нажать enter. Должна появиться надпись: Welcome to nginx!

    1.5. Установить PHP
      - Для этого ввести:

          sudo apt-get install php5-fpm
          sudo apt-get install php5-cli

    1.6. Осуществить первичную настройку PHP
      
      # Устранить небольшую проблему с безопасностью
        - Открыть конфиг php:

            sudo nano /etc/php5/fpm/php.ini

        - Найти и заменить (устранение проблемы с безопасностью):

            С:    cgi.fix_pathinfo=1
            На:   cgi.fix_pathinfo=0

        - Сохнанить и закрыть конфиг php.

      # Внести изменения в конфигурацию PHP-FPM
        - Открыть конфиг:

            sudo nano /etc/php5/fpm/pool.d/www.conf

        - Найти и заменить:

            С:    listen = 127.0.0.1:9000
            На:   /var/run/php5-fpm.sock

        - Сохранить и выйти. Перезапустить php-fpm:
        
            sudo service php5-fpm restart 

  2. Установка GIT
    
    2.1. Установить GIT
      - Для установки ввести:

          sudo apt-get install git

    2.2. Настроить GIT
      - Указать своё имя и email.
      - Для этого ввести:

          git config --global user.name "4gekkman"
          git config --global user.email "4gekkman@gmail.com"          

  3. Установка Composer

    3.1. Установить CURL
      - Она понадобится нам, чтобы скачать composer.
      - Для этого ввести:

          sudo apt-get install curl

    3.2. Скачать и установить Composer
      - Для этого ввести:

          curl -sS https://getcomposer.org/installer | sudo php -- --install-dir=/usr/local/bin --filename=composer

      - Проверить, что composer работает. Для этого ввести:

          composer

      - Должен отобразиться список доступных команд.

  4. Установка NodeJS

    4.1. Установить NodeJS
      - Для этого ввести:

          sudo apt-get install nodejs

    4.2. Установить npm (менеджер пакетов nodejs)
      - Для этого ввести:

          sudo apt-get install npm

    4.3. Установить pm2 (нужен для Laravel)
      - Для этого ввести:

          npm install pm2 -g

    4.4. Установить Bower npm install -g bower
      - Для этого ввести:

          npm install -g bower

    4.5. Установить Grunt npm install -g bower
      - Для этого ввести:

          npm install -g grunt-cli

    4.6. Установить Gulp npm install -g bower
      - Для этого ввести:

          npm install --save gulp-install

    4.7. Установка необходимых для Websocket модулей
      - Для этого ввести:

          npm install socket.io
          npm install ioredis


  5. Установка Redis

    5.1. Установка Redis
      - Для этого выполнить:

          sudo apt-get install redis-server

      - Проверить, работает ли Redis, выполнив:

          redis-cli -v        // должен вернуть версию Redis'а

    5.2. Сделать бэкап конфига Redis
      - Для этого ввести:

          sudo cp /etc/redis/redis.conf /etc/redis/redis.conf.default


> Этап №2: тонкая настройка php

  1. Открыть конфиг php.ini в редакторе
    - Для этого выполнить:

        sudo nano /etc/php5/fpm/php.ini

  2. В нём найти и настроить следующие директивы:

    upload_max_filesize = 100M    // MAX размер загружаемого файла
    memory_limit = 512MB          // Лимит RAM на выполнение скрипта
    max_execution_time = 300      // MAX время (сек.) исполнения скрипта
    max_file_uploads = 100        // MAX кол-во одновременных загрузок файлов
    post_max_size = 100M          // Ограничение на MAX размер POST-запросов
    max_input_vars = 10000        // Ограничение на MAX число переменных в POST-запросах

  3. Перезапустить PHP
    - Для этого выполнить:

        restart php5-fpm


> Этап №3: тонкая настройка MySQL

  1. Открыть конфиг my.conf в редакторе
    - Для этотого выполнить:

        sudo nano /etc/mysql/my.cnf

  2. В нём найти и настроить следующие директивы:

    > Общие настройки

      # innodb_buffer_pool_size
        - Должно быть MAX возможным, близким к MAX RAM.
        - Это гарантирует, что RAM, а не HDD будет использоваться для операций.
        - Обычно его назначают равным 75% от RAM.
        - Таблица значений в зависимости от размера RAM:
          
            RAM           VALUE
          ---------------------------
            512M          384M
            1GB           768M
            2GB           1.5GB
            4GB           3GB
            8GB           6GB
            16GB          12GB
            32GB          24GB
            64GB          48GB

      # innodb_log_file_size
        - Это логи операций для восстановления в случае аварии.
        - Состоят из 2-х файлов-логов.
        - Здесь мы назначаем MAX размер каждого.
        - Для обычного приложения можно поставить:

            512M      // даёт 1024M на redo-логи

        - Для приложения, интенсивно пищущего в БД:

            4G        // даёт 8G на redo-логи

        - После изменения этого значения, надо удалить старые логи.
        - Иначе, демон mysql не будет запускаться.
        - Для этого, выполнить команды:

            sudo rm /var/lib/mysql/ib_logfile0
            sudo rm /var/lib/mysql/ib_logfile1

      # max_connections
        - Есть такая ошибка "too many connections".
        - Она означает, что max_connections слишком низок.
        - По умолчанию стоит 151 max соединение.
        - А если поставить много, скажем, 1000, то может зависнуть.
        - Можно поставить 1000:

            max_connections = 1000

        - Пусть обслуживет, как может.

    > Настройки InnoDB

      # innodb_file_per_table
        - Хранить ли данные и индексы таблиц в 1 или разных файлах?
        - Если таблиц много (10k+), то лучше хранить в 1 файле.
        - А если таблиц мало, то лучше хранить в разных.
        - В MySQL по умолчанию ON.
        - В общем случае, лучше хранить в 1 файле:

          innodb_file_per_table = OFF
 
      # innodb_flush_log_at_trx_commit
        - Как часто данные сбрасываются в redo-log?
        - Доступные значения (чем выше, тем быстрее работает):

          0   // не часто (хороший вариант для реплики)
          2   // раз в секунду (менее безопасно, чем 1)
          1   // (по умолчанию) Отвечает ACID (каждая транзакция сбрасывается)

        - В итоге надо поставить:

          innodb_flush_log_at_trx_commit = 2
   
      # innodb_flush_method
        - Как данные сбрасываются из памяти на диск.
        - Есть 2 значения (чем выше, тем быстрее):

            O_DSYNC   // Не надёжнее, но быстрее (лучше использовать для реплик)
            O_DIRECT  // (по умолчанию) Надёжнее, но медленнее

        - В итоге, надо поставить:

            innodb_flush_method = O_DIRECT

      # innodb_log_buffer_size
        - Размер буфер для транзакций, которые ещё не были подтверждены.
        - По умолчанию стоит значение 1M, что обычно норм.
        - Но если в транзакциях передаются большие штуки, буфер переполняется.
        - Что приводит к большой I/O нагрузке.
        - Можно поставить 10M:

          innodb_log_buffer_size = 10M          

    > Прочие настройки

      # query_cache_size
        - Кэш с ключами - запросами, значениями - результатами запросов.
        - Плюс, в кэше хранится список таблиц, выборки из которых закэшированы.
        - При изменениях в любой из них, соотв.кэш удаляется.
        - Рекомендуется ставить не более 256M
        
          query_cache_size = 256M

  3. Настроить удалённый доступ к MySQL
  
    3.1. Общая информация
      - Он нужен для подключения к MySQL сервера с моего девелоперского компа.
      - А именно, из программы MySQL Workbench, для управления БД сервера.
      - Так, с помощью моделей, я легко буду обновлять БД модулей на моих серверах.
      - Пароль на сервере никакой, чтобы обезопаситься, надо настроить фаервол.
      - Для этого мой девелоперский комп должен использовать один и тот же IP.
      - В iptables на сервере надо будет прописать этот IP.
      - И в конфеги my.cnf сервера MySQL разрешить удалённые подключения.

    3.2. Настроить Iptables
      - Как это сделать, см. главу:
          B5. Работа с Iptables, настройка фаервола для MySQL

    3.3. Разрешить в конфиге MySQL удалённые подключения
      - Надо открыть в редакторе конфиг my.cnf:

          sudo nano /etc/mysql/my.cnf

      - И там установить значение:

          bind_address = 0.0.0.0

      - Теперь подключиться к этому серверу MySQL можно откуда угодно.
      - А по умолчанию стоял localhost (127.0.0.1).
      - С этого момента сервер под угрозой взлома.
      - Необходимо установить для него защиту фаерволом. 

  4. Перезагрузить MySQL
    - Для этого выполнить:

        sudo service mysql restart

  5. Создать нового пользователя
    - С административными привилегиями.
    - С именем homestead и паролем secret.
    - Для этого подключиться к серверу MySQL от имени root.
    - Посмотреть, какие пользователи уже есть:

        SELECT user,host FROM mysql.user;

    - Затем, создать нового пользователя-админа:

        CREATE USER 'homestead'@'127.0.0.1' IDENTIFIED BY 'secret';
        GRANT ALL PRIVILEGES ON *.* TO 'homestead'@'127.0.0.1' WITH GRANT OPTION;  



> Установка таймаутов побольше 

  1. Установим таймаут nginx 300 секунд (вместо стандартных 30):
    - Открываем файл /etc/nginx/available-sites/[нужный конфиг]
    - Там в указанный блок location вписываем директиву:

      location ~ \.php$ {
        ...
        fastcgi_read_timeout 300;
        ...
      } 

  2. Установим таймаут php-fpm 300 секунд (вместо стандартных 30):   
    - Открываем конфиг php-fpm: /etc/php5/php-fpm/php.ini
    - Находим там директиву max_execution_time.
    - Устанавливаем значение 300.

> Настройка ограничений в php.ini
  http://php.net/manual/ru/features.file-upload.common-pitfalls.php

  # Максимальный размер закачиваемого файла
    - upload_max_filesize
    - Установить равным 100M

  # Ограничение RAM на выполнение скрипта
    - memory_limit
    - Установить равным 512MB

  # MAX время выполнения скрипта
    - max_execution_time
    - Установить равным 300 

  # MAX кол-во одновременно закачиваемых файлов
    - max_file_uploads
    - Установить равным 100


> Этап №4: настройка фаервола
  - Теперь надо настроить фаервол для сервера.
  - Как это сделать, см. в главе:
      B5. Работа с Iptables, настройка фаервола для MySQL
  - А именно, см. пункт "Настройка фаервола на новом сервере".


> Этап №5: настройка удалённого подключения к MySQL с Workbench

  1. Сконвертировать private-ключ от PuTTY в формат OpenSSH

    1.1. Открыть PuttyGen
    1.2. Нажать Load
    1.3. Загрузить свой приватный ключ от PuTTY
      - Которым можно подключиться к дроплету в DO.
    1.4. Нажать "Conversions->Export OpenSSH" и экспортировать ключ в формат OpenSSH.
    1.5. Оставить поле пароля SSH пустым.
    1.6. Сохранить новый SSH-ключ рядом со старым.
    1.7. Далее в настройках workbench указывать именно вот этот новый ключ. 

  2. Запустить Workbench

  3. Создать новое подключение.

  4. Выбрать Connection Method
    - Standard TCP/IP over SSH

  5. Настроить подключение:
    - Указать: 

      hostname = [ip сервера на DO]
      SSH Key File = [путь к приватному SSH-ключу от DO сервера]
      MySQL hostname = 127.0.0.1
      Username = [имя пользователя MySQl]
      Password = [пароль пользователя MySQl]


> Этап №6: скопировать web-приложение на сервер

  1. Создать каталог /root/projects для проектов
    - И открыть к нему общий доступ.
    - Для этого:

        sudo mkdir /root/projects
        sudo chmod 777 /root/projects

  2. Подключить ФС сервера к ФС компа для разработки
    - Как сделать это для windows описано в главе:
        "В6. Как смонтировать ФС удалённого Linux в ФС Windows"

  3. Скопировать в project нужные проекты

  4. Через workbench наполнить БД сервера
    - Сделать экспорт БД проекта из MySQL-сервера на компе разработчика.
    - Потом сделать импорт в MySQL-сервер дроплета.


Этап №7: настроить cron и автозапуск сервера

  1. Настроить планировщик Laravel
    - Чтобы он запускался ежеминутно.
    - Для этого ввести:

        crontab -e

    - Нажать enter.
    - И туда разместить вот такую строку (указать правильный путь):

        * * * * * php /root/projects/control-center-one.ru/artisan schedule:run 1>> /dev/null 2>&1

  2. Настроить автозапуск демона queue:listen
    - Для этого открыть конфиг автозапуска:

         sudo nano /etc/rc.local

    - И туда вставить следующий код.
    - Только в нём заменить пути на актуальные:

      -------------------------------------------

# Отладка
exec 2> /tmp/rc.local.debug
set -x

# Проверить наличие необходимых каталогов
# - Их может и не быть в наличии, т.к. NFS может ещё не успеть их подключить
# - В этом случае, скрипт ждёт 5 секунд, и проверяет снова.

  # Подготовить переменную есть/нет
  IS="no";

  # Запустить цикл, пока IS=="no"
  while [ $IS == "no" ]; do

    # Если требуемые каталоги есть, то присвоить переменной IS значение "yes"
    if [ -d "/root/projects/control-center-one.ru/" ]; then
      if [ -d "/root/projects/control-center-one.ru/app/Websocket" ]; then
        IS="yes"
      fi
    # В противном случае, подождать 5 сек., и попробовать снова
    fi
    sleep 5

  done

# Запустить демон queue:listen
cd "/root/projects/control-center-one.ru/"
php artisan queue:listen > /dev/null 2>&1 &

# Запустить websocket-сервер
cd "/root/projects/control-center-one.ru/app/Websocket"
nohup nodejs socket.js > /dev/null 2>&1 &

exit 0

      -------------------------------------------


> Этап №8: сменить конфиг проекта на "продакшн"
  - Актуальный конфиг Laravel-проекта лежит в .env в корне проекта.
  - Во время разработки конфиг проекта был "для разработки".
  - А на продакшн сервере должен быть другой конфиг.


> Этап №9: настроить nginx

  1) Настроить конфиги в /etc/nginx/sites-available
  
  2) Настроить символьные ссылки в /etc/nginx/sites-enabled
    - Надо перейти в этот каталог.
    - И настроить именны символьные ссылки на конфиги из sites-available.
    - Например:

        sudo ln -s /etc/nginx/sites-available/airbeats-russia.ru airbeats-russia.ru


> Этап №10: настроить DNS и домены
  - Читай следующие главы:
    В7. Настройка DNS на DigitalOcean  
    В8. Настройка электронной почты











B5. Работа с Iptables, настройка фаервола для MySQL

--------------------------------------
Оглавление:

  # Ссылки
  # Введение

  Как работает iptables

    # Общая информация об Iptables
    # Как работает Iptables
    # IPv4 против IPv6
    # Что надо намотать на ус

  Настройка iptables, чтобы пропускал SSH- и HTTP-трафик
    
    # Обзор синтаксиса для работы с iptables
    # Конкретные рецепты по работе с iptables

      - Показать все правила всех цепочек
      - Установить политику для указанной цепочки
      - Удалить все правила из всех цепочек
      - Удалить правило #7 из цепочки INPUT

    # Настройка фаервола на новом сервере

--------------------------------------

> Ссылки

  # How the Iptables Firewall Works
      https://www.digitalocean.com/community/tutorials/how-the-iptables-firewall-works

  # How To Set Up a Firewall Using Iptables on Ubuntu 14.04
      https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-iptables-on-ubuntu-14-04

  # Iptables Essentials: Common Firewall Rules and Commands
      https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands

  # 21 пример использования iptables для администраторов.
      http://vasilisc.com/21-examples-iptables

> Введение
  - Здесь мы рассмотрим основы работы с фаерволом Iptables.
  - А также настройку Iptables для защиты интерфейса MySQL от взлома.


> Общая информация об Iptables
  - Это стандартный фаервол, который есть в большинстве дистрибутивов Linux.
  - Современный вариант Iptables - Nftables - постепенно вытесняет первого.
  - По большому счёту, это фронтенд к части ядра, отвечающей за сеть.
  - Он матчит каждый сетевой пакет с указанным в конфиге набором правил.
  - И на основании этих правил решает, что делать с этим самым пакетом.


> Как работает Iptables
  
  # Вводная
    - Обсудим терминологию, и общие принципы работы Iptables.
  
  # Набор правил
    - Фаервол Iptables пропускает сетевой трафик через набор правил.
    - Правила определяют хар-ки пакетов, на которые они должны действовать.
    - А также, какие действия с соотв.пакетами должен произвести фаервол.

  # Как матчатся пакеты
    - Есть много свойств, по которым фаервол матчит пакеты.
    - Протокол, ip и port, использованный интерфейс, 
      соотнесение с предыдущими пакетами и т.д.

  # Действия
    - Допустим, фаервол заматчил какой-то пакет.
    - И теперь он должен применить к нему некое действие.
    - Это действие в местной терминологии называется Target.
    - Целью может быть: пропустить, зарубить, перенаправить,
      записаь в лог, и т.д.

  # Цепочки правил - может выполниться лишь 1 действие на всю цепочку
    - Все правила сгруппированы в цепочки.
    - Пакет последовательно проходит через строй правил в цепочках.
    - Когда пакет матчится с 1-им из правил цепочки, выполняется соотв.действие.
    - При этом, пакет уже не идёт дальше, и не матчится с остальными.
    - Т.О., может выполниться лишь 1 действие на всю цепочку.
    - Пользователь может создавать столько цепочек, сколько ему надо.
    - По умолчанию определено 3 цепочки:

      INPUT
        Обрабатывает все пакеты, входящие в сервер.

      OUTPUT
        Обрабатывает все пакеты, исходящие от сервера.

      FORWARD
        Обрабатывает все переадресованные сервером пакеты.

  # Политика
    - Определяет, что будет с пакетом, прошедшим все правила
      цепочки, но не заматчившимся ни с одним из них,
      и, соответственно, когда ни одно действие не исполнилось.
    - Каждая цепочка изначально обладает политикой по умолчанию.
    - Последняя состоит в том, чтобы пропустить этот пакет.
    - Но можно выбрать какое-либо другое действие по умолчанию.

  # Отслеживание соединений
    - Через правила фаервол может также отслеживать соединения.
    - Соотв.можно создавать правила, использующие эту инфу.


> IPv4 против IPv6

  # Трафик IPv4 и IPv6 совершенно независимы
    - Это как 2 независимые дороги в ядре Linux.

  # Фаерволы для IPv4 и IPv6 разные и независимые
    - Из предыдущего следует сабж.
    - Это значит, придётся 2 раза настраивать 2 фаервола.
    - Один для IPv4, второй для IPv6.

  # iptables для IPv4-трафика
    - Никакие правила из iptables никак не влияют на IPv6-трафик.

  # ip6tables для IPv6-трафика
    - Никакие правила из ip6tables никак не влияют на IPv4-трафик. 
    - Чтобы работать с ip6tables нужно знать правильный IPv6-адрес сервера.

  # Синтаксис для iptables и ip6tables одинаковый
    - Так что это не так уж трудно создавать правила им обоим.
    - Главное не забывать держать актуальными обе таблицы.


> Что надо намотать на ус

  # Первое
    - Всегда д.б. правило, которое держит соединение активным.
    - При применении по умолчанию к цепочке политики уничтожения пакетов.
    - Особенно это важно, если ты взаимодействуешь с сервером через SSH.
    - Может статься, что ты так настроишь фаервол, что не сможешь подключитсья по SSH.
    - Но не беда, тогда придётся воспользоваться веб-консолью из ЛК DO.

  # Второе
    - Порядок правил в каждой цепочке имеет значение.
    - Сортировка д.б. такая, чем ниже, тем более общие правила.
    - А чем выше, тем более специфичные прафила.
    - Самое последнее правило в цепочке, это и есть политика.
    - Оно является самым общим, и ловит все пакеты, доходящие до него.

  # Третье
    - Как следствие, действия правил цепочки зависят от политики.
    - Если политика ACCEPT, то действия правил должны дропать некоторые пакеты.
    - Если политика DROP, то действия правил должны пропускать некоторые пакеты.


> Обзор синтаксиса для работы с iptables

  # Возможные варианты синтаксиса:

     iptables -[ACD] chain rule-specification [options]
     iptables -I chain [rulenum] rule-specification [options]
     iptables -R chain rulenum rule-specification [options]
     iptables -D chain rulenum [options]
     iptables -[LS] [chain [rulenum]] [options]
     iptables -[FZ] [chain] [options]
     iptables -[NX] chain
     iptables -E old-chain-name new-chain-name
     iptables -P chain target [options]
     iptables -h (print this help information)    

  # Команды

    -A chain                          Append to chain
    -C chain                          Check for the existence of a rule
    -D chain                          Delete matching rule from chain
    -D chain rulenum                  Delete rule rulenum (1 = first) from chain
    -I chain [rulenum]                Insert in chain as rulenum (default 1=first)
    -R chain rulenum                  Replace rule rulenum (1 = first) in chain
    -L [chain [rulenum]]              List the rules in a chain or all chains
    -S [chain [rulenum]]              Print the rules in a chain or all chains
    -F [chain]                        Delete all rules in chain or all chains
    -Z [chain [rulenum]]              Zero counters in chain or all chains
    -N chain                          Create a new user-defined chain
    -X [chain]                        Delete a user-defined chain
    -P chain target                   Change policy on chain to target
    -E old-chain new-chain            Change chain name, (moving any references)

  # Опции

    -4                                Nothing (line is ignored by ip6tables-restore)
    -6                                Error (line is ignored by iptables-restore)
    -p proto                          protocol: by number or name, eg. `tcp'
    -s address[/mask][...]            source specification
    -d address[/mask][...]            destination specification
    -i input name[+]                  network interface name ([+] for wildcard)
    -j target                         target for rule (may load target extension)    
    -g chain                          jump to chain with no return
    -m match                          extended match (may load extension)
    -n                                numeric output of addresses and ports
    -o output name[+]                 network interface name ([+] for wildcard)
    -t table                          table to manipulate (default: `filter')
    -v                                verbose mode
    -w                                wait for the xtables lock
    --line-numbers                    print line numbers when listing
    -x                                expand numbers (display exact values)
    -f                                match second or further fragments only
    --modprobe=<command>              try to insert modules using this command
    --set-counters PKTS BYTES         set the counter during insert/append
    -V                                print package version.


> Конкретные рецепты по работе с iptables

  # Показать все правила всех цепочек

      sudo iptables -L

  # Установить политику для указанной цепочки

      sudo iptables -P INPUT ACCEPT
      sudo iptables -P OUTPUT DROP
      sudo iptables -P FORWARD REJECT

  # Удалить все правила из всех цепочек

      sudo iptables -F

  # Удалить правило #7 из цепочки INPUT

       iptables -D INPUT 7


> Настройка фаервола на новом сервере

  1. Удалить все правила
    - Для этого выполнить:
      
      sudo iptables -F      // для IPv4
      sudo ip6tables -F     // для IPv6

  2. Установить цепочкам INPUT и OUTPUT политику ACCEPT
    - Для этого выполнить:
      
      IPv4
        sudo iptables -P INPUT ACCEPT 
        sudo iptables -P OUTPUT ACCEPT 

      IPv6
        sudo ip6tables -P INPUT ACCEPT 
        sudo ip6tables -P OUTPUT ACCEPT           

  3. Добавить правило, явно разрешающее SSH-соединения
    - Для этого выполнить:

      sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT   // IPv4
      sudo ip6tables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT  // IPv6

    - Рассмотрим значения компонентов этого правила:

      -A INPUT
          Применить новое правило к цепочке INPUT

      -m conntrack
          Подключить модуль conntrack с доп.функционалом

      --ctstate ESTABLISHED,RELATED
          Применить правило к пакетам существующего соединения (ESTABLISHED)
          Применить правило к пакетам, имеющим отношение к существующему соединению (RELATED)

      -j ACCEPT
          Выбрать действие для правило - ACCEPT - пропустить эти пакеты.

    - Убедимся, что правило добавилось.
    - Для этого выполним:

        sudo iptables -L

  4. Открыть ряд портов
    - А именно:

      1) Порт 22 для SSH-соединений
      2) Порт 80 для HTTP-соединений
      3) Порт 53 для DNS
      4) Порт 443 для HTTPS-соединений
      5) Порт 25 для SMTP
      6) Порт 110 для POP3
      7) Порт 143 для IMAP
      8) Порт 6001 для WebSockets

    - Для этого выполнить:

        IPv4
          sudo iptables -A INPUT -m tcp -p tcp --dport 22 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 80 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 53 -j ACCEPT
          sudo iptables -A INPUT -m udp -p udp --dport 53 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 443 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 25 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 110 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 143 -j ACCEPT
          sudo iptables -A INPUT -m tcp -p tcp --dport 6001 -j ACCEPT

        IPv6
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 22 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 80 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 53 -j ACCEPT
          sudo ip6tables -A INPUT -m udp -p udp --dport 53 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 443 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 25 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 110 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 143 -j ACCEPT
          sudo ip6tables -A INPUT -m tcp -p tcp --dport 6001 -j ACCEPT

    - Рассмотрим значения компонентов этого правила:

      -A INPUT
          Применить новое правило к цепочке INPUT

      -p tcp
          Матчить пакеты, передаваемые по указанному протоколу        

      --dport 22
          Эта опция доступна, если опция -p tcp указана ранее.
          Она говорит - матчить пакеты, передаваемые через порт 22

      -j ACCEPT
          Выбрать действие для правило - ACCEPT - пропустить эти пакеты.

  5. Открыть доступ к MySQL-серверу через порт 3306 с IP девелопера
    - Ниже заменить тестовый IP на постоянный IP девелопера (узнать у провайдера)
    - Которому надо будет удалённо подключаться к MySQL-серверу.
    - Для этого выполнить:

        iptables -I INPUT 1 -p tcp -s 46.188.91.82 --dport 3306 -j ACCEPT     // IPv4
                                                                              // IPv6 - нет - разрешаем подключения только с IPv4

    - Не забыть в кофиге MySQL открыть доступ к нему извне.

  6. Разрешить взаимодействие внутренних серверов с использованием сетевых коммуникаций
    - Многие сервисы в ОС взаимодействуют друг с другом.
    - И часто они делают это с использованием сетевых коммуникаций.
    - То есть, как если бы они вз-ли через интернет.
    - Они делают это, используя псевдо-сетевой интерфейс loopback device.
    - Который направляет трафик обратно внутрь, а не к другим компьютерам.
    - Итак, что нужно, чтобы один сервис нормально вз-вал с другим?
    - Который слушает порт 4555?
    - Ему нужно отправлять пакеты на порт 4555 интерфейса loopback device.
    - Это нам и надо разрешить отдельным правилом. Для этого надо выполнить:

        sudo iptables -I INPUT 1 -i lo -j ACCEPT    // IPv4
        sudo ip6tables -I INPUT 1 -i lo -j ACCEPT   // IPv6

    - Рассмотрим значения компонентов этого правила:
    
        -I INPUT 1
            -I вставляет правило в указанное место цепочки
            В даном случае, правило вставляется на 1 место цепочки
            Все входящие пакетв в 1-ю очередь проходят через него        

        -i lo
            Матчится, если пакет использует интерфейс loopback device (синоним IO interface)

    - Посмотреть все назначенные правила можно так.
    - В том числе, увидеть и интерфейсы, привязанные к правилам:

        sudo iptables -S

  7. Разрешить PING: изнутри-наружу, снаружи-внутрь
    - Для этого выполнить:

      IPv4
        iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
        iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT 
        iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT
        iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT

      IPv6
        - нет

  8. Добавить в конец цепочки INPUT дропающее оставшиеся пакеты правило
    - Для этого выполнить:

        sudo iptables -A INPUT -j DROP    // IPv4
        sudo ip6tables -A INPUT -j DROP   // IPv6

    - Это правило всегда должно быть в конце цепочки INPUT.
    - Ну а что, если надо добавить новое правило?
    - Надо сначала удалить дропающее правило из конца.
    - Затем добавить нужные новые правила.
    - А потом, в конце, снова добавить дропающее правило.
    - Например:

        sudo iptables -D INPUT -j DROP
        sudo iptables -A INPUT new_rule_here
        sudo iptables -A INPUT -j DROP        

  9. Сделать все назначенные для iptables правила постоянными
    - По умолчанию, все они временные, исчезнут после ребута.
    - Чтобы сделать их постоянными, надо установить это:

        sudo apt-get install iptables-persistent

    - Теперь сервис iptables-persistent будет загружаться при старте сервера.
    - И загружать все сохранённые правила.
    - После изменения правил фаервола, надо сохранить изменения в iptables-persistent.
    - Для этого надо выполнять команду:

        sudo invoke-rc.d iptables-persistent save


В6. Как смонтировать ФС удалённого Linux в ФС Windows

--------------------------------------
Оглавление:

  # Ссылки
  # Введение
  # Инструкция

--------------------------------------

> Ссылки

  # Статья на DigitalOcean, писывающая процесс
      https://www.digitalocean.com/community/tutorials/how-to-use-sshfs-to-mount-remote-file-systems-over-ssh

  # Ссылка на win-sshfs
      https://code.google.com/p/win-sshfs/

  # Статья с подсказкой:
      http://linuxlove.eu/quick-tip-mounting-remote-linux-directory-windows-linux-ssh/


> Введение
  - Чаще всего веб-сервер базируется на ОС Linux.
  - Сам же сервер, обычно, удалённый, где-нибудь в облаке.
  - Разработчик же у себя использует обычно Windows или MacOS.
  - В этой главе допустим, что он использует Windows 8.1.
  - Часто разработчику нужно переносить файлы.
  - Со своего компьютеран на сервер, и наоборот.
  - Делать это всё время в окне терминала неудобно.
  - Было бы здорово смонтировать ФС сервера в ФС компьютера разработчика.
  - В этой главе описано, как это сделать.


> Инструкция

  1. Скачать win-sshfs

  2. Назначить установочному файлу режим совместимости с Win7
    - Дело в том, что проект заброшен с 2012 года.
    - И Win8 официально им не поддерживается.
    - Если попробовать установить так, то будет error.

  3. Выполнить установку
    - Оно установится в "C:\Program Files (x86)\win-sshfs\".
    - Во время установки попросит перезагрузить систему.
    - Поэтому, перезагрузить, и закончить установку.

  4. Назначить файлу запуска программы режим совместимости с Win7
    - Сабж.

  5. Запустить программу
    - Она появится справа сверху в трее, щёлкнуть.

  6. Нажать кнопку Add
    - Ввести все данные для подключения.
    - Указать метод аутентификации через private key.
    - Выбрать буковку L для обозначения ФС.
    - Кликнуть галочку mount at login.
    - Нажать кнопки Save и Mount.
    - Всё, теперь он будет монтироваться каждый раз при старте компа.


В7. Настройка DNS на DigitalOcean

--------------------------------------
Оглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  # Официальная статья по настройке DNS от DigitalOcean
      https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean


> Введение
  - Итак, ты настроил сервер и прикупил себе домен.
  - У тебя есть IP адрес сервера, и имя твоего домена.
  - Их теперь надо связать на каком-нибудь DNS-сервере.
  - В нашем случае, у DO есть свои DNS-сервера.
  - В этой главе приведена пошаговая инструкция.


> Пошаговая инструкция

  1. Посмотреть, у какого регистратора зарегистрирован домен
    - В терминале ввести:

        whois example.com

    - Заменив "example.com" на имя своего домена.
    - В поле registrar будет имя регистратора.

  2. Указать домену DNS-сервера от DigitalOcean
    - Зайти в свой ЛК на сайте-регистраторе домена.
    - Зайти в раздел, где можно настроить DNS.
    - Указать для домена DNS от DigitalOcean:

        ns1.digitalocean.com
        ns2.digitalocean.com
        ns3.digitalocean.com       

    - Нажать ОК, и ждать.
    - Обновление DNS занимает обычно до 24 часов.
    - Проверить, внесены ли изменения, можно так:

        whois example.com   // указать свой домен

    - Там должны быть указаны 3 соотв. поля "Name Server".

  3. Настроить домен на DigitalOcean
    - Зайти в свой ЛК на DO.
    - Там сверху выбрать вкладку "Networking".
    - В ней указать для дроплета все домены (без www).

  4. Теперь надо подождать несколько часов
    - Пока все эти изменения всосутся DNS-серверами по всему миру.
    - И тогда, попробовать пингануть с компьютера разработчика наш домен:

        ping -t example.com


В8. Настройка электронной почты

--------------------------------------
Оглавление:

  # Ссылки
  # Введение
  # Пошаговая инструкция

--------------------------------------

> Ссылки

  # Официальный сайт email-сервиса mailgun
      http://www.mailgun.com/


> Введение
  - Итак, дроплет настроен, DNS и домен настроены.
  - Теперь надо организовать работу электронной почты.
  - В этой главе описано, как это сдеалть с помощью mailgun.
  - И как верифицировать свой домен для mailgun в DigitalOcean.


> Инструкция

  1. Создать учётную запись на mailgun.com
    - Она понадобится нам для авторизации на их smtp-сервере.
    - Заходим на mailgun.com и создаём новую учётную запись.  
    - Если учётная запись там уже есть, можно пропустить этот этап.

  2. Зайти в ЛК и добавить новый домен
    - В меню сверху выбрать Domains.
    - Там добавить домен, используемый с DigitalOcean.
    - В формате: mg.[имя домена].
    - Например: mg.domain.ru.

  3. Верифицировать добавленный домен
    - Кликнуть по добавленному домену в списке.
    - Там ниже есть раздел "Domain Verification & DNS".
    - В нём написано, какие записи надо добавить домену.
    - Открываем ЛК DigitalOcean, раздел "Networking -> Domains".
    - Заходим в настройки нужного нам домена.
    - И добавляем те записи, которые просит добавить mailgun.
    - Подождать до 24 часов, пока mailgun увидить изменения.

  4. Настроить config/mail.php в Laravel
    - Зайти в панель управления mailgun, раздел "Domains".
    - Зайти в доступный домен, щёлкнув по нему.
    - Посмотреть значения следующих параметров:

      # SMTP Hostname
        - Скорее всего это: smtp.mailgun.org

      # Default SMTP Login
        - Логин для подключения к SMTP-серверу

      # Default Password
        - Пароль для подключения к SMTP-серверу

    - Посмотреть номера портов.
    - Обычно SMTP-сервер слушает порты 25, 587 и 465.
    - Записать SMTP-логин и SMTP-пароль в файл настроек laravel mail.php
    - SMTP-логин записать в параметр 'username'.
    - SMTP-пароль записать в параметр 'password'.


