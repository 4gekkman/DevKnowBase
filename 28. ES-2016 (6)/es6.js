////=================================================////
////                                                 ////
////            Что нового в ECMAScript 6            ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Ресурсы //
  //---------//

    # Современные возможности ES-2015
        https://learn.javascript.ru/es-modern

    # Здесь можно проверить степень реализации фич ES6 в браузерах
        http://kangax.github.io/compat-table/es6/

    # Транспайлер Babel
        https://babeljs.io/repl

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////

  # А.  Современные возможности ES-2015

    А1. ES-2015 сейчас
    А2. Переменные: let и const
    А3. Деструктуризация
    А4. Функции
    А5. Строки


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. ES-2015 сейчас

--------------------------------------
Подоглавление:

  # Ссылки
  # Общие сведения о ES-2015
  # Какие в настоящее время есть возможности использовать ES6?

    ▪ Писать код конкретный JS-движок
    ▪ Использовать Babel

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] ES-2015 сейчас
      https://learn.javascript.ru/es-modern-usage

> Общие сведения о ES-2015

  • Был принят в 2015-м году.
  • Ещё не все возможности реализованы во всех браузерах.
  • Во многих браузерах сейчас работает только с 'use strict'.

> Какие в настоящее время есть возможности использовать ES6?

  • Писать код конкретный JS-движок
    - Про конкретные движки изестно, какие фичи ES6 они уже поддерживают.
    - Поэтому, можно просто не использовать не поддерживемы фичи.
    - Но этот вариант не особо годится для продакшн в большинстве случаев.
    - Для node.js сойдёт, но не для кроссбраузерной поддержки.

  • Использовать Babel

    ▪ Что такое Babel?
      - Это транспайлер, переписывающий код из ES-2015 на предыдущий стандарт.
    
    ▪ Состоит из двух частей

      1. Транспайлер.
      2. Полифилл
        - Это библиотека, которая добавляет в старые браузеры 
          поддержку возможностей, которые в современных браузерах являются встроенными.
        - Он добавляет методы Array.from, String.prototype.repeat и другие.

    ▪ Как обычно применяют babel
      - Обычно он работает на сервере.
      - В составе системы сборки, вроде webpack или brunch.
      - И автоматически переписывает весь код в ES5.
      - Настроить всё это легко, у большинства систем сборки есть плагин с Babel.


    - Он состоит из двух частей


А2. Переменные: let и const

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Отличия let от var
  # Константа const

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] Переменные: let и const
      https://learn.javascript.ru/let-const

> Введение
  - В ES-2015 предусмотрены новые способы объявления переменных.
  - Через let и const вместо var.

> Отличия let от var

  1. Область видимости переменной let – блок {...}.
    - var видна везде в функции.
    - let видна только в блоке {...}, где объявлена.
    - Это касается и блоков в if, while, for.
    - Пример:

      let age = 10;
      if(true) { 
        let age = 15;
        console.log(age);           // 15 
      }
      console.log(age);             // 10

  2. Переменная let видна только после объявления.
    - Переменные var существуют и до объявления, они равны undefined.
    - Переменные let же не существую до объявления.
    - Плюс, переменные let нельзя повторно объявлять, будет ошибка.

  3. При использовании в цикле, для каждой итерации создаётся своя переменная.
    - Переменная var одна на все итерации цикла. И видна даже после него.
    - Но с let по-другому. Каждому повторению цикла - своя let.
    - Если внутри цикла есть сложенные объявлений функций, то 
      в замыкании каждой будет соответствующая итерации переменная let.
    - Пример:

        function makeArmy() {

          let shooters = [];

          for (let i = 0; i < 10; i++) {
            shooters.push(function() {
              alert( i ); // выводит свой номер
            });
          }

          return shooters;
        }

        var army = makeArmy();

        army[0](); // 0
        army[5](); // 5    

> Константа const
  
  • Принципы работы const
    - Объявление const задаёт константу.
    - Константу нельзя изменить.
    - Пример:

        const apple = 5;
        apple = 10;       // ошибка  

    - В остальном, const аналогично let.

  • Если в константу присвоен объект
    - То от изменения защищена сама константа.
    - А вот свойства объекта менять можно.
    - Пример:

      const user = {
        name: "Вася"
      };

      user.name = "Петя"; // допустимо
      user = 5;           // нельзя, будет ошибка    

  • Верхний регистр


А3. Деструктуризация

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Деструктуризация массива

    ▪ Пример деструктуризации массива
    ▪ Ненужные элементы массива можно отбросить с помощью запятых
    ▪ Оператор "spread"
    ▪ Значения по умолчанию

  # Деструктуризация объекта

    ▪ Пример деструктуризации объекта
    ▪ Как присвоить св-во объекта в переменную с другим именем
    ▪ Значения по умолчанию
    ▪ Отсутствие оператора "spread" при диструктуризации объектов
    ▪ Проблема с видимостью let-переменных при деструктуризации

  # Вложенные диструктуризации

    ▪ В чём суть вложенных деструктуризаций
    ▪ Пример вложенных деструктуризаций    

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] Деструктуризация
      https://learn.javascript.ru/destructuring

> Введение
  - Деструктуризация, это особый синтаксис присвоения.
  - Можно присвоить массив или объект сразу нескольким
    переменным, разбив его на части.

> Деструктуризация массива

  • Пример деструктуризации массива
    - Первое значение массива пойдёт в переменную firstName.
    - Второе значение массива пойдёт в переменную lastName.

      'use strict';
      let [firstName, lastName] = ["Илья", "Кантор"];
      alert(firstName); // Илья
      alert(lastName);  // Кантор

  • Ненужные элементы массива можно отбросить с помощью запятых

      'use strict';
      // первый и второй элементы не нужны
      let [, , title] = "Юлий Цезарь Император Рима".split(" ");
      alert(title); // Император

  • Оператор "spread"
    - Иногда мы хотим получить последующие значения массива.
    - Но не уверены в их числе.
    - Можно добавить ещё один параметр, который получит "всё остальное".
    - Для этого надо использовать оператор "..." (spread, троеточие).
    - Пример:

        'use strict';
        let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
        alert(firstName); // Юлий
        alert(lastName);  // Цезарь
        alert(rest);      // Император,Рима (массив из 2х элементов)    

  • Значения по умолчанию
    
    ▪ Undefined по умолчанию
      - Если значений в массиве меньше, чем переменных, ошибки не будут.
      - Лишние переменные просто будут наполнены значениями undefined.
      - Пример:

          'use strict';
          let [firstName, lastName] = [];
          alert(firstName); // undefined    

    ▪ Самому задавать значения по умолчанию
      - Но вместо этого можно задавать значения по умолчанию.
      - Для этого после переменной используют =
      - Пример:

          'use strict';
          // значения по умолчанию
          let [firstName="Гость", lastName="Анонимный"] = [];
          alert(firstName); // Гость
          alert(lastName);  // Анонимный

      - В качестве значений по умолчанию можно задавать не только примитивы.
      - Но можно использовать выражения, фукнции, и т.д.
      - Пример, причём вызов defaultLastName будет осуществлён только
        при необходимости, т.е. если значения нет в массиве:

          'use strict';

              function defaultLastName() {
                return Date.now() + '-visitor';
              }
              // lastName получит значение, соответствующее текущей дате:
              let [firstName, lastName=defaultLastName()] = ["Вася"];
              alert(firstName); // Вася
              alert(lastName);  // 1436...-visitor

> Деструктуризация объекта

  • Пример деструктуризации объекта
    - Объект справа, уже существующий, который мы хотим разбить на переменные.
    - Объект слева, список переменных, в которые надо соотв.св-ва записать.
    - Пример:

        'use strict';
        let options = {
          title: "Меню",
          width: 100,
          height: 200
        };
        let {title, width, height} = options;
        alert(title);  // Меню
        alert(width);  // 100
        alert(height); // 200    

  • Как присвоить св-во объекта в переменную с другим именем
    - Например, чтобы св-во options.width шло в переменную w.
    - Пример:

        'use strict';
        let options = {
          title: "Меню",
          width: 100,
          height: 200
        };
        let {width: w, height: h, title} = options;
        alert(title);  // Меню
        alert(w);      // 100
        alert(h);      // 200    

  • Значения по умолчанию
    - Если каких-то св-в в объекте нет, можно указать значения по умолчанию.
    - Для этого нужно использовать знак =
    - Пример:

        'use strict';
        let options = {
          title: "Меню"
        };
        let {width=100, height=200, title} = options;
        alert(title);  // Меню
        alert(width);  // 100
        alert(height); // 200    

  • Отсутствие оператора "spread" при диструктуризации объектов
    - Если в объекте больше значений, чем переменных.
    - То присвоить "остаток", аналогично массивам, некуда.
    - Но она планируется в будущем стандарте.

  • Проблема с видимостью let-переменных при деструктуризации
    - Чтобы её избежать, надо использовать скобки.
    - Пример:

        let a, b;
        ({a, b} = {a:5, b:6}); // внутри выражения это уже не блок    

> Вложенные диструктуризации

  • В чём суть вложенных деструктуризаций
    - Например, массив/объект содержит другие массивы/объекты.
    - И мы ходим их тоже деструктуризировать - не проблема.
    - Деструктуризации можно как угодно сочетать, вкладывать друг в друга.

  • Пример вложенных деструктуризаций

      'use strict';

      let options = {
        size: {
          width: 100,
          height: 200
        },
        items: ["Пончик", "Пирожное"]
      }

      let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

      // Меню 100 200 Пончик Пирожное
      alert(title);  // Меню
      alert(width);  // 100
      alert(height); // 200
      alert(item1);  // Пончик
      alert(item2);  // Пирожное  


А4. Функции

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Параметры по умолчанию

    ▪ Пример параметров по умолчанию
    ▪ Параметры по умолчанию м.б. не только значениями, но и выражениями

  # Оператор spread вместо arguments

    ▪ Оператор ... для получения массива аргументов
    ▪ Использование ... при вызове функции для передачи параметров

  # Деструктуризация в параметрах

    ▪ Деструктуризация при передачи объекта в функцию
    ▪ Более сложный пример деструктуризации
    ▪ Параметры по умолчанию, чтобы можно было вызвать фукнцию без аргументов

  # Имя функции в св-ве name

    ▪ В св-ве name фунции содержится её имя
    ▪ Даже у анонимных функций могут быть имена

  # Объявленная в блоке ф-ия ведёт себя, как let-переменная
  # Стрелочные функции (через =>)

    ▪ Что такое стрелочная функция?
    ▪ Если аргументво несколько, нужно обернуть их в скобки
    ▪ Если нужно задать функцию без аргументов, также используются скобки
    ▪ Когда тело функции достаточно большое, можно обернуть его в фигурные скобки
    ▪ Стрелочные функции очень удобны в качестве коллбэков
    ▪ У стрелочных функций нет своего this
    ▪ Стрелочные функции нельзя запускать с new
    ▪ Стрелочные функции не имеют своего arguments  

--------------------------------------

> Ссылки
  
  # [learn.javascript.ru] Функции
      https://learn.javascript.ru/es-function

> Введение
  - Основные изменения в функциях касаются передачи параметров.
  - Плюс, введена доп.короткая запись через стрелочку =>

> Параметры по умолчанию
  
  • Пример параметров по умолчанию
    - Можно указывать параметры по умолчанию через =
    - Применяется при отсутствующем, или равном undefined аргументе.
    - При любом другом значении кроме undefined, включая null, не применяется.
    - Например:

        function showMenu(title = "Без заголовка", width = 100, height = 200) {
          alert(title + ' ' + width + ' ' + height);
        }
        showMenu("Меню"); // Меню 100 200  

  • Параметры по умолчанию м.б. не только значениями, но и выражениями
    - Соотв.выражение будет выполнено только по мере необходимости.
    - Т.Е. если значение не передано, или равно undefined.
    - Например:

        function sayHi(who = getCurrentUser().toUpperCase()) {
          alert('Привет, ' + who);
        }

        function getCurrentUser() {
          return 'Вася';
        }

        sayHi(); // Привет, ВАСЯ    

> Оператор spread вместо arguments

  • Оператор ... для получения массива аргументов
    - В примере rest является не псевдомассивом, а настоящим (в отличие от arguments).
    - Кроме того, оператор ... должен обязательно быть в конце.
    - Пример:

        function showName(firstName, lastName, ...rest) {
          alert(firstName + ' ' + lastName + ' - ' + rest);
        }

        // выведет: Юлий Цезарь - Император,Рима
        showName("Юлий", "Цезарь", "Император", "Рима");

  • Использование ... при вызове функции для передачи параметров
    - Пример:

        'use strict';
        let numbers = [2, 3, 15];
        // Оператор ... в вызове передаст массив как список аргументов
        // Этот вызов аналогичен Math.max(2, 3, 15)
        let max = Math.max(...numbers);
        alert( max ); // 15    

    - Формально говоря, эти 2 вызова делают одно и то же:

        Math.max(...numbers);
        Math.max.apply(Math, numbers);    

> Деструктуризация в параметрах

  • Деструктуризация при передачи объекта в функцию
    - Определяем объект options.
    - И просто передаём его в функцию.
    - А в аргументах при определении функции тоже размещаем объект.
    - Пример:

      'use strict';

      let options = {
        title: "Меню",
        width: 100,
        height: 200
      };

      function showMenu({title, width, height}) {
        alert(title + ' ' + width + ' ' + height); // Меню 100 200
      }

      showMenu(options);  

  • Более сложный пример деструктуризации
    - С соответствиями и значениями по умолчанию.
    - Пример:

        'use strict';

        let options = {
          title: "Меню"
        };

        function showMenu({title="Заголовок", width:w=100, height:h=200}) {
          alert(title + ' ' + w + ' ' + h);
        }

        // объект options будет разбит на переменные
        showMenu(options); // Меню 100 200    

  • Параметры по умолчанию, чтобы можно было вызвать фукнцию без аргументов

      'use strict';

      function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) {
        alert(title + ' ' + w + ' ' + h);
      }

      showMenu(); // Заголовок 100 200

> Имя функции в св-ве name
  
  • В св-ве name фунции содержится её имя
    - Например:

      'use strict';
      function f() {}               // f.name == "f"
      let g = function g() {};      // g.name == "g"
      alert(f.name + ' ' + g.name)  // f g

  • Даже у анонимных функций могут быть имена
    - Например, при создании анон.функции она записывается в переменную.
    - Тогда она получает имя, равное названию переменной.
    - Пример:

        'use strict';
        // свойство g.name = "g"
        let g = function() {};
        let user = {
          // свойство user.sayHi.name == "sayHi"
          sayHi: function() {}
        };    

> Объявленная в блоке ф-ия ведёт себя, как let-переменная
  - Объявлении функции Function Declaration, сделанное в блоке,
    видно только в этом блоке.
  - Пример:

      'use strict';

      if (true) {
        sayHi(); // работает
        function sayHi() {
          alert("Привет!");
        }
      }
      sayHi(); // ошибка, функции не существует

  - По сути, это тоже самое, что использовать let.
  - Пример:

      if (true) {
        let sayHi = function sayHi() {
          alert("Привет!");
        }
      }
      sayHi(); // ошибка, функции не существует 

> Стрелочные функции (через =>)

  • Что такое стрелочная функция?
    - Появился новый синтаксис для задания функций через стрелку =>
    - Он позволяет подсократить объявление функций.
    - Пример-сравнение обычного и нового синтаксиса:

        let inc = x => x+1;
        let inc = function(x) { return x + 1; };

  • Если аргументво несколько, нужно обернуть их в скобки
    - Пример:

        'use strict';
        let sum = (a,b) => a + b;
        // аналог с function
        // let inc = function(a, b) { return a + b; };
        alert( sum(1, 2) ); // 3

  • Если нужно задать функцию без аргументов, также используются скобки
    - Пример:

        'use strict';
        // вызов getTime() будет возвращать текущее время
        let getTime = () => new Date().getHours() + ':' + new Date().getMinutes();
        alert( getTime() ); // текущее время    

  • Когда тело функции достаточно большое, можно обернуть его в фигурные скобки
    - Однако, если тело обёрнуто в {}, его результат уже не возвращается автоматически.
    - Такая функция должна иметь явный return.

        'use strict';
        let getTime = () => {
          let date = new Date();
          let hours = date.getHours();
          let minutes = date.getMinutes();
          return hourse + ':' + minutes;
        };
        alert( getTime() ); // текущее время

  • Стрелочные функции очень удобны в качестве коллбэков
    - Пример:

        `use strict`;
        let arr = [5, 8, 3];
        let sorted = arr.sort( (a,b) => a - b );
        alert(sorted); // 3, 5, 8

  • У стрелочных функций нет своего this
    - Внутри них this тот же самый, что и снаружи.
    - Это удобно в обработчиках событий и колбэках.
    - Например:

        'use strict';
        let group = {
          title: "Наш курс",
          students: ["Вася", "Петя", "Даша"],

          showList: function() {
            this.students.forEach(
              student => alert(this.title + ': ' + student)
            )
          }
        }
        group.showList();
        // Наш курс: Вася
        // Наш курс: Петя
        // Наш курс: Даша    

  • Стрелочные функции нельзя запускать с new
    - Так как у неё нет своего this.

  • Стрелочные функции не имеют своего arguments
    - А arguments содержит ссылку на оной внешней "обычной" функции.
    - Например, вызов f выведет 1, получив его из аргументов внешней обычной функции:

        'use strict';
        function f() {
          let showArg = () => alert(arguments[0]);
          showArg();
        }
        f(1); // 1    


А5. Строки

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
--------------------------------------

> Ссылки

  # [learn.javascript.ru] Строки
      https://learn.javascript.ru/es-string

> Введение







