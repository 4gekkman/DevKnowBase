////=================================================////
////                                                 ////
////                     Vue.js                      ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Официальные ресурсы //
  //---------------------//

    # Сайт Vue.js (en, ru)
        https://vuejs.org
        https://ru.vuejs.org

    # Руководство v2 (en, ru)
        https://vuejs.org/v2/guide/
        https://ru.vuejs.org/v2/guide/

    # Сообщество и поддержка
        https://gitter.im/vuejs/vue           // Чат в гиттере
        https://forum.vuejs.org/              // Форум

    # Шаблоны
        https://github.com/vuejs-templates

    # Новости
        https://twitter.com/vuejs             // Частые новости
        https://medium.com/the-vue-point      // Блог, редко обновляется

    # Ресурсы
        https://github.com/vuejs/awesome-vue  // Обновляемый список относящихся к vue ресурсов (компоненты, туториалы и т.д.)
        https://vuex.vuejs.org/ru             // Vuex (core plugin)
        https://router.vuejs.org/ru           // Router (core plugin)

    # Песочница с Vue
        https://jsfiddle.net/chrisvfritz/50wL7mdz/

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Vue.js

    А1. План изучения Vue.js
    А2. Установка, совместимость
    А3. Введение в Vue
    А4. Экземпляр Vue
    А5. Синтаксис шаблонов
    А6. Вычисляемые свойства и слежение
    А7. Работа с CSS: классы и стили


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. План изучения Vue.js

--------------------------------------
Подоглавление:

  # Введение
  # Как лучше изучать Vue.js?

--------------------------------------

> Ссылки

  # Где тестировать примеры
      https://jsfiddle.net

> Введение
  - Это короткая глава про то, как лучше изучать Vue.js
  - Данное руководстов актуально на 29.05.2017.

> Как лучше изучать Vue.js?

  1. Официальная документация Vue.js на родном языке
    - Используй последнюю версию документации (на 25.05.2017 - v2).
      https://ru.vuejs.org/v2/guide/
    - Напиши сквозную методичку по всей документации.
    - Так ты получишь полный обзор возможностей фреймворка.

  2. Плагины ядра vuex и router
    - Используй последнюю версию документации (на 25.05.2017 - v2).
    - Напиши сквозные методички по документации vuex и router.
    - Это позволит с самого начала применять их для работы.

  3. Пополнение собственной подборки полезных сторонних vue-компонентов
    - Создай в этой методичке отдельный раздел для этих целей.
    - И постепенно пополняй его инфой о сторонних полезных vue-компонентах.
    - Используй awsome-vue и оцициальный twitter в качестве источников.

А2. Установка, совместимость

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Вопросы совместимости Vue.js

    ▪ ECMAScript >= 5
    ▪ IE >= 9

  # Способы подключения Vue.js к проекту

    ▪ Подключение файла через <script>
    ▪ Подключение ссылки из CDN через <script>
    ▪ Подключение через NPM

  # Официальный CLI от VUE
  # Объяснение различных сборок VUE
  # Runtime + Компилятор vs Runtime-only

    ▪ Когда нужен компилятор
    ▪ Для однофайловых компонентов *.vue компилятор не нужен
    ▪ Псевдоним в сборщике при использовании полных сборок

  # Режим разработки vs режим production

    ▪ UMD-сборки
    ▪ CommonJS и ES Module
    ▪ Переменная среды process.env.NODE_ENV

--------------------------------------

> Ссылки
  
  # [Официальноу руководство] Установка
      https://ru.vuejs.org/v2/guide/installation.html

> Введение
  - Рассмотрены вопросы установки, совместимости, использования Vue.js.

> Вопросы совместимости Vue.js

  • ECMAScript >= 5
    - Vue.js должен работать с браузерами, поддерживающими ES >= 5

  • IE >= 9
    - Vue.js не работает с IE <= 8, т.к. там нельзя эмулировать ES >= 5.

> Способы подключения Vue.js к проекту

  • Подключение файла через <script>
    - Скачать файл с Vue.js и подключить.
    - На данный момент (30.05.2017) есть 2 версии:

      ▪ Для разработчиков   | С предупреждениями для удобства разработки и отладки
      ▪ Для production      | Без предупреждений, ~30кб.

  • Подключение ссылки из CDN через <script>
    - Рекомендуемый CDN: https://unpkg.com/vue

  • Подключение через NPM
    - Автор рекомендует NPM для крупных Vue-приложений.
    - Этот вариант хорошо работает с инструментами сборке,
      такими как Webpack и Browserify.
    - В Vue также есть совместимые с ними инструменты
      для использования однофайловых компонентов.

> Официальный CLI от VUE
  - У VUE есть официальный интерпретатор командной строке (CLI).
  - Это позволяет быстро создавать каркас одностраничных приложений.
  - Предлагаемые шаблоны содержат всё необходимое для фронтенд-разработки.
  - Всего за несколько минут вы получите конфигурацию с hot-reload,
    линтингом кода при сохранении и настроенной конфигурации
    production-сборки.

> Объяснение различных сборок VUE
  
  ▪ Схема

                                UMD                 CommonJS                ES Module
    ----------------------------------------------------------------------------------------------
    Полная                      vue.js              vue.common.js           vue.esm.js
    Runtime-only                vue.runtime.js      vue.runtime.common.js   vue.runtime.esm.js
    Полная (production)         vue.min.js          -
    Runtime-only (production)   vue.runtime.min.js  -

  ▪ Терминология
    - Полная      | Сборка, которая содержит и компилятор, и runtime.
    - Компилятор  | Код, который отвечает за компиляцию строковых
                    шаблонов в JavaScript render-функции.
    - Runtime     | Код, который отвечает за создание экземпляров Vue,
                    рендеринг и изменение виртуального DOM, и т.д. Обобщённо, этой
                    всё, за исключением компилятора.
    - UMD         | UMD-сборки можно использовать сразу в браузере,
                    подключая тегом <script>. Файлом по умолчанию в Unpkg CDN из
                    https://unpkg.com/vue будет Runtime + Компилятор UMD-сборка (vue.js).
    - CommonJS    | CommonJS-сборки предназначены для использования вместе со старыми
                    инструментами сборки, такими как Browserify или Webpack 1. Файлом
                    по умолчанию для них (pkg.main) будет Runtime-only CommonJS сборка
                    (vue.runtime.common.js).
    - ES Module   | ES module сборки предназначены для использования с современными
                    инструментами сборки, такими как Webpack 2 или Rollup. Файлом по умолчанию
                    для них (pgk.module) будет Runtime-only ES Module сборка
                    (vue.runtime.esm.js).

  ▪ Runtime + Компилятор vs Runtime-only
    
    ▪ Когда нужен компилятор
      - Компилятор нужен, если надо компилировать шаблоны на лету.
      - Например:

          // это требует компилятора
          new Vue({
            template: `<div>{{ hi }}</div>`
          })

          // это нет
          new Vue({
            render (h) {
              return h('div', this.hi)
            }
          })    

    ▪ Для однофайловых компонентов *.vue компилятор не нужен
      - Vue-loader и vuefiy компилируют шаблоны внутри *.vue на этапе сборки.
      - Так что, с файлми *.vue можно использовать runtime-only сборки.

    ▪ Псевдоним в сборщике при использовании полных сборок
      - Runtime-only сборки примерно на 30% легче, в сравнении с полными.
      - Поэтому, есть смысл использовать их, когда это возможно.
      - А для использования полных сборок надо настроить псевдоним в сборщике:

        ▪ Webpack
          module.exports = {
            // ...
            resolve: {
              alias: {
                'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' для webpack 1
              }
            }
          }

        ▪ Rollup
          const alias = require('rollup-plugin-alias')
          rollup({
            // ...
            plugins: [
              alias({
                'vue': 'vue/dist/vue.esm.js'
              })
            ]
          })

        ▪ Browserify
          - Добавьте в package.json вашего проекта:
            {
              // ...
              "browser": {
                "vue": "vue/dist/vue.common.js"
              }
            }

> Режим разработки vs режим production

  • UMD-сборки
    - Тут есть min и не-min файлы.
    - min для продакшн, не-min для разработки.

  • CommonJS и ES Module
    - Тут не минифицированный код.
    - Ведь эти сборки предназначены для инструментов сборки.
    - Хочешь минифицировать - легко это сделаешь через оные.
    
  • Переменная среды process.env.NODE_ENV
    - Также эти сборки палят переменную среды: process.env.NODE_ENV.
    - В каждой системе сборки можно использовать соотв.плагин:

      ▪ Webpack

          var webpack = require('webpack')
          module.exports = {
            // ...
            plugins: [
              // ...
              new webpack.DefinePlugin({
                'process.env': {
                  NODE_ENV: JSON.stringify('production')
                }
              })
            ]
          }

      ▪ Rollup

          const replace = require('rollup-plugin-replace')
          rollup({
            // ...
            plugins: [
              replace({
                'process.env.NODE_ENV': JSON.stringify('production')
              })
            ]
          }).then(...)

      ▪ Browserify

          NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js

А3. Введение в Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое Vue.js?
    ▪ Описание Vue
    ▪ Hello World на Vue

  # Немного истории
    ▪ Vue 1 (2013 - 2016)
    ▪ Vue 2 (2016 - ...)

  # Декларативный рендеринг и реактивный биндинг
    ▪ Что такое декларативный рендеринг
    ▪ Что такое реактивный биндинг
    ▪ Пример декларативного рендеринга и реактивного биндинга
    ▪ Пример биндинга атрибута title

  # Условия и циклы, transition-эффекты
    ▪ Про условия и циклы в Vue
    ▪ Управление присутствием эл-та в DOM с помощью v-if
    ▪ Пример использования директивы v-for
    ▪ Пример использования v-if с transition-эффектом

  # Работа с событиями, 2-сторонний биндинг эл-в формы
    ▪ Про биндинг событий в Vue
    ▪ Биндинг событий с обработчиками с помощью директивы v-on
    ▪ Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

  # Разбиение приложения на компоненты
    ▪ Ключевые понятия концепции компонентов
      - Vue-компонент
      - Vue не реализует паттерн MVVP в полной мере
      - Слабая связанность и автономность
      - Повторное использование
      - Репозитории сторонних компонентов
      - Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Пример компактного шаблона приложения, использующего компоненты
    ▪ Создать простейший vue-компонент
    ▪ Использования входных параметров vue-компонента

--------------------------------------

> Ссылки

  # [Официальноу руководство] Введение
      https://ru.vuejs.org/v2/guide/

  # Однофайловые компоненты
      https://ru.vuejs.org/v2/guide/single-file-components.html

  # База готовых компонентов и библиотеками
      https://github.com/vuejs/awesome-vue#components--libraries

  # Чем Vue отличается от других фронтенд библиотек/фреймфорков
      https://ru.vuejs.org/v2/guide/comparison.html
  
  # Паттерн MVVM
      https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel
  
> Введение
  - Это обзорное введение в Vue.js.
  - Это не справочник, а обзорная экскурсия.
  - Стараемся зацепить все наиболее важные темы, но поверхностно.

> Что такое Vue.js?
  
  • Описание Vue
    - Vue произносится, как vju:, примерно как view.
    - Это прогрессивный фреймворк для создания пользовательских инетрфейсов.
    - В отличие от фреймворков-монолитов, vue годится для постепенного внедрения.
      Его ядро в 1-ю очередь решает задачи уровня представления (view).
      Что упрощает интеграцию с другими библиотеками и существующими проектами.
    - Vue полностью подходит для создания одностраничных приложений
      (SPA, Single-Page Applications). Помочь в этом может:

        ▪ Применение однофайловых компонентов (см.ссылки).
        ▪ Базы готовых компонентов и библиотек (см.ссылки).

  • Hello World на Vue

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>
      
      // 2. Подготовить шаблон
      <div id="app">
        <p>{{ message }}</p>
      </div> 

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue.js!'
        }
      })

> Немного истории

  • Vue 1 (2013 - 2016)
    - Создателем Vue.js является Evan You, бывший сотрудник Google и Meteor Dev Group.
    - Начал он разрабатывать фреймворк в 2013-м, а в феврале 2014-го состоялся первый публичный релиз.
    - Vue широко используется среди китайских компаний, например: Alibaba, Baidu, Xiaomi, Sina Weibo и др. 
    - Он входит в ядро Laravel и PageKit.
    - Недавно свободная система управления репозиториями GitLab тоже перешла на Vue.js. 
    
  • Vue 2 (2016 - ...)
    - В конце сентября 2016-го вышел в релиз Vue.js 2.0
    - Упор был сделан на производительность.
    - Теперь используется виртуальный DOM.
    - Поддерживается серверный рендеринг, возможность использовать JSX и т.д.
    - Сейчас фреймворк поддерживается только сообществом
      (хотя ходят слухи, что > 50% финансируется alibaba'ой).

> Декларативный рендеринг и реактивный биндинг

  • Что такое декларативный рендеринг
    - Позволяет связывать модель с шаблоном прямо в шаблоне.
    - По тому же принципу работает, например, Knockoutjs.
    - В качестве примера см. Hello World на Vue выше.

  • Что такое реактивный биндинг
    - Когда при изменении значения в модели меняется и значение в шаблоне.
    - По умолчанию применяется 1-направленный биндинг: модель -> шаблон.
    - Но можно использоватьи 2-направленный, с помощью v-model (например, в формах).

  • Пример декларативного рендеринга и реактивного биндинга
    - Этот пример демонстрирует декларативный рендеринг и 
      1-направленный декларативный биндинг.
    - В консоли браузера можно написать:

        app.message = 'test'

    - И новое значение сразу будет отрисовано.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app">
        {{ message }}
      </div>

      // 3. Создать экземпляр Vue
      var app = new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue!'
        }
      })      

  • Пример биндинга атрибута title
    - В примере мы применяем директиву v-bind.
    - И однонаправленно биндим атрибут title со св-вом message в модели.
    - Теперь, при изменении message, будет меняться и title.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-2">
        <span v-bind:title="message">
          Подержи курсор надо мной пару секунд,
          чтобы увидеть динамически связанное значение title!
        </span>
      </div>

      // 3. Создать экземпляр Vue
      var app2 = new Vue({
        el: '#app-2',
        data: {
          message: 'Вот когда вы загрузили эту страницу: ' + new Date()
        }
      })      

> Условия и циклы, transition-эффекты

  • Про условия и циклы в Vue
    - Они работают примерно аналогично knockoutjs`овским.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Управление присутствием эл-та в DOM с помощью v-if
    - Можно менять значение app3.seen на true/false.
    - И тем самым управлять присутствием шаблона в DOM.
    - Директива v-if аналогична директиве if из knockoutjs.
    - При false шаблон просто изчезает из DOM (не путать с display:none).
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-3">
        <p v-if="seen">Сейчас меня видно</p>
      </div>      

      // 3. Создать экземпляр Vue
      var app3 = new Vue({
        el: '#app-3',
        data: {
          seen: true
        }
      })      

  • Пример использования директивы v-for
    - Можно на лету добавить новый элемент в массив todos.
    - Это можно сделать, например, в консоли: app4.todos.push({ text: 'Новый элемент' })
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-4">
        <ol>
          <li v-for="todo in todos">
            {{ todo.text }}
          </li>
        </ol>
      </div>

      // 3. Создать экземпляр Vue
      var app4 = new Vue({
        el: '#app-4',
        data: {
          todos: [
            { text: 'Посадить дерево' },
            { text: 'Построить дом' },
            { text: 'Вырастить сына' }
          ]
        }
      })

  • Пример использования v-if с transition-эффектом
    - Vue имеет встроенную систему анимации, которая применяет transition-эффекты.
    - В этом примере мы меняем значение v-if нажатием кнопки.
    - Благодаря transition-эффекту эл-т плавно появляется/исчезает.
    - Можно также назначать JS-хуки, которые будут вызваны в нужные моменты времени.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="demo">
        <button v-on:click="show = !show">
          Переключить
        </button>
        <transition name="fade">
          <p v-if="show">hello</p>
        </transition>
      </div>    

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#demo',
        data: {
          show: true
        }
      }) 

      // 4. Подготовить CSS
      .fade-enter-active, .fade-leave-active {
        transition: opacity .5s
      }
      .fade-enter, .fade-leave-to /* .fade-leave-active для <2.1.8 */ {
        opacity: 0
      }

> Работа с событиями, 2-сторонний биндинг эл-в формы

  • Про биндинг событий в Vue
    - С точки зрения использования, всё работает, как knockoutjs.
    - Можно назначать обработчики событий для элементов.
    - Можно делать 2-сторонний биндинг с элементами формы типа input, textarea и т.д.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Биндинг событий с обработчиками с помощью директивы v-on
    - С помощью v-on можно связать событие на элементе с обработчиком.
    - Например, свяжем событие click на эл-те с функцией-обработчиком:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-5">
        <p>{{ message }}</p>
        <button v-on:click="reverseMessage">Обратить порядок букв в сообщении</button>
      </div>

      // 3. Создать экземпляр Vue     
      var app5 = new Vue({
        el: '#app-5',
        data: {
          message: 'Hello Vue.js!'
        },
        methods: {
          reverseMessage: function () {
            this.message = this.message.split('').reverse().join('')
          }
        }
      })

  • Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-6">
        <p>{{ message }}</p>
        <input v-model="message">
      </div>

      // 3. Создать экземпляр Vue
      var app6 = new Vue({
        el: '#app-6',
        data: {
          message: 'Hello Vue!'
        }
      })

> Разбиение приложения на компоненты

  • Ключевые понятия концепции компонентов

    ▪ Vue-компонент
      - Концепция Vue изначально предполагает использование компонентов.
      - В Vue, компонент — это, по сути, экземпляр Vue с предустановленными опциями. 
      - Эта абстракция позволяет собирать большие приложения из малых кусочков.
      - Почти любой интерфейс может быть представлен, как дерево компонентов.

    ▪ Vue не реализует паттерн MVVP в полной мере
      - Речь идёт о паттерне Model–view–viewmodel.

    ▪ Слабая связанность и автономность
      - Связь между компонентами должна отсутствовать.
      - Каждый компонент должн быть в MAX степени автономен.

    ▪ Повторное использование
      - Компоненты представляют собой пригодные к повторному использованию объекты.
      - Ведь они слабо связаны друг с другом, и м.б. перенесены в другой проект/место проекта.

    ▪ Репозитории сторонних компонентов
      - Благодаря компонентной концепции могут быть созданы репозитории компонентов.
      - Теперь не надо писать всё самому, можно использовать сторонние компоненты.

    ▪ Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Разработкой компонентной системы намного легче управлять.
      - Можно разбить её на дерево мелких автономных компонентов.
      - Для разработки каждого компонента написать чёткое тех.задание.
      - И раздать подряды на разработку большому кол-ву разработчиков.
      - Это позволит кардинально увеличить скорость разработки фронтенда проекта.
      - Относиться к каждому компоненту, можно как к чёрному ящику.
      - У которого есть входы и выходы (но код инспектировать всё равно нужно).

    ▪ Пример компактного шаблона приложения, использующего компоненты
      - В крупных приложениях разделение на компоненты очень важно.
      - Это становится обязательным условием для сохранения управляемости процесса разработки.
      - Вот, как бы мог выглядеть шаблон приложения, использующего компоненты:

          <div id="app">
            <app-nav></app-nav>
            <app-view>
              <app-sidebar></app-sidebar>
              <app-content></app-content>
            </app-view>
          </div>

      - Как видно, на верхнем уровне находится блок с id="app".
      - А далее, считай, что просто идёт дерево компонентов.

  • Создать простейший vue-компонент
    - Это чисто для демонстрации концепции.
    - Код:

      // Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        template: '<li>Это todo</li>'
      })

      // Использовать компонент todo-item в шаблоне другого компонента
      <ul>
        <!-- Создаём экземпляр компонента todo-item -->
        <todo-item></todo-item>
      </ul>      

  • Использования входных параметров vue-компонента
    - Это расширение предыдущего примера.
    - Здесь мы добавляем компоненту todo-item принимать входящий параметр.
    - Для этого в определении компонента мы используем св-во props.
    - В нём перечисляются параметры, которые может принимать компонент.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
      })

      // 3. Подготовить шаблон
      // - В этом шаблоне мы и применяем наш компонент todo-item.
      // - Применяем директивы v-for прямо на компонент, которая пробегает
      //   массив groceryList из модели приложения.
      // - Далее с помощью v-bind связываем item массива с параметром todo компонента.
      // - И также с помощью v-bind связываем индекс с item.id.
      <div id="app-7">
        <ol>
          <!--
            Теперь мы можем передать каждому компоненту todo объект
            с информацией о задаче, который будет динамически меняться.
            Мы также определяем для каждого компонента "key",
            значение которого будет объяснено далее в руководстве.
          -->
          <todo-item
            v-for="item in groceryList"
            v-bind:todo="item"
            v-bind:key="item.id">
          </todo-item>
        </ol>
      </div>

      // 4. Создать экземпляр Vue
      var app7 = new Vue({
        el: '#app-7',
        data: {
          groceryList: [
            { id: 0, text: 'Овощи' },
            { id: 1, text: 'Сыр' },
            { id: 2, text: 'Что там ещё люди едят?' }
          ]
        }
      })      


А4. Экземпляр Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Конструктор Vue
    ▪ Модель приложения / корневой экземпляр Vue
    ▪ Опции по умолчанию для компонента / расширение конструктора Vue
    ▪ Экземпляры компонентов рекомендуется создавать декларативно

  # Свойства и методы
    ▪ Vue-экземпляр проксирует все св-ва из объекта data
      - Что значит проксирует?
      - Что значит проксирует ссылки?
    ▪ Все проксируемые свойства из data являются реактивными
    ▪ Vue-экземпляр содержив встроенные св-ва/методы, начинающиеся с $
    ▪ Не используй стрелочные функции в св-вах экземпляра и колбэках!

  # Хуки жизненного цикла экземпляра

    ▪ Последовательность шагов при инициализации экземпляра
    ▪ Хуки жизненного цикла
    ▪ Хуки вызываются с контекстной переменной this
    ▪ Контроллеров в Vue не существует

  # Диаграмма жизненного цикла vue-экземпляра

--------------------------------------

> Ссылки

  # [Официальноу руководство] Экземпляр Vue
      https://ru.vuejs.org/v2/guide/instance.html

> Введение
  - Vue не реализует полностью паттерн MVVM, но его архитектура вдохновлена им.
  - Поэтому, традиционно, переменная с экземпляром Vue называется vm (от ViewModel).
  - Грубо говоря, экземпляр Vue - это объект с Vue-моделью.
  - В knockoutjs я привык называть это просто "модель".
  - В этой главе речь пойдёт об общих свойствах моделей в Vue.
  - Таких, как: конструктор, св-ва и методы, хуки и жизненный цикл.

> Конструктор Vue

  • Модель приложения / корневой экземпляр Vue
    - Корневой экземпляр обычно создаётся императивно.
    - При создании в него передаётся объект с опциями.
    - В нём - данные, шаблон, DOM-элемент, методы, хуки жизненного цикла и т.д.
    - Например:

        var vm = new Vue({
          // опции
        })

  • Опции по умолчанию для компонента / расширение конструктора Vue
    - Допустим, у нас есть какой-то компонент.
    - И нам его надо много раз создавать императивно в приложении.
    - И напрягает, что каждый раз надо передавать объект с опциями.
    - Чтобы этого не делать, можно задать объект с опциями по умолчанию.
    - Для этого надо расширить конструктор vue.
    - Например:

        // Задать опции по умолчанию для компонента, расширив его конструктор
        var MyComponent = Vue.extend({
          // опции компонента
        })    

        // Теперь все экземпляры этого компонента используют опции по умолчанию
        var myComponentInstance = new MyComponent()

  • Экземпляры компонентов рекомендуется создавать декларативно
    - Выше продемонстрирован пример императивного создания экземпляра компонента.
    - Однако, автор рекомендует создавать их декларативно.
    - Т.Е., как пользовательские HTML-элементы в шаблонах.
    - Подробнее об этом см.главу про Vue-компоненты.
    - А пока запомни: все Vue-компоненты являются расширенными Vue-экземплярами.

> Свойства и методы

  • Vue-экземпляр проксирует ссылки всех св-в из объекта data
    
    ▪ Что значит проксирует?
      - То есть, они становятся напрямую свойствами модели.
      - Вместо vm.data.prop надо писать просто vm.prop.
      - Пояснение на примере:

          // Подготовим data и создаим vue-экземпляр
          var data = { a: 1 }
          var vm = new Vue({
            data: data
          })

          // Удостоверимся в написанном выше
          vm.a === data.a   // true

    ▪ Что значит проксирует ссылки?
      - Значит, что vm.a и data.a содержат одну и ту же ссылку.
      - Т.Е. меняя значение в модели, мы меняем его в исходном объекте data.
      - Примеры для иллюстрации этого:

          // установка свойства также влияет на оригинальные данные
          vm.a = 2
          data.a      // 2

          // ... и наоборот
          data.a = 3
          vm.a        // 3  

  • Все проксируемые свойства из data являются реактивными
    - Т.Е. при изменении их значений автоматом меняется и представление.
    - Однако, реактивными они становятся при создании экземпляра.
    - Добавление новых св-в в data после создания экземпляра не сделает их реактивными.
    - Хотя, есть возможность добавлять реактивные св-ва во вложенные объекты.
    - В общем, подробнее о рекативности читай в главе про реактивность.

  • Vue-экземпляр содержив встроенные св-ва/методы, начинающиеся с $
    - С $ они начинаются, чтобы отличаться от пользовательских.
    - Например, ссылка на объект data лежит в vm.$data,
      а ссылка на DOM-элемент лежит в $el,
      а коллбэк на изменение св-ва можно задать методом $watch.
    - Полный список встроенных св-в и методов см. в главе-справочнике API.
    - Проиллюстрируем на примере:

        // Подготовим data и создаим vue-экземпляр
        var data = { a: 1 }
        var vm = new Vue({
          el: '#example',
          data: data
        })

        // Собственно, иллюстрация
        vm.$data === data                             // true
        vm.$el === document.getElementById('example') // true

        // $watch — это метод экземпляра
        vm.$watch('a', function (newVal, oldVal) {
          // этот коллбэк будет вызван, когда изменится `vm.a`
        })

  • Не используй стрелочные функции в св-вах экземпляра и колбэках!
    - Например: vm.$watch('a', newVal => this.myMethod())
    - Потому что СФ связываются с родительским контекстом (this).
    - Соответственно, this внутри не будет указывать на vue-экземпляр.
    - И, например, this.myMethod будет undefined.

> Хуки жизненного цикла экземпляра

  • Последовательность шагов при инициализации экземпляра
    - Каждый vue-экземпляр проходит при создании некий процесс.
    - Процесс представляет собой последовательность задач инициализации.
    - Например:

      ▪ Настройка наблюдения за данными.
      ▪ Компиляция шаблона.
      ▪ Монтаж экземпляра в DOM.
      ▪ Обновление DOM при изменении данных.
      ▪ .. и прочие ..

  • Хуки жизненного цикла
    - Всё имеет своё начало, и свой конец. И vue-экземпляр тоже.
    - По мере путешествия экземпляра по жизненному циклу, 
      он на каждом шагу генерирует события.
    - Например: created, mounted, updated, destroyed, и т.д.
    - Соответственно, можно назначать обработчики для этих хуков.
    - Например, назначим обработчик, который вызывается после создания экземпляра:

        var vm = new Vue({
          data: {
            a: 1
          },
          created: function () {
            // `this` указывает на экземпляр vm
            console.log('Значение a: ' + this.a)
          }
        })
        // -> "Значение a: 1"

  • Хуки вызываются с контекстной переменной this
    - Она содержит ссылку на вызывающий vue-экземпляр.

  • Контроллеров в Vue не существует
    - Впрочем, как и в knockoutjs.
    - Наверное, они есть в angular? [примечание автора методички].
    - В общем, всё польз.поведение компонента должно быть в этих хуках.

> Диаграмма жизненного цикла vue-экземпляра

              
                       new Vue()
                          |
   [событие] beforeCreate |
                          |
                     Observe Data 
                          |
        [событие] created |
                          | 
                      Init Events
                          |                  
                          |                  
                          |                  
                  Есть ли опция "el"? -------
                          |                 |
                       Да |                 | - Vue ждёт, пока vm.$mount(el) будет вызвана вручную
                          |                 |
                Есть ли опция "template"?----
                          |
                          |
             ---------------------------
          Да |                         | Нет
             |                         | 
      Скомпилировать             Взять outerHTML
      этот template              в качестве шаблона,
             |                   и скомпилировать его
             |                         |
             ---------------------------
                          |
    [событие] beforeMount |
                          |
                   Создать vm.$el и
                   заменить содержимое
                   el скомпилированным
                          | 
        [событие] mounted | 
                          |   При изменении
                         /|\  данных
                        /   \   /------>------ 
                       / См- \ /             | - [событие] beforeUpdate            
                      / онти- \              |
                     / рованн- \        Ререндеринг
                    / ое состо- \       виртуального DOM
                    \ яние Vue- /            |
                     \ компон- /             | - [событие] updated
                      \ ента  /--------<------
                       \     /
                        \   /
                         \|/
                          |
                          |
                Если вызван встроенный
                метод vm.$destroy()
                          |
  [событие] beforeDestroy |
                          |
                  Завершение работы
                  вотчеров, дочерних
                  компонентов и 
                  обработчиков событий
                          | 
                          | 
                         /|\ 
                        /   \ 
                       / Ун- \ 
                      / ичто- \  
                     / женный  \ 
                    / Компонент \
                    \           /
                     \         / 
                      \       /
                       \     /
                        \   /
                         \|/ 
                          | 
      [событие] destroyed | 
                          |
                        -----
 
 
А5. Синтаксис шаблонов
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
    ▪ Модель с DOM в Vue связывается через HTML
    ▪ Шаблоны Vue являются валидным HTML-кодом
    ▪ Использование виртуального DOM
    ▪ Можно использовать свою render-функцию
 
  # Интерполяции (компиляция всяких vue-подстановок из шаблона в HTML)
    ▪ Подстановка через {{ }}, или @{{ }} для Blade
      - Связать св-во с DOM
      - v-once: связать св-во с DOM, но не обновлять DOM при его изменении
      - Использование js-выражения внутри {{ }}
      - Содержимое {{ }} подставляется, как текст, а не HTML
    
    ▪ Подстановка сырого HTML
      - Директива v-html
      - Нельзя использовать v-html для вложения шаблонов друг в друга
      - Подставляй только доверенный HTML
    
    ▪ Подстановка атрибутов: v-bind
 
  # Директивы
    ▪ В общем про директивы
    ▪ Атрибуты директив
    ▪ Модификаторы директив
    ▪ Фильтры в интерполяциях {{ }} и директиве v-bind
      - Фильтры форматирую текст
      - Фильтры можно определить в объекте filters в корне модели
      - Фильтры можно чейнить
      - Фильтры могут принимать параметры    
    ▪ Сокращения директив

--------------------------------------

> Ссылки

  # [Официальноу руководство] Синтаксис шаблонов
      https://ru.vuejs.org/v2/guide/syntax.html

> Введение
  
  • Модель с DOM в Vue связывается через HTML
    - Аналогичный подход используется и в knockout.

  • Шаблоны Vue являются валидным HTML-кодом
    - Его могут распарсить все HTML-парсеры и браузеры.
 
  • Использование виртуального DOM
    - Vue компилирует шаблоны в функции рендера виртуального DOM.
    - При изменении состояния приложения система реактивности
      определяет MIN набор компонентов для повторного рендеринга.
    - А виртуальный DOM определяет минимальные изменения уже внутри них.
 
  • Можно использовать свою render-функцию
    - То есть, сгенерировать HTML с помощью низкоуровневого JS.
    - Для этого нужно добавить в vue-компонент свойство render.
    - А в него положить функцию, которая должна вернуть созданный элемент.
    - Обычно вместо этого применяются vue-шаблоны.
    - Но могут быть случаи, когда удобнее использовать render-функцию.
    - Подробнее о render-функциях читай в соответствующей главе.

> Интерполяции (компиляция всяких vue-подстановок из шаблона в HTML)

  • Подстановка через {{ }}, или @{{ }} для Blade
 
    ▪ Связать св-во с DOM
      - msg будет заменено на значение св-ва msg из модели.
      - Имеется в виду модель vue-компонента, в чьём шаблоне эта интерполяция.
      - DOM будет обновляться при изменении значения св-ва в модели.

        <span>Сообщение: {{ msg }}</span>     | - в обычном случае
        <span>Сообщение: @{{ msg }}</span>    | - в Blade (Laravel)

    ▪ v-once: связать св-во с DOM, но не обновлять DOM при его изменении
      - Допустим, надо подставить значение лишь при загрузке.
      - А при изменении значения в модели, DOM не менять.
      - Для этого и можно применить директиву v-once:

          <span v-once>Это сообщение никогда не изменится: {{ msg }}</span>

    ▪ Использование js-выражения внутри {{ }}
      - Внутри {{ }} можно использовать и js-выражение.
      - Оно будет вычислено, и будет возвращён его результат.
      - Вычисление будет производиться в контексте модели vue-экземпляра.
      - Выражения имеют доступ лишь к ограниченному списку глобальных объектов,
        таких как Math и Date. Поэтому, получить доступ к пользовательским
        глобальным объектам не получится.
      - Примеры:

          {{ number + 1 }}
          {{ ok ? 'YES' : 'NO' }}
          {{ message.split('').reverse().join('') }}
          <div v-bind:id="'list-' + id"></div>

    ▪ Содержимое {{ }} подставляется, как текст, а не HTML
      - А для вывода HTML используй директиву v-html.

  • Подстановка сырого HTML
    
    ▪ Директива v-html
      - Производится с помощью директивы v-html.
      - Например:

          <div v-html="rawHtml"></div>

    ▪ Нельзя использовать v-html для вложения шаблонов друг в друга
      - Так как движок шаблонов Vue не основывается на строках.
      - Вместо этого надо использовать vue-компоненты.

    ▪ Подставляй только доверенный HTML
      - Не подставляй контент, сгенерированный пользователем.
      - Это может привести к XSS-уязвимостям.

  • Подстановка атрибутов: v-bind
    - Синтаксис {{ }} не работает с атрибутами.
    - Для подстановки последних используй директиву v-bind
    - Например, свяжем атрибут id со св-вом модели dynamicId: 

        <div v-bind:id="dynamicId"></div>

    - При этом dynamicId также может быть и булевым значением.
    - В случае, если оно равно true, то будет атрибут без значения.
    - А если false, то атрибут будет удалён полностью.
    - Например:

        <button v-bind:disabled="isOn">Кнопка</button>
        <button disabled>Кнопка</button>  | если isOn == true
        <button>Кнопка</button>           | если isOn == false

> Директивы

  • В общем про директивы
    - Директивы, это специальный атрибуты с префиксом v-
    - Принцип работу у них похож на их аналоги data-bind из knockoutjs.
    - В качестве значения v- директивы принимают 1-но js-выражение (за исключением v-for).
    - Это выражение выполняется в контексте модели соответствующего vue-экземпляра.
    - Директива реактивно применяет к DOM изменения при обновлении этого выражения.
    - Например, эта директива удалит/вставит элемент в DOM в зависимости
      от значения св-ва seen в модели vue-компонента:

        <p v-if="seen">Сейчас меня видно</p>

  • Атрибуты директив
    - Некоторые директивы могут принимать аргумент через двоеточие.
    - Примеры: 

        <a v-bind:href="url"></a>     | связать атрибут href со св-вом url модели
        <a v-on:click="doSomething">  | назначить обработчик doSomething события click для элемента

  • Модификаторы директив
    - Это особые постфиксы, добавляемые после точки.
    - Они приказывают провести биндинг особым образом.
    - Пример:

        <form v-on:submit.prevent="onSubmit"></form>  | предотвратить действия браузера по умолчанию при обработке события

  • Фильтры в интерполяциях {{ }} и директиве v-bind
    
    ▪ Фильтры форматирую текст
      - Речь идёт о форматировании текста.
      - Фильтр добавляется в конце js-выражения, и отделяется вертикальной чертой.
      - Например:

          {{ message | capitalize }}
          <div v-bind:id="rawId | formatId"></div>

    ▪ Фильтры можно определить в объекте filters в корне модели
      - Надо добавлять в этот объект св-ва со значениями-функциями.
      - 1-ым аргументом такая функция получит значение js-выражения.
      - Например, определим фильтр capitalize:

          new Vue({
            // ...
            filters: {
              capitalize: function (value) {
                if (!value) return ''
                value = value.toString()
                return value.charAt(0).toUpperCase() + value.slice(1)
              }
            }
          })

    ▪ Фильтры можно чейнить
      - Например:

          {{ message | filterA | filterB }}

    ▪ Фильтры могут принимать параметры
      - Они пойдут со 2-го аргумента и далее (т.к. в 1-й передаётся значение js-выражения).
      - Например:

          {{ message | filterA('arg1', arg2) }}      

  • Сокращения директив

    ▪ Зачем нужны сокращения
      - Для тех, кому лень написать несколько лишних символов.
      - В Vue есть сокращения для директив v-bind и v-on.
      - Сокращение производится через : и @ соотственно.
      - Символы : и @ валидны во всех современных браузерах.
      - В итоговой разметке они не появляются.

    ▪ Сокращение для v-bind через :
 
        <a v-bind:href="url"></a>         | полный синтаксис
        <a :href="url"></a>               | сокращение
 
    ▪ Сокращение для v-on через @

        <a v-on:click="doSomething"></a>  | полный синтаксис   
        <a @click="doSomething"></a>      | сокращение
 
 
А6. Вычисляемые свойства и слежение 
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Концепция вычисляемой
  # Отличие Vue-вычисляемых от Knockout-вычисляемых

    ▪ Что было в Knockout с вычисляемой?
    ▪ Две опции: метод или вычисляемая
    ▪ Вычисляемая кэшируется, метод нет

  # Пример вычисляемого свойства
  # Пример использования метода вместо вычисляемой
  # Альтернатива наблюдаемым: слежение за св-ми с помощью watch

    ▪ Суть применения watch
    ▪ Доступ к объекту watch через переменную модели
    ▪ Пример применения watch
      - Решение через наблюдаемую
      - Решение через метод
      - Решение через watch

  # Запись в наблюдаемые: сеттеры

    ▪ Редко когда надо писать в наблюдаемые
    ▪ Как настроить наблюдаемую, чтобы в неё можно было писать

  # Как ограничить частоту выполнения наблюдаемых?

    ▪ Проблемы с производительностью наблюдаемых
    ▪ В Vue вместо наблюдаемой: метод + watch
    ▪ Ограничение частоты выполнения 

--------------------------------------

> Ссылки

  # [Официальноу руководство] Вычисляемые свойства и слежение 
      https://ru.vuejs.org/v2/guide/computed.html

> Введение
  - Вычисляемые в Vue чуток отличаются от оных в Knockout.
  - Но концепция остаётся прежней.
  
> Концепция вычисляемой
  - Как упоминалось в А5, в {{ }} и директивы можно вставлять 1-но js-выражение.
  - И при изменении задействованных в нём св-в модели, оно будет перевычисляться.
  - И соответствующий DOM будет обновлятсья.
  - Но держать в HTML много кода неудобно.
  - Проще добавить в модель вычисляемое св-во, а в HTML уже его вставить.

> Отличие Vue-вычисляемых от Knockout-вычисляемых

  • Что было в Knockout с вычисляемой?
    - В knockout значение вычисляемой не кэшируется.
    - Её можно использовать в шаблоне, она будет реактивна.
    - А вот метод в knockout при подстановке в шаблон реактивен 
      не был, и срабатывал тольк 1 раз при загрузке.

  • Метод в Vue соответствует вычисляемой в Knockout
    - Его значение не кэшируется, как и Knockout-вычисляемой.
    - Его можно использовать в шаблоне, и он реактивен.

  • Vue-вычисляемая, как метод, только значение её кэшируется
    - Оно не меняется при запросах к вычисляемой.
    - А меняется только, когда меняются значения наблюдаемых,
      которые присутствуют в функции этой вычисляемой.
    - Это позволяет улучшить производительность, когда от
      этой вычисляемой зависит много других.

> Пример вычисляемого свойства

  • Описание
    - Определяем обычное свойство message.
    - Определяем вычисляемое св-во reversedMessage.
    - В ф-ии выч-го св-ва возвращаем реверс-значение текущего св-ва message.
    - При изменении message будет меняться и значение вычисляемого св-ва.
    - В шаблоне можно использовать вычисляемое также, как и обычное св-во.
    - Короче говоря, тоже самое, что и в knockoutjs.

  • Шаблон
    <div id="example">
      <p>Изначальное сообщение: "{{ message }}"</p>
      <p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
    </div>  

  • Модель
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Привет'
      },
      computed: {
        // геттер вычисляемого значения
        reversedMessage: function () {
          // `this` указывает на экземпляр vm
          return this.message.split('').reverse().join('')
        }
      }
    })

  • Результат

    Привет
    тевирП

> Пример использования метода вместо вычисляемой

    // 1. Подключить UMD-сборку Vue из CDN
    <script src="https://unpkg.com/vue"></script>

    // 2. Подготовить шаблон
    <div id="example">
      <p>Сообщение задом наперёд: "{{ reverseMessage() }}"</p>
    </div>

    // 3. Определить новый компонент
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Привет'
      },
      methods: {
        reverseMessage: function () {
          return this.message.split('').reverse().join('')
        }
      }
    })

    // 4. Меняем значение св-ва из метода, чтобы проверить, изменится ли DOM (да)
    vm.message = 'Привет1';

> Альтернатива наблюдаемым: слежение за св-ми с помощью watch

  • Суть применения watch
    - В модель можно добавить объект watch.
    - В него добавлять колбэки.
    - Ключами должны служить св-ва из data, за которыми надо следить.
    - Соотв.колбэк будет срабатывать при изменении этого свойства.
    - И, например, менять какое-то 3-е св-во.

  • Доступ к объекту watch через переменную модели
    - vm.$watch

  • Пример применения watch
    - Например, есть у нас 3 св-ва: name, surname, fullname.
    - Как получать fullname? Один вариант: метод или наблюдаемая.
    - Другой вариант: watch. Следить за name и surname.
    - И вызывать колбэк, меняющий fullname, при изменении последних.
    - Код:

      ▪ Решение через наблюдаемую

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName() }}</div>

        // 3. Определить новый компонент
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          methods: {
            fullName: {
              fullName: function () {
                return firstName + ' ' + lastName
              }
            }
          }
        })

      ▪ Решение через метод

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName }}</div>

        // 3. Определить новый компонент
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          methods: {
            fullName: function () {
              return this.firstName + ' ' + this.lastName
            }
          }
        });     

      ▪ Решение через watch

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName }}</div>

        // 3. Определить новый компонент под названием todo-item
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar',
            fullName: 'Foo Bar'
          },
          watch: {
            firstName: function (val) {
              this.fullName = val + ' ' + this.lastName
            },
            lastName: function (val) {
              this.fullName = this.firstName + ' ' + val
            }
          }
        })      

> Запись в наблюдаемые: сеттеры

  • Редко когда надо писать в наблюдаемые
    - Я использовал Knockout пару лет.
    - Там тоже можно записывать в наблюдаемую, если надо.
    - Но за всё время не было ни 1 случая, когда это понадобилось.
    - Думаю, аналогичная ситуация ждёт и в Vue.
    - Поэтому, по умолчанию в Vue и можно лишь читать из наблюдаемой.
    - Но, при необходимости, можно настроить её и на запись.
   
  • Как настроить наблюдаемую, чтобы в неё можно было писать
    - На примере:

        computed: {
          fullName: {
            // геттер:
            get: function () {
              return this.firstName + ' ' + this.lastName
            },
            // сеттер:
            set: function (newValue) {
              var names = newValue.split(' ')
              this.firstName = names[0]
              this.lastName = names[names.length - 1]
            }
          }
        }

> Как ограничить частоту выполнения наблюдаемых?

  • Проблемы с производительностью наблюдаемых
    - У меня есть большой опыт работы с наблюдаемыми в Knockout.
    - В том числе, с очень большим SPA, в которых десятки наблюдаемых.
    - В том SPA от при изменении наблюдаемых перерисовывался и DOM.
    - А перерисовывание DOM операция достаточно тяжёлая.
    - И если очень-очень часто дёргать наблюдаемую, всё жёстко лагало.
    - Выходом было ограничение частоты выполнения наблюдаемых.
    - В этом разделе описано, как это осуществить в Vue с помощью библиотеки loadash.

  • В Vue вместо наблюдаемой: метод + watch 
    - В Vue с наблюдаемой это провернуть не выйдет.
    - Придётся использовать метод + watch + lodash.

  • Ограничение частоты выполнения 
    - В данном примере выполняется ajax-запрос в ответ
      на ввод текста пользователем в input.
    - Но не выполнять же запрос при каждом нажатии?
    - С помощью метода, watch и lodash мы ограничиваем
      MAX частоту отправки ajax-запроса.
    - Конкретно, используется метод _.debounce из lodash.
    - Он будет срабатывать спустя указанное кол-во ms (500)
      после последего запроса к методу.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>    

      // 2. Подготовить шаблон
      <div id="watch-example">
        <p>
          Задайте вопрос, на который можно ответить "да" или "нет":
          <input v-model="question">
        </p>
        <p>{{ answer }}</p>
      </div>

      // 3. Подключить либы, определить новый компонент
      <!-- Поскольку уже существует обширная экосистема ajax-библиотек  -->
      <!-- и библиотек функций общего назначения, ядро Vue может        -->
      <!-- оставаться маленьким и не изобретать их заново. Кроме того,  -->
      <!-- это позволяет вам использовать только знакомые инструменты. -->
      <script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
      <script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
      <script>
      var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
          question: '',
          answer: 'Пока вы не зададите вопрос, я не могу ответить!'
        },
        watch: {
          // эта функция запускается при любом изменении вопроса
          question: function (newQuestion) {
            this.answer = 'Ожидаю, когда вы закончите печатать...'
            this.getAnswer()
          }
        },
        methods: {
          // _.debounce — это функция из lodash, позволяющая ограничить
          // то, насколько часто может выполняться определённая операция.
          // В данном случае, мы хотим ограничить частоту обращений к yesno.wtf/api,
          // дожидаясь завершения печати вопроса перед тем как послать ajax-запрос.
          // Чтобы узнать больше о функции _.debounce (и её родственнице _.throttle),
          // см. документацию: https://lodash.com/docs#debounce
          getAnswer: _.debounce(
            function () {
              if (this.question.indexOf('?') === -1) {
                this.answer = 'Вопросы обычно заканчиваются вопросительным знаком. ;-)'
                return
              }
              this.answer = 'Думаю...'
              var vm = this
              axios.get('https://yesno.wtf/api')
                .then(function (response) {
                  vm.answer = _.capitalize(response.data.answer)
                })
                .catch(function (error) {
                  vm.answer = 'Ошибка! Не могу связаться с API. ' + error
                })
            },
            // Это число миллисекунд, которое мы ждём, после того как пользователь прекратил печатать:
            500
          )
        }
      })
      </script>


А7. Работа с CSS: классы и стили

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

    ▪ Управление стилями и классами в Vue
    ▪ Директива class
    ▪ Директива style

  # Управление классами через объект

    ▪ Передача объекта прямо в шаблоне
    ▪ Vue оставляет оригинальное содержимое class без изменений
    ▪ Передача объекта из модели
    ▪ Передача объекта из наблюдаемой

  # Управление классами через массив

    ▪ Массив вместо объекта
    ▪ Тернарный оператор для переключеняи классов в массиве
    ▪ Смешанный стиль: массив + объект

  # Vue-компоненты и директива class

    ▪ Директива class добавляет стили корневому эл-ту компонента
    ▪ Собственные класы компонента потеряны не будут
    ▪ Пример применения class к компоненту

  # Управление inline-стилями в Vue

    ▪ Решай сам: camelCase или kebab-case
    ▪ Управление стилями через объект
    ▪ Используем наблюдаемый объект
    ▪ Управление стилями через массив: применить несколько объектов стилей
    ▪ Vue сам добавляет вендорные префиксы
    ▪ Последнее значение, поддерживаемое в браузере

--------------------------------------

> Ссылки

  # [Официальноу руководство] Работа с классами и стилями
      https://ru.vuejs.org/v2/guide/class-and-style.html

> Введение

  • Управление стилями и классами в Vue
    - В Vue для работы с классами и стилями есть директивы class и style.
    - Хотя, как грубый инструмент, можно использовать и v-bind,
      и работать с классами, как с атрибутами. 

  • Директива class
    - Позволяет с удобствами управлять классами в Vue.

  • Директива style
    - Позволяет с удобствами управлять инлайновыми стилями в Vue.

> Управление классами через объект

  • Передача объекта прямо в шаблоне

    <div v-bind:class="{ active: isActive }"></div>

  • Vue оставляет оригинальное содержимое class без изменений
  
    ▪ Что имеется в виду?
      - У div в шаблоне ниже определён атрибут class.
      - У него есть значение "static".
      - Что будет, если использовать v-bind:class?
      - Атрибут class никуда не денется, он НЕ затирается.

    ▪ Шаблон

      <div class="static"
           v-bind:class="{ active: isActive, 'text-danger': hasError }">
      </div>

    ▪ Фрагмент JS с данными модели

      data: {
        isActive: true,
        hasError: true
      }  

    ▪ Что после рендеринга?

      <div class="static isActive hasError"</div>      

  • Передача объекта из модели
    - Объект не обязательно писать прямо в шаблоне.
    - Его можно поместить в модель, и передать оттуда.
    - Например:

      ▪ Шаблон

        <div v-bind:class="classObject"></div>   

      ▪ Фрагмент JS с данными модели

        data: {
          classObject: {
            active: true,
            'text-danger': false
          }
        }      

  • Передача объекта из вычисляемой
    - Можно также использовать и вычисляемую.
    - Вместо наблюдаемого объекта, как из предыдущего пункта.
    - Например:

      ▪ Шаблон

        <div v-bind:class="classObject"></div>

      ▪ Фрагмент JS с данными модели

        data: {
          isActive: true,
          error: null
        },
        computed: {
          classObject: function () {
            return {
              active: this.isActive && !this.error,
              'text-danger': this.error && this.error.type === 'fatal',
            }
          }
        }  

> Управление классами через массив
  
  • Массив вместо объекта
    - Можно вместо объекти использовать и массив.
    - Например:

      ▪ Шаблон
        
        <div v-bind:class="[activeClass, errorClass]">

      ▪ Фрагмент JS с данными модели

        data: {
          activeClass: 'active',
          errorClass: 'text-danger'
        }        
            
  • Тернарный оператор для переключеняи классов в массиве
    - В случае с объектом мы писали что-то типа: {active: isActive}.
    - А в случае с объектом можно использовать тернарный оператор:

      <div v-bind:class="[isActive ? activeClass : '', errorClass]">

  • Смешанный стиль: массив + объект
    - Для истинных ценителей:

      <div v-bind:class="[{ active: isActive }, errorClass]">

> Vue-компоненты и директива class

  • Директива class добавляет стили корневому эл-ту компонента
    - Если применить эту директиву к самому компоненту.

  • Собственные класы компонента потеряны не будут
    - Ситуация аналогичная, как и с не-компонентами.

  • Пример применения class к компоненту

    ▪ Компонент

      Vue.component('my-component', {
        template: '<p class="foo bar">Hi</p>'
      })

    ▪ Если указать доп.классы с помощью атрибута class
      - То они просто добавятся к указанным в шаблоне.
        
        <my-component class="baz boo"></my-component>
      
      - В результате будет: 
        
        <p class="foo bar baz boo">Hi</p>

    ▪ Если применить директиву v-bind:class
      - То, если isActive == true, он добавится к указанным в шаблоне.
      - Например:

        <my-component v-bind:class="{ active: isActive }"></my-component>

      - В результате будет: 

        <p class="foo bar active">Hi</p>

> Управление inline-стилями в Vue

  • Решай сам: camelCase или kebab-case
    - В Vue можно применять и тот, и другой стиль.
    - Но при использовании kebab-case не забывай про кавычки.
    - Например:

      <div v-bind:style="{ fontSize: fontSize + 'px', "font-size": fontSize + 'px' }"></div>

  • Управление стилями через объект

    ▪ Используем наблюдаемые
      - Передаём в директиву объект прямо в шаблоне.
      - Используем наблюдаемые для задания значений.
      - Код:

        ▪ Шаблон

          <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
       
        ▪ Фрагмент JS с данными модели

          data: {
            activeColor: 'red',
            fontSize: 30
          }

    ▪ Используем наблюдаемый объект
      - Передаём в директиву наблюдаемый объект.
      - А его свойства уже содержат инфу о стилях.
      - Код:

        ▪ Шаблон

          <div v-bind:style="styleObject"></div> 

        ▪ Фрагмент JS с данными модели

          data: {
            styleObject: {
              color: 'red',
              fontSize: '13px'
            }
          }      

  • Управление стилями через массив: применить несколько объектов стилей
    - Можно директиве передать массив объектов.
    - Тем самым, применив к эл-ту несколько объектов стилей.
    - Например:

        <div v-bind:style="[baseStyles, overridingStyles]">

  • Vue сам добавляет вендорные префиксы
    - Об этом паритсья не нужно.

  • Последнее значение, поддерживаемое в браузере
    - Часто разные браузеры не поддерживают кое-какие значения.
    - Поэтому, в версии 2.3 в Vue добавили эту фичу.
    - В примере ниже будет использовано последне значение,
      которое поддерживает браузер, где это выполнится:

        <div v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }">


