////=================================================////
////                                                 ////
////                     Vue.js                      ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Официальные ресурсы //
  //---------------------//

    # Сайт Vue.js (en, ru)
        https://vuejs.org
        https://ru.vuejs.org

    # Руководство v2 (en, ru)
        https://vuejs.org/v2/guide/
        https://ru.vuejs.org/v2/guide/

    # Сообщество и поддержка
        https://gitter.im/vuejs/vue           // Чат в гиттере
        https://forum.vuejs.org/              // Форум

    # Шаблоны
        https://github.com/vuejs-templates

    # Новости
        https://twitter.com/vuejs             // Частые новости
        https://medium.com/the-vue-point      // Блог, редко обновляется

    # Ресурсы
        https://github.com/vuejs/awesome-vue  // Обновляемый список относящихся к vue ресурсов (компоненты, туториалы и т.д.)
        https://vuex.vuejs.org/ru             // Vuex (core plugin)
        https://router.vuejs.org/ru           // Router (core plugin)

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Vue.js

    А1. План изучения Vue.js
    А2. Установка, совместимость
    А3. Введение в Vue
    А4. Экземпляр Vue
    А5. Синтаксис шаблонов


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. План изучения Vue.js

--------------------------------------
Подоглавление:

  # Введение
  # Как лучше изучать Vue.js?

--------------------------------------

> Ссылки

  # Где тестировать примеры
      https://jsfiddle.net

> Введение
  - Это короткая глава про то, как лучше изучать Vue.js
  - Данное руководстов актуально на 29.05.2017.

> Как лучше изучать Vue.js?

  1. Официальная документация Vue.js на родном языке
    - Используй последнюю версию документации (на 25.05.2017 - v2).
      https://ru.vuejs.org/v2/guide/
    - Напиши сквозную методичку по всей документации.
    - Так ты получишь полный обзор возможностей фреймворка.

  2. Плагины ядра vuex и router
    - Используй последнюю версию документации (на 25.05.2017 - v2).
    - Напиши сквозные методички по документации vuex и router.
    - Это позволит с самого начала применять их для работы.

  3. Пополнение собственной подборки полезных сторонних vue-компонентов
    - Создай в этой методичке отдельный раздел для этих целей.
    - И постепенно пополняй его инфой о сторонних полезных vue-компонентах.
    - Используй awsome-vue и оцициальный twitter в качестве источников.

А2. Установка, совместимость

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Вопросы совместимости Vue.js

    ▪ ECMAScript >= 5
    ▪ IE >= 9

  # Способы подключения Vue.js к проекту

    ▪ Подключение файла через <script>
    ▪ Подключение ссылки из CDN через <script>
    ▪ Подключение через NPM

  # Официальный CLI от VUE
  # Объяснение различных сборок VUE
  # Runtime + Компилятор vs Runtime-only

    ▪ Когда нужен компилятор
    ▪ Для однофайловых компонентов *.vue компилятор не нужен
    ▪ Псевдоним в сборщике при использовании полных сборок

  # Режим разработки vs режим production

    ▪ UMD-сборки
    ▪ CommonJS и ES Module
    ▪ Переменная среды process.env.NODE_ENV

--------------------------------------

> Ссылки
  
  # [Официальноу руководство] Установка
      https://ru.vuejs.org/v2/guide/installation.html

> Введение
  - Рассмотрены вопросы установки, совместимости, использования Vue.js.

> Вопросы совместимости Vue.js

  • ECMAScript >= 5
    - Vue.js должен работать с браузерами, поддерживающими ES >= 5

  • IE >= 9
    - Vue.js не работает с IE <= 8, т.к. там нельзя эмулировать ES >= 5.

> Способы подключения Vue.js к проекту

  • Подключение файла через <script>
    - Скачать файл с Vue.js и подключить.
    - На данный момент (30.05.2017) есть 2 версии:

      ▪ Для разработчиков   | С предупреждениями для удобства разработки и отладки
      ▪ Для production      | Без предупреждений, ~30кб.

  • Подключение ссылки из CDN через <script>
    - Рекомендуемый CDN: https://unpkg.com/vue

  • Подключение через NPM
    - Автор рекомендует NPM для крупных Vue-приложений.
    - Этот вариант хорошо работает с инструментами сборке,
      такими как Webpack и Browserify.
    - В Vue также есть совместимые с ними инструменты
      для использования однофайловых компонентов.

> Официальный CLI от VUE
  - У VUE есть официальный интерпретатор командной строке (CLI).
  - Это позволяет быстро создавать каркас одностраничных приложений.
  - Предлагаемые шаблоны содержат всё необходимое для фронтенд-разработки.
  - Всего за несколько минут вы получите конфигурацию с hot-reload,
    линтингом кода при сохранении и настроенной конфигурации
    production-сборки.

> Объяснение различных сборок VUE
  
  ▪ Схема

                                UMD                 CommonJS                ES Module
    ----------------------------------------------------------------------------------------------
    Полная                      vue.js              vue.common.js           vue.esm.js
    Runtime-only                vue.runtime.js      vue.runtime.common.js   vue.runtime.esm.js
    Полная (production)         vue.min.js          -
    Runtime-only (production)   vue.runtime.min.js  -

  ▪ Терминология
    - Полная      | Сборка, которая содержит и компилятор, и runtime.
    - Компилятор  | Код, который отвечает за компиляцию строковых
                    шаблонов в JavaScript render-функции.
    - Runtime     | Код, который отвечает за создание экземпляров Vue,
                    рендеринг и изменение виртуального DOM, и т.д. Обобщённо, этой
                    всё, за исключением компилятора.
    - UMD         | UMD-сборки можно использовать сразу в браузере,
                    подключая тегом <script>. Файлом по умолчанию в Unpkg CDN из
                    https://unpkg.com/vue будет Runtime + Компилятор UMD-сборка (vue.js).
    - CommonJS    | CommonJS-сборки предназначены для использования вместе со старыми
                    инструментами сборки, такими как Browserify или Webpack 1. Файлом
                    по умолчанию для них (pkg.main) будет Runtime-only CommonJS сборка
                    (vue.runtime.common.js).
    - ES Module   | ES module сборки предназначены для использования с современными
                    инструментами сборки, такими как Webpack 2 или Rollup. Файлом по умолчанию
                    для них (pgk.module) будет Runtime-only ES Module сборка
                    (vue.runtime.esm.js).

  ▪ Runtime + Компилятор vs Runtime-only
    
    ▪ Когда нужен компилятор
      - Компилятор нужен, если надо компилировать шаблоны на лету.
      - Например:

          // это требует компилятора
          new Vue({
            template: `<div>{{ hi }}</div>`
          })

          // это нет
          new Vue({
            render (h) {
              return h('div', this.hi)
            }
          })    

    ▪ Для однофайловых компонентов *.vue компилятор не нужен
      - Vue-loader и vuefiy компилируют шаблоны внутри *.vue на этапе сборки.
      - Так что, с файлми *.vue можно использовать runtime-only сборки.

    ▪ Псевдоним в сборщике при использовании полных сборок
      - Runtime-only сборки примерно на 30% легче, в сравнении с полными.
      - Поэтому, есть смысл использовать их, когда это возможно.
      - А для использования полных сборок надо настроить псевдоним в сборщике:

        ▪ Webpack
          module.exports = {
            // ...
            resolve: {
              alias: {
                'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' для webpack 1
              }
            }
          }

        ▪ Rollup
          const alias = require('rollup-plugin-alias')
          rollup({
            // ...
            plugins: [
              alias({
                'vue': 'vue/dist/vue.esm.js'
              })
            ]
          })

        ▪ Browserify
          - Добавьте в package.json вашего проекта:
            {
              // ...
              "browser": {
                "vue": "vue/dist/vue.common.js"
              }
            }

> Режим разработки vs режим production

  • UMD-сборки
    - Тут есть min и не-min файлы.
    - min для продакшн, не-min для разработки.

  • CommonJS и ES Module
    - Тут не минифицированный код.
    - Ведь эти сборки предназначены для инструментов сборки.
    - Хочешь минифицировать - легко это сделаешь через оные.
    
  • Переменная среды process.env.NODE_ENV
    - Также эти сборки палят переменную среды: process.env.NODE_ENV.
    - В каждой системе сборки можно использовать соотв.плагин:

      ▪ Webpack

          var webpack = require('webpack')
          module.exports = {
            // ...
            plugins: [
              // ...
              new webpack.DefinePlugin({
                'process.env': {
                  NODE_ENV: JSON.stringify('production')
                }
              })
            ]
          }

      ▪ Rollup

          const replace = require('rollup-plugin-replace')
          rollup({
            // ...
            plugins: [
              replace({
                'process.env.NODE_ENV': JSON.stringify('production')
              })
            ]
          }).then(...)

      ▪ Browserify

          NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js

А3. Введение в Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое Vue.js?
    ▪ Описание Vue
    ▪ Hello World на Vue

  # Декларативный рендеринг и реактивный биндинг
    ▪ Что такое декларативный рендеринг
    ▪ Что такое реактивный биндинг
    ▪ Пример декларативного рендеринга и реактивного биндинга
    ▪ Пример биндинга атрибута title

  # Условия и циклы, transition-эффекты
    ▪ Про условия и циклы в Vue
    ▪ Управление присутствием эл-та в DOM с помощью v-if
    ▪ Пример использования директивы v-for
    ▪ Пример использования v-if с transition-эффектом

  # Работа с событиями, 2-сторонний биндинг эл-в формы
    ▪ Про биндинг событий в Vue
    ▪ Биндинг событий с обработчиками с помощью директивы v-on
    ▪ Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

  # Разбиение приложения на компоненты
    ▪ Ключевые понятия концепции компонентов
      - Vue-компонент
      - Vue не реализует паттерн MVVP в полной мере
      - Слабая связанность и автономность
      - Повторное использование
      - Репозитории сторонних компонентов
      - Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Пример компактного шаблона приложения, использующего компоненты
    ▪ Создать простейший vue-компонент
    ▪ Использования входных параметров vue-компонента

--------------------------------------

> Ссылки

  # [Официальноу руководство] Введение
      https://ru.vuejs.org/v2/guide/

  # Однофайловые компоненты
      https://ru.vuejs.org/v2/guide/single-file-components.html

  # База готовых компонентов и библиотеками
      https://github.com/vuejs/awesome-vue#components--libraries

  # Чем Vue отличается от других фронтенд библиотек/фреймфорков
      https://ru.vuejs.org/v2/guide/comparison.html
  
  # Паттерн MVVM
      https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel
  
> Введение
  - Это обзорное введение в Vue.js.
  - Это не справочник, а обзорная экскурсия.
  - Стараемся зацепить все наиболее важные темы, но поверхностно.

> Что такое Vue.js?
  
  • Описание Vue
    - Vue произносится, как vju:, примерно как view.
    - Это прогрессивный фреймворк для создания пользовательских инетрфейсов.
    - В отличие от фреймворков-монолитов, vue годится для постепенного внедрения.
      Его ядро в 1-ю очередь решает задачи уровня представления (view).
      Что упрощает интеграцию с другими библиотеками и существующими проектами.
    - Vue полностью подходит для создания одностраничных приложений
      (SPA, Single-Page Applications). Помочь в этом может:

        ▪ Применение однофайловых компонентов (см.ссылки).
        ▪ Базы готовых компонентов и библиотек (см.ссылки).

  • Hello World на Vue

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>
      
      // 2. Подготовить шаблон
      <div id="app">
        <p>{{ message }}</p>
      </div> 

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue.js!'
        }
      })

> Декларативный рендеринг и реактивный биндинг

  • Что такое декларативный рендеринг
    - Позволяет связывать модель с шаблоном прямо в шаблоне.
    - По тому же принципу работает, например, Knockoutjs.
    - В качестве примера см. Hello World на Vue выше.

  • Что такое реактивный биндинг
    - Когда при изменении значения в модели меняется и значение в шаблоне.
    - По умолчанию применяется 1-направленный биндинг: модель -> шаблон.
    - Но можно использоватьи 2-направленный, с помощью v-model (например, в формах).

  • Пример декларативного рендеринга и реактивного биндинга
    - Этот пример демонстрирует декларативный рендеринг и 
      1-направленный декларативный биндинг.
    - В консоли браузера можно написать:

        app.message = 'test'

    - И новое значение сразу будет отрисовано.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app">
        {{ message }}
      </div>

      // 3. Создать экземпляр Vue
      var app = new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue!'
        }
      })      

  • Пример биндинга атрибута title
    - В примере мы применяем директиву v-bind.
    - И однонаправленно биндим атрибут title со св-вом message в модели.
    - Теперь, при изменении message, будет меняться и title.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-2">
        <span v-bind:title="message">
          Подержи курсор надо мной пару секунд,
          чтобы увидеть динамически связанное значение title!
        </span>
      </div>

      // 3. Создать экземпляр Vue
      var app2 = new Vue({
        el: '#app-2',
        data: {
          message: 'Вот когда вы загрузили эту страницу: ' + new Date()
        }
      })      

> Условия и циклы, transition-эффекты

  • Про условия и циклы в Vue
    - Они работают примерно аналогично knockoutjs`овским.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Управление присутствием эл-та в DOM с помощью v-if
    - Можно менять значение app3.seen на true/false.
    - И тем самым управлять присутствием шаблона в DOM.
    - Директива v-if аналогична директиве if из knockoutjs.
    - При false шаблон просто изчезает из DOM (не путать с display:none).
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-3">
        <p v-if="seen">Сейчас меня видно</p>
      </div>      

      // 3. Создать экземпляр Vue
      var app3 = new Vue({
        el: '#app-3',
        data: {
          seen: true
        }
      })      

  • Пример использования директивы v-for
    - Можно на лету добавить новый элемент в массив todos.
    - Это можно сделать, например, в консоли: app4.todos.push({ text: 'Новый элемент' })
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-4">
        <ol>
          <li v-for="todo in todos">
            {{ todo.text }}
          </li>
        </ol>
      </div>

      // 3. Создать экземпляр Vue
      var app4 = new Vue({
        el: '#app-4',
        data: {
          todos: [
            { text: 'Посадить дерево' },
            { text: 'Построить дом' },
            { text: 'Вырастить сына' }
          ]
        }
      })

  • Пример использования v-if с transition-эффектом
    - Vue имеет встроенную систему анимации, которая применяет transition-эффекты.
    - В этом примере мы меняем значение v-if нажатием кнопки.
    - Благодаря transition-эффекту эл-т плавно появляется/исчезает.
    - Можно также назначать JS-хуки, которые будут вызваны в нужные моменты времени.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="demo">
        <button v-on:click="show = !show">
          Переключить
        </button>
        <transition name="fade">
          <p v-if="show">hello</p>
        </transition>
      </div>    

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#demo',
        data: {
          show: true
        }
      }) 

      // 4. Подготовить CSS
      .fade-enter-active, .fade-leave-active {
        transition: opacity .5s
      }
      .fade-enter, .fade-leave-to /* .fade-leave-active для <2.1.8 */ {
        opacity: 0
      }

> Работа с событиями, 2-сторонний биндинг эл-в формы

  • Про биндинг событий в Vue
    - С точки зрения использования, всё работает, как knockoutjs.
    - Можно назначать обработчики событий для элементов.
    - Можно делать 2-сторонний биндинг с элементами формы типа input, textarea и т.д.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Биндинг событий с обработчиками с помощью директивы v-on
    - С помощью v-on можно связать событие на элементе с обработчиком.
    - Например, свяжем событие click на эл-те с функцией-обработчиком:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-5">
        <p>{{ message }}</p>
        <button v-on:click="reverseMessage">Обратить порядок букв в сообщении</button>
      </div>

      // 3. Создать экземпляр Vue     
      var app5 = new Vue({
        el: '#app-5',
        data: {
          message: 'Hello Vue.js!'
        },
        methods: {
          reverseMessage: function () {
            this.message = this.message.split('').reverse().join('')
          }
        }
      })

  • Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-6">
        <p>{{ message }}</p>
        <input v-model="message">
      </div>

      // 3. Создать экземпляр Vue
      var app6 = new Vue({
        el: '#app-6',
        data: {
          message: 'Hello Vue!'
        }
      })

> Разбиение приложения на компоненты

  • Ключевые понятия концепции компонентов

    ▪ Vue-компонент
      - Концепция Vue изначально предполагает использование компонентов.
      - В Vue, компонент — это, по сути, экземпляр Vue с предустановленными опциями. 
      - Эта абстракция позволяет собирать большие приложения из малых кусочков.
      - Почти любой интерфейс может быть представлен, как дерево компонентов.

    ▪ Vue не реализует паттерн MVVP в полной мере
      - Речь идёт о паттерне Model–view–viewmodel.

    ▪ Слабая связанность и автономность
      - Связь между компонентами должна отсутствовать.
      - Каждый компонент должн быть в MAX степени автономен.

    ▪ Повторное использование
      - Компоненты представляют собой пригодные к повторному использованию объекты.
      - Ведь они слабо связаны друг с другом, и м.б. перенесены в другой проект/место проекта.

    ▪ Репозитории сторонних компонентов
      - Благодаря компонентной концепции могут быть созданы репозитории компонентов.
      - Теперь не надо писать всё самому, можно использовать сторонние компоненты.

    ▪ Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Разработкой компонентной системы намного легче управлять.
      - Можно разбить её на дерево мелких автономных компонентов.
      - Для разработки каждого компонента написать чёткое тех.задание.
      - И раздать подряды на разработку большому кол-ву разработчиков.
      - Это позволит кардинально увеличить скорость разработки фронтенда проекта.
      - Относиться к каждому компоненту, можно как к чёрному ящику.
      - У которого есть входы и выходы (но код инспектировать всё равно нужно).

    ▪ Пример компактного шаблона приложения, использующего компоненты
      - В крупных приложениях разделение на компоненты очень важно.
      - Это становится обязательным условием для сохранения управляемости процесса разработки.
      - Вот, как бы мог выглядеть шаблон приложения, использующего компоненты:

          <div id="app">
            <app-nav></app-nav>
            <app-view>
              <app-sidebar></app-sidebar>
              <app-content></app-content>
            </app-view>
          </div>

      - Как видно, на верхнем уровне находится блок с id="app".
      - А далее, считай, что просто идёт дерево компонентов.

  • Создать простейший vue-компонент
    - Это чисто для демонстрации концепции.
    - Код:

      // Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        template: '<li>Это todo</li>'
      })

      // Использовать компонент todo-item в шаблоне другого компонента
      <ul>
        <!-- Создаём экземпляр компонента todo-item -->
        <todo-item></todo-item>
      </ul>      

  • Использования входных параметров vue-компонента
    - Это расширение предыдущего примера.
    - Здесь мы добавляем компоненту todo-item принимать входящий параметр.
    - Для этого в определении компонента мы используем св-во props.
    - В нём перечисляются параметры, которые может принимать компонент.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
      })

      // 3. Подготовить шаблон
      // - В этом шаблоне мы и применяем наш компонент todo-item.
      // - Применяем директивы v-for прямо на компонент, которая пробегает
      //   массив groceryList из модели приложения.
      // - Далее с помощью v-bind связываем item массива с параметром todo компонента.
      // - И также с помощью v-bind связываем индекс с item.id.
      <div id="app-7">
        <ol>
          <!--
            Теперь мы можем передать каждому компоненту todo объект
            с информацией о задаче, который будет динамически меняться.
            Мы также определяем для каждого компонента "key",
            значение которого будет объяснено далее в руководстве.
          -->
          <todo-item
            v-for="item in groceryList"
            v-bind:todo="item"
            v-bind:key="item.id">
          </todo-item>
        </ol>
      </div>

      // 4. Создать экземпляр Vue
      var app7 = new Vue({
        el: '#app-7',
        data: {
          groceryList: [
            { id: 0, text: 'Овощи' },
            { id: 1, text: 'Сыр' },
            { id: 2, text: 'Что там ещё люди едят?' }
          ]
        }
      })      


А4. Экземпляр Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Конструктор Vue
    ▪ Модель приложения / корневой экземпляр Vue
    ▪ Опции по умолчанию для компонента / расширение конструктора Vue
    ▪ Экземпляры компонентов рекомендуется создавать декларативно

  # Свойства и методы
    ▪ Vue-экземпляр проксирует все св-ва из объекта data
      - Что значит проксирует?
      - Что значит проксирует ссылки?
    ▪ Все проксируемые свойства из data являются реактивными
    ▪ Vue-экземпляр содержив встроенные св-ва/методы, начинающиеся с $
    ▪ Не используй стрелочные функции в св-вах экземпляра и колбэках!

  # Хуки жизненного цикла экземпляра

    ▪ Последовательность шагов при инициализации экземпляра
    ▪ Хуки жизненного цикла
    ▪ Хуки вызываются с контекстной переменной this
    ▪ Контроллеров в Vue не существует

  # Диаграмма жизненного цикла vue-экземпляра

--------------------------------------

> Ссылки

  # [Официальноу руководство] Экземпляр Vue
      https://ru.vuejs.org/v2/guide/instance.html

> Введение
  - Vue не реализует полностью паттерн MVVM, но его архитектура вдохновлена им.
  - Поэтому, традиционно, переменная с экземпляром Vue называется vm (от ViewModel).
  - Грубо говоря, экземпляр Vue - это объект с Vue-моделью.
  - В knockoutjs я привык называть это просто "модель".
  - В этой главе речь пойдёт об общих свойствах моделей в Vue.
  - Таких, как: конструктор, св-ва и методы, хуки и жизненный цикл.

> Конструктор Vue

  • Модель приложения / корневой экземпляр Vue
    - Корневой экземпляр обычно создаётся императивно.
    - При создании в него передаётся объект с опциями.
    - В нём - данные, шаблон, DOM-элемент, методы, хуки жизненного цикла и т.д.
    - Например:

        var vm = new Vue({
          // опции
        })

  • Опции по умолчанию для компонента / расширение конструктора Vue
    - Допустим, у нас есть какой-то компонент.
    - И нам его надо много раз создавать императивно в приложении.
    - И напрягает, что каждый раз надо передавать объект с опциями.
    - Чтобы этого не делать, можно задать объект с опциями по умолчанию.
    - Для этого надо расширить конструктор vue.
    - Например:

        // Задать опции по умолчанию для компонента, расширив его конструктор
        var MyComponent = Vue.extend({
          // опции компонента
        })    

        // Теперь все экземпляры этого компонента используют опции по умолчанию
        var myComponentInstance = new MyComponent()

  • Экземпляры компонентов рекомендуется создавать декларативно
    - Выше продемонстрирован пример императивного создания экземпляра компонента.
    - Однако, автор рекомендует создавать их декларативно.
    - Т.Е., как пользовательские HTML-элементы в шаблонах.
    - Подробнее об этом см.главу про Vue-компоненты.
    - А пока запомни: все Vue-компоненты являются расширенными Vue-экземплярами.

> Свойства и методы

  • Vue-экземпляр проксирует ссылки всех св-в из объекта data
    
    ▪ Что значит проксирует?
      - То есть, они становятся напрямую свойствами модели.
      - Вместо vm.data.prop надо писать просто vm.prop.
      - Пояснение на примере:

          // Подготовим data и создаим vue-экземпляр
          var data = { a: 1 }
          var vm = new Vue({
            data: data
          })

          // Удостоверимся в написанном выше
          vm.a === data.a   // true

    ▪ Что значит проксирует ссылки?
      - Значит, что vm.a и data.a содержат одну и ту же ссылку.
      - Т.Е. меняя значение в модели, мы меняем его в исходном объекте data.
      - Примеры для иллюстрации этого:

          // установка свойства также влияет на оригинальные данные
          vm.a = 2
          data.a      // 2

          // ... и наоборот
          data.a = 3
          vm.a        // 3  

  • Все проксируемые свойства из data являются реактивными
    - Т.Е. при изменении их значений автоматом меняется и представление.
    - Однако, реактивными они становятся при создании экземпляра.
    - Добавление новых св-в в data после создания экземпляра не сделает их реактивными.
    - Хотя, есть возможность добавлять реактивные св-ва во вложенные объекты.
    - В общем, подробнее о рекативности читай в главе про реактивность.

  • Vue-экземпляр содержив встроенные св-ва/методы, начинающиеся с $
    - С $ они начинаются, чтобы отличаться от пользовательских.
    - Например, ссылка на объект data лежит в vm.$data,
      а ссылка на DOM-элемент лежит в $el,
      а коллбэк на изменение св-ва можно задать методом $watch.
    - Полный список встроенных св-в и методов см. в главе-справочнике API.
    - Проиллюстрируем на примере:

        // Подготовим data и создаим vue-экземпляр
        var data = { a: 1 }
        var vm = new Vue({
          el: '#example',
          data: data
        })

        // Собственно, иллюстрация
        vm.$data === data                             // true
        vm.$el === document.getElementById('example') // true

        // $watch — это метод экземпляра
        vm.$watch('a', function (newVal, oldVal) {
          // этот коллбэк будет вызван, когда изменится `vm.a`
        })

  • Не используй стрелочные функции в св-вах экземпляра и колбэках!
    - Например: vm.$watch('a', newVal => this.myMethod())
    - Потому что СФ связываются с родительским контекстом (this).
    - Соответственно, this внутри не будет указывать на vue-экземпляр.
    - И, например, this.myMethod будет undefined.

> Хуки жизненного цикла экземпляра

  • Последовательность шагов при инициализации экземпляра
    - Каждый vue-экземпляр проходит при создании некий процесс.
    - Процесс представляет собой последовательность задач инициализации.
    - Например:

      ▪ Настройка наблюдения за данными.
      ▪ Компиляция шаблона.
      ▪ Монтаж экземпляра в DOM.
      ▪ Обновление DOM при изменении данных.
      ▪ .. и прочие ..

  • Хуки жизненного цикла
    - Всё имеет своё начало, и свой конец. И vue-экземпляр тоже.
    - По мере путешествия экземпляра по жизненному циклу, 
      он на каждом шагу генерирует события.
    - Например: created, mounted, updated, destroyed, и т.д.
    - Соответственно, можно назначать обработчики для этих хуков.
    - Например, назначим обработчик, который вызывается после создания экземпляра:

        var vm = new Vue({
          data: {
            a: 1
          },
          created: function () {
            // `this` указывает на экземпляр vm
            console.log('Значение a: ' + this.a)
          }
        })
        // -> "Значение a: 1"

  • Хуки вызываются с контекстной переменной this
    - Она содержит ссылку на вызывающий vue-экземпляр.

  • Контроллеров в Vue не существует
    - Впрочем, как и в knockoutjs.
    - Наверное, они есть в angular? [примечание автора методички].
    - В общем, всё польз.поведение компонента должно быть в этих хуках.

> Диаграмма жизненного цикла vue-экземпляра

              
                       new Vue()
                          |
   [событие] beforeCreate |
                          |
                     Observe Data 
                          |
        [событие] created |
                          | 
                      Init Events
                          |                  
                          |                  
                          |                  
                  Есть ли опция "el"? -------
                          |                 |
                       Да |                 | - Vue ждёт, пока vm.$mount(el) будет вызвана вручную
                          |                 |
                Есть ли опция "template"?----
                          |
                          |
             ---------------------------
          Да |                         | Нет
             |                         | 
      Скомпилировать             Взять outerHTML
      этот template              в качестве шаблона,
             |                   и скомпилировать его
             |                         |
             ---------------------------
                          |
    [событие] beforeMount |
                          |
                   Создать vm.$el и
                   заменить содержимое
                   el скомпилированным
                          | 
        [событие] mounted | 
                          |   При изменении
                         /|\  данных
                        /   \   /------>------ 
                       / См- \ /             | - [событие] beforeUpdate            
                      / онти- \              |
                     / рованн- \        Ререндеринг
                    / ое состо- \       виртуального DOM
                    \ яние Vue- /            |
                     \ компон- /             | - [событие] updated
                      \ ента  /--------<------
                       \     /
                        \   /
                         \|/
                          |
                          |
                Если вызван встроенный
                метод vm.$destroy()
                          |
  [событие] beforeDestroy |
                          |
                  Завершение работы
                  вотчеров, дочерних
                  компонентов и 
                  обработчиков событий
                          | 
                          | 
                         /|\ 
                        /   \ 
                       / Ун- \ 
                      / ичто- \  
                     / женный  \ 
                    / Компонент \
                    \           /
                     \         / 
                      \       /
                       \     /
                        \   /
                         \|/ 
                          | 
      [событие] destroyed | 
                          |
                        -----
 
 
 А5. Синтаксис шаблонов
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
 
--------------------------------------

> Ссылки

  # [Официальноу руководство] Синтаксис шаблонов
      https://ru.vuejs.org/v2/guide/syntax.html

> Введение
  - 
 
 
 

 
 
 
 
 
 
 