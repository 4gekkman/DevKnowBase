////=================================================////
////                                                 ////
////                     Vue.js                      ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Официальные ресурсы //
  //---------------------//

    # Сайт Vue.js (en, ru)
        https://vuejs.org
        https://ru.vuejs.org

    # Руководство v2 (en, ru)
        https://vuejs.org/v2/guide/
        https://ru.vuejs.org/v2/guide/

    # Сообщество и поддержка
        https://gitter.im/vuejs/vue           // Чат в гиттере
        https://forum.vuejs.org/              // Форум

    # Шаблоны
        https://github.com/vuejs-templates

    # Новости
        https://twitter.com/vuejs             // Частые новости
        https://medium.com/the-vue-point      // Блог, редко обновляется

    # Ресурсы
        https://github.com/vuejs/awesome-vue  // Обновляемый список относящихся к vue ресурсов (компоненты, плагины, библиотеки, туториалы и т.д.)
        https://vuex.vuejs.org/ru             // Vuex (core plugin)
        https://router.vuejs.org/ru           // Router (core plugin)

    # Песочница с Vue
        https://jsfiddle.net/chrisvfritz/50wL7mdz/

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Vue.js

    А1. План изучения Vue.js
    А2. Установка, совместимость
    А3. Введение в Vue
    А4. Экземпляр Vue
    А5. Синтаксис шаблонов
    А6. Вычисляемые свойства и слежение
    А7. Работа с CSS: классы и стили
    А8. Условный рендеринг
    А9. Рендеринг списков
    А10. Обработка событий
    А11. Работа с формами
    А12. Компоненты
    
  # Б.  Продвинутые темы Vue.js

    Б1. Подробно о реактивности
    Б2. Анимирование эффектов переходов
    Б3. Анимирование данных
    Б4. Render-функции
    Б5. Пользовательские директивы
    Б6. Примеси
    Б7. Плагины
    Б8. Однофайловые компоненты
    Б9. Советы по деплою
    Б10. Vue CLI
    Б11. Vue devtools, плагин для Chrome
    Б12. Vue API
    Б13. Vuex 2.x
    Б14. Vue-router 2.x

  # 


    Про что ещё написать
    - Vuex
    - Vue router
    - Обзор компонентов/плагинов/и т.п. из Vue-awesome

    На потом
    - Серверный рендеринг/пререндеринг

////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. План изучения Vue.js

--------------------------------------
Подоглавление:

  # Введение
  # Как лучше изучать Vue.js?

--------------------------------------

> Ссылки

  # Где тестировать примеры
      https://jsfiddle.net

> Введение
  - Это короткая глава про то, как лучше изучать Vue.js
  - Данное руководстов актуально на 29.05.2017.

> Как лучше изучать Vue.js?

  1. Официальная документация Vue.js на родном языке
    - Используй последнюю версию документации (на 25.05.2017 - v2).
      https://ru.vuejs.org/v2/guide/
    - Напиши сквозную методичку по всей документации.
    - Так ты получишь полный обзор возможностей фреймворка.

  2. Плагины ядра vuex и router
    - Используй последнюю версию документации (на 25.05.2017 - v2).
    - Напиши сквозные методички по документации vuex и router.
    - Это позволит с самого начала применять их для работы.

  3. Пополнение собственной подборки полезных сторонних vue-компонентов
    - Создай в этой методичке отдельный раздел для этих целей.
    - И постепенно пополняй его инфой о сторонних полезных vue-компонентах.
    - Используй awsome-vue и оцициальный twitter в качестве источников.

А2. Установка, совместимость

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Вопросы совместимости Vue.js

    ▪ ECMAScript >= 5
    ▪ IE >= 9

  # Способы подключения Vue.js к проекту

    ▪ Подключение файла через <script>
    ▪ Подключение ссылки из CDN через <script>
    ▪ Подключение через NPM

  # Официальный CLI от VUE
  # Объяснение различных сборок VUE
  # Runtime + Компилятор vs Runtime-only

    ▪ Когда нужен компилятор
    ▪ Для однофайловых компонентов *.vue компилятор не нужен
    ▪ Псевдоним в сборщике при использовании полных сборок

  # Режим разработки vs режим production

    ▪ UMD-сборки
    ▪ CommonJS и ES Module
    ▪ Переменная среды process.env.NODE_ENV

--------------------------------------

> Ссылки
  
  # [Официальное руководство] Установка
      https://ru.vuejs.org/v2/guide/installation.html

> Введение
  - Рассмотрены вопросы установки, совместимости, использования Vue.js.

> Вопросы совместимости Vue.js

  • ECMAScript >= 5
    - Vue.js должен работать с браузерами, поддерживающими ES >= 5

  • IE >= 9
    - Vue.js не работает с IE <= 8, т.к. там нельзя эмулировать ES >= 5.

> Способы подключения Vue.js к проекту

  • Подключение файла через <script>
    - Скачать файл с Vue.js и подключить.
    - На данный момент (30.05.2017) есть 2 версии:

      ▪ Для разработчиков   | С предупреждениями для удобства разработки и отладки
      ▪ Для production      | Без предупреждений, ~30кб.

  • Подключение ссылки из CDN через <script>
    - Рекомендуемый CDN: https://unpkg.com/vue

  • Подключение через NPM
    - Автор рекомендует NPM для крупных Vue-приложений.
    - Этот вариант хорошо работает с инструментами сборке,
      такими как Webpack и Browserify.
    - В Vue также есть совместимые с ними инструменты
      для использования однофайловых компонентов.

> Официальный CLI от VUE
  - У VUE есть официальный интерпретатор командной строке (CLI).
  - Это позволяет быстро создавать каркас одностраничных приложений.
  - Предлагаемые шаблоны содержат всё необходимое для фронтенд-разработки.
  - Всего за несколько минут вы получите конфигурацию с hot-reload,
    линтингом кода при сохранении и настроенной конфигурации
    production-сборки.

> Объяснение различных сборок VUE
  
  ▪ Схема

                                UMD                 CommonJS                ES Module
    ----------------------------------------------------------------------------------------------
    Полная                      vue.js              vue.common.js           vue.esm.js
    Runtime-only                vue.runtime.js      vue.runtime.common.js   vue.runtime.esm.js
    Полная (production)         vue.min.js          -
    Runtime-only (production)   vue.runtime.min.js  -

  ▪ Терминология
    - Полная      | Сборка, которая содержит и компилятор, и runtime.
    - Компилятор  | Код, который отвечает за компиляцию строковых
                    шаблонов в JavaScript render-функции.
    - Runtime     | Код, который отвечает за создание экземпляров Vue,
                    рендеринг и изменение виртуального DOM, и т.д. Обобщённо, этой
                    всё, за исключением компилятора.
    - UMD         | UMD-сборки можно использовать сразу в браузере,
                    подключая тегом <script>. Файлом по умолчанию в Unpkg CDN из
                    https://unpkg.com/vue будет Runtime + Компилятор UMD-сборка (vue.js).
    - CommonJS    | CommonJS-сборки предназначены для использования вместе со старыми
                    инструментами сборки, такими как Browserify или Webpack 1. Файлом
                    по умолчанию для них (pkg.main) будет Runtime-only CommonJS сборка
                    (vue.runtime.common.js).
    - ES Module   | ES module сборки предназначены для использования с современными
                    инструментами сборки, такими как Webpack 2 или Rollup. Файлом по умолчанию
                    для них (pgk.module) будет Runtime-only ES Module сборка
                    (vue.runtime.esm.js).

  ▪ Runtime + Компилятор vs Runtime-only
    
    ▪ Когда нужен компилятор
      - Компилятор нужен, если надо компилировать шаблоны на лету.
      - Например:

          // это требует компилятора
          new Vue({
            template: `<div>{{ hi }}</div>`
          })

          // это нет
          new Vue({
            render (h) {
              return h('div', this.hi)
            }
          })    

    ▪ Для однофайловых компонентов *.vue компилятор не нужен
      - Vue-loader и vuefiy компилируют шаблоны внутри *.vue на этапе сборки.
      - Так что, с файлми *.vue можно использовать runtime-only сборки.

    ▪ Псевдоним в сборщике при использовании полных сборок
      - Runtime-only сборки примерно на 30% легче, в сравнении с полными.
      - Поэтому, есть смысл использовать их, когда это возможно.
      - А для использования полных сборок надо настроить псевдоним в сборщике:

        ▪ Webpack
          module.exports = {
            // ...
            resolve: {
              alias: {
                'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' для webpack 1
              }
            }
          }

        ▪ Rollup
          const alias = require('rollup-plugin-alias')
          rollup({
            // ...
            plugins: [
              alias({
                'vue': 'vue/dist/vue.esm.js'
              })
            ]
          })

        ▪ Browserify
          - Добавьте в package.json вашего проекта:
            {
              // ...
              "browser": {
                "vue": "vue/dist/vue.common.js"
              }
            }

> Режим разработки vs режим production

  • UMD-сборки
    - Тут есть min и не-min файлы.
    - min для продакшн, не-min для разработки.

  • CommonJS и ES Module
    - Тут не минифицированный код.
    - Ведь эти сборки предназначены для инструментов сборки.
    - Хочешь минифицировать - легко это сделаешь через оные.
    
  • Переменная среды process.env.NODE_ENV
    - Также эти сборки палят переменную среды: process.env.NODE_ENV.
    - В каждой системе сборки можно использовать соотв.плагин:

      ▪ Webpack

          var webpack = require('webpack')
          module.exports = {
            // ...
            plugins: [
              // ...
              new webpack.DefinePlugin({
                'process.env': {
                  NODE_ENV: JSON.stringify('production')
                }
              })
            ]
          }

      ▪ Rollup

          const replace = require('rollup-plugin-replace')
          rollup({
            // ...
            plugins: [
              replace({
                'process.env.NODE_ENV': JSON.stringify('production')
              })
            ]
          }).then(...)

      ▪ Browserify

          NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js

А3. Введение в Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое Vue.js?
    ▪ Описание Vue
    ▪ Hello World на Vue

  # Немного истории
    ▪ Vue 1 (2013 - 2016)
    ▪ Vue 2 (2016 - ...)

  # Декларативный рендеринг и реактивный биндинг
    ▪ Что такое декларативный рендеринг
    ▪ Что такое реактивный биндинг
    ▪ Пример декларативного рендеринга и реактивного биндинга
    ▪ Пример биндинга атрибута title

  # Условия и циклы, transition-эффекты
    ▪ Про условия и циклы в Vue
    ▪ Управление присутствием эл-та в DOM с помощью v-if
    ▪ Пример использования директивы v-for
    ▪ Пример использования v-if с transition-эффектом

  # Работа с событиями, 2-сторонний биндинг эл-в формы
    ▪ Про биндинг событий в Vue
    ▪ Биндинг событий с обработчиками с помощью директивы v-on
    ▪ Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

  # Разбиение приложения на компоненты
    ▪ Ключевые понятия концепции компонентов
      - Vue-компонент
      - Vue не реализует паттерн MVVP в полной мере
      - Слабая связанность и автономность
      - Повторное использование
      - Репозитории сторонних компонентов
      - Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Пример компактного шаблона приложения, использующего компоненты
    ▪ Создать простейший vue-компонент
    ▪ Использования входных параметров vue-компонента

--------------------------------------

> Ссылки

  # [Официальное руководство] Введение
      https://ru.vuejs.org/v2/guide/

  # Однофайловые компоненты
      https://ru.vuejs.org/v2/guide/single-file-components.html

  # База готовых компонентов и библиотеками
      https://github.com/vuejs/awesome-vue#components--libraries

  # Чем Vue отличается от других фронтенд библиотек/фреймфорков
      https://ru.vuejs.org/v2/guide/comparison.html
  
  # Паттерн MVVM
      https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel
  
> Введение
  - Это обзорное введение в Vue.js.
  - Это не справочник, а обзорная экскурсия.
  - Стараемся зацепить все наиболее важные темы, но поверхностно.

> Что такое Vue.js?
  
  • Описание Vue
    - Vue произносится, как vju:, примерно как view.
    - Это прогрессивный фреймворк для создания пользовательских инетрфейсов.
    - В отличие от фреймворков-монолитов, vue годится для постепенного внедрения.
      Его ядро в 1-ю очередь решает задачи уровня представления (view).
      Что упрощает интеграцию с другими библиотеками и существующими проектами.
    - Vue полностью подходит для создания одностраничных приложений
      (SPA, Single-Page Applications). Помочь в этом может:

        ▪ Применение однофайловых компонентов (см.ссылки).
        ▪ Базы готовых компонентов и библиотек (см.ссылки).

  • Hello World на Vue

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>
      
      // 2. Подготовить шаблон
      <div id="app">
        <p>{{ message }}</p>
      </div> 

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue.js!'
        }
      })

> Немного истории

  • Vue 1 (2013 - 2016)
    - Создателем Vue.js является Evan You, бывший сотрудник Google и Meteor Dev Group.
    - Начал он разрабатывать фреймворк в 2013-м, а в феврале 2014-го состоялся первый публичный релиз.
    - Vue широко используется среди китайских компаний, например: Alibaba, Baidu, Xiaomi, Sina Weibo и др. 
    - Он входит в ядро Laravel и PageKit.
    - Недавно свободная система управления репозиториями GitLab тоже перешла на Vue.js. 
    
  • Vue 2 (2016 - ...)
    - В конце сентября 2016-го вышел в релиз Vue.js 2.0
    - Упор был сделан на производительность.
    - Теперь используется виртуальный DOM.
    - Поддерживается серверный рендеринг, возможность использовать JSX и т.д.
    - Сейчас фреймворк поддерживается только сообществом
      (хотя ходят слухи, что > 50% финансируется alibaba'ой).

> Декларативный рендеринг и реактивный биндинг

  • Что такое декларативный рендеринг
    - Позволяет связывать модель с шаблоном прямо в шаблоне.
    - По тому же принципу работает, например, Knockoutjs.
    - В качестве примера см. Hello World на Vue выше.

  • Что такое реактивный биндинг
    - Когда при изменении значения в модели меняется и значение в шаблоне.
    - По умолчанию применяется 1-направленный биндинг: модель -> шаблон.
    - Но можно использоватьи 2-направленный, с помощью v-model (например, в формах).

  • Пример декларативного рендеринга и реактивного биндинга
    - Этот пример демонстрирует декларативный рендеринг и 
      1-направленный декларативный биндинг.
    - В консоли браузера можно написать:

        app.message = 'test'

    - И новое значение сразу будет отрисовано.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app">
        {{ message }}
      </div>

      // 3. Создать экземпляр Vue
      var app = new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue!'
        }
      })      

  • Пример биндинга атрибута title
    - В примере мы применяем директиву v-bind.
    - И однонаправленно биндим атрибут title со св-вом message в модели.
    - Теперь, при изменении message, будет меняться и title.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-2">
        <span v-bind:title="message">
          Подержи курсор надо мной пару секунд,
          чтобы увидеть динамически связанное значение title!
        </span>
      </div>

      // 3. Создать экземпляр Vue
      var app2 = new Vue({
        el: '#app-2',
        data: {
          message: 'Вот когда вы загрузили эту страницу: ' + new Date()
        }
      })      

> Условия и циклы, transition-эффекты

  • Про условия и циклы в Vue
    - Они работают примерно аналогично knockoutjs`овским.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Управление присутствием эл-та в DOM с помощью v-if
    - Можно менять значение app3.seen на true/false.
    - И тем самым управлять присутствием шаблона в DOM.
    - Директива v-if аналогична директиве if из knockoutjs.
    - При false шаблон просто изчезает из DOM (не путать с display:none).
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-3">
        <p v-if="seen">Сейчас меня видно</p>
      </div>      

      // 3. Создать экземпляр Vue
      var app3 = new Vue({
        el: '#app-3',
        data: {
          seen: true
        }
      })      

  • Пример использования директивы v-for
    - Можно на лету добавить новый элемент в массив todos.
    - Это можно сделать, например, в консоли: app4.todos.push({ text: 'Новый элемент' })
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-4">
        <ol>
          <li v-for="todo in todos">
            {{ todo.text }}
          </li>
        </ol>
      </div>

      // 3. Создать экземпляр Vue
      var app4 = new Vue({
        el: '#app-4',
        data: {
          todos: [
            { text: 'Посадить дерево' },
            { text: 'Построить дом' },
            { text: 'Вырастить сына' }
          ]
        }
      })

  • Пример использования v-if с transition-эффектом
    - Vue имеет встроенную систему анимации, которая применяет transition-эффекты.
    - В этом примере мы меняем значение v-if нажатием кнопки.
    - Благодаря transition-эффекту эл-т плавно появляется/исчезает.
    - Можно также назначать JS-хуки, которые будут вызваны в нужные моменты времени.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="demo">
        <button v-on:click="show = !show">
          Переключить
        </button>
        <transition name="fade">
          <p v-if="show">hello</p>
        </transition>
      </div>    

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#demo',
        data: {
          show: true
        }
      }) 

      // 4. Подготовить CSS
      .fade-enter-active, .fade-leave-active {
        transition: opacity .5s
      }
      .fade-enter, .fade-leave-to /* .fade-leave-active для <2.1.8 */ {
        opacity: 0
      }

> Работа с событиями, 2-сторонний биндинг эл-в формы

  • Про биндинг событий в Vue
    - С точки зрения использования, всё работает, как knockoutjs.
    - Можно назначать обработчики событий для элементов.
    - Можно делать 2-сторонний биндинг с элементами формы типа input, textarea и т.д.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Биндинг событий с обработчиками с помощью директивы v-on
    - С помощью v-on можно связать событие на элементе с обработчиком.
    - Например, свяжем событие click на эл-те с функцией-обработчиком:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-5">
        <p>{{ message }}</p>
        <button v-on:click="reverseMessage">Обратить порядок букв в сообщении</button>
      </div>

      // 3. Создать экземпляр Vue     
      var app5 = new Vue({
        el: '#app-5',
        data: {
          message: 'Hello Vue.js!'
        },
        methods: {
          reverseMessage: function () {
            this.message = this.message.split('').reverse().join('')
          }
        }
      })

  • Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-6">
        <p>{{ message }}</p>
        <input v-model="message">
      </div>

      // 3. Создать экземпляр Vue
      var app6 = new Vue({
        el: '#app-6',
        data: {
          message: 'Hello Vue!'
        }
      })

> Разбиение приложения на компоненты

  • Ключевые понятия концепции компонентов

    ▪ Vue-компонент
      - Концепция Vue изначально предполагает использование компонентов.
      - В Vue, компонент — это, по сути, экземпляр Vue с предустановленными опциями. 
      - Эта абстракция позволяет собирать большие приложения из малых кусочков.
      - Почти любой интерфейс может быть представлен, как дерево компонентов.

    ▪ Vue не реализует паттерн MVVP в полной мере
      - Речь идёт о паттерне Model–view–viewmodel.

    ▪ Слабая связанность и автономность
      - Связь между компонентами должна отсутствовать.
      - Каждый компонент должн быть в MAX степени автономен.

    ▪ Повторное использование
      - Компоненты представляют собой пригодные к повторному использованию объекты.
      - Ведь они слабо связаны друг с другом, и м.б. перенесены в другой проект/место проекта.

    ▪ Репозитории сторонних компонентов
      - Благодаря компонентной концепции могут быть созданы репозитории компонентов.
      - Теперь не надо писать всё самому, можно использовать сторонние компоненты.

    ▪ Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Разработкой компонентной системы намного легче управлять.
      - Можно разбить её на дерево мелких автономных компонентов.
      - Для разработки каждого компонента написать чёткое тех.задание.
      - И раздать подряды на разработку большому кол-ву разработчиков.
      - Это позволит кардинально увеличить скорость разработки фронтенда проекта.
      - Относиться к каждому компоненту, можно как к чёрному ящику.
      - У которого есть входы и выходы (но код инспектировать всё равно нужно).

    ▪ Пример компактного шаблона приложения, использующего компоненты
      - В крупных приложениях разделение на компоненты очень важно.
      - Это становится обязательным условием для сохранения управляемости процесса разработки.
      - Вот, как бы мог выглядеть шаблон приложения, использующего компоненты:

          <div id="app">
            <app-nav></app-nav>
            <app-view>
              <app-sidebar></app-sidebar>
              <app-content></app-content>
            </app-view>
          </div>

      - Как видно, на верхнем уровне находится блок с id="app".
      - А далее, считай, что просто идёт дерево компонентов.

  • Создать простейший vue-компонент
    - Это чисто для демонстрации концепции.
    - Код:

      // Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        template: '<li>Это todo</li>'
      })

      // Использовать компонент todo-item в шаблоне другого компонента
      <ul>
        <!-- Создаём экземпляр компонента todo-item -->
        <todo-item></todo-item>
      </ul>      

  • Использования входных параметров vue-компонента
    - Это расширение предыдущего примера.
    - Здесь мы добавляем компоненту todo-item принимать входящий параметр.
    - Для этого в определении компонента мы используем св-во props.
    - В нём перечисляются параметры, которые может принимать компонент.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
      })

      // 3. Подготовить шаблон
      // - В этом шаблоне мы и применяем наш компонент todo-item.
      // - Применяем директивы v-for прямо на компонент, которая пробегает
      //   массив groceryList из модели приложения.
      // - Далее с помощью v-bind связываем item массива с параметром todo компонента.
      // - И также с помощью v-bind связываем индекс с item.id.
      <div id="app-7">
        <ol>
          <!--
            Теперь мы можем передать каждому компоненту todo объект
            с информацией о задаче, который будет динамически меняться.
            Мы также определяем для каждого компонента "key",
            значение которого будет объяснено далее в руководстве.
          -->
          <todo-item
            v-for="item in groceryList"
            v-bind:todo="item"
            v-bind:key="item.id">
          </todo-item>
        </ol>
      </div>

      // 4. Создать экземпляр Vue
      var app7 = new Vue({
        el: '#app-7',
        data: {
          groceryList: [
            { id: 0, text: 'Овощи' },
            { id: 1, text: 'Сыр' },
            { id: 2, text: 'Что там ещё люди едят?' }
          ]
        }
      })      


А4. Экземпляр Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Конструктор Vue
    ▪ Модель приложения / корневой экземпляр Vue
    ▪ Опции по умолчанию для компонента / расширение конструктора Vue
    ▪ Экземпляры компонентов рекомендуется создавать декларативно

  # Свойства и методы
    ▪ Vue-экземпляр проксирует все св-ва из объекта data
      - Что значит проксирует?
      - Что значит проксирует ссылки?
    ▪ Все проксируемые свойства из data являются реактивными
    ▪ Vue-экземпляр содержит встроенные св-ва/методы, начинающиеся с $
    ▪ Не используй стрелочные функции в св-вах экземпляра и колбэках!

  # Хуки жизненного цикла экземпляра

    ▪ Последовательность шагов при инициализации экземпляра
    ▪ Хуки жизненного цикла
    ▪ Хуки вызываются с контекстной переменной this
    ▪ Контроллеров в Vue не существует

  # Диаграмма жизненного цикла vue-экземпляра

--------------------------------------

> Ссылки

  # [Официальное руководство] Экземпляр Vue
      https://ru.vuejs.org/v2/guide/instance.html

> Введение
  - Vue не реализует полностью паттерн MVVM, но его архитектура вдохновлена им.
  - Поэтому, традиционно, переменная с экземпляром Vue называется vm (от ViewModel).
  - Грубо говоря, экземпляр Vue - это объект с Vue-моделью.
  - В knockoutjs я привык называть это просто "модель".
  - В этой главе речь пойдёт об общих свойствах моделей в Vue.
  - Таких, как: конструктор, св-ва и методы, хуки и жизненный цикл.

> Конструктор Vue

  • Модель приложения / корневой экземпляр Vue
    - Корневой экземпляр обычно создаётся императивно.
    - При создании в него передаётся объект с опциями.
    - В нём - данные, шаблон, DOM-элемент, методы, хуки жизненного цикла и т.д.
    - Например:

        var vm = new Vue({
          // опции
        })

  • Опции по умолчанию для компонента / расширение конструктора Vue
    - Допустим, у нас есть какой-то компонент.
    - И нам его надо много раз создавать императивно в приложении.
    - И напрягает, что каждый раз надо передавать объект с опциями.
    - Чтобы этого не делать, можно задать объект с опциями по умолчанию.
    - Для этого надо расширить конструктор vue.
    - Например:

        // Задать опции по умолчанию для компонента, расширив его конструктор
        var MyComponent = Vue.extend({
          // опции компонента
        })    

        // Теперь все экземпляры этого компонента используют опции по умолчанию
        var myComponentInstance = new MyComponent()

  • Экземпляры компонентов рекомендуется создавать декларативно
    - Выше продемонстрирован пример императивного создания экземпляра компонента.
    - Однако, автор рекомендует создавать их декларативно.
    - Т.Е., как пользовательские HTML-элементы в шаблонах.
    - Подробнее об этом см.главу про Vue-компоненты.
    - А пока запомни: все Vue-компоненты являются расширенными Vue-экземплярами.

> Свойства и методы

  • Vue-экземпляр проксирует ссылки всех св-в из объекта data
    
    ▪ Что значит проксирует?
      - То есть, они становятся напрямую свойствами модели.
      - Вместо vm.data.prop надо писать просто vm.prop
      - Пояснение на примере:

          // Подготовим data и создаим vue-экземпляр
          var data = { a: 1 }
          var vm = new Vue({
            data: data
          })

          // Удостоверимся в написанном выше
          vm.a === data.a   // true

    ▪ Что значит проксирует ссылки?
      - Значит, что vm.a и data.a содержат одну и ту же ссылку.
      - Т.Е. меняя значение в модели, мы меняем его в исходном объекте data.
      - Примеры для иллюстрации этого:

          // установка свойства также влияет на оригинальные данные
          vm.a = 2
          data.a      // 2

          // ... и наоборот
          data.a = 3
          vm.a        // 3  

  • Все проксируемые свойства из data являются реактивными
    - Т.Е. при изменении их значений автоматом меняется и представление.
    - Однако, реактивными они становятся при создании экземпляра.
    - Добавление новых св-в в data после создания экземпляра не сделает их реактивными.
    - Хотя, есть возможность добавлять реактивные св-ва во вложенные объекты.
    - В общем, подробнее о рекативности читай в главе про реактивность.

  • Vue-экземпляр содержит встроенные св-ва/методы, начинающиеся с $
    - С $ они начинаются, чтобы отличаться от пользовательских.
    - Например, ссылка на объект data лежит в vm.$data,
      а ссылка на DOM-элемент лежит в $el,
      а коллбэк на изменение св-ва можно задать методом $watch.
    - Полный список встроенных св-в и методов см. в главе-справочнике API.
    - Проиллюстрируем на примере:

        // Подготовим data и создаим vue-экземпляр
        var data = { a: 1 }
        var vm = new Vue({
          el: '#example',
          data: data
        })

        // Собственно, иллюстрация
        vm.$data === data                             // true
        vm.$el === document.getElementById('example') // true

        // $watch — это метод экземпляра
        vm.$watch('a', function (newVal, oldVal) {
          // этот коллбэк будет вызван, когда изменится `vm.a`
        })

  • Не используй стрелочные функции в св-вах экземпляра и колбэках!
    - Например: vm.$watch('a', newVal => this.myMethod())
    - Потому что СФ связываются с родительским контекстом (this).
    - Соответственно, this внутри не будет указывать на vue-экземпляр.
    - И, например, this.myMethod будет undefined.

> Хуки жизненного цикла экземпляра

  • Последовательность шагов при инициализации экземпляра
    - Каждый vue-экземпляр проходит при создании некий процесс.
    - Процесс представляет собой последовательность задач инициализации.
    - Например:

      ▪ Настройка наблюдения за данными.
      ▪ Компиляция шаблона.
      ▪ Монтаж экземпляра в DOM.
      ▪ Обновление DOM при изменении данных.
      ▪ .. и прочие ..

  • Хуки жизненного цикла
    - Всё имеет своё начало, и свой конец. И vue-экземпляр тоже.
    - По мере путешествия экземпляра по жизненному циклу, 
      он на каждом шагу генерирует события.
    - Например: created, mounted, updated, destroyed, и т.д.
    - Соответственно, можно назначать обработчики для этих хуков.
    - Например, назначим обработчик, который вызывается после создания экземпляра:

        var vm = new Vue({
          data: {
            a: 1
          },
          created: function () {
            // `this` указывает на экземпляр vm
            console.log('Значение a: ' + this.a)
          }
        })
        // -> "Значение a: 1"

  • Хуки вызываются с контекстной переменной this
    - Она содержит ссылку на вызывающий vue-экземпляр.

  • Контроллеров в Vue не существует
    - Впрочем, как и в knockoutjs.
    - Наверное, они есть в angular? [примечание автора методички].
    - В общем, всё польз.поведение компонента должно быть в этих хуках.

> Диаграмма жизненного цикла vue-экземпляра

              
                       new Vue()
                          |
   [событие] beforeCreate |
                          |
                     Observe Data 
                          |
        [событие] created |
                          | 
                      Init Events
                          |                  
                          |                  
                          |                  
                  Есть ли опция "el"? -------
                          |                 |
                       Да |                 | - Vue ждёт, пока vm.$mount(el) будет вызвана вручную
                          |                 |
                Есть ли опция "template"?----
                          |
                          |
             ---------------------------
          Да |                         | Нет
             |                         | 
      Скомпилировать             Взять outerHTML
      этот template              в качестве шаблона,
             |                   и скомпилировать его
             |                         |
             ---------------------------
                          |
    [событие] beforeMount |
                          |
                   Создать vm.$el и
                   заменить содержимое
                   el скомпилированным
                          | 
        [событие] mounted | 
                          |   При изменении
                         /|\  данных
                        /   \   /------>------ 
                       / См- \ /             | - [событие] beforeUpdate            
                      / онти- \              |
                     / рованн- \        Ререндеринг
                    / ое состо- \       виртуального DOM
                    \ яние Vue- /            |
                     \ компон- /             | - [событие] updated
                      \ ента  /--------<------
                       \     /
                        \   /
                         \|/
                          |
                          |
                Если вызван встроенный
                метод vm.$destroy()
                          |
  [событие] beforeDestroy |
                          |
                  Завершение работы
                  вотчеров, дочерних
                  компонентов и 
                  обработчиков событий
                          | 
                          | 
                         /|\ 
                        /   \ 
                       / Ун- \ 
                      / ичто- \  
                     / женный  \ 
                    / Компонент \
                    \           /
                     \         / 
                      \       /
                       \     /
                        \   /
                         \|/ 
                          | 
      [событие] destroyed | 
                          |
                        -----
 
 
А5. Синтаксис шаблонов
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
    ▪ Модель с DOM в Vue связывается через HTML
    ▪ Шаблоны Vue являются валидным HTML-кодом
    ▪ Использование виртуального DOM
    ▪ Можно использовать свою render-функцию
 
  # Интерполяции (компиляция всяких vue-подстановок из шаблона в HTML)
    ▪ Подстановка через {{ }}, или @{{ }} для Blade
      - Связать св-во с DOM
      - v-once: связать св-во с DOM, но не обновлять DOM при его изменении
      - Использование js-выражения внутри {{ }}
      - Содержимое {{ }} подставляется, как текст, а не HTML
    
    ▪ Подстановка сырого HTML
      - Директива v-html
      - Нельзя использовать v-html для вложения шаблонов друг в друга
      - Подставляй только доверенный HTML
    
    ▪ Подстановка атрибутов: v-bind
 
  # Директивы
    ▪ В общем про директивы
    ▪ Атрибуты директив
    ▪ Модификаторы директив
    ▪ Фильтры в интерполяциях {{ }} и директиве v-bind
      - Фильтры форматирую текст
      - Фильтры можно определить в объекте filters в корне модели
      - Фильтры можно чейнить
      - Фильтры могут принимать параметры    
    ▪ Сокращения директив

--------------------------------------

> Ссылки

  # [Официальное руководство] Синтаксис шаблонов
      https://ru.vuejs.org/v2/guide/syntax.html

> Введение
  
  • Модель с DOM в Vue связывается через HTML
    - Аналогичный подход используется и в knockout.

  • Шаблоны Vue являются валидным HTML-кодом
    - Его могут распарсить все HTML-парсеры и браузеры.
 
  • Использование виртуального DOM
    - Vue компилирует шаблоны в функции рендера виртуального DOM.
    - При изменении состояния приложения система реактивности
      определяет MIN набор компонентов для повторного рендеринга.
    - А виртуальный DOM определяет минимальные изменения уже внутри них.
 
  • Можно использовать свою render-функцию
    - То есть, сгенерировать HTML с помощью низкоуровневого JS.
    - Для этого нужно добавить в vue-компонент свойство render.
    - А в него положить функцию, которая должна вернуть созданный элемент.
    - Обычно вместо этого применяются vue-шаблоны.
    - Но могут быть случаи, когда удобнее использовать render-функцию.
    - Подробнее о render-функциях читай в соответствующей главе.

> Интерполяции (компиляция всяких vue-подстановок из шаблона в HTML)

  • Подстановка через {{ }}, или @{{ }} для Blade
 
    ▪ Связать св-во с DOM
      - msg будет заменено на значение св-ва msg из модели.
      - Имеется в виду модель vue-компонента, в чьём шаблоне эта интерполяция.
      - DOM будет обновляться при изменении значения св-ва в модели.

        <span>Сообщение: {{ msg }}</span>     | - в обычном случае
        <span>Сообщение: @{{ msg }}</span>    | - в Blade (Laravel)

    ▪ v-once: связать св-во с DOM, но не обновлять DOM при его изменении
      - Допустим, надо подставить значение лишь при загрузке.
      - А при изменении значения в модели, DOM не менять.
      - Для этого и можно применить директиву v-once:

          <span v-once>Это сообщение никогда не изменится: {{ msg }}</span>

    ▪ Использование js-выражения внутри {{ }}
      - Внутри {{ }} можно использовать и js-выражение.
      - Оно будет вычислено, и будет возвращён его результат.
      - Вычисление будет производиться в контексте модели vue-экземпляра.
      - Выражения имеют доступ лишь к ограниченному списку глобальных объектов,
        таких как Math и Date. Поэтому, получить доступ к пользовательским
        глобальным объектам не получится.
      - Примеры:

          {{ number + 1 }}
          {{ ok ? 'YES' : 'NO' }}
          {{ message.split('').reverse().join('') }}
          <div v-bind:id="'list-' + id"></div>

    ▪ Содержимое {{ }} подставляется, как текст, а не HTML
      - А для вывода HTML используй директиву v-html.

  • Подстановка сырого HTML
    
    ▪ Директива v-html
      - Производится с помощью директивы v-html.
      - Например:

          <div v-html="rawHtml"></div>

    ▪ Нельзя использовать v-html для вложения шаблонов друг в друга
      - Так как движок шаблонов Vue не основывается на строках.
      - Вместо этого надо использовать vue-компоненты.

    ▪ Подставляй только доверенный HTML
      - Не подставляй контент, сгенерированный пользователем.
      - Это может привести к XSS-уязвимостям.

  • Подстановка атрибутов: v-bind
    - Синтаксис {{ }} не работает с атрибутами.
    - Для подстановки последних используй директиву v-bind
    - Например, свяжем атрибут id со св-вом модели dynamicId: 

        <div v-bind:id="dynamicId"></div>

    - При этом dynamicId также может быть и булевым значением.
    - В случае, если оно равно true, то будет атрибут без значения.
    - А если false, то атрибут будет удалён полностью.
    - Например:

        <button v-bind:disabled="isOn">Кнопка</button>
        <button disabled>Кнопка</button>  | если isOn == true
        <button>Кнопка</button>           | если isOn == false

> Директивы

  • В общем про директивы
    - Директивы, это специальный атрибуты с префиксом v-
    - Принцип работу у них похож на их аналоги data-bind из knockoutjs.
    - В качестве значения v- директивы принимают 1-но js-выражение (за исключением v-for).
    - Это выражение выполняется в контексте модели соответствующего vue-экземпляра.
    - Директива реактивно применяет к DOM изменения при обновлении этого выражения.
    - Например, эта директива удалит/вставит элемент в DOM в зависимости
      от значения св-ва seen в модели vue-компонента:

        <p v-if="seen">Сейчас меня видно</p>

  • Атрибуты директив
    - Некоторые директивы могут принимать аргумент через двоеточие.
    - Примеры: 

        <a v-bind:href="url"></a>     | связать атрибут href со св-вом url модели
        <a v-on:click="doSomething">  | назначить обработчик doSomething события click для элемента

  • Модификаторы директив
    - Это особые постфиксы, добавляемые после точки.
    - Они приказывают провести биндинг особым образом.
    - Пример:

        <form v-on:submit.prevent="onSubmit"></form>  | предотвратить действия браузера по умолчанию при обработке события

  • Фильтры в интерполяциях {{ }} и директиве v-bind
    
    ▪ Фильтры форматирую текст
      - Речь идёт о форматировании текста.
      - Фильтр добавляется в конце js-выражения, и отделяется вертикальной чертой.
      - Например:

          {{ message | capitalize }}
          <div v-bind:id="rawId | formatId"></div>

    ▪ Фильтры можно определить в объекте filters в корне модели
      - Надо добавлять в этот объект св-ва со значениями-функциями.
      - 1-ым аргументом такая функция получит значение js-выражения.
      - Например, определим фильтр capitalize:

          new Vue({
            // ...
            filters: {
              capitalize: function (value) {
                if (!value) return ''
                value = value.toString()
                return value.charAt(0).toUpperCase() + value.slice(1)
              }
            }
          })

    ▪ Фильтры можно чейнить
      - Например:

          {{ message | filterA | filterB }}

    ▪ Фильтры могут принимать параметры
      - Они пойдут со 2-го аргумента и далее (т.к. в 1-й передаётся значение js-выражения).
      - Например:

          {{ message | filterA('arg1', arg2) }}      

  • Сокращения директив

    ▪ Зачем нужны сокращения
      - Для тех, кому лень написать несколько лишних символов.
      - В Vue есть сокращения для директив v-bind и v-on.
      - Сокращение производится через : и @ соотственно.
      - Символы : и @ валидны во всех современных браузерах.
      - В итоговой разметке они не появляются.

    ▪ Сокращение для v-bind через :
 
        <a v-bind:href="url"></a>         | полный синтаксис
        <a :href="url"></a>               | сокращение
 
    ▪ Сокращение для v-on через @

        <a v-on:click="doSomething"></a>  | полный синтаксис   
        <a @click="doSomething"></a>      | сокращение
 
 
А6. Вычисляемые свойства и слежение 
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Концепция вычисляемой
  # Отличие Vue-вычисляемых от Knockout-вычисляемых

    ▪ Что было в Knockout с вычисляемой?
    ▪ Метод в Vue соответствует вычисляемой в Knockout
    ▪ Vue-вычисляемая, как метод, только значение её кэшируется

  # Пример вычисляемого свойства
  # Пример использования метода вместо вычисляемой
  # Альтернатива наблюдаемым: слежение за св-ми с помощью watch

    ▪ Суть применения watch
    ▪ Доступ к объекту watch через переменную модели
    ▪ Пример применения watch
      - Решение через наблюдаемую
      - Решение через метод
      - Решение через watch

  # Запись в наблюдаемые: сеттеры

    ▪ Редко когда надо писать в наблюдаемые
    ▪ Как настроить наблюдаемую, чтобы в неё можно было писать

  # Как ограничить частоту выполнения наблюдаемых?

    ▪ Проблемы с производительностью наблюдаемых
    ▪ В Vue вместо наблюдаемой: метод + watch
    ▪ Ограничение частоты выполнения 

--------------------------------------

> Ссылки

  # [Официальное руководство] Вычисляемые свойства и слежение 
      https://ru.vuejs.org/v2/guide/computed.html

> Введение
  - Вычисляемые в Vue чуток отличаются от оных в Knockout.
  - Но концепция остаётся прежней.
  
> Концепция вычисляемой
  - Как упоминалось в А5, в {{ }} и директивы можно вставлять 1-но js-выражение.
  - И при изменении задействованных в нём св-в модели, оно будет перевычисляться.
  - И соответствующий DOM будет обновлятсья.
  - Но держать в HTML много кода неудобно.
  - Проще добавить в модель вычисляемое св-во, а в HTML уже его вставить.

> Отличие Vue-вычисляемых от Knockout-вычисляемых

  • Что было в Knockout с вычисляемой?
    - В knockout значение вычисляемой не кэшируется.
    - Её можно использовать в шаблоне, она будет реактивна.
    - А вот метод в knockout при подстановке в шаблон реактивен 
      не был, и срабатывал только 1 раз при загрузке.

  • Метод в Vue соответствует вычисляемой в Knockout
    - Его значение не кэшируется, как и Knockout-вычисляемой.
    - Его можно использовать в шаблоне, и он реактивен.

  • Vue-вычисляемая, как метод, только значение её кэшируется
    - Оно не меняется при запросах к вычисляемой.
    - А меняется только, когда меняются значения наблюдаемых,
      которые присутствуют в функции этой вычисляемой.
    - Это позволяет улучшить производительность, когда от
      этой вычисляемой зависит много других.

> Пример вычисляемого свойства

  • Описание
    - Определяем обычное свойство message.
    - Определяем вычисляемое св-во reversedMessage.
    - В ф-ии выч-го св-ва возвращаем реверс-значение текущего св-ва message.
    - При изменении message будет меняться и значение вычисляемого св-ва.
    - В шаблоне можно использовать вычисляемое также, как и обычное св-во.
    - Короче говоря, тоже самое, что и в knockoutjs.

  • Шаблон
    <div id="example">
      <p>Изначальное сообщение: "{{ message }}"</p>
      <p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
    </div>  

  • Модель
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Привет'
      },
      computed: {
        // геттер вычисляемого значения
        reversedMessage: function () {
          // `this` указывает на экземпляр vm
          return this.message.split('').reverse().join('')
        }
      }
    })

  • Результат

    Привет
    тевирП

> Пример использования метода вместо вычисляемой

    // 1. Подключить UMD-сборку Vue из CDN
    <script src="https://unpkg.com/vue"></script>

    // 2. Подготовить шаблон
    <div id="example">
      <p>Сообщение задом наперёд: "{{ reverseMessage() }}"</p>
    </div>

    // 3. Определить новый компонент
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Привет'
      },
      methods: {
        reverseMessage: function () {
          return this.message.split('').reverse().join('')
        }
      }
    })

    // 4. Меняем значение св-ва из метода, чтобы проверить, изменится ли DOM (да)
    vm.message = 'Привет1';

> Альтернатива наблюдаемым: слежение за св-ми с помощью watch

  • Суть применения watch
    - В модель можно добавить объект watch.
    - В него добавлять колбэки.
    - Ключами должны служить св-ва из data, за которыми надо следить.
    - Соотв.колбэк будет срабатывать при изменении этого свойства.
    - И, например, менять какое-то 3-е св-во.

  • Доступ к объекту watch через переменную модели
    - vm.$watch

  • Пример применения watch
    - Например, есть у нас 3 св-ва: name, surname, fullname.
    - Как получать fullname? Один вариант: метод или наблюдаемая.
    - Другой вариант: watch. Следить за name и surname.
    - И вызывать колбэк, меняющий fullname, при изменении последних.
    - Код:

      ▪ Решение через наблюдаемую

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName() }}</div>

        // 3. Определить новый компонент
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          methods: {
            fullName: {
              fullName: function () {
                return firstName + ' ' + lastName
              }
            }
          }
        })

      ▪ Решение через метод

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName }}</div>

        // 3. Определить новый компонент
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          methods: {
            fullName: function () {
              return this.firstName + ' ' + this.lastName
            }
          }
        });     

      ▪ Решение через watch

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName }}</div>

        // 3. Определить новый компонент под названием todo-item
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar',
            fullName: 'Foo Bar'
          },
          watch: {
            firstName: function (val) {
              this.fullName = val + ' ' + this.lastName
            },
            lastName: function (val) {
              this.fullName = this.firstName + ' ' + val
            }
          }
        })      

> Запись в наблюдаемые: сеттеры

  • Редко когда надо писать в наблюдаемые
    - Я использовал Knockout пару лет.
    - Там тоже можно записывать в наблюдаемую, если надо.
    - Но за всё время не было ни 1 случая, когда это понадобилось.
    - Думаю, аналогичная ситуация ждёт и в Vue.
    - Поэтому, по умолчанию в Vue и можно лишь читать из наблюдаемой.
    - Но, при необходимости, можно настроить её и на запись.
   
  • Как настроить наблюдаемую, чтобы в неё можно было писать
    - На примере:

        computed: {
          fullName: {
            // геттер:
            get: function () {
              return this.firstName + ' ' + this.lastName
            },
            // сеттер:
            set: function (newValue) {
              var names = newValue.split(' ')
              this.firstName = names[0]
              this.lastName = names[names.length - 1]
            }
          }
        }

> Как ограничить частоту выполнения наблюдаемых?

  • Проблемы с производительностью наблюдаемых
    - У меня есть большой опыт работы с наблюдаемыми в Knockout.
    - В том числе, с очень большим SPA, в которых десятки наблюдаемых.
    - В том SPA от при изменении наблюдаемых перерисовывался и DOM.
    - А перерисовывание DOM операция достаточно тяжёлая.
    - И если очень-очень часто дёргать наблюдаемую, всё жёстко лагало.
    - Выходом было ограничение частоты выполнения наблюдаемых.
    - В этом разделе описано, как это осуществить в Vue с помощью библиотеки loadash.

  • В Vue вместо наблюдаемой: метод + watch 
    - В Vue с наблюдаемой это провернуть не выйдет.
    - Придётся использовать метод + watch + lodash.

  • Ограничение частоты выполнения 
    - В данном примере выполняется ajax-запрос в ответ
      на ввод текста пользователем в input.
    - Но не выполнять же запрос при каждом нажатии?
    - С помощью метода, watch и lodash мы ограничиваем
      MAX частоту отправки ajax-запроса.
    - Конкретно, используется метод _.debounce из lodash.
    - Он будет срабатывать спустя указанное кол-во ms (500)
      после последего запроса к методу.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>    

      // 2. Подготовить шаблон
      <div id="watch-example">
        <p>
          Задайте вопрос, на который можно ответить "да" или "нет":
          <input v-model="question">
        </p>
        <p>{{ answer }}</p>
      </div>

      // 3. Подключить либы, определить новый компонент
      <!-- Поскольку уже существует обширная экосистема ajax-библиотек  -->
      <!-- и библиотек функций общего назначения, ядро Vue может        -->
      <!-- оставаться маленьким и не изобретать их заново. Кроме того,  -->
      <!-- это позволяет вам использовать только знакомые инструменты. -->
      <script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
      <script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
      <script>
      var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
          question: '',
          answer: 'Пока вы не зададите вопрос, я не могу ответить!'
        },
        watch: {
          // эта функция запускается при любом изменении вопроса
          question: function (newQuestion) {
            this.answer = 'Ожидаю, когда вы закончите печатать...'
            this.getAnswer()
          }
        },
        methods: {
          // _.debounce — это функция из lodash, позволяющая ограничить
          // то, насколько часто может выполняться определённая операция.
          // В данном случае, мы хотим ограничить частоту обращений к yesno.wtf/api,
          // дожидаясь завершения печати вопроса перед тем как послать ajax-запрос.
          // Чтобы узнать больше о функции _.debounce (и её родственнице _.throttle),
          // см. документацию: https://lodash.com/docs#debounce
          getAnswer: _.debounce(
            function () {
              if (this.question.indexOf('?') === -1) {
                this.answer = 'Вопросы обычно заканчиваются вопросительным знаком. ;-)'
                return
              }
              this.answer = 'Думаю...'
              var vm = this
              axios.get('https://yesno.wtf/api')
                .then(function (response) {
                  vm.answer = _.capitalize(response.data.answer)
                })
                .catch(function (error) {
                  vm.answer = 'Ошибка! Не могу связаться с API. ' + error
                })
            },
            // Это число миллисекунд, которое мы ждём, после того как пользователь прекратил печатать:
            500
          )
        }
      })
      </script>


А7. Работа с CSS: классы и стили

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

    ▪ Управление стилями и классами в Vue
    ▪ Директива class
    ▪ Директива style

  # Управление классами через объект

    ▪ Передача объекта прямо в шаблоне
    ▪ Vue оставляет оригинальное содержимое class без изменений
    ▪ Передача объекта из модели
    ▪ Передача объекта из наблюдаемой

  # Управление классами через массив

    ▪ Массив вместо объекта
    ▪ Тернарный оператор для переключеняи классов в массиве
    ▪ Смешанный стиль: массив + объект

  # Vue-компоненты и директива class

    ▪ Директива class добавляет стили корневому эл-ту компонента
    ▪ Собственные класы компонента потеряны не будут
    ▪ Пример применения class к компоненту

  # Управление inline-стилями в Vue

    ▪ Решай сам: camelCase или kebab-case
    ▪ Управление стилями через объект
    ▪ Используем наблюдаемый объект
    ▪ Управление стилями через массив: применить несколько объектов стилей
    ▪ Vue сам добавляет вендорные префиксы
    ▪ Последнее значение, поддерживаемое в браузере

--------------------------------------

> Ссылки

  # [Официальное руководство] Работа с классами и стилями
      https://ru.vuejs.org/v2/guide/class-and-style.html

> Введение

  • Управление стилями и классами в Vue
    - В Vue для работы с классами и стилями есть директивы class и style.
    - Хотя, как грубый инструмент, можно использовать и v-bind,
      и работать с классами, как с атрибутами. 

  • Директива class
    - Позволяет с удобствами управлять классами в Vue.

  • Директива style
    - Позволяет с удобствами управлять инлайновыми стилями в Vue.

> Управление классами через объект

  • Передача объекта прямо в шаблоне

    <div v-bind:class="{ active: isActive }"></div>

  • Vue оставляет оригинальное содержимое class без изменений
  
    ▪ Что имеется в виду?
      - У div в шаблоне ниже определён атрибут class.
      - У него есть значение "static".
      - Что будет, если использовать v-bind:class?
      - Атрибут class никуда не денется, он НЕ затирается.

    ▪ Шаблон

      <div class="static"
           v-bind:class="{ active: isActive, 'text-danger': hasError }">
      </div>

    ▪ Фрагмент JS с данными модели

      data: {
        isActive: true,
        hasError: true
      }  

    ▪ Что после рендеринга?

      <div class="static isActive hasError"</div>      

  • Передача объекта из модели
    - Объект не обязательно писать прямо в шаблоне.
    - Его можно поместить в модель, и передать оттуда.
    - Например:

      ▪ Шаблон

        <div v-bind:class="classObject"></div>   

      ▪ Фрагмент JS с данными модели

        data: {
          classObject: {
            active: true,
            'text-danger': false
          }
        }      

  • Передача объекта из вычисляемой
    - Можно также использовать и вычисляемую.
    - Вместо наблюдаемого объекта, как из предыдущего пункта.
    - Например:

      ▪ Шаблон

        <div v-bind:class="classObject"></div>

      ▪ Фрагмент JS с данными модели

        data: {
          isActive: true,
          error: null
        },
        computed: {
          classObject: function () {
            return {
              active: this.isActive && !this.error,
              'text-danger': this.error && this.error.type === 'fatal',
            }
          }
        }  

> Управление классами через массив
  
  • Массив вместо объекта
    - Можно вместо объекти использовать и массив.
    - Например:

      ▪ Шаблон
        
        <div v-bind:class="[activeClass, errorClass]">

      ▪ Фрагмент JS с данными модели

        data: {
          activeClass: 'active',
          errorClass: 'text-danger'
        }        
            
  • Тернарный оператор для переключеняи классов в массиве
    - В случае с объектом мы писали что-то типа: {active: isActive}.
    - А в случае с объектом можно использовать тернарный оператор:

      <div v-bind:class="[isActive ? activeClass : '', errorClass]">

  • Смешанный стиль: массив + объект
    - Для истинных ценителей:

      <div v-bind:class="[{ active: isActive }, errorClass]">

> Vue-компоненты и директива class

  • Директива class добавляет стили корневому эл-ту компонента
    - Если применить эту директиву к самому компоненту.

  • Собственные класы компонента потеряны не будут
    - Ситуация аналогичная, как и с не-компонентами.

  • Пример применения class к компоненту

    ▪ Компонент

      Vue.component('my-component', {
        template: '<p class="foo bar">Hi</p>'
      })

    ▪ Если указать доп.классы с помощью атрибута class
      - То они просто добавятся к указанным в шаблоне.
        
        <my-component class="baz boo"></my-component>
      
      - В результате будет: 
        
        <p class="foo bar baz boo">Hi</p>

    ▪ Если применить директиву v-bind:class
      - То, если isActive == true, он добавится к указанным в шаблоне.
      - Например:

        <my-component v-bind:class="{ active: isActive }"></my-component>

      - В результате будет: 

        <p class="foo bar active">Hi</p>

> Управление inline-стилями в Vue

  • Решай сам: camelCase или kebab-case
    - В Vue можно применять и тот, и другой стиль.
    - Но при использовании kebab-case не забывай про кавычки.
    - Например:

      <div v-bind:style="{ fontSize: fontSize + 'px', "font-size": fontSize + 'px' }"></div>

  • Управление стилями через объект

    ▪ Используем наблюдаемые
      - Передаём в директиву объект прямо в шаблоне.
      - Используем наблюдаемые для задания значений.
      - Код:

        ▪ Шаблон

          <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
       
        ▪ Фрагмент JS с данными модели

          data: {
            activeColor: 'red',
            fontSize: 30
          }

    ▪ Используем наблюдаемый объект
      - Передаём в директиву наблюдаемый объект.
      - А его свойства уже содержат инфу о стилях.
      - Код:

        ▪ Шаблон

          <div v-bind:style="styleObject"></div> 

        ▪ Фрагмент JS с данными модели

          data: {
            styleObject: {
              color: 'red',
              fontSize: '13px'
            }
          }      

  • Управление стилями через массив: применить несколько объектов стилей
    - Можно директиве передать массив объектов.
    - Тем самым, применив к эл-ту несколько объектов стилей.
    - Например:

        <div v-bind:style="[baseStyles, overridingStyles]">

  • Vue сам добавляет вендорные префиксы
    - Об этом паритсья не нужно.

  • Последнее значение, поддерживаемое в браузере
    - Часто разные браузеры не поддерживают кое-какие значения.
    - Поэтому, в версии 2.3 в Vue добавили эту фичу.
    - В примере ниже будет использовано последне значение,
      которое поддерживает браузер, где это выполнится:

        <div v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }">

А8. Условный рендеринг

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # v-if

    ▪ v-if и v-else
    ▪ Условные группы с v-if и <template>
    ▪ v-else
    ▪ v-else-if
    ▪ Управление повторным использованием эл-в с помощью key
      - Пример переиспользования DOM-элемента в Vue
      - Запретить Vue переиспользовать DOM-элементы спомощью key

  # v-show
  # v-if VS v-show

    ▪ v-if: настойщий условный рендеринг
    ▪ v-if: ленив
    ▪ v-show: манипулирует стилем display, э-нт всегда в DOM

  # v-if вместе с v-for

--------------------------------------

> Ссылки

  # [Официальное руководство] Условный рендеринг
      https://ru.vuejs.org/v2/guide/conditional.html#v-else

> Введение
  - Это глава про условный рендеринг с помощью Vue.

> v-if

  • v-if и v-else
    - У Vue есть шаблонизаторский функционал для условного рендеринга.
    - Аналогичный функционал, например, есть у knockout (директива if).
    - Вот пример условного рендеринга в Vue:

      <h1 v-if="ok">Да</h1>
      <h1 v-else>Нет</h1>    

  • Условные группы с v-if и <template>
    - В knockout можно было использовать псевдоэлементы,
      вроде: <!-- ko if: true --> <!-- /ko -->.
    - В Vue есть аналог - псевдоэлемент <template>:

      <template v-if="ok">
        <h1>Заголовок</h1>
        <p>Абзац 1</p>
        <p>Абзац 2</p>
      </template>    

  • v-else
    - Ещё один пример с if-else в Vue:

      <div v-if="Math.random() > 0.5">
        Сейчас меня видно
      </div>
      <div v-else>
        А теперь — нет
      </div>

  • v-else-if
    - Эта возможност добавлена в v2.1.0.
    - А именно, else-if. 
    - Его можно применять только между блоками с v-if и v-else.
    - Пример:

      <div v-if="type === 'A'">
        A
      </div>
      <div v-else-if="type === 'B'">
        B
      </div>
      <div v-else-if="type === 'C'">
        C
      </div>
      <div v-else>
        Не A/B/C
      </div>    

  • Управление повторным использованием эл-в с помощью key
    - Vue старается рендерить DOM-элементы MAX эффективно.
    - Часто, предпочитая переиспользовать, а не пересоздавать.
    - Это приводит к интересным особенностям. Например:

      • Пример переиспользования DOM-элемента в Vue
        - У нас есть 2 формы, содержащие input.
        - Между ними можно переключаться, меняя значение св-ва loginType.
        - Vue в такой ситуации переиспользует DOM-элемент input.
        - То есть, лишь меняет paceholder, а значение не затирается.
        - Хорошо ли это, или плохо, зависит от ситуации, но это так.
        - Код:

          <template v-if="loginType === 'username'">
            <label>Имя пользователя</label>
            <input placeholder="Введите имя пользователя">
          </template>
          <template v-else>
            <label>Email</label>
            <input placeholder="Введите адрес email">
          </template>        

      • Запретить Vue переиспользовать DOM-элементы спомощью key
        - Описанное выше поведение может реально напрягать иногда.
        - Допустим, мы хотим, чтобы DOM-элементы input из примера 
          выше не переиспользовались.
        - Тогда надо каждому из них указать атрибут key с уникальным значением.
        - В итоге, label будет переиспользоваться, а input нет, т.к. указаны key.
        - Код:

          <template v-if="loginType === 'username'">
            <label>Имя пользователя</label>
                <input placeholder="Введите имя пользователя" key="username-input">
          </template>
          <template v-else>
            <label>Email</label>
                <input placeholder="Введите адрес email" key="email-input">
          </template>        

> v-show
  - Директива v-show, это аналог директивы visible из knockout.
  - При использовании v-show DOM-элемент остаётся в DOM в любом случае.
  - Просто производится манипуляция с его CSS-свойством display.
  - А ещё, v-show нельзя использовать с <template>, поскольку
    оный не присутствует в DOM, и v-show нечего с ним делать.
  - Пример использования v-show:

    <h1 v-show="ok">Привет!</h1>

> v-if VS v-show

  • v-if: настойщий условный рендеринг
    - Элементы и подписчики должным образом уничтожаются/создаются.
    - Элемент либо полностью исчезает из DOM, либо присутствует.

  • v-if: ленив
    - Если условие на момент рендеринга ложное, ничего не произойдёт.
    - Условный блок не будет отображён, пока условие впервые не станет true.

  • v-show: манипулирует стилем display, э-нт всегда в DOM
    - По аналогии с knockout'ким visible.

> v-if вместе с v-for
  - v-if и v-for можно использовать совместно.
  - При этом, v-for имеет более высокий приоритет.


А9. Рендеринг списков

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Основное отличие v-for от for в knockout
  # Простой пример использования v-for
  # Индекс и контекст в v-for

    ▪ Контекст в v-for
    ▪ Индекс в v-for
    ▪ Пример контекста и индекса в v-for

  # Разделитель: in / of
  # Использование v-for с псевдоэлементом <template>
  # Использование v-for с объектом

    ▪ Итерирование по св-вам объектов
    ▪ Пример использования v-for с объектом
    ▪ Порядок обхода не гарантируется

  # Отрисовка DOM-элемента N раз путём передачив v-for целого числа
  # Компоненты и v-for

    ▪ v-for можно использовать на пользовательских компонентах
    ▪ Необходимо указывать key
    ▪ Данные в компонент надо передавать вручную
    ▪ Полный пример простого ToDo на компонентах и v-for

  # v-for и v-if в одном элементе
  
    ▪ У v-for приоритет больше, чем у v-if
    ▪ v-if будет выполняться на каждой итерации

  # Методы, которыми можно изменить наблюдаемый массив

    ▪ push      | Вставить элемент в конец массива
    ▪ shift     | Вставить элемент в начало массива
    ▪ pop       | Удалить последний эл-т и вернуть его
    ▪ unshift   | Удалить 1-й эл-т и вернуть его
    ▪ splice    | Добавить/Удалить указанные эл-ты массива
    ▪ sort      | Отсортировать массив
    ▪ reverse   | Изменить порядок эл-в в массиве на обратный

  # Методы, не изменяющие наблюдаемый массив

    ▪ filter    | Отфильтровать массив
    ▪ concat    | Сложить массивы
    ▪ slice     | Вернуть копию части исходного массива

  # Vue не заметит: вставку по индексу / изменение длины массива

    ▪ Вставка по индексу
    ▪ Явное изменение длины массива

  # Техника массивов-наследников

--------------------------------------

> Ссылки

  # [Официальное руководство] Рендеринг списков
      https://ru.vuejs.org/v2/guide/list.html

> Введение
  - Эта глава про рендеринг списков в Vue, и его особенности.
  - Для этого применяется директива v-for.

> Основное отличие v-for от for в knockout
  - В KO for применялся к элементу-обёртке. При этом 
    циклично рендерилось его содержимое.
  - В Vue for применяется к самому элементу, который
    и будет циклично рендериться.
  - Поначалу это может сбить вас с толку, если вы 
    переходите на Vue с Knockout.

> Простой пример использования v-for

  • Шаблон
    - Здесь видно, что v-for применён к <li>, а не к <ul>.
    - Если бы дело было в knockout, for бы применили к <ul>.
    - Код:

      <ul id="example-1">
        <li v-for="item in items">
          {{ item.message }}
        </li>
      </ul>

  • Модель

      var example1 = new Vue({
        el: '#example-1',
        data: {
          items: [
            { message: 'Foo' },
            { message: 'Bar' }
          ]
        }
      })

> Индекс и контекст в v-for

  • Контекст в v-for
    - Также отличается от того, что происходило в knockout.
    - В knockout внутри for мы находились в контексте текущего эл-та.
    - А в Vue даже внутри v-for мы находимся в контексте модели.
    - Пример: см.ниже.

  • Индекс в v-for
    - Вторым аргументом можно получать индекс v-for.
    - См.пример ниже.

  • Пример контекста и индекса в v-for

    ▪ Шаблон

      <ul id="example-2">
        <li v-for="(item, index) in items">
          {{ parentMessage }} - {{ index }} - {{ item.message }}
        </li>
      </ul>  

    ▪ Модель

      var example2 = new Vue({
        el: '#example-2',
        data: {
          parentMessage: 'Родитель',
          items: [
            { message: 'Foo' },
            { message: 'Bar' }
          ]
        }
      })

> Разделитель: in / of
  - Разделителем в v-for могут бать in / of.
  - Никакой разницы нет.
  - Пример:

      <div v-for="item of items"></div>

> Использование v-for с псевдоэлементом <template>
  - Директиву v-for можно использовать с <template>
  - Пример:

      <ul>
        <template v-for="item in items">
          <li>{{ item.msg }}</li>
          <li class="divider"></li>
        </template>
      </ul>  

> Использование v-for с объектом
  
  • Итерирование по св-вам объектов
    - v-for можно также использовать для итерирования по св-вам объектов.

  • Пример использования v-for с объектом

    ▪ Шаблон

      ▪ Вариант с 1 аргументом

          <ul id="repeat-object" class="demo">
            <li v-for="value in object">
              {{ value }}
            </li>
          </ul>  

      ▪ Вариант с 2 аргументами
        - В key можно получать ключи.
        - Код:

          <div v-for="(value, key) in object">
            {{ key }} : {{ value }}
          </div>

      ▪ Вариант с 3 аргументами
        - В index можно получать индексы.
        - Код: 

          <div v-for="(value, key, index) in object">
            {{ index }}. {{ key }} : {{ value }}
          </div>

  • Порядок обхода не гарантируется
    - И зависит от от разных реализаций движкой JS.
    - Но вообще, он д.б. такой же, как порядок ключей в Object.keys().

> Отрисовка DOM-элемента N раз путём передачив v-for целого числа
  - В v-for можно передать целое число N.
  - Тогда DOM-элемент будет отрисован N раз.
  - Пример (1 2 3 4 5 6 7 8 9 10):

      <div>
        <span v-for="n in 10">{{ n }} </span>
      </div>  

> Компоненты и v-for

  • v-for можно использовать на пользовательских компонентах
    - Например:

      <my-component v-for="item in items" :key="item.id"></my-component>

  • Необходимо указывать key
    
    ▪ Key обязателен с v-for, начиная с v2.2.0
      - Начиная с v2.2.0 key теперь обязателен при использовании с v-for.
    
    ▪ "Стратегия по умолчанию", или "обновление на месте"
      - До v2.2.0 была опция не указывать key с v-for.
      - Тогда Vue использовал стратегию "обновления на месте".
      - Например, порядок элементов массива/объекта изменился.
      - Vue не будет перемещать эл-ты DOM, а просто обновит каждый "на месте".
      - Чтобы он отображал новые данные по соотв.индексу.

    ▪ Для чего Vue использует key
      - В качестве уникального ID элемента внутри соответствующего v-for.
      - Key позволяет Vue отслеживать идентичность каждого элемента.
      - Что позволяет переиспользовать и перемещать существующие эл-ты.
      - Вообще, механизм key является общим идентификационным механизмом в Vue,
        и может быть использован и в других, не связанных с v-for случаях.

  • Данные в компонент надо передавать вручную
    - Т.Е., автоматически данные в v-for в компонент не передаются.
    - Ведь компоненты имеют изолированные области видимости, и если бы
      данные автоматически передавались, это бы сделало компонент
      жёстко связанным с логикой работы v-for.
    - Для передачи данных нужно явно использовать входные параметры.
    - Например:

        <my-component
          v-for="(item, index) in items"
          v-bind:item="item"
          v-bind:index="index"
          v-bind:key="item.id">
        </my-component>

  • Полный пример простого ToDo на компонентах и v-for

    ▪ Шаблон

      <div id="todo-list-example">
        <input
          v-model="newTodoText"
          v-on:keyup.enter="addNewTodo"
          placeholder="Добавить todo"
        >
        <ul>
          <li
            is="todo-item"
            v-for="(todo, index) in todos"
            v-bind:key="todo"
            v-bind:title="todo"
            v-on:remove="todos.splice(index, 1)"
          ></li>
        </ul>
      </div>

    ▪ Компонент элемента списка

      Vue.component('todo-item', {
        template: `
          <li>
            {{ title }}
            <button v-on:click="$emit('remove')">X</button>
          </li>
        `,
        props: ['title']
      })

    ▪ Модель

      new Vue({
        el: '#todo-list-example',
        data: {
          newTodoText: '',
          todos: [
            'Вымыть посуду',
            'Вынести мусор',
            'Подстричь газон'
          ]
        },
        methods: {
          addNewTodo: function () {
            this.todos.push(this.newTodoText)
            this.newTodoText = ''
          }
        }
      })    


> v-for и v-if в одном элементе

  • У v-for приоритет больше, чем у v-if
    - Как следствие, см.следущий пункт.

  • v-if будет выполняться на каждой итерации
    - Что достаточно удобно.
    - Например, выведем только те ToDo, что ещё не выполнены:

      <li v-for="todo in todos" v-if="!todo.isComplete">
        {{ todo }}
      </li>

    - А если надо запускать сам цикл по условию,
      придётся поставить v-if на внешний элемент:

      <ul v-if="shouldRenderTodos">
        <li v-for="todo in todos">
          {{ todo }}
        </li>
      </ul>      

> Методы, которыми можно изменить наблюдаемый массив
  - Эти методы применяются обычным для JS образом.
  - Они изменяют наблюдаемый массив, и Vue перерисовывает DOM.
  - См.их список в оглавлении главы.

> Методы, не изменяющие наблюдаемый массив
  - Такие, как: filter, concat, slice.
  - Их применение на наблюдаемом массиве вернёт новый массив.
  - Но никто не запрещает заменить старый массив новым:

      example1.items = example1.items.filter(function (item) {
        return item.message.match(/Foo/)
      })  

  - Можно подумать, что это будет очень тяжёлой операцией.
  - И что Vue будет перерисовывать весь массив в DOM.
  - Но, как уверяют авторы, Vue всё сделает по-умному и оч.легко.
  - См.их список в оглавлении главы.

> Vue не заметит: вставку по индексу / изменение длины массива

  ▪ Вставка по индексу
    - vm.items[indexOfItem] = newValue
    - Такое Vue не заметит, и ничего не произойдёт.
    - Есть 2 варианта обхода:

      // Vue.set
      Vue.set(example1.items, indexOfItem, newValue) 

      // Array.prototype.splice
      example1.items.splice(indexOfItem, 1, newValue)

  ▪ Явное изменение длины массива
    - vm.items.length = newLength
    - Такое Vue не заметит, и ничего не произойдёт.
    - Есть варианта обхода:

      // Array.prototype.splice
      example1.items.splice(newLength)

> Техника массивов-наследников
  - Допустим, есть у нас в модели первый наблюдаемый массив.
  - А нам нужен другой, но основанный на этом, второй массив.
  - Второй должен автоматически изменяться при изменении первого.
  - Тогда, просто добавляем в модель второй массив.
  - И с помощью вычисляемой перенаполняем его всякий раз при изменении первого.

А10. Обработка событий

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Подписка на события: v-on
  # Методы, как обработчики событий

    ▪ Использование методов, как обработчиков событий
    ▪ Пример №1: указать имя метода в v-on
    ▪ Пример №2: вызвать метод в js-выражении в v-on
    ▪ Пример №3: доступ к объекту-событию в методе

  # Модификаторы событий

    ▪ Что такое модификаторы событий?
    ▪ Модификаторы событий можно чейнить
    ▪ Можно опускать пользовательский обработчик
    
    ▪ .stop       | Событие не будет всплывать дальше
    ▪ .prevent    | Предотвратить действие браузера по умолчанию
    ▪ .capture    | Приказать обработчику срабатывать на стадии перехвата события
    ▪ .self       | Обрабатывать лишь возникшее на этом эл-те событие
    ▪ .once       | Приказать обработчику события сработать лишь 1 раз

  # Модификаторы событий клавиатуры

    ▪ Что такое модификаторы событий клавиатуры?
    ▪ Алиасы для распространённых keyCodes

      ▪ .N        | [общий случай] Где N - keyCode клавиши
      ▪ .enter    | Класиша enter
      ▪ .tab      | Класиша enter
      ▪ .delete   | Клавиши delete и backspace
      ▪ .esc      | Класиша esc 
      ▪ .space    | Класиша space
      ▪ .up       | Класиша up
      ▪ .down     | Класиша down
      ▪ .left     | Класиша left
      ▪ .right    | Класиша right 

    ▪ Алиасы для клавиш-модификаторов

      ▪ .ctrl     | Класиша ctrl 
      ▪ .alt      | Класиша alt 
      ▪ .shift    | Класиша shift 
      ▪ .meta     | Класиша meta 

    ▪ Добавление кастомных алиасов через Vue.config.keyCodes

  # Модификаторы событий мыши

    ▪ Что такое модификаторы событий мыши?

    ▪ .left       | Левая кнопка мыши
    ▪ .right      | Правая кнопка мыши
    ▪ .middle     | Средняя кнопка мыши

--------------------------------------

> Ссылки

  # [Официальное руководство] Обработка событий
      https://ru.vuejs.org/v2/guide/events.html

> Введение
  - В этой главе описана работа с событиями в Vue.

> Подписка на события: v-on
  - Подписаться на события можно через директиву v-on.
  - Пример:

    • Шаблон

      <div id="example-1">
        <button v-on:click="counter += 1">+1</button>
        <p>Кнопка выше была нажата {{counter}} раз</p>
      </div>

    • Модель

      var example1 = new Vue({
        el: '#example-1',
        data: {
          counter: 0
        }
      })

> Методы, как обработчики событий
  
  • Использование методов, как обработчиков событий
    - Можно, конечно, для обработки событий использовать js-выражения.
    - Как, например, это сделано в примере выше.
    - Но чище всё же выделять под это дело отделный метод.

  • Пример №1: указать имя метода в v-on

    ▪ Шаблон

      <div id="example-2">
        <!-- `greet` — это название метода, определённого ниже -->
        <button v-on:click="greet">Поприветствовать</button>
      </div> 

    ▪ Модель

      var example2 = new Vue({
        el: '#example-2',
        data: {
          name: 'Vue.js'
        },
        // определяйте методы в объекте `methods`
        methods: {
          greet: function (event) {
            // `this` внутри методов указывает на экземпляр Vue
            alert('Привет, ' + this.name + '!')
            // `event` — нативное событие DOM
            if (event) {
              alert(event.target.tagName)
            }
          }
        }
      })

  • Пример №2: вызвать метод в js-выражении в v-on

    ▪ Шаблон

      <div id="example-3">
        <button v-on:click="say('hi')">Скажи hi</button>
        <button v-on:click="say('what')">Скажи what</button>
      </div>

    ▪ Модель

      new Vue({
        el: '#example-3',
        methods: {
          say: function (message) {
            alert(message)
          }
        }
      })

  • Пример №3: доступ к объекту-событию в методе
    - В knockout объект-событие автоматом передавалось в метод.
    - В Vue оно тоже передаётся, но лишь при вызове метода по имени в v-on.
    - А при inline-вызове метода в js-выражении надо $event передавать вручную:

      ▪ Шаблон

        <button v-on:click="warn('Форма пока не может быть отправлена.', $event)">
          Отправить
        </button>

      ▪ Модель

        // ...
        methods: {
          warn: function (message, event) {
            // теперь у нас есть доступ к нативному событию
            if (event) event.preventDefault()
            alert(message)
          }
        }

> Модификаторы событий

  • Что такое модификаторы событий?
    - Они изменяют некоторые св-ва процесса обработки событий.
    - Вроде prevent default или stop propagation.
    - Конечно, можно было бы делать всё это внутри метода-обработчика.
    - Но было бы лучше сохранить чистоту логики и абстрагироваться
      от деталей реализации событий DOM.
    - Для решения этой задачи Vue и предлагает модификаторы событий для v-on.
    - Напомним, модификаторы директив указываются, как постфиксы, и отделяются точкой.

  • Модификаторы событий можно чейнить
    - Например:

      <a v-on:click.stop.prevent="doThat"></a>

  • Можно опускать пользовательский обработчик
    - Например:

      <form v-on:submit.prevent></form>

  • .stop  
    - Событие не будет всплывать дальше.
    - Пример:

      <a v-on:click.stop="doThis"></a>

  • .prevent
    - Предотвратить действие браузера по умолчанию.
    - Пример:

      <form v-on:submit.prevent="onSubmit"></form>

  • .capture
    - Приказать обработчику срабатывать на стадии перехвата события.
    - Подробнее про стадии перехвата/всплытия события см.здесь:
        https://learn.javascript.ru/event-bubbling#погружение
    - Пример:

      <div v-on:click.capture="doThis">...</div>

  • .self
    - Обрабатывать лишь возникшее на этом эл-те событие.
    - И игнорировать транзитные события (стадии перехвата/всплытия).
    - Пример:

      <div v-on:click.self="doThat">...</div>

  • .once
    - Приказать обработчику события сработать лишь 1 раз.
    - В отличие от остальных модификаторов, которые поддерживают
      исключительно нативные DOM-события, модификатор .once можно
      использовать и в пользовательских событиях компонентов.
    - Пример:

      <a v-on:click.once="doThis"></a>

> Модификаторы событий клавиатуры

  • Что такое модификаторы событий клавиатуры?
    - При нажатии какой-либо клавиши возбуждаются соотв.события.
    - В объекте-событии есть key code нажатой клавиши.
    - По нему мы и можем понять, какая же клавиша была нажата.
    - Обычный сценарий обработки событий клавиатуры таков:

      1. Смотрим keyCode.
      2. Если keyCode не тот, что нас интересует, ничего не делаем.
      3. Если keyCode тот, то продолжаем обработку.

    - Vue предлагает сэкономить время на этом сценарии.
    - И для этого выкатывает модификаторы событий клавиатуры.
    - С их помощью можно сразу указать, какие key code нас интересуют.
    - И обработчик просто не будет срабатывать с другими.
    - Причём, т.к. модификаторы можно чейнить, можно указать много key code'ов.

  • Алиасы для распространённых keyCodes
    - Полный список алиасов см.в оглавлении.
    - Ниже приведём несколько примеров:

      ▪ .N 
        - [общий случай] Где N - keyCode клавиши
        - Пример:

          <input v-on:keyup.13="submit">

      ▪ .enter
        - Класиша enter.
        - Пример:

          <input v-on:keyup.enter="submit">
          <input @keyup.enter="submit">       | сокращённая запись

  • Алиасы для клавиш-модификаторов
    - Полный список алиасов см.в оглавлении.
    - Ниже приведём несколько примеров:

      ▪ Alt + C

          <input @keyup.alt.67="clear">

      ▪ Ctrl + Click

          <div @click.ctrl="doSomething">Сделать что-нибудь</div>

  • Добавление кастомных алиасов через Vue.config.keyCodes
    - Например, определим алиас для клавиши f1:

        Vue.config.keyCodes.f1 = 112


А11. Работа с формами

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Двунаправленное связывание: v-model
  
    ▪ Директива v-model для элементов input и textarea
    ▪ V-model игнорирует атрибуты value, checked, selected

  # Работа с input
  # Работа с textarea
  # Работа с чекбоксами

    ▪ Биндинг 1-го чекбокса с 1-им св-вом модели
    ▪ Биндинг N чекбоксов с массивом N св-во модели
    ▪ v-bind для привязки value чекбокса к св-ву модели

  # Работа с радиобуттонами

    ▪ Пример №1: работа с радиобуттонами
    ▪ Пример №2: v-bind для привязки value радиобуттона к св-ву модели

  # Работа с селектами

    ▪ "Не выбранное" состояние селекта
    ▪ Выбор единственного значения
    ▪ Выбор нескольких значений (привязка к массиву)
    ▪ Динамическое отображение опций с помощью v-for
    ▪ v-bind для привязки value опций селекта к св-вам модели

  # Модификаторы для v-model

    ▪ .lazy     | Синхронизация не по событию input, а по change
    ▪ .number   | Приводить ввод к числу
    ▪ .trim     | Автоматически обрезать пробелы по краям

  # Использование v-model с компонентами

--------------------------------------

> Ссылки

  # [Официальное руководство] Работа с формами
      https://ru.vuejs.org/v2/guide/forms.html

> Введение
  - В этой главе описана работа с формами в Vue.

> Двунаправленное связывание: v-model
  
  • Директива v-model для элементов input и textarea
    - Директивы v-model реализвут 2-направленное связывание.
    - Она работает с DOM-элементами input и textarea.
    - Принцип работы такой же, как в knockoutjs.

  • V-model игнорирует атрибуты value, checked, selected
    - Которые она найдёт на любых элементах форм.
    - Модель Vue всегда будет источником истины.
    - Поэтому, начальное значение надо объявлять в модели.

> Работа с input
  - Представим, что в модели есть св-во message.
  - Организуем его 2-направленный биндинг text input:

      <input v-model="message" placeholder="отредактируй меня">
      <p>Введённое сообщение: {{ message }}</p>

> Работа с textarea
  - Представим, что в модели есть св-во message.
  - Причём, интерполяция внутрь тега работат НЕ БУДЕТ:

      <textarea>{{text}}</textarea>   // Работать не будет

  - Организуем его 2-направленный биндинг textarea:  

      <span>Введённое многострочное сообщение:</span>
      <p style="white-space: pre">{{ message }}</p>
      <br>
      <textarea v-model="message" placeholder="введите несколько строчек"></textarea>

> Работа с чекбоксами

  • Биндинг 1-го чекбокса с 1-им св-вом модели

      <input type="checkbox" id="checkbox" v-model="checked">
      <label for="checkbox">{{ checked }}</label>

  • Биндинг N чекбоксов с массивом N св-во модели

    ▪ Шаблон

      <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
      <label for="jack">Jack</label>
      <input type="checkbox" id="john" value="John" v-model="checkedNames">
      <label for="john">John</label>
      <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
      <label for="mike">Mike</label>

      <span>Отмеченные имена: {{ checkedNames }}</span>    

    ▪ Модель

      new Vue({
        el: '...',
        data: {
          checkedNames: []
        }
      })

  ▪ v-bind для привязки value чекбокса к св-ву модели

    <input
      type="checkbox"
      v-model="toggle"
      v-bind:true-value="a"
      v-bind:false-value="b"
    >

> Работа с радиобуттонами

  • Пример №1: работа с радиобуттонами

    <input type="radio" id="one" value="One" v-model="picked">
    <label for="one">One</label>
    
    <input type="radio" id="two" value="Two" v-model="picked">
    <label for="two">Two</label>
    
    <span>Выбрано: {{ picked }}</span>

  • Пример №2: v-bind для привязки value радиобуттона к св-ву модели
    - Привязываем value радиобуттона к св-ву pick модели

      <input type="radio" v-model="pick" v-bind:value="a">  

> Работа с селектами

  • "Не выбранное" состояние селекта
    - В примере ниже начальное значение св-ва selected пустое.
    - Оно не совпадает ни с одним из вариантов option в списке.
    - Поэтому, при загрузке селект будет отображаться в "disabled"-состоянии.
    - Тут у нас есть 2 варианта:

      ▪ [наш выбор] Добавить доп.option для состояния по умолчанию
        - В нашем примере, для состояния со значением "".
        - Эта опция идёт с атрибутом disabled в примере ниже.

      ▪ Не добавлять доп.option для состояния по умолчанию
        - Это плохо, т.к. в iOS элемент будет сломан.
        - При выборе опции не будет генерироваться событие changed.

  • Выбор единственного значения

    ▪ Шаблон

      <select v-model="selected">
        <option disabled value="">Выберите один из вариантов</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
      </select>
      <span>Выбрано: {{ selected }}</span>

    ▪ Модель

      new Vue({
        el: '...',
        data: {
          selected: ''
        }
      })    

  • Выбор нескольких значений (привязка к массиву)

      <select v-model="selected" multiple>
        <option>A</option>
        <option>B</option>
        <option>C</option>
      </select>
      <br>
      <span>Выбрано: {{ selected }}</span>

  • Динамическое отображение опций с помощью v-for
    - Просто добавляем в модель массив объектов.
    - И внутри select с помощью v-for разворачиваем.
    - Пример:

      ▪ Шаблон

          <select v-model="selected">
            <option v-for="option in options" v-bind:value="option.value">
              {{ option.text }}
            </option>
          </select>
          <span>Выбрано: {{ selected }}</span>

      ▪ Модель

          new Vue({
            el: '...',
            data: {
              selected: 'A',
              options: [
                { text: 'One', value: 'A' },
                { text: 'Two', value: 'B' },
                { text: 'Three', value: 'C' }
              ]
            }
          })

  • v-bind для привязки value опций селекта к св-вам модели

    <select v-model="selected">
      <!-- inline object literal -->
      <option v-bind:value="{ number: 123 }">123</option>
    </select>

> Модификаторы для v-model

  • .lazy
    - Синхронизация не по событию input, а по change.
    - По умолчанию, v-model синхронизируется при каждом input.
    - Но можно приказать, чтобы по каждому change, а не input.
    - Например:

      <input v-model.lazy="msg">

  • .number
    - Приводить ввод к числу.
    - Это полезно, т.к. даже с type="number", значение input
      всегда возвращается в виде строки.
    - Например:

      <input v-model.number="age" type="number">

  • .trim
    - Автоматически обрезать пробелы по краям.
    - Например:

      <input v-model.trim="msg">

> Использование v-model с компонентами
  - Стандартные input'ы не всегда отвечают нашим требованиям.
  - Но можно сделать свой input в виде Vue-компонента.
  - И его поведение может сильно отличаться от стандартного.
  - Причём, он даже будет работать с v-model.
  - Подробнее см.следующую главу про компоненты, и там раздел
    про кастомные инпуты.


А12. Компоненты

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Модульный подход к разработке фронтенд-приложений
  # -------------------------------------------------

    ▪ Множество компонентов
    ▪ Независимость и самодостаточность компонентов
    ▪ Повторное использование компонентов
    ▪ Дерево/лес компонентов
    ▪ API компонента
    ▪ Компонент, как чёрный ящик
    ▪ Взаимодействие компонентов
    ▪ Версии компонентов
    ▪ Сторонние библиотеки компонентов
    ▪ Делегирование разработки компонентов субподрядчикам
    ▪ Скоростная разработка фронтенд-приложения

  # Использование компонентов
  # -------------------------

    • Регистрация компонента

      ▪ Регистрация компонента глобально
        - Должна производиться ДО создания корневого vue-экземпляра
        - Пример регистрации компонента глобально
      ▪ Регистрация компонента локально (инкапсуляция)
        - Опция components: рендерить компонент лишь в шаблоне родителя
        - Пример регистрации компонента локально

    • Особенности парсинга DOM-шаблона

      ▪ Доступные в Vue источники шаблонов
        - DOM-шаблон
        - <script type="text/x-template">
        - inline-строки JavaScript
        - .vue-компоненты
      ▪ Ограничения HTML, влияющие на Vue
        - Атрибут is: обойти ограничения, возникающие в DOM-шаблоне?
        - Совет: пользуйся inline- или .vue-шаблоном

    • В компоненте data д.б. ф-ией, возвращающей объект
      ▪ Как делать НЕ ЖЕЛАТЕЛЬНО: передавать объект в data
      ▪ Как РЕКОМЕНДУЕТСЯ делать: генерировать объект в data анон.ф-ией    

    • Взаимодействие родственных компонентов: параметры вниз, события вверх
      ▪ Родитель -> Потомок : входные параметры
      ▪ Потомок -> Родитель : возбуждение событий
      ▪ Принцип относительной изоляции компонентов

  # Входные параметры
  # -----------------

    • Передача данных через props: родитель -> потомок
      ▪ У потомка нет доступа к моделям предков
      ▪ Опция props: передача данных из родителя в потомка
      ▪ Пример использования props без валидации

    • Способы передачи входных параметров
      ▪ Через HTML-атрибут в элементе-компоненте
      ▪ Через v-bind связывать параметр с наблюдаемой родителя
        - Я рекомендую пользоваться этим способом
        - Пример передачи ссылка на наблюдаемую родителя в кач-ве параметра

    • Валидация входных параметров
      ▪ Валидация определяется в опции props
      ▪ Опции валидации
        - default     | задать значение по умолчанию
        - type        | валидация типа значения
        - validator   | пользовательская функция-валидатор
        - required    | обязательное значение
      ▪ Доступные значения для type (все JS-типы)

    • Концепция однонаправленного потока данных
      ▪ Позволяет легче понимать структуру потоков данных в приложении
      ▪ Не меняй вручную значения входных параметров

  # Пользовательские события
  # ------------------------

    • Система кастомных событий Vue
      ▪ Независима от браузерной
      ▪ Методы интерфейса событий Vue
        - $on       | Назначить обработчик кастомного события
        - $emit     | Возбудить кастомное событие

    • Способы коммуникации между компонентами
      
      ▪ v-on: родительский компонент <--- дочерний компонент
        - Только родитель-дочка
        - Нельзя использовать $on, нет доступа к модели дочки
        - Надо использовать v-on, на примере

      ▪ Через вспомогательный vue-экземпляр: связь для не-родственников
        - Подходит для простых приложений
        - Подходит для связи между любыми компонентами
        - Принцип связи: через вспомогательный vue-экземпляр
        - Пример связи через вспомогательный vue-экземпляр

      ▪ Через vuex
        - Подходит для средних и крупных SPA-приложений
        - Публичная/Приватная части модели компонента
        - Что такое vuex

    • Модификаторы .sync, .native; директива v-model

      ▪ Модификатор .sync: работает через систему событий Vue
      ▪ Модификатор .native: обрабатывать события из браузера
      ▪ Директива v-model: лишь синтаксический сахар
        - Как она работает
        - Как застаить работать v-model с компонентом

  # Слоты: распределение контента
  # -----------------------------

    • Слоты: в чём суть кратко
      ▪ Суть слотов кратко
      ▪ Замечание об областях видимости при компиляции шаблонов
    • Если <slot> отсутствует: контент псевдоэлемента игнорирутеся
    • Если есть 1-ин <slot>: подменяется контентом псевдоэлемента
    • Запасной контент слота: если в <slot> нечего вставлять
    • Именные <slot>: что в слот с каким именем распихать
    • Scoped slots: кастомизация шаблона компонента через контент псевдоэлемента
      ▪ Инструмент для кастомизации компонентов
      ▪ Пример использования scoped slots

  # Горячая замена компонентов
  # --------------------------

    • Горячая замена: пример   
    • Горячая замена: через прямую ссылку на объект компонента    
    • Псевдоэлемент <keep-alive>: хранить отключенные ком-ты в памяти

  # Прочие темы, касающиеся компонентов
  # -----------------------------------

    • Создание компонентов для повторного использования
      ▪ Предназначен ли компонент для повторного использования?
      ▪ Чёткий API для повторно используемых компонентов
      ▪ Краткий и чёткий способ описания API компонента

    • Ссылки на компоненты-потомки
      ▪ Атрибут ref: способ получить ссылки на объекты-модели компонентов-потомков
      ▪ Получаем ссылку на модель компонента-потомка через модель родителя
      ▪ Объект $refs заполняется только после рендеринга компонента
      ▪ Используй эту возможность лишь в крайних случаях

    • Асинхронные компоненты
      ▪ Приложение на части; подгрузка оных по мере необходимости
      ▪ Определить компонент, как функцию фабрику
      ▪ Пример компонента, определённого, как фабрика
      ▪ Пример использования промисов с Webpack 2

    • Продвинутые асинхронные компоненты
      ▪ Новая версия объекта для фабрики компонентов (version >=2.3)

    • Соглашения по именованию компонентов
      ▪ Нижний регистр
      ▪ Кебаб-стайл

    • Рекурсивные компоненты
      ▪ Компонент может рекурсивно вызвать самого себя
      ▪ При глобальной регистрации name равна глобальному ID компонента
      ▪ Осторожно: беспонечные циклы

    • Циклические ссылки между компонентами
    • Inline-шаблоны
      ▪ Атрибут inline-template у компонента
      ▪ Не надо путать себя и людей

    • Определение шаблонов через X-Template
      ▪ Ещё один способ задать шаблоны
      ▪ Не надо путать себя и людей

    • “Дешёвые” статические компоненты с использованием v-once
      ▪ Экономим, не делая перерендеринг статических данных
      ▪ Атрибут v-once, как решение проблемы

--------------------------------------

> Ссылки

  # [Официальное руководство] Компоненты
      https://ru.vuejs.org/v2/guide/components.html

> Введение
  - Эта глава описывает работу с vue-компонентами.
  - Также рассмотрен модульный подход к разработке.

> Модульный подход к разработке фронтенд-приложений

  • Приложение, как набор компонентов
    - Любое фронтенд-приложение можно разложить на N компонентов.

  • Независимость и самодостаточность компонентов
    - Каждый компонет должен быть независим и самодостаточен.
    - Он не должен иметь никаких связей с внешним контекстом.
    - В идеале, должна быть 100% автономность и независимость.

  • Повторное использование компонентов
    - Независимые самодостаточные компоненты легко повторно использовать.
    - Особенно если в их дизайн заложены гибкость и универсальность.

  • Дерево/лес компонентов
    - Приложение не является бесструктурной кучей компонентов.
    - Приложение представляет из себя дерево/лес компонентов.
    - Корнем дерева является vue-экземпляр.
    - Узлами в ветвях дерева являются vue-компоненты.

  • API компонента
    - Каждый компонент имеет API для взаимодействия с ним.
    - API компонентов состоит из 3-х частей:

      ▪ Входные параметры
        - Позволяют передавать в компонент данные извне.

      ▪ События 
        - Позволяют компонентам воздействовать на внешнее окружение.

      ▪ Слоты 
        - Позволяют внешнему окружению дополнять компоненты новым контентом.

  • Компонент, как чёрный ящик
    - К компоненту можно относиться, как к чёрному ящику.
    - Достаточно знать API компонента, чтобы работать с ним.
    - Поэтому, можно легко использовать чужие компоненты, зная их API.

  • Взаимодействие компонентов

    ▪ Взаимодействие потомка и предка
      - Т.Е. компонентов, состоящих в 1-й ветке 1-го дерева.
      - Предок может передавать параметры при создании потомка.
      - Предок может дополнять потомка новым контентом через слоты.
      - Потомок может слать события предку после своего создания.

  • Версии компонентов
    - Можно испольозвать версионный контроль для работы с компонентами.
    - Код компонента хранить, например, в git-репозитории.
    - Обеспечивать обратную совместимость для минорных версий и патчей.
    - И прочее.

  • Сторонние библиотеки компонентов
    - Другие разработчики создали и создадут много компонентов.
    - На это было и будет затрачено огромное количество человеко-часов.
    - Было бы преступной халатностью не использовать эти наработки.
    - Благодаря модульному подходу, делать это стало проще.
    - Ведь при таком подходе, не обязательно разбираться в чужом коде.
    - Достаточно знать API компонента, чтобы его использовать.

  • Делегирование разработки компонентов субподрядчикам
    - Модульный подход позволяет не вникать в код компонента.
    - Поэтому, их разработку можно смело поручать субподрядчикам.
    - Примерный процесс таков:

      ▪ Даёшь ему задание
        - Нужен vue-компонент.
        - Должен выглядеть и работать так-то.
        - Описываешь его API:
            Должен принимать такие-то параметры.
            Должен генерировать такие-то события.
            Должен работать с такими-то слотами.
  
      ▪ Когда готово, всё проверяешь
        - Наискосок пробегаешь код компонента.
        - Вставляешь компонент в своё приложение.
        - Тестируешь, всё ли работает правильно.
        - Если что-то не ОК, просишь доработать.
        - Если всё ОК, платишь и прощаешься.

  • Скоростная разработка фронтенд-приложения
    - Ключ к успеху в параллельной разработке N компонентов.
    - Допустим, над каждым компонентом трудится отдельный разработчик.
    - Чем больше разработчиков одновременно работают, тем быстрее идёт процесс.
    - Но важно также успевать обслуживать это дело:

      ▪ Успевать качественно осуществлять проектирование
      ▪ Успевать готовить задачи на разработку следующих компонентов
      ▪ Успевать принимать и интегрировать готовые компоненты

> Использование компонентов

  # Регистрация компонента

    • Регистрация компонента глобально

      ▪ Должна производиться ДО создания корневого vue-экземпляра
        - Чтобы оный имел понятие о существовании соответствующего компонента.
        - И мог узнать и соотв.образом обработать его во время компиляции.

      ▪ Пример регистрации компонента глобально

        ▪ Регистрация

          Vue.component('my-component', {
            template: '<div>Пользовательский компонент!</div>'
          })

        ▪ Создание корневого экземпляра

          new Vue({
            el: '#example'
          })

        ▪ Использование

          <div id="example">
            <my-component></my-component>
          </div>  
        
        ▪ Результат рендеринга

          <div id="example">
            <div>Пользовательский компонент!</div>
          </div>          

    • Регистрация компонента локально (инкапсуляция)

      ▪ Опция components: рендерить компонент лишь в шаблоне родителя
        - Доступна конструкторе vue-экземпляра или vue-компонента.
        - Она содержит объект, в котором можно регистрировать компоненты.
        - Ключ: имя компонента, значение: конструктор компонента.
        - Vue будет рендерить этот компонент только в шаблоне соотв.экземпляра/компонента.
        - Пример см.ниже.

      ▪ Пример регистрации компонента локально

        new Vue({
          // ...
          components: {
            // <my-component> будет доступен только в шаблоне родителя
            'my-component': {
              template: '<div>Пользовательский компонент!</div>'
            }
          }
        })   

  # Особенности парсинга DOM-шаблона

    • Доступные в Vue источники шаблонов

      ▪ DOM-шаблон
        - В конструкторе Vue есть опция "el".
        - В ней можно указать селектор для поиска элемента в DOM.
        - DOM этого элемента и будет использован в качестве шаблона.
        - Пример селектора: "#elementID".

      ▪ <script type="text/x-template">
        - Шаблон можно определить внутри элемента script.
        - У него ещё должен бать атрибут type="text/x-template".
        - В опции template можно вписать указывающий на script селектор.
        - Содержимое script будет использовано в качестве шаблона.
        - Автор советует избегать такого подхода, т.к. шаблон т.о.
          отделяется от остального определения компонента.
        - Пример:

            <script type="text/x-template" id="hello-world-template">
              <p>Привет привет привет</p>
            </script> 

            Vue.component('hello-world', {
              template: '#hello-world-template'
            })

      ▪ inline-строки JavaScript
        - В опцию template конструктора Vue можно вписать HTML-код.
        - Этот код и станет шаблоном.
        - Пример:

            Vue.component('terms-of-service', {
              template: '\
                <div v-once>\
                  <h1>Условия Использования</h1>\
                  ... много-много статического контента ...\
                </div>\
              '
            })        

      ▪ .vue-компоненты
        - Речь идёт об одновайловых компонентах .vue
        - В них используют псевдо-элемент <template></template>.
        - Компонент использует содержащийся в нём HTML-код в качестве шаблона.

          <template>
            <p>{{ greeting }} World!</p>
          </template>

    • Ограничения HTML, влияющие на Vue
      
      ▪ DOM-шаблон и ограничения из-за парсинга браузером
        - Описанные ограничений действуют только для DOM-шаблонов.
        - И не действуют для остальных типов шаблонов
          (которые попадают прямо в Vue без доп.обработки браузером).
        - Вот, что происходит для DOM-шаблона:

          ▪ Сначала браузер парсит HTML-код.
            - Он его обрабатывает и нормализует.
            - Применяет к нему все правила HTML.
            - При этом определённые сочетания эл-в могут
              не соответствовать нормам языка HTML.
            - Например, есть ограничение, какие эл-ты могут находиться
              внутри эл-в: <ul>, <ol>, <table>, <select>;
              Для некоторых других элементов, например <option>,
              ограничен список допустимых родительских элементов.
            - В итоге, в такой ситуции:

                <table>
                  <my-row>...</my-row>
                </table>   
                
            - браузер просто отбросит компонент my-row.
            - И до Vue он просто не доберётся.           

      ▪ Атрибут is: обойти ограничения, возникающие в DOM-шаблоне?
        - Использование этого способа похоже, честно говоря, на костыль.
        - Мы просто вставляем то, чего ожидает увидеть браузер.
        - Например, в <table> помещаем элемент <tr>.
        - А элементу назначаем атрибут is с именем компонента.
        - В итоге, всё это доходит без изменений до компилятора Vue.
        - И тот, видя атрибут is, заменяет <tr> на шаблон компонента.
        - Пример:

            <table>
              <tr is="my-row"></tr>
            </table>        

      ▪ Совет: пользуйся inline- или .vue-шаблоном
        - Чтобы избежать обозначенных выше проблем/костылей.


  # В компоненте data д.б. ф-ией, возвращающей объект
    - Один компонент может быть использован много раз.
    - Поэтому нельзя в конструктор передавать вещи по ссылке.
    - Проще объяснить на примере:

      ▪ Как делать НЕ ЖЕЛАТЕЛЬНО: передавать объект в data
        - В этом примере передаём объект в data.
        - Каждый экземпляр будет ссылаться именно на этот объект.
        - Т.Е. при изменении его в 1-ом, он изменится во всех экземплярах.
        - Код:

          Vue.component('my-component', {
            template: '<span>{{ message }}</span>',
            data: {
              message: 'привет!'
            }
          })        

      ▪ Как РЕКОМЕНДУЕТСЯ делать: генерировать объект в data анон.ф-ией
        - Не надо передавать в конструктор объект.
        - Надо генерировать новый объект анонимной функцией.
        - Так, у каждого экземпляра будет свой объект в data.
        - Код:

          Vue.component('my-component', {
            template: '<span>{{ message }}</span>',
            data: unction () {
              return {
                counter: 0
              }
            }
          })  

  # Взаимодействие родственных компонентов: параметры вниз, события вверх
    
    ▪ Родитель -> Потомок : входные параметры
      - Родитель передаёт данные потомку с помощью входных параметров.
    
    ▪ Потомок -> Родитель : возбуждение событий
      - Потомок передаёт данные родителю, возбуждая события, который последний перехватывает.

    ▪ Принцип относительной изоляции компонентов
      - Такой подход упродает поддержку кода.
      - И потенциально облегчает повторное использование компонентов.

> Входные параметры

  # Передача данных через props: родитель -> потомок

    • У потомка нет доступа к моделям предков
      - Каждый экземпляр vue-компонента имеет изолированную область видимости.
      - Потомок не может прямо из своего шаблона обращаться к модели родителя.

    • Опция props: передача данных из родителя в потомка
      - В опции props потомка можно разместить массив.
      - В этом массиве перечислить ожидаемые входные параметры.
      - Здесь же можно провести и валидацию (о ней ниже).

    • Пример использования props без валидации

        Vue.component('child', {
          props: ['myMessage'],
          template: '<span>{{ myMessage }}</span>'
        })    

  # Способы передачи входных параметров

    • Через HTML-атрибут в элементе-компоненте
      - Допустим, есть у нас компонент child.
      - И есть у него в props параметр message.
      - Вот, как можно передать туда простой литерал:

        <child message="привет!"></child>

    • Через v-bind связывать параметр с наблюдаемой родителя
      
      ▪ Я рекомендую пользоваться этим способом
        - Я думаю, метод через HTML-атрибут менее популярен.
        - А более популярно передавать ссылку на наблюдаемую родителя.
        - И даже, если хочешь передать литерал, всё равно.
        - Просто это более универсальный способ передачи параметров.

      ▪ Пример передачи ссылка на наблюдаемую родителя в кач-ве параметра
        - Допустим, есть у нас компонент child.
        - И есть у него в props параметр message.
        - У него есть также какой-то компонент-родитель.
        - У последнего в модели есть наблюдаемая parentMsg.
        - И мы хотим передать ссылку на parentMsg в message.
        - Сделать это можно через v-bind:

          <child v-bind:my-message="parentMsg"></child>
          <child :my-message="parentMsg"></child>         // сокращённая запись для v-bind  

  # Валидация входных параметров

    • Валидация определяется в опции props

      Vue.component('example', {
        props: {
          propA: Number,                // простая проверка типа (`null` означает допустимость любого типа)
          propB: [String, Number],      // несколько допустимых типов
          propC: {                      // обязательное значение строкового типа
            type: String,
            required: true
          },
          propD: {                      // число со значением по умолчанию
            type: Number,
            default: 100
          },
          propE: {                      // значения по умолчанию для объектов и массивов должны задаваться через функцию
            type: Object,
            default: function () {
              return { message: 'привет!' }
            }
          },
          propF: {                      // пользовательская функция для валидации
            validator: function (value) {
              return value > 10
            }
          }
        }
      })

    • Опции валидации
      - default     | задать значение по умолчанию
      - type        | валидация типа значения
      - validator   | пользовательская функция-валидатор
      - required    | обязательное значение

    • Доступные значения для type (все JS-типы)

      ▪ String
      ▪ Number
      ▪ Boolean
      ▪ Function
      ▪ Object
      ▪ Array
      ▪ Symbol

  # Концепция однонаправленного потока данных
    
    • Позволяет легче понимать структуру потоков данных в приложении
      - В knockoutjs направленность потоков данных не ограничивалась.
      - В больших приложениях это приводило к спагетти-потокам данных.
      - К хаусу, разобраться в котором мог лишь разработчик этого приложения.
      - Да и то, лишь пока не прошло слишком много времени, и он всё не забыл.
      - Многие это заметили, и родилась концепция однонаправленного потока данных.
      - Благодаря ей проще держать под контролем потоки данных приложения.
      - Даже если это чужой код, в потоках данных легко разобраться.

    • Не меняй вручную значения входных параметров
      - Потому что это бессмысленно и опасно.
      - Ведь они чаще всего будут привязаны к наблюдаемым родителя.
      - И когда значение наблюдаемой изменится, значение параметра обновится.
      - Внесённые тобой изменения затрутся, и это может стать неожиданностью.

> Пользовательские события

  # Система кастомных событий Vue

    • Независима от браузерной
      - Полностью отделена от системы событий браузера. 
      - Это разные, совершенно не связанные вещи.
      - $on != addEventListener, $emit != dispatchEvent.

    • Методы интерфейса событий Vue

      ▪ $on
        - Назначить обработчик кастомного события.
        - Допустим, есть у нас vue-экземпляр bus:

            bus.$on('id-selected', function (id) {
              // ...
            })

      ▪ $emit
        - Возбудить кастомное событие.
        - Допустим, есть у нас vue-экземпляр bus:

            bus.$emit('id-selected', 1)

  # Способы коммуникации между компонентами

    • v-on: родительский компонент <--- дочерний компонент
      
      ▪ Только родитель-дочка
        - Этот способ только для связки родительский-дочерний компоненты.
        - Не надо путать это с "предок-потомок". Только для "родитель-дочка".
      
      ▪ Нельзя использовать $on, нет доступа к модели дочки
        - Дочерний компонент может возбуждать кастомные события.
        - Родительский компонент может обрабатывать эти события.
        - Но использовать $on прямо он не может (нет доступа к модели).
      
      ▪ Надо использовать v-on, на примере
        - Поэтому, он должен использовать v-on.
        - Пример:

        ▪ Шаблон

          <div id="counter-event-example">
            <p>{{ total }}</p>
            <button-counter v-on:increment="incrementTotal"></button-counter>
            <button-counter v-on:increment="incrementTotal"></button-counter>
          </div>      

        ▪ Компонент

          Vue.component('button-counter', {
            template: '<button v-on:click="increment">{{ counter }}</button>',
            data: function () {
              return {
                counter: 0
              }
            },
            methods: {
              increment: function () {
                this.counter += 1
                this.$emit('increment')
              }
            },
          })

        ▪ Модель

          new Vue({
            el: '#counter-event-example',
            data: {
              total: 0
            },
            methods: {
              incrementTotal: function () {
                this.total += 1
              }
            }
          })      

    • Через вспомогательный vue-экземпляр: связь для не-родственников

      ▪ Подходит для простых приложений
        - А для более сложных авторы советуют vuex.

      ▪ Подходит для связи между любыми компонентами
        - В том числе, и между родителем-дочкой.
        - Но для последних лучше использовать v-on.

      ▪ Принцип связи: через вспомогательный vue-экземпляр
        - Где-то создаём вспомогательные vue-экземпляр.
        - И прямо на нём применяем методы $on и $emit.
        - И пускаем поток данных между ком-ми через экземпляр.

      ▪ Пример связи через вспомогательный vue-экземпляр

          var bus = new Vue()                     // Создаём вспомогательный vue-экземпляр
          bus.$emit('id-selected', 1)             // В методе компонента А
          bus.$on('id-selected', function (id) {  // В хуке created метода B
            // ...
          })

    • Через vuex

      ▪ Подходит для средних и крупных SPA-приложений
        - Хотя никто не запрещает использовать подход и для простых.
        - Но в этом случае накладные расходы могут себя не окупать.
        - Хотя, с точки зрения универсальности, лучше всегда задействовать vuex.

      ▪ Публичная/Приватная части модели компонента
        - Концепция vuex подразумевает следующее.
        - Мы делим модель компонента на публичную/приватную.
        - Публичная часть выносится в объект-хранилище vuex.
        - С публичной частью может взаимодействовать любой компонент.

      ▪ Что такое vuex
        - Либа для управления централизованным хранилищем 
          публичных моделей компонентов приложения.
        - Одновременно, термином vuex называют и соответствующий паттерн.
        - Поддерживает продвинутый функционал, такой как:

          ▪ Техника отладки "машина времени" из коробки
          ▪ Экспрорт/Импорт снэпшотов

> Модификаторы .sync, .native; директива v-model

  # Модификатор .sync: работает через систему событий Vue
    - Он позволяет организовать 2-направленный биндинг.
    - Но сам по себе является лишь синтаксическим сахаром.
    - Этот код:

        <comp :foo.sync="bar"></comp>

    - Преобразуется компилятормо vue в:

        <comp :foo="bar" @update:foo="val => bar = val"></comp>

    - И, допустим, дочерний компонент хочет обновить foo.
    - Он не должен прямо менять значение св-ва foo.
    - А должен сделать это через событие:

        this.$emit('update:foo', newValue)

  # Модификатор .native: обрабатывать события из браузера
    - Иногда надо через v-on назначить обработчик для события браузера.
    - Ведь в системах события vue/браузера м.б. события с одинаковым именем.
    - Например: click.
    - И, допустим, мы хотим обрабатывать только события браузера.
    - Тогда и надо использовать модификатор .native:

      <my-component v-on:click.native="doTheThing"></my-component>

  # Директива v-model: лишь синтаксический сахар
    
    ▪ Как она работает
      - Она позволяет нам организовать 2-сторонний биндинг.
      - Но сама по себе является лишь синтаксическим сахаром, как и .sync
      - Этот код:

          <input v-model="something">

      - Преобразуется компилятормо vue в:

          <input
            v-bind:value="something"
            v-on:input="something = $event.target.value">

    ▪ Как застаить работать v-model с компонентом
      - Допустим, у нас есть компонент currency-input.
      - В его шаблоне есть какой-то input.
      - Мы хотим сделать возможным применение v-model
        прямо на псевдоэлементе компонента, для организации
        2-сторонней связи со свойством компонента price.
      - Тогда нам надо сделать 2 вещи с input в шаблоне:

          1. Связать его через v-bind со св-вом price.
          2. Назначить обработчик события input, который
             обновляет значение price текущи значением из input.
      - Пример:

        ▪ Использование компонента с v-model

          <currency-input v-model="price"></currency-input>

        ▪ Компонент

          Vue.component('currency-input', {
            template: `
              <span>
                $
                <input
                  ref="input"
                  v-bind:value="value"
                  v-on:input="updateValue($event.target.value)">
              </span>
            `,
            props: ['value'],
            methods: {
              // Instead of updating the value directly, this
              // method is used to format and place constraints
              // on the input's value
              updateValue: function (value) {
                var formattedValue = value
                  // Remove whitespace on either side
                  .trim()
                  // Shorten to 2 decimal places
                  .slice(
                    0,
                    value.indexOf('.') === -1
                      ? value.length
                      : value.indexOf('.') + 3
                  )
                // If the value was not already normalized,
                // manually override it to conform
                if (formattedValue !== value) {
                  this.$refs.input.value = formattedValue
                }
                // Emit the number value through the input event
                this.$emit('input', Number(formattedValue))
              }
            }
          })        

> Слоты

  # Слоты: в чём суть кратко

    • Суть слотов кратко
      - Допустим, есть у нас компонент comp.
      - У него есть собственный какой-то шаблон.
      - Где-то в другом шаблоне comp могут использовать.
      - Это делают через псевдоэлемент DOM.
      - Например:

          <comp></comp>      

      - Однако, внутри псевдоэлемента может быть контент.
      - Например:

          <comp>
            Контент
          </comp>

      - Вопрос в том, куда девается этот контент?
      - Ведь у comp есть уже свой какой-то шаблон.
      - Встраивается ли этот контент как-то в этот шаблон?
      - Или он просто отбрасывается?
      - Или он как-то модифицирует шаблон?
      - Механизм слотов как раз и позволяет всем этим управлять.

    • Замечание об областях видимости при компиляции шаблонов
      - Шаблон компонента компилируется в области видимости компонента.
      - Шаблон родителя компонента компилируется в области видимости родителя.
      - Частая ошибка, обращение к св-ву из модели дочернего
        компонента из родительского компонента:

          <!-- Это не сработает -->
          <child-component v-show="someChildProperty"></child-component>

  # Если <slot> отсутствует: контент псевдоэлемента игнорирутеся
    - Например:

      ▪ Шаблон компонента comp: эл-в <slot> нет

          <div>
            <h2>I'm the child title</h2>
          </div>

      ▪ Шаблон, где используется comp
        - Внутри comp есть контент.

          <div>
            <h1>I'm the parent title</h1>
            <comp>
              Контент
            </comp>
          </div>

      ▪ Результат рендеринга
        - Строки "Контент" в нём нет.
        - Ведь в шаблоне comp нет ни 1-го <slot>.

          <div>
            <h1>I'm the parent title</h1>
            <div>
              <h2>I'm the child title</h2>
            </div>
          </div>      

  # Если есть 1-ин <slot>: подменяется контентом псевдоэлемента
    - Например:

      ▪ Шаблон компонента comp, есть 1 <slot>
        
          <div>
            <h2>I'm the child title</h2>
            <slot></slot>
          </div>

      ▪ Шаблон, где используется comp
        - Внутри comp есть контент.

          <div>
            <h1>I'm the parent title</h1>
            <comp>
              Контент
            </comp>
          </div>

      ▪ Результат рендеринга
        - Вместо <slot> мы видим контент псевдоэлемента.

          <div>
            <h1>I'm the parent title</h1>
            <div>
              <h2>I'm the child title</h2>
              Контент
            </div>
          </div>

  # Запасной контент слота: если в <slot> нечего вставлять
    - Бывает, что в <slot> нечего вставить.
    - Например, когда внутри псевдоэлемента нет контента:

        <comp></comp>

    - Тогда при рендеринге что будет подставлено вместо slot?
    - Будет подставлен контент псевдоэлемента slot:

        <slot>Контент</slot>

    - Этот контент и называют запасным контентом слота.

  # Именные <slot>: что в слот с каким именем распихать
    - Всё, что можно, будет распихано по именным слотам.
    - А всё остальное в оставшийся не именной <slot>.
    - Например:

      ▪ Шаблон компонента comp: эл-в <slot> нет
        - В нём есть 3 слота.
        - Один основной (не именной, <slot></slot>).
        - И два именных, с именами name1 и name2.

          <div>
            <h2>I'm the child title</h2>
            <slot name="name1"></slot>
            <slot name="name2"></slot>
            <slot></slot>
          </div>

      ▪ Шаблон, где используется comp
        - Внутри comp есть контент.
        - С помощью атрибута slot можно указывать,
          в слот с каким именем какой контент запихивать.
        - Если атрибута slot нет, значит запихивать в основной.

          <div>
            <h1>I'm the parent title</h1>
            <comp>

              <span slot="name1">Это запихнуть в слот name1</span>
              <span slot="name2">Это запихнуть в слот name2</span>
              
              <span>А всё остальное</span>
              <span>запихнуть</span>
              <span>в основной слот</span>

            </comp>
          </div>

      ▪ Результат рендеринга
        - Весь контент распихан по указанным слотам.

          <div>
            <h2>I'm the child title</h2>

            <span slot="name1">Это запихнуть в слот name1</span>
            <span slot="name2">Это запихнуть в слот name2</span>

            <span>А всё остальное</span>
            <span>запихнуть</span>
            <span>в основной слот</span>

          </div>   

  # Scoped slots: кастомизация шаблона компонента через контент псевдоэлемента

    • Инструмент для кастомизации компонентов
      - Разработчик компонента может предусмотреть кастомизацию.
      - Для кастомизации нужен особый контент в псевдоэлементе компонента.
      - Используется псевдоэлемент template с атрибутом scope="props".

    • Пример использования scoped slots
      - Допустим, есть компонент list.
      - Он может выводить списки.
      - Причём, формат вывода можно кастомизировать.
      - Кастомизация проводится как раз через scoped slots.

        ▪ Шаблон компонента list
          - Атрибут name указывает имя слота: "item".
          - В data компонента есть наблюдаемый массив items,
            атрибут v-for указывает, что нужен перебор по items.
          - Атрибут v-bind:text связывает атрибут text с item.text 

            <ul>
              <slot name="item" v-for="item in items" :text="item.text">
              </slot>
            </ul>

        ▪ Шаблон, где используется list
          - Здесь в компонент передаётся параметр items
            (ссылка на массив из data родит.экземпляра/компонента).
          - Применяется псевдоэлемент template, который будет 
            распихан в слот с именем "item".
          - У template также есть атрибут scope, что обозначает,
            что данный слот является scoped.
          - props содержит переданные в шаблоне компонента list
            в виде атрибутов параметры, к которым можно обращаться
            внутри template.

              <list :items="items">
                <template slot="item" scope="props">
                  <li class="my-fancy-item">{{ props.text }}</li>
                </template>
              </list>

> Горячая замена компонентов

  # Горячая замена: пример

    • Модель

        var vm = new Vue({
          el: '#example',
          data: {
            currentView: 'home'
          },
          components: {
            home: { /* ... */ },
            posts: { /* ... */ },
            archive: { /* ... */ }
          }
        })

    • Шаблон
      - Применяется псевдоэлемент <component>.
      - Код:

        <component v-bind:is="currentView">
          <!-- изменяя vm.currentView можно переключаться между компонентами -->
        </component>    

  # Горячая замена: через прямую ссылку на объект компонента

      var Home = {
        template: '<p>Добро пожаловать домой!</p>'
      }

      var vm = new Vue({
        el: '#example',
        data: {
          currentView: Home
        }
      })

  # Псевдоэлемент <keep-alive>: хранить отключенные ком-ты в памяти
    - Иногда бывает выгодно хранить отключенные компоненты в памяти.
    - Чтобы не терять их состояния, и не выполнять их повторный рендеринг.
    - Для этого нужно обернуть динамический компонент в псевдоэлемент <keep-alive>.
    - Например:

        <keep-alive>
          <component :is="currentView">
            <!-- неактивные компоненты будут закешированы! -->
          </component>
        </keep-alive>

> Прочие темы, касающиеся компонентов

  # Создание компонентов для повторного использования

    • Предназначен ли компонент для повторного использования?
      - Некоторые компоненты м.б. предназначены, а другие нет.
      - Если не предназначен, то компонент м.б. и сильно связан.
      - А если предназначет, то должен быть MAX автономен.

    • Чёткий API для повторно используемых компонентов

      ▪ Входные параметры   | Которые принимает компонент
      ▪ События             | Которые возбуждает компонент
      ▪ Слоты               | Которые есть в шаблоне компонента

    • Краткий и чёткий способ описания API компонента

      <my-component
        :foo="baz"
        :bar="qux"
        @event-a="doThis"
        @event-b="doThat"
      >
        <img slot="icon" src="...">
        <p slot="main-text">Привет!</p>
      </my-component>   

  # Ссылки на компоненты-потомки

    • Атрибут ref: способ получить ссылки на объекты-модели компонентов-потомков

      ▪ Применяем атрибут ref

        <div id="parent">
          <user-profile ref="profile"></user-profile>
        </div>

      ▪ Получаем ссылку на модель компонента-потомка через модель родителя

        var parent = new Vue({ el: '#parent' })
        // получаем экземпляр компонента-потомка
        var child = parent.$refs.profile      

    • При использовании с v-for, будет возвращён массив ссылок
      - На соответствующие объекты-модели потомков.

    • Объект $refs заполняется только после рендеринга компонента
      - Это надо иметь в виду.

    • Используй эту возможность лишь в крайних случаях
      - Вообще, это считается плохой практикой.

  # Асинхронные компоненты

    • Приложение на части; подгрузка оных по мере необходимости
      - Часто SPA-приложения разрастаются до неприличных размеров.
      - Если грузить в ответ на GET-запрос всё, это может занять вечность.
      - Поэтому, есть смысл грузить сразу лишь запрошенный кусок.
      - А остальное подгружать по мере возникновения необходимости.

    • Определить компонент, как функцию фабрику
      - Vue позволяет определить компонент, как функцию-фабрику.
      - Эта функция асинхронно возвращает определение компонента.
      - Vue вызовет фабричную функцию, только когда она понадобится.
      - Результат будет закэширован для дальнейшего использования.
      
    • Пример компонента, определённого, как фабрика
      - Здесь чисто для примера использован setTimeout.
      - Вообще, можно передавать методы resolve и reject.
      - Код:

        Vue.component('async-example', function (resolve, reject) {
          setTimeout(function () {
            // Передаём шаблон компонента в коллбэк resolve
            resolve({
              template: '<div>Я — асинхронный!</div>'
            })
          }, 1000)
        })     

    • Пример использования промисов с Webpack 2

        Vue.component(
          'async-webpack-example',
          () => import('./my-async-component')
        )     

  # Продвинутые асинхронные компоненты
    
    • Новая версия объекта для фабрики компонентов (version >=2.3)
      - Начиная с v2.3 фабрика АК может возвращать объект, как ниже.
      - Нужно будет также использовать vue-router версии >= 2.4.0.
      - Код:

        const AsyncComp = () => ({
          component: import('./MyComp.vue'),  // Загружаемый компонент. Значение должно быть Promise
          loading: LoadingComp,               // Компонент загрузки, используемый пока загружается асинхронный компонент
          error: ErrorComp,                   // Компонент ошибки, используемый при неудачной загрузке
          delay: 200,                         // Задержка перед показом компонента загрузки. По умолчанию: 200ms.
          timeout: 3000                       // Компонент ошибки будет отображаться если таймаут был указан и время ожидания превышено. По умолчанию: Infinity (бесконечное ожидание).
        })    

  # Соглашения по именованию компонентов

    • Нижний регистр
      - Потому что шаблон может быть определён в HTML.
      - А HTML регистронезависим.
      - Чтобы не путать себя и людей, всегда используем нижний регистр.

    • Кебаб-стайл
      - Пример кебаб-стайла: <kebab-style-component>.
      - camelStyle и TitleStyle не подойдут из-за верхнего регистра.
      - Так что, для названия компонентов используем kebab-style.

  # Рекурсивные компоненты

    • Компонент может рекурсивно вызвать самого себя
      - Но для этого должна быть указана опция name:

        name: 'unique-name-of-my-component'

    • При глобальной регистрации name равна глобальному ID компонента
      - Компонент можно зарегистрировать глобально с помощью Vue.component.
      - Тогда name автоматически становится равна его глобальному ID. 
      - Пример:

        Vue.component('unique-name-of-my-component', {
          // ...
        })      

    • Осторожно: беспонечные циклы
      - Бесконечный цикл приведёт к ошибке переполнения стека.
      - Поэтому следите, чтобы рекурсивный вызов был условным,
        т.е. чтобы в нём была директива v-if, которая рано или
        поздно станет ложной.
      - Пример бесконечного цикла:

        name: 'stack-overflow',
        template: '<div><stack-overflow></stack-overflow></div>'

  # Циклические ссылки между компонентами
    - Допустим, мы проэктируем дерево.
    - Каждый узел одновременно и предок, и потомок другого узла.
    - Этот парадокс Vue разрешает автоматом при глобальной регистрации.
    - Но при импорте через webpack возникает ошибка:

        Failed to mount component: template or render function not defined.

    - Чтобы это исправить, нам надо указать сборщику точку,
      в которой он сможет сказать: "рано или поздно для 
      разрешения А нужно разрешить Б, но нет необходимости
      разрешать Б прямо сейчас".
    - Пример - не регистрировать компонент, пока не наступит событие beforeCreate:

        beforeCreate: function () {
          this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
        }    

  # Inline-шаблоны

    • Атрибут inline-template у компонента
      - Без него содержимое компонента будет распихано по слотам в его шаблоне.
      - А с ним оно само будет использовано, как шаблон.
      - Например:

          <my-component inline-template>
            <div>
              <p>Этот шаблон будет скомпилирован в области видимости компонента-потомка.</p>
              <p>Доступа к данным родителя нет.</p>
            </div>
          </my-component>   
        
    • Не надо путать себя и людей
      - С другой стороны, это может иногда путать.
      - Так что лучше определять шаблон в опции template в конструкторе компонента.   

  # Определение шаблонов через X-Template
    
    • Ещё один способ задать шаблоны
      - Через элементы stript с типом text/x-template.
      - Например:

          <script type="text/x-template" id="hello-world-template">
            <p>Привет привет привет</p>
          </script> 

          Vue.component('hello-world', {
            template: '#hello-world-template'
          })

    • Не надо путать себя и людей
      - Эта возможность бывает полезна для демо-приложений, или для мелких.
      - В целом, такого подхода следует избегать, т.к. шаблон
        отделяется от остальных частей определения компонента.
      - Так что лучше определять шаблон в опции template в конструкторе компонента.   

  # “Дешёвые” статические компоненты с использованием v-once

    • Экономим, не делая перерендеринг статических данных
      - Бывает, что статических данных в компоненте много.
      - А ему надо часто перерисовываться.
      - И постоянно всё это перерисовывать становится накладно.

    • Атрибут v-once, как решение проблемы
      - Помечаем атрибутом v-once всю статику.
      - Тогда она будет отрисовываться 1 раз на старте.
      - Например:

          Vue.component('terms-of-service', {
            template: '\
              <div v-once>\
                <h1>Условия Использования</h1>\
                ... много-много статического контента ...\
              </div>\
            '
          })      


Б1. Подробно о реактивности

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Как отслеживаются изменения

    ▪ Опция data, пары геттер/сеттер
    ▪ Инструменты разработчика Vue-devtools
    ▪ Экземпляры и наблюдатели

  # Особенности отслеживания изменений

    ▪ Vue не позволяет динамически добавлять/удалять корневые св-ва в data
    ▪ Однако, можно добавить реактивное св-во во вложенные объекты

  # Объявление реактивных свойств

    ▪ Все корневые св-ва надо инициализировать при создании экземпляра
    ▪ Это решает проблемы с граничными случаями, облегчает поддержку

  # Асинхронная очередь обновлений

    ▪ В Vue обносление DOM выполняется асинхронно
    ▪ Vue.nextTick: дождаться обновления DOM, и лишь тогда выполнить код
    ▪ vm.$nextTick: используй внутри компонентов, this содержит модель оных

--------------------------------------

> Ссылки

  # [Официальное руководство] Подробно о реактивности
      https://ru.vuejs.org/v2/guide/reactivity.html

> Введение
  - В Vue применяется механизм ненавязчивой реактивности.
  - В качестве моделей используются простые JS-объекты.
  - При изменении объектоа, автоматически меняется и представление.
  - Это делает управление состоянием приложения простым и очевидным.
  - Как и везде, у реализации реактивности в Vue есть свои нюансы.
  - В этой главе рассмотрим его низкоуровневую реализацию и эти нюансы.

> Как отслеживаются изменения

  • Опция data, пары геттер/сеттер
    - В конструкторе Vue есть опция data.
    - Туда передают простой js-объект.
    - Vue обходит все его поля, превращая в пары геттер/сеттер.
    - Для этого используется Object.defineProperty.
    - Эта возможность появилась в ES5.
    - В версиях до ES5 эмулировать её не выйдет.
    - Поэтому Vue не поддерживает IE <= 8.

  • Инструменты разработчика Vue-devtools
    - Геттеры/сеттеры не видны пользователю.
    - Но именно они обеспечивают мехинизм реактивности Vue.
    - Однако, при выводе в консоль, data не выглядит, как обычный объект.
    - Поэтому, для наглядной визуализации, используй Vue-devtools.

  • Экземпляры и наблюдатели
    - Каждый экземпляр компонента связан экземпляром наблюдателя.
    - Он помечает все поля, затронутые при рендеринге компонента, как зависимости.
    - В дальнейшем значение поля м.б. изменено (вызывается его сеттер).
    - При этом сеттер уведомляет наблюдателя.
    - А оный, в свою очередь, инициирует повторный рендеринг компонента.

> Особенности отслеживания изменений

  • Vue не позволяет динамически добавлять/удалять корневые св-ва в data
    - В силу ограничений современного JS.
    - А также отказа от Object.observe.
    - Чтобы поле стало реактивным, оно д.б. в data на старте.
    - Иллюстрация:

        // `vm.a` будет реактивным полем
        var vm = new Vue({
          data: {
            a: 1
          }
        })
        
        // `vm.b` НЕ реактивно
        vm.b = 2

  • Однако, можно добавить реактивное св-во во вложенные объекты

    ▪ Добавление во вложенные объекты
      - Нет способа динамически добавить новое корневое реактивное св-во.
      - Однако, в data можно разместить объект.
      - И в этот объект уже можно добавлять реактивные св-ва.
      - Для этого есть метод Vue.set

    ▪ Глобальный метод Vue.set(object, key, value)

        Vue.set(vm.someObject, 'b', 2)

    ▪ Метод экземпляра vm.$set
      - Представляет собой псевдоним к глобальному Vue.set.
      - Пример:

          this.$set(this.someObject, 'b', 2)

> Объявление реактивных свойств

  • Все корневые св-ва надо инициализировать при создании экземпляра
    - Ведь Vue не позволит добавить их после создания экземпляра.
    - Поэтому, надо всех их сразу перечислить в конструкторе.
    - И инициализировать, даже хотя бы пустыми значениями.
    - Например:

        var vm = new Vue({
          data: {
            // объявляем поле message, содержащее пустую строку
            // Если не задать поле message, Vue выведет warning.
            message: ''
          },
          template: '<div>{{ message }}</div>'
        })

        // впоследствии задаём значение `message`
        vm.message = 'Hello!'

  • Это решает проблемы с граничными случаями, облегчает поддержку
    - Существуют технические причины для этого ограничения.
    - Во-первых, оно позволяет исключить целый класс граничных 
      случаев в системе учета зависимостей.
    - Во-вторых, упростить взаимодействие Vue с системами проверки типов.
    - В-третьих, облегчает поддержку кода. Т.К. теперь объект data
      можно рассматривать, как схему состояния компонента. Код, в котором
      реактивные св-ва компонента перечислены заранее, намного проще
      для понимания.

> Асинхронная очередь обновлений

  • В Vue обносление DOM выполняется асинхронно
    - Каждый раз при изменении данных создаётся очередь.
    - Она, как буфер, для изменений на текущем тике цикла событий.
    - Если на тике один и тот же наблюдатель срабатывает несколько раз,
      то в очереди в итоге оказывается лишь одна связанная с ним задача.
    - Благодаря буферу и устранинию дубликатов манипуляции с DOM минимизируются.
    - На следующем тике Vue разбирает очередь и выполняет актуальные обновления.
    - На низком уровне для асинхронной постановки задач используются
      Promise.then и MutationObserver, а если они недоступны, то setTimeout.

  • Vue.nextTick: дождаться обновления DOM, и лишь тогда выполнить код
    - Как рассказано выше, при изменении в data DOM обновится не мгновенно.
    - А лишь на следующем тике, при разборе очереди.
    - Но иногда бывает нужно дождаться состояния, в котором DOM обновлён.
    - И лишь после этого выполнять какой-то код.
    - Чтобы выполнить код на следующем тике: Vue.nextTick(callback)
    - Например:

      ▪ Шаблон

        <div id="example">{{ message }}</div>

      ▪ Модель

        var vm = new Vue({
          el: '#example',
          data: {
            message: '123'
          }
        })
        vm.message = 'новое сообщение' // изменяем данные
        vm.$el.textContent === 'новое сообщение' // false
        Vue.nextTick(function () {
          vm.$el.textContent === 'новое сообщение' // true
        })

  • vm.$nextTick: используй внутри компонентов, this содержит модель оных
    - Особенно подходит для использования внутри компонентов.
    - Ведь он не требует обращения к глобальной переменной Vue.
    - А также автоматически связывает контекст this коллбэка с текущим экземпляром Vue.
    - Например:

        Vue.component('example', {
          template: '<span>{{ message }}</span>',
          data: function () {
            return {
              message: 'не обновлено'
            }
          },
          methods: {
            updateMessage: function () {
              this.message = 'обновлено'
              console.log(this.$el.textContent) // => 'не обновлено'
              this.$nextTick(function () {
                console.log(this.$el.textContent) // => 'обновлено'
              })
            }
          }
        })


Б2. Анимирование эффектов переходов

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение  

    ▪ Анимация переходов при обновлении/добавлении/удалении эл-в DOM

  # Анимирование одиночного DOM-элемента/компонента

    • Компонент-обёртка <transition></transition>
      ▪ Анимация появления/исчезновения в следующих случаях
        ▪ Условный рендеринг (используя v-if)
        ▪ Условное отображение (используя v-show)
        ▪ Динамические компоненты
        ▪ Корневые элементы компонентов
      ▪ Пример применения transition
      ▪ Что происходит за сценой при применении transition

    • Классы переходов
      
      ▪ 6 классов переходов
        ▪ Наглядная иллюстрация классов анимации переходов
        ▪ v-enter         | начало анимации появления
        ▪ v-enter-active  | остаётся в течение всей анимации появления
        ▪ v-enter-to      | анимация появления завершается
        ▪ v-leave         | начало анимации исчезновения
        ▪ v-leave-active  | остаётся в течение всей анимации исчезновения
        ▪ v-leave-to      | анимация исчезновения завершается

      ▪ Префикс для классов переходов: v- / атрибут name из transition
        ▪ Префикс по умолчанию в отсутствие name: v-
        ▪ Кастомизация классов по умолчанию: атрибут name для transition

      ▪ Переопределение имён классов переходов через атрибуты transition
        ▪ enter-class
        ▪ enter-active-class
        ▪ enter-to-class
        ▪ leave-class
        ▪ leave-active-class
        ▪ leave-to-class

    • CSS transition: пример
    • CSS animation: пример
    • Совместное использование transiton и animation
    • Настройка длительности transition: опция duration
    • JS-хуки переходов
      ▪ JS-хуки можно применять на псевдоэлементе transition
      ▪ Список JS-хуков переходов
        
        ▪ before-enter      | v-on:before-enter     ="beforeEnter"
        ▪ enter             | v-on:enter            ="enter"
        ▪ after-enter       | v-on:after-enter      ="afterEnter"
        ▪ enter-cancelled   | v-on:enter-cancelled  ="enterCancelled"
        ▪ before-leave      | v-on:before-leave     ="beforeLeave"
        ▪ leave             | v-on:on:leave         ="leave"
        ▪ after-leave       | v-on:after-leave      ="afterLeave"
        ▪ leave-cancelled   | v-on:leave-cancelled  ="leaveCancelled"
      
      ▪ Схема использования JS-хуков переходов
      ▪ Для JS-переходов ВСЕГДА используй коллбэки done в хуках enter / leave
      ▪ Для JS-переходов указывай: v-bind:css="false"
      ▪ Пример использования JS-хуков перехода с Velocity.js

  # Переходы при первичном рендеринге

    • По умолчанию, на старте анимация не срабатывает
    • Атрибут appear для transition запустит appear-анимацию на старте
    • Кастомные CSS-классы для appear-анимации с помощью атрибутов
      
      ▪ Пример кастомных CSS-стилей для appear-анимации
      ▪ appear-class
      ▪ appear-to-class
      ▪ appear-active-class

    • Кастомные JS-хуки для appear-анимации

      ▪ Пример кастомных JS-хуков для appear-анимации
      ▪ before-appear       | v-on:before-appear="customBeforeAppearHook"
      ▪ appear              | v-on:appear="customAppearHook"
      ▪ after-appear        | v-on:after-appear="customAfterAppearHook"
      ▪ appear-cancelled    | v-on:appear-cancelled="customAppearCancelledHook"
    
  # Переходы между DOM-элементами

    • Переход между DOM-эл-ми с разными тегами с помощью v-if / v-else
    • Переход между DOM-эл-ми с одинаковым тегами

      ▪ Нужно использовать атрибут key
      ▪ Техника перехода с помощью v-if / v-else
      ▪ [Продвинутая] Техника перехода с помощью key
 
    • Режимы работы transition: атрибут mode

      ▪ sync    | [по умолчанию] Одновременно
      ▪ in-out  | Сначала входит новый, потом выходит старый
      ▪ out-in  | Сначала выходит старый, потом входит новый
 
  # Переходы между компонентами
    
    • Атрибут key не нужен, используем component - динамиеский компонент    
 
  # Переходы в списках

    • Компонент <transition-group> для анимации списков

      ▪ Используется для sync-анимации в v-for списках
      ▪ <transition-group> рендерится в реальный DOM-элемент
        ▪ По умолчанию <transition-group> рендерится в <span>
        ▪ Атрибут tag: указать, в какой тег среднерится <transition-group>
      ▪ Элементы списка внутри <transition-group> ВСЕГДА ДОЛЖНЫ иметь уникальный key

    • Анимация добавления/удаления из списка
    • Анимация изменения позиции в списке
      ▪ Класс v-move на время анимации
      ▪ Атрибут move-class для назначения кастомного имени для v-move
      ▪ Не работает с элементами с display: inline
      ▪ Простой пример анимации изменения позиции в списке
      ▪ Пример с анимацей всего: добавления/удаления/изменения позиции

    • Анимация фильтрации списка
      ▪ Что имеется в виду под анимацией фильтрации
      ▪ Пример анимации фильтрации списка

  # Повторно используемые переходы

    • Пример компонента, реализующего повторно используемый переход
    • Используй функциональные компоненты для повторных переходов (пример)

  # Динамические переходы: меняем св-ва анимации на основе data
 
    • Что имеется в виду под динамическими переходами?
    • Меняем css-классы анимаций в зависимости от св-ва модели
    • Меняем js-хуки velocity-анимаций в зависимости от св-ва модели
 
--------------------------------------

> Ссылки

  # [Официальное руководство] Анимированные эффекты переходов
      https://ru.vuejs.org/v2/guide/transitions.html

  # Техника анимации FLIP
      https://aerotwist.com/blog/flip-your-animations/

> Введение
  
  • Анимация переходов при обновлении/добавлении/удалении эл-в DOM
    - В Vue есть встроенны инструменты для работы с анимацией переходов.
    - Они дают возможность:

      ▪ Автоматически примененять CSS-классы для анимаций и переходов.
      ▪ Интегрировать сторонние библиотеки CSS-анимаций, такие как Animate.css.
      ▪ Использовать JavaScript для работы с DOM напрямую в transition-хуках.
      ▪ Интегрировать сторонние библиотеки JavaScript-анимаций, такие как Velocity.js.

> Анимирование одиночного DOM-элемента/компонента

  • Компонент-обёртка <transition></transition>
    
    ▪ Анимация появления/исчезновения в следующих случаях

      ▪ Условный рендеринг (используя v-if)
      ▪ Условное отображение (используя v-show)
      ▪ Динамические компоненты
      ▪ Корневые элементы компонентов

    ▪ Пример применения transition

      ▪ Шаблон

        <div id="demo">
          <button v-on:click="show = !show">
            Переключить
          </button>
          <transition name="fade">
            <p v-if="show">hello</p>
          </transition>
        </div>

      ▪ Модель

        new Vue({
          el: '#demo',
          data: {
            show: true
          }
        })

      ▪ Стили

        .fade-enter-active, .fade-leave-active {
          transition: opacity .5s
        }
        .fade-enter, .fade-leave-to /* .fade-leave-active для <2.1.8 */ {
          opacity: 0
        }

    ▪ Что происходит за сценой при применении transition

      1. Vue автоматически узнаёт, применены ли к целевому 
         ементу CSS-переходы или анимации. Если да, 
         соответствующие CSS-классы будут должным образом 
         обновлены в нужные моменты времени.

      2. Если для компонента указаны хуки JavaScript, они 
         будут вызваны в соответствующие моменты времени.

      3. Если не обнаружено ни CSS-переходов и анимаций, 
         ни JavaScript-хуков, операции DOM для вставки или 
         удаления элемента будут выполнены непосредственно 
         в следующем анимационном фрейме (важно: речь идёт 
         об анимационном фрейме браузера, отличном от 
         используемой во Vue концепции nextTick).

  • Классы переходов
    
    ▪ 6 классов переходов

      ▪ Наглядная иллюстрация классов анимации переходов

        Enter                       Leave                                  
        ------------------------>   ------------------------>                                
                                      
        Opacity: 0    Opacity:1     Opacity: 1    Opacity:0                                          
            |             |             |             |                                          
        [v-enter]    [v-enter-to]   [v-leave]    [v-leave-to]                                          
            |             |             |             |                                          
            ---------------             ---------------                                          
            [v-enter-active]            [v-leave-active]                                           

      ▪ v-enter
        - Начало анимации появления.
        - Добавляется перед вставкой элемента.
        - Удаляется в следующем фрейме после вставки.

      ▪ v-enter-active
        - Означает, что идёт анимация появления.
        - Остаётся в течение всей анимации появления.
        - Добавляется перед вставкой элемента.
        - Удаляется, как только анимация прекратилась.
        - Используй его для установки duration / delay 
          / easing curve анимации перехода.

      ▪ v-enter-to
        - Анимация появления завершается.
        - Добавляетс в следующем фрейме после вставки эл-та,
          тогда же, когда будет удалён v-enter.
        - Удаляется после завершения анимации перехода.

      ▪ v-leave
        - Начало анимации исчезновения.
        - Аналог v-enter.

      ▪ v-leave-active
        - Остаётся в течение всей анимации исчезновения.
        - Аналог v-enter-active.

      ▪ v-leave-to
        - Анимация исчезновения завершается.
        - Аналог v-enter-to.

    ▪ Префикс для классов переходов: v- / атрибут name из transition

      ▪ Префикс по умолчанию в отсутствие name: v-
        - Если в <transition> отсутствует атрибут name.
        - Тогда он подхватит классы со стандартным префиксом v-
        - Можно считать эти классы оными по умолчанию для transition без name.

      ▪ Кастомизация классов по умолчанию: атрибут name для transition
        - Псевдоэлементу <transition> можно указать атрибут name.
        - Тогда он будет пытаться подсосать классы с префиксом,
          равным значению name.
        - Например, вместо класса v-enter будет применяться my-transition-enter:

            <transition name="my-transition">

    ▪ Переопределение имён классов переходов через атрибуты transition
      - Названия классов переходов можно переопределить для конкретного transition.
      - Для этого можно использовать перечисленные ниже атрибуты:

        ▪ enter-class
        ▪ enter-active-class
        ▪ enter-to-class
        ▪ leave-class
        ▪ leave-active-class
        ▪ leave-to-class

      - Это м.б. полезно для комбинирования системы анимированных
        переходов Vue с возможностями сторонних библиотек
        css-анимаций, таких как Animate.css
      - Пример:

        ▪ Шаблон

          <link href="https://unpkg.com/animate.css@3.5.1/animate.min.css" rel="stylesheet" type="text/css">
          <div id="example-3">
            <button @click="show = !show">
              Переключить рендеринг
            </button>
            <transition
              name="custom-classes-transition"
              enter-active-class="animated tada"
              leave-active-class="animated bounceOutRight"
            >
              <p v-if="show">hello</p>
            </transition>
          </div>

        ▪ Модель

          new Vue({
            el: '#example-3',
            data: {
              show: true
            }
          })

  • CSS transition: пример

    ▪ Шаблон

      <div id="example-1">
        <button @click="show = !show">
          Переключить рендеринг
        </button>
        <transition name="slide-fade">
          <p v-if="show">hello</p>
        </transition>
      </div>    

    ▪ Модель

      new Vue({
        el: '#example-1',
        data: {
          show: true
        }
      })

    ▪ Стили

      // Анимации появления и исчезновения могут иметь
      // различные продолжительности и динамику.      
      .slide-fade-enter-active {
        transition: all .3s ease;
      }
      .slide-fade-leave-active {
        transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
      }
      .slide-fade-enter, .slide-fade-leave-to

  • CSS animation: пример

    ▪ Шаблон

      <div id="example-2">
        <button @click="show = !show">Переключить отображение</button>
        <transition name="bounce">
          <p v-if="show">Посмотри на меня!</p>
        </transition>
      </div>

    ▪ Модель

      new Vue({
        el: '#example-2',
        data: {
          show: true
        }
      })

    ▪ Стили

      .bounce-enter-active {
        animation: bounce-in .5s;
      }
      .bounce-leave-active {
        animation: bounce-in .5s reverse;
      }
      @keyframes bounce-in {
        0% {
          transform: scale(0);
        }
        50% {
          transform: scale(1.5);
        }
        100% {
          transform: scale(1);
        }
      }

  • Совместное использование transiton и animation
    - Vue надо знать, когда переход/анимация завершается.
    - Для этого ему надо назначить обработчики событий.
    - Либо на событие transitionend, либо на animationend.
    - При использовании перехода ИЛИ анимации, Vue сам определяет.
    - Но при одновременном использовании обоих, м.б. затруднения.
    - Например:

      На одном и том же элементе реализуется CSS-анимация
      инструментами Vue, а также CSS-transition при hover.

      В этом случае, нужно явно в атрибует type псевдоэлемента
      transition указать Vue, за чем он должен следить,
      анимацией или переходом:

        <transition type="animation"></transition>
        <transition type="transition"></transition>

  • Настройка длительности transition: опция duration
    - По умолчанию, Vue автоматич.определяет завершение перехода.
    - Он отслеживает события transitionend / animationend на корневом элементе.
    - Но, если надо, можно и явно указать продолжительность перехода в мс.
    - Для эого используется опция duration компонента <transition>:

        <transition :duration="1000">...</transition>

    - Можно также указывать отдельные значения длительности
      начала и окончания перехода:

        <transition :duration="{ enter: 500, leave: 800 }">...</transition>

  • JS-хуки переходов

    ▪ JS-хуки можно применять на псевдоэлементе transition
      - Например:

        <transition v-on:before-enter="beforeEnter"></transition>

    ▪ Список JS-хуков переходов

      ▪ before-enter      | v-on:before-enter     ="beforeEnter"
      ▪ enter             | v-on:enter            ="enter"
      ▪ after-enter       | v-on:after-enter      ="afterEnter"
      ▪ enter-cancelled   | v-on:enter-cancelled  ="enterCancelled"
      ▪ before-leave      | v-on:before-leave     ="beforeLeave"
      ▪ leave             | v-on:on:leave         ="leave"
      ▪ after-leave       | v-on:after-leave      ="afterLeave"
      ▪ leave-cancelled   | v-on:leave-cancelled  ="leaveCancelled"

    ▪ Схема использования JS-хуков переходов

      ▪ Шаблон

        <transition
          v-on:before-enter="beforeEnter"
          v-on:enter="enter"
          v-on:after-enter="afterEnter"
          v-on:enter-cancelled="enterCancelled"
          v-on:before-leave="beforeLeave"
          v-on:leave="leave"
          v-on:after-leave="afterLeave"
          v-on:leave-cancelled="leaveCancelled"
        >
          <!-- ... -->
        </transition>      

      ▪ Модель

        // ...
        methods: {
          // --------
          // ПОЯВЛЕНИЕ
          // --------
          beforeEnter: function (el) {
            // ...
          },
          // коллбэк done не обязательно использовать если
          // анимация или переход также определены в CSS
          enter: function (el, done) {
            // ...
            done()
          },
          afterEnter: function (el) {
            // ...
          },
          enterCancelled: function (el) {
            // ...
          },
          // --------
          // ИСЧЕЗНОВЕНИЕ
          // --------
          beforeLeave: function (el) {
            // ...
          },
          // коллбэк done не обязательно использовать если
          // анимация или переход также определены в CSS
          leave: function (el, done) {
            // ...
            done()
          },
          afterLeave: function (el) {
            // ...
          },
          // leaveCancelled доступна только для v-show
          leaveCancelled: function (el) {
            // ...
          }
        }

    ▪ Для JS-переходов ВСЕГДА используй коллбэки done в хуках enter / leave
      - Если переход основан только на JS.
      - Обязательно вызывай коллбэки done в в хуках enter / leave.
      - Иначе, переход будет мнгновенно завершаться (не сработает).

    ▪ Для JS-переходов указывай: v-bind:css="false"
      - Чтобы дать понять Vue, что это чисто JS-ONLY переход.
      - Это сэкономит ресурсы, т.к. Vue не будет пытаться 
        понять, css ли это переход, или js.
      - Кроме того, это убережёт нас от случайного взаимовлияния 
        CSS-правил и JS-перехода.

    ▪ Пример использования JS-хуков перехода с Velocity.js

      ▪ Шаблон

        <!--
        Velocity работает примерно так же, как и jQuery.animate
        и весьма удобен для создания JavaScript-анимаций
        -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
        <div id="example-4">
          <button @click="show = !show">
            Переключить
          </button>
          <transition
            v-on:before-enter="beforeEnter"
            v-on:enter="enter"
            v-on:leave="leave"
            v-bind:css="false"
          >
            <p v-if="show">
              Демо
            </p>
          </transition>
        </div>      

      ▪ Модель

        new Vue({
          el: '#example-4',
          data: {
            show: false
          },
          methods: {
            beforeEnter: function (el) {
              el.style.opacity = 0
            },
            enter: function (el, done) {
              Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })
              Velocity(el, { fontSize: '1em' }, { complete: done })
            },
            leave: function (el, done) {
              Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })
              Velocity(el, { rotateZ: '100deg' }, { loop: 2 })
              Velocity(el, {
                rotateZ: '45deg',
                translateY: '30px',
                translateX: '30px',
                opacity: 0
              }, { complete: done })
            }
          }
        })      

> Переходы при первичном рендеринге

  • По умолчанию, на старте анимация не срабатывает
    - Сабж.

  • Атрибут appear для transition запустит appear-анимацию на старте
    - Иногда требуется, чтобы анимация в начале сработала.
    - Этого можно добиться, применив атрибут appear на эл-те transition:

      <transition appear>
        <!-- ... -->
      </transition>

  • Кастомные CSS-классы для appear-анимации с помощью атрибутов
    
    ▪ Пример кастомных CSS-стилей для appear-анимации
      - По умолчани для appear-анимации будут применяться
        те же стили, что для enter-анимации.
      - Но если надо, чтобы appear-стили отличались:

        <transition
          appear
          appear-class="custom-appear-class"
          appear-to-class="custom-appear-to-class" (>= 2.1.8 only)
          appear-active-class="custom-appear-active-class"
        >
          <!-- ... -->
        </transition>      

    ▪ appear-class
      <transition appear-class="custom-appear-class"></transition> 

    ▪ appear-to-class
      <transition appear-to-class="custom-appear-to-class"></transition> 

    ▪ appear-active-class
      <transition appear-active-class="custom-appear-active-class"></transition> 

  • Кастомные JS-хуки для appear-анимации

    ▪ Пример кастомных JS-хуков для appear-анимации
      - По умолчани для appear-анимации будут применяться
        те же хуки, что для enter-анимации.
      - Но если надо, чтобы appear-хуки отличались: 

        <transition
          appear
          v-on:before-appear="customBeforeAppearHook"
          v-on:appear="customAppearHook"
          v-on:after-appear="customAfterAppearHook"
          v-on:appear-cancelled="customAppearCancelledHook"
        >
          <!-- ... -->
        </transition>

    ▪ before-appear
      <transition v-on:before-appear="customBeforeAppearHook"></transition> 

    ▪ appear
      <transition v-on:appear="customAppearHook"></transition> 

    ▪ after-appear
      <transition v-on:after-appear="customAfterAppearHook"></transition> 

    ▪ appear-cancelled
      <transition v-on:appear-cancelled="customAppearCancelledHook"></transition> 

> Переходы между DOM-элементами

  • Переход между DOM-эл-ми с разными тегами с помощью v-if / v-else
    - Допустим, между списком и сообщением, что список пуст.
    - Пример:

        <transition>
          <table v-if="items.length > 0">
            <!-- ... -->
          </table>
          <p v-else>Sorry, no items found.</p>
        </transition>    

  • Переход между DOM-эл-ми с одинаковым тегами

    ▪ Нужно использовать атрибут key
      - Это актуально при переходе между DOM-эл-ми с одинаковыми тегами.
      - Нужно дать понять Vue, что это разные элементы.
      
        ▪ Для этого использовать атрибуты key.
        ▪ Значения для key д.б. уникальны в пределах тега transition.
      
      - Иначе, компилятор Vue лишь поменяет контент эл-в (экономя ресурсы).
      - Вообще, даже если нет необходимость, признано хорошей практикой
        использовать key внутри transition для одинаковых DOM-элементов.

    ▪ Техника перехода с помощью v-if / v-else
      - Допустим, есть 2 button внутри transition.
      - Назначаем им атрибут key с уникальнымм внутри transition значениями.
      - В зависимости от значения isEditing будет показан тот или иной эл-т:

          <transition>
            <button v-if="isEditing" key="save">
              Save
            </button>
            <button v-else key="edit">
              Edit
            </button>
          </transition>

    ▪ [Продвинутая] Техника перехода с помощью key
      - При изменении docState button будет заменяться целиком.
      - Это, в т.ч., вызовет соотв.анимации, и хуки.
      - При изменении docState будет меняться и надпись на кнопке.
      - Код:

        ▪ Шаблон

          <transition>
            <button v-bind:key="docState">
              {{ buttonMessage }}
            </button>
          </transition>

        ▪ Часть модели

          computed: {
            buttonMessage: function () {
              switch (docState) {
                case 'saved': return 'Edit'
                case 'edited': return 'Save'
                case 'editing': return 'Cancel'
              }
            }
          }

  • Режимы работы transition: атрибут mode

    ▪ sync
      - Является режимом по умолчанию работы transition.
      - Новый входит, старый выходит, одновременно.
      - В некоторых случаях этот режим норм, в некоторых не норм.      
      - Чтобы его включить, надо просто не испольозвать атрибут mode.
      - Писать mode="sync" не надо, не сработает.

    ▪ in-out
      - Сначала входит новый, потом выходит старый.
      - Пример:

          <transition name="fade" mode="in-out">
            <!-- ... the buttons ... -->
          </transition>      

    ▪ out-in
      - Сначала выходит старый, потом входит новый.
      - Пример:

          <transition name="fade" mode="out-in">
            <!-- ... the buttons ... -->
          </transition>  


> Переходы между компонентами

  • Атрибут key не нужен, используем component - динамиеский компонент    

    ▪ Шаблон

      <transition name="component-fade" mode="out-in">
        <component v-bind:is="view"></component>
      </transition>

    ▪ Модель

      new Vue({
        el: '#transition-components-demo',
        data: {
          view: 'v-a'
        },
        components: {
          'v-a': {
            template: '<div>Component A</div>'
          },
          'v-b': {
            template: '<div>Component B</div>'
          }
        }
      })    

    ▪ Стили

      .component-fade-enter-active, .component-fade-leave-active {
        transition: opacity .3s ease;
      }
      .component-fade-enter, .component-fade-leave-to
      /* .component-fade-leave-active for <2.1.8 */ {
        opacity: 0;
      }    

> Переходы в списках

  • Компонент <transition-group> для анимации списков

    ▪ Используется для sync-анимации в v-for списках
      - Что, если мы хотим синхронную анимацию эл-в в списках?
      - А эти списки отрисовываются с опмощью директивы v-for?
      - В таком случае, надо использовать компонент <transition-group>.

    ▪ <transition-group> рендерится в реальный DOM-элемент

      ▪ По умолчанию <transition-group> рендерится в <span>
        - Компонент <transition> не рендерится в реальный DOM-элемент.
        - А компонент <transition-group> рендерится, по умолчанию, в span.

      ▪ Атрибут tag: указать, в какой тег среднерится <transition-group>
        - Чтобы изменить тэг DOM-элемента по умолчанию, используй атрибут tag.
        - Например:

          <transition-group name="list" tag="p">
            ...
          </transition-group> 

    ▪ Элементы списка внутри <transition-group> ВСЕГДА ДОЛЖНЫ иметь уникальный key
      - Сабж.

  • Анимация добавления/удаления из списка

    ▪ Шаблон

      <div id="list-demo">
        <button v-on:click="add">Add</button>
        <button v-on:click="remove">Remove</button>
        <transition-group name="list" tag="p">
          <span v-for="item in items" v-bind:key="item" class="list-item">
            {{ item }}
          </span>
        </transition-group>
      </div>

    ▪ Модель

      new Vue({
        el: '#list-demo',
        data: {
          items: [1,2,3,4,5,6,7,8,9],
          nextNum: 10
        },
        methods: {
          randomIndex: function () {
            return Math.floor(Math.random() * this.items.length)
          },
          add: function () {
            this.items.splice(this.randomIndex(), 0, this.nextNum++)
          },
          remove: function () {
            this.items.splice(this.randomIndex(), 1)
          },
        }
      })

    ▪ Стили

      .list-item {
        display: inline-block;
        margin-right: 10px;
      }
      .list-enter-active, .list-leave-active {
        transition: all 1s;
      }
      .list-enter, .list-leave-to /* .list-leave-active for <2.1.8 */ {
        opacity: 0;
        transform: translateY(30px);
      }    

  • Анимация изменения позиции в списке

    ▪ Класс v-move на время анимации
      - Vue добавляет класс v-move элементам списка
        на время анимации изменения позиции в списке.
      - Он работает по аналогии с другими анимационными классами.
      - Префикс по умолчанию "v-", кастомизируется с помощью атрибута name.
      - Чаще всего v-move используют для кастомизации
        transition timing и easing curve.

    ▪ Атрибут move-class для назначения кастомного имени для v-move
      - Имя может быть вручную изменено атрибутом move-class.
      - Например:

        <transition-group name="flip-list" tag="ul">
          ...
        </transition-group>

    ▪ Не работает с элементами с display: inline
      - Для анимации позиции Vue использует технику FLIP.
      - Подробнее о FLIP: https://aerotwist.com/blog/flip-your-animations/
      - А FLIP не работает с эл-ми с display: inline.

    ▪ Простой пример анимации изменения позиции в списке
    
      ▪ Шаблон

        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
        <div id="flip-list-demo" class="demo">
          <button v-on:click="shuffle">Shuffle</button>
          <transition-group name="flip-list" tag="ul">
            <li v-for="item in items" v-bind:key="item">
              {{ item }}
            </li>
          </transition-group>
        </div>

      ▪ Модель

        new Vue({
          el: '#flip-list-demo',
          data: {
            items: [1,2,3,4,5,6,7,8,9]
          },
          methods: {
            shuffle: function () {
              this.items = _.shuffle(this.items)
            }
          }
        })

      ▪ Стили

        .flip-list-move {
          transition: transform 1s;
        }

    ▪ Пример с анимацей всего: добавления/удаления/изменения позиции

      ▪ Шаблон

          <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
          <div id="list-complete-demo" class="demo">
            <button v-on:click="shuffle">Shuffle</button>
            <button v-on:click="add">Add</button>
            <button v-on:click="remove">Remove</button>
            <transition-group name="list-complete" tag="p">
              <span
                v-for="item in items"
                v-bind:key="item"
                class="list-complete-item"
              >
                {{ item }}
              </span>
            </transition-group>
          </div>

      ▪ Модель
  
          new Vue({
            el: '#list-complete-demo',
            data: {
              items: [1,2,3,4,5,6,7,8,9],
              nextNum: 10
            },
            methods: {
              randomIndex: function () {
                return Math.floor(Math.random() * this.items.length)
              },
              add: function () {
                this.items.splice(this.randomIndex(), 0, this.nextNum++)
              },
              remove: function () {
                this.items.splice(this.randomIndex(), 1)
              },
              shuffle: function () {
                this.items = _.shuffle(this.items)
              }
            }
          })

      ▪ Стили

          .list-complete-item {
            transition: all 1s;
            display: inline-block;
            margin-right: 10px;
          }
          .list-complete-enter, .list-complete-leave-to
          /* .list-complete-leave-active for <2.1.8 */ {
            opacity: 0;
            transform: translateY(30px);
          }
          .list-complete-leave-active {
            position: absolute;
          }

  • Анимация фильтрации списка

    ▪ Что имеется в виду под анимацией фильтрации
      - Например, есть у нас список строк.
      - Он формируется динамически через computed.
      - При формировании он фильтруется по значению св-ва.
      - Вводишь букву, и все не подходящие эл-ты отфильтровываются.
      - Вот эта техника позволяет анимировать всё это дело.

    ▪ Пример анимации фильтрации списка

      ▪ Шаблон

        <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
        <div id="staggered-list-demo">
          <input v-model="query">
          <transition-group
            name="staggered-fade"
            tag="ul"
            v-bind:css="false"
            v-on:before-enter="beforeEnter"
            v-on:enter="enter"
            v-on:leave="leave"
          >
            <li
              v-for="(item, index) in computedList"
              v-bind:key="item.msg"
              v-bind:data-index="index"
            >{{ item.msg }}</li>
          </transition-group>
        </div>

      ▪ Модель

        new Vue({
          el: '#staggered-list-demo',
          data: {
            query: '',
            list: [
              { msg: 'Bruce Lee' },
              { msg: 'Jackie Chan' },
              { msg: 'Chuck Norris' },
              { msg: 'Jet Li' },
              { msg: 'Kung Fury' }
            ]
          },
          computed: {
            computedList: function () {
              var vm = this
              return this.list.filter(function (item) {
                return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1
              })
            }
          },
          methods: {
            beforeEnter: function (el) {
              el.style.opacity = 0
              el.style.height = 0
            },
            enter: function (el, done) {
              var delay = el.dataset.index * 150
              setTimeout(function () {
                Velocity(
                  el,
                  { opacity: 1, height: '1.6em' },
                  { complete: done }
                )
              }, delay)
            },
            leave: function (el, done) {
              var delay = el.dataset.index * 150
              setTimeout(function () {
                Velocity(
                  el,
                  { opacity: 0, height: 0 },
                  { complete: done }
                )
              }, delay)
            }
          }
        })

> Повторно используемые переходы

  • Пример компонента, реализующего повторно используемый переход
  
      Vue.component('my-special-transition', {
        template: '\
          <transition\
            name="very-special-transition"\
            mode="out-in"\
            v-on:before-enter="beforeEnter"\
            v-on:after-enter="afterEnter"\
          >\
            <slot></slot>\
          </transition>\
        ',
        methods: {
          beforeEnter: function (el) {
            // ...
          },
          afterEnter: function (el) {
            // ...
          }
        }
      })

  • Используй функциональные компоненты для повторных переходов (пример)
    - Подробнее функц-ые компоненты описаны в главе про render-функцию.
    - Кратко, это компоненты без состояния, т.е. без опции data.
    - Они хорошо подходят для реализации повторных переходов.
    - Пример:

        Vue.component('my-special-transition', {
          functional: true,
          render: function (createElement, context) {
            var data = {
              props: {
                name: 'very-special-transition',
                mode: 'out-in'
              },
              on: {
                beforeEnter: function (el) {
                  // ...
                },
                afterEnter: function (el) {
                  // ...
                }
              }
            }
            return createElement('transition', data, context.children)
          }
        })    

> Динамические переходы: меняем св-ва анимации на основе data

  • Что имеется в виду под динамическими переходами?
    - Можно менять св-ва анимации динамически.
    - Например, в зависимости от каких-то св-в в модели.
    - Для этого прямо на transition можно использовать,
      например, v-bind.

  • Меняем css-классы анимаций в зависимости от св-ва модели

    <transition v-bind:name="transitionName">
      <!-- ... -->
    </transition>

  • Меняем js-хуки velocity-анимаций в зависимости от св-ва модели

    ▪ Шаблон

      <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
      <div id="dynamic-fade-demo">
        Fade In: <input type="range" v-model="fadeInDuration" min="0" v-bind:max="maxFadeDuration">
        Fade Out: <input type="range" v-model="fadeOutDuration" min="0" v-bind:max="maxFadeDuration">
        <transition
          v-bind:css="false"
          v-on:before-enter="beforeEnter"
          v-on:enter="enter"
          v-on:leave="leave"
        >
          <p v-if="show">hello</p>
        </transition>
        <button v-on:click="stop = true">Stop it!</button>
      </div>

    ▪ Модель

      new Vue({
        el: '#dynamic-fade-demo',
        data: {
          show: true,
          fadeInDuration: 1000,
          fadeOutDuration: 1000,
          maxFadeDuration: 1500,
          stop: false
        },
        mounted: function () {
          this.show = false
        },
        methods: {
          beforeEnter: function (el) {
            el.style.opacity = 0
          },
          enter: function (el, done) {
            var vm = this
            Velocity(el,
              { opacity: 1 },
              {
                duration: this.fadeInDuration,
                complete: function () {
                  done()
                  if (!vm.stop) vm.show = false
                }
              }
            )
          },
          leave: function (el, done) {
            var vm = this
            Velocity(el,
              { opacity: 0 },
              {
                duration: this.fadeOutDuration,
                complete: function () {
                  done()
                  vm.show = true
                }
              }
            )
          }
        }
      })


Б3. Анимирование данных

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение  

    ▪ Анимация данных

  # Анимация св-в модели через watch

    ▪ Анимация чисел через watch
    ▪ Анимация не числа через watch и computed (на примере цвета)

  # Анимация данных, выделенная в компонент

    ▪ Избежать переусложнения компонента/экземпляра
    ▪ Выделение анимации числа из примера выше в компонент

--------------------------------------

> Ссылки

  # [Официальное руководство] Анимирование переходов между состояниями
      https://ru.vuejs.org/v2/guide/transitioning-state.html

  # Пример анимации "бешеный полигон"
      https://jsfiddle.net/chrisvfritz/65gLu2b6/

> Введение

  • Анимация данных
    - Инструменты Vue также облегчают анимацию данных.
    - Например:

      ▪ Чисел и арифметических выражений.
      ▪ Отображаемых цветов.
      ▪ Позиции SVG-элементов.
      ▪ Размеров и прочих свойств элементов.

    - Все эти параметры являются числами по сути.
    - Значит, можно использовать сторонние библиотеки для анимации,
      в сочетании с компонентными и реактивными системами Vue.

> Анимация св-в модели через watch

  • Анимация чисел через watch

    ▪ Шаблон

      <script src="https://unpkg.com/tween.js@16.3.4"></script>
      <div id="animated-number-demo">
        <input v-model.number="number" type="number" step="20">
        <p>{{ animatedNumber }}</p>
      </div>

    ▪ Модель

      new Vue({
        el: '#animated-number-demo',
        data: {
          number: 0,
          animatedNumber: 0
        },
        watch: {
          number: function(newValue, oldValue) {
            var vm = this
            var animationFrame
            function animate (time) {
              TWEEN.update(time)
              animationFrame = requestAnimationFrame(animate)
            }
            new TWEEN.Tween({ tweeningNumber: oldValue })
              .easing(TWEEN.Easing.Quadratic.Out)
              .to({ tweeningNumber: newValue }, 500)
              .onUpdate(function () {
                vm.animatedNumber = this.tweeningNumber.toFixed(0)
              })
              .onComplete(function () {
                cancelAnimationFrame(animationFrame)
              })
              .start()
            animationFrame = requestAnimationFrame(animate)
          }
        }
      })

  • Анимация не числа через watch и computed (на примере цвета)

    ▪ Шаблон

      <script src="https://unpkg.com/tween.js@16.3.4"></script>
      <script src="https://unpkg.com/color-js@1.0.3/color.js"></script>
      <div id="example-7">
        <input
          v-model="colorQuery"
          v-on:keyup.enter="updateColor"
          placeholder="Enter a color"
        >
        <button v-on:click="updateColor">Обновить</button>
        <p>Предпросмотр:</p>
        <span
          v-bind:style="{ backgroundColor: tweenedCSSColor }"
          class="example-7-color-preview"
        ></span>
        <p>{{ tweenedCSSColor }}</p>
      </div>

    ▪ Модель

      var Color = net.brehaut.Color
      new Vue({
        el: '#example-7',
        data: {
          colorQuery: '',
          color: {
            red: 0,
            green: 0,
            blue: 0,
            alpha: 1
          },
          tweenedColor: {}
        },
        created: function () {
          this.tweenedColor = Object.assign({}, this.color)
        },
        watch: {
          color: function () {
            var animationFrame
            function animate (time) {
              TWEEN.update(time)
              animationFrame = requestAnimationFrame(animate)
            }
            new TWEEN.Tween(this.tweenedColor)
              .to(this.color, 750)
              .onComplete(function () {
                cancelAnimationFrame(animationFrame)
              })
              .start()
            animationFrame = requestAnimationFrame(animate)
          }
        },
        computed: {
          tweenedCSSColor: function () {
            return new Color({
              red: this.tweenedColor.red,
              green: this.tweenedColor.green,
              blue: this.tweenedColor.blue,
              alpha: this.tweenedColor.alpha
            }).toCSS()
          }
        },
        methods: {
          updateColor: function () {
            this.color = new Color(this.colorQuery).toRGB()
            this.colorQuery = ''
          }
        }
      })

    ▪ Стили

      .example-7-color-preview {
        display: inline-block;
        width: 50px;
        height: 50px;
      }    

> Анимация данных, выделенная в компонент

  • Избежать переусложнения компонента/экземпляра
    - В к./э. может быть очень много всяких анимаций.
    - В результате "за деревьями леса не видно".
    - Чтобы не грузить ими компонент, можно их выделять
      в отдельные компоненты.

  • Выделение анимации числа из примера выше в компонент

    ▪ Шаблон

      <script src="https://unpkg.com/tween.js@16.3.4"></script>
      <div id="example-8">
        <input v-model.number="firstNumber" type="number" step="20"> +
        <input v-model.number="secondNumber" type="number" step="20"> =
        {{ result }}
        <p>
          <animated-integer v-bind:value="firstNumber"></animated-integer> +
          <animated-integer v-bind:value="secondNumber"></animated-integer> =
          <animated-integer v-bind:value="result"></animated-integer>
        </p>
      </div>    

    ▪ Компонент и экземпляр

      // Эта логика перехода может быть отныне повторно использована
      // с любыми целыми числами, которые мы бы хотели анимировать в приложении.
      // Кроме того, компоненты предоставляют удобный интерфейс для конфигурирования
      // более сложных и динамичных переходов.
      Vue.component('animated-integer', {
        template: '<span>{{ tweeningValue }}</span>',
        props: {
          value: {
            type: Number,
            required: true
          }
        },
        data: function () {
          return {
            tweeningValue: 0
          }
        },
        watch: {
          value: function (newValue, oldValue) {
            this.tween(oldValue, newValue)
          }
        },
        mounted: function () {
          this.tween(0, this.value)
        },
        methods: {
          tween: function (startValue, endValue) {
            var vm = this
            var animationFrame
            function animate (time) {
              TWEEN.update(time)
              animationFrame = requestAnimationFrame(animate)
            }
            new TWEEN.Tween({ tweeningValue: startValue })
              .to({ tweeningValue: endValue }, 500)
              .onUpdate(function () {
                vm.tweeningValue = this.tweeningValue.toFixed(0)
              })
              .onComplete(function () {
                cancelAnimationFrame(animationFrame)
              })
              .start()
            animationFrame = requestAnimationFrame(animate)
          }
        }
      })
      // В самом экземпляре Vue больше не осталось никакой логики анимаций
      new Vue({
        el: '#example-8',
        data: {
          firstNumber: 20,
          secondNumber: 40
        },
        computed: {
          result: function () {
            return this.firstNumber + this.secondNumber
          }
        }
      })    


Б4. Render-функции

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение  

    ▪ Render-функции - низкоуровневая альтернатива шаблонам
    ▪ За сценой Vue компилирует шаблон в render-функцию
    ▪ В render-функции можно использовать JSX
      ▪ Описание проблемы
      ▪ Плагин Babel
      ▪ Внимание! Используй алиас h для createElement, это обязательно

  # Простой пример, где использование render-функции целесообразно

    ▪ Условия задачи
    ▪ Решение задачи через шаблон
    ▪ Решение задачи через render-функцию
    ▪ Сравнение двух решений
 
  # Функция createElement

    ▪ Синтаксис createElement
    ▪ Подробнее об объекте данных (2-й аргумент в createElement)
    ▪ Внимание! Все VNode'ы должны быть уникальными!
      ▪ Пример не валидной рендер-фукнции
      ▪ Используйте функцию-фабрику, чтобы избежать дублей
        
  # Реализация возможностей шаблона с помощью JS        
        
    ▪ v-if / v-for
    ▪ v-model
    ▪ События и модификаторы клавиш
    ▪ Слоты
        
  # Функциональные компоненты

    ▪ Без состояния (data) и экземпляра (this)
    ▪ Аргумент context функции render
    ▪ Функциональные компоненты легче рендерить
    ▪ Функциональных компонентов нет в VueJS Chrome dev tools
    ▪ Функциональный компонент, как обёртка
    ▪ slots() vs children        
        
--------------------------------------

> Ссылки

  # [Официальное руководство] Render-функции
      https://ru.vuejs.org/v2/guide/render-function.html

> Введение

  • Render-функции - низкоуровневая альтернатива шаблонам
    - Обычно в Vue для отрисовки HTML используют шаблон.
    - Но если надо больше гибкости, тогда render-функцию.

  • За сценой Vue компилирует шаблон в render-функцию

    ▪ Пример шаблона

        <div>
          <header>
            <h1>I'm a template!</h1>
          </header>
          <p v-if="message">
            {{ message }}
          </p>
          <p v-else>
            No message.
          </p>
        </div>

    ▪ render

        function anonymous() {
          with(this){return _c('div',[_m(0),(message)?_c('p',[_v(_s(message))]):_c('p',[_v("No message.")])])}
        }

    ▪ staticRenderFns

        _m(0): function anonymous() {
          with(this){return _c('header',[_c('h1',[_v("I'm a template!")])])}
        }    

  • В render-функции можно использовать JSX

    ▪ Описание проблемы
      - Не красиво и нудно писать рендер-функции без JSX.
      - Например:

          createElement(
            'anchored-heading', {
              props: {
                level: 1
              }
            }, [
              createElement('span', 'Hello'),
              ' world!'
            ]
          )      

      - Всё это лишь для того, чтобы заменить простой шаблон:

          <anchored-heading :level="1">
            <span>Hello</span> world!
          </anchored-heading>      

    ▪ Плагин Babel
      - Чтобы использовать JSX, надо установить плагин Babel.
      - Тогда примеры выше можно будет писать так:

          import AnchoredHeading from './AnchoredHeading.vue'
          new Vue({
            el: '#demo',
            render (h) {
              return (
                <AnchoredHeading level={1}>
                  <span>Hello</span> world!
                </AnchoredHeading>
              )
            }
          })

    ▪ Внимание! Используй алиас h для createElement, это обязательно
      - Просто так принято в экосистеме Vue.
      - Иначе всё просто сломается.
      - См.пример выше. 

> Простой пример, где использование render-функции целесообразно

  • Условия задачи
    - Требуется генерировать заголовки с якорями, например:

        <h1>
          <a name="hello-world" href="#hello-world">
            Hello world!
          </a>
        </h1>

    - Для этого требуется написать компонент.
    - Пример интерфейса компонента:

        <anchored-heading :level="1">Hello world!</anchored-heading>

  • Решение задачи через шаблон

    ▪ Шаблон

      <script type="text/x-template" id="anchored-heading-template">
        <div>
          <h1 v-if="level === 1">
            <slot></slot>
          </h1>
          <h2 v-if="level === 2">
            <slot></slot>
          </h2>
          <h3 v-if="level === 3">
            <slot></slot>
          </h3>
          <h4 v-if="level === 4">
            <slot></slot>
          </h4>
          <h5 v-if="level === 5">
            <slot></slot>
          </h5>
          <h6 v-if="level === 6">
            <slot></slot>
          </h6>
        </div>
      </script>

    ▪ Модель

      Vue.component('anchored-heading', {
        template: '#anchored-heading-template',
        props: {
          level: {
            type: Number,
            required: true
          }
        }
      })

  • Решение задачи через render-функцию

      var getChildrenTextContent = function (children) {
        return children.map(function (node) {
          return node.children
            ? getChildrenTextContent(node.children)
            : node.text
        }).join('')
      }
      Vue.component('anchored-heading', {
        render: function (createElement) {
          // создать id в kebabCase
          var headingId = getChildrenTextContent(this.$slots.default)
            .toLowerCase()
            .replace(/\W+/g, '-')
            .replace(/(^\-|\-$)/g, '')
          return createElement(
            'h' + this.level,
            [
              createElement('a', {
                attrs: {
                  name: headingId,
                  href: '#' + headingId
                }
              }, this.$slots.default)
            ]
          )
        },
        props: {
          level: {
            type: Number,
            required: true
          }
        }
      })  

  • Сравнение двух решений
    - Код решения с render-функцией длиннее и запутаннее.
    - Но могут быть случае, когда он будет короче =)
    - В любом случае, он даёт больше гибкости, и 
      в каких-то случаях позволяет разрулить ситуацию.

# Функция createElement

  • Синтаксис createElement
    
    ▪ Возвращает VNode
      - Виртуальный узел.

    ▪ Синтаксис createElement

      createElement(el, [data], [children])

    ▪ Параметр el
      - {String | Object | Function}
      - Обязательный параметр.
      - Название тега HTML, опции компонента, или функция, их возвращающая.

    ▪ Объект данных data
      - {Object}
      - Не обязательный параметр.
      - Объект данных, содержащий атрибуты, который вы бы указали в шаблоне.

    ▪ Дочерние VNode'ы
      - {String | Array}
      - Опциональный параметр.

    ▪ Пример

        createElement(
          'div', {}, [
            createElement('h1', 'hello world'),
            createElement(MyComponent, {
              props: {
                someProp: 'foo'
              }
            }),
            'bar'
          ]
        )  

  • Подробнее об объекте данных (2-й аргумент в createElement)

      {
        // То же API что и у `v-bind:class`
        'class': {
          foo: true,
          bar: false
        },
        // То же API что и у `v-bind:style`
        style: {
          color: 'red',
          fontSize: '14px'
        },
        // Обычные атрибуты HTML
        attrs: {
          id: 'foo'
        },
        // Входные параметры компонентов
        props: {
          myProp: 'bar'
        },
        // Свойства DOM
        domProps: {
          innerHTML: 'baz'
        },
        // Обработчики событий располагаются под ключом "on",
        // однако модификаторы вроде как v-on:keyup.enter не
        // поддерживаются. Проверять keyCode придётся вручную.
        on: {
          click: this.clickHandler
        },
        // Только для компонентов. Позволяет слушать нативные события,
        // а не генерируемые в компоненте через vm.$emit.
        nativeOn: {
          click: this.nativeClickHandler
        },
        // Пользовательские директивы. Обратите внимание, что oldValue
        // не может быть указано, так как Vue сам его отслеживает
        directives: [
          {
            name: 'my-custom-directive',
            value: '2'
            expression: '1 + 1',
            arg: 'foo',
            modifiers: {
              bar: true
            }
          }
        ],
        // Слоты с ограниченной областью видимостью в формате
        // { name: props => VNode | Array<VNode> }
        scopedSlots: {
          default: props => createElement('span', props.text)
        },
        // Имя слота, если этот компонент
        // является потомком другого компонента
        slot: 'name-of-slot'
        // Прочие специальные свойства верхнего уровня
        key: 'myKey',
        ref: 'myRef'
      }

  • Внимание! Все VNode'ы должны быть уникальными!
    
    ▪ Пример не валидной рендер-фукнции
      - Все VNode'ы в компоненте д.б. уникальными.
      - Например, рендер-функция ниже не валидна:

          render: function (createElement) {
            var myParagraphVNode = createElement('p', 'hi')
            return createElement('div', [

              // Упс — дублирующиеся VNode'ы!
              myParagraphVNode, 
              myParagraphVNode

            ])
          }

    ▪ Используйте функцию-фабрику, чтобы избежать дублей
      - Например, надо отобразить 20 элементов p
      - Сделаем это с помощью функции-фабрики:

          render: function (createElement) {
            return createElement('div',
              Array.apply(null, { length: 20 }).map(function () {
                return createElement('p', 'hi')
              })
            )
          }      

> Реализация возможностей шаблона с помощью JS        
      
  • v-if / v-for

    ▪ Шаблон

        <ul v-if="items.length">
          <li v-for="item in items">{{ item.name }}</li>
        </ul>
        <p v-else>Ничего не найдено.</p>

    ▪ Реализующая шаблон render-функция

        render: function (createElement) {
          if (this.items.length) {
            return createElement('ul', this.items.map(function (item) {
              return createElement('li', item.name)
            }))
          } else {
            return createElement('p', 'Ничего не найдено.')
          }
        }

  • v-model

      render: function (createElement) {
        var self = this
        return createElement('input', {
          domProps: {
            value: self.value
          },
          on: {
            input: function (event) {
              self.value = event.target.value
              self.$emit('input', event.target.value)
            }
          }
        })
      }

  • События и модификаторы клавиш

    ▪ Префиксы для модификаторов событий .capture и .once
      
      ▪ Модификаторы:

        !     | .capture
        ~     | .once
        ~!    | .capture.once

      ▪ Например

        on: {
          '!click': this.doThisInCapturingMode,
          '~keyup': this.doThisOnce,
          `~!mouseover`: this.doThisOnceInCapturingMode
        }      

    ▪ Остальные модификаторы реализуй сам в обработчике
      - В шаблонах реализованы многие модификаторы событий.
      - Их список можно посмотреть в главе про события.
      - Но если решил использовать render-функцию, то
        тебе доступны только .capture и .once через префиксы.
      - Остальные модификаторы реализуй сам в обработчике:

        ▪ .stop

            event.stopPropagation()

        ▪ .prevent

            event.preventDefault()

        ▪ .self

            if (event.target !== event.currentTarget) return

        ▪ Клавиши .enter, .13

            if (event.keyCode !== 13) return (измените 13 на любой другой код клавиши для модификаторов других клавиш)

        ▪ Модификаторы .ctrl, .alt, .shift, .meta  

            if (!event.ctrlKey) return (измените ctrlKey на altKey, shiftKey, или metaKey, соответственно)

      - Шаблон их использования всех вместе:

          on: {
            keyup: function (event) {
              // Ничего не делаем, если элемент на котором произошло
              // событие не является элементом который мы отслеживаем
              if (event.target !== event.currentTarget) return
              
              // Ничего не делаем, если клавиша не Enter (13)
              // и клавиша SHIFT не была нажата в тоже время
              if (!event.shiftKey || event.keyCode !== 13) return
              
              // Останавливаем всплытие события
              event.stopPropagation()
              
              // Останавливаем стандартный обработчик keyup для этого элемента
              event.preventDefault()
              
              // ...
            }
          }      

  • Слоты

    ▪ Статический контент слотов в виде массивов VNode'ов
      - Содержится в this.$slots
      - Пример использования:

          render: function (createElement) {
            // <div><slot></slot></div>
            return createElement('div', this.$slots.default)
          }

    • Доступ к scoped slots
      - Как к функциям, которые возвращают VNode'ы из this.$scopedSlots
      - Пример использования:

          render: function (createElement) {
            // <div><slot :text="msg"></slot></div>
            return createElement('div', [
              this.$scopedSlots.default({
                text: this.msg
              })
            ])
          }

    • Передать scoped slots дочернему компоненту в render-функции
      - Используй поле scopedSlots в объекте данных createElement:

          render (createElement) {
            return createElement('div', [
              createElement('child', {
                // pass scopedSlots in the data object
                // in the form of { name: props => VNode | Array<VNode> }
                scopedSlots: {
                  default: function (props) {
                    return createElement('span', props.text)
                  }
                }
              })
            ])
          }

> Функциональные компоненты

  • Без состояния (data) и экземпляра (this)
    - Обычный компонент имеет состояние (data).
    - А следовательно, и контекст экземпляра (this).
    - Однако, есть простые компоненты, которым это не нужно.
    - В конструкторе есть специальное св-во functional.
    - Если ему передать true, компонент будет обозначен, как функциональный.
    - Например:

        Vue.component('my-component', {
          functional: true,

          // To compensate for the lack of an instance,
          // we are now provided a 2nd context argument.
          render: function (createElement, context) {
            // ...
          },

          // Props are optional
          props: {
            // ...
          }

        })

  • Аргумент context функции render
    - Обратим внимание на аргумент context функции render.
    - Туда должен передаваться объект.
    - Всё нужное компоненту должно быть передано через него.
    - Включая:

      ▪ props       | объект с props
      ▪ children    | массив дочерних VNode'ов
      ▪ slots       | функция, возвращающая объекто слотов
      ▪ data        | объект data
      ▪ parent      | ссылка на родительский компонент
      ▪ listeners   | [алиас для data.on] объект с обработчиками из родителя
      ▪ injections  | при использовании опции inject, содержит resolved injections

  • Функциональные компоненты легче рендерить
    - Ведь это просто функции.
    - По сути, это позволяет экономить ресурсы системы.
    - Короче говоря, это способ повысить производительность.
    - Для фанатов =)

  • Функциональных компонентов нет в VueJS Chrome dev tools
    - Что делает их отладку менее удобной.

  • Функциональный компонент, как обёртка
    - ФК очень полезны, как обёртки.
    - Примеры ситуаций, когда это можно использовать:

      ▪ Программно выбрать 1 из N компонентов для чего-то.
      ▪ Предобработка children, props, data и т.д. перед передачей в дочерний компонент.

    - Вот пример компонента-обёртки smart-list.
    - В зависимости от props он применяет разные компоненты.
    - Код:

        var EmptyList = { /* ... */ }
        var TableList = { /* ... */ }
        var OrderedList = { /* ... */ }
        var UnorderedList = { /* ... */ }
        Vue.component('smart-list', {
          functional: true,
          render: function (createElement, context) {
            function appropriateListComponent () {
              var items = context.props.items
              if (items.length === 0)           return EmptyList
              if (typeof items[0] === 'object') return TableList
              if (context.props.isOrdered)      return OrderedList
              return UnorderedList
            }
            return createElement(
              appropriateListComponent(),
              context.data,
              context.children
            )
          },
          props: {
            items: {
              type: Array,
              required: true
            },
            isOrdered: Boolean
          }
        })    
  
  • slots() vs children
    - Вы можете удивлятсья, зачем нужны slots() и children одновременно?
    - Разве slots().default не будет равно children?
    - В некоторых случаях да, но что, если у вас есть функциональный
      компонент следующего вида:

        <my-functional-component>
          <p slot="foo">
            first
          </p>
          <p>second</p>
        </my-functional-component>

    - Children вернёт оба элемента p.
    - slots().default вернёт только второй p.
    - slots().foo вернёт только первый p.


Б5. Пользовательские директивы

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

    ▪ Кастомные пользовательские директивы
    ▪ Способ создавать повторно используемый код
    ▪ Используй, если нужны низкоуровневые операции с DOM

  # JS-хуки жизненного цикла директив

    ▪ bind              | Срабатывает 1 раз при биндинге директивы с эл-том
    ▪ inserted          | Срабатывает после вставки связанного эл-та в эл-т родителя
    ▪ update            | Срабатывает при обновлении компонента-контейнера, не ждёт обновления потомков.
    ▪ componentUpdated  | Срабатывает после обновления как комп.-контейнера, так и его потомков.
    ▪ unbind            | Срабатывает 1 раз при анбиндинге директивы от эл-та

  # Аргументы JS-хуков директив

    • Список аргументов JS-хуков директив

      ▪ el            | Эл-к, к которому привязана директива
      ▪ binding       | Объект со св-ми директивы
        ▪ name        | - Название директивы без префикса v-
        ▪ value       | - Значение, переданное в директиву
        ▪ oldValue    | - Предыдущее значение, переданное в директиву
        ▪ expression  | - Выражение-строка, переданное в директиву
        ▪ arg         | - Аргумент, переданный в директиву (если есть)
        ▪ modifiers   | - Объект с модификаторами (если они есть)
      ▪ vnode         | Вирт.эл-т, созданный компилятором Vue
      ▪ oldVnode      | Предыдущий vnode, доступный лишь для хуков

    • Все аргументы, кроме el, только для чтения
    • Пример кастомной директивы, использующей аргументы

  # Сокращённая запись

    • Хуки bind и update
    • Сокращённая запись: обработчик вместо объекта обработчиков

  # Передача объекта данных в директиву

    • Через объект удобно передавать данные в директиву

--------------------------------------

> Ссылки

  # [Официальное руководство] Пользовательские директивы
      https://ru.vuejs.org/v2/guide/custom-directive.html

> Введение

  • Кастомные пользовательские директивы
    - Vue позволяет создавать кастомные директивы.
    - Кастомные директивы представляют повторно используемый код.

  • Способ создавать повторно используемый код
    - КПД являются способом создавать ПИК.
    - Но основным способом создавать ПИК в Vue являются компоненты.

  • Используй, если нужны низкоуровневые операции с DOM
    - В качестве примера реализуем фокус на элементе input.
    - Код примера:

      // Регистрируем глобальную пользовательскую директиву v-focus
      Vue.directive('focus', {
        // Когда привязанный элемент вставлен в DOM...
        inserted: function (el) {
          // Переключаем фокус на элемент
          el.focus()
        }
      })    

    - Директиву можно зарегистрировать и локально в компоненте.
    - Надо передать опцию directives в конструкторе компонента:

      directives: {
        focus: {
          // определение директивы
        }
      }

    - И теперь в шаблонах можно использовать атрибут v-focus.
    - Вот так:

      <input v-focus>

> JS-хуки жизненного цикла директив

  • bind
    - Срабатывает 1 раз при биндинге директивы с эл-том.
    - Здесь можно поместить код инициализации.

  • inserted
    - Срабатывает после вставки связанного эл-та в эл-т родителя.
    - Сам родитель может на этот момент и не принадлежать ещё основному дереву элементов.
  
  • update
    - Срабатывает при обновлении компонента-контейнера, не ждёт обновления потомков.
    - Значение директивы к этому моменту может измениться, а может и нет.
    - Сравнивая текущее и прошлое значения, вы можете избежать избыточных операций
      (см. ниже об аргументах хуков).

  • componentUpdated
    - Срабатывает после обновления как комп.-контейнера, так и его потомков.

  • unbind
    - Срабатывает 1 раз при анбиндинге директивы от эл-та.

> Аргументы JS-хуков директив

  # Список аргументов JS-хуков директив

    • el
      - Эл-к, к которому привязана директива.
      - Можно использовать для прямых манипуляций с DOM.

    • binding
      - Объект со св-ми директивы.
      - Заполняется автоматом, на основе переданных 
        директиве в шаблоне данных.
      - Список свойств:
   
        ▪ name
          - Название директивы без префикса v- .
        
        ▪ value
          - Значение, переданное в директиву.
          - Например, для v-my-directive="1 + 1" значением будет 2.

        ▪ oldValue
          - Предыдущее значение, переданное в директиву.
          - Доступно только для хуков update и componentUpdated.
          - Передаётся независимо от того, произошло ли в действительности его изменение.

        ▪ expression
          - Выражение-строка, переданное в директиву.
          - Например, для v-my-directive="1 + 1" это будет "1 + 1".

        ▪ arg
          - Аргумент, переданный в директиву (если есть).
          - Например, для v-my-directive:foo это будет "foo".

        ▪ modifiers
          - Объект с модификаторами (если они есть).
          - Например, для v-my-directive.foo.bar, объектом 
            модификаторов будет { foo: true, bar: true }.
      
    • vnode
      - Вирт.эл-т, созданный компилятором Vue.
      - См. https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js

    • oldVnode
      - Предыдущий vnode, доступный лишь для хуков.


  # Все аргументы, кроме el, только для чтения
    - Никогда не следует их изменять.
    - Для передачи инфы между хуками используй dataset:
      https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset

  # Пример кастомной директивы, использующей аргументы

    ▪ Что делает
      - Ничего особенного.
      - Заменяет содержимое связанное эл-та текстом.
      - В тексте выводит содержимое объекта binding.

    ▪ Использование директивы

      <div id="hook-arguments-example" v-demo:foo.a.b="message"></div>

    ▪ Создание директивы, экземпляр

      Vue.directive('demo', {
        bind: function (el, binding, vnode) {
          var s = JSON.stringify
          el.innerHTML =
            'name: '       + s(binding.name) + '<br>' +
            'value: '      + s(binding.value) + '<br>' +
            'expression: ' + s(binding.expression) + '<br>' +
            'argument: '   + s(binding.arg) + '<br>' +
            'modifiers: '  + s(binding.modifiers) + '<br>' +
            'vnode keys: ' + Object.keys(vnode).join(', ')
        }
      })
      new Vue({
        el: '#hook-arguments-example',
        data: {
          message: 'hello!'
        }
      })    

> Сокращённая запись

  • Хуки bind и update
    - Бывает, что в директиве нужны лишь хуки bind и update.
    - Да и для них нужно применить один и тот же обработчик.
    - Тогда можно использовать сокращённую запись.

  • Сокращённая запись: обработчик вместо объекта обработчиков
    - В функцию Vue.directive надо передавать в т.ч. 2-й аргумент.
    - В не сокращённом варианте это объект хуков, типа:

        Vue.directive('demo', {
          bind:             function (el, binding, vnode) {...},
          inserted:         function (el, binding, vnode) {...},
          update:           function (el, binding, vnode) {...},
          componentUpdated: function (el, binding, vnode) {...},
          unbind:           function (el, binding, vnode) {...}
        }

    - А в сокращённом мы вместо объекта передаём функцию.
    - И эта функция является обработчиком для bind и update.
    - Например:

        Vue.directive('demo', function (el, binding, vnode) {
          ... код обработчика ...
        })       

    - Это тоже самое, что написать:

        Vue.directive('demo', {
          bind:             function (el, binding, vnode) {...},
          update:           function (el, binding, vnode) {...},
        }    

> Передача объекта данных в директиву

  • Через объект удобно передавать данные в директиву
    - Тогда она сможет принимать несколько параметров.
    - Например:

      ▪ В шаблоне, передаём директиве объект

        <div v-demo="{ color: 'white', text: 'hello!' }"></div>

      ▪ Определение директивы, она принимает значения из объекта

        Vue.directive('demo', function (el, binding) {
          console.log(binding.value.color) // => "white"
          console.log(binding.value.text)  // => "hello!"
        })      


Б6. Примеси

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

    ▪ Инструмент повторного использ.кода в компонентах Vue
    ▪ Быстрый простой пример использования примеси

  # Стратегии слияние опций (собственных и примесей)

    • Слияние хуков

      ▪ Не пересекующиеся хуки будут просто добавлены
      ▪ Пересекающиеся хуки будут объединены в массив
      ▪ [пример] Из пересекающихся хуков сначала сработают хуки примесей 

    ▪ Слияние объектов (напр.: methods / components / directives)

      ▪ Св-ва объектов будут объединены, если нет конфликта
      ▪ [пример] В случае конфликта, приоритет опциям компонента

    ▪ Те же стратегии слияния используются в Vue.extend()

  # Глобальные примеси

    • Глобальное применение примеси прямо к Vue
    • Это окажет влияние на все экземпляры Vue
    • Пример глобальной примеси

  # Стратегия слияния пользовательских опций

    • Стратегия по умолчанию для слияния пользовательских опций
    • Можно кастомизировать стратегию слияния пользовательских опций
    • Использование стратегии, как для опции methods
    • Пример более сложной стратегии слияния из Vuex 1.x

-------------------------------------- 

> Ссылки

  # [Официальное руководство] Примеси
      https://ru.vuejs.org/v2/guide/mixins.html

> Введение

  • Инструмент повторного использ.кода в компонентах Vue
    - Объект примеси может содержать любые опции компонентов.
    - Компонент может использовать от 0 и больше примесей.
    - Все опции примесей "подмешиваются" к собственным опциям компонентов.

  • Быстрый простой пример использования примеси

    ▪ Определение объекта-примеси

      var myMixin = {
        created: function () {
          this.hello()
        },
        methods: {
          hello: function () {
            console.log('привет из примеси!')
          }
        }
      }

    ▪ Определение компонента, использующего примесь

      var Component = Vue.extend({
        mixins: [myMixin]
      })

    ▪ При создании компонента срабатывает метод hello из примеси

      var component = new Component() // -> "привет из примеси!"

> Стратегии слияние опций (собственных и примесей)

  # Слияние хуков

    • Не пересекующиеся хуки будут просто добавлены
      - Допустим, у компонента есть хук created.
      - А в миксине есть хук updated.
      - Конфликта нет, хук updated просто будет добавлен в компонент.

    • Пересекающиеся хуки будут объединены в массив
      - Допустим, у компонента есть хук created.
      - И в миксине тоже есть хук created.
      - Сработают ли они оба? Да.

    • [пример] Из пересекающихся хуков сначала сработают хуки примесей 
      - Но сначала сработает хук created миксины, а потом - компонента.
      - Например:

          var mixin = {
            created: function () {
              console.log('вызван хук примеси')
            }
          }
          new Vue({
            mixins: [mixin],
            created: function () {
              console.log('вызван хук компонента')
            }
          })
          // -> "вызван хук примеси"
          // -> "вызван хук компонента"

  # Слияние объектов (напр.: methods / components / directives)

    • Св-ва объектов будут объединены, если нет конфликта
      - Просто св-ва из миксины добавятся к св-вам в компоненте.
      - Т.К. конфликта нет, они просто встанут рядышком.

    • [пример] В случае конфликта, приоритет опциям компонента
      - А что, если в объектах в компоненте и миксине одинаковые св-ва?
      - Тогда приоритет будет отдан св-вам в компоненте.
      - Ну а св-ва и миксины будут посланы куда подальше.
      - Пример:

          var mixin = {
            methods: {
              foo: function () {
                console.log('foo')
              },
              conflicting: function () {
                console.log('из примеси')
              }
            }
          }
          var vm = new Vue({
            mixins: [mixin],
            methods: {
              bar: function () {
                console.log('bar')
              },
              conflicting: function () {
                console.log('из самого компонента')
              }
            }
          })
          vm.foo() // -> "foo"
          vm.bar() // -> "bar"
          vm.conflicting() // -> "из самого компонента"

  # Те же стратегии слияния используются в Vue.extend()
    - Сабж.

> Глобальные примеси

  • Глобальное применение примеси прямо к Vue
    - Примесь может быть применена и глобально.
    - Прямо к самому Vue.

  • Это окажет влияние на все экземпляры Vue
    - Поэтому, нужно использовать эту возможность осторожно.
    - Они влияют на все до единого экземпляры Vue.
    - Включая, внешние компоненты, и что-то могут в них сломать.
    - Часто, не стоит их использовать для обработки польз.опций (см.пример ниже).
    - Лучше всё это оформлять в виде плагинов, чтобы избежать дублирования кода.

  • Пример глобальной примеси

    ▪ Добавляем обработчик для пользовательской опции `myOption`
    
      Vue.mixin({
        created: function () {
          var myOption = this.$options.myOption
          if (myOption) {
            console.log(myOption)
          }
        }
      })

    ▪ Создаём новый экземпляр, и обработчик срабатывает

      new Vue({
        myOption: 'hello!'
      })
      // -> "hello!"

> Стратегия слияния пользовательских опций

  • Стратегия по умолчанию для слияния пользовательских опций
    - Действует для пользовательских опций.
    - Состоит в том, что просто заменяет одни опции на другие.

  • Можно кастомизировать стратегию слияния пользовательских опций
    - Используя метод Vue.config.optionMergeStrategies
    - Например:

      Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
        // return mergedVal
      }

  • Использование стратегии, как для опции methods
    - Для большей части опций-объектов можно использовать её.
    - Например, для объекта myOption:

      var strategies = Vue.config.optionMergeStrategies;
      strategies.myOption = strategies.methods;

  • Пример более сложной стратегии слияния из Vuex 1.x

    const merge = Vue.config.optionMergeStrategies.computed
    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
      if (!toVal) return fromVal
      if (!fromVal) return toVal
      return {
        getters: merge(toVal.getters, fromVal.getters),
        state: merge(toVal.state, fromVal.state),
        actions: merge(toVal.actions, fromVal.actions)
      }
    }


Б7. Плагины

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

    • Что делают плагины?
    • Несколько типов плагинов
    • Что из себя представляет плагин; метод install
    • Пример плагина и того, что он может
      ▪ Добавление глобального метода или свойства
      ▪ Добавление глобального объекта (директивы)
      ▪ Добавление опций компонентов (миксины)
      ▪ Добавление метода экземпляра      

  # Использование плагина

    • Метод Vue.use; доп.параметры
    • Vue.use предохраняет от множественной регистрации
    • При использовании с webpack надо вызывать Vue.use вручную
 
-------------------------------------- 

> Ссылки

  # [Официальное руководство] Плагины
      https://ru.vuejs.org/v2/guide/plugins.html

  # Огромная коллекция плагинов и библиотек от сообщества Vue
      https://github.com/vuejs/awesome-vue#components--libraries

> Введение

  • Что делают плагины?
    - Добавляют в Vue некоторый глобальный функционал.
    - В явном виде область применения плагинов не определена.

  • Несколько типов плагинов

    ▪ Добавляющие глобальные методы и/или свойства
      - Например vue-custom-element.

    ▪ Добавляющие глобальные объекты: директивы/фильтры/переходы и т.д.
      - Например vue-touch.

    ▪ Добавляющие опции компонентов посредством глобальной примеси
      - Например Vuex.

    ▪ Добавляющие методы экземпляра Vue через Vue.prototype

    ▪ Библиотеки, предоставляющие собственные API, комбинируя вышеперечисленные возможности
      - например Vue-router

  • Что из себя представляет плагин; метод install
    - Это просто js-объект с методом install.
    - Метод install должен принимать 2 аргумента:

        MyPlugin.install = function (Vue, options) {
          ...
        }

    - В первом при использовании плагина будет конструктор Vue.
    - Во стором объект с дополнительными опциями.

  • Пример плагина и того, что он может

    MyPlugin.install = function (Vue, options) {

      ▪ Добавление глобального метода или свойства

        Vue.myGlobalMethod = function () {
          // некоторая логика ...
        }

      ▪ Добавление глобального объекта (директивы)

        Vue.directive('my-directive', {
          bind (el, binding, vnode, oldVnode) {
            // некоторая логика ...
          }
          ...
        })

      ▪ Добавление опций компонентов (миксины)

        Vue.mixin({
          created: function () {
            // некоторая логика ...
          }
          ...
        })

      ▪ Добавление метода экземпляра

        Vue.prototype.$myMethod = function (options) {
          // некоторая логика ...
        }

    }

> Использование плагина

  • Метод Vue.use; доп.параметры
    - Использовать плагин можно с помощью метода Vue.use.
    - При установке плагина можно передавать доп.параметры.

      Vue.use(MyPlugin)                       // без доп.параметров
      Vue.use(MyPlugin, { someOption: true }) // с доп.параметрами

  • Vue.use предохраняет от множественной регистрации
    - .. одного и того же плагина.
    - Вызов Vue.use для 1-го плагина приведёт к его 1-кратной установке.

  • При использовании с webpack надо вызывать Vue.use вручную
    - Многие оф.плагины для Vue делают это автоматически.
    - Сами себя устанавливают, если видят глобальную Vue.
    - Но при работе с webpack, надо вызывать Vue.use вручную.
    - Например:

      ▪ При использовании CommonJS посредством Browserify или Webpack
      
        var Vue = require('vue')
        var VueRouter = require('vue-router')
      
      ▪ Не забудьте этот вызов!
      
        Vue.use(VueRouter)


Б8. Однофайловые компоненты

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

    • О чём данная глава?
    • О разделении ответственности

  # Обоснование существования однофайловых vue-компонентов

    • 2 способа определить компонент: глобально, через .vue-файл
      ▪ Глобальное определение
      ▪ Через .vue-файл

    • Недостатки глобального определения (ГО)
      ▪ Необходимость уникальных имён компонентов
      ▪ Нет подсветки синтаксиса в строковых шаблонах
      ▪ Нельзя встроить CSS в модули
      ▪ Отсутствие шага сборки (предварительной компиляции)

    • .vue + webpack = решение вышеописанных проблем

  # Простой пример однофайлового .vue-компонента

    • Без использования препроцессоров и пр.
    • С использованием препроцессоров и пр.

-------------------------------------- 

> Ссылки

  # [Официальное руководство] Однофайловые компоненты
      https://ru.vuejs.org/v2/guide/single-file-components.html

  # Официальный сайт webpack
      https://webpack.js.org/

  # Официальный шаблон фронтенд-проекта на однофайловых компонентах и webpack
      https://github.com/vuejs-templates/webpack-simple

  # Список официалных шаблонов фронтенд-проекта
      https://github.com/vuejs-templates

> Введение

  • О чём данная глава?
    - Общий обзор однофайловых vue-компонентов.

  • О разделении ответственности
    - Есть подход, когда код в UI делять на 3 больших слоя.
    - HTML, CSS, JS. Их кладут в разные файлы, потом они переплетаются между собой.
    - Авторы Vue предлагают вместо этого использовать компоненты.
    - Каждый компонент содержит HTML, CSS, JS, и представляет отдельный файл.
    - Внутри компонента шаблон, логика и стили неразрывно связаны между собой.
    - Компоненты слабо связаны между собой, но их можно использовать совместно.
    - Это должно облегчить поддержку и использование кода.
    - Хотя, при желании, можно и HTML,CSS,JS выделить в отдельные файлы,
      и использовать однофайловые компоненты:

        <!-- my-component.vue -->
        <template>
          <div>Это будет предварительно скомпилировано</div>
        </template>
        <script src="./my-component.js"></script>
        <style src="./my-component.css"></style>      

> Обоснование существования однофайловых vue-компонентов

  • 2 способа определить компонент: глобально, через .vue-файл

    ▪ Глобальное определение
      - Во многих проектах компоненты определяются через Vue.component
      - И после определения в теле каждого документа: 

          new Vue({ el: '#container' })

    ▪ Через .vue-файл
      - Компонент определяется в отдельном файле с расширением .vue
      - Затем через систему сборки (webpack) компилируется в js. 

  • Недостатки глобального определения (ГО)
    - Для малых проектов глобальное определение может сгодиться.
    - Но для больших SPA-приложений, явными становятся следующщие недостатки:

      ▪ Необходимость уникальных имён компонентов
        - ГО заставляет давать уникальное имя каждому компоненту.

      ▪ Нет подсветки синтаксиса в строковых шаблонах
        - Кроме того, приходится использовать слэши для переноса строки.

      ▪ Нельзя встроить CSS в модули
        - В компонент можно встроить HTML и JS, но не CSS.

      ▪ Отсутствие шага сборки (предварительной компиляции)
        - Имеется в виду использование систем сборок, типа webpack
        - Во время сборки мы бы могли как-то всё это дело обрабатывать.
        - В том числе, использовать, например ES6 с помощью babel.
        - Вставлять вендорные префиксы в CSS, производить минификацию, и т.п.
        - Но при ГО шаг сборки отсутствует, и мы лишаемся многих возможностей.
    
  • .vue + webpack = решение вышеописанных проблем
    - Соответственно, однофайловые .vue-компоненты лишены этих недостатков.
    - .vue + webpack = решение вышеописанных проблем.
    - Поэтому то, рекомендуется использовать .vue-компоненты в крупных проектах.

> Простой пример однофайлового .vue-компонента

  • Без использования препроцессоров и пр.

    ▪ Шаблон

      <template>
        <p>{{ greeting }} World!</p>
      </template>

    ▪ Модель    ▪ Модель    ▪ Модель    ▪ Модель    ▪ Модель

      <script>
      module.exports = {
        data: function(){
          return {
            greeting: 'Hello'
          }
        }
      };
      </script>

    ▪ Стили

      <style scoped>
        p {
          font-size: 2em;
          text-align: center;
        }
      </style>

  • С использованием препроцессоров и пр.

    ▪ Шаблон

      <template lang="jade">
        div
          p {{ greeting }} World!
          other-component
      </template>

    ▪ Модель

      <script>

        // Импортируем компонент
        import OtherComponent from './OtherComponent.vue'

        // Определяем модель
        export default {
          data () {
            return {
              greeting: 'Hello'
            }
          },
          components: {
            OtherComponent
          }      
        };

      </script>

    ▪ Стили

      <style lang="stylus" scoped>
        p
          font-size 2em
          text-align center
      </style>


Б9. Советы по деплою

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

    • Режимы работы Vue: dev / prod
    • Режим prod увеличивает производительность

  # Способы вкл/выкл режима production

    • UMD-сборки
    • CommonJS и ES Module
    • Переменная среды process.env.NODE_ENV

  # Прекомпиляция шаблонов

    • Компиляция на лету
      ▪ Компилятор Vue
      ▪ DOM- и строковые шаблоны компилируются на лету
      ▪ Компиляция на лету вредит производительности

    • Прекомпиляция шаблонов
      ▪ Прекомпиляция webpack'ом на этапе сборки на сервере
      ▪ Прекомпиляция используется с однофайловыми .vue-компонентами
      ▪ Прекомпиляция на сервере повышает производительность клиента

  # Проблема FOUC: flash of unstyled content

    • В чём состоит проблема FOUC
    • Как CSS однофайлового компонента добавляется в документ
    • Актуально при рендеригне на стороне сервера
    • Побороть FOUC: сбор всех стилей с компонентов в 1 файл

  # Отслеживание ошибок рендеринга компонентов

    • Хук Vue.config.errorHandler
    • Сервис Sentry

-------------------------------------- 

> Ссылки

  # [Официальное руководство] Советы по деплою
      https://ru.vuejs.org/v2/guide/deployment.html

> Введение
  
  • Режимы работы Vue: dev / prod
    -librariesВ dev-режиме Vue выполняет проверки, выводит предупреждения, и т.п.
  
  • Режим prod увеличивает производительность
    - В prod-режиме всё это не нужно, и можно отключить.

> Способы вкл/выкл режима production

  • UMD-сборки
    - Тут есть min и не-min файлы.
    - min для продакшн, не-min для разработки.

  • CommonJS и ES Module
    - Тут не минифицированный код.
    - Ведь эти сборки предназначены для инструментов сборки.
    - Хочешь минифицировать - легко это сделаешь через оные.
    
  • Переменная среды process.env.NODE_ENV
    - Также эти сборки палят переменную среды: process.env.NODE_ENV.
    - В каждой системе сборки можно использовать соотв.плагин:

      ▪ Webpack

          var webpack = require('webpack')
          module.exports = {
            // ...
            plugins: [
              // ...
              new webpack.DefinePlugin({
                'process.env': {
                  NODE_ENV: JSON.stringify('production')
                }
              })
            ]
          }

      ▪ Rollup

          const replace = require('rollup-plugin-replace')
          rollup({
            // ...
            plugins: [
              replace({
                'process.env.NODE_ENV': JSON.stringify('production')
              })
            ]
          }).then(...)

      ▪ Browserify

          NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js

> Прекомпиляция шаблонов

  • Компиляция на лету

    ▪ Компилятор Vue
      - Компиляция на лету производится компилятором Vue.
      - Компилятор ещё должен присутствовать в используемой сборке Vue.

    ▪ DOM- и строковые шаблоны компилируются на лету
      - Имеется в виду, в render-функцию.
      - Прямо на стороне клиента, компилятором Vue.

    ▪ Компиляция на лету вредит производительности
      - На клиента ложится доп.нагрузка по компиляции.
      - А если приложение оч.большое, это серьёзная проблема.

  • Прекомпиляция шаблонов

    ▪ Прекомпиляция webpack'ом на этапе сборки на сервере
      - Другой подход, прекомпилировать шаблоны на сервере.
      - Например, это можно делать с помощью webpack.

    ▪ Прекомпиляция используется с однофайловыми .vue-компонентами
      - Архитектурно, однофайловые компоненты прекомпилируются системой сборки.
      - Соответственно, одновременно и шаблоны компилируются в render-функции.
      - А глобальные компоненты, по умолчанию, не пропускаются через
        систему сборки, соответственно, и шаблоны нельзя в них прекомпилировать.

    ▪ Прекомпиляция на сервере повышает производительность клиента
      - Т.К. с клиента снимается доп.нагрузка по "компиляции на лету".
      - Для больших SPA-приложений советую пользоваться прекомпиляцией.

> Проблема FOUC: flash of unstyled content

  • В чём состоит проблема FOUC
    - CSS однофайловых компонентов не сразу применяется.
    - В момент, когда всё уже готово, а стили ещё не подключены,
      пользователь на доли секунды видит не стилизованный контент,
      он как бы "мелькает", а потом стили применяются.
  
  • Как CSS однофайлового компонента добавляется в документ
    - В однофайловых компонентах CSS встроен.
    - При подключении компонента его CSS добавляется в документ.
    - С помощью JS, этот CSS просто тупо вставляется в тег <style> в документе.
    - И на выполнение этой операции требуется некоторое время...

  • Актуально при рендеригне на стороне сервера
    - Проблема FOUC актуальна при рендеринге на стороне сервера.

  • Побороть FOUC: сбор всех стилей с компонентов в 1 файл
    - Допустим, в документе используются N компонентов.
    - Надо их стили собрать с помощью webpack в 1 файл.
    - Вообще, все стили всего документа собрать в этот 1 файл.

> Отслеживание ошибок рендеринга компонентов

  • Хук Vue.config.errorHandler
    - В случае ошибки, вызывается эта функция.
    - Конечно. в том случае, если она была задана.

  • Сервис Sentry
    - Это можно интегрировать с сервисом Sentry.
    - Это сервис для отслеживания ошибок.
    - У него есть интеграции с Vue.


Б10. Vue CLI

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

    • Официальный Vue CLI
    • Нужен для подготовки "рыбы" проекта из шаблона
  
  # Установка Vue CLI
  # Использование Vue CLI

    • Команда init
    • [пример] Создать проект из шаблона webpack

-------------------------------------- 

> Ссылки

  # [Официальный репозиторий на github] Vue CLI
      https://github.com/vuejs/vue-cli

> Введение
  
  • Официальный Vue CLI
    - Для Vue есть простой официальный CLI.

  • Нужен для подготовки "рыбы" проекта из шаблона
    - Это его основное предназначение.
    - То есть, CLI действительно не слишком функциональный.

> Установка Vue CLI

    npm install -g vue-cli

> Использование Vue CLI

  • Команда init
    - Она качает шаблон из:
      https://github.com/vuejs-templates/<template-name>
    - Запрашивает у пользователя кое-какую инфу.
    - И создаёт проект по адресу: ./<имя проекта>

        vue init <template-name> <project-name>

  • [пример] Создать проект из шаблона webpack

      vue init webpack my-project


Б11. Vue devtools, плагин для Chrome

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

  # Какие браузеры поддерживаются

    • Chrome
    • Firefox
    • Safari

  # Важные замечания о Vue devtools

    • Панель не покажется для продакшн-сборок Vue
    • Протокол file:// - включи опцию "Allow access to file URLs"  
    • Vue devtools работает с vuex time-travel debugging

-------------------------------------- 

> Ссылки

  # [Официальный репозиторий на github] Vue CLI
      https://github.com/vuejs/vue-cli

> Введение
  - Для Vue существует оф.плагин для отладки в браузере.
  - Данная глава об этом плагине.

> Какие браузеры поддерживаются

  • Chrome
    - Для chrome есть extension.

  • Firefox
    - Для firefox есть addon.

  • Safari
    - Чтобы разаротало на сафари, нужно немного танцев с бубном.
    - См.здесь: https://github.com/vuejs/vue-devtools/blob/master/docs/workaround-for-safari.md

> Важные замечания о Vue devtools
  
  • Панель не покажется для продакшн-сборок Vue
    - Потому что в них отладка отключена.

  • Протокол file:// - включи опцию "Allow access to file URLs"
    - Речь о случае, когда ты просто открываешь файл из папочки.
    - Файл открывается через протокол file://
    - Чтобы заработало в Chrome, надо включить опцию для расширения:
      "Allow access to file URLs".
  
  • Vue devtools работает с vuex time-travel debugging
    - Сабж.
  
  
Б12. Vue API

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 
 
  # Встроенные компоненты (• - компонент, ▪ - свойство, ► - событие)

    • component         | Встроенный компонент-обёртка для условного рендеринга компонентов
      
      ▪ is                            | Какой компонент рендерить (имя лок.комп / ссылка на объект-определение)
      ▪ inline-template               | Использовать html внутри component, как шаблон для обёрнутого компонента (иначе, распихать по слотам комп-та из is).
       
    • transition        | Встроенный компонент-обёртка для transition-эффектов на 1-ом обёрнутом компоненте/DOM-элементе

      ▪ name                          | Кастомный префикс для transition-классов ('v' по умолчанию)
      ▪ appear                        | Применять ли transition при начальном рендеринге (false по умолчанию)
      ▪ css                           | Применять ли CSS transition-классы
      ▪ type                          | Конец анимации определять по css/js анимации (брать сам.длинную по умолчанию)?
      ▪ mode                          | Порядок срабатывания transition enter/leave (синхронно по умолчанию)
    
      ▪ enter-class                   | CSS-класс начала анимации появления
      ▪ leave-class                   | CSS-класс начала анимации исчезновения
      ▪ appear-class                  | CSS-класс начала анимации появления при 1-м рендеринге
      ▪ enter-to-class                | CSS-класс конца анимации появления
      ▪ leave-to-class                | CSS-класс конца анимации исчезновения
      ▪ appear-to-class               | CSS-класс конца анимации появления при 1-м рендеринге
      ▪ enter-active-class            | CSS-класс процесса анимации (когда она идёт) появления
      ▪ leave-active-class            | CSS-класс процесса анимации (когда она идёт) исчезновения
      ▪ appear-active-class           | CSS-класс процесса анимации (когда она идёт) появления при 1-м рендеринге

      ► before-enter                  | Хук, сработает непосредственно перед началом анимации появления 
      ► before-leave                  | Хук, сработает непосредственно перед началом анимации исчезновения
      ► before-appear                 | Хук, сработает непосредственно перед началом анимации появления при 1-м рендеринге
      ► enter                         | Хук, сработает в момент начала анимации появления
      ► leave                         | Хук, сработает в момент начала анимации исчезновения
      ► appear                        | Хук, сработает в момент начала анимации появления при 1-м рендеринге
      ► after-enter                   | Хук, сработает непосредственно после начала анимации появления
      ► after-leave                   | Хук, сработает непосредственно после начала анимации исчезновения
      ► after-appear                  | Хук, сработает непосредственно после начала анимации появления при 1-м рендеринге
      ► enter-cancelled               | Хук, сработает при отмене анимации появления
      ► leave-cancelled (лишь v-only) | Хук, сработает при отмене анимации исчезновения (только для v-show)
      ► appear-cancelled              | Хук, сработает при отмене анимации появления при 1-м рендеринге

    • transition-group  | Встроенный компонент-обёртка для transition-эффектов на N обёрнутых компонентах/DOM-элементах

      ▪ tag                           | Вместо span, в какой DOM-элемент срендерится обёртка transition-group
      ▪ move-class                    | Вручную указать имя CSS-класса, которое заменит v-move

      ► События --//--, что и в transition        

    • keep-alive        | Встроенный компонент-обёртка вокруг <component></component> для кэширования содержимого, без его уничтожения

      ▪ include                       | Перечислить компоненты, на которых подействует keep-alive ("a,b" / RegExp)
      ▪ exclude                       | Перечислить компоненты, на которых НЕ подействует keep-alive ("a,b" / RegExp)

      ► activated                     | Хук, сработает, когда keep-alive "сохранит" очередной компонент внутри
      ► deactivated                   | Хук, сработает, когда keep-alive "удалит из сохранения" очередной компонент внутри

    • slot              | Используется в шаблоне, чтобы указать, куда распихать переданный в компонент контент

      ▪ name    | Имя, используется для именованных слотов

  # Директивы

    ▪ v-text            | Весь текст внутри элемента
      ▪ {{ Mustache }}  | - Лишь часть текста внутри эл-та (mustache-style)
    ▪ v-html            | HTML внутри элемента
    ▪ v-show            | Переключает CSS-свойство display
    ▪ v-if              | Условный рендеринг элемента
    ▪ v-else            | Часть механизма условного рендеринга элемента
    ▪ v-else-if         | Часть механизма условного рендеринга элемента
    ▪ v-for             | Многократный рендеринг куска шаблона на основе переданных данных
    ▪ v-on / @          | Добавляет элементу обработчик указанного DOM/кастомного события
    ▪ v-bind / :        | Добавить DOM-элементу атрибут; передать компоненту параметр; значение компилируется
    ▪ v-model           | Двунаправленный биндинг на эл-тах формы или компоненте
    ▪ v-pre             | Пропустить компиляцию для этого эл-та и всех его потомков
    ▪ v-cloak           | Висит на связанном с vue-экземпляром DOM-элементе до завершения компиляции
    ▪ v-once            | Указывает, что элемент/компонент надо рендерить лишь однажды

  # Специальные атрибуты

    ▪ key               | Отменить стратегию "обновления на месте"; всегда заменять элемент на новый, а не переиспользовать
    ▪ ref               | Ключ для регистрации ссылки на DOM-элемент/экземпляр компонента/или массив оных (при исп.с v-for) в $refs
    ▪ slot              | В слот с каким именем в шаблоне компонента запихнуть данный кусок контента внутри компонента
    ▪ is                | Подменяет DOM-элемент на указанный в значении компонент
  
  # Опции / данные

    ▪ data              | Объект с данными корневого/компонентного vue-экземпляра
    ▪ props             | Массив/хэш ожидаемых входных параметров
    ▪ propsData         | Параметры компонента при его создании
    ▪ computed          | Вычисляемые свойства, которые будут подмешаны к экземпляру Vue 
    ▪ methods           | Методы, которые будут подмешаны к экземпляру Vue
    ▪ watch             | Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении

  # Опции / DOM

    ▪ el                | Вместо какого DOM-элемента смонтировать экземпляр Vue (css-селектор/ссылка; в отсутствии render/template)
    ▪ template          | Inline-шаблон для экземпляра Vue (строка с шаблоном или #<id DOM-элемента>; в отсутствии render)
    ▪ render            | Render-функция (низкоуровневая альтернатива шаблонам)
    ▪ renderError       | Обеспечивает альтернативный рендер когда render-функция по умолчанию встречает ошибку

  # Опции / хуки жизненного цикла

    i Общая информация о хуках жизненного цикла
    ▪ beforeCreate      | Вызывается синхронно сразу после инициализации экземпляра
    ▪ created           | Вызывается синхронно сразу после создания экземпляра
    ▪ beforeMount       | [кроме ренд.на серв.] Вызывается перед началом монтирования, сразу перед первым вызовом функции render
    ▪ mounted           | [кроме ренд.на серв.] Вызывается сразу после того как экземпляр был смонтирован, а взамен el создан vm.$el
    ▪ beforeUpdate      | [кроме ренд.на серв.] Вызывается при изменении данных, до повторного рендеринга и обновления виртуального DOM-а
    ▪ updated           | [кроме ренд.на серв.] Вызывается после того, как виртуальный DOM был обновлён из-за изменения данных
    ▪ activated         | [кроме ренд.на серв.] Вызывается при активации keep-alive компонента
    ▪ deactivated       | [кроме ренд.на серв.] Вывается после деактивации keep-alive компонента
    ▪ beforeDestroy     | [кроме ренд.на серв.] Вызывается перед уничтожением экземпляра Vue
    ▪ destroyed         | [кроме ренд.на серв.] Вызывается после уничтожения экземпляра Vue

  # Опции / ресурсы

    ▪ directives        | Объект с польз.директивами, доступными экземпляру Vue
    ▪ filters           | Объект с фильтрами, доступными экземпляру Vue
    ▪ components        | Объект с локальными регистрациями компонентов

  # Опции / композиция

    ▪ parent            | Определяет родительский экземпляр для создаваемого
    ▪ mixins            | Массив объектов-примесей
    ▪ extends           | Позволяет декларативно наследоваться от другого компонента, не используя Vue.extend
    ▪ provide / inject  | Нужны компоненту для внедрения зависимостей в любого потомка

  # Опции / разное

    ▪ name              | Название компонента (при глоб.регистрации, равно глоб-му ID компонента)
    ▪ delimiters        | Разделители, выделяющие текст для интерполяции
    ▪ functional        | Превращает компонент в функциональный, то есть не имеющий собственного состояния (data) и своего экземпляра (this)
    ▪ model             | Позволяет настроить входной параметр и событие, используемые для работы v-model
 
  # Свойства экземпляра

    ▪ vm.$data          | Объект с данными, над которым экземпляр Vue осуществляет наблюдение
    ▪ vm.$props         | Объект, предоставляющий доступ к текущим входным данным компонента
    ▪ vm.$el            | [readonly] Корневой элемент DOM, управляемый экземпляром Vue
    ▪ vm.$options       | [readonly] Опции, переданные в конструктор экземпляра Vue
    ▪ vm.$parent        | [readonly] Ссылка на экземпляр родителя, если он есть у текущего экземпляра
    ▪ vm.$root          | [readonly] Корневой экземпляр Vue текущего дерева компонентов
    ▪ vm.$children      | [readonly] Компоненты-потомки экземпляра
    ▪ vm.$slots         | [readonly] Используется для доступа к контенту, распределяемому слотами
    ▪ vm.$scopedSlots   | [readonly] Используется для доступа к scoped slots
    ▪ vm.$refs          | [readonly] Объект, с DOM-элементами/экземплярами компонента/или массивами оных, имеющими параметр ref.
    ▪ vm.$isServer      | [readonly] Запущен ли данный экземпляр Vue на сервере

  # Методы экземпляра: данные

    ▪ vm.$watch         | Отслеживать изменения в наблюдаемой/их, выполнять колбэк (типа computed в knockout)
    ▪ vm.$set           | Позволяет вставлять в наблюдаемый объект/массив по ключу/индексу так, чтобы Vue заметил
    ▪ vm.$delete        | Позволяет удалять из наблюдаемого объекта/массива по ключу/индексу так, чтобы Vue заметил

  # Методы экземпляра: события

    ▪ vm.$on            | Подписать обработчик на польз.событие/массив польз.событий
    ▪ vm.$once          | Подписать на польз.событие обработчик, который сработает лишь однажды
    ▪ vm.$off           | Удалить все или указанные подписки на польз.события
    ▪ vm.$emit          | Возбудить польз.событие в укзанном экземпляре

  # Методы экземпляра: жизненный цикл

    ▪ vm.$mount         | Смонтировать в DOM еще не смонтированный ранее экземпляр Vue
    ▪ vm.$forceUpdate   | Заставляет экземпляр Vue произвести перерендеринг
    ▪ vm.$nextTick      | Выполняет callback на след.тике обновления DOM (в this callback будет ссылка на этот экземпляр)
    ▪ vm.$destroy       | Полностью уничтожает экземпляр vue model

  # Глобальный API
  
    ▪ Vue.extend        | Задать объект-конструктор по умолчанию для Vue
    ▪ Vue.nextTick      | Выполнить callback на следующем тике обновления DOM
    ▪ Vue.set           | Позволяет вставлять в наблюдаемый объект/массив по ключу/индексу так, чтобы Vue заметил
    ▪ Vue.delete        | Позволяет удалять из наблюдаемого объекта/массива по ключу/индексу так, чтобы Vue заметил
    ▪ Vue.directive     | Регистрирует новую глобальную польз.директиву или возвращает уже зарегистрированную
    ▪ Vue.filter        | Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.
    ▪ Vue.component     | Регистрирует новый глобальный компонент или возвращает уже зарегистрированный
    ▪ Vue.use           | Устанавливает плагин в Vue
    ▪ Vue.mixin         | Применяет примесь ко всем будущим экземплярам Vue
    ▪ Vue.compile       | Компилирует inline-шаблон в render-функцию
    ▪ Vue.version       | Возвращает версию используемого Vue в виде строки

  # Глобальный конфиг

    i Про глобальный конфиг Vue.config
    ▪ silent                | Отключает вывод логов и предупреждений Vue
    ▪ optionMergeStrategies | Меняет стратегию слияния опций на вашу собственную
    ▪ devtools              | Указывает, должен ли Vue позволять Vue-devtools проводить инспекцию
    ▪ errorHandler          | Устанавливает обработчик для ошибок, не пойманных во время рендеринга компонентов и в наблюдателях
    ▪ ignoredElements       | Позволяет Vue игнорировать пользовательские компоненты, установленные за пределами Vue (например, используя Web Components API)
    ▪ keyCodes              | Определение пользовательских псевдонимов для директивы v-on
    ▪ perfomance            | Установите в true, чтобы включить отслеживание производительности на этапах инициализации, компиляции, рендера и обновления компонента на графике в инструментах разработчика браузера
    ▪ productionTip         | Установите в false, чтобы отключить предупреждение о работе в режиме разработки при запуске Vue

-------------------------------------- 

> Ссылки

  # [Официальный репозиторий на github] Vue API
      https://ru.vuejs.org/v2/api/

> Введение
  - Полный официальный API Vue, версия 2.0.

> Встроенные компоненты

  • component

    ▪ Описание
      - Встроенный компонент-обёртка для условного рендеринга компонентов.
      - По сути, обёртка, которая рендерит указанный в атрибуте is компонент.
      - Подробнее ищи по ключевой фразе: "Горячая замена компонентов".
      - Пример:

          <!-- a dynamic component controlled by -->
          <!-- the `componentId` property on the vm -->
          <component :is="componentId"></component>

          <!-- can also render registered component or component passed as prop -->
          <component :is="$options.components.child"></component>      

    ▪ Свойства

      ▪ is
        - Какой компонент рендерить (имя лок.комп / ссылка на объект-определение).
        - Возможные значения:

          ▪ string
            - Имя локально зарегистрированного компонента.
            - Пример:

              ▪ Модель, в components локальные компоненты

                  var vm = new Vue({
                    el: '#example',
                    data: {
                      currentView: 'home'
                    },
                    components: {
                      home: { /* ... */ },
                      posts: { /* ... */ },
                      archive: { /* ... */ }
                    }
                  })

              ▪ Шаблон
                - Применяется псевдоэлемент <component>.
                - Имя локально-зарегистрированного компонента 
                  берётся из наблюдаемой currentView.
                - Код:

                  <component v-bind:is="currentView">
                    <!-- изменяя vm.currentView можно переключаться между компонентами -->
                  </component>              

          ▪ ComponentDefinition
            - Объект с определением компонента.
            - Пример:

              ▪ Объект с определением компонента

                  var Home = {
                    template: '<p>Добро пожаловать домой!</p>'
                  }

              ▪ Модель

                  var vm = new Vue({
                    el: '#example',
                    data: {
                      currentView: Home
                    }
                  })

              ▪ Шаблон
                - Применяется псевдоэлемент <component>.
                - Ссылка на определение компонента берётся 
                  из наблюдаемой currentView.
                - Код:

                  <component v-bind:is="currentView">
                    <!-- изменяя vm.currentView можно переключаться между компонентами -->
                  </component>             

          ▪ ComponentConstructor
            - TODO: точно не понятно, что это.
            - Возможно, имеется в виду то, что возвращает
              Vue после глобальной регистрации компонента:

                var constructor = Vue.component('my-component', {
                  template: '<div>Пользовательский компонент!</div>'
                });

      ▪ inline-template
        - Использовать html внутри component, как шаблон для обёрнутого компонента (иначе, распихать по слотам комп-та из is).
        - Без этого атрибута содержимое <component>..содержимое..</component> 
          будет распихано по слотам в шаблоне компонента из is.
        - А с ним оно само будет использовано, как шаблон.
        - Например:

            <my-component inline-template>
              <div>
                <p>Этот шаблон будет скомпилирован в области видимости компонента-потомка.</p>
                <p>Доступа к данным родителя нет.</p>
              </div>
            </my-component>   

  • transition

    ▪ Описание
      - Встроенный компонент-обёртка для transition-эффектов на 1-ом обёрнутом компоненте/DOM-элементе.
      - <transition> не отрисовывает в DOM никаких доп.элементов,
        и не отображается в иерархии компонентов.
      - Он лишь применяет transition-эффекты в завёрнутому
        в него элементу/компоненту.
      - Пример:

        ▪ Шаблон

          <!-- simple element -->
          <transition>
            <div v-if="ok">toggled content</div>
          </transition>

          <!-- dynamic component -->
          <transition name="fade" mode="out-in" appear>
            <component :is="view"></component>
          </transition>

          <!-- event hooking -->
          <div id="transition-demo">
            <transition @after-enter="transitionComplete">
              <div v-show="ok">toggled content</div>
            </transition>
          </div>        

        ▪ Модель

          new Vue({
            ...
            methods: {
              transitionComplete: function (el) {
                // for passed 'el' that DOM element as the argument, something ...
              }
            }
            ...
          }).$mount('#transition-demo')

    ▪ Свойства

      ▪ name 
        - Кастомный префикс для transition-классов ('v' по умолчанию).
        - Transition-классы по умолчанию выглядят так:
            v-enter        
            v-enter-active 
            v-enter-to     
            v-leave        
            v-leave-active 
            v-leave-to               
        - Как видно, везде используется стандартный
          префикс "v".
        - Но его можно изменить, задав другое name.
        - Например, если name равно 'fade', то transition-
          классы уже будут выглядеть так:
            fade-enter        
            fade-enter-active 
            fade-enter-to     
            fade-leave        
            fade-leave-active 
            fade-leave-to            

      ▪ appear
        - Применять ли transition при начальном рендеринге (false по умолчанию).

      ▪ css
        - Применять ли CSS transition-классы.
        - По умолчанию: true.
        - Если поставить false, то лишь будут исполнены
          js-обработчики соответствующих событий.

      ▪ type
        - Конец анимации определять по css/js анимации (брать сам.длинную по умолчанию)?
        - Тип transition-событий, по которым определять
          конец transition.
        - Возможные варианты: transition / animation
        - По умолчанию, автоматически использует тип,
          который длится дольше.

      ▪ mode
        - Порядок срабатывания transition enter/leave (синхронно по умолчанию)
        - Возможные варианты: out-in / in-out.

      ▪ enter-class           
      ▪ leave-class           
      ▪ appear-class       
      ▪ enter-to-class        
      ▪ leave-to-class        
      ▪ appear-to-class    
      ▪ enter-active-class 
      ▪ leave-active-class 
      ▪ appear-active-class
        - См.описания в оглавлении.

    ▪ События

      ▪ before-enter                  
      ▪ before-leave                  
      ▪ before-appear                 
      ▪ enter                         
      ▪ leave                         
      ▪ appear                        
      ▪ after-enter                   
      ▪ after-leave                   
      ▪ after-appear                  
      ▪ enter-cancelled               
      ▪ leave-cancelled (лишь v-show) 
      ▪ appear-cancelled              
        - См.описания в оглавлении.

  • transition-group

    ▪ Описание

      ▪ Общее описание
        - Встроенный компонент-обёртка для transition-эффектов на N обёрнутых компонентах/DOM-элементах.
        - Рендерится в реальный DOM-элемент, span по умолчанию.
          В какой эл-т он срендерится, можно указывать в св-ве tag.
        - Все обёрные эл-ты должны иметь уникальный key, чтобы
          анимация работала правильно.

      ▪ Поддерживает transition движения
        - Это когда позиция элемента меняется на экране.
        - Например, когда меняется позиция эл-та в списке.
        - Vue добавляет класс v-move на время анимации движения.
        - Он работает по аналогии с другими анимационными классами.
        - Префикс по умолчанию "v-", кастомизируется с помощью атрибута name.
        - Чаще всего v-move используют для кастомизации
          transition timing и easing curve.
        - Указать кастомное имя для класса v-move можно в св-ве move-class.

    ▪ Свойства 

      ▪ tag
        - Вместо span, в какой DOM-элемент срендерится обёртка transition-group.

      ▪ move-class
        - Вручную указать имя CSS-класса, которое заменит v-move. 

    ▪ События
      - --//--, что и в transition.

  • keep-alive

    ▪ Описание
      
      ▪ Общее описание
        - Встроенный компонент-обёртка вокруг <component></component> для кэширования содержимого, без его уничтожения.
        - Иногда бывает выгодно хранить отключенные компоненты в памяти.
        - Чтобы не терять их состояния, и не выполнять их повторный рендеринг.
        - Для этого нужно обернуть динамический компонент в псевдоэлемент <keep-alive>.
        - Например:

      ▪ События activated и deactivated
        - При переключении компонентов на любом уровне
          вложенности внутри keep-alive, срабатывают события 
          activated и deactivated.

      ▪ Для чего преимущественно используется
        - Чтобы сохранить состояние компонента.
        - Чтобы избежать ре-рендеринга компонента.

      ▪ Несколько примеров

        <keep-alive>
          <component :is="currentView">
            <!-- неактивные компоненты будут закешированы! -->
          </component>
        </keep-alive>

        <!-- basic -->
        <keep-alive>
          <component :is="view"></component>
        </keep-alive>

        <!-- multiple conditional children -->
        <keep-alive>
          <comp-a v-if="a > 1"></comp-a>
          <comp-b v-else></comp-b>
        </keep-alive>

        <!-- used together with <transition> -->
        <transition>
          <keep-alive>
            <component :is="view"></component>
          </keep-alive>
        </transition>       

    ▪ Свойства 

      ▪ include
        - Перечислить компоненты, на которых подействует keep-alive ("a,b" / RegExp)
        - Например:

          <keep-alive include="a,b">
            <component :is="view"></component>
          </keep-alive>        

      ▪ exclude
        - Перечислить компоненты, на которых НЕ подействует keep-alive ("a,b" / RegExp)
        - Например:

          <!-- regex (use v-bind) -->
          <keep-alive :include="/a|b/">
            <component :is="view"></component>
          </keep-alive>  

    ▪ События

      ▪ activated
        - Хук, сработает, когда keep-alive "сохранит" очередной компонент внутри
      
      ▪ deactivated
        - Хук, сработает, когда keep-alive "удалит из сохранения" очередной компонент внутри

  • slot

    ▪ Описание
      - Используется в шаблоне, чтобы указать, куда распихать переданный в компонент контент.
      - Подробнее о слотах читай в главе "А12. Компоненты".

    ▪ Свойства 

      ▪ name
        - Имя, используется для именованных слотов

> Директивы

  • v-text

    ▪ Описание
      - Весь текст внутри элемента.
      - Для управлению частью текста, используй mustache-style:

          {{ Mustache }}

    ▪ Принимает
      - string

    ▪ Пример
      - Первый пример v-text, второй - mustache-style.
      - В данном случае, оба делают одно и то же.

        <span v-text="msg"></span>
        <span>{{msg}}</span>

  • v-html

    ▪ Описание
      - HTML внутри элемента.
      - Вставляемый html НЕ компилируется, как шаблон Vue.
      - Не надо организовывать вложенные шаблоны с помощью v-html,
        лучше используй компоненты.
      - XSS уязвимость! Не передавай в v-html непроверенный польз.код.

    ▪ Принимает
      - string

    ▪ Пример
      - Допустим, в модели есть св-во html, содержащее html.
      - Передадим его в директиву v-html:

          <div v-html="html"></div>

  • v-show

    ▪ Описание
      - Переключает CSS-свойство display.

    ▪ Принимает
      - any

    ▪ Пример
      
        <h1 v-show="ok">Привет!</h1>

  • v-if

    ▪ Описание
      - Условный рендеринг элемента.
      - При изменении значения выражения на противоположные,
        элемент и содержащиеся в нём компоненты/директивы
        пересоздаются.
      - Если применить к <template>, в случае true, вместо
        него будет отрендерено его содержимое.

    ▪ Принимает
      - any

    ▪ Пример
      
        <div v-if="type == 'A'">
          A
        </div>      

  • v-else

    ▪ Описание
      - Часть механизма условного рендеринга элемента.
      - Если эл-т со связанным v-if не отрендерен,
        и элементы со связанными v-else-if не отрендерены,
        то данный эл-т с v-else отрендерится.
      - Предшествующий элемент должен быть с v-if,
        или с v-else-if.

    ▪ Принимает
      - nothing

    ▪ Пример
      
        <div v-if="type == 'A'">
          A
        </div>      
        <div v-else>
          Не A
        </div>

  • v-else-if

    ▪ Описание
      - Часть механизма условного рендеринга элемента.
      - Если эл-т со связанным v-if не отрендерен,
        и элементы со связанными предыдущими v-else-if 
        не отрендерены, то данный эл-т с v-else отрендерится.
      - Предшествующий элемент должен быть с v-if,
        или с v-else-if.

    ▪ Принимает
      - any

    ▪ Пример
      
        <div v-if="type == 'A'">
          A
        </div>
        <div v-else-if="type == 'B'">
          B
        </div>
        <div v-else>
          Не A,B
        </div>      

  • v-for

    ▪ Описание

      ▪ Общее описание
        - Многократный рендеринг куска шаблона на основе переданных данных.
        - Подробнее о v-for см.главу "А9. Рендеринг списков".
        - Значение директивы должно следовать синтаксису:

            alias in expression     // в alias будет элемент текущей итерации

      ▪ Необходимо указывать key
        
        ▪ Key обязателен с v-for, начиная с v2.2.0
          - Начиная с v2.2.0 key теперь обязателен при использовании с v-for.
        
        ▪ "Стратегия по умолчанию", или "обновление на месте"
          - До v2.2.0 была опция не указывать key с v-for.
          - Тогда Vue использовал стратегию "обновления на месте".
          - Например, порядок элементов массива/объекта изменился.
          - Vue не будет перемещать эл-ты DOM, а просто обновит каждый "на месте".
          - Чтобы он отображал новые данные по соотв.индексу.

        ▪ Для чего Vue использует key
          - В качестве уникального ID элемента внутри соответствующего v-for.
          - Key позволяет Vue отслеживать идентичность каждого элемента.
          - Что позволяет переиспользовать и перемещать существующие эл-ты.
          - Вообще, механизм key является общим идентификационным механизмом в Vue,
            и может быть использован и в других, не связанных с v-for случаях.

      • v-for и v-if в одном элементе

        ▪ У v-for приоритет больше, чем у v-if
          - Как следствие, см.следущий пункт.

        ▪ v-if будет выполняться на каждой итерации
          - Что достаточно удобно.
          - Например, выведем только те ToDo, что ещё не выполнены:

            <li v-for="todo in todos" v-if="!todo.isComplete">
              {{ todo }}
            </li>

          - А если надо запускать сам цикл по условию,
            придётся поставить v-if на внешний элемент:

            <ul v-if="shouldRenderTodos">
              <li v-for="todo in todos">
                {{ todo }}
              </li>
            </ul>  

    ▪ Принимает
      - Array | Object | number | string

    ▪ Пример
      
      ▪ Простейший пример
        - Есть у нас в модели св-во items, содержащее массив объектов.
        - У каждого объекта в массиве есть св-во text.
        - Это выражение выведет N блоков div, с текстом из всех объектов,
          где N, это длина массива items:

            <div v-for="item in items">
              {{ item.text }}
            </div>      

      ▪ Как указать key для каждого отрендеренного эл-та
        - Начиная с v2.2.0 key теперь обязателен при использовании с v-for.
        - Он должен быть уникален внутри данного v-for.
        - Вот, как его надо указывать:

          <div v-for="item in items" :key="item.id">
            {{ item.text }}
          </div>  

      ▪ Доступ к значению/ключу/индексу

          <div v-for="(item, index) in items"></div>
          <div v-for="(val, key) in object"></div>
          <div v-for="(val, key, index) in object"></div>          

  • v-on / @

    ▪ Описание

      ▪ Общее описание
        - Добавляет элементу обработчик указанного DOM/кастомного события.
        - Тип события указывается в параметре event.
        - Выражение м.б. именем метода, inline-выражением,
          или отсутствовать, если указаны >= 1 модификаторов.

      ▪ Родные и кастомные события
        - Обычный DOM-элемент можно подписать лишь на родные DOM-события.
        - А vue-компонент, ещё и на кастомные (пользовательские) события,
          возбуждаемые дочерним элементом.

      ▪ Как получит объект-событие DOM (для родных событий)
        - Обработчик получает его единственным/первым аргументом.
        - В inline выражениях доступ к нему можно получить с помощью $event:

            v-on:click="handle('ok', $event)"

    ▪ Принимает
      - Function | Inline-выражение

    ▪ Параметры
      
      ▪ :event   | [обязательный] С каким событием связать обработчик

    ▪ Модификаторы

      ▪ .stop                 | Остановить всплытие события
      ▪ .prevent              | Предотвратить действия браузера по умолчанию
      ▪ .capture              | Обработчик сработает на стадии перехвата события
      ▪ .self                 | Вызовет обработчик только если событие возникло непосредственно на этом элементе
      ▪ .{keyCode | keyAlias} | Вызывает обработчик только при нажатии определённой клавиши
      ▪ .native               | Обрабатывать лишь события из системы событий браузера (а не оной Vue)
      ▪ .once                 | Вызвать обработчик не более 1-го раза
      ▪ .left                 | Вызвать обработчик только по событию нажатию левой кнопки мыши
      ▪ .right                | Вызвать обработчик только по событию нажатию правой кнопки мыши
      ▪ .middle               | Вызвать обработчик только по событию нажатию средней кнопки мыши
      ▪ .passive              | Вызвать обработчик события DOM с опцией 

    ▪ Пример
      
      ▪ Подписки на родные события DOM

        <!-- обработчик метода -->
        <button v-on:click="doThis"></button>

        <!-- inline-выражение -->
        <button v-on:click="doThat('hello', $event)"></button>

        <!-- сокращённая запись -->
        <button @click="doThis"></button>

        <!-- модификатор stop propagation -->
        <button @click.stop="doThis"></button>

        <!-- модификатор prevent default -->
        <button @click.prevent="doThis"></button>

        <!-- модификатор prevent default без дополнительных действий -->
        <form @submit.prevent></form>

        <!-- цепочка из модификаторов -->
        <button @click.stop.prevent="doThis"></button>

        <!-- модификатор клавиши keyAlias -->
        <input @keyup.enter="onEnter">

        <!-- модификатор клавиши keyCode -->
        <input @keyup.13="onEnter">

        <!-- обработчик метода будет вызван не больше одного раза -->
        <button v-on:click.once="doThis"></button>      

      ▪ Подписки на пользовательские события, возбуждаемые дочерним элементом

        <my-component @my-event="handleThis"></my-component>
        
        <!-- inline-выражение -->
        <my-component @my-event="handleThis(123, $event)"></my-component>
        
        <!-- подписываемся на нативное событие в компоненте -->
        <my-component @click.native="onClick"></my-component>

  • v-bind / :

    ▪ Описание
      
      ▪ Общее описание
        - Добавить DOM-элементу атрибут; передать компоненту параметр; значение компилируется.

      ▪ Чем полезен для обычных DOM-элементов
        - Можно добавить атрибут.
        - Выражение в значении может просто дать литерал.
        - А может связать значение атрибута с наблюдаемой.
        - Например:

          <div :id="element_id"></div>
          <div :id="id_prop"></div>

      ▪ Чем полезен для компонентов
        - Как известно, параметры в компоненты передаются через атрибуты.
        - Соответственно, через v-bind на элементе компонента мы
          можем создать атрибут, т.е. передать в компонент параметр.
        - Выражение в значении может просто дать литерал.
        - А может связать значение атрибута с наблюдаемой.       
        - Подробнее читай: "А12. Компоненты" -> "Входные параметры".
        - Например:

          <child v-bind:my-message="parentMsg"></child>
          <child :my-message="parentMsg"></child>       

      ▪ Особенности работы с атрибутами class и style
        - При работе с ними поддерживает массивы и объекты в кач-ве значений.
        - Подробнее читай в главу "А7. Работа с CSS: классы и стили".

      ▪ Если аргумент не указан
        - Связанное значение м.б. объектом, содержащим пары имя-значение.
        - В этом случае атрибуты class/style не поддерживают массивы и объекты.

    ▪ Принимает
      - any (если указан параметр) | Object (если параметр не указан)

    ▪ Параметры

      ▪ attrOrProp    | [опциональный] Атрибут / Входной параметр компонента

    ▪ Модификаторы

      ▪ .prop     | Забиндить, как DOM-свойство, а не как атрибут
      ▪ .camel    | Преобразовать имя атрибута в-kebab-стиле в верблюжийСтиль
      ▪ .sync     | Синтаксический сахар, трансформируется в v-on для обновления связанного значения

    ▪ Примеры

      <!-- связывание атрибута -->
      <img v-bind:src="imageSrc">

      <!-- сокращение -->
      <img :src="imageSrc">

      <!-- поддержка конкатенации строк -->
      <img :src="'/path/to/images/' + fileName">

      <!-- связывание CSS-класса -->
      <div :class="{ red: isRed }"></div>
      <div :class="[classA, classB]"></div>
      <div :class="[classA, { classB: isB, classC: isC }]">

      <!-- связывание локального стиля -->
      <div :style="{ fontSize: size + 'px' }"></div>
      <div :style="[styleObjectA, styleObjectB]"></div>

      <!-- связывание с объектом, содержащим атрибуты -->
      <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

      <!-- связывание с атрибутами DOM при указании модификатора -->
      <div v-bind:text-content.prop="text"></div>

      <!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
      <my-component :prop="someThing"></my-component>

      <!-- передача всех входных параметров компонента в child-component -->
      <child-component v-bind="$props"></child-component>

      <!-- XLink -->
      <svg><a :xlink:special="foo"></a></svg>    
      
  • v-model

    ▪ Описание
      - Двунаправленный биндинг на эл-тах формы или компоненте.
      - Подробнее читай:

        ▪ Главу: "А11. Работа с формами".
        ▪ Главу и раздел: "А12. Компоненты" -> "Модификаторы .sync, .native; директива v-model"

    ▪ Можно использовать лишь с

      ▪ <input>
      ▪ <select>
      ▪ <textarea>
      ▪ components

    ▪ Модификаторы

      ▪ .lazy     | Слушать событие change, а не input
      ▪ .number   | Преобразовывать входящие строки в числа
      ▪ .trim     | Тримить входящую строку

    ▪ Принимает
      - Зависит

    ▪ Пример
      - 

  • v-pre

    ▪ Описание
      - Пропустить компиляцию для этого эл-та и всех его потомков.
      - Например, это можно делать, для отображения raw-кода,
        содержащего mustache-тэги (см.пример).

    ▪ Принимает
      - nothing

    ▪ Пример
      - Допустим, мы хотим вывести в span строку:
        "{{ this will not be compiled }}".
      - Прямо так, как есть, без компиляции.
      - Вот так это и можно сделать:

        <span v-pre>{{ this will not be compiled }}</span>

  • v-cloak

    ▪ Описание
      - Висит на связанном с vue-экземпляром DOM-элементе до завершения компиляции.
      - Что-то вроде индикатора, позволяющего, например, с помощью
        display: none скрывать недокомпилировавшиеся части шаблона, и т.п.
      - Я так понимаю, это актуально при компиляции "на лету".

    ▪ Принимает
      - nothing

    ▪ Примеры
      
      [v-cloak] {
        display: none;
      }

      <div v-cloak>
        {{ message }}
      </div>

  • v-once

    ▪ Описание
      - Указывает, что элемент/компонент надо рендерить лишь однажды.
      - После 1-й отрисовки, последущние процессы по отрисовке
        будут воспринимать элемент/компонент и всех его потомков,
        как статический контент.
      - Это используют для оптимизации производительности.
      - Подробнее читай: 
          "А12. Компоненты" -> 
          "Горячая замена компонентов" -> 
          "“Дешёвые” статические компоненты с использованием v-once"

    ▪ Принимает
      - nothing

    ▪ Пример

        <!-- single element -->
        <span v-once>This will never change: {{msg}}</span>

        <!-- the element have children -->
        <div v-once>
          <h1>comment</h1>
          <p>{{msg}}</p>
        </div>

        <!-- component -->
        <my-component v-once :comment="msg"></my-component>

        <!-- v-for directive -->
        <ul>
          <li v-for="i in list" v-once>{{i}}</li>
        </ul>

> Специальные атрибуты

  • key

    ▪ Принимает
      - string

    ▪ Описание
      
      ▪ Общее описание
        - Отменить стратегию "обновления на месте"; всегда заменять элемент на новый, а не переиспользовать.
        - Чаще всего используется в следующих ситуациях:

          1. Вместе с v-for
            - Использование key позволяет отменить стратегию "обновления на месте".
            - И при изменении порядка эл-в они не переиспользуются, а заменяются на новые.
            - Соотв-но, срабатываеют все lifecicle-хуки и анимации.
            - И не происходит путаницы с биндингами, когда какой-то элемент
              связан со св-вом модели, потом он переиспользуется, и там
              отображается не то, что должно.
            - См.пример.

          2. Всегда заменять элемент на новый, а не переиспользовать
            - Позволяет быть  уверенным, что все хуки жизненного цикла компонента будут вызваны.
            - Позволяет запускать соотв.аниаации (например, установленные в transition).
            - См.пример.

      ▪ Key обязателен с v-for, начиная с v2.2.0
        - Начиная с v2.2.0 key теперь обязателен при использовании с v-for.
      
      ▪ "Стратегия по умолчанию", или "обновление на месте"
        - До v2.2.0 была опция не указывать key с v-for.
        - Тогда Vue использовал стратегию "обновления на месте".
        - Например, порядок элементов массива/объекта изменился.
        - Vue не будет перемещать эл-ты DOM, а просто обновит каждый "на месте".
        - Чтобы он отображал новые данные по соотв.индексу.

      ▪ Для чего Vue использует key
        - В качестве уникального ID элемента внутри соответствующего v-for.
        - Key позволяет Vue отслеживать идентичность каждого элемента.
        - Что позволяет переиспользовать и перемещать существующие эл-ты.
        - Вообще, механизм key является общим идентификационным механизмом в Vue,
          и может быть использован и в других, не связанных с v-for случаях.

    ▪ Примеры

      ▪ Пример использования с v-for

          <ul>
            <li v-for="item in items" :key="item.id">...</li>
          </ul>

      ▪ Пример использования с целью всегда заменять элемент на новый, а не переиспользовать
        - При изменении text, <span> всегда будет заменяться
          целиком, что спровоцирует вызов анимации.

          <transition>
            <span :key="text">{{ text }}</span>
          </transition>

  • ref

    ▪ Принимает
      - string

    ▪ Описание
      
      ▪ Общее описание
        - Ключ для регистрации ссылки на DOM-элемент/экземпляр компонента/или массив оных (при исп.с v-for) в $refs.
        - В объекте $refs появится поле с ключём, равным значению этого атрибута.
        - В качестве значения будет:

          ▪ Ссылка на DOM-элемент, если ref применён к оному.
          ▪ Ссылка на экземпляр компонента, если ref применён к компоненту.
          ▪ Массив ссылок на DOM-элементы/экземпляры компонентов, если
            ref применён вместе с v-for.

      ▪ Важные замечения о том, когда эти ссылки появятся в $refs
        
        ▪ Ссылки в $refs ещё не существуют при первичном рендеринге
          - Ссылки создаются render-функцией.
          - Поэтому, их нельзя испольовать при первичном рендеринге.
          - Ведь на тот момент ссылки ещё не существуют!

        ▪ $refs не является реактивным
          - Поэтому не стоит пытаться использовать его в шаблонах для связывания данных.

    ▪ Примеры

      <!-- vm.$refs.p будет DOM-элементом -->
      <p ref="p">hello</p>

      <!-- vm.$refs.child будет указывать на экземпляр ChildComp -->
      <child-comp ref="child"></child-comp>

  • slot

    ▪ Описание
      - В слот с каким именем в шаблоне компонента запихнуть данный кусок контента внутри компонента.
      - Это имеет отношение к именованным слотам.
      - Подробнее о них читай здесь: 
        "А12. Компоненты" -> "Именные <slot>: что в слот с каким именем распихать"

    ▪ Пример

      ▪ Шаблон компонента comp: эл-в <slot> нет
        - В нём есть 3 слота.
        - Один основной (не именной, <slot></slot>).
        - И два именных, с именами name1 и name2.

          <div>
            <h2>I'm the child title</h2>
            <slot name="name1"></slot>
            <slot name="name2"></slot>
            <slot></slot>
          </div>

      ▪ Шаблон, где используется comp
        - Внутри comp есть контент.
        - С помощью атрибута slot можно указывать,
          в слот с каким именем какой контент запихивать.
        - Если атрибута slot нет, значит запихивать в основной.

          <div>
            <h1>I'm the parent title</h1>
            <comp>

              <span slot="name1">Это запихнуть в слот name1</span>
              <span slot="name2">Это запихнуть в слот name2</span>
              
              <span>А всё остальное</span>
              <span>запихнуть</span>
              <span>в основной слот</span>

            </comp>
          </div>

      ▪ Результат рендеринга
        - Весь контент распихан по указанным слотам.

          <div>
            <h2>I'm the child title</h2>

            <span slot="name1">Это запихнуть в слот name1</span>
            <span slot="name2">Это запихнуть в слот name2</span>

            <span>А всё остальное</span>
            <span>запихнуть</span>
            <span>в основной слот</span>

          </div>  

  • is

    ▪ Принимает
      - string

    ▪ Описание
      
      ▪ Общее описание
        - Подменяет DOM-элемент на указанный в значении компонент.
        - Подмена производится Vue на этапе компиляции.
        - Используется, в основном, в двух местах:

          1. Во встроенном компоненте <component>
            - Встроенный компонент-обёртка для условного рендеринга компонентов.
            - Атрибут is в нём указывает, какой компонент рендерить (имя лок.комп / ссылка на объект-определение).

          2. В обычных DOM-элементах для обхода ограничений в DOM-шаблоне
            - Vue может использовать разные источники шаблонов, один из них - DOM-шаблон.
            - У него есть ограничения, напр., внутри <table> м.б. ограниченный набор тегов.
              Подробнее об ограничениях: "А12. Компоненты" -> "Особенности парсинга DOM-шаблона".
            - Чтобы обойти ограничения, мы используем "костыль" - в DOM-шаблоне
              используем тот тег, который ожидает браузер, но ему указываем атрибут
              id, и компилятор Vue подменит этот DOM-элемент на указанный в is компонент.
            - Но лучше просто не пользоваться DOM-шаблонами, а использовать
              шаблоны в однофайловых компонентах, или inline-шаблоны.

    ▪ Примеры

      ▪ Пример использования с <component>

          <!-- a dynamic component controlled by -->
          <!-- the `componentId` property on the vm -->
          <component :is="componentId"></component>

          <!-- can also render registered component or component passed as prop -->
          <component :is="$options.components.child"></component>      

      ▪ Пример использования с DOM-элементом

          <!-- используемый компонент меняется при изменениях currentView -->
          <component v-bind:is="currentView"></component>
          
          <!-- необходим, потому что <my-row> будет считаться невалидным -->
          <!-- элементом внутри <table> и будет вынесен выше             -->
          <table>
            <tr is="my-row"></tr>
          </table>     


> Опции / данные

  • data

    ▪ Тип
      - Object | Function

    ▪ Ограничение: в компоненте data д.б. ф-ией, возвращающей объект
      - Один компонент может быть использован много раз.
      - Поэтому нельзя в конструктор передавать вещи по ссылке.
      - Проще объяснить на примере:

        ▪ Как делать НЕ ЖЕЛАТЕЛЬНО: передавать объект в data
          - В этом примере передаём объект в data.
          - Каждый экземпляр будет ссылаться именно на этот объект.
          - Т.Е. при изменении его в 1-ом, он изменится во всех экземплярах.
          - Код:

            Vue.component('my-component', {
              template: '<span>{{ message }}</span>',
              data: {
                message: 'привет!'
              }
            })        

        ▪ Как РЕКОМЕНДУЕТСЯ делать: генерировать объект в data анон.ф-ией
          - Не надо передавать в конструктор объект.
          - Надо генерировать новый объект анонимной функцией.
          - Так, у каждого экземпляра будет свой объект в data.
          - Код:

            Vue.component('my-component', {
              template: '<span>{{ message }}</span>',
              data: unction () {
                return {
                  counter: 0
                }
              }
            })  

    ▪ Описание
      
      ▪ Общее описание
        - Объект с данными корневого/компонентного vue-экземпляра.
        - Vue рекурсивно переводит его поля в геттеры/сеттеры,
          и они становятся "реактивными".

      ▪ Vue-экземпляр проксирует ссылки всех св-в из объекта data
        
        ▪ Что значит проксирует?
          - То есть, они становятся напрямую свойствами модели.
          - Вместо vm.data.prop надо писать просто vm.prop
          - Пояснение на примере:

              // Подготовим data и создаим vue-экземпляр
              var data = { a: 1 }
              var vm = new Vue({
                data: data
              })

              // Удостоверимся в написанном выше
              vm.a === data.a   // true

        ▪ Что значит проксирует ссылки?
          - Значит, что vm.a и data.a содержат одну и ту же ссылку.
          - Т.Е. меняя значение в модели, мы меняем его в исходном объекте data.
          - Примеры для иллюстрации этого:

              // установка свойства также влияет на оригинальные данные
              vm.a = 2
              data.a      // 2

              // ... и наоборот
              data.a = 3
              vm.a        // 3  

      ▪ Vue-экземпляр содержит встроенные св-ва/методы, начинающиеся с $
        - Св-ва, начинающиеся с _ или $ не проксируются.
        - С $ или _ они начинаются, чтобы отличаться от пользовательских.
        - Например, ссылка на объект data лежит в vm.$data,
          а ссылка на DOM-элемент лежит в $el,
          а коллбэк на изменение св-ва можно задать методом $watch.
        - Полный список встроенных св-в и методов см. в главе-справочнике API.
        - Проиллюстрируем на примере:

            // Подготовим data и создаим vue-экземпляр
            var data = { a: 1 }
            var vm = new Vue({
              el: '#example',
              data: data
            })

            // Собственно, иллюстрация
            vm.$data === data                             // true
            vm.$el === document.getElementById('example') // true

            // $watch — это метод экземпляра
            vm.$watch('a', function (newVal, oldVal) {
              // этот коллбэк будет вызван, когда изменится `vm.a`
            })

      ▪ Не используй стрелочные функции в св-вах экземпляра и колбэках!
        - Например: vm.$watch('a', newVal => this.myMethod())
        - Потому что СФ связываются с родительским контекстом (this).
        - Соответственно, this внутри не будет указывать на vue-экземпляр.
        - И, например, this.myMethod будет undefined.

    ▪ Как получить полную копию оригинального объекта?

        var obj = JSON.parse(JSON.stringify( vm.$data ));

    ▪ Пример

        var data = { a: 1 }

        // создаём экземпляр напрямую:
        var vm = new Vue({
          data: data
        })
        vm.a // -> 1
        vm.$data === data // -> true

        // обязательно используйте функцию во Vue.extend():
        var Component = Vue.extend({
          data: function () {
            return { a: 1 }
          }
        })

  • props

    ▪ Тип
      - Array<string> | Object

    ▪ Описание
      
      ▪ Общее описание
        - Массив/хэш ожидаемых входных параметров.
        - Подробне см.: "А12. Компоненты" -> "Входные параметры".

      ▪ Передача данных через props: родитель -> потомок

        ▪ У потомка нет доступа к моделям предков
          - Каждый экземпляр vue-компонента имеет изолированную область видимости.
          - Потомок не может прямо из своего шаблона обращаться к модели родителя.

        ▪ Опция props: передача данных из родителя в потомка
          - В опции props потомка можно разместить массив.
          - В этом массиве перечислить ожидаемые входные параметры.
          - Здесь же можно провести и валидацию (о ней ниже).

        ▪ Пример использования props без валидации

            Vue.component('child', {
              props: ['myMessage'],
              template: '<span>{{ myMessage }}</span>'
            })    

      ▪ Способы передачи входных параметров

        ▪ Через HTML-атрибут в элементе-компоненте
          - Допустим, есть у нас компонент child.
          - И есть у него в props параметр message.
          - Вот, как можно передать туда простой литерал:

            <child message="привет!"></child>

        ▪ Через v-bind связывать параметр с наблюдаемой родителя
          
          ▪ Я рекомендую пользоваться этим способом
            - Я думаю, метод через HTML-атрибут менее популярен.
            - А более популярно передавать ссылку на наблюдаемую родителя.
            - И даже, если хочешь передать литерал, всё равно.
            - Просто это более универсальный способ передачи параметров.

          ▪ Пример передачи ссылка на наблюдаемую родителя в кач-ве параметра
            - Допустим, есть у нас компонент child.
            - И есть у него в props параметр message.
            - У него есть также какой-то компонент-родитель.
            - У последнего в модели есть наблюдаемая parentMsg.
            - И мы хотим передать ссылку на parentMsg в message.
            - Сделать это можно через v-bind:

              <child v-bind:my-message="parentMsg"></child>
              <child :my-message="parentMsg"></child>         // сокращённая запись для v-bind  

      ▪ Валидация входных параметров

        ▪ Валидация определяется в опции props

          Vue.component('example', {
            props: {
              propA: Number,                // простая проверка типа (`null` означает допустимость любого типа)
              propB: [String, Number],      // несколько допустимых типов
              propC: {                      // обязательное значение строкового типа
                type: String,
                required: true
              },
              propD: {                      // число со значением по умолчанию
                type: Number,
                default: 100
              },
              propE: {                      // значения по умолчанию для объектов и массивов должны задаваться через функцию
                type: Object,
                default: function () {
                  return { message: 'привет!' }
                }
              },
              propF: {                      // пользовательская функция для валидации
                validator: function (value) {
                  return value > 10
                }
              }
            }
          })

        ▪ Опции валидации
          - default     | задать значение по умолчанию
          - type        | валидация типа значения
          - validator   | пользовательская функция-валидатор
          - required    | обязательное значение

        ▪ Доступные значения для type (все JS-типы)

          ▪ String
          ▪ Number
          ▪ Boolean
          ▪ Function
          ▪ Object
          ▪ Array
          ▪ Symbol

      ▪ Концепция однонаправленного потока данных
        
        ▪ Позволяет легче понимать структуру потоков данных в приложении
          - В knockoutjs направленность потоков данных не ограничивалась.
          - В больших приложениях это приводило к спагетти-потокам данных.
          - К хаусу, разобраться в котором мог лишь разработчик этого приложения.
          - Да и то, лишь пока не прошло слишком много времени, и он всё не забыл.
          - Многие это заметили, и родилась концепция однонаправленного потока данных.
          - Благодаря ей проще держать под контролем потоки данных приложения.
          - Даже если это чужой код, в потоках данных легко разобраться.

        ▪ Не меняй вручную значения входных параметров
          - Потому что это бессмысленно и опасно.
          - Ведь они чаще всего будут привязаны к наблюдаемым родителя.
          - И когда значение наблюдаемой изменится, значение параметра обновится.
          - Внесённые тобой изменения затрутся, и это может стать неожиданностью.

    ▪ Пример

      // простая форма записи:
      Vue.component('props-demo-simple', {
        props: ['size', 'myMessage']
      })

      // объект с указанием правил валидации:
      Vue.component('props-demo-advanced', {
        props: {
          // только проверка типа
          height: Number,
          // проверка типа и другие правила валидации
          age: {
            type: Number,
            default: 0,
            required: true,
            validator: function (value) {
              return value >= 0
            }
          }
        }
      })

  • propsData

    ▪ Тип
      - { [key: string]: any }

    ▪ Ограничения
      - Учитывается только при создании экземпляра выражением new.

    ▪ Описание
      - Параметры компонента при его создании.
      - Обычно используются для облегчения модульного тестирования.

    ▪ Пример

        var Comp = Vue.extend({
          props: ['msg'],
          template: '<div>{{ msg }}</div>'
        })
        var vm = new Comp({
          propsData: {
            msg: 'привет'
          }
        })

  • computed

    ▪ Тип
      - { [key: string]: Function | { get: Function, set: Function } }

    ▪ Описание
      - Вычисляемые свойства, которые будут подмешаны к экземпляру Vue.
      - В геттерах и сеттерах this будет указывать на экземпляр Vue.
      - Вычисляемые свойства кешируются и повторно вычисляются только 
        при изменении реактивных зависимостей.
      - Обратите внимание, что если определённая зависимость выходит 
        за область видимости экземпляра (т.е не реактивная), 
        то вычисляемое свойство не будет обновляться.
      - Подробнее см.: "А6. Вычисляемые свойства и слежение".

    ▪ Пример

      var vm = new Vue({
        data: { a: 1 },
        computed: {
          // если свойство только возвращает данные, достаточно простой функции:
          aDouble: function () {
            return this.a * 2
          },
          // свойство и возвращает, и получает данные:
          aPlus: {
            get: function () {
              return this.a + 1
            },
            set: function (v) {
              this.a = v - 1
            }
          }
        }
      })
      vm.aPlus   // -> 2
      vm.aPlus = 3
      vm.a       // -> 2
      vm.aDouble // -> 4

  • methods

    ▪ Тип
      - { [key: string]: Function }

    ▪ Описание
      - Методы, которые будут подмешаны к экземпляру Vue.
      - Вы можете запустить эти методы прямо из экземпляра VM,
        или использовать в директивах.
      - this методов указывает на экземпляр Vue.

    ▪ Пример

      var vm = new Vue({
        data: { a: 1 },
        methods: {
          plus: function () {
            this.a++
          }
        }
      })
      vm.plus()
      vm.a // 2

  • watch

    ▪ Тип
      - { [key: string]: string | Function | Object }

    ▪ Описание
      - Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении.
      - Значения также могут строками с именами методов, или объектами, содержащими дополнительные опции.
      - Экземпляр Vue вызовет $watch() соответствующий каждому ключу объекта при своём создании.
      - Подробнее о watch см.: "А6. Вычисляемые свойства и слежение" -> "Альтернатива наблюдаемым: слежение за св-ми с помощью watch".

    ▪ Пример

      var vm = new Vue({
        data: {
          a: 1,
          b: 2,
          c: 3
        },
        watch: {
          a: function (val, oldVal) {
            console.log('новое значение: %s, старое значение: %s', val, oldVal)
          },
          // строка с именем метода:
          b: 'someMethod',
          // глубокий (рекурсивный) наблюдатель:
          c: {
            handler: function (val, oldVal) { /* ... */ },
            deep: true
          }
        }
      })
      vm.a = 2 // -> новое значение: 2, старое значение: 1

> Опции / DOM

  • el

    ▪ Тип
      - string | HTMLElement

    ▪ Ограничение
      - Учитывается только при создании экземпляра выражением new.

    ▪ Описание

      ▪ Общее описание
        - Вместо какого DOM-элемента смонтировать экземпляр Vue 
          (css-селектор/ссылка; в отсутствии render/template)
        - М.Б. строковым CSS-селектором, или ссылкой на DOM-элемент.

      ▪ vm.$el
        - После монтирования экземпляра, переданный или найденный 
          по CSS-селектору элемент будет доступен в vm.$el

      ▪ Когда начнётся компиляция; m.$mount()
        - Если эта опция указана при создании экземпляра, компиляция начнётся сразу же.
        - В остальных случаях, вызовите vm.$mount(), чтобы запустить компиляцию.

      ▪ Указанный в el элемент будет заменён при компиляции
        - Он служит лишь точкой монтирования.
        - В отличии от Vue 1.x, он обязательно будет заменён DOM-ом, сгенерированным Vue. 
        - Поэтому не стоит монтировать в корневые элементы <html> или <body>.

      ▪ Когда содержимое el будет использованов в качестве шаблона?
        - В отсутствии опций: 

          ▪ render    // render-функция
          ▪ template  // inline-шаблон

    ▪ Пример

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>
        
        // 2. Подготовить шаблон
        <div id="app">
          <p>{{ message }}</p>
        </div> 

        // 3. Создать экземпляр Vue
        new Vue({
          el: '#app',
          data: {
            message: 'Hello Vue.js!'
          }
        })

  • template

    ▪ Тип
      - string

    ▪ Описание

      ▪ Общее описание
        - Inline-шаблон для экземпляра Vue (строка с шаблоном или #<id DOM-элемента>; в отсутствии render).
        - Этот шаблон ЗАМЕНИТ el в точке монтирования.
        - Вся существующая внутри el разметка будет уничтожена,
          если template не содержит slot'ов.

      ▪ Можно указать вместо шаблона ID DOM-элемента
        - Тогда его содержимое будет использовано в качестве шаблона.
        - Указывать надо через #, например:

            template: "#some_id"

      ▪ Безопасность
        - Не используй в кач-ве шаблона непроверенные 
          пользовательские данные.

      ▪ Если в опциях есть render, template будет проигнорирован
        - Сабж.

    ▪ Примеры

      // Создать vue-эуземпляр
      new Vue({
        template: `<div>123</div>`
      })    

      // Создать vue-компонент
      Vue.component('todo-item', {
        propнs: ['todo'],
        template: '<li>{{ todo.text }}</li>'
      })      

  • render

    ▪ Тип
      - (createElement: () => VNode) => VNode

    ▪ Описание

      ▪ Общее описание
        - Render-функция (низкоуровневая альтернатива шаблонам).
        - Render-функция получает первым аргументом метод createElement, 
          нужный для создания VNode-ов.
        - Если компонент функциональный, вторым параметром передаётся context, 
          дающий доступ к контекстным данным, так как функциональные компоненты 
          не имеют экземпляров.
        - Подробнее см.главу: "Б4. Render-функции"

      ▪ У render приоритет над template и el
        - Допустим, в конструкторе указаны все 3 опции.
        - Тогда template и el будут проигнорированы, а render использована.

    ▪ Примеры
      - См.главу "Б4. Render-функции"

  • renderError

    ▪ Тип
      - (createElement: () => VNode, error: Error) => VNode

    ▪ Ограничение
      - Работает только в режиме разработки.

    ▪ Описание
      - Обеспечивает альтернативный рендер когда render-функция по умолчанию встречает ошибку.
      - Эта ошибка будет передана в renderError в качестве второго аргумента.
      - Это особенно полезно при использовании вместе с горячей перезагрузкой модулей.

    ▪ Пример
      - Это демонстративный пример.
      - В нём мы в render специально возбуждаем ошибку.
      - А в renderError получаем сведения о ней 2-ым аргументом,
        и рендерим их.
      - Код:

          new Vue({
            render (h) {
              throw new Error('oops')
            },
            renderError (h, err) {
              return h('pre', { style: { color: 'red' }}, err.stack)
            }
          }).$mount('#app')    

> Опции / хуки жизненного цикла

  • Общая информация о хуках жизненного цикла
    
    ▪ Хуки жизненного цикла
      - Хук, это синоним обработчика событий.
      - В процессе жизненного цикла экземпляр возбуждает события.
      - Можно привязывать к этим событиям хуки.
      - Хуки позволяют расширить или изменить стандартное поведение на пользовательское.
      - Подробнее о хуках жизненного цикла экземпляра см.:
        "А4. Экземпляр Vue" -> "Хуки жизненного цикла экземпляра"

    ▪ Контекст this хуков
      - Указывает на экземпляр Vue.
      - Не следует использовать стрелочные функции при
        назначении хуков, т.к. this тогда не будет указывать
        на экземпляр Vue (с.ф. связываются с родит.контекстом).

    ▪ Диаграмма жизненного цикла vue-экземпляра

                  
                           new Vue()
                              |
       [событие] beforeCreate |
                              |
                         Observe Data 
                              |
            [событие] created |
                              | 
                          Init Events
                              |                  
                              |                  
                              |                  
                      Есть ли опция "el"? -------
                              |                 |
                           Да |                 | - Vue ждёт, пока vm.$mount(el) будет вызвана вручную
                              |                 |
                    Есть ли опция "template"?----
                              |
                              |
                 ---------------------------
              Да |                         | Нет
                 |                         | 
          Скомпилировать             Взять outerHTML
          этот template              в качестве шаблона,
                 |                   и скомпилировать его
                 |                         |
                 ---------------------------
                              |
        [событие] beforeMount |
                              |
                       Создать vm.$el и
                       заменить содержимое
                       el скомпилированным
                              | 
            [событие] mounted | 
                              |   При изменении
                             /|\  данных
                            /   \   /------>------ 
                           / См- \ /             | - [событие] beforeUpdate            
                          / онти- \              |
                         / рованн- \        Ререндеринг
                        / ое состо- \       виртуального DOM
                        \ яние Vue- /            |
                         \ компон- /             | - [событие] updated
                          \ ента  /--------<------
                           \     /
                            \   /
                             \|/
                              |
                              |
                    Если вызван встроенный
                    метод vm.$destroy()
                              |
      [событие] beforeDestroy |
                              |
                      Завершение работы
                      вотчеров, дочерних
                      компонентов и 
                      обработчиков событий
                              | 
                              | 
                             /|\ 
                            /   \ 
                           / Ун- \ 
                          / ичто- \  
                         / женный  \ 
                        / Компонент \
                        \           /
                         \         / 
                          \       /
                           \     /
                            \   /
                             \|/ 
                              | 
          [событие] destroyed | 
                              |
                            -----

  • beforeCreate
    - Вызывается синхронно сразу после инициализации экземпляра.
    - До настройки наблюдения за данными, механизмов слежения и событий.
  
  • created
    - Вызывается синхронно сразу после создания экземпляра.
    - На этом этапе экземпляр закончил обработку опций и 
      настроил наблюдение за данными, вычисляемые свойства, 
      методы, коллбэки слежения и событий. 
    - Однако, фаза монтирования ещё не начата, и свойство 
      $el ещё не доступно.

  • beforeMount
    - Вызывается перед началом монтирования, сразу перед первым вызовом функции render.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается!

  • mounted
    - Вызывается сразу после того как экземпляр был смонтирован, а взамен el создан vm.$el
    - Если корневой экземпляр смонтирован на элемент документа, vm.$el тоже будет элементом документа.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается!

  • beforeUpdate
    - Вызывается при изменении данных, до повторного рендеринга и обновления виртуального DOM-а.
    - В этом хуке можно дополнительно изменять состояние, и это не вызовет нового повторного рендеринга.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается!

  • updated
    - Вызывается после того, как виртуальный DOM был обновлён из-за изменения данных.
    - DOM компонента будет уже обновлён к моменту вызова этого хука, 
      поэтому вы МОЖЕТЕ выполнять связанные с DOM операции здесь.
    - Тем не менее, в большинстве случаев старайтесь избегать изменения состояния в этом хуке.
    - Для реагирования на изменение состояния лучше использовать вычисляемые свойства,
      или отслеживание с помощью watch.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается! 

  • activated
    - Вызывается при активации keep-alive компонента.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается! 

  • deactivated
    - Вызывается после деактивации keep-alive компонента.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается!

  • beforeDestroy
    - Вызывается перед уничтожением экземпляра Vue.
    - На этом этапе экземпляр всё ещё полностью функционален.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается!

  • destroyed
    - Вызывается после уничтожения экземпляра Vue.
    - К моменту вызова этого хука, все директивы экземпляра Vue уже отвязаны, 
      все подписчики событий удалены, а все дочерние экземпляры Vue уничтожены.
    - ВНИМАНИЕ! При рендеринге на стороне сервера этот хук не вызывается!

> Опции / ресурсы

  • directives
    - Объект с польз.директивами, доступными экземпляру Vue.
    - Подробнее см.: "Б5. Пользовательские директивы".
    - Например:

        directives: {
          focus: {
            // определение директивы
          }
        }

  • filters
    - Объект с фильтрами, доступными экземпляру Vue.
    - Подробнее см.: 

        "А5. Синтаксис шаблонов" ->
        "Директивы" ->
        "Фильтры в интерполяциях {{ }} и директиве v-bind"

    - Например:

        new Vue({
          // ...
          filters: {
            capitalize: function (value) {
              if (!value) return ''
              value = value.toString()
              return value.charAt(0).toUpperCase() + value.slice(1)
            }
          }
        })    

  • components
    - Объект с локальными регистрациями компонентов.
    - Подробнее см.:

        "А12. Компоненты" ->
        "Использование компонентов" ->
        "Регистрация компонента" ->
        "Регистрация компонента локально (инкапсуляция)"

    - Например:

        new Vue({
          // ...
          components: {
            // <my-component> будет доступен только в шаблоне родителя
            'my-component': {
              template: '<div>Пользовательский компонент!</div>'
            }
          }
        })       

> Опции / композиция

  • parent

    ▪ Тип
      - Экземпляр Vue

    ▪ Описание

      ▪ Общее описание
        - Определяет родительский экземпляр для создаваемого.
        - Устанавливает отношение “родитель-потомок” между ними.
        - Родитель будет доступен дочернему экземпляру посредством this.$parent, 
          а дочерний экземпляр будет добавлен в массив $children родителя.

      ▪ Этот механизм на крайний случай
        - Старайтесь реже использовать $parent и $children.
        - Этот механизм мы предусмотрели на крайний случай.
        - Для общения между родителем и ребёнком лучше 
          использовать свойства и события.

  • mixins

    ▪ Тип
      - Array<Object>

    ▪ Описание
      - Массив объектов-примесей.
      - Примеси могут содержать те же опции, что и обычные объекты экземпляров Vue.
      - Они будут добавлены к основным опциям согласно логике Vue.extend().
      - Например, если и примесь и объект экземпляра содержат хук created, то будут вызваны оба.
      - Хуки примесей вызываются в порядке их определения, до вызова собственных хуков компонента.
      - Подробнее о примесях читай в главе "Б6. Примеси".

    ▪ Пример

        var mixin = {
          created: function () { console.log(1) }
        }
        var vm = new Vue({
          created: function () { console.log(2) },
          mixins: [mixin]
        })
        // -> 1
        // -> 2

  • extends

    ▪ Тип
      - Object | Function

    ▪ Описание

      ▪ Общее описание
        - Позволяет декларативно наследоваться от другого компонента, не используя Vue.extend
        - Который может быть либо простым объектом, либо конструктором.
        - Главным образом предназначено для облегчения наследования между компонентами, 
          определёнными в одном файле.

      ▪ Близка к mixins
        - Эта функциональность близка к mixins.
        - С той разницей, что собственные опции компонента 
          приоритетнее опций компонента, от которого происходит наследование.

    ▪ Пример

        var CompA = { ... }
        // наследуем от CompA, не вызывая Vue.extend:
        var CompB = {
          extends: CompA,
          ...
        }

  • provide / inject

    ▪ Тип
      - provide: Object | () => Object
      - inject: Array<string> | { [key: string]: string | Symbol }

    ▪ Описание
      
      ▪ Общее описание
        - Нужны компоненту для внедрения зависимостей в любого потомка.
        - Независимо от того, насколько глубоко в иерархии оный потомок находится.
        - Если вы знакомы с React, это очень похоже на функцию контекста.

      ▪ Опция provide
        - Должна быть объектом или ф-ей, возвращающей объект.
        - Объект должен содержать св-ва, которые будут доступны
          для внедрения их в потомках.

      ▪ Опция inject
        - Должна быть массивом строк или объектом, 
          где ключи стоят для локального связывания имени,
          а значение является ключём (string / symbol)
          для поиска в доступных инъекциях.

      ▪ Привязке provide / inject не реактивны
        - Это сделано намеренно.
        - Однако, если ты передаёшь вниз отслеживаемый объект,
          свойства в нём остаются реактивными.

    ▪ Пример

      ▪ №1

        var Provider = {
          provide: {
            foo: 'bar'
          },
          // ...
        }
        var Child = {
          inject: ['foo'],
          created () {
            console.log(this.foo) // -> "bar"
          }
          // ...
        }

      ▪ №2 (Vue > 2.2.1)
        - Использование внедрённого значения, значением по умолчанию для входных данных:

            const Child = {
              inject: ['foo'],
              props: {
                bar: {
                  default () {
                    return this.foo
                  }
                }
              }
            }

      ▪ #3 (Vue > 2.2.1)
        - Использование внедрённого значения в качестве данных:

            const Child = {
              inject: ['foo'],
              data () {
                return {
                  bar: this.foo
                }
              }
            }

> Опции / разное

  • name

    ▪ Тип
      - string

    ▪ Ограничение
      - Учитывается только при определении компонента

    ▪ Описание

      ▪ Общее описание
        - Название компонента (при глоб.регистрации, равно глоб-му ID компонента).
        - Позволяет компоненту рекурсивно вызывать самого себя в шаблоне.
        - При глобальной регистрации компонента с помощью Vue.component(), 
          его name автоматически выставляется равным его глобальному ID.

      ▪ Проще отлаживать
        - Компоненты с понятным name проще отлаживать из-за
          более разборчивых сообщений в консоли.
        - В Vue-devtools все безымянные компоненты довольно
          неинформативно называются <AnonymousComponent>. Указание
          имён для компонентов значительно улучшает ситуацию.

  • delimiters

    ▪ Тип
      - Array<string>

    ▪ Значение по умолчанию
      - ["{{", "}}"]

    ▪ Ограничение
      - Доступно только в полной сборке.

    ▪ Описание
      - Разделители, выделяющие текст для интерполяции.

    ▪ Пример

      // Разделители изменены на стиль строк-шаблонов в ES6
      new Vue({
        delimiters: ['${', '}']
      })

  • functional

    ▪ Тип
      - boolean

    ▪ Описание
      - Превращает компонент в функциональный, то есть не имеющий собственного состояния (data) и своего экземпляра (this).
      - Такие компоненты по сути — просто render-функция, возвращающая узлы виртуального DOM.
      - Это сильно ускоряет их рендеринг.
      - Подробнее о функциональных компонентах см.:

        "Б4. Render-функции" ->
        "Функциональные компоненты"

  • model

    ▪ Тип
      - { prop?: string, event?: string }

    ▪ Описание
      - Позволяет настроить входной параметр и событие, используемые для работы v-model.
      - По умолчанию, v-model на компоненте использует входной параметр value и событие input.
      - Но для некоторых типов полей, таких как чекбоксы и радио-кнопки, может 
        потребоваться использовать входной параметр value для других целей.
      - Использование опции model позволит избежать конфликта в таких случаях.
 
    ▪ Пример

      ▪ Компонент

          Vue.component('my-checkbox', {
            model: {
              prop: 'checked',
              event: 'change'
            },
            props: {
              // это позволит использовать входной параметр `value` для других целей
              value: String,
              // используйте `checked` в качестве параметра, который заменяет `value`
              checked: {
                type: Number,
                default: 0
              }
            },
            // ...
          })      

      ▪ Шаблон

          <my-checkbox v-model="foo" value="some value"></my-checkbox>      

      ▪ Указанное выше эквивалентно следующему

          <my-checkbox
            :checked="foo"
            @change="val => { foo = val }"
            value="some value">
          </my-checkbox>      

> Свойства экземпляра

  • vm.$data

    ▪ Тип
      - Object

    ▪ Описание
      - Объект с данными, над которым экземпляр Vue осуществляет наблюдение.
      - Экземпляр проксирует сюда вызовы своих полей. 
      - Например, vm.a будет указывать на vm.$data.a.

  • vm.$props

    ▪ Тип
      - Object

    ▪ Описание
      - Объект, предоставляющий доступ к текущим входным данным компонента.
      - Экземпляр Vue проксирует доступ к свойствам своего объекта входных данных.

  • vm.$el

    ▪ Тип
      - HTMLElement

    ▪ Описание
      - [readonly] Корневой элемент DOM, управляемый экземпляром Vue.
      - Только для чтения.

  • vm.$options

    ▪ Тип
      - Object

    ▪ Описание
      - [readonly] Опции, переданные в конструктор экземпляра Vue.
      - Только для чтения.
      - Полезно, если вы хотите передавать туда собственные опции:

          new Vue({
            customOption: 'что-нибудь',
            created: function () {
              console.log(this.$options.customOption) // -> 'что-нибудь'
            }
          })  

  • vm.$parent

    ▪ Тип
      - Экземпляр Vue

    ▪ Описание
      - [readonly] Ссылка на экземпляр родителя, если он есть у текущего экземпляра.
      - Только для чтения.

  • vm.$root

    ▪ Тип
      - Экземпляр Vue.

    ▪ Описание
      - [readonly] Корневой экземпляр Vue текущего дерева компонентов.
      - Если у экземпляра нет родителя, в этом поле будет он сам.
      - Только для чтения.

  • vm.$children

    ▪ Тип
      - Array<экземпляр Vue>

    ▪ Описание
      - [readonly] Компоненты-потомки экземпляра.
      - Только для чтения.
      - ВНИМАНИЕ! Порядок следования элементов в $children не гарантируется, 
        и этот массив не реактивен.
      - Вместо того, чтобы использовать $children для связывания данных, 
        попробуйте использовать обычный массив и директиву v-for 
        для создания дочерних компонентов, и используйте этот 
        массив как “источник истины”.

  • vm.$slots

    ▪ Тип
      - { [name: string]: ?Array<VNode> }

    ▪ Описание
      - [readonly] Используется для доступа к контенту, распределяемому слотами.
      - Только для чтения.
      - У каждого именованного слота есть соответствующее значение.
      - Например, содержимое slot="foo" попадёт в vm.$slots.foo
      - Свойство default содержит узлы, не включённые в именованные слоты.
      - Особенно полезно vm.$slots в компонентах с render-функциями.

    ▪ Пример для иллюстрации полезности vm.$slots в render-функциях

      ▪ Шаблон

        <blog-post>
          <h1 slot="header">
            Обо мне
          </h1>
          <p>Этот контент попадёт в vm.$slots.default, потому что он не в именованном слоте.</p>
          <p slot="footer">
            Copyright 2016 Evan You
          </p>
          <p>Этот контент тоже попадёт в vm.$slots.default.</p>.
        </blog-post> 

      ▪ Компонент

        Vue.component('blog-post', {
          render: function (createElement) {
            var header = this.$slots.header
            var body   = this.$slots.default
            var footer = this.$slots.footer
            return createElement('div', [
              createElement('header', header),
              createElement('main', body),
              createElement('footer', footer)
            ])
          }
        })      

  • vm.$scopedSlots

    ▪ Тип
      - { [name: string]: props => VNode | Array<VNode> }

    ▪ Описание
      - [readonly] Используется для доступа к scoped slots.
      - Только для чтения.
      - Для каждого слота, включая и слот default, объект 
        содержащий соответствующую функцию, что возвращает VNode.
      - Использование vm.$scopedSlots наиболее полезно при написании 
        компонентов с использованием render-функций.

  • vm.$refs

    ▪ Тип
      - Object

    ▪ Описание
      - [readonly] Объект, с DOM-элементами/экземплярами компонента/или массивами оных, имеющими параметр ref.
      - Только для чтения.
      - Подробнее см.:

        "Б12. Vue API" ->
        "Специальные атрибуты" ->
        "ref"

  • vm.$isServer

    ▪ Тип
      - boolean

    ▪ Описание
      - [readonly] Запущен ли данный экземпляр Vue на сервере.
      - Только для чтения.

> Методы экземпляра: данные

  • vm.$watch

    ▪ Формат
      - vm.$watch(expOrFn, callback [, options])

    ▪ Аргументы

      ▪ {string | Function} expOrFn
      ▪ {Function}          callback
      ▪ {Object}            options     // не обязательный аргумент

        ▪ {boolean} deep
        ▪ {boolean} immediate

    ▪ Возвращает
      - {Function} unwatch
      - Позволяет отменить слежение:

          // Начать слежение
          var unwatch = vm.$watch('a', cb);
          
          // Остановить слежение
          unwatch();

    ▪ Описание

      ▪ Общее описание
        - Отслеживать изменения в наблюдаемой/их, выполнять колбэк (типа computed в knockout).
        - Подробнее о watch (не путать с vm.$watch) см.: 

          "А6. Вычисляемые свойства и слежение" ->
          "Альтернатива наблюдаемым: слежение за св-ми с помощью watch"

      ▪ Аргумент expOrFn
        - Либо это путь к наблюдаемой из data, вроде: "a.b.c".
        - Либо это функция, внутри которой используются наблюдаемые из data.
          Эти наблюдаемые и будут отслеживаться.

      ▪ Аргумент callback
        - Срабатывает при изменении отслеживаемых наблюдаемых.

      ▪ Опция deep
        - Чтобы слежение реагировало на изменения во вложенных объектах, 
          передайте deep: true в объекте параметров.
        - Обратите внимание, что для наблюдения за изменениями массивов этого не требуется.
        - Пример:

            vm.$watch('someObject', callback, {
              deep: true
            })
            vm.someObject.nestedValue = 123
            // вызывается callback        

      ▪ Опция immediate
        - Если передано immediate: true, коллбэк будет вызван 
          сразу же после начала наблюдения с текущим значением выражения.
        - Пример:

            vm.$watch('a', callback, {
              immediate: true
            })
            // callback вызывается сразу, с текущим значением `a`

    ▪ Пример

      // Следим за переменной, указанной путём:
      var unwatch1 = vm.$watch('a.b.c', function (newVal, oldVal) {
        // переменная изменилась, сделайте что-нибудь
      })

      // Следим за функцией:
      var unwatch2 = vm.$watch(
        function () {
          return this.a + this.b
        },
        function (newVal, oldVal) {
          // значение функции изменилось, сделайте что-нибудь
        }
      )

      // Останавливаем слежение
      unwatch1();
      unwatch2();

  • vm.$set

    ▪ Формат
      - vm.$set(target, key, value)

    ▪ Аргументы

      ▪ {Object | Array}  target
      ▪ {string | number} key
      ▪ {any}             value

    ▪ Возвращает
      - Установленное значение

    ▪ Описание
      - Позволяет вставлять в наблюдаемый объект/массив по ключу/индексу так, чтобы Vue заметил.
      - Актуально для массивов, т.к. если по индексу вставить без set,
        Vue не заметит изменения в массиве.
      - Псевдоним глобального метода Vue.set

  • vm.$delete

    ▪ Формат
      - vm.$delete(target, key)

    ▪ Аргументы

      ▪ {Object | Array}  target
      ▪ {string | number} key

    ▪ Описание
      - Позволяет удалять из наблюдаемого объекта/массива по ключу/индексу так, чтобы Vue заметил.
      - Псевдоним глобального метода Vue.delete
      - Вообще, в отличие от $set, $delete редко когда нужен.

> Методы экземпляра: события

  • vm.$on

    ▪ Формат
      - vm.$on(event, callback)

    ▪ Аргументы

      ▪ {string | Array<string>}  event
      ▪ {Function}                callback

    ▪ Описание
      - Подписать обработчик на польз.событие/массив польз.событий.
      - Польз.событие можно возбудить с помощью vm.$emit
      - Колбэк получит все доп.аргументы, переданные методу $on.

    ▪ Пример

      vm.$on('test', function (msg) {
        console.log(msg)
      })
      vm.$emit('test', 'привет')
      // -> "привет"

  • vm.$once 

    ▪ Формат
      - vm.$once(event, callback)

    ▪ Аргументы

      ▪ {string} event
      ▪ {Function} callback

    ▪ Описание
      - Подписать на польз.событие обработчик, который сработает лишь однажды

  • vm.$off 

    ▪ Формат
      - vm.$off([event, callback])

    ▪ Аргументы

      ▪ {string} [event]
      ▪ {Function} [callback]

    ▪ Описание
      - Удалить все или указанные подписки на польз.события.

    ▪ Примеры

      vm.$off()                   // удалить ВСЕ подписки на ВСЕ польз.события
      vm.$off('event')            // удалить ВСЕ подписки на польз.событие event
      vm.$off('event', callback)  // удалить подписку callback подписки на польз.событие event

  • vm.$emit 

    ▪ Формат
      - vm.$emit(event, [...args])

    ▪ Аргументы

      ▪ {string} event
      ▪ [...args]

    ▪ Описание
      - Возбудить польз.событие в укзанном экземпляре.
      - Все доп.указанные параметры будут переданы в обработчик.

> Методы экземпляра: жизненный цикл

  • vm.$mount

    ▪ Формат
      - vm.$mount([elementOrSelector])

    ▪ Аргументы

      ▪ {Element | string} [elementOrSelector]
      ▪ {boolean} [hydrating]

    ▪ Возвращает
      - vm, т.е. ссылку на экземпляр.

    ▪ Описание
      - Смонтировать в DOM еще не смонтированный ранее экземпляр Vue.
      - Если при создании экземпляра Vue не была указана опция el, 
        он окажется в “непримонтированном” (unmounted) состоянии,
        то есть без ассоциированного элемента DOM.
      - Если параметр elementOrSelector не указан, шаблон будет 
        отрендерен как элемент вне документа. Вы сможете затем 
        вставить такой элемент нативным интерфейсом DOM.
      - Метод возвращает сам экземпляр, чтобы вы могли вызывать 
        дополнительные методы по цепочке.

    ▪ Пример

      var MyComponent = Vue.extend({
        template: '<div>Привет!</div>'
      })

      // создаём и монтируем в #app (заменит #app):
      new MyComponent().$mount('#app')

      // другой вариант записи, делает то же самое:
      new MyComponent({ el: '#app' })
      
      // рендерим вне документа и вставляем в DOM позднее:
      var component = new MyComponent().$mount()
      document.getElementById('app').appendChild(component.$el)

  • vm.$forceUpdate

    ▪ Формат
      - vm.$forceUpdate()

    ▪ Аргументы
      - Нет.

    ▪ Описание
      - Заставляет экземпляр Vue произвести перерендеринг.
      - Обратите внимание, что этот метод затронет не все 
        дочерние компоненты, а только сам экземпляр и дочерние 
        компоненты с контентными слотами.

  • vm.$nextTick

    ▪ Формат
      - vm.$nextTick([callback])

    ▪ Аргументы

      ▪ {Function} [callback]

    ▪ Описание
      - Выполняет callback на след.тике обновления DOM (в this callback будет ссылка на этот экземпляр).
      - Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM.
      - Функция делает то же самое, что и глобальный Vue.nextTick, но кроме того 
        связывает this с текущим экземпляром в коллбэке
      - Если окружение поддерживает, и callback пуст, возвращает Promise.

    ▪ Пример

      new Vue({
        // ...
        methods: {
          // ...
          example: function () {
            // меняем данные:
            this.message = 'changed'
            // DOM ещё не обновлён
            this.$nextTick(function () {
              // теперь DOM обновлён
              // `this` указывает на текущий экземпляр
              this.doSomethingElse()
            })
          }
        }
      })

  • vm.$destroy

    ▪ Формат
      - vm.$destroy()

    ▪ Аргументы
      - Нет.

    ▪ Описание
      - Полностью уничтожает экземпляр vue model.
      - Очищает связи с другими vm, отвязывает директивы,
        отменяет все подписки на события.
      - Как правило, вам не придётся вызывать этот метод самим. 
        Лучше контролировать жизненный цикл дочерних компонентов 
        в data-driven стиле директивами v-if и v-for.

> Глобальный API

  • Vue.extend 

    ▪ Формат
      - Vue.extend(options)

    ▪ Аргументы

      ▪ {Object} options

    ▪ Описание
      
      ▪ Общее описание
        - Задать объект-конструктор по умолчанию для Vue.
        - Допустим, у нас есть какой-то компонент.
        - И нам его надо много раз создавать императивно в приложении.
        - И напрягает, что каждый раз надо передавать объект с опциями.
        - Чтобы этого не делать, можно задать объект с опциями по умолчанию.
        - Для этого надо расширить конструктор vue.
        - Например:

          // Задать опции по умолчанию для компонента, расширив его конструктор
          var MyComponent = Vue.extend({
            // опции компонента
          })    

          // Теперь все экземпляры этого компонента используют опции по умолчанию
          var myComponentInstance = new MyComponent()        

      ▪ data должно быть функцией
        - ВНИМАНИЕ! У объекта, переданного в Vue.extend() свойство data 
          должно быть функцией.

    ▪ Пример

      ▪ Шаблон

        <div id="mount-point"></div>

      ▪ Создание конструктора и экземпляра

        // Создание конструктора
        var Profile = Vue.extend({
          template: '<p>{{firstName}} {{lastName}}, также известный как {{alias}}</p>',
          data: function () {
            return {
              firstName: 'Уолтер',
              lastName: 'Уайт',
              alias: 'Гейзенберг'
            }
          }
        })

        // создаёт экземпляр Profile и монтирует его к элементу DOM
        new Profile().$mount('#mount-point')      

      ▪ Результат

        <p>Уолтер Уайт, также известный как Гейзенберг</p>

  • Vue.nextTick 

    ▪ Формат
      - Vue.nextTick([callback, context])

    ▪ Аргументы

      ▪ {Function} [callback]
      ▪ {Object} [context]

    ▪ Описание
      - Выполнить callback на следующем тике обновления DOM.
      - Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM.
      - Если окружение поддерживает, и callback пуст, возвращает Promise.

    ▪ Пример
          
      // изменение данных
      vm.msg = 'Привет'

      // DOM ещё не обновлён
      Vue.nextTick(function () {
        // теперь DOM обновлён
      })    
 
  • Vue.set 

    ▪ Формат
      - Vue.set(target, key, value)

    ▪ Аргументы

      ▪ {Object | Array} target
      ▪ {string | number} key
      ▪ {any} value

    ▪ Возвращает
      - Установленное значение

    ▪ Описание
      - Позволяет вставлять в наблюдаемый объект/массив по ключу/индексу так, чтобы Vue заметил.
      - Актуально для массивов, т.к. если по индексу вставить без set,
        Vue не заметит изменения в массиве.
      - Псевдоним локального метода vm.$set

    ▪ Внимание!
      - Объект не может быть экземпляром Vue или корневым 
        объектом data экземпляра Vue.
    
      
  • Vue.delete 

    ▪ Формат
      - Vue.delete(target, key)

    ▪ Аргументы

      ▪ {Object| Array} target
      ▪ {string | number} key

    ▪ Описание
      - Позволяет удалять из наблюдаемого объекта/массива по ключу/индексу так, чтобы Vue заметил.
      - Псевдоним локального метода vm.$delete
      - Вообще, в отличие от set, delete редко когда нужен.

    ▪ Внимание!
      - Объект target не может быть экземпляром Vue,
        или корневым объектом данных экземпляра Vue.
   
  • Vue.directive 

    ▪ Формат
      - Vue.directive(id, [definition])

    ▪ Аргументы

      ▪ {string} id
      ▪ {Function | Object} [definition]

    ▪ Описание
      - Регистрирует новую глобальную польз.директиву или возвращает уже зарегистрированную.
      - Подробнее читай: "Б5. Пользовательские директивы".

    ▪ Пример
    
      // регистрируем директиву-объект:
      Vue.directive('my-directive', {
        bind: function () {},
        inserted: function () {},
        update: function () {},
        componentUpdated: function () {},
        unbind: function () {}
      })

      // региструем директиву в виде простой функции:
      Vue.directive('my-directive', function () {
        // Vue будет вызывать эту функцию как `bind` и `update`
      })
      
      // получаем определение директивы, если она зарегистрирована:
      var myDirective = Vue.directive('my-directive')    

  • Vue.filter 

    ▪ Формат
      - Vue.filter(id, [definition])

    ▪ Аргументы

      ▪ {string} id
      ▪ {Function} [definition]

    ▪ Описание
      - Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.
      - Подробнее про фильтры см.: 

        "А5. Синтаксис шаблонов" ->
        "Директивы" ->
        "Фильтры в интерполяциях {{ }} и директиве v-bind"

    ▪ Пример

      // регистрируем фильтр:
      Vue.filter('my-filter', function (value) {
        // возвращаем обработанное значение
      })

      // получаем фильтр, если он зарегистрирован:
      var myFilter = Vue.filter('my-filter')    
    
   
  • Vue.component 

    ▪ Формат
      - Vue.component(id, [definition])

    ▪ Аргументы

      ▪ {string} id
      ▪ {Function | Object} [definition]

    ▪ Описание
      - Регистрирует новый глобальный компонент или возвращает уже зарегистрированный.
      - Регистрация также автоматически установит свойство name компонента равным переданному id.
      - Подробнее о компонентах см.: "А12. Компоненты".

    ▪ Пример
    
      // регистрируем конструктор, полученный из Vue.extend:
      Vue.component('my-component', Vue.extend({ /* ... */ }))
      
      // регистрируем объект с опциями (Vue вызовет для этого объекта Vue.extend автоматически):
      Vue.component('my-component', { /* ... */ })
      
      // получаем зарегистрированный компонент (всегда вернёт конструктор):
      var MyComponent = Vue.component('my-component')    

  • Vue.use 

    ▪ Формат
      - Vue.use(plugin)

    ▪ Аргументы

      ▪ {Object | Function} plugin

    ▪ Описание
      - Устанавливает плагин в Vue.
      - Если плагин — объект, у него должен быть публичный метод install.
      - Если плагин — функция, она будет воспринята как метод install.
      - Этот метод будет выполнен с Vue в качестве аргумента.
      - Плагин будет установлен только один раз, независимо от количества 
        вызовов этого метода с одним и тем же плагином.
      - Подробнее о плагинах см.: "Б7. Плагины".

  • Vue.mixin 

    ▪ Формат
      - Vue.mixin(mixin)

    ▪ Аргументы

      ▪ {Object} mixin

    ▪ Описание
      - Применяет примесь ко всем будущим экземплярам Vue.
      - Так авторы плагинов могут встроить желаемое поведение в компоненты.
      - Не рекомендуется использовать в коде приложений.
      - Подробнее о примесях см.: "Б6. Примеси".
    
  • Vue.compile 

    ▪ Формат
      - Vue.compile(template)

    ▪ Аргументы

      ▪ {string} template

    ▪ Описание
      - Компилирует inline-шаблон в render-функцию.
      - Доступен только в полной сборке.

    ▪ Пример
    
        var res = Vue.compile('<div><span>{{ msg }}</span></div>')
        new Vue({
          data: {
            msg: 'hello'
          },
          render: res.render,
          staticRenderFns: res.staticRenderFns
        })    
  
  • Vue.version 

    ▪ Формат
      - Vue.version 

    ▪ Аргументы
      - Нет.

    ▪ Описание
      - Возвращает версию используемого Vue в виде строки.
      - Это может быть полезно при разработке плагинов и компонентов, 
        где вы могли бы использовать различные стратегии для работы с разными версиями.

    ▪ Пример
    
      var version = Number(Vue.version.split('.')[0])
      if (version === 2) {
        // Vue v2.x.x
      } else if (version === 1) {
        // Vue v1.x.x
      } else {
        // Неподдерживамые версии Vue
      }    

> Глобальный конфиг

  • Про глобальный конфиг Vue.config
    - Vue.config — это объект, содержащий глобальные параметры Vue.
    - Перед загрузкой приложения можно изменить указанные ниже свойства.

  • silent

    ▪ Тип
      - boolean

    ▪ По умолчанию
      - false

    ▪ Описание
      - Отключает вывод логов и предупреждений Vue.
      - Пример:

          Vue.config.silent = true

  • optionMergeStrategies

    ▪ Тип
      - { [key: string]: Function }

    ▪ По умолчанию
      - {}

    ▪ Описание
      - Меняет стратегию слияния опций на вашу собственную.
      - Стратегия слияния получает значения опции родительского 
        и дочернего элемента первым и вторым параметром соответственно.
      - Третьим параметром передаётся контекст действующего экземпляра Vue.
      - Подробнее о стратегии слияния опций см.:

        "Б6. Примеси" ->
        "Стратегии слияние опций (собственных и примесей)"

    ▪ Пример

      Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
        return child + 1
      }
      const Profile = Vue.extend({
        _my_option: 1
      })
      // Profile.options._my_option = 2    

  • devtools

    ▪ Тип
      - boolean

    ▪ По умолчанию
      - true (false в production-сборках)

    ▪ Описание
      - Указывает, должен ли Vue позволять Vue-devtools проводить инспекцию. 
      - Значение по умолчанию для development-окружения — true, для production-сборок — false.
      - Установите true, чтобы vue-devtools работал и в production.
      - Пример:

        // убедитесь, что устанавливаете это свойство синхронно сразу после загрузки Vue
        Vue.config.devtools = true      

  • errorHandler

    ▪ Тип
      - Function

    ▪ По умолчанию
      - undefined

    ▪ Описание
      - Устанавливает обработчик для ошибок, не пойманных во время рендеринга компонентов и в наблюдателях.
      - Обработчик получит в параметрах ошибку и действующий экземпляр Vue.
      - В версии 2.2.0, этот хук также отслеживает ошибки в хуках жизненного цикла компонентов.
      - Кроме того, при установленном значении undefined захваченные ошибки будут зарегистрированы 
        с помощью console.error вместо вызова сбоя приложения.

    ▪ Пример

        Vue.config.errorHandler = function (err, vm, info) {
          // обработка ошибки
          // `info` это информация Vue-специфичной ошибки, например в каком хуке жизненного цикла
          // была найдена ошибка. Доступно только в версиях 2.2.0+
        }      

  • ignoredElements

    ▪ Тип
      - Array<string>

    ▪ По умолчанию
      - []

    ▪ Описание
      - Позволяет Vue игнорировать пользовательские компоненты, установленные за пределами Vue (например, используя Web Components API).
      - Иначе возникнет предупреждение о "Неизвестном пользовательском элементе".
      - Означающее, что вы забыли зарегистрировать глобальный компонент или допустили ошибку в написании имени компонента.

    ▪ Пример

        Vue.config.ignoredElements = [
          'my-custom-web-component', 'another-web-component'
        ]    

  • keyCodes

    ▪ Тип
      - { [key: string]: number | Array<number> }

    ▪ По умолчанию
      - {}

    ▪ Описание
      - Определение пользовательских псевдонимов для директивы v-on.

    ▪ Пример

        Vue.config.keyCodes = {
          v: 86,
          f1: 112,
          // camelCase не будет работать
          mediaPlayPause: 179,
          // можно использовать kebab-case в двойных кавычках
         "media-play-pause": 179,
          up: [38, 87]
        }    

        <input type="text" @keyup.media-play-pause="method">

  • perfomance

    ▪ Тип
      - boolean

    ▪ По умолчанию
      - false

    ▪ Описание
      - Установите в true, чтобы включить отслеживание производительности на этапах инициализации, компиляции, рендера и обновления компонента на графике в инструментах разработчика браузера.
      - Работает только в режиме разработки и в браузерах, которые поддерживают performance.mark API.

  • productionTip

    ▪ Тип
      - boolean

    ▪ По умолчанию
      - true

    ▪ Описание
      - Установите в false, чтобы отключить предупреждение о работе в режиме разработки при запуске Vue.


Б13. Vuex 2.x

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение 

  # Подключение Vuex
  # Сборка последней версии вручную

  # Способы коммуникации между компонентами
    
    ▪ v-on: родительский компонент <--- дочерний компонент
      - Только родитель-дочка
      - Нельзя использовать $on, нет доступа к модели дочки
      - Надо использовать v-on, на примере

    ▪ Через вспомогательный vue-экземпляр: связь для не-родственников
      - Подходит для простых приложений
      - Подходит для связи между любыми компонентами
      - Принцип связи: через вспомогательный vue-экземпляр
      - Пример связи через вспомогательный vue-экземпляр

    ▪ Через vuex
      - Подходит для средних и крупных SPA-приложений
      - Публичная/Приватная части модели компонента
      - Что такое vuex

  # Ключевые понятия Vuex: обзор
    ▪ Vuex-хранилище: ц.хаб для общения компонентов
    ▪ Геттеры: аналог computed
    ▪ Мутации: синх.операции с хранилищем
    ▪ Действия: синх./асинх.операции с хранилищем
    ▪ Модули: борьба с разрастанием хранилища

  # Зачем нужен Vuex
    ▪ Про принцип относительной изоляции компонентов
    ▪ Проблема взаимодействия компонентов, не являющихся родителем-дочкой
    ▪ Использование вспомогательного vue-экземпляра, как общего хаба событий
    ▪ Учёт и систематизация лапша-стайл связей с помощью vuex

  # Ключевые понятия Vuex: подробности и использование

    • Vuex-хранилище
      ▪ Хранилище в центре vuex-приложения
      ▪ Два отличия vuex-хранилища от обычного глобального объекта
      ▪ Пример простейшего vuex-хранилища
      ▪ Пример простейшего vuex-приложения, реализующий счётчик

    • Состояние
      ▪ Единое дерево состояния
      ▪ Передача ссылки на хранилище/его свойства компонентам дерева
        ▪ Способ №1 (не оптимальный): вычисляемые свойства
        ▪ Способ №2 (наш выбор): опция store со ссылкой на хранилище      
      ▪ Ф-ия mapState: автоген.computed в ком-те для исп-ех св-в из хранилища
      ▪ Локальное и глобальное состояния компонентов

    • Геттеры
      ▪ Геттеры в хранилище, как аналог computed в модели компонента
      ▪ Ф-ия mapGetters: автоген.computed в ком-те для исп-ех св-в из хранилища

    • Мутации
      ▪ Мутации: единственный способ писать в vuex-хранилище
      ▪ Применение мутаций: функция store.commit; её синтаксис
        ▪ commit(mutation)
        ▪ commit(mutation, payload)
        ▪ commit({type: mutation, ...})
      ▪ Реактивность и мутации
      ▪ Использование констант для названий мутаций
      ▪ Мутации обязаны синхронными
      ▪ Вызов мутаций из кода компонентов
      ▪ Мутации и действия

    • Действия
      ▪ Действия: синх./асинх. операции и применение мутаций
      ▪ Применение действий: функция store.dispatch; её синтаксис
        ▪ dispatch(action)
        ▪ dispatch(mutation, payload)
        ▪ dispatch({type: mutation, ...})
      ▪ Более близкий к реальности пример действия
      ▪ Вызов действий из кода компонентов
      ▪ Ф-ия mapActions: автоген.methods в ком-те для действий из хранилища
      ▪ Использовать async/await и promise с действиями

    • Модули
      ▪ Vuex-хранилище можно разбить на модули
      ▪ Каждый модуль можно положить в отдельный файл
      ▪ Фрактальная структура: state/mutations/actions/getters в каждом модуле
      ▪ Локальное состояние модуля; корневое состояние vuex-хранилища
      ▪ Пространстова имён модулей
        ▪ По умолчанию, глобальное
        ▪ Локальное пр.имён, основанное на пути к модулю
        ▪ Наличие локального пр.имён не влияет на код внутри модуля
        ▪ Доступ к глобальным М/Д/Г из модуля с локальным пр.имён
        ▪ Подключение модуля с лок.пр.имён к компоненту
        ▪ Замечание для разработчиков плагинов
        ▪ Регистрация модуля уже после создания vue-хранилища
        ▪ Плагины могут использовать vuex для себя
        ▪ Можно удалить динамически зарегистрированный модуль
        ▪ Повторное использование модулей

  # Ограничения на структуру приложения
  # Vuex-плагины
    ▪ Vuex-плагин, как хук для мутаций
    ▪ Пример применения плагина: синхронизация с сервером
    ▪ Как снять снэпшот состояния хранилища?

  # Режим работы Vuex в strict mode; обработка форм
    ▪ Строгий режим разрешает изменение хранилища лишь мутациями
    ▪ Включить строгий режим можно опцией strict: true
    ▪ Не используй strict mode в production, это медленно!
    ▪ Проблемы с v-model в strict mode; используй 2-сторонний computed
      ▪ В чём состоит проблема?
      ▪ Решение проблемы, способы имитации работы v-model
        ▪ №1: мапим св-во и мутатор в локальну модель
        ▪ №2: используем 2-сторонний computed

--------------------------------------

> Ссылки

  # Официальная документация Vuex 2.x
      https://vuex.vuejs.org/ru/

> Введение
  - В этой главе описана работа с Vuex v2.x

> Подключение Vuex

  ▪ Скачать или использовать CDN
    - И подключить после vue:

        <script src="/path/to/vue.js"></script>
        <script src="/path/to/vuex.js"></script>

  ▪ Установить через NPM
    - С помощью install:

        npm install vuex --save

> Сборка последней версии вручную
  - Можно качнуть последнюю версию с github.
  - И сделать свою сборку.
  - Т.О. можно использовать самую последнюю версию Vuex.
  - Примерно так это делается:

      git clone https://github.com/vuejs/vuex.git node_modules/vuex
      cd node_modules/vuex
      npm install
      npm run build 

> Способы коммуникации между компонентами

  • v-on: родительский компонент <--- дочерний компонент
    
    ▪ Только родитель-дочка
      - Этот способ только для связки родительский-дочерний компоненты.
      - Не надо путать это с "предок-потомок". Только для "родитель-дочка".
    
    ▪ Нельзя использовать $on, нет доступа к модели дочки
      - Дочерний компонент может возбуждать кастомные события.
      - Родительский компонент может обрабатывать эти события.
      - Но использовать $on прямо он не может (нет доступа к модели).
    
    ▪ Надо использовать v-on, на примере
      - Поэтому, он должен использовать v-on.
      - Пример:

      ▪ Шаблон

        <div id="counter-event-example">
          <p>{{ total }}</p>
          <button-counter v-on:increment="incrementTotal"></button-counter>
          <button-counter v-on:increment="incrementTotal"></button-counter>
        </div>      

      ▪ Компонент

        Vue.component('button-counter', {
          template: '<button v-on:click="increment">{{ counter }}</button>',
          data: function () {
            return {
              counter: 0
            }
          },
          methods: {
            increment: function () {
              this.counter += 1
              this.$emit('increment')
            }
          },
        })

      ▪ Модель

        new Vue({
          el: '#counter-event-example',
          data: {
            total: 0
          },
          methods: {
            incrementTotal: function () {
              this.total += 1
            }
          }
        })      

  • Через вспомогательный vue-экземпляр: связь для не-родственников

    ▪ Подходит для простых приложений
      - А для более сложных авторы советуют vuex.

    ▪ Подходит для связи между любыми компонентами
      - В том числе, и между родителем-дочкой.
      - Но для последних лучше использовать v-on.

    ▪ Принцип связи: через вспомогательный vue-экземпляр
      - Где-то создаём вспомогательные vue-экземпляр.
      - И прямо на нём применяем методы $on и $emit.
      - И пускаем поток данных между ком-ми через экземпляр.

    ▪ Пример связи через вспомогательный vue-экземпляр

        var bus = new Vue()                     // Создаём вспомогательный vue-экземпляр
        bus.$emit('id-selected', 1)             // В методе компонента А
        bus.$on('id-selected', function (id) {  // В хуке created метода B
          // ...
        })

  • Через vuex

    ▪ Подходит для средних и крупных SPA-приложений
      - Хотя никто не запрещает использовать подход и для простых.
      - Но в этом случае накладные расходы могут себя не окупать.
      - Хотя, с точки зрения универсальности, лучше всегда задействовать vuex.

    ▪ Публичная/Приватная части модели компонента
      - Концепция vuex подразумевает следующее.
      - Мы делим модель компонента на публичную/приватную.
      - Публичная часть выносится в объект-хранилище vuex.
      - С публичной частью может взаимодействовать любой компонент.

    ▪ Что такое vuex
      - Либа для управления централизованным хранилищем 
        публичных моделей компонентов приложения.
      - Одновременно, термином vuex называют и соответствующий паттерн.
      - Поддерживает продвинутый функционал, такой как:

        ▪ Техника отладки "машина времени" из коробки
        ▪ Экспрорт/Импорт снэпшотов

> Ключевые понятия Vuex: обзор
  
  • Vuex-хранилище: ц.хаб для общения компонентов
    - Создаём vuex-хранилище. Оно всегда должно быть одно во всём документе.
    - В конструкторе vue-экземпляра указываем св-во store.
      Тогда в $store экземпляра и каждого компонента во всём
      дереве будет лежать ссылка на созданное vuex-хранилище.
    - Публичную часть моделей компонентов помещаем в vuex-хранилище,
      а приватную оставляем в модулях компонентов. 

  • Геттеры: аналог computed
    - Это аналог computed для хранилища.
    - Хранятся в объекте getters хранилища, либо в модулях.

  • Мутации: синх.операции с хранилищем
    - Модель vuex-хранилища надо менять только через мутации.
    - Это нужно для улучшенного учёта и отладки.
    - Хранятся в объекте mutations хранилища, либо в модулях.
    - По сути, это просто функция, которая изменяет какое-то
      свойство хранилища.
    - Могут быть только синхронными.

  • Действия: синх./асинх.операции с хранилищем
    - Почти тоже, что мутации, но могут быть асинхронными.
    - Можно асинхронно что-то запросить (напр.через AJAX), получить ответ.
    - В зависимости от как.л.условий вызвать те или иные мутации.
    - Хранятся в объекте actions хранилища, либо в модулях.
    - По идее, возникает вопрос, зачем нужны мутации, и почему не 
      менять св-ва хранилища прямо в действиях? Потому что операции
      по измененияю д.б. синхронными; поэтому архитектура vuex 
      позволяет манипулировать хранилищем только через мутации.

  • Модули: борьба с разрастанием хранилища
    - В больших приложениях vuex-хранилище может стать оч.большим.
    - С помощью модулей его можно разбивать по как.л.признакам.
    - Хранятся в объекте modules хранилища.
    - Каждый модуль может иметь свои state, mutations, actions, getters;
      т.е. на лицо фракталообразная архитектура.

> Зачем нужен Vuex

  • Про принцип относительной изоляции компонентов

    ▪ Родитель -> Потомок : входные параметры
      - Родитель передаёт данные потомку с помощью входных параметров.
    
    ▪ Потомок -> Родитель : возбуждение событий
      - Потомок передаёт данные родителю, возбуждая события, который последний перехватывает.

    ▪ Принцип относительной изоляции компонентов
      - Такой подход упродает поддержку кода.
      - И потенциально облегчает повторное использование компонентов.

  • Проблема взаимодействия компонентов, не являющихся родителем-дочкой
    - Соседей, из соседних веток, или дальних родственников.
    - Реальная жизнь не идеальна, часто требуются подобные взаимодействия.
    - В knockout в связи с этим мы имели лапша-стайл связи по всему коду.
    - Код становиля трудно поддерживаемым даже для того, кто его написал.
    - Однако, в Vue потребность в лапша-стайл связях не исчезла, и появился vuex.
    
  • Использование вспомогательного vue-экземпляра, как общего хаба событий
    - В vue сизначально боролись с лапшой с помощью принципа относ.изоляции компонентов.
    - Однако, любители лапша-стайл могут организовать её с помощью вспомог.vue-экземпляра.
    - Подробнее см.выше: "Способы коммуникации между компонентами".

  • Учёт и систематизация лапша-стайл связей с помощью vuex
    - Vuex, в отличие от вспомг.vue-экземпляра, это целая продуманная система.
    - Vuex ведёт учёт и систематизацию этих связей, накладывает определённы ограничения.
    - В результате, нам труднее запутаться и забыть, что на что влияет, и легче 
      отлаживать и поддерживать код.

> Ключевые понятия Vuex: подробности и использование

  # Vuex-хранилище

    • Хранилище в центре vuex-приложения
      - В центре любого Vuex-приложения находится хранилище.
      - По сути, это контейнер, который хранит состояние приложения.

    • Два отличия vuex-хранилища от обычного глобального объекта

      1. Хранилища Vuex реактивны
        - Если компоненты Vue зависят от состояния хранилища,
          изменение состояния хранилища вызовет соответствующие
          изменения компонентов.

      2. Непосредственное изменение состояния хранилища запрещено
        - Единственный способ внести изменения явно, вызвать мутацию.

    • Пример простейшего vuex-хранилища

      ▪ Создать хранилище
        - Создадим простой хранилище, в котором есть счётчик,
          а также мутация для его инкрементации:

            // Удостоверьтесь, что вызвали Vue.use(Vuex) в коде до этого, если используете модульный сборщик

            const store = new Vuex.Store({
              state: {
                count: 0
              },
              mutations: {
                increment (state) {
                  state.count++
                }
              }
            })

      ▪ Получить доступ к объекту state хранилища
        - Выведем содержимое count:

            console.log(store.state.count) // -> 1

      ▪ Применить мутацию 
        - И инкрементировать count.
        - Заметим, что мы прямо не меняем значение count: это запрещено.
        - Поэтому, мы используем мутацию.

            store.commit('increment')
            console.log(store.state.count) // -> 1

      ▪ Как использовать state хранилища в компонентах?
        - Надо создать в компонентах соотв.вычисляемые свойсва.
        - Поскольку хранилище реактивно, всё будет работать хорошо.
        - А изменять св-ва в state хранилища можно, используя мутации.

    • Пример простейшего vuex-приложения, реализующий счётчик
 
      ▪ Ссылка на пример в jsfiddle
        - https://jsfiddle.net/n9jmu5v7/1269/

      ▪ Шаблон

        <div id="app">
          <p>{{ count }}</p>
          <p>
            <button @click="increment">+</button>
            <button @click="decrement">-</button>
          </p>
        </div>

      ▪ Vuex-хранилище

        // make sure to call Vue.use(Vuex) if using a module system

        const store = new Vuex.Store({
          state: {
            count: 0
          },
          mutations: {
            increment: state => state.count++,
            decrement: state => state.count--
          }
        })      
 
      ▪ Модель

        new Vue({
          el: '#app',
          computed: {
            count () {
              return store.state.count
            }
          },
          methods: {
            increment () {
              store.commit('increment')
            },
            decrement () {
              store.commit('decrement')
            }
          }
        })      

  # Состояние

    • Единое дерево состояния
      - Vuex использует единое дерево состояния.
      - Иначе говоря, на весь документ д.б. лишь 1-но vuex-хранилище.
      - Концепция единого дерева состояния не конфликтует с концепцией
        модульности, ведь хранилище можно разбить на подмодули.

    • Передача ссылки на хранилище/его свойства компонентам дерева

      ▪ Способ №1 (не оптимальный): вычисляемые свойства

        ▪ Суть способа №1
          - Хранилище Vuex реактивно, поэтому можно использовать computed-свойства.
          - Создаём computed в модели компонента, и там получаем св-во из хранилища.
          - Например:

              // создадим компонент-счётчик:
              const Counter = {
                template: `<div>{{ count }}</div>`,
                computed: {
                  count () {
                    return store.state.count
                  }
                }
              }

          - Любые изменение store.state.count вызовут обновление вычисляемой.
          - Что, в свою очередь, вызовет соответствующие изменения в DOM.

        ▪ Минусы способа №1
          - Во-первых, надо делать доп.работу по созданию вычисляемых,
            и засорять мусором модель компонента.
          - Во-вторых, получается, компонент начинает явно зависеть 
            от наличия соотв.свойства в хранилище, что делает наш
            код более "лапшичным".
          - Короче, лучше использовать способ №2.

      ▪ Способ №2 (наш выбор): опция store со ссылкой на хранилище
        - Передаём в конструктор vue-экземпляра опцию store без значения
          (предварительно необходимо вызвать Vue.use(Vuex)).
        - Итог, у него и всего дерева компонентов появится св-во $store.
        - В нём будет лежать ссылка на vuex-хранилище.
        - Её и можно прямо использовать для чтения св-в их хранилища
          (но не для их изменения, помним, что менять надо только через мутаторы).
        - Пример:

          ▪ Передаём опцию store в конструктор vue

              const app = new Vue({
                el: '#app',
                // указываем хранилище в опции "store", что обеспечит
                // доступ к нему также и для всех дочерних компонентов
                store,
                components: { Counter },
                template: `
                  <div class="app">
                    <counter></counter>
                  </div>
                `
              })          

          ▪ Используем $store в модели компонента

              const Counter = {
                template: `<div>{{ count }}</div>`,
                computed: {
                  count () {
                    return this.$store.state.count
                  }
                }
              }

    • Ф-ия mapState: автоген.computed в ком-те для исп-ех св-в из хранилища
      - Выше описаны 2 способа передачи ссылки на хранилище/его свойства компонентам дерева.
      - В способе №1 используются computed в модели компонента.
      - Если компонент использует много св-в или геттеров хранилища, будет напряжно
        создавать целую кучу наблюдаемых для всего этого добра. Пригодилась бы
        какая-нибудь mapping-функция.
      - Хотя, ещё раз напомним, что лучше использовать способ №2: опцию store.
      - В общем, такая mapping-функция есть, это mapState:

        ▪ Пример использования mapState

          // при использовании модульных систем, необходимо импортировать Vuex.mapState
          import { mapState } from 'vuex'

          export default {
            // ...
            computed: mapState({
              // arrow-функции позволяют писать код очень лаконично
              count: state => state.count,

              // передача строки 'count' эквивалентна записи `state => state.count`
              countAlias: 'count',

              // если требуется доступ и к локальному состоянию, нужно использовать традиционную функцию
              countPlusLocalState (state) {
                return state.count + this.localCount
              }
            })
          }

        ▪ В простых случаях, можно в mapState передавать просто массив строк

            computed: mapState([
              // проксирует через this.count доступ к store.state.count
              'count'
            ])
  
        ▪ Использование оператора распространения объектом ...
          - Функция mapState возвращает объект.
          - Но как быть, если нам нужны и локальные вычисляемые?
            Ведь, как видно в примере выше, мы подставляем mapState
            в опцию computed в модели компонента, где, вообще то,
            должны быть локальные вычисляемы.
          - Нам поможет оператор распространения объектов,
            который добавит результаты mapState в существующий
            объект:

              computed: {
                localComputed () { /* ... */ },
                // результаты работы mapState будут добавлены в уже существующий объект
                ...mapState({
                  // ...
                })
              }        

    • Локальное и глобальное состояния компонентов
      - Не обязательно, и даже вредно, всё состояние компонента
        выносить в хранилище.
      - Выносить в общем случае нужно лишь необходимый минимум.
        Хотя, это зависит от ситуации и приложения, и остаётся
        на совести разработчика.

  # Геттеры

    • Геттеры, как глобальные computed
      - В объекте computed компонента хранятся локальные computed.
      - В объекте getters vuex-хранилища хранятся глобальные computed.

    • Обоснование потребности в геттерах
      - Допустим, в хранилище хранится какой-то список.
      - И N компонентам требуется доступ к фильтрованнй версии.
      - Конечно, можно в N моделях компонентов создать одинаковые вычисляемые:

          computed: {
            doneTodosCount () {
              return this.$store.state.todos.filter(todo => todo.done).length
            }
          }

      - Но это плохо: трудно поддерживать, лишняя работа, и т.п.
      - Проще тогда создать 1-ин геттер в vuex, который все будут использовать:

          const store = new Vuex.Store({
            state: {
              todos: [
                { id: 1, text: '...', done: true },
                { id: 2, text: '...', done: false }
              ]
            },
            getters: {
              // ...
              getTodoById: (state, getters) => (id) => {
                return state.todos.find(todo => todo.id === id)
              }
            }
          }) 

    • Как получить доступ к геттерам
      - Используем геттер doneTodos: 

          store.getters.doneTodos     // [{ id: 1, text: '...', done: true }]      

    ▪ Аргументы state/getters; передача доп.аргументов в геттер
      - В геттер vuex передаёт 2 стандартных агрумента:

        ▪ state       // ссылка на vuex-хранилище
        ▪ getters     // ссылка на объект getters в vuex-хранилище
 
      - Также можно передавать пользовательские аргументы.
      - См.геттер getTodoById в примере выше.
      - Он там написан через стрелочные функции, это эквивалентно следующему:

          getters: {
            getTodoById: function(state, getters){
              return function(id){
                state.todos.find(todo => todo.id === id)
              }
            }
          }  

    ▪ Использование геттера в компонентах
      - На примере геттера getTodoById:

          store.getters.getTodoById(2)      // { id: 2, text: '...', done: false }  

    • Ф-ия mapGetters: автоген.computed в ком-те для исп-ех св-в из хранилища
      - Это аналог mapState, только для геттеров.
      - Эта функция-маппер добавляет в computed компонента указанные геттеры
        из vuex-хранилища.
      - Но, снова упомяну, что лучше просто опцией state передавать всему
        дереву компонентов ссылку на vuex-хранилище, и использовать геттеры
        напрямую обращаясь к нему.
      - Как пользоваться:

          import { mapGetters } from 'vuex'

          export default {
            // ...
            computed: {
              // примешиваем геттеры в вычисляемые свойства оператором расширения
              ...mapGetters([
                'doneTodosCount',
                'anotherGetter',
                // ...
              ])
            }
          }

      - Если хочешь изменить имена геттеров, используй объектный синтаксис:

          ...mapGetters({
            // проксируем this.doneCount в store.getters.doneTodosCount
            doneCount: 'doneTodosCount'
          })

  # Мутации

    • Мутации: единственный способ писать в vuex-хранилище
      
      ▪ Единственный способ
        - Мутации, единственный спосом менять значения св-в vuex-хранилища.
 
      ▪ Похожи на события: строковой ключ + обработчик
        - Мутации очень похожи на события.
        - У мутации есть строковой ключ, а также функция-обработчик.

      ▪ Изменение state в обработчике
        - В этом обработчике и происходит изменение состояния.
        - Которое, к слову, передаётся первым аргументом.

      ▪ Прямо функцию-мутацию вызывать нельзя
        - Вместо этого надо использовать функцию commit.
        - В неё передавать имя мутации, и доп.аргументы, если надо.
        - А commit уже вызовет функцию-обработчик мутации.
        - См.примеры ниже.

    • Применение мутаций: функция store.commit; её синтаксис

      ▪ commit(mutation)
        
        ▪ Описание
          - Это простой пример применения мутации.
          - Никаких доп.аргументов не передаётся.

        ▪ Хранилище

            const store = new Vuex.Store({
              state: {
                count: 1
              },
              mutations: {
                increment (state) {
                  // изменяем состояние
                  state.count++
                }
              }
            })

        ▪ Применение мутации

            store.commit('increment')

      ▪ commit(mutation, payload)
      
        ▪ Описание
          - Здесь демонстрируется передача доп.второго аргумента.
          - Как правило, payload - объект (но м.б. и другим типом). 

        ▪ Мутация

          ▪ Payload - число

            mutations: {
              increment (state, n) {
                state.count += n
              }
            }

          ▪ Payload - объект

            mutations: {
              increment (state, payload) {
                state.count += payload.amount
              }
            }            

        ▪ Применение мутации

          ▪ Payload - число

            store.commit('increment', 10)

          ▪ Payload - объект

            store.commit('increment', {
              amount: 10
            })            

      ▪ commit({type: mutation, ...})

        ▪ Описание
          - Здесь в commit передаётся лишь 1 аргумент - объект.
          - Имя мутации передаётся в св-ве type объекта.
          - А доп.аргументы в других св-вах объекта.

        ▪ Мутация

          mutations: {
            increment (state, payload) {
              state.count += payload.amount
            }
          }

        ▪ Применение мутации

          store.commit({
            type: 'increment',
            amount: 10
          })

    • Реактивность и мутации
      - В vuex-хранилище с реактивностью те же проблемы, что и в
        экземплярах vue/компонентов.
      - Соответственно, применяя мутации, надо иметь их в виду:

        ▪ Только изначально инициализированные св-ва станут реактивными
          - Реактивность присваивается свойствам при инициализации хранилища.
          - Добавленные обыным образом позже св-ва не будут реактивными.
          - Поэтому, все св-ва, кот-ые д.б. реактивны, лучше помещать
            в vuex-хранилище при инициализации.

        ▪ Добавить новые реактивные св-ва в хранилище можно с помощью Vue.set
          - Например: Vue.set(obj, 'newProp', 123).
          - Либо можно целиком заменить старый объект новым:

              state.obj = { ...state.obj, newProp: 123 }

    • Использование констант для названий мутаций
      - Это совершенно не обязательно. Для любителей констант.
      - Можно вынести имена всех мутаций/действий в константы.
      - И даже поместить в отдельный файл, получится типа API.
      - Говорят, это может оказаться полезным в крупных проектах.
      - Пример:

        // mutation-types.js
        export const SOME_MUTATION = 'SOME_MUTATION'

        // store.js
        import Vuex from 'vuex'
        import { SOME_MUTATION } from './mutation-types'

        const store = new Vuex.Store({
          state: { ... },
          mutations: {
            // "вычисляемые имена" из ES2015 позволяют использовать
            // константу в качестве имени функции
            [SOME_MUTATION] (state) {
              // здесь будет изменяться состояние
            }
          }
        })      

    • Мутации обязаны синхронными
      - Обработчики мутаций ОБЯЗАНЫ быть синхронными.
      - Потому что devtools должен сохранить слепки приложения
        ДО и ПОСЛЕ мутации.
      - И делает он это в момент применения мутации, никакого
        ответа, например, через AJAX дело ждать де будет.
      - Вот и получается, что сохранится неправильный слепок ПОСЛЕ.

    • Вызов мутаций из кода компонентов
      - Мутации можно вызывать в компонентах.
      - Для этого есть 2 способа:

        ▪ Обращатья напрямую к хранилищу
          - Для этого у компонента д.б. ссылка на vuex-хранилище.
          - Т.Е. в корневом vue-экземпляре, либо в экземпляре компонента
            ниже по ветке, д.б. применена опция store.
          - В целом, вызвать мутацию можно так:

              this.$store.commit('xxx')

        ▪ Проксировать мутации в методы компонента
          - С помощью mapMutations (см.ниже).

    • Ф-ия mapMutations: автоген.methods в ком-те для мутаций из хранилища
      - Это функция-маппер, аналогичная mapState/mapGetters.
      - Она проксирует указанные мутации в методы компонента.
      - Пример:

          import { mapMutations } from 'vuex'

          export default {
            // ...
            methods: {
              ...mapMutations([
                'increment', // this.increment() будет вызывать this.$store.commit('increment')

                // mapMutations также поддерживает нагрузку:
                'incrementBy' // this.incrementBy(amount) будет вызывать this.$store.commit('incrementBy', amount)
              ]),
              ...mapMutations({
                add: 'increment' // this.add() будет вызывать this.$store.commit('increment')
              })
            }
          }

    • Мутации и действия
      - По идее, возникает вопрос, зачем нужны мутации, и почему не 
        менять св-ва хранилища прямо в действиях? Потому что операции
        по измененияю д.б. синхронными; поэтому архитектура vuex 
        позволяет манипулировать хранилищем только через мутации.

          store.commit('increment')
          // все изменения состояния, вызываемые мутацией "increment",
          // к этому моменту уже должны произойти.

  # Действия

    • Действия: синх./асинх. операции и применение мутаций

      ▪ Не могут прямо менять состояние
        - Прямо менять состояния могут только мутации.
        - Действия могут менять состояние только через мутации.

      ▪ В отличии от мутаций, допускают асинхронные операции
        - Мутации не допускают асинхронных операций,
          подробне см.раздел про мутации выше.
        - Зато действия допускают асинхронные операции.

      ▪ Прямо функцию-действие вызвать нельзя
        - Вместо этого надо использовать функцию dispatch.
        - В неё передавать имя действия, и доп.аргументы, если надо.
        - А dispatch уже вызовет функцию-обработчик мутации.
        - См.примеры ниже.

    • Применение действий: функция store.dispatch; её синтаксис

      ▪ dispatch(action)

        ▪ Описание
          - Это простой пример применения действия.
          - Никаких доп.аргументов не передаётся.

        ▪ Хранилище

            const store = new Vuex.Store({
              state: {
                count: 0
              },
              mutations: {
                increment (state) {
                  state.count++
                }
              },
              actions: {
                increment (context) {
                  context.commit('increment')
                }
              }
            })        

        ▪ Применение действия  

            store.dispatch('increment')

      ▪ dispatch(mutation, payload)

        ▪ Описание
          - Это простой пример применения асинхронного действия.
          - Никаких доп.аргументов не передаётся.

        ▪ Асинхронное действие

            actions: {
              incrementAsync ({ commit }) {
                setTimeout(() => {
                  commit('increment')
                }, 1000)
              }
            }

        ▪ Применение асинхронного действия  

            store.dispatch('incrementAsync', {
              amount: 10
            })

      ▪ dispatch({type: mutation, ...})

        ▪ Применение асинхронного действия  

            store.dispatch({
              type: 'incrementAsync',
              amount: 10
            })

    • Более близкий к реальности пример действия
      - Представим, что у нас есть магазин.
      - И это действие обрабатывает покупку в нём.
      - Он содержит асинх.ajax операции.
      - Покупка может закончиться удачей или провалом.
      - В зависимости от результата мы запускаем ту или 
        иную мутацию:

          actions: {
            checkout ({ commit, state }, products) {

              // сохраним находящиеся на данный момент в корзине товары
              const savedCartItems = [...state.cart.added]

              // инициируем запрос и "оптимистично" очистим корзину
              commit(types.CHECKOUT_REQUEST)

              // предположим, что API магазина позволяет передать колбэки
              // для обработки успеха и неудачи при формировании заказа
              shop.buyProducts(
                products,
                // обработка успешного исхода
                () => commit(types.CHECKOUT_SUCCESS),
                // обработка неудачного исхода
                () => commit(types.CHECKOUT_FAILURE, savedCartItems)
              )

            }
          }        

    • Вызов действий из кода компонентов
      - Действия можно вызывать в компонентах.
      - Для этого есть 2 способа:

        ▪ Обращатья напрямую к хранилищу
          - Для этого у компонента д.б. ссылка на vuex-хранилище.
          - Т.Е. в корневом vue-экземпляре, либо в экземпляре компонента
            ниже по ветке, д.б. применена опция store.
          - В целом, вызвать мутацию можно так:

              this.$store.dispatch('xxx')

        ▪ Проксировать действия в методы компонента
          - С помощью mapActions (см.ниже).

    • Ф-ия mapActions: автоген.methods в ком-те для действий из хранилища
      - Это функция-маппер, аналогичная mapState/mapGetters/mapMutations.
      - Она проксирует указанные действия в методы компонента.
      - Пример:

          import { mapActions } from 'vuex'

          export default {
            // ...
            methods: {
              ...mapActions([
                'increment' // проксирует this.increment() в this.$store.dispatch('increment')

                // mapActions также поддерживают нагрузку (payloads):
                'incrementBy' // проксирует this.incrementBy(amount) в this.$store.dispatch('incrementBy', amount)
              ]),
              ...mapActions({
                add: 'increment' // проксирует this.add() в this.$store.dispatch('increment')
              })
            }
          }

    • Использовать async/await и promise с действиями
      - store.dispatch может вызывать несколько обработчиков 
        действий в различных модулях одновременно. 
      - В этом случае возвращаемым значением будет Promise, 
        разрешающийся после разрешения всех вызванных обработчиков.
      - Пример использования async/await и promise:

        // предположим, что getData() и getOtherData() возвращают промисы

        actions: {
          async actionA ({ commit }) {
            commit('gotData', await getData())
          },
          async actionB ({ dispatch, commit }) {
            await dispatch('actionA') // дожидаемся завершения действия actionA
            commit('gotOtherData', await getOtherData())
          }
        }

  # Модули

    • Vuex-хранилище можно разбить на модули

        const moduleA = {
          state: { ... },
          mutations: { ... },
          actions: { ... },
          getters: { ... }
        }

        const moduleB = {
          state: { ... },
          mutations: { ... },
          actions: { ... }
        }

        const store = new Vuex.Store({
          modules: {
            a: moduleA,
            b: moduleB
          }
        })

        store.state.a // -> состояние модуля moduleA
        store.state.b // -> состояние модуля moduleB

    • Каждый модуль можно положить в отдельный файл
      - А потом объединить файлы.
      - И добавить модули в объект modules хранилища.

    • Фрактальная структура: state/mutations/actions/getters в каждом модуле
      - Каждый модуль имеет всё то же самое, что хранилище.
      - И каждый модуль даже может иметь свои подмодули.
        Уровень вложенности не ограничен (вроде).

    • Локальное состояние модуля; корневое состояние vuex-хранилища
      - Мутации/действия/геттеры модуля выполняются в контексте модуля.
      - Все они 1-ым аргументом получают state, указывающий на
        локальное состояние модуля:
      
          const moduleA = {
            state: { count: 0 },
            mutations: {
              increment (state) {
                // state указывает на локальное состояние модуля
                state.count++
              }
            },

            getters: {
              doubleCount (state) {
                return state.count * 2
              }
            }
          }      

      - Состояние vuex-хранилища же передаётся 3-м аргументом:

          const moduleA = {
            // ...
            actions: {
              incrementIfOddOnRootSum ({ state, commit, rootState }) {
                if ((state.count + rootState.count) % 2 === 1) {
                  commit('increment')
                }
              }
            }
          }      

    • Пространстова имён модулей

      ▪ По умолчанию, глобальное
        - По умолчанию, все модули создаются в глобальном пр.имён.
        - Т.Е. у разных модулей имена мутаций/действий/геттеров
          не должны конфликтовать.

      ▪ Локальное пр.имён, основанное на пути к модулю
        - Можно организовать оное, используя св-во namespaced: true
        - Например:

            const store = new Vuex.Store({
              modules: {
                account: {
                  namespaced: true,

                  // содержимое модуля
                  state: { ... }, // состояние модуля автоматически вложено и не зависит от опции пространства имён
                  getters: {
                    isAdmin () { ... } // -> getters['account/isAdmin']
                  },
                  actions: {
                    login () { ... } // -> dispatch('account/login')
                  },
                  mutations: {
                    login () { ... } // -> commit('account/login')
                  },

                  // вложенные модули
                  modules: {
                    // наследует пространство имён из родительского модуля
                    myPage: {
                      state: { ... },
                      getters: {
                        profile () { ... } // -> getters['account/profile']
                      }
                    },

                    // большая вложенность с собственным пространством имён
                    posts: {
                      namespaced: true,

                      state: { ... },
                      getters: {
                        popular () { ... } // -> getters['account/posts/popular']
                      }
                    }
                  }
                }
              }
            })

      ▪ Наличие локального пр.имён не влияет на код внутри модуля
        - Внутри модуля можно обращаться в мутациям/действиям/геттерам
          этого модуля без префиксов пр.имён. Но вне модуля - только с 
          префиксами.        

      ▪ Доступ к глобальным М/Д/Г из модуля с локальным пр.имён

        ▪ Доступ к глобальным мутациям или действиям
          - Надо добавить { root: true } 3-им аргументам в commit.

        ▪ Доступ к глобальным действиям
          - Надо добавить { root: true } 3-им аргументам в dispatch.

        ▪ Доступ к глобальным геттерам
          - rootState и rootGetters передаются 3-м и 4-м аргументами в функции геттеров.
          - А также, как свойства в объекте context, передаваемом в функции действий.

        ▪ Примеры доступа к глобальным М/Д/Г из модуля с локальным пр.имён

          modules: {
            foo: {
              namespaced: true,

              getters: {
                // `getters` ограничены геттерами данного модуля
                // вы можете использовать rootGetters из 4-го аргумента геттеров
                someGetter (state, getters, rootState, rootGetters) {
                  getters.someOtherGetter // -> 'foo/someOtherGetter'
                  rootGetters.someOtherGetter // -> 'someOtherGetter'
                },
                someOtherGetter: state => { ... }
              },

              actions: {
                // dispatch и commit также ограничены данным модулем
                // они принимают опцию `root` для вызова в глобальном пространстве имён
                someAction ({ dispatch, commit, getters, rootGetters }) {
                  getters.someGetter // -> 'foo/someGetter'
                  rootGetters.someGetter // -> 'someGetter'

                  dispatch('someOtherAction') // -> 'foo/someOtherAction'
                  dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'

                  commit('someMutation') // -> 'foo/someMutation'
                  commit('someMutation', null, { root: true }) // -> 'someMutation'
                },
                someOtherAction (ctx, payload) { ... }
              }
            }
          }

      ▪ Подключение модуля с лок.пр.имён к компоненту
        - С помощью mapState, mapGetters, mapActions и mapMutations.
        - Пример (передаём строку с префиксом пр.имён 1-ым аргументом):

            computed: {
              ...mapState('some/nested/module', {
                a: state => state.a,
                b: state => state.b
              })
            },
            methods: {
              ...mapActions('some/nested/module', [
                'foo',
                'bar'
              ])
            }

      ▪ Замечание для разработчиков плагинов
        - Вас может обеспокоить непредсказуемость пространства имён для ваших модулей,
          когда вы создаёте плагин с собственными модулями и возможностью пользователям 
          добавлять их в хранилище Vuex.
        - Ваши модули будут также помещены в пространство имён, если пользователи 
          плагина добавляют ваши модули в модуль со своим пространством имён.
        - Чтобы приспособиться к этой ситуации, вам может потребоваться получить 
          значение пространства имён через настройки плагина:

            // получение значения пространства имён через options
            // и возвращение функции плагина Vuex
            export function createPlugin (options = {}) {
              return function (store) {
                // добавление пространства имён к модулям плагина
                const namespace = options.namespace || ''
                store.dispatch(namespace + 'pluginAction')
              }
            }

      ▪ Регистрация модуля уже после создания vue-хранилища
        
        ▪ Возможна, с помощью store.registerModule

            // регистрация модуля `myModule`
            store.registerModule('myModule', {
              // ...
            })

            // регистрация вложенного модуля `nested/myModule`
            store.registerModule(['nested', 'myModule'], {
              // ...
            })

        ▪ Состояние модуля будет доступно, как:

            store.state.myModule
            store.state.nested.myModule.

      ▪ Плагины могут использовать vuex для себя
        - Просто добавляя свой модуль в vuex-хранилище.
        - Например, библиотека vuex-router-sync интегрирует
          vue-router в vuex, отражая изменение текущего пути
          приложения в динамически присоединённом модуле.

      ▪ Можно удалить динамически зарегистрированный модуль
        - С помощью store.unregisterModule(moduleName).
        - ВНИМАНИЕ! Статические (существовавние на момент
          создания хранилища) модули при помощи этого
          метода удалить НЕ ПОЛУЧИТСЯ.

      ▪ Повторное использование модулей
        - Есть ситуации, когда может понадобится N экземпляров модуля.
        - Например:

          ▪ Создание нескольких хранилищ, которые используются одним модулем;
          ▪ Регистрация модуля несколько раз в одном хранилище.

        - Надо, чтобы state разных экземпляров модуля не являлся
          одной и той же ссылкой на один и тот же объект.
        - Для этого надо добавлять state через функцию:

            const MyReusableModule = {
              state () {
                return {
                  foo: 'bar'
                }
              },
              // мутации, действия, геттеры...
            }        

> Ограничения на структуру приложения
  - Vuex не накладывает ограничений на структуру.
  - Главное, должно соблюдаться 3 простых правила:

    ▪ Храни глобальное состояние в vuex-хранилище.
    ▪ Меняй глобальное состояние только мутациями,
      которые являются синхронными операциями.
    ▪ Асинхронные операции осуществляй действиями,
      или их комбинациями.
  
  - Покуда правила не нарушаешь, используй любую структуру.
  - По мере роста хранилища, можно выделять код в модули.
  - Модули можно выносить в отдельные файлы.
  - Вот пример возможной структуры проекта:

    ├── index.html
    ├── main.js
    ├── api
    │   └── ... # абстракции для выполнения запросов к API
    ├── components
    │   ├── App.vue
    │   └── ...
    └── store
        ├── index.js          # здесь мы собираем модули и экспортируем хранилище
        ├── actions.js        # корневые действия
        ├── mutations.js      # корневые мутации
        └── modules
            ├── cart.js       # модуль корзины
            └── products.js   # модуль товаров  

> Vuex-плагины

  • Vuex-плагин, как хук для мутаций
    - Vuex-плагин представляет собой простую функцию.
    - Она принимает ссылку на хранилище единственным параметром.
    - Зарегистрировать плагин можно в массиве plugins в хранилище.
    - Функция-плагин будет вызываться после каждой мутации.
    - Пример:

      ▪ Плагин

        const myPlugin = store => {
          // вызывается после инициализации хранилища
          store.subscribe((mutation, state) => {
            // вызывается после каждой мутации
            // мутация передаётся в формате { type, payload }.
          })
        }      

      ▪ Регистрация плагина в хранилище

        const store = new Vuex.Store({
          // ...
          plugins: [myPlugin]
        })

  • Пример применения плагина: синхронизация с сервером
    - В функции-плагине мы можем получить имя мутации.
    - В зависимости от имени можем выполнять те или иные действия.
    - Допустим, для мутации UPDATE_DATA можем синхронизироваться с сервером:

        export default function createWebSocketPlugin (socket) {
          return store => {
            socket.on('data', data => {
              store.commit('receiveData', data)
            })
            store.subscribe(mutation => {
              if (mutation.type === 'UPDATE_DATA') {
                socket.emit('update', mutation.payload)
              }
            })
          }
        }

        const plugin = createWebSocketPlugin(socket)

        const store = new Vuex.Store({
          state,
          mutations,
          plugins: [plugin]
        })        

  • Как снять снэпшот состояния хранилища?
    - Иногда может понадобиться снять снэпшот хранилища.
    - Это делается с помощью dash так:

        let prevState = _.cloneDeep(store.state)    

    - В плагине можно снять старое и новое состояния.
    - Чтобы потом их сравнить:

        const myPluginWithSnapshot = store => {
          let prevState = _.cloneDeep(store.state)
          store.subscribe((mutation, state) => {
            let nextState = _.cloneDeep(state)

            // сравнение prevState и nextState...

            // сохранение состояния для следующей мутации
            prevState = nextState
          })
        }

    - Операция cloneDeep медленная, не для production.
    - На production можно отключать:

        const store = new Vuex.Store({
          // ...
          plugins: process.env.NODE_ENV !== 'production'
            ? [myPluginWithSnapshot]
            : []
        })    

> Режим работы Vuex в strict mode; обработка форм

  • Строгий режим разрешает изменение хранилища лишь мутациями
    - Он гарантирует, что состояние в vuex-хранилище
      не будет изменено никаким другим способом,
      кроме как через мутации.

  • Включить строгий режим можно опцией strict: true

      const store = new Vuex.Store({
        // ...
        strict: true
      })

  • Не используй strict mode в production, это медленно!
    - Он глубоко отслеживает дерево и т.п. Оч.медленно.
    - Можно просто выключать его в production:

      const store = new Vuex.Store({
        // ...
        strict: process.env.NODE_ENV !== 'production'
      })    

  • Проблемы с v-model в strict mode; используй 2-сторонний computed

    ▪ В чём состоит проблема?
      - Strict mode разрешает менять состояние хранилища только через мутаторы.
      - А v-model, по умолчанию, будет прямо пытаться это делать.

    ▪ Решение проблемы, способы имитации работы v-model

      ▪ №1: мапим св-во и мутатор в локальну модель
        - Мапим св-во из хранилища в computed в локальной модели.
        - И мапим мутатор из хранилища в локальный метод модели.
        - Их и спользуем для имитации работы v-model:

            <input :value="message" @input="updateMessage">
            // ...
            computed: {
              ...mapState({
                message: state => state.obj.message
              })
            },
            methods: {
              updateMessage (e) {
                this.$store.commit('updateMessage', e.target.value)
              }
            }

      ▪ №2: используем 2-сторонний computed
        - В нём обращаемся к св-ву и мутатору хранилища через $state.
        - Это решение выглядит покрасивее. Код:

            <input v-model="message">
            // ...
            computed: {
              message: {
                get () {
                  return this.$store.state.obj.message
                },
                set (value) {
                  this.$store.commit('updateMessage', value)
                }
              }
            }        


Б14. Vue-router 2.x

--------------------------------------
Подоглавление:

  # Введение
  # Как лучше изучать Vue.js?

  # Простой пример применения VR
  # Параметры роутинга в URI
    ▪ Параметры роутинга, типа: "/user/:username/post/:post_id"
    ▪ Доступ к параметрам роутинга через this.$route.params
    ▪ Как получить: URL, URI, массив сегментов URI, query string, имя именованного роута
      
      ▪ $route.fullPath   | получить полный URL
      ▪ $route.path       | получить полный URI
      ▪ $route.matched    | получить массив сегментов-объектов URI
      ▪ $route.query      | получить объект с параметрами из query string
      ▪ $route.name       | получить имя именованного роута

  # Вложенные роуты
    ▪ Объект-роут может содержать вложенные роуты в children
    ▪ Вложенным роутам нужны свои точки монтирования <router-view>
    ▪ Пример объекта router с вложенными роутами
    ▪ Вложенный роут с пустым '' path
    ▪ Действующее демо примера с вложенными роутами на jsfiddle

  # Императивная навигация
    ▪ Управление навигацией из кода
    ▪ Методы императивной навигации

      ▪ router.push     | Перейти по новому URI, добавив запись в историю
      ▪ router.replace  | Перейти по новому URI, заменив текущую запись в истории новой
      ▪ router.go       | На сколько шагов перейти по истории назад (n отриц.) или вперёд (n полож.)

    ▪ Методы навигации работают одинаково во всех режимах роутера (history, hash и abstract)

  # Именованные роуты
    ▪ Роуту можно присвоить имя
    ▪ Для перехода на именованный роут используй объектную запись
      ▪ Декларативное использование именованного роута
      ▪ Императивное использование именованного роута

  # Именованные представления (<router-view>)
    ▪ Как отображать N не вложенных компонентов по одному URI?
    ▪ <router-view> без name получает имя default по умолчанию
    ▪ В объекте-роуте вместо component используй components

  # Редиректы
    ▪ Редирект на URI
    ▪ Редирект по имени именованного роута
    ▪ Динамический редирект со значением-функцией
    ▪ Пример с изощрёнными редиректами

  # Псевдонимы
    ▪ Отличие редиректа от псевдонима
    ▪ Св-во alias в объекте-роутере для настройки псевдонима
    ▪ Пример с изощрёнными псевдонимами

  # Отделение компонентов от роутинга
    ▪ 
    ▪ 
    ▪ 



--------------------------------------

> Ссылки

  # Официальная документация Vue-router 2.x
      https://router.vuejs.org/ru/

> Введение
  - В этой главе описано, как работать с Vue-router 2.x
  - Это продвинутый инструмент для организации клиентского
    роутинга в SPA-приложениях на Vue.

> Простой пример применения VR

  ▪ jsfiddle
    - http://jsfiddle.net/yyx990803/xgrjzsup/

  ▪ Шаблон
    - Обратите внимание, что <router-link> автоматически получает класс 
      .router-link-active при совпадении пути.
    - Выбранный компонент будет отображаться на месте <router-view>.

      <script src="https://unpkg.com/vue/dist/vue.js"></script>
      <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>

      <div id="app">
        <h1>Hello App!</h1>
        <p>
          <!-- используйте компонент router-link для создания ссылок -->
          <!-- входной параметр `to` определяет путь для перехода -->
          <!-- `<router-link>` по умолчанию преобразуется в тег `<a>` -->
          <router-link to="/foo">Go to Foo</router-link>
          <router-link to="/bar">Go to Bar</router-link>
        </p>
        <!-- отображение компонента, для которого совпал путь -->
        <router-view></router-view>
      </div>  

  ▪ Javascript

      // 0. При использовании модульной системы (напр. vue-cli),
      // импортируйте Vue и VueRouter и затем вызовите `Vue.use(VueRouter)`

      // 1. Определение используемых компонентов
      // Они могут быть импортированы из внешних файлов
      const Foo = { template: '<div>foo</div>' }
      const Bar = { template: '<div>bar</div>' }

      // 2. Определение путей
      // Каждый путь должен указывать на компонент
      // "Компонентом" может быть как созданный через `Vue.extend()`
      // полноценный конструктор, так и просто объект с настройками компонента
      // Вложенные пути будут рассмотрены далее.
      const routes = [
        { path: '/foo', component: Foo },
        { path: '/bar', component: Bar }
      ]

      // 3. Создаём инстанс роутера с опцией `routes`
      // Можно передать и другие опции, но пока не будем усложнять
      const router = new VueRouter({
        routes // сокращение от `routes: routes`
      })

      // 4. Создаём и монтируем корневой инстанс Vue нашего приложения.
      // Удостоверьтесь, что передали инстанс роутера в опции `router`,
      // что позволит приложению знать о его наличии
      const app = new Vue({
        router
      }).$mount('#app')

      // Всё, приложение работает! ;)  

> Параметры роутинга в URI
  
  • Параметры роутинга, типа: "/user/:username/post/:post_id"
    - Роутинг в Vue поддерживает параметры роутинга.
    - В примере в заголовке их 2, username и post_id.
    - В данном случае корневым URI является /user,
      а все URI от 2 и более сегменов считаются одним
      и тем же роутом, просто с разными параметрами.

  • Доступ к параметрам роутинга через this.$route.params
    - Экземпляр роутера доступен в св-ве модели компонента $route.
    - Оттуда мы можем получить и значения параметров роутинга.

        const User = {
          template: '<div>Пользователь {{ $route.params.id }}</div>'
        }

        const router = new VueRouter({
          routes: [
            // динамические сегменты начинаются с двоеточия
            { path: '/user/:username/post/:post_id', component: User }
          ]
        })    

    - Ещё несколько примеров шаблон/пример/параметры:

        /user/:username                       // Шаблон
        /user/evan                            // Пример
        { username: 'evan' }                  // Параметры ($route.params)

        /user/:username/post/:post_id         // Шаблон
        /user/evan/post/123                   // Пример
        { username: 'evan', post_id: 123 }    // Параметры ($route.params)

  • Как получить: URL, URI, массив сегментов URI, query string, имя именованного роута

    ▪ $route.fullPath
      - Получить полный URL.
      - Полная запись URL, включая строку запроса и хэш.

    ▪ $route.path
      - Получить полный URI.
      - Например: /foo/bar.

    ▪ $route.matched
      - Получить массив сегментов-объектов URI.
      - Например, для /foo/bar, $route.matched будет 
        массивом, содержащим копии обоих объектов,
        в порядке сортировки от родителя к потомку:

          const router = new VueRouter({
            routes: [
              // объект ниже — это запись пути
              { path: '/foo', component: Foo,
                children: [
                  // это — тоже запись пути
                  { path: 'bar', component: Bar }
                ]
              }
            ]
          })

    ▪ $route.query
      - Получить объект с параметрами из query string.
      - Например, для пути /foo?user=1 получится 
        $route.query.user == 1. При отсутствии строки 
        запроса, будет пустым объектом.

    ▪ $route.name
      - Получить имя именованного роута.
      - Если, конечно, сооветствующий роут является именованным.

> Вложенные роуты

  • Объект-роут может содержать вложенные роуты в children
    - В объекте-роуте может быть массив children.
    - Этот массив может содержать вложенные объекты-роуты.
    - Эта матрёшка может иметь сколько угодно уровней вложенности.
    - Роуты на верхнем уровне будем называть "роуты верхнего уровня".
  
  • Вложенным роутам нужны свои точки монтирования <router-view>
    - Представим такую структуру компонентов:

        /user/foo/profile                     /user/foo/posts
        +------------------+                  +-----------------+
        | User             |                  | User            |
        | +--------------+ |                  | +-------------+ |
        | | Profile      | |  +------------>  | | Posts       | |
        | |              | |                  | |             | |
        | +--------------+ |                  | +-------------+ |
        +------------------+                  +-----------------+    
  
    - Шаблон приложения выглядит так:

        <div id="app">
          <router-view></router-view>
        </div>    

    - Здесь мы видим точку монтирования верхнего уровня <router-view>.
    - Шаблон компонента User будет смонтирован вместо этого DOM-элемента.
    - Но куда будут смонтированы шаблоны дочерних для User компонентов 
      Profile и Posts?
    - Для них в шаблоне Users надо также предусмотреть точку монтирования
      <router-view>:

        const User = {
          template: `
            <div class="user">
              <h2>Пользователь {{ $route.params.id }}</h2>
              <router-view></router-view>
            </div>
          `
        }


  • Пример объекта router с вложенными роутами
    - ВНИМАНИЕ! Path, начинающийся с '/', может быть только
      у роутов верхнего уровня, и считается корневым.
    - Код:

      const router = new VueRouter({
        routes: [
          { path: '/user/:id', component: User,
            children: [
              {
                // при совпадении пути с шаблоном /user/:id/profile
                // в <router-view> компонента User будет отображён UserProfile
                path: 'profile',
                component: UserProfile
              },
              {
                // при совпадении с шаблоном /user/:id/posts
                // в <router-view> компонента User будет отображён UserPosts
                path: 'posts',
                component: UserPosts
              }
            ]
          }
        ]
      })

  • Вложенный роут с пустым '' path
    - Допустим, есть у нас роут верх.уровня с path = '/user/:id'.
    - А у него есть вложенный роут с path = ''.
    - Тогда URI, подходящий под шаблон '/user/:id', вроде '/user/12',
      приведёт к показу вложенного роута с path = ''.
    - Пример этой ситуации:

        const router = new VueRouter({
          routes: [
            {
              path: '/user/:id', component: User,
              children: [
                // при совпадении пути с шаблоном /user/:id
                // в <router-view> компонента User будет отображён UserHome
                { path: '', component: UserHome },

                // ...остальные вложенные пути
              ]
            }
          ]
        })

  • Действующее демо примера с вложенными роутами на jsfiddle
    - http://jsfiddle.net/yyx990803/L7hscd8h/

> Императивная навигация

  • Управление навигацией из кода
    - Декларативной называют навигацию через <router-link>
      в шаблоне для создания ссылок.
    - А императивной с помощью методов императивной навигации
      в JS-коде.

  • Методы императивной навигации

    ▪ router.push(location, onComplete?, onAbort?)
      
      ▪ Описание
        - Перейти по новому URI, добавив запись в историю.
        - Это позволит нажать в браузере "назад" и вернуться.
        - Доступ к роутероу из vue-экземпляра: this.$router.push
        - При клике на <router-link>, push вызывается автоматически.
        
          Декларативная запись        Императивная запись
          ---------------------------------------------
          <router-link :to="...">     router.push(...)

      ▪ Аргументы

        ▪ location      | Строка или объект, описывающие путь
        
        ▪ onComplete?   | [не обязательно] Колбэк, сработает в случае успеха (и асинх.хуки уже завершены)
        ▪ onAbort?      | [не обязательно] Колбэк, сработает в случае, если навигация будет прервана,
                                           переходом на этот же или другой роут.
 
      ▪ Примеры

        // строка
        router.push('home')

        // объект
        router.push({ path: 'home' })

        // именованный путь
        router.push({ name: 'user', params: { userId: 123 }})

        // со строкой запроса, получится /register?plan=private
        router.push({ path: 'register', query: { plan: 'private' }})

    ▪ router.replace(location, onComplete?, onAbort?)

      ▪ Описание
        - Перейти по новому URI, заменив текущую запись в истории новой.
        - Текущая запись истории будет затёрта.
        - Вернуться к ней с помощью "назад" будет нельзя.
        - Часто используется при 1-й загрузке приложения.

          Декларативная запись              Императивная запись
          -----------------------------------------------------
          <router-link :to="..." replace>   router.replace(...)  

      ▪ Аргументы
        - --//--, что и у push.

    ▪ router.go(n)
      
      ▪ Описание
        - На сколько шагов перейти по истории назад (n отриц.) или вперёд (n полож.).

      ▪ Примеры

        // перейти на одну запись вперёд, эквивалентно history.forward()
        router.go(1)

        // перейти на одну запись назад, эквивалентно history.back()
        router.go(-1)

        // перейти на 3 записи вперёд
        router.go(3)

        // если записей в истории недостаточно много, перехода просто не произойдёт
        router.go(-100)
        router.go(100)

  • Методы навигации работают одинаково во всех режимах роутера (history, hash и abstract)
    - Vue router может работать в 3-х режимах: history, hash и abstract.
    - Так вот, навигация работает одинаково во всех.

> Именованные роуты

  • Роуту можно присвоить имя
    - В объекте-роуте через св-во name можно роута задать имя.
    - Например:

        const router = new VueRouter({
          routes: [
            {
              path: '/user/:userId',
              name: 'user',
              component: User
            }
          ]
        })    

  • Для перехода на именованный роут используй объектную запись

    ▪ Декларативное использование именованного роута

      <router-link :to="{ name: 'user', params: { userId: 123 }}">Пользователь</router-link>

    ▪ Императивное использование именованного роута

      router.push({ name: 'user', params: { userId: 123 }})

> Именованные представления (<router-view>)

  • Как отображать N не вложенных компонентов по одному URI?
    - Как раз это и позволяют делать именованные <router-view>.
    - С помощью атрибута name можно давать <router-view> имя:

      <router-view class="view one"></router-view>
      <router-view class="view two" name="a"></router-view>
      <router-view class="view three" name="b"></router-view>

  • <router-view> без name получает имя default по умолчанию
    - В примере выше самый верхний <router-view> не имеет name.
    - Считай, что его имя "default".

  • В объекте-роуте вместо component используй components
    - Обычный объект-роут использует component для связи с компонентом:

      {
        path: '/user/:userId',
        name: 'user',
        component: User
      }    

    - Но мы то хотим показать сразу N компонентов для этого path.
    - Поэтому, вместо component надо использовать components.
    - В components надо передать объект, где ключ - имя именованных 
      <router-view>, а значение - ссылка на компонент:

        const router = new VueRouter({
          routes: [
            {
              path: '/',
              components: {
                default: Foo,
                a: Bar,
                b: Baz
              }
            }
          ]
        })      

> Редиректы

  • Редирект на URI

    const router = new VueRouter({
      routes: [
        { path: '/a', redirect: '/b' }
      ]
    })

  • Редирект по имени именованного роута

    const router = new VueRouter({
      routes: [
        { path: '/a', redirect: { name: 'foo' }}
      ]
    })

  • Динамический редирект со значением-функцией

    const router = new VueRouter({
      routes: [
        { path: '/a', redirect: to => {
          // в функцию в качестве аргумента передаётся путь
          // возвращаемым значением должна быть строка или объект пути
        }}
      ]
    })

  • Пример с изощрёнными редиректами
    - https://github.com/vuejs/vue-router/blob/dev/examples/redirect/app.js

> Псевдонимы
  
  • Отличие редиректа от псевдонима
    - Допустим, есть /a, и у него псевдоним /b.
    - При посещении /b URI останется равным /b.
    - Но роутер выполнинт все действия, как для /a.
    - В общем, разница понятна интуитивно.

  • Св-во alias в объекте-роутере для настройки псевдонима

    const router = new VueRouter({
      routes: [
        { path: '/a', component: A, alias: '/b' }
      ]
    })

  • Пример с изощрёнными псевдонимами
    - https://github.com/vuejs/vue-router/blob/dev/examples/route-alias/app.js

> Отделение компонентов от роутинга

  • Почему жёсткая связь компонента с роутингом, это плохо

    ▪ Пример плохой жёсткой связи

        const User = {
          template: '<div>User {{ $route.params.id }}</div>'
        }
        const router = new VueRouter({
          routes: [
            { path: '/user/:id', component: User }
          ]
        })    

    ▪ Чем это плохо: жёсткая связь с роутером и URI с конкр.параметрами

      ▪ Привязка к vue router
        - Без него компонент уже работать не будет.

      ▪ Привязка к URI с параметром id
        - С любыми другими URI компонент уже работать не будет.

  • Преобразовываем параметры роутинга во входные параметры компонента

    ▪ Используем св-во props в объекте-роутере
      - В качестве значения либо true/false, либо объект.
    
    ▪ Если роут БЕЗ именов.представлений, значение props - true/false
      - Например, props: true

    ▪ Если роут С именов.представлениями, значение props - объект
      - В нём ключ, это имя одного из компонентов.
      - А значение, это true/false.

    ▪ Пример компонента, отделённого от роутинга
      - Здесь компонент User принимает входной параметр id.
      - А в роутере, в каждом объекте-роуте мы указываем props.
      - Причём, для роутов БЕЗ именованных представлений, в 
        качестве значения props можно просто указать true/false.
      - А для роутов С именованными представлениями, в качестве
        значения props надо указать объект, где для каждого именованного
        представления указывать true/false.
      - Код:

        // Компонент
        const User = {
          props: ['id'],
          template: '<div>User {{ id }}</div>'
        }

        // Роутер
        const router = new VueRouter({
          routes: [
            { path: '/user/:id', component: User, props: true }

            // для маршрутов с именованными представлениями, необходимо указывать опцию props для каждого именованного представления:
            {
              path: '/user/:id',
              components: { default: User, sidebar: Sidebar },
              props: { default: true, sidebar: false }
            }
          ]
        })    

  • Изощрённый пример преобразовывания параметров роутинга во входные параметры компонента
    - https://github.com/vuejs/vue-router/blob/dev/examples/route-props/app.js




