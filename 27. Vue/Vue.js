////=================================================////
////                                                 ////
////                     Vue.js                      ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Официальные ресурсы //
  //---------------------//

    # Сайт Vue.js (en, ru)
        https://vuejs.org
        https://ru.vuejs.org

    # Руководство v2 (en, ru)
        https://vuejs.org/v2/guide/
        https://ru.vuejs.org/v2/guide/

    # Сообщество и поддержка
        https://gitter.im/vuejs/vue           // Чат в гиттере
        https://forum.vuejs.org/              // Форум

    # Шаблоны
        https://github.com/vuejs-templates

    # Новости
        https://twitter.com/vuejs             // Частые новости
        https://medium.com/the-vue-point      // Блог, редко обновляется

    # Ресурсы
        https://github.com/vuejs/awesome-vue  // Обновляемый список относящихся к vue ресурсов (компоненты, туториалы и т.д.)
        https://vuex.vuejs.org/ru             // Vuex (core plugin)
        https://router.vuejs.org/ru           // Router (core plugin)

    # Песочница с Vue
        https://jsfiddle.net/chrisvfritz/50wL7mdz/

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Vue.js

    А1. План изучения Vue.js
    А2. Установка, совместимость
    А3. Введение в Vue
    А4. Экземпляр Vue
    А5. Синтаксис шаблонов
    А6. Вычисляемые свойства и слежение
    А7. Работа с CSS: классы и стили
    А8. Условный рендеринг
    А9. Рендеринг списков
    А10. Обработка событий
    А11. Работа с формами
    А12. Компоненты


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. План изучения Vue.js

--------------------------------------
Подоглавление:

  # Введение
  # Как лучше изучать Vue.js?

--------------------------------------

> Ссылки

  # Где тестировать примеры
      https://jsfiddle.net

> Введение
  - Это короткая глава про то, как лучше изучать Vue.js
  - Данное руководстов актуально на 29.05.2017.

> Как лучше изучать Vue.js?

  1. Официальная документация Vue.js на родном языке
    - Используй последнюю версию документации (на 25.05.2017 - v2).
      https://ru.vuejs.org/v2/guide/
    - Напиши сквозную методичку по всей документации.
    - Так ты получишь полный обзор возможностей фреймворка.

  2. Плагины ядра vuex и router
    - Используй последнюю версию документации (на 25.05.2017 - v2).
    - Напиши сквозные методички по документации vuex и router.
    - Это позволит с самого начала применять их для работы.

  3. Пополнение собственной подборки полезных сторонних vue-компонентов
    - Создай в этой методичке отдельный раздел для этих целей.
    - И постепенно пополняй его инфой о сторонних полезных vue-компонентах.
    - Используй awsome-vue и оцициальный twitter в качестве источников.

А2. Установка, совместимость

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  
  # Вопросы совместимости Vue.js

    ▪ ECMAScript >= 5
    ▪ IE >= 9

  # Способы подключения Vue.js к проекту

    ▪ Подключение файла через <script>
    ▪ Подключение ссылки из CDN через <script>
    ▪ Подключение через NPM

  # Официальный CLI от VUE
  # Объяснение различных сборок VUE
  # Runtime + Компилятор vs Runtime-only

    ▪ Когда нужен компилятор
    ▪ Для однофайловых компонентов *.vue компилятор не нужен
    ▪ Псевдоним в сборщике при использовании полных сборок

  # Режим разработки vs режим production

    ▪ UMD-сборки
    ▪ CommonJS и ES Module
    ▪ Переменная среды process.env.NODE_ENV

--------------------------------------

> Ссылки
  
  # [Официальноу руководство] Установка
      https://ru.vuejs.org/v2/guide/installation.html

> Введение
  - Рассмотрены вопросы установки, совместимости, использования Vue.js.

> Вопросы совместимости Vue.js

  • ECMAScript >= 5
    - Vue.js должен работать с браузерами, поддерживающими ES >= 5

  • IE >= 9
    - Vue.js не работает с IE <= 8, т.к. там нельзя эмулировать ES >= 5.

> Способы подключения Vue.js к проекту

  • Подключение файла через <script>
    - Скачать файл с Vue.js и подключить.
    - На данный момент (30.05.2017) есть 2 версии:

      ▪ Для разработчиков   | С предупреждениями для удобства разработки и отладки
      ▪ Для production      | Без предупреждений, ~30кб.

  • Подключение ссылки из CDN через <script>
    - Рекомендуемый CDN: https://unpkg.com/vue

  • Подключение через NPM
    - Автор рекомендует NPM для крупных Vue-приложений.
    - Этот вариант хорошо работает с инструментами сборке,
      такими как Webpack и Browserify.
    - В Vue также есть совместимые с ними инструменты
      для использования однофайловых компонентов.

> Официальный CLI от VUE
  - У VUE есть официальный интерпретатор командной строке (CLI).
  - Это позволяет быстро создавать каркас одностраничных приложений.
  - Предлагаемые шаблоны содержат всё необходимое для фронтенд-разработки.
  - Всего за несколько минут вы получите конфигурацию с hot-reload,
    линтингом кода при сохранении и настроенной конфигурации
    production-сборки.

> Объяснение различных сборок VUE
  
  ▪ Схема

                                UMD                 CommonJS                ES Module
    ----------------------------------------------------------------------------------------------
    Полная                      vue.js              vue.common.js           vue.esm.js
    Runtime-only                vue.runtime.js      vue.runtime.common.js   vue.runtime.esm.js
    Полная (production)         vue.min.js          -
    Runtime-only (production)   vue.runtime.min.js  -

  ▪ Терминология
    - Полная      | Сборка, которая содержит и компилятор, и runtime.
    - Компилятор  | Код, который отвечает за компиляцию строковых
                    шаблонов в JavaScript render-функции.
    - Runtime     | Код, который отвечает за создание экземпляров Vue,
                    рендеринг и изменение виртуального DOM, и т.д. Обобщённо, этой
                    всё, за исключением компилятора.
    - UMD         | UMD-сборки можно использовать сразу в браузере,
                    подключая тегом <script>. Файлом по умолчанию в Unpkg CDN из
                    https://unpkg.com/vue будет Runtime + Компилятор UMD-сборка (vue.js).
    - CommonJS    | CommonJS-сборки предназначены для использования вместе со старыми
                    инструментами сборки, такими как Browserify или Webpack 1. Файлом
                    по умолчанию для них (pkg.main) будет Runtime-only CommonJS сборка
                    (vue.runtime.common.js).
    - ES Module   | ES module сборки предназначены для использования с современными
                    инструментами сборки, такими как Webpack 2 или Rollup. Файлом по умолчанию
                    для них (pgk.module) будет Runtime-only ES Module сборка
                    (vue.runtime.esm.js).

  ▪ Runtime + Компилятор vs Runtime-only
    
    ▪ Когда нужен компилятор
      - Компилятор нужен, если надо компилировать шаблоны на лету.
      - Например:

          // это требует компилятора
          new Vue({
            template: `<div>{{ hi }}</div>`
          })

          // это нет
          new Vue({
            render (h) {
              return h('div', this.hi)
            }
          })    

    ▪ Для однофайловых компонентов *.vue компилятор не нужен
      - Vue-loader и vuefiy компилируют шаблоны внутри *.vue на этапе сборки.
      - Так что, с файлми *.vue можно использовать runtime-only сборки.

    ▪ Псевдоним в сборщике при использовании полных сборок
      - Runtime-only сборки примерно на 30% легче, в сравнении с полными.
      - Поэтому, есть смысл использовать их, когда это возможно.
      - А для использования полных сборок надо настроить псевдоним в сборщике:

        ▪ Webpack
          module.exports = {
            // ...
            resolve: {
              alias: {
                'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' для webpack 1
              }
            }
          }

        ▪ Rollup
          const alias = require('rollup-plugin-alias')
          rollup({
            // ...
            plugins: [
              alias({
                'vue': 'vue/dist/vue.esm.js'
              })
            ]
          })

        ▪ Browserify
          - Добавьте в package.json вашего проекта:
            {
              // ...
              "browser": {
                "vue": "vue/dist/vue.common.js"
              }
            }

> Режим разработки vs режим production

  • UMD-сборки
    - Тут есть min и не-min файлы.
    - min для продакшн, не-min для разработки.

  • CommonJS и ES Module
    - Тут не минифицированный код.
    - Ведь эти сборки предназначены для инструментов сборки.
    - Хочешь минифицировать - легко это сделаешь через оные.
    
  • Переменная среды process.env.NODE_ENV
    - Также эти сборки палят переменную среды: process.env.NODE_ENV.
    - В каждой системе сборки можно использовать соотв.плагин:

      ▪ Webpack

          var webpack = require('webpack')
          module.exports = {
            // ...
            plugins: [
              // ...
              new webpack.DefinePlugin({
                'process.env': {
                  NODE_ENV: JSON.stringify('production')
                }
              })
            ]
          }

      ▪ Rollup

          const replace = require('rollup-plugin-replace')
          rollup({
            // ...
            plugins: [
              replace({
                'process.env.NODE_ENV': JSON.stringify('production')
              })
            ]
          }).then(...)

      ▪ Browserify

          NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js

А3. Введение в Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое Vue.js?
    ▪ Описание Vue
    ▪ Hello World на Vue

  # Немного истории
    ▪ Vue 1 (2013 - 2016)
    ▪ Vue 2 (2016 - ...)

  # Декларативный рендеринг и реактивный биндинг
    ▪ Что такое декларативный рендеринг
    ▪ Что такое реактивный биндинг
    ▪ Пример декларативного рендеринга и реактивного биндинга
    ▪ Пример биндинга атрибута title

  # Условия и циклы, transition-эффекты
    ▪ Про условия и циклы в Vue
    ▪ Управление присутствием эл-та в DOM с помощью v-if
    ▪ Пример использования директивы v-for
    ▪ Пример использования v-if с transition-эффектом

  # Работа с событиями, 2-сторонний биндинг эл-в формы
    ▪ Про биндинг событий в Vue
    ▪ Биндинг событий с обработчиками с помощью директивы v-on
    ▪ Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

  # Разбиение приложения на компоненты
    ▪ Ключевые понятия концепции компонентов
      - Vue-компонент
      - Vue не реализует паттерн MVVP в полной мере
      - Слабая связанность и автономность
      - Повторное использование
      - Репозитории сторонних компонентов
      - Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Пример компактного шаблона приложения, использующего компоненты
    ▪ Создать простейший vue-компонент
    ▪ Использования входных параметров vue-компонента

--------------------------------------

> Ссылки

  # [Официальноу руководство] Введение
      https://ru.vuejs.org/v2/guide/

  # Однофайловые компоненты
      https://ru.vuejs.org/v2/guide/single-file-components.html

  # База готовых компонентов и библиотеками
      https://github.com/vuejs/awesome-vue#components--libraries

  # Чем Vue отличается от других фронтенд библиотек/фреймфорков
      https://ru.vuejs.org/v2/guide/comparison.html
  
  # Паттерн MVVM
      https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel
  
> Введение
  - Это обзорное введение в Vue.js.
  - Это не справочник, а обзорная экскурсия.
  - Стараемся зацепить все наиболее важные темы, но поверхностно.

> Что такое Vue.js?
  
  • Описание Vue
    - Vue произносится, как vju:, примерно как view.
    - Это прогрессивный фреймворк для создания пользовательских инетрфейсов.
    - В отличие от фреймворков-монолитов, vue годится для постепенного внедрения.
      Его ядро в 1-ю очередь решает задачи уровня представления (view).
      Что упрощает интеграцию с другими библиотеками и существующими проектами.
    - Vue полностью подходит для создания одностраничных приложений
      (SPA, Single-Page Applications). Помочь в этом может:

        ▪ Применение однофайловых компонентов (см.ссылки).
        ▪ Базы готовых компонентов и библиотек (см.ссылки).

  • Hello World на Vue

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>
      
      // 2. Подготовить шаблон
      <div id="app">
        <p>{{ message }}</p>
      </div> 

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue.js!'
        }
      })

> Немного истории

  • Vue 1 (2013 - 2016)
    - Создателем Vue.js является Evan You, бывший сотрудник Google и Meteor Dev Group.
    - Начал он разрабатывать фреймворк в 2013-м, а в феврале 2014-го состоялся первый публичный релиз.
    - Vue широко используется среди китайских компаний, например: Alibaba, Baidu, Xiaomi, Sina Weibo и др. 
    - Он входит в ядро Laravel и PageKit.
    - Недавно свободная система управления репозиториями GitLab тоже перешла на Vue.js. 
    
  • Vue 2 (2016 - ...)
    - В конце сентября 2016-го вышел в релиз Vue.js 2.0
    - Упор был сделан на производительность.
    - Теперь используется виртуальный DOM.
    - Поддерживается серверный рендеринг, возможность использовать JSX и т.д.
    - Сейчас фреймворк поддерживается только сообществом
      (хотя ходят слухи, что > 50% финансируется alibaba'ой).

> Декларативный рендеринг и реактивный биндинг

  • Что такое декларативный рендеринг
    - Позволяет связывать модель с шаблоном прямо в шаблоне.
    - По тому же принципу работает, например, Knockoutjs.
    - В качестве примера см. Hello World на Vue выше.

  • Что такое реактивный биндинг
    - Когда при изменении значения в модели меняется и значение в шаблоне.
    - По умолчанию применяется 1-направленный биндинг: модель -> шаблон.
    - Но можно использоватьи 2-направленный, с помощью v-model (например, в формах).

  • Пример декларативного рендеринга и реактивного биндинга
    - Этот пример демонстрирует декларативный рендеринг и 
      1-направленный декларативный биндинг.
    - В консоли браузера можно написать:

        app.message = 'test'

    - И новое значение сразу будет отрисовано.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app">
        {{ message }}
      </div>

      // 3. Создать экземпляр Vue
      var app = new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue!'
        }
      })      

  • Пример биндинга атрибута title
    - В примере мы применяем директиву v-bind.
    - И однонаправленно биндим атрибут title со св-вом message в модели.
    - Теперь, при изменении message, будет меняться и title.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-2">
        <span v-bind:title="message">
          Подержи курсор надо мной пару секунд,
          чтобы увидеть динамически связанное значение title!
        </span>
      </div>

      // 3. Создать экземпляр Vue
      var app2 = new Vue({
        el: '#app-2',
        data: {
          message: 'Вот когда вы загрузили эту страницу: ' + new Date()
        }
      })      

> Условия и циклы, transition-эффекты

  • Про условия и циклы в Vue
    - Они работают примерно аналогично knockoutjs`овским.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Управление присутствием эл-та в DOM с помощью v-if
    - Можно менять значение app3.seen на true/false.
    - И тем самым управлять присутствием шаблона в DOM.
    - Директива v-if аналогична директиве if из knockoutjs.
    - При false шаблон просто изчезает из DOM (не путать с display:none).
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-3">
        <p v-if="seen">Сейчас меня видно</p>
      </div>      

      // 3. Создать экземпляр Vue
      var app3 = new Vue({
        el: '#app-3',
        data: {
          seen: true
        }
      })      

  • Пример использования директивы v-for
    - Можно на лету добавить новый элемент в массив todos.
    - Это можно сделать, например, в консоли: app4.todos.push({ text: 'Новый элемент' })
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-4">
        <ol>
          <li v-for="todo in todos">
            {{ todo.text }}
          </li>
        </ol>
      </div>

      // 3. Создать экземпляр Vue
      var app4 = new Vue({
        el: '#app-4',
        data: {
          todos: [
            { text: 'Посадить дерево' },
            { text: 'Построить дом' },
            { text: 'Вырастить сына' }
          ]
        }
      })

  • Пример использования v-if с transition-эффектом
    - Vue имеет встроенную систему анимации, которая применяет transition-эффекты.
    - В этом примере мы меняем значение v-if нажатием кнопки.
    - Благодаря transition-эффекту эл-т плавно появляется/исчезает.
    - Можно также назначать JS-хуки, которые будут вызваны в нужные моменты времени.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="demo">
        <button v-on:click="show = !show">
          Переключить
        </button>
        <transition name="fade">
          <p v-if="show">hello</p>
        </transition>
      </div>    

      // 3. Создать экземпляр Vue
      new Vue({
        el: '#demo',
        data: {
          show: true
        }
      }) 

      // 4. Подготовить CSS
      .fade-enter-active, .fade-leave-active {
        transition: opacity .5s
      }
      .fade-enter, .fade-leave-to /* .fade-leave-active для <2.1.8 */ {
        opacity: 0
      }

> Работа с событиями, 2-сторонний биндинг эл-в формы

  • Про биндинг событий в Vue
    - С точки зрения использования, всё работает, как knockoutjs.
    - Можно назначать обработчики событий для элементов.
    - Можно делать 2-сторонний биндинг с элементами формы типа input, textarea и т.д.
    - Здесь приведём лишь пару примеров, полный справочник далее.

  • Биндинг событий с обработчиками с помощью директивы v-on
    - С помощью v-on можно связать событие на элементе с обработчиком.
    - Например, свяжем событие click на эл-те с функцией-обработчиком:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-5">
        <p>{{ message }}</p>
        <button v-on:click="reverseMessage">Обратить порядок букв в сообщении</button>
      </div>

      // 3. Создать экземпляр Vue     
      var app5 = new Vue({
        el: '#app-5',
        data: {
          message: 'Hello Vue.js!'
        },
        methods: {
          reverseMessage: function () {
            this.message = this.message.split('').reverse().join('')
          }
        }
      })

  • Пример 2-стороннего биндинга эл-в формы с моделью с помощью v-model

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Подготовить шаблон
      <div id="app-6">
        <p>{{ message }}</p>
        <input v-model="message">
      </div>

      // 3. Создать экземпляр Vue
      var app6 = new Vue({
        el: '#app-6',
        data: {
          message: 'Hello Vue!'
        }
      })

> Разбиение приложения на компоненты

  • Ключевые понятия концепции компонентов

    ▪ Vue-компонент
      - Концепция Vue изначально предполагает использование компонентов.
      - В Vue, компонент — это, по сути, экземпляр Vue с предустановленными опциями. 
      - Эта абстракция позволяет собирать большие приложения из малых кусочков.
      - Почти любой интерфейс может быть представлен, как дерево компонентов.

    ▪ Vue не реализует паттерн MVVP в полной мере
      - Речь идёт о паттерне Model–view–viewmodel.

    ▪ Слабая связанность и автономность
      - Связь между компонентами должна отсутствовать.
      - Каждый компонент должн быть в MAX степени автономен.

    ▪ Повторное использование
      - Компоненты представляют собой пригодные к повторному использованию объекты.
      - Ведь они слабо связаны друг с другом, и м.б. перенесены в другой проект/место проекта.

    ▪ Репозитории сторонних компонентов
      - Благодаря компонентной концепции могут быть созданы репозитории компонентов.
      - Теперь не надо писать всё самому, можно использовать сторонние компоненты.

    ▪ Компонент, как чёрный ящик; делегирование разработки субподрядчикам
      - Разработкой компонентной системы намного легче управлять.
      - Можно разбить её на дерево мелких автономных компонентов.
      - Для разработки каждого компонента написать чёткое тех.задание.
      - И раздать подряды на разработку большому кол-ву разработчиков.
      - Это позволит кардинально увеличить скорость разработки фронтенда проекта.
      - Относиться к каждому компоненту, можно как к чёрному ящику.
      - У которого есть входы и выходы (но код инспектировать всё равно нужно).

    ▪ Пример компактного шаблона приложения, использующего компоненты
      - В крупных приложениях разделение на компоненты очень важно.
      - Это становится обязательным условием для сохранения управляемости процесса разработки.
      - Вот, как бы мог выглядеть шаблон приложения, использующего компоненты:

          <div id="app">
            <app-nav></app-nav>
            <app-view>
              <app-sidebar></app-sidebar>
              <app-content></app-content>
            </app-view>
          </div>

      - Как видно, на верхнем уровне находится блок с id="app".
      - А далее, считай, что просто идёт дерево компонентов.

  • Создать простейший vue-компонент
    - Это чисто для демонстрации концепции.
    - Код:

      // Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        template: '<li>Это todo</li>'
      })

      // Использовать компонент todo-item в шаблоне другого компонента
      <ul>
        <!-- Создаём экземпляр компонента todo-item -->
        <todo-item></todo-item>
      </ul>      

  • Использования входных параметров vue-компонента
    - Это расширение предыдущего примера.
    - Здесь мы добавляем компоненту todo-item принимать входящий параметр.
    - Для этого в определении компонента мы используем св-во props.
    - В нём перечисляются параметры, которые может принимать компонент.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>

      // 2. Определить новый компонент под названием todo-item
      Vue.component('todo-item', {
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
      })

      // 3. Подготовить шаблон
      // - В этом шаблоне мы и применяем наш компонент todo-item.
      // - Применяем директивы v-for прямо на компонент, которая пробегает
      //   массив groceryList из модели приложения.
      // - Далее с помощью v-bind связываем item массива с параметром todo компонента.
      // - И также с помощью v-bind связываем индекс с item.id.
      <div id="app-7">
        <ol>
          <!--
            Теперь мы можем передать каждому компоненту todo объект
            с информацией о задаче, который будет динамически меняться.
            Мы также определяем для каждого компонента "key",
            значение которого будет объяснено далее в руководстве.
          -->
          <todo-item
            v-for="item in groceryList"
            v-bind:todo="item"
            v-bind:key="item.id">
          </todo-item>
        </ol>
      </div>

      // 4. Создать экземпляр Vue
      var app7 = new Vue({
        el: '#app-7',
        data: {
          groceryList: [
            { id: 0, text: 'Овощи' },
            { id: 1, text: 'Сыр' },
            { id: 2, text: 'Что там ещё люди едят?' }
          ]
        }
      })      


А4. Экземпляр Vue

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Конструктор Vue
    ▪ Модель приложения / корневой экземпляр Vue
    ▪ Опции по умолчанию для компонента / расширение конструктора Vue
    ▪ Экземпляры компонентов рекомендуется создавать декларативно

  # Свойства и методы
    ▪ Vue-экземпляр проксирует все св-ва из объекта data
      - Что значит проксирует?
      - Что значит проксирует ссылки?
    ▪ Все проксируемые свойства из data являются реактивными
    ▪ Vue-экземпляр содержив встроенные св-ва/методы, начинающиеся с $
    ▪ Не используй стрелочные функции в св-вах экземпляра и колбэках!

  # Хуки жизненного цикла экземпляра

    ▪ Последовательность шагов при инициализации экземпляра
    ▪ Хуки жизненного цикла
    ▪ Хуки вызываются с контекстной переменной this
    ▪ Контроллеров в Vue не существует

  # Диаграмма жизненного цикла vue-экземпляра

--------------------------------------

> Ссылки

  # [Официальноу руководство] Экземпляр Vue
      https://ru.vuejs.org/v2/guide/instance.html

> Введение
  - Vue не реализует полностью паттерн MVVM, но его архитектура вдохновлена им.
  - Поэтому, традиционно, переменная с экземпляром Vue называется vm (от ViewModel).
  - Грубо говоря, экземпляр Vue - это объект с Vue-моделью.
  - В knockoutjs я привык называть это просто "модель".
  - В этой главе речь пойдёт об общих свойствах моделей в Vue.
  - Таких, как: конструктор, св-ва и методы, хуки и жизненный цикл.

> Конструктор Vue

  • Модель приложения / корневой экземпляр Vue
    - Корневой экземпляр обычно создаётся императивно.
    - При создании в него передаётся объект с опциями.
    - В нём - данные, шаблон, DOM-элемент, методы, хуки жизненного цикла и т.д.
    - Например:

        var vm = new Vue({
          // опции
        })

  • Опции по умолчанию для компонента / расширение конструктора Vue
    - Допустим, у нас есть какой-то компонент.
    - И нам его надо много раз создавать императивно в приложении.
    - И напрягает, что каждый раз надо передавать объект с опциями.
    - Чтобы этого не делать, можно задать объект с опциями по умолчанию.
    - Для этого надо расширить конструктор vue.
    - Например:

        // Задать опции по умолчанию для компонента, расширив его конструктор
        var MyComponent = Vue.extend({
          // опции компонента
        })    

        // Теперь все экземпляры этого компонента используют опции по умолчанию
        var myComponentInstance = new MyComponent()

  • Экземпляры компонентов рекомендуется создавать декларативно
    - Выше продемонстрирован пример императивного создания экземпляра компонента.
    - Однако, автор рекомендует создавать их декларативно.
    - Т.Е., как пользовательские HTML-элементы в шаблонах.
    - Подробнее об этом см.главу про Vue-компоненты.
    - А пока запомни: все Vue-компоненты являются расширенными Vue-экземплярами.

> Свойства и методы

  • Vue-экземпляр проксирует ссылки всех св-в из объекта data
    
    ▪ Что значит проксирует?
      - То есть, они становятся напрямую свойствами модели.
      - Вместо vm.data.prop надо писать просто vm.prop.
      - Пояснение на примере:

          // Подготовим data и создаим vue-экземпляр
          var data = { a: 1 }
          var vm = new Vue({
            data: data
          })

          // Удостоверимся в написанном выше
          vm.a === data.a   // true

    ▪ Что значит проксирует ссылки?
      - Значит, что vm.a и data.a содержат одну и ту же ссылку.
      - Т.Е. меняя значение в модели, мы меняем его в исходном объекте data.
      - Примеры для иллюстрации этого:

          // установка свойства также влияет на оригинальные данные
          vm.a = 2
          data.a      // 2

          // ... и наоборот
          data.a = 3
          vm.a        // 3  

  • Все проксируемые свойства из data являются реактивными
    - Т.Е. при изменении их значений автоматом меняется и представление.
    - Однако, реактивными они становятся при создании экземпляра.
    - Добавление новых св-в в data после создания экземпляра не сделает их реактивными.
    - Хотя, есть возможность добавлять реактивные св-ва во вложенные объекты.
    - В общем, подробнее о рекативности читай в главе про реактивность.

  • Vue-экземпляр содержив встроенные св-ва/методы, начинающиеся с $
    - С $ они начинаются, чтобы отличаться от пользовательских.
    - Например, ссылка на объект data лежит в vm.$data,
      а ссылка на DOM-элемент лежит в $el,
      а коллбэк на изменение св-ва можно задать методом $watch.
    - Полный список встроенных св-в и методов см. в главе-справочнике API.
    - Проиллюстрируем на примере:

        // Подготовим data и создаим vue-экземпляр
        var data = { a: 1 }
        var vm = new Vue({
          el: '#example',
          data: data
        })

        // Собственно, иллюстрация
        vm.$data === data                             // true
        vm.$el === document.getElementById('example') // true

        // $watch — это метод экземпляра
        vm.$watch('a', function (newVal, oldVal) {
          // этот коллбэк будет вызван, когда изменится `vm.a`
        })

  • Не используй стрелочные функции в св-вах экземпляра и колбэках!
    - Например: vm.$watch('a', newVal => this.myMethod())
    - Потому что СФ связываются с родительским контекстом (this).
    - Соответственно, this внутри не будет указывать на vue-экземпляр.
    - И, например, this.myMethod будет undefined.

> Хуки жизненного цикла экземпляра

  • Последовательность шагов при инициализации экземпляра
    - Каждый vue-экземпляр проходит при создании некий процесс.
    - Процесс представляет собой последовательность задач инициализации.
    - Например:

      ▪ Настройка наблюдения за данными.
      ▪ Компиляция шаблона.
      ▪ Монтаж экземпляра в DOM.
      ▪ Обновление DOM при изменении данных.
      ▪ .. и прочие ..

  • Хуки жизненного цикла
    - Всё имеет своё начало, и свой конец. И vue-экземпляр тоже.
    - По мере путешествия экземпляра по жизненному циклу, 
      он на каждом шагу генерирует события.
    - Например: created, mounted, updated, destroyed, и т.д.
    - Соответственно, можно назначать обработчики для этих хуков.
    - Например, назначим обработчик, который вызывается после создания экземпляра:

        var vm = new Vue({
          data: {
            a: 1
          },
          created: function () {
            // `this` указывает на экземпляр vm
            console.log('Значение a: ' + this.a)
          }
        })
        // -> "Значение a: 1"

  • Хуки вызываются с контекстной переменной this
    - Она содержит ссылку на вызывающий vue-экземпляр.

  • Контроллеров в Vue не существует
    - Впрочем, как и в knockoutjs.
    - Наверное, они есть в angular? [примечание автора методички].
    - В общем, всё польз.поведение компонента должно быть в этих хуках.

> Диаграмма жизненного цикла vue-экземпляра

              
                       new Vue()
                          |
   [событие] beforeCreate |
                          |
                     Observe Data 
                          |
        [событие] created |
                          | 
                      Init Events
                          |                  
                          |                  
                          |                  
                  Есть ли опция "el"? -------
                          |                 |
                       Да |                 | - Vue ждёт, пока vm.$mount(el) будет вызвана вручную
                          |                 |
                Есть ли опция "template"?----
                          |
                          |
             ---------------------------
          Да |                         | Нет
             |                         | 
      Скомпилировать             Взять outerHTML
      этот template              в качестве шаблона,
             |                   и скомпилировать его
             |                         |
             ---------------------------
                          |
    [событие] beforeMount |
                          |
                   Создать vm.$el и
                   заменить содержимое
                   el скомпилированным
                          | 
        [событие] mounted | 
                          |   При изменении
                         /|\  данных
                        /   \   /------>------ 
                       / См- \ /             | - [событие] beforeUpdate            
                      / онти- \              |
                     / рованн- \        Ререндеринг
                    / ое состо- \       виртуального DOM
                    \ яние Vue- /            |
                     \ компон- /             | - [событие] updated
                      \ ента  /--------<------
                       \     /
                        \   /
                         \|/
                          |
                          |
                Если вызван встроенный
                метод vm.$destroy()
                          |
  [событие] beforeDestroy |
                          |
                  Завершение работы
                  вотчеров, дочерних
                  компонентов и 
                  обработчиков событий
                          | 
                          | 
                         /|\ 
                        /   \ 
                       / Ун- \ 
                      / ичто- \  
                     / женный  \ 
                    / Компонент \
                    \           /
                     \         / 
                      \       /
                       \     /
                        \   /
                         \|/ 
                          | 
      [событие] destroyed | 
                          |
                        -----
 
 
А5. Синтаксис шаблонов
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
    ▪ Модель с DOM в Vue связывается через HTML
    ▪ Шаблоны Vue являются валидным HTML-кодом
    ▪ Использование виртуального DOM
    ▪ Можно использовать свою render-функцию
 
  # Интерполяции (компиляция всяких vue-подстановок из шаблона в HTML)
    ▪ Подстановка через {{ }}, или @{{ }} для Blade
      - Связать св-во с DOM
      - v-once: связать св-во с DOM, но не обновлять DOM при его изменении
      - Использование js-выражения внутри {{ }}
      - Содержимое {{ }} подставляется, как текст, а не HTML
    
    ▪ Подстановка сырого HTML
      - Директива v-html
      - Нельзя использовать v-html для вложения шаблонов друг в друга
      - Подставляй только доверенный HTML
    
    ▪ Подстановка атрибутов: v-bind
 
  # Директивы
    ▪ В общем про директивы
    ▪ Атрибуты директив
    ▪ Модификаторы директив
    ▪ Фильтры в интерполяциях {{ }} и директиве v-bind
      - Фильтры форматирую текст
      - Фильтры можно определить в объекте filters в корне модели
      - Фильтры можно чейнить
      - Фильтры могут принимать параметры    
    ▪ Сокращения директив

--------------------------------------

> Ссылки

  # [Официальноу руководство] Синтаксис шаблонов
      https://ru.vuejs.org/v2/guide/syntax.html

> Введение
  
  • Модель с DOM в Vue связывается через HTML
    - Аналогичный подход используется и в knockout.

  • Шаблоны Vue являются валидным HTML-кодом
    - Его могут распарсить все HTML-парсеры и браузеры.
 
  • Использование виртуального DOM
    - Vue компилирует шаблоны в функции рендера виртуального DOM.
    - При изменении состояния приложения система реактивности
      определяет MIN набор компонентов для повторного рендеринга.
    - А виртуальный DOM определяет минимальные изменения уже внутри них.
 
  • Можно использовать свою render-функцию
    - То есть, сгенерировать HTML с помощью низкоуровневого JS.
    - Для этого нужно добавить в vue-компонент свойство render.
    - А в него положить функцию, которая должна вернуть созданный элемент.
    - Обычно вместо этого применяются vue-шаблоны.
    - Но могут быть случаи, когда удобнее использовать render-функцию.
    - Подробнее о render-функциях читай в соответствующей главе.

> Интерполяции (компиляция всяких vue-подстановок из шаблона в HTML)

  • Подстановка через {{ }}, или @{{ }} для Blade
 
    ▪ Связать св-во с DOM
      - msg будет заменено на значение св-ва msg из модели.
      - Имеется в виду модель vue-компонента, в чьём шаблоне эта интерполяция.
      - DOM будет обновляться при изменении значения св-ва в модели.

        <span>Сообщение: {{ msg }}</span>     | - в обычном случае
        <span>Сообщение: @{{ msg }}</span>    | - в Blade (Laravel)

    ▪ v-once: связать св-во с DOM, но не обновлять DOM при его изменении
      - Допустим, надо подставить значение лишь при загрузке.
      - А при изменении значения в модели, DOM не менять.
      - Для этого и можно применить директиву v-once:

          <span v-once>Это сообщение никогда не изменится: {{ msg }}</span>

    ▪ Использование js-выражения внутри {{ }}
      - Внутри {{ }} можно использовать и js-выражение.
      - Оно будет вычислено, и будет возвращён его результат.
      - Вычисление будет производиться в контексте модели vue-экземпляра.
      - Выражения имеют доступ лишь к ограниченному списку глобальных объектов,
        таких как Math и Date. Поэтому, получить доступ к пользовательским
        глобальным объектам не получится.
      - Примеры:

          {{ number + 1 }}
          {{ ok ? 'YES' : 'NO' }}
          {{ message.split('').reverse().join('') }}
          <div v-bind:id="'list-' + id"></div>

    ▪ Содержимое {{ }} подставляется, как текст, а не HTML
      - А для вывода HTML используй директиву v-html.

  • Подстановка сырого HTML
    
    ▪ Директива v-html
      - Производится с помощью директивы v-html.
      - Например:

          <div v-html="rawHtml"></div>

    ▪ Нельзя использовать v-html для вложения шаблонов друг в друга
      - Так как движок шаблонов Vue не основывается на строках.
      - Вместо этого надо использовать vue-компоненты.

    ▪ Подставляй только доверенный HTML
      - Не подставляй контент, сгенерированный пользователем.
      - Это может привести к XSS-уязвимостям.

  • Подстановка атрибутов: v-bind
    - Синтаксис {{ }} не работает с атрибутами.
    - Для подстановки последних используй директиву v-bind
    - Например, свяжем атрибут id со св-вом модели dynamicId: 

        <div v-bind:id="dynamicId"></div>

    - При этом dynamicId также может быть и булевым значением.
    - В случае, если оно равно true, то будет атрибут без значения.
    - А если false, то атрибут будет удалён полностью.
    - Например:

        <button v-bind:disabled="isOn">Кнопка</button>
        <button disabled>Кнопка</button>  | если isOn == true
        <button>Кнопка</button>           | если isOn == false

> Директивы

  • В общем про директивы
    - Директивы, это специальный атрибуты с префиксом v-
    - Принцип работу у них похож на их аналоги data-bind из knockoutjs.
    - В качестве значения v- директивы принимают 1-но js-выражение (за исключением v-for).
    - Это выражение выполняется в контексте модели соответствующего vue-экземпляра.
    - Директива реактивно применяет к DOM изменения при обновлении этого выражения.
    - Например, эта директива удалит/вставит элемент в DOM в зависимости
      от значения св-ва seen в модели vue-компонента:

        <p v-if="seen">Сейчас меня видно</p>

  • Атрибуты директив
    - Некоторые директивы могут принимать аргумент через двоеточие.
    - Примеры: 

        <a v-bind:href="url"></a>     | связать атрибут href со св-вом url модели
        <a v-on:click="doSomething">  | назначить обработчик doSomething события click для элемента

  • Модификаторы директив
    - Это особые постфиксы, добавляемые после точки.
    - Они приказывают провести биндинг особым образом.
    - Пример:

        <form v-on:submit.prevent="onSubmit"></form>  | предотвратить действия браузера по умолчанию при обработке события

  • Фильтры в интерполяциях {{ }} и директиве v-bind
    
    ▪ Фильтры форматирую текст
      - Речь идёт о форматировании текста.
      - Фильтр добавляется в конце js-выражения, и отделяется вертикальной чертой.
      - Например:

          {{ message | capitalize }}
          <div v-bind:id="rawId | formatId"></div>

    ▪ Фильтры можно определить в объекте filters в корне модели
      - Надо добавлять в этот объект св-ва со значениями-функциями.
      - 1-ым аргументом такая функция получит значение js-выражения.
      - Например, определим фильтр capitalize:

          new Vue({
            // ...
            filters: {
              capitalize: function (value) {
                if (!value) return ''
                value = value.toString()
                return value.charAt(0).toUpperCase() + value.slice(1)
              }
            }
          })

    ▪ Фильтры можно чейнить
      - Например:

          {{ message | filterA | filterB }}

    ▪ Фильтры могут принимать параметры
      - Они пойдут со 2-го аргумента и далее (т.к. в 1-й передаётся значение js-выражения).
      - Например:

          {{ message | filterA('arg1', arg2) }}      

  • Сокращения директив

    ▪ Зачем нужны сокращения
      - Для тех, кому лень написать несколько лишних символов.
      - В Vue есть сокращения для директив v-bind и v-on.
      - Сокращение производится через : и @ соотственно.
      - Символы : и @ валидны во всех современных браузерах.
      - В итоговой разметке они не появляются.

    ▪ Сокращение для v-bind через :
 
        <a v-bind:href="url"></a>         | полный синтаксис
        <a :href="url"></a>               | сокращение
 
    ▪ Сокращение для v-on через @

        <a v-on:click="doSomething"></a>  | полный синтаксис   
        <a @click="doSomething"></a>      | сокращение
 
 
А6. Вычисляемые свойства и слежение 
 
--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Концепция вычисляемой
  # Отличие Vue-вычисляемых от Knockout-вычисляемых

    ▪ Что было в Knockout с вычисляемой?
    ▪ Две опции: метод или вычисляемая
    ▪ Вычисляемая кэшируется, метод нет

  # Пример вычисляемого свойства
  # Пример использования метода вместо вычисляемой
  # Альтернатива наблюдаемым: слежение за св-ми с помощью watch

    ▪ Суть применения watch
    ▪ Доступ к объекту watch через переменную модели
    ▪ Пример применения watch
      - Решение через наблюдаемую
      - Решение через метод
      - Решение через watch

  # Запись в наблюдаемые: сеттеры

    ▪ Редко когда надо писать в наблюдаемые
    ▪ Как настроить наблюдаемую, чтобы в неё можно было писать

  # Как ограничить частоту выполнения наблюдаемых?

    ▪ Проблемы с производительностью наблюдаемых
    ▪ В Vue вместо наблюдаемой: метод + watch
    ▪ Ограничение частоты выполнения 

--------------------------------------

> Ссылки

  # [Официальноу руководство] Вычисляемые свойства и слежение 
      https://ru.vuejs.org/v2/guide/computed.html

> Введение
  - Вычисляемые в Vue чуток отличаются от оных в Knockout.
  - Но концепция остаётся прежней.
  
> Концепция вычисляемой
  - Как упоминалось в А5, в {{ }} и директивы можно вставлять 1-но js-выражение.
  - И при изменении задействованных в нём св-в модели, оно будет перевычисляться.
  - И соответствующий DOM будет обновлятсья.
  - Но держать в HTML много кода неудобно.
  - Проще добавить в модель вычисляемое св-во, а в HTML уже его вставить.

> Отличие Vue-вычисляемых от Knockout-вычисляемых

  • Что было в Knockout с вычисляемой?
    - В knockout значение вычисляемой не кэшируется.
    - Её можно использовать в шаблоне, она будет реактивна.
    - А вот метод в knockout при подстановке в шаблон реактивен 
      не был, и срабатывал тольк 1 раз при загрузке.

  • Метод в Vue соответствует вычисляемой в Knockout
    - Его значение не кэшируется, как и Knockout-вычисляемой.
    - Его можно использовать в шаблоне, и он реактивен.

  • Vue-вычисляемая, как метод, только значение её кэшируется
    - Оно не меняется при запросах к вычисляемой.
    - А меняется только, когда меняются значения наблюдаемых,
      которые присутствуют в функции этой вычисляемой.
    - Это позволяет улучшить производительность, когда от
      этой вычисляемой зависит много других.

> Пример вычисляемого свойства

  • Описание
    - Определяем обычное свойство message.
    - Определяем вычисляемое св-во reversedMessage.
    - В ф-ии выч-го св-ва возвращаем реверс-значение текущего св-ва message.
    - При изменении message будет меняться и значение вычисляемого св-ва.
    - В шаблоне можно использовать вычисляемое также, как и обычное св-во.
    - Короче говоря, тоже самое, что и в knockoutjs.

  • Шаблон
    <div id="example">
      <p>Изначальное сообщение: "{{ message }}"</p>
      <p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
    </div>  

  • Модель
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Привет'
      },
      computed: {
        // геттер вычисляемого значения
        reversedMessage: function () {
          // `this` указывает на экземпляр vm
          return this.message.split('').reverse().join('')
        }
      }
    })

  • Результат

    Привет
    тевирП

> Пример использования метода вместо вычисляемой

    // 1. Подключить UMD-сборку Vue из CDN
    <script src="https://unpkg.com/vue"></script>

    // 2. Подготовить шаблон
    <div id="example">
      <p>Сообщение задом наперёд: "{{ reverseMessage() }}"</p>
    </div>

    // 3. Определить новый компонент
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Привет'
      },
      methods: {
        reverseMessage: function () {
          return this.message.split('').reverse().join('')
        }
      }
    })

    // 4. Меняем значение св-ва из метода, чтобы проверить, изменится ли DOM (да)
    vm.message = 'Привет1';

> Альтернатива наблюдаемым: слежение за св-ми с помощью watch

  • Суть применения watch
    - В модель можно добавить объект watch.
    - В него добавлять колбэки.
    - Ключами должны служить св-ва из data, за которыми надо следить.
    - Соотв.колбэк будет срабатывать при изменении этого свойства.
    - И, например, менять какое-то 3-е св-во.

  • Доступ к объекту watch через переменную модели
    - vm.$watch

  • Пример применения watch
    - Например, есть у нас 3 св-ва: name, surname, fullname.
    - Как получать fullname? Один вариант: метод или наблюдаемая.
    - Другой вариант: watch. Следить за name и surname.
    - И вызывать колбэк, меняющий fullname, при изменении последних.
    - Код:

      ▪ Решение через наблюдаемую

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName() }}</div>

        // 3. Определить новый компонент
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          methods: {
            fullName: {
              fullName: function () {
                return firstName + ' ' + lastName
              }
            }
          }
        })

      ▪ Решение через метод

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName }}</div>

        // 3. Определить новый компонент
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          methods: {
            fullName: function () {
              return this.firstName + ' ' + this.lastName
            }
          }
        });     

      ▪ Решение через watch

        // 1. Подключить UMD-сборку Vue из CDN
        <script src="https://unpkg.com/vue"></script>    

        // 2. Подготовить шаблон
        <div id="demo">{{ fullName }}</div>

        // 3. Определить новый компонент под названием todo-item
        var vm = new Vue({
          el: '#demo',
          data: {
            firstName: 'Foo',
            lastName: 'Bar',
            fullName: 'Foo Bar'
          },
          watch: {
            firstName: function (val) {
              this.fullName = val + ' ' + this.lastName
            },
            lastName: function (val) {
              this.fullName = this.firstName + ' ' + val
            }
          }
        })      

> Запись в наблюдаемые: сеттеры

  • Редко когда надо писать в наблюдаемые
    - Я использовал Knockout пару лет.
    - Там тоже можно записывать в наблюдаемую, если надо.
    - Но за всё время не было ни 1 случая, когда это понадобилось.
    - Думаю, аналогичная ситуация ждёт и в Vue.
    - Поэтому, по умолчанию в Vue и можно лишь читать из наблюдаемой.
    - Но, при необходимости, можно настроить её и на запись.
   
  • Как настроить наблюдаемую, чтобы в неё можно было писать
    - На примере:

        computed: {
          fullName: {
            // геттер:
            get: function () {
              return this.firstName + ' ' + this.lastName
            },
            // сеттер:
            set: function (newValue) {
              var names = newValue.split(' ')
              this.firstName = names[0]
              this.lastName = names[names.length - 1]
            }
          }
        }

> Как ограничить частоту выполнения наблюдаемых?

  • Проблемы с производительностью наблюдаемых
    - У меня есть большой опыт работы с наблюдаемыми в Knockout.
    - В том числе, с очень большим SPA, в которых десятки наблюдаемых.
    - В том SPA от при изменении наблюдаемых перерисовывался и DOM.
    - А перерисовывание DOM операция достаточно тяжёлая.
    - И если очень-очень часто дёргать наблюдаемую, всё жёстко лагало.
    - Выходом было ограничение частоты выполнения наблюдаемых.
    - В этом разделе описано, как это осуществить в Vue с помощью библиотеки loadash.

  • В Vue вместо наблюдаемой: метод + watch 
    - В Vue с наблюдаемой это провернуть не выйдет.
    - Придётся использовать метод + watch + lodash.

  • Ограничение частоты выполнения 
    - В данном примере выполняется ajax-запрос в ответ
      на ввод текста пользователем в input.
    - Но не выполнять же запрос при каждом нажатии?
    - С помощью метода, watch и lodash мы ограничиваем
      MAX частоту отправки ajax-запроса.
    - Конкретно, используется метод _.debounce из lodash.
    - Он будет срабатывать спустя указанное кол-во ms (500)
      после последего запроса к методу.
    - Код:

      // 1. Подключить UMD-сборку Vue из CDN
      <script src="https://unpkg.com/vue"></script>    

      // 2. Подготовить шаблон
      <div id="watch-example">
        <p>
          Задайте вопрос, на который можно ответить "да" или "нет":
          <input v-model="question">
        </p>
        <p>{{ answer }}</p>
      </div>

      // 3. Подключить либы, определить новый компонент
      <!-- Поскольку уже существует обширная экосистема ajax-библиотек  -->
      <!-- и библиотек функций общего назначения, ядро Vue может        -->
      <!-- оставаться маленьким и не изобретать их заново. Кроме того,  -->
      <!-- это позволяет вам использовать только знакомые инструменты. -->
      <script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
      <script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
      <script>
      var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
          question: '',
          answer: 'Пока вы не зададите вопрос, я не могу ответить!'
        },
        watch: {
          // эта функция запускается при любом изменении вопроса
          question: function (newQuestion) {
            this.answer = 'Ожидаю, когда вы закончите печатать...'
            this.getAnswer()
          }
        },
        methods: {
          // _.debounce — это функция из lodash, позволяющая ограничить
          // то, насколько часто может выполняться определённая операция.
          // В данном случае, мы хотим ограничить частоту обращений к yesno.wtf/api,
          // дожидаясь завершения печати вопроса перед тем как послать ajax-запрос.
          // Чтобы узнать больше о функции _.debounce (и её родственнице _.throttle),
          // см. документацию: https://lodash.com/docs#debounce
          getAnswer: _.debounce(
            function () {
              if (this.question.indexOf('?') === -1) {
                this.answer = 'Вопросы обычно заканчиваются вопросительным знаком. ;-)'
                return
              }
              this.answer = 'Думаю...'
              var vm = this
              axios.get('https://yesno.wtf/api')
                .then(function (response) {
                  vm.answer = _.capitalize(response.data.answer)
                })
                .catch(function (error) {
                  vm.answer = 'Ошибка! Не могу связаться с API. ' + error
                })
            },
            // Это число миллисекунд, которое мы ждём, после того как пользователь прекратил печатать:
            500
          )
        }
      })
      </script>


А7. Работа с CSS: классы и стили

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

    ▪ Управление стилями и классами в Vue
    ▪ Директива class
    ▪ Директива style

  # Управление классами через объект

    ▪ Передача объекта прямо в шаблоне
    ▪ Vue оставляет оригинальное содержимое class без изменений
    ▪ Передача объекта из модели
    ▪ Передача объекта из наблюдаемой

  # Управление классами через массив

    ▪ Массив вместо объекта
    ▪ Тернарный оператор для переключеняи классов в массиве
    ▪ Смешанный стиль: массив + объект

  # Vue-компоненты и директива class

    ▪ Директива class добавляет стили корневому эл-ту компонента
    ▪ Собственные класы компонента потеряны не будут
    ▪ Пример применения class к компоненту

  # Управление inline-стилями в Vue

    ▪ Решай сам: camelCase или kebab-case
    ▪ Управление стилями через объект
    ▪ Используем наблюдаемый объект
    ▪ Управление стилями через массив: применить несколько объектов стилей
    ▪ Vue сам добавляет вендорные префиксы
    ▪ Последнее значение, поддерживаемое в браузере

--------------------------------------

> Ссылки

  # [Официальноу руководство] Работа с классами и стилями
      https://ru.vuejs.org/v2/guide/class-and-style.html

> Введение

  • Управление стилями и классами в Vue
    - В Vue для работы с классами и стилями есть директивы class и style.
    - Хотя, как грубый инструмент, можно использовать и v-bind,
      и работать с классами, как с атрибутами. 

  • Директива class
    - Позволяет с удобствами управлять классами в Vue.

  • Директива style
    - Позволяет с удобствами управлять инлайновыми стилями в Vue.

> Управление классами через объект

  • Передача объекта прямо в шаблоне

    <div v-bind:class="{ active: isActive }"></div>

  • Vue оставляет оригинальное содержимое class без изменений
  
    ▪ Что имеется в виду?
      - У div в шаблоне ниже определён атрибут class.
      - У него есть значение "static".
      - Что будет, если использовать v-bind:class?
      - Атрибут class никуда не денется, он НЕ затирается.

    ▪ Шаблон

      <div class="static"
           v-bind:class="{ active: isActive, 'text-danger': hasError }">
      </div>

    ▪ Фрагмент JS с данными модели

      data: {
        isActive: true,
        hasError: true
      }  

    ▪ Что после рендеринга?

      <div class="static isActive hasError"</div>      

  • Передача объекта из модели
    - Объект не обязательно писать прямо в шаблоне.
    - Его можно поместить в модель, и передать оттуда.
    - Например:

      ▪ Шаблон

        <div v-bind:class="classObject"></div>   

      ▪ Фрагмент JS с данными модели

        data: {
          classObject: {
            active: true,
            'text-danger': false
          }
        }      

  • Передача объекта из вычисляемой
    - Можно также использовать и вычисляемую.
    - Вместо наблюдаемого объекта, как из предыдущего пункта.
    - Например:

      ▪ Шаблон

        <div v-bind:class="classObject"></div>

      ▪ Фрагмент JS с данными модели

        data: {
          isActive: true,
          error: null
        },
        computed: {
          classObject: function () {
            return {
              active: this.isActive && !this.error,
              'text-danger': this.error && this.error.type === 'fatal',
            }
          }
        }  

> Управление классами через массив
  
  • Массив вместо объекта
    - Можно вместо объекти использовать и массив.
    - Например:

      ▪ Шаблон
        
        <div v-bind:class="[activeClass, errorClass]">

      ▪ Фрагмент JS с данными модели

        data: {
          activeClass: 'active',
          errorClass: 'text-danger'
        }        
            
  • Тернарный оператор для переключеняи классов в массиве
    - В случае с объектом мы писали что-то типа: {active: isActive}.
    - А в случае с объектом можно использовать тернарный оператор:

      <div v-bind:class="[isActive ? activeClass : '', errorClass]">

  • Смешанный стиль: массив + объект
    - Для истинных ценителей:

      <div v-bind:class="[{ active: isActive }, errorClass]">

> Vue-компоненты и директива class

  • Директива class добавляет стили корневому эл-ту компонента
    - Если применить эту директиву к самому компоненту.

  • Собственные класы компонента потеряны не будут
    - Ситуация аналогичная, как и с не-компонентами.

  • Пример применения class к компоненту

    ▪ Компонент

      Vue.component('my-component', {
        template: '<p class="foo bar">Hi</p>'
      })

    ▪ Если указать доп.классы с помощью атрибута class
      - То они просто добавятся к указанным в шаблоне.
        
        <my-component class="baz boo"></my-component>
      
      - В результате будет: 
        
        <p class="foo bar baz boo">Hi</p>

    ▪ Если применить директиву v-bind:class
      - То, если isActive == true, он добавится к указанным в шаблоне.
      - Например:

        <my-component v-bind:class="{ active: isActive }"></my-component>

      - В результате будет: 

        <p class="foo bar active">Hi</p>

> Управление inline-стилями в Vue

  • Решай сам: camelCase или kebab-case
    - В Vue можно применять и тот, и другой стиль.
    - Но при использовании kebab-case не забывай про кавычки.
    - Например:

      <div v-bind:style="{ fontSize: fontSize + 'px', "font-size": fontSize + 'px' }"></div>

  • Управление стилями через объект

    ▪ Используем наблюдаемые
      - Передаём в директиву объект прямо в шаблоне.
      - Используем наблюдаемые для задания значений.
      - Код:

        ▪ Шаблон

          <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
       
        ▪ Фрагмент JS с данными модели

          data: {
            activeColor: 'red',
            fontSize: 30
          }

    ▪ Используем наблюдаемый объект
      - Передаём в директиву наблюдаемый объект.
      - А его свойства уже содержат инфу о стилях.
      - Код:

        ▪ Шаблон

          <div v-bind:style="styleObject"></div> 

        ▪ Фрагмент JS с данными модели

          data: {
            styleObject: {
              color: 'red',
              fontSize: '13px'
            }
          }      

  • Управление стилями через массив: применить несколько объектов стилей
    - Можно директиве передать массив объектов.
    - Тем самым, применив к эл-ту несколько объектов стилей.
    - Например:

        <div v-bind:style="[baseStyles, overridingStyles]">

  • Vue сам добавляет вендорные префиксы
    - Об этом паритсья не нужно.

  • Последнее значение, поддерживаемое в браузере
    - Часто разные браузеры не поддерживают кое-какие значения.
    - Поэтому, в версии 2.3 в Vue добавили эту фичу.
    - В примере ниже будет использовано последне значение,
      которое поддерживает браузер, где это выполнится:

        <div v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }">

А8. Условный рендеринг

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # v-if

    ▪ v-if и v-else
    ▪ Условные группы с v-if и <template>
    ▪ v-else
    ▪ v-else-if
    ▪ Управление повторным использованием эл-в с помощью key
      - Пример переиспользования DOM-элемента в Vue
      - Запретить Vue переиспользовать DOM-элементы спомощью key

  # v-show
  # v-if VS v-show

    ▪ v-if: настойщий условный рендеринг
    ▪ v-if: ленив
    ▪ v-show: манипулирует стилем display, э-нт всегда в DOM

  # v-if вместе с v-for

--------------------------------------

> Ссылки

  # [Официальноу руководство] Условный рендеринг
      https://ru.vuejs.org/v2/guide/conditional.html#v-else

> Введение
  - Это глава про условный рендеринг с помощью Vue.

> v-if

  • v-if и v-else
    - У Vue есть шаблонизаторский функционал для условного рендеринга.
    - Аналогичный функционал, например, есть у knockout (директива if).
    - Вот пример условного рендеринга в Vue:

      <h1 v-if="ok">Да</h1>
      <h1 v-else>Нет</h1>    

  • Условные группы с v-if и <template>
    - В knockout можно было использовать псевдоэлементы,
      вроде: <!-- ko if: true --> <!-- /ko -->.
    - В Vue есть аналог - псевдоэлемент <template>:

      <template v-if="ok">
        <h1>Заголовок</h1>
        <p>Абзац 1</p>
        <p>Абзац 2</p>
      </template>    

  • v-else
    - Ещё один пример с if-else в Vue:

      <div v-if="Math.random() > 0.5">
        Сейчас меня видно
      </div>
      <div v-else>
        А теперь — нет
      </div>

  • v-else-if
    - Эта возможност добавлена в v2.1.0.
    - А именно, else-if. 
    - Его можно применять только между блоками с v-if и v-else.
    - Пример:

      <div v-if="type === 'A'">
        A
      </div>
      <div v-else-if="type === 'B'">
        B
      </div>
      <div v-else-if="type === 'C'">
        C
      </div>
      <div v-else>
        Не A/B/C
      </div>    

  • Управление повторным использованием эл-в с помощью key
    - Vue старается рендерить DOM-элементы MAX эффективно.
    - Часто, предпочитая переиспользовать, а не пересоздавать.
    - Это приводит к интересным особенностям. Например:

      • Пример переиспользования DOM-элемента в Vue
        - У нас есть 2 формы, содержащие input.
        - Между ними можно переключаться, меняя значение св-ва loginType.
        - Vue в такой ситуации переиспользует DOM-элемент input.
        - То есть, лишь меняет paceholder, а значение не затирается.
        - Хорошо ли это, или плохо, зависит от ситуации, но это так.
        - Код:

          <template v-if="loginType === 'username'">
            <label>Имя пользователя</label>
            <input placeholder="Введите имя пользователя">
          </template>
          <template v-else>
            <label>Email</label>
            <input placeholder="Введите адрес email">
          </template>        

      • Запретить Vue переиспользовать DOM-элементы спомощью key
        - Описанное выше поведение может реально напрягать иногда.
        - Допустим, мы хотим, чтобы DOM-элементы input из примера 
          выше не переиспользовались.
        - Тогда надо каждому из них указать атрибут key с уникальным значением.
        - В итоге, label будет переиспользоваться, а input нет, т.к. указаны key.
        - Код:

          <template v-if="loginType === 'username'">
            <label>Имя пользователя</label>
                <input placeholder="Введите имя пользователя" key="username-input">
          </template>
          <template v-else>
            <label>Email</label>
                <input placeholder="Введите адрес email" key="email-input">
          </template>        

> v-show
  - Директива v-show, это аналог директивы visible из knockout.
  - При использовании v-show DOM-элемент остаётся в DOM в любом случае.
  - Просто производится манипуляция с его CSS-свойством display.
  - А ещё, v-show нельзя использовать с <template>, поскольку
    оный не присутствует в DOM, и v-show нечего с ним делать.
  - Пример использования v-show:

    <h1 v-show="ok">Привет!</h1>

> v-if VS v-show

  • v-if: настойщий условный рендеринг
    - Элементы и подписчики должным образом уничтожаются/создаются.
    - Элемент либо полностью исчезает из DOM, либо присутствует.

  • v-if: ленив
    - Если условие на момент рендеринга ложное, ничего не произойдёт.
    - Условный блок не будет отображён, пока условие впервые не станет true.

  • v-show: манипулирует стилем display, э-нт всегда в DOM
    - По аналогии с knockout'ким visible.

> v-if вместе с v-for
  - v-if и v-for можно использовать совместно.
  - При этом, v-for имеет более высокий приоритет.


А9. Рендеринг списков

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Основное отличие v-for от for в knockout
  # Простой пример использования v-for
  # Индекс и контекст в v-for

    ▪ Контекст в v-for
    ▪ Индекс в v-for
    ▪ Пример контекста и индекса в v-for

  # Разделитель: in / of
  # Использование v-for с псевдоэлементом <template>
  # Использование v-for с объектом

    ▪ Итерирование по св-вам объектов
    ▪ Пример использования v-for с объектом
    ▪ Порядок обхода не гарантируется

  # Отрисовка DOM-элемента N раз путём передачив v-for целого числа
  # Компоненты и v-for

    ▪ v-for можно использовать на пользовательских компонентах
    ▪ Необходимо указывать key
    ▪ Данные в компонент надо передавать вручную
    ▪ Полный пример простого ToDo на компонентах и v-for

  # v-for и v-if в одном элементе
  
    ▪ У v-for приоритет больше, чем у v-if
    ▪ v-if будет выполняться на каждой итерации

  # Методы, которыми можно изменить наблюдаемый массив

    ▪ push      | Вставить элемент в конец массива
    ▪ shift     | Вставить элемент в начало массива
    ▪ pop       | Удалить последний эл-т и вернуть его
    ▪ unshift   | Удалить 1-й эл-т и вернуть его
    ▪ splice    | Добавить/Удалить указанные эл-ты массива
    ▪ sort      | Отсортировать массив
    ▪ reverse   | Изменить порядок эл-в в массиве на обратный

  # Методы, не изменяющие наблюдаемый массив

    ▪ filter    | Отфильтровать массив
    ▪ concat    | Сложить массивы
    ▪ slice     | Вернуть копию части исходного массива

  # Vue не заметит: вставку по индексу / изменение длины массива

    ▪ Вставка по индексу
    ▪ Явное изменение длины массива

  # Техника массивов-наследников

--------------------------------------

> Ссылки

  # [Официальноу руководство] Рендеринг списков
      https://ru.vuejs.org/v2/guide/list.html

> Введение
  - Эта глава про рендеринг списков в Vue, и его особенности.
  - Для этого применяется директива v-for.

> Основное отличие v-for от for в knockout
  - В KO for применялся к элементу-обёртке. При этом 
    циклично рендерилось его содержимое.
  - В Vue for применяется к самому элементу, который
    и будет циклично рендериться.
  - Поначалу это может сбить вас с толку, если вы 
    переходите на Vue с Knockout.

> Простой пример использования v-for

  • Шаблон
    - Здесь видно, что v-for применён к <li>, а не к <ul>.
    - Если бы дело было в knockout, for бы применили к <ul>.
    - Код:

      <ul id="example-1">
        <li v-for="item in items">
          {{ item.message }}
        </li>
      </ul>

  • Модель

      var example1 = new Vue({
        el: '#example-1',
        data: {
          items: [
            { message: 'Foo' },
            { message: 'Bar' }
          ]
        }
      })

> Индекс и контекст в v-for

  • Контекст в v-for
    - Также отличается от того, что происходило в knockout.
    - В knockout внутри for мы находились в контексте текущего эл-та.
    - А в Vue даже внутри v-for мы находимся в контексте модели.
    - Пример: см.ниже.

  • Индекс в v-for
    - Вторым аргументом можно получать индекс v-for.
    - См.пример ниже.

  • Пример контекста и индекса в v-for

    ▪ Шаблон

      <ul id="example-2">
        <li v-for="(item, index) in items">
          {{ parentMessage }} - {{ index }} - {{ item.message }}
        </li>
      </ul>  

    ▪ Модель

      var example2 = new Vue({
        el: '#example-2',
        data: {
          parentMessage: 'Родитель',
          items: [
            { message: 'Foo' },
            { message: 'Bar' }
          ]
        }
      })

> Разделитель: in / of
  - Разделителем в v-for могут бать in / of.
  - Никакой разницы нет.
  - Пример:

      <div v-for="item of items"></div>

> Использование v-for с псевдоэлементом <template>
  - Директиву v-for можно использовать с <template>
  - Пример:

      <ul>
        <template v-for="item in items">
          <li>{{ item.msg }}</li>
          <li class="divider"></li>
        </template>
      </ul>  

> Использование v-for с объектом
  
  • Итерирование по св-вам объектов
    - v-for можно также использовать для итерирования по св-вам объектов.

  • Пример использования v-for с объектом

    ▪ Шаблон

      ▪ Вариант с 1 аргументом

          <ul id="repeat-object" class="demo">
            <li v-for="value in object">
              {{ value }}
            </li>
          </ul>  

      ▪ Вариант с 2 аргументами
        - В key можно получать ключи.
        - Код:

          <div v-for="(value, key) in object">
            {{ key }} : {{ value }}
          </div>

      ▪ Вариант с 3 аргументами
        - В index можно получать индексы.
        - Код: 

          <div v-for="(value, key, index) in object">
            {{ index }}. {{ key }} : {{ value }}
          </div>

  • Порядок обхода не гарантируется
    - И зависит от от разных реализаций движкой JS.
    - Но вообще, он д.б. такой же, как порядок ключей в Object.keys().

> Отрисовка DOM-элемента N раз путём передачив v-for целого числа
  - В v-for можно передать целое число N.
  - Тогда DOM-элемент будет отрисован N раз.
  - Пример (1 2 3 4 5 6 7 8 9 10):

      <div>
        <span v-for="n in 10">{{ n }} </span>
      </div>  

> Компоненты и v-for

  • v-for можно использовать на пользовательских компонентах
    - Например:

      <my-component v-for="item in items" :key="item.id"></my-component>

  • Необходимо указывать key
    
    ▪ Key обязателен с v-for, начиная с v2.2.0
      - Начиная с v2.2.0 key теперь обязателен при использовании с v-for.
    
    ▪ "Стратегия по умолчанию", или "обновление на месте"
      - До v2.2.0 была опция не указывать key с v-for.
      - Тогда Vue использовал стратегию "обновления на месте".
      - Например, порядок элементов массива/объекта изменился.
      - Vue не будет перемещать эл-ты DOM, а просто обновит каждый "на месте".
      - Чтобы он отображал новые данные по соотв.индексу.

    ▪ Для чего Vue использует key
      - В качестве уникального ID элемента внутри соответствующего v-for.
      - Key позволяет Vue отслеживать идентичность каждого элемента.
      - Что позволяет переиспользовать и перемещать существующие эл-ты.
      - Вообще, механизм key является общим идентификационным механизмом в Vue,
        и может быть использован и в других, не связанных с v-for случаях.

  • Данные в компонент надо передавать вручную
    - Т.Е., автоматически данные в v-for в компонент не передаются.
    - Ведь компоненты имеют изолированные области видимости, и если бы
      данные автоматически передавались, это бы сделало компонент
      жёстко связанным с логикой работы v-for.
    - Для передачи данных нужно явно использовать входные параметры.
    - Например:

        <my-component
          v-for="(item, index) in items"
          v-bind:item="item"
          v-bind:index="index"
          v-bind:key="item.id">
        </my-component>

  • Полный пример простого ToDo на компонентах и v-for

    ▪ Шаблон

      <div id="todo-list-example">
        <input
          v-model="newTodoText"
          v-on:keyup.enter="addNewTodo"
          placeholder="Добавить todo"
        >
        <ul>
          <li
            is="todo-item"
            v-for="(todo, index) in todos"
            v-bind:key="todo"
            v-bind:title="todo"
            v-on:remove="todos.splice(index, 1)"
          ></li>
        </ul>
      </div>

    ▪ Компонент элемента списка

      Vue.component('todo-item', {
        template: `
          <li>
            {{ title }}
            <button v-on:click="$emit('remove')">X</button>
          </li>
        `,
        props: ['title']
      })

    ▪ Модель

      new Vue({
        el: '#todo-list-example',
        data: {
          newTodoText: '',
          todos: [
            'Вымыть посуду',
            'Вынести мусор',
            'Подстричь газон'
          ]
        },
        methods: {
          addNewTodo: function () {
            this.todos.push(this.newTodoText)
            this.newTodoText = ''
          }
        }
      })    


> v-for и v-if в одном элементе

  • У v-for приоритет больше, чем у v-if
    - Как следствие, см.следущий пункт.

  • v-if будет выполняться на каждой итерации
    - Что достаточно удобно.
    - Например, выведем только те ToDo, что ещё не выполнены:

      <li v-for="todo in todos" v-if="!todo.isComplete">
        {{ todo }}
      </li>

    - А если надо запускать сам цикл по условию,
      придётся поставить v-if на внешний элемент:

      <ul v-if="shouldRenderTodos">
        <li v-for="todo in todos">
          {{ todo }}
        </li>
      </ul>      

> Методы, которыми можно изменить наблюдаемый массив
  - Эти методы применяются обычным для JS образом.
  - Они изменяют наблюдаемый массив, и Vue перерисовывает DOM.
  - См.их список в оглавлении главы.

> Методы, не изменяющие наблюдаемый массив
  - Такие, как: filter, concat, slice.
  - Их применение на наблюдаемом массиве вернёт новый массив.
  - Но никто не запрещает заменить старый массив новым:

      example1.items = example1.items.filter(function (item) {
        return item.message.match(/Foo/)
      })  

  - Можно подумать, что это будет очень тяжёлой операцией.
  - И что Vue будет перерисовывать весь массив в DOM.
  - Но, как уверяют авторы, Vue всё сделает по-умному и оч.легко.
  - См.их список в оглавлении главы.

> Vue не заметит: вставку по индексу / изменение длины массива

  ▪ Вставка по индексу
    - vm.items[indexOfItem] = newValue
    - Такое Vue не заметит, и ничего не произойдёт.
    - Есть 2 варианта обхода:

      // Vue.set
      Vue.set(example1.items, indexOfItem, newValue) 

      // Array.prototype.splice
      example1.items.splice(indexOfItem, 1, newValue)

  ▪ Явное изменение длины массива
    - vm.items.length = newLength
    - Такое Vue не заметит, и ничего не произойдёт.
    - Есть варианта обхода:

      // Array.prototype.splice
      example1.items.splice(newLength)

> Техника массивов-наследников
  - Допустим, есть у нас в модели первый наблюдаемый массив.
  - А нам нужен другой, но основанный на этом, второй массив.
  - Второй должен автоматически изменяться при изменении первого.
  - Тогда, просто добавляем в модель второй массив.
  - И с помощью вычисляемой перенаполняем его всякий раз при изменении первого.

А10. Обработка событий

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Подписка на события: v-on
  # Методы, как обработчики событий

    ▪ Использование методов, как обработчиков событий
    ▪ Пример №1: указать имя метода в v-on
    ▪ Пример №2: вызвать метод в js-выражении в v-on
    ▪ Пример №3: доступ к объекту-событию в методе

  # Модификаторы событий

    ▪ Что такое модификаторы событий?
    ▪ Модификаторы событий можно чейнить
    ▪ Можно опускать пользовательский обработчик
    
    ▪ .stop       | Событие не будет всплывать дальше
    ▪ .prevent    | Предотвратить действие браузера по умолчанию
    ▪ .capture    | Приказать обработчику срабатывать на стадии перехвата события
    ▪ .self       | Обрабатывать лишь возникшее на этом эл-те событие
    ▪ .once       | Приказать обработчику события сработать лишь 1 раз

  # Модификаторы событий клавиатуры

    ▪ Что такое модификаторы событий клавиатуры?
    ▪ Алиасы для распространённых keyCodes

      ▪ .N        | [общий случай] Где N - keyCode клавиши
      ▪ .enter    | Класиша enter
      ▪ .tab      | Класиша enter
      ▪ .delete   | Клавиши delete и backspace
      ▪ .esc      | Класиша esc 
      ▪ .space    | Класиша space
      ▪ .up       | Класиша up
      ▪ .down     | Класиша down
      ▪ .left     | Класиша left
      ▪ .right    | Класиша right 

    ▪ Алиасы для клавиш-модификаторов

      ▪ .ctrl     | Класиша ctrl 
      ▪ .alt      | Класиша alt 
      ▪ .shift    | Класиша shift 
      ▪ .meta     | Класиша meta 

    ▪ Добавление кастомных алиасов через Vue.config.keyCodes

  # Модификаторы событий мыши

    ▪ Что такое модификаторы событий мыши?

    ▪ .left       | Левая кнопка мыши
    ▪ .right      | Правая кнопка мыши
    ▪ .middle     | Средняя кнопка мыши

--------------------------------------

> Ссылки

  # [Официальноу руководство] Обработка событий
      https://ru.vuejs.org/v2/guide/events.html

> Введение
  - В этой главе описана работа с событиями в Vue.

> Подписка на события: v-on
  - Подписаться на события можно через директиву v-on.
  - Пример:

    • Шаблон

      <div id="example-1">
        <button v-on:click="counter += 1">+1</button>
        <p>Кнопка выше была нажата {{counter}} раз</p>
      </div>

    • Модель

      var example1 = new Vue({
        el: '#example-1',
        data: {
          counter: 0
        }
      })

> Методы, как обработчики событий
  
  • Использование методов, как обработчиков событий
    - Можно, конечно, для обработки событий использовать js-выражения.
    - Как, например, это сделано в примере выше.
    - Но чище всё же выделять под это дело отделный метод.

  • Пример №1: указать имя метода в v-on

    ▪ Шаблон

      <div id="example-2">
        <!-- `greet` — это название метода, определённого ниже -->
        <button v-on:click="greet">Поприветствовать</button>
      </div> 

    ▪ Модель

      var example2 = new Vue({
        el: '#example-2',
        data: {
          name: 'Vue.js'
        },
        // определяйте методы в объекте `methods`
        methods: {
          greet: function (event) {
            // `this` внутри методов указывает на экземпляр Vue
            alert('Привет, ' + this.name + '!')
            // `event` — нативное событие DOM
            if (event) {
              alert(event.target.tagName)
            }
          }
        }
      })

  • Пример №2: вызвать метод в js-выражении в v-on

    ▪ Шаблон

      <div id="example-3">
        <button v-on:click="say('hi')">Скажи hi</button>
        <button v-on:click="say('what')">Скажи what</button>
      </div>

    ▪ Модель

      new Vue({
        el: '#example-3',
        methods: {
          say: function (message) {
            alert(message)
          }
        }
      })

  • Пример №3: доступ к объекту-событию в методе
    - В knockout объект-событие автоматом передавалось в метод.
    - В Vue оно тоже передаётся, но лишь при вызове метода по имени в v-on.
    - А при inline-вызове метода в js-выражении надо $event передавать вручную:

      ▪ Шаблон

        <button v-on:click="warn('Форма пока не может быть отправлена.', $event)">
          Отправить
        </button>

      ▪ Модель

        // ...
        methods: {
          warn: function (message, event) {
            // теперь у нас есть доступ к нативному событию
            if (event) event.preventDefault()
            alert(message)
          }
        }

> Модификаторы событий

  • Что такое модификаторы событий?
    - Они изменяют некоторые св-ва процесса обработки событий.
    - Вроде prevent default или stop propagation.
    - Конечно, можно было бы делать всё это внутри метода-обработчика.
    - Но было бы лучше сохранить чистоту логики и абстрагироваться
      от деталей реализации событий DOM.
    - Для решения этой задачи Vue и предлагает модификаторы событий для v-on.
    - Напомним, модификаторы директив указываются, как постфиксы, и отделяются точкой.

  • Модификаторы событий можно чейнить
    - Например:

      <a v-on:click.stop.prevent="doThat"></a>

  • Можно опускать пользовательский обработчик
    - Например:

      <form v-on:submit.prevent></form>

  • .stop  
    - Событие не будет всплывать дальше.
    - Пример:

      <a v-on:click.stop="doThis"></a>

  • .prevent
    - Предотвратить действие браузера по умолчанию.
    - Пример:

      <form v-on:submit.prevent="onSubmit"></form>

  • .capture
    - Приказать обработчику срабатывать на стадии перехвата события.
    - Подробнее про стадии перехвата/всплытия события см.здесь:
        https://learn.javascript.ru/event-bubbling#погружение
    - Пример:

      <div v-on:click.capture="doThis">...</div>

  • .self
    - Обрабатывать лишь возникшее на этом эл-те событие.
    - И игнорировать транзитные события (стадии перехвата/всплытия).
    - Пример:

      <div v-on:click.self="doThat">...</div>

  • .once
    - Приказать обработчику события сработать лишь 1 раз.
    - В отличие от остальных модификаторов, которые поддерживают
      исключительно нативные DOM-события, модификатор .once можно
      использовать и в пользовательских событиях компонентов.
    - Пример:

      <a v-on:click.once="doThis"></a>

> Модификаторы событий клавиатуры

  • Что такое модификаторы событий клавиатуры?
    - При нажатии какой-либо клавиши возбуждаются соотв.события.
    - В объекте-событии есть key code нажатой клавиши.
    - По нему мы и можем понять, какая же клавиша была нажата.
    - Обычный сценарий обработки событий клавиатуры таков:

      1. Смотрим keyCode.
      2. Если keyCode не тот, что нас интересует, ничего не делаем.
      3. Если keyCode тот, то продолжаем обработку.

    - Vue предлагает сэкономить время на этом сценарии.
    - И для этого выкатывает модификаторы событий клавиатуры.
    - С их помощью можно сразу указать, какие key code нас интересуют.
    - И обработчик просто не будет срабатывать с другими.
    - Причём, т.к. модификаторы можно чейнить, можно указать много key code'ов.

  • Алиасы для распространённых keyCodes
    - Полный список алиасов см.в оглавлении.
    - Ниже приведём несколько примеров:

      ▪ .N 
        - [общий случай] Где N - keyCode клавиши
        - Пример:

          <input v-on:keyup.13="submit">

      ▪ .enter
        - Класиша enter.
        - Пример:

          <input v-on:keyup.enter="submit">
          <input @keyup.enter="submit">       | сокращённая запись

  • Алиасы для клавиш-модификаторов
    - Полный список алиасов см.в оглавлении.
    - Ниже приведём несколько примеров:

      ▪ Alt + C

          <input @keyup.alt.67="clear">

      ▪ Ctrl + Click

          <div @click.ctrl="doSomething">Сделать что-нибудь</div>

  • Добавление кастомных алиасов через Vue.config.keyCodes
    - Например, определим алиас для клавиши f1:

        Vue.config.keyCodes.f1 = 112


А11. Работа с формами

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Двунаправленное связывание: v-model
  
    ▪ Директива v-model для элементов input и textarea
    ▪ V-model игнорирует атрибуты value, checked, selected

  # Работа с input
  # Работа с textarea
  # Работа с чекбоксами

    ▪ Биндинг 1-го чекбокса с 1-им св-вом модели
    ▪ Биндинг N чекбоксов с массивом N св-во модели
    ▪ v-bind для привязки value чекбокса к св-ву модели

  # Работа с радиобуттонами

    ▪ Пример №1: работа с радиобуттонами
    ▪ Пример №2: v-bind для привязки value радиобуттона к св-ву модели

  # Работа с селектами

    ▪ "Не выбранное" состояние селекта
    ▪ Выбор единственного значения
    ▪ Выбор нескольких значений (привязка к массиву)
    ▪ Динамическое отображение опций с помощью v-for
    ▪ v-bind для привязки value опций селекта к св-вам модели

  # Модификаторы для v-model

    ▪ .lazy     | Синхронизация не по событию input, а по change
    ▪ .number   | Приводить ввод к числу
    ▪ .trim     | Автоматически обрезать пробелы по краям

  # Использование v-model с компонентами

--------------------------------------

> Ссылки

  # [Официальноу руководство] Работа с формами
      https://ru.vuejs.org/v2/guide/forms.html

> Введение
  - В этой главе описана работа с формами в Vue.

> Двунаправленное связывание: v-model
  
  • Директива v-model для элементов input и textarea
    - Директивы v-model реализвут 2-направленное связывание.
    - Она работает с DOM-элементами input и textarea.
    - Принцип работы такой же, как в knockoutjs.

  • V-model игнорирует атрибуты value, checked, selected
    - Которые она найдёт на любых элементах форм.
    - Модель Vue всегда будет источником истины.
    - Поэтому, начальное значение надо объявлять в модели.

> Работа с input
  - Представим, что в модели есть св-во message.
  - Организуем его 2-направленный биндинг text input:

      <input v-model="message" placeholder="отредактируй меня">
      <p>Введённое сообщение: {{ message }}</p>

> Работа с textarea
  - Представим, что в модели есть св-во message.
  - Причём, интерполяция внутрь тега работат НЕ БУДЕТ:

      <textarea>{{text}}</textarea>   // Работать не будет

  - Организуем его 2-направленный биндинг textarea:  

      <span>Введённое многострочное сообщение:</span>
      <p style="white-space: pre">{{ message }}</p>
      <br>
      <textarea v-model="message" placeholder="введите несколько строчек"></textarea>

> Работа с чекбоксами

  • Биндинг 1-го чекбокса с 1-им св-вом модели

      <input type="checkbox" id="checkbox" v-model="checked">
      <label for="checkbox">{{ checked }}</label>

  • Биндинг N чекбоксов с массивом N св-во модели

    ▪ Шаблон

      <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
      <label for="jack">Jack</label>
      <input type="checkbox" id="john" value="John" v-model="checkedNames">
      <label for="john">John</label>
      <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
      <label for="mike">Mike</label>

      <span>Отмеченные имена: {{ checkedNames }}</span>    

    ▪ Модель

      new Vue({
        el: '...',
        data: {
          checkedNames: []
        }
      })

  ▪ v-bind для привязки value чекбокса к св-ву модели

    <input
      type="checkbox"
      v-model="toggle"
      v-bind:true-value="a"
      v-bind:false-value="b"
    >

> Работа с радиобуттонами

  • Пример №1: работа с радиобуттонами

    <input type="radio" id="one" value="One" v-model="picked">
    <label for="one">One</label>
    
    <input type="radio" id="two" value="Two" v-model="picked">
    <label for="two">Two</label>
    
    <span>Выбрано: {{ picked }}</span>

  • Пример №2: v-bind для привязки value радиобуттона к св-ву модели
    - Привязываем value радиобуттона к св-ву pick модели

      <input type="radio" v-model="pick" v-bind:value="a">  

> Работа с селектами

  • "Не выбранное" состояние селекта
    - В примере ниже начальное значение св-ва selected пустое.
    - Оно не совпадает ни с одним из вариантов option в списке.
    - Поэтому, при загрузке селект будет отображаться в "disabled"-состоянии.
    - Тут у нас есть 2 варианта:

      ▪ [наш выбор] Добавить доп.option для состояния по умолчанию
        - В нашем примере, для состояния со значением "".
        - Эта опция идёт с атрибутом disabled в примере ниже.

      ▪ Не добавлять доп.option для состояния по умолчанию
        - Это плохо, т.к. в iOS элемент будет сломан.
        - При выборе опции не будет генерироваться событие changed.

  • Выбор единственного значения

    ▪ Шаблон

      <select v-model="selected">
        <option disabled value="">Выберите один из вариантов</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
      </select>
      <span>Выбрано: {{ selected }}</span>

    ▪ Модель

      new Vue({
        el: '...',
        data: {
          selected: ''
        }
      })    

  • Выбор нескольких значений (привязка к массиву)

      <select v-model="selected" multiple>
        <option>A</option>
        <option>B</option>
        <option>C</option>
      </select>
      <br>
      <span>Выбрано: {{ selected }}</span>

  • Динамическое отображение опций с помощью v-for
    - Просто добавляем в модель массив объектов.
    - И внутри select с помощью v-for разворачиваем.
    - Пример:

      ▪ Шаблон

          <select v-model="selected">
            <option v-for="option in options" v-bind:value="option.value">
              {{ option.text }}
            </option>
          </select>
          <span>Выбрано: {{ selected }}</span>

      ▪ Модель

          new Vue({
            el: '...',
            data: {
              selected: 'A',
              options: [
                { text: 'One', value: 'A' },
                { text: 'Two', value: 'B' },
                { text: 'Three', value: 'C' }
              ]
            }
          })

  • v-bind для привязки value опций селекта к св-вам модели

    <select v-model="selected">
      <!-- inline object literal -->
      <option v-bind:value="{ number: 123 }">123</option>
    </select>

> Модификаторы для v-model

  • .lazy
    - Синхронизация не по событию input, а по change.
    - По умолчанию, v-model синхронизируется при каждом input.
    - Но можно приказать, чтобы по каждому change, а не input.
    - Например:

      <input v-model.lazy="msg">

  • .number
    - Приводить ввод к числу.
    - Это полезно, т.к. даже с type="number", значение input
      всегда возвращается в виде строки.
    - Например:

      <input v-model.number="age" type="number">

  • .trim
    - Автоматически обрезать пробелы по краям.
    - Например:

      <input v-model.trim="msg">

> Использование v-model с компонентами
  - Стандартные input'ы не всегда отвечают нашим требованиям.
  - Но можно сделать свой input в виде Vue-компонента.
  - И его поведение может сильно отличаться от стандартного.
  - Причём, он даже будет работать с v-model.
  - Подробнее см.следующую главу про компоненты, и там раздел
    про кастомные инпуты.


А12. Компоненты

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Модульный подход к разработке фронтенд-приложений
  # -------------------------------------------------

    ▪ Множество компонентов
    ▪ Независимость и самодостаточность компонентов
    ▪ Повторное использование компонентов
    ▪ Дерево/лес компонентов
    ▪ API компонента
    ▪ Компонент, как чёрный ящик
    ▪ Взаимодействие компонентов
    ▪ Версии компонентов
    ▪ Сторонние библиотеки компонентов
    ▪ Делегирование разработки компонентов субподрядчикам
    ▪ Скоростная разработка фронтенд-приложения

  # Использование компонентов
  # -------------------------

    • Регистрация компонента

      ▪ Регистрация компонента глобально
        - Должна производиться ДО создания корневого vue-экземпляра
        - Пример регистрации компонента глобально
      ▪ Регистрация компонента локально (инкапсуляция)
        - Опция components: рендерить компонент лишь в шаблоне родителя
        - Пример регистрации компонента локально

    • Особенности парсинга DOM-шаблона

      ▪ Доступные в Vue источники шаблонов
        - DOM-шаблон
        - <script type="text/x-template">
        - inline-строки JavaScript
        - .vue-компоненты
      ▪ Ограничения HTML, влияющие на Vue
        - Атрибут is: обойти ограничения, возникающие в DOM-шаблоне?
        - Совет: пользуйся inline- или .vue-шаблоном

    • В компоненте data д.б. ф-ией, возвращающей объект
      ▪ Как делать НЕ ЖЕЛАТЕЛЬНО: передавать объект в data
      ▪ Как РЕКОМЕНДУЕТСЯ делать: генерировать объект в data анон.ф-ией    

    • Взаимодействие родственных компонентов: параметры вниз, события вверх
      ▪ Родитель -> Потомок : входные параметры
      ▪ Потомок -> Родитель : возбуждение событий
      ▪ Принцип относительной изоляции компонентов

  # Входные параметры
  # -----------------

    • Передача данных через props: родитель -> потомок
      ▪ У потомка нет доступа к моделям предков
      ▪ Опция props: передача данных из родителя в потомка
      ▪ Пример использования props без валидации

    • Способы передачи входных параметров
      ▪ Через HTML-атрибут в элементе-компоненте
      ▪ Через v-bind связывать параметр с наблюдаемой родителя
        - Я рекомендую пользоваться этим способом
        - Пример передачи ссылка на наблюдаемую родителя в кач-ве параметра

    • Валидация входных параметров
      ▪ Валидация определяется в опции props
      ▪ Опции валидации
        - default     | задать значение по умолчанию
        - type        | валидация типа значения
        - validator   | пользовательская функция-валидатор
        - required    | обязательное значение
      ▪ Доступные значения для type (все JS-типы)

    • Концепция однонаправленного потока данных
      ▪ Позволяет легче понимать структуру потоков данных в приложении
      ▪ Не меняй вручную значения входных параметров

  # Пользовательские события
  # ------------------------

    • Система кастомных событий Vue
      ▪ Независима от браузерной
      ▪ Методы интерфейса событий Vue
        - $on       | Назначить обработчик кастомного события
        - $emit     | Возбудить кастомное событие

    • Способы коммуникации между компонентами
      
      ▪ v-on: родительский компонент <--- дочерний компонент
        - Только родитель-дочка
        - Нельзя использовать $on, нет доступа к модели дочки
        - Надо использовать v-on, на примере

      ▪ Через вспомогательный vue-экземпляр: связь для не-родственников
        - Подходит для простых приложений
        - Подходит для связи между любыми компонентами
        - Принцип связи: через вспомогательный vue-экземпляр
        - Пример связи через вспомогательный vue-экземпляр

      ▪ Через vuex
        - Подходит для средних и крупных SPA-приложений
        - Публичная/Приватная части модели компонента
        - Что такое vuex

    • Модификаторы .sync, .native; директива v-model

      ▪ Модификатор .sync: работает через систему событий Vue
      ▪ Модификатор .native: обрабатывать события из браузера
      ▪ Директива v-model: лишь синтаксический сахар
        - Как она работает
        - Как застаить работать v-model с компонентом

  # Слоты: распределение контента




--------------------------------------


> Ссылки

  # [Официальноу руководство] Компоненты
      https://ru.vuejs.org/v2/guide/components.html

> Введение
  - Эта глава описывает работу с vue-компонентами.
  - Также рассмотрен модульный подход к разработке.

> Модульный подход к разработке фронтенд-приложений

  • Приложение, как набор компонентов
    - Любое фронтенд-приложение можно разложить на N компонентов.

  • Независимость и самодостаточность компонентов
    - Каждый компонет должен быть независим и самодостаточен.
    - Он не должен иметь никаких связей с внешним контекстом.
    - В идеале, должна быть 100% автономность и независимость.

  • Повторное использование компонентов
    - Независимые самодостаточные компоненты легко повторно использовать.
    - Особенно если в их дизайн заложены гибкость и универсальность.

  • Дерево/лес компонентов
    - Приложение не является бесструктурной кучей компонентов.
    - Приложение представляет из себя дерево/лес компонентов.
    - Корнем дерева является vue-экземпляр.
    - Узлами в ветвях дерева являются vue-компоненты.

  • API компонента
    - Каждый компонент имеет API для взаимодействия с ним.
    - API компонентов состоит из 3-х частей:

      ▪ Входные параметры
        - Позволяют передавать в компонент данные извне.

      ▪ События 
        - Позволяют компонентам воздействовать на внешнее окружение.

      ▪ Слоты 
        - Позволяют внешнему окружению дополнять компоненты новым контентом.

  • Компонент, как чёрный ящик
    - К компоненту можно относиться, как к чёрному ящику.
    - Достаточно знать API компонента, чтобы работать с ним.
    - Поэтому, можно легко использовать чужие компоненты, зная их API.

  • Взаимодействие компонентов

    ▪ Взаимодействие потомка и предка
      - Т.Е. компонентов, состоящих в 1-й ветке 1-го дерева.
      - Предок может передавать параметры при создании потомка.
      - Предок может дополнять потомка новым контентом через слоты.
      - Потомок может слать события предку после своего создания.

  • Версии компонентов
    - Можно испольозвать версионный контроль для работы с компонентами.
    - Код компонента хранить, например, в git-репозитории.
    - Обеспечивать обратную совместимость для минорных версий и патчей.
    - И прочее.

  • Сторонние библиотеки компонентов
    - Другие разработчики создали и создадут много компонентов.
    - На это было и будет затрачено огромное количество человеко-часов.
    - Было бы преступной халатностью не использовать эти наработки.
    - Благодаря модульному подходу, делать это стало проще.
    - Ведь при таком подходе, не обязательно разбираться в чужом коде.
    - Достаточно знать API компонента, чтобы его использовать.

  • Делегирование разработки компонентов субподрядчикам
    - Модульный подход позволяет не вникать в код компонента.
    - Поэтому, их разработку можно смело поручать субподрядчикам.
    - Примерный процесс таков:

      ▪ Даёшь ему задание
        - Нужен vue-компонент.
        - Должен выглядеть и работать так-то.
        - Описываешь его API:
            Должен принимать такие-то параметры.
            Должен генерировать такие-то события.
            Должен работать с такими-то слотами.
  
      ▪ Когда готово, всё проверяешь
        - Наискосок пробегаешь код компонента.
        - Вставляешь компонент в своё приложение.
        - Тестируешь, всё ли работает правильно.
        - Если что-то не ОК, просишь доработать.
        - Если всё ОК, платишь и прощаешься.

  • Скоростная разработка фронтенд-приложения
    - Ключ к успеху в параллельной разработке N компонентов.
    - Допустим, над каждым компонентом трудится отдельный разработчик.
    - Чем больше разработчиков одновременно работают, тем быстрее идёт процесс.
    - Но важно также успевать обслуживать это дело:

      ▪ Успевать качественно осуществлять проектирование
      ▪ Успевать готовить задачи на разработку следующих компонентов
      ▪ Успевать принимать и интегрировать готовые компоненты

> Использование компонентов

  # Регистрация компонента

    • Регистрация компонента глобально

      ▪ Должна производиться ДО создания корневого vue-экземпляра
        - Чтобы оный имел понятие о существовании соответствующего компонента.
        - И мог узнать и соотв.образом обработать его во время компиляции.

      ▪ Пример регистрации компонента глобально

        ▪ Регистрация

          Vue.component('my-component', {
            template: '<div>Пользовательский компонент!</div>'
          })

        ▪ Создание корневого экземпляра

          new Vue({
            el: '#example'
          })

        ▪ Использование

          <div id="example">
            <my-component></my-component>
          </div>  
        
        ▪ Результат рендеринга

          <div id="example">
            <div>Пользовательский компонент!</div>
          </div>          

    • Регистрация компонента локально (инкапсуляция)

      ▪ Опция components: рендерить компонент лишь в шаблоне родителя
        - Доступна конструкторе vue-экземпляра или vue-компонента.
        - Она содержит объект, в котором можно регистрировать компоненты.
        - Ключ: имя компонента, значение: конструктор компонента.
        - Vue будет рендерить этот компонент только в шаблоне соотв.экземпляра/компонента.
        - Пример см.ниже.

      ▪ Пример регистрации компонента локально

        new Vue({
          // ...
          components: {
            // <my-component> будет доступен только в шаблоне родителя
            'my-component': {
              template: '<div>Пользовательский компонент!</div>'
            }
          }
        })   

  # Особенности парсинга DOM-шаблона

    • Доступные в Vue источники шаблонов

      ▪ DOM-шаблон
        - В конструкторе Vue есть опция "el".
        - В ней можно указать селектор для поиска элемента в DOM.
        - DOM этого элемента и будет использован в качестве шаблона.
        - Пример селектора: "#elementID".

      ▪ <script type="text/x-template">
        - Шаблон можно определить внутри элемента script.
        - У него ещё должен бать атрибут type="text/x-template".
        - В опции template можно вписать указывающий на script селектор.
        - Содержимое script будет использовано в качестве шаблона.
        - Автор советует избегать такого подхода, т.к. шаблон т.о.
          отделяется от остального определения компонента.
        - Пример:

            <script type="text/x-template" id="hello-world-template">
              <p>Привет привет привет</p>
            </script> 

            Vue.component('hello-world', {
              template: '#hello-world-template'
            })

      ▪ inline-строки JavaScript
        - В опцию template конструктора Vue можно вписать HTML-код.
        - Этот код и станет шаблоном.
        - Пример:

            Vue.component('terms-of-service', {
              template: '\
                <div v-once>\
                  <h1>Условия Использования</h1>\
                  ... много-много статического контента ...\
                </div>\
              '
            })        

      ▪ .vue-компоненты
        - Речь идёт об одновайловых компонентах .vue
        - В них используют псевдо-элемент <template></template>.
        - Компонент использует содержащийся в нём HTML-код в качестве шаблона.

          <template>
            <p>{{ greeting }} World!</p>
          </template>

    • Ограничения HTML, влияющие на Vue
      
      ▪ DOM-шаблон и ограничения из-за парсинга браузером
        - Описанные ограничений действуют только для DOM-шаблонов.
        - И не действуют для остальных типов шаблонов
          (которые попадают прямо в Vue без доп.обработки браузером).
        - Вот, что происходит для DOM-шаблона:

          ▪ Сначала браузер парсит HTML-код.
            - Он его обрабатывает и нормализует.
            - Применяет к нему все правила HTML.
            - При этом определённые сочетания эл-в могут
              не соответствовать нормам языка HTML.
            - Например, есть ограничение, какие эл-ты могут находиться
              внутри эл-в: <ul>, <ol>, <table>, <select>;
              Для некоторых других элементов, например <option>,
              ограничен список допустимых родительских элементов.
            - В итоге, в такой ситуции:

                <table>
                  <my-row>...</my-row>
                </table>   
                
            - браузер просто отбросит компонент my-row.
            - И до Vue он просто не доберётся.           

      ▪ Атрибут is: обойти ограничения, возникающие в DOM-шаблоне?
        - Использование этого способа похоже, честно говоря, на костыль.
        - Мы просто вставляем то, чего ожидает увидеть браузер.
        - Например, в <table> помещаем элемент <tr>.
        - А элементу назначаем атрибут is с именем компонента.
        - В итоге, всё это доходит без изменений до компилятора Vue.
        - И тот, видя атрибут is, заменяет <tr> на шаблон компонента.
        - Пример:

            <table>
              <tr is="my-row"></tr>
            </table>        

      ▪ Совет: пользуйся inline- или .vue-шаблоном
        - Чтобы избежать обозначенных выше проблем/костылей.


  # В компоненте data д.б. ф-ией, возвращающей объект
    - Один компонент может быть использован много раз.
    - Поэтому нельзя в конструктор передавать вещи по ссылке.
    - Проще объяснить на примере:

      ▪ Как делать НЕ ЖЕЛАТЕЛЬНО: передавать объект в data
        - В этом примере передаём объект в data.
        - Каждый экземпляр будет ссылаться именно на этот объект.
        - Т.Е. при изменении его в 1-ом, он изменится во всех экземплярах.
        - Код:

          Vue.component('my-component', {
            template: '<span>{{ message }}</span>',
            data: {
              message: 'привет!'
            }
          })        

      ▪ Как РЕКОМЕНДУЕТСЯ делать: генерировать объект в data анон.ф-ией
        - Не надо передавать в конструктор объект.
        - Надо генерировать новый объект анонимной функцией.
        - Так, у каждого экземпляра будет свой объект в data.
        - Код:

          Vue.component('my-component', {
            template: '<span>{{ message }}</span>',
            data: unction () {
              return {
                counter: 0
              }
            }
          })  

  # Взаимодействие родственных компонентов: параметры вниз, события вверх
    
    ▪ Родитель -> Потомок : входные параметры
      - Родитель передаёт данные потомку с помощью входных параметров.
    
    ▪ Потомок -> Родитель : возбуждение событий
      - Потомок передаёт данные родителю, возбуждая события, который последний перехватывает.

    ▪ Принцип относительной изоляции компонентов
      - Такой подход упродает поддержку кода.
      - И потенциально облегчает повторное использование компонентов.

> Входные параметры

  # Передача данных через props: родитель -> потомок

    • У потомка нет доступа к моделям предков
      - Каждый экземпляр vue-компонента имеет изолированную область видимости.
      - Потомок не может прямо из своего шаблона обращаться к модели родителя.

    • Опция props: передача данных из родителя в потомка
      - В опции props потомка можно разместить массив.
      - В этом массиве перечислить ожидаемые входные параметры.
      - Здесь же можно провести и валидацию (о ней ниже).

    • Пример использования props без валидации

        Vue.component('child', {
          props: ['myMessage'],
          template: '<span>{{ myMessage }}</span>'
        })    

  # Способы передачи входных параметров

    • Через HTML-атрибут в элементе-компоненте
      - Допустим, есть у нас компонент child.
      - И есть у него в props параметр message.
      - Вот, как можно передать туда простой литерал:

        <child message="привет!"></child>

    • Через v-bind связывать параметр с наблюдаемой родителя
      
      ▪ Я рекомендую пользоваться этим способом
        - Я думаю, метод через HTML-атрибут менее популярен.
        - А более популярно передавать ссылку на наблюдаемую родителя.
        - И даже, если хочешь передать литерал, всё равно.
        - Просто это более универсальный способ передачи параметров.

      ▪ Пример передачи ссылка на наблюдаемую родителя в кач-ве параметра
        - Допустим, есть у нас компонент child.
        - И есть у него в props параметр message.
        - У него есть также какой-то компонент-родитель.
        - У последнего в модели есть наблюдаемая parentMsg.
        - И мы хотим передать ссылку на parentMsg в message.
        - Сделать это можно через v-bind:

          <child v-bind:my-message="parentMsg"></child>
          <child :my-message="parentMsg"></child>         // сокращённая запись для v-bind  

  # Валидация входных параметров

    • Валидация определяется в опции props

      Vue.component('example', {
        props: {
          propA: Number,                // простая проверка типа (`null` означает допустимость любого типа)
          propB: [String, Number],      // несколько допустимых типов
          propC: {                      // обязательное значение строкового типа
            type: String,
            required: true
          },
          propD: {                      // число со значением по умолчанию
            type: Number,
            default: 100
          },
          propE: {                      // значения по умолчанию для объектов и массивов должны задаваться через функцию
            type: Object,
            default: function () {
              return { message: 'привет!' }
            }
          },
          propF: {                      // пользовательская функция для валидации
            validator: function (value) {
              return value > 10
            }
          }
        }
      })

    • Опции валидации
      - default     | задать значение по умолчанию
      - type        | валидация типа значения
      - validator   | пользовательская функция-валидатор
      - required    | обязательное значение

    • Доступные значения для type (все JS-типы)

      ▪ String
      ▪ Number
      ▪ Boolean
      ▪ Function
      ▪ Object
      ▪ Array
      ▪ Symbol

  # Концепция однонаправленного потока данных
    
    • Позволяет легче понимать структуру потоков данных в приложении
      - В knockoutjs направленность потоков данных не ограничивалась.
      - В больших приложениях это приводило к спагетти-потокам данных.
      - К хаусу, разобраться в котором мог лишь разработчик этого приложения.
      - Да и то, лишь пока не прошло слишком много времени, и он всё не забыл.
      - Многие это заметили, и родилась концепция однонаправленного потока данных.
      - Благодаря ей проще держать под контролем потоки данных приложения.
      - Даже если это чужой код, в потоках данных легко разобраться.

    • Не меняй вручную значения входных параметров
      - Потому что это бессмысленно и опасно.
      - Ведь они чаще всего будут привязаны к наблюдаемым родителя.
      - И когда значение наблюдаемой изменится, значение параметра обновится.
      - Внесённые тобой изменения затрутся, и это может стать неожиданностью.

> Пользовательские события

  # Система кастомных событий Vue

    • Независима от браузерной
      - Полностью отделена от системы событий браузера. 
      - Это разные, совершенно не связанные вещи.
      - $on != addEventListener, $emit != dispatchEvent.

    • Методы интерфейса событий Vue

      ▪ $on
        - Назначить обработчик кастомного события.
        - Допустим, есть у нас vue-экземпляр bus:

            bus.$on('id-selected', function (id) {
              // ...
            })

      ▪ $emit
        - Возбудить кастомное событие.
        - Допустим, есть у нас vue-экземпляр bus:

            bus.$emit('id-selected', 1)

  # Способы коммуникации между компонентами

    • v-on: родительский компонент <--- дочерний компонент
      
      ▪ Только родитель-дочка
        - Этот способ только для связки родительский-дочерний компоненты.
        - Не надо путать это с "предок-потомок". Только для "родитель-дочка".
      
      ▪ Нельзя использовать $on, нет доступа к модели дочки
        - Дочерний компонент может возбуждать кастомные события.
        - Родительский компонент может обрабатывать эти события.
        - Но использовать $on прямо он не может (нет доступа к модели).
      
      ▪ Надо использовать v-on, на примере
        - Поэтому, он должен использовать v-on.
        - Пример:

        ▪ Шаблон

          <div id="counter-event-example">
            <p>{{ total }}</p>
            <button-counter v-on:increment="incrementTotal"></button-counter>
            <button-counter v-on:increment="incrementTotal"></button-counter>
          </div>      

        ▪ Компонент

          Vue.component('button-counter', {
            template: '<button v-on:click="increment">{{ counter }}</button>',
            data: function () {
              return {
                counter: 0
              }
            },
            methods: {
              increment: function () {
                this.counter += 1
                this.$emit('increment')
              }
            },
          })

        ▪ Модель

          new Vue({
            el: '#counter-event-example',
            data: {
              total: 0
            },
            methods: {
              incrementTotal: function () {
                this.total += 1
              }
            }
          })      

    • Через вспомогательный vue-экземпляр: связь для не-родственников

      ▪ Подходит для простых приложений
        - А для более сложных авторы советуют vuex.

      ▪ Подходит для связи между любыми компонентами
        - В том числе, и между родителем-дочкой.
        - Но для последних лучше использовать v-on.

      ▪ Принцип связи: через вспомогательный vue-экземпляр
        - Где-то создаём вспомогательные vue-экземпляр.
        - И прямо на нём применяем методы $on и $emit.
        - И пускаем поток данных между ком-ми через экземпляр.

      ▪ Пример связи через вспомогательный vue-экземпляр

          var bus = new Vue()                     // Создаём вспомогательный vue-экземпляр
          bus.$emit('id-selected', 1)             // В методе компонента А
          bus.$on('id-selected', function (id) {  // В хуке created метода B
            // ...
          })

    • Через vuex

      ▪ Подходит для средних и крупных SPA-приложений
        - Хотя никто не запрещает использовать подход и для простых.
        - Но в этом случае накладные расходы могут себя не окупать.
        - Хотя, с точки зрения универсальности, лучше всегда задействовать vuex.

      ▪ Публичная/Приватная части модели компонента
        - Концепция vuex подразумевает следующее.
        - Мы делим модель компонента на публичную/приватную.
        - Публичная часть выносится в объект-хранилище vuex.
        - С публичной частью может взаимодействовать любой компонент.

      ▪ Что такое vuex
        - Либа для управления централизованным хранилищем 
          публичных моделей компонентов приложения.
        - Одновременно, термином vuex называют и соответствующий паттерн.
        - Поддерживает продвинутый функционал, такой как:

          ▪ Техника отладки "машина времени" из коробки
          ▪ Экспрорт/Импорт снэпшотов

> Модификаторы .sync, .native; директива v-model

  # Модификатор .sync: работает через систему событий Vue
    - Он позволяет организовать 2-направленный биндинг.
    - Но сам по себе является лишь синтаксическим сахаром.
    - Этот код:

        <comp :foo.sync="bar"></comp>

    - Преобразуется компилятормо vue в:

        <comp :foo="bar" @update:foo="val => bar = val"></comp>

    - И, допустим, дочерний компонент хочет обновить foo.
    - Он не должен прямо менять значение св-ва foo.
    - А должен сделать это через событие:

        this.$emit('update:foo', newValue)

  # Модификатор .native: обрабатывать события из браузера
    - Иногда надо через v-on назначить обработчик для события браузера.
    - Ведь в системах события vue/браузера м.б. события с одинаковым именем.
    - Например: click.
    - И, допустим, мы хотим обрабатывать только события браузера.
    - Тогда и надо использовать модификатор .native:

      <my-component v-on:click.native="doTheThing"></my-component>

  # Директива v-model: лишь синтаксический сахар
    
    ▪ Как она работает
      - Она позволяет нам организовать 2-сторонний биндинг.
      - Но сама по себе является лишь синтаксическим сахаром, как и .sync
      - Этот код:

          <input v-model="something">

      - Преобразуется компилятормо vue в:

          <input
            v-bind:value="something"
            v-on:input="something = $event.target.value">

    ▪ Как застаить работать v-model с компонентом
      - Допустим, у нас есть компонент currency-input.
      - В его шаблоне есть какой-то input.
      - Мы хотим сделать возможным применение v-model
        прямо на псевдоэлементе компонента, для организации
        2-сторонней связи со свойством компонента price.
      - Тогда нам надо сделать 2 вещи с input в шаблоне:

          1. Связать его через v-bind со св-вом price.
          2. Назначить обработчик события input, который
             обновляет значение price текущи значением из input.
      - Пример:

        ▪ Использование компонента с v-model

          <currency-input v-model="price"></currency-input>

        ▪ Компонент

          Vue.component('currency-input', {
            template: `
              <span>
                $
                <input
                  ref="input"
                  v-bind:value="value"
                  v-on:input="updateValue($event.target.value)">
              </span>
            `,
            props: ['value'],
            methods: {
              // Instead of updating the value directly, this
              // method is used to format and place constraints
              // on the input's value
              updateValue: function (value) {
                var formattedValue = value
                  // Remove whitespace on either side
                  .trim()
                  // Shorten to 2 decimal places
                  .slice(
                    0,
                    value.indexOf('.') === -1
                      ? value.length
                      : value.indexOf('.') + 3
                  )
                // If the value was not already normalized,
                // manually override it to conform
                if (formattedValue !== value) {
                  this.$refs.input.value = formattedValue
                }
                // Emit the number value through the input event
                this.$emit('input', Number(formattedValue))
              }
            }
          })        







Компонент: шаблон + модель
Глобальная/локальная регистрация
Инкапсуляция
Проблема парсинга шаблонов из DOM, используй строковые шаблоны
data д.б. ф-ей, чтоб при созд.экз-ра он получал свой объект data, а не общий

Принцип: входные параметры — вниз, события — вверх
Опция props: входные параметры
Однонаправленные поток данных
На надо пытаться менять знач-я вход.парам-ов, они могут не сохраниться
Валидация парам-ов в props, пользовательские правила валидации

Собственная система событий в Vue, независимая от браузерной
$on, $emit
Потомок полностью независим от происходящего снаружи
Подписка компонента на нативные события браузера
Синт.сахар .sync для 2-стороннего биндинга входных параметров
v-model является синтаксическим сахаром для v-bind + v-on
Настройка v-model с помощью опции model в объекте-конструкторе
Коммуникация не со состоящих в род.связях компонентов: общий предок, vuex
Распределение контента слотами
Род.конт.будет отброшен, если <slot> отсутствуют
Если есть лишь 1 <slot>, род.контент будет помещён в него
Внутри: <slot>резервный конт.</slot> - будет показан при отсутствии род.контента
Именованные слоты, для адресации контента
Слоты с ограниченной областью видимости
Динамическое переключение компонентов с помощью псевдоэлемента <component>
Хранение состояния отключенных с помощью <component> компонентов в памяти с помощью <keep-alive>

API vue-компонентов: параметры, события, слоты
Назвать компоненты лучше в стиле kebab-style, т.к. это катит в т.ч. для DOM-шаблонов



