////=============================================////
////                                             ////
////                    SVG + D3                 ////
////                                             ////
////=============================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // SVG //
  //-----//

    # Статья про SVG на WIKI
        https://ru.wikipedia.org/wiki/SVG
        https://en.wikipedia.org/wiki/Scalable_Vector_Graphics

    # Туториал по SVG от w3schools
        http://www.w3schools.com/svg/default.asp

    # Mozilla Developer Network - SVG
        https://developer.mozilla.org/ru/docs/Web/SVG

    # Туториал по SVG от Mozilla
        https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial

    # SVG tutorial, example and demonstration site
        http://carto.net

    # Ещё один туториал по SVG
        https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html

  // D3 //
  //----//

    // Официальные ресурсы D3 //
    //------------------------//

      # Официальный репозиторий D3 на github
          https://github.com/mbostock-bower/d3-bower

      # Официальный сайт D3
          https://d3js.org/

      # Официальная документация (wiki) для D3 (D3 v3.*)
          https://github.com/d3/d3/wiki

      # Официальная документация (wiki) для D3 (D3 v4.*)
          https://github.com/d3/d3/blob/master/README.md#api-reference

      # Официальная галерея примеров для D3
          https://github.com/d3/d3/wiki/Gallery

      # Модули D3
          https://github.com/d3

    // Компоненты и плагины D3 //
    //-------------------------//

      # Компоненты
          https://github.com/d3/d3/wiki/API-Reference

      # Плагины
          https://github.com/d3/d3-plugins


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////

  # A. SVG: основы

    А1. Теоретические основы SVG
    А2. Базовый туториал по SVG

    Аn. Библиотека примеров и наработок на SVG

  # Б. D3: основы + справочник

    Б1. Основы D3.js
    Б2. D3-модуль: selections (svg v4.*)

  # В. D3: наработки



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Теоретические основы SVG

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Что такое SVG

    ▪ SVG: Scalable Vector Graphics
    ▪ Интерактивность и анимация
    ▪ На основе XML
    ▪ Спецификация разрабатывается W3C с 1999
    ▪ Является открытым стандартом
    ▪ SVG-изображения определяются в текстовых XML-файлах
    ▪ Поддерживается всеми основными современными WEB-браузерами
    ▪ SVG допускает 3 типа объектов: векторная графика, растровая графика и текст
    ▪ Каждый SVG-объект есть в DOM

  # Краткая история SVG

    ▪ Работы над SVG начались в 1998
    ▪ В 2001 году стандарт SVG 1.0 стал W3C-рекомендацией
    ▪ В 2003 году стандарт SVG 1.1 стал W3C-рекомендацией
    ▪ В 2011 году появился SVG 1.1 Second Edition
    ▪ В настоящее время (2016-07-31) ведутся работы над SVG2

  # Возможности SVG

    ▪ Paths
    ▪ Basic shapes
    ▪ Text
    ▪ Painting
    ▪ Color
    ▪ Gradients and patterns
    ▪ Clipping, masking and compositing
    ▪ Filter effects
    ▪ Interactivity
    ▪ Linking
    ▪ Scripting
    ▪ Animation
    ▪ Fonts
    ▪ Metadata

  # Преимущества и недостатки SVG

    ▪ Преимущество: текстовый формат
    ▪ Преимущество: масштабируемость
    ▪ Преимущество: возможность использования растровой графики
    ▪ Преимущество: текст в SVG-изображении является текстом, а не пикселями
    ▪ Преимущество: анимация встроенными средствами, JS-средствами, CSS-средствами
    ▪ Преимущество: открытый стандарт, никто не предъявит
    ▪ Преимущество: лёгкая интеграция с HTML и XHTML
    ▪ Преимущество: совместимость с CSS
    ▪ Преимущество: SVG предоставляет все преимущества XML

    ▪ Недостаток: наследует все недостатки XML
    ▪ Недостаток: сложность использования в крупных картографических приложениях
    ▪ Недостаток: проблемы с производительностью при наличии большого числа мелких деталей

--------------------------------------

> Ссылки

  # Статья про SVG на WIKI
      https://ru.wikipedia.org/wiki/SVG
      https://en.wikipedia.org/wiki/Scalable_Vector_Graphics

  # Статьи по основам SVG
      https://svg-art.ru/
      https://developer.mozilla.org/ru/docs/Web/SVG

> Введение
  - В этой главе рассмотрим, что такое SVG в принципе, основы.

> Что такое SVG

  • SVG: Scalable Vector Graphics
    - Масштабируемая векторная графика.

  • Интерактивность и анимация
    - С изображением и его частями можно взаимодействовать из JS.
    - Всё это дело также можно анимировать.

  • На основе XML
    - SVG входит в подмножество расширяемого языка разметки XML.

  • Спецификация разрабатывается W3C с 1999
    - World Wide Web Consortium (W3C) разрабатывает спецификацию SVG с 1999 года.

  • Является открытым стандартом
    - Значит, можно его свободно использовать, и никто тебе не предъявит.

  • SVG-изображения определяются в текстовых XML-файлах
    - Можно создать TXT-файл и написать там SVG-код, создав таким образом SVG-изображение.
    - Чаще всего SVG-изображение создаются специальным ПО.

  • Поддерживается всеми основными современными WEB-браузерами
    - Включая:

      ▪ Mozilla Firefox
      ▪ Internet Explorer
      ▪ Microsoft Edge
      ▪ Google Chrome
      ▪ Opera
      ▪ Safari

  • SVG допускает 3 типа объектов: векторная графика, растровая графика и текст
    - В SVG-изображении могут присутствовать только объекты указанных типов.

  • Каждый SVG-объект есть в DOM
    - И реагирует на любые JS-события.
    - Это является одним из ключевых отличий SVG от Canvas.

> Краткая история SVG

  • Работы над SVG начались в 1998
    - После того, как Macromedia и Microsoft представили формат VML.
    - И после того, как Adobe и Sun представили PGML.
    - То есть, стандарт SVG от W3C стал конкурентом для VML и PGML.

  • В 2001 году стандарт SVG 1.0 стал W3C-рекомендацией
    - 4 сентября 2001 года.

  • В 2003 году стандарт SVG 1.1 стал W3C-рекомендацией
    - 14 января 2003 года.
    - Спецификацию сделали модульной, чтобы позволить подмножествам быть
      определёнными, как профили.
    - Если не считать этого, 1.1 мало чем отличался от 1.0.

  • В 2011 году появился SVG 1.1 Second Edition
    - В нём не появилось никаких новых функций, по сравнению с First Edition.
    - А лишь правки и уточнения.

  • В настоящее время (2016-07-31) ведутся работы над SVG2
    - Больше можно узнать здесь: https://www.w3.org/TR/SVG2/

> Возможности SVG

  • Paths
    - Можно отрисовывать контуры простых и составных фигур, прямыми и кривыми линиями.
    - Короче говоря, можно отрисовать любую фигуру компактной строкой.
    - В ней д.б. описан путь от начальной точки до конечной, через промежуточные.
    - Строка с данными задаётся атрибутом d тега path и содержит команды,
      закодированные набором букв и чисел.
    - Буквы определяют тип команды, числа - её параметры (чаще всего координаты).
    - Команды позволяют описывать фигуры, состоящие из:

      ▪ Отрезков прямых (L, H, V).
      ▪ Кривых Безье (C, S, Q, T).
      ▪ Дуг (A).

    - Регистр букв имеет значение:

      ▪ Буквы в верхнем регистре обозначают абсолютные координаты.
      ▪ Буквы в нижнем регистре обозначают относительные координаты.

  • Basic shapes
    - Можно рисовать основные геометрические фигуры.
    - Например: треугольники, квадраты, полигоны, окружности и т.д.

  • Text
    - Можно добавлять UTF-8 текст.
    - К тексту можно применять много различных визуальных эффектов.
    - Например: писать текст по кривой.

  • Painting

    ▪ Наполнение или обводка
      - Можно наполнить фигуру.
      - А можно сделать обводку с наполнением.
      -

    ▪ Чем можно наполнять
      - Цветом.
      - Градиентом.
      - Паттерном.

    ▪ Наполнение может быть полупрозрачным
      - Сабж.

  • Color
    - Цвета можно применять ко всем видимым SVG-элементам.
    - Прямо, или с помощью "fill", "stroke" и других свойств.
    - Цвета определяются также, как в CSS.
    - Примеры: #000, RGBA(0,0,0,.5), black.

  • Gradients and patterns

    ▪ Линейные и радиальные градиенты
      - Поддерживаются в SVG.

    ▪ Градиенты могут включать любое кол-во цветов
      - В том числе, цвета в градиенте могут и повторяться.

    ▪ Градиенты могут быть полупрозрачными
      - Сабж.

    ▪ Про паттерны
      - Они основаны на предопределённых векторных или растровых объектах.
      - Эти объекты могут быть повторены в x/y направлениях.

    ▪ Градиенты и паттерны могут быть анимированы или заскриптованы
      - Сабж.

    ▪ Градиентные сетки
      - Скорее всего, будут поддерживаться в SVG2.

  • Clipping, masking and compositing
    - Графические элементы - текст, пути, базовые фигуры, и их комбинации -
      могут быть использованы, как контуры для определяния и внутренних,
      и внешних регионов.
    - Определённые регионы могут быть независимо залиты (цветом, градиентом, паттерном).
    - Полностью прозрачные clipping paths и полу-прозрачные маски совмещаются
      друг с другом, чтобы вычислить цвет и полупрозрачность каждого пикселя
      финального изображения.

  • Filter effects

    ▪ Что такое фильтр
      - Набор графических операций, который можно применять к SVG-изображениям.
      - И на выходе получать обработанное этим фильтром SVG-изображение.

    ▪ Фильтры можно применять с помощью св-ва filter
      - Его можно применять к контейнеру, или к любому графическому элементу.

    ▪ Примитивы фильтров
      - Каждый элемент filter может содержать набор примитивов, как дочерние элементы.
      - Каждый примитив обозначает примитивную графическую операцию.

  • Interactivity
    - SVG-изображения могут взаимодействовать с пользователя многоми способами.
    - В дополнение к гиперссылкам: SVG-изображения могут быть восприимчивы к
      событиями интерфейса, таким как изменения фокуса, клики мыши,
      скроллинг и зуминг изображения, события клавиатуры, документы
      и так далее.
    - Обработчики событий могут запускать/останавливать анимации и другие
      процессы, скрипты и т.д.

  • Linking

    ▪ Ссылки на другие документы
      - Можно организовать с помощью XLink.

    ▪ Ссылки на SVG-файлы, которые меняют видимую часть документа
      - Можно организовать с помощью <view> или fragment identifier.
      - Это позволяет создавать состояния, которые используются для
        zoom in/out определённой области, или для ограничения
        представления определённым элементом.
      - Это полезно, когда создаёшь спрайты.

  • Scripting
    - Управлять всеми аспектами SVG-изображения можно в текстово файле.
    - По умолчанию, скриптовым языком для SVG является ECMAScript.
    - DOM-объекты определяются для каждого SVG-элемента.
    - Они реагируют на любые JS-события - мыши, клавиатуры и т.д.

  • Animation

    ▪ Анимация встроенными средствами
      - SVG может быть анимирован встроенными анимационынми элементами.
      - Такими, как: <animate>, <animateMotion> и <animateColor>.

    ▪ Анимация с помощью JS
      - Никто не запрещает анимировать SVG с помощью JS-скриптов.

    ▪ Анимация с помощью CSS3
      - Никто не запрещает анимировать SVG с помощью CSS3.

  • Fonts
    - Как и в HTML/CSS, в SVG можно подключать внешние шрифты.

  • Metadata
    - SVG позволяет авторам добавлять метаданные об SVG-изображении.
    - Они должны быть в элементе <metadata>.
    - Также они могут быть в <title> или <desc>.

> Преимущества и недостатки SVG

  • Преимущество: текстовый формат
    - SVG-изображения можно редактировать в txt-редакторе.
    - SVG-изображения обычно меньше по размеру, чем сравнимып по качеству растровые.

  • Преимущество: масштабируемость
    - Поскольку SVG векторный формат, его легко масштабировать.
    - В отличие от растровых изображений, которые масштабировать нелегко.

  • Преимущество: возможность использования растровой графики
    - Можно вставлять в SVG-изображение растровые картинки (PNG, GIF, JPG).

  • Преимущество: текст в SVG-изображении является текстом, а не пикселями
    - Текст в SVG-изображении является текстом, а не изображением.
    - Поэтому, его можно выделять, копировать, он индексируется.
    - Не нужно создавать дополнительные метафайлы для поисковых роботов.

  • Преимущество: анимация встроенными средствами, JS-средствами, CSS-средствами
    - Есть много способов анимировать SVG-изображение, его части.

  • Преимущество: открытый стандарт, никто не предъявит
    - В отличие от некоторых других форматов, SVG не является чьей-либо собственностью.

  • Преимущество: лёгкая интеграция с HTML и XHTML
    - SVG-документы легко интегрируются с HTML и XHTML документами.
    - Внешние SVG подключаются через тег <object>.
    - Значение атрибута data - путь к файлу с расширением .svg
    - Атрибуты width и height определяют размер области SVG.
    - Элементы SVG совместимы с HTML и DHTML.

  • Преимущество: совместимость с CSS
    - Отображением SVG-элементов можно управлять с помощью CSS.

  • Преимущество: SVG предоставляет все преимущества XML

    ▪ Возможность работы в различных средах.
    ▪ Интернационализация (поддержка юникода).
    ▪ Широкая доступность для различных приложений.
    ▪ Легко изменять с помощью стандартных API
      - Например, с через DOM.
      - Ведь SVG поддерживают стандартизированную W3C объектную модель документа DOM.
      - Что обеспечивает доступ к любому SVG-объекту.
      - Это даёт широкие возможности по динамическому изменения эл-в, их атрибутов.
      - В том числе, работают все стандартные события.
    ▪ Лёгкое преобразование таблицами стилей XSLT
      - Как для любого XML-формата, для обработки SVG можно применять таблицы трансформации (XSLT).
      - Преобразуя XML-данные в SVG с помощью простого XSL, можно легко получать графическое
        представление любых данных.
      - Например, визуализировать химические молекулы, описанные на
        языке CML (Chemical Markup Language).

  • Недостаток: наследует все недостатки XML
    - Сабж.

  • Недостаток: сложность использования в крупных картографических приложениях
    - Для правильного отображения маленькой части изображения
      документ необходимо прочитать полностью.

  • Недостаток: проблемы с производительностью при наличии большого числа мелких деталей
    - Чем больше в изображении мелких деталей, тем быстрее растёт размер SVG-данных.
    - Предельный случай - когда изображение представляет из себя белый шум.
    - В этом случае SVG проиграет растровому файлу по размеру.
    - На практики, SVG становится невыгоден по размеру уже задолго
      до того, как изображение дойдёт до стадии белого шума.


А2. Базовый туториал по SVG

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

    ▪ О чём эта статья
    ▪ Базовые ингридиенты
    ▪ Простейший пример
    ▪ Поздние элементы отрисовываются поверх ранних

  # Как вставить SVG в HTML-документ

    ▪ Если это HTML5-документ, можно писать SVG-код прямо в нём
    ▪ SVG можно создать динамически с помощью JS и вставить в DOM
    ▪ С помощью <object>
    ▪ С помощью <iframe>
    ▪ С помощью <img> (но не работает в Firefox<4.0)

  # Возможные типы SVG-файлов

    ▪ Текстовый файл .svg
    ▪ Gzip-файл .svgz

  # HTTP-заголовки при работе с SVG-файлами

    ▪ Для .svg
    ▪ Для .svgz

  # Позиционирование элементов

    ▪ Система координат с нулевой точкой в верхнем левом углу
    ▪ Единицами измерения являются пиксели (px)

--------------------------------------

> Ссылки

  # Туториал по SVG от w3schools
      http://www.w3schools.com/svg/default.asp

  # Туториал по SVG от Mozilla
      https://developer.mozilla.org/ru/docs/Web/SVG
      https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial

  # SVG tutorial, example and demonstration site
      http://carto.net

> Введение

  • О чём эта статья
    - В этой главе базовый туториал по SVG.
    - Он должен давать хорошее представление об использовании SVG на практике.
    - Справочную же информацию по SVG ищи в последующих главах.

  • Базовые ингридиенты
    - HTML состоит из элементов, определяющих заголовки, параграфы, и т.д.
    - Точно также SVG состоит из эл-в, определяющих кривые, круги, прямоугольники и т.д.
    - Простой SVG-документ выглядит так:

      <svg>
        <!-- Тут несколько SVG-элементов, например, круг и квадрат =) -->
      </svg/

    - Кроме того, с помощью эл-та <g> можно группировать несколько SVG-элементов.
    - Например, так:

      <svg>

        <g>
          <!-- круг -->
          <!-- квадрат -->
        </g>

      </svg>

  • Простейший пример

    ▪ Описание примера
      - В этом примере мы создаём корневой SVG-элемент шириной 300px, высотой 200px.
      - И в него помещаем красный прямоугольник, зелёный круг и текст.

    ▪ Пример на jsfiddle
        https://jsfiddle.net/GermanM/gsssh8vo/

    ▪ Код примера

      <svg version="1.1" baseProfile="full" width="300" height="200" xmlns="http://www.w3.org/2000/svg">
        <rect width="100%" height="100%" fill="red" />
        <circle cx="150" cy="100" r="80" fill="green" />
        <text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG</text>
      </svg>

  • Поздние элементы отрисовываются поверх ранних
    - Это важнейшее свойство SVG, которое следует запомнить.
    - Элемент ниже по коду отрисовывается поверх элемента выше по коду.
    - Это хорошо видно на приведённом выше примере:

      ▪ Тексто отрисовывается поверх круга и прямоугольника.
      ▪ Зелёный круг отрисовывается поверх красного прямоугольника.

> Как вставить SVG в HTML-документ

  • Если это HTML5-документ, можно писать SVG-код прямо в нём

  • SVG можно создать динамически с помощью JS и вставить в DOM
    - Точно также, как можно это делать с другими HTML-элементами.

  • С помощью <object>

      <object data="image.svg" type="image/svg+xml" />

  • С помощью <iframe>

      <iframe src="image.svg"></iframe>

  • С помощью <img> (но не работает в Firefox<4.0)
    - Лучше так не делать.

> Возможные типы SVG-файлов

  • Текстовый файл .svg
    - Обычный SVG-файл является обычным текстовым файлом.
    - Рекомендуемое расширение: .svg
    - Имя файла рекомендуется писать в нижнем регистре.

  • Gzip-файл .svgz
    - В некоторые крупных приложениях SVG-файлы могут быть гигантскими.
    - Поэтому SVG-спецификация допускает gzip-сжатые SVG-файлы.
    - Рекомендуемое расширение для них: .svgz
    - Имя файла рекомендуется писать в нижнем регистре.
    - Однако, трудно заставить многие браузеры правильно их отображать.
    - Поскольку, для таких типов файлов отсутствует соответствующий MIME.
    - Поэтому, использования svgz следует использовать с осторожностью.
      Желательно, только если ты профессионал в этой теме, и хорошо понимаешь, что делаешь.

> HTTP-заголовки при работе с SVG-файлами

  ▪ Для .svg

      Content-Type: image/svg+xml
      Vary: Accept-Encoding

  ▪ Для .svgz

      Content-Type: image/svg+xml
      Content-Encoding: gzip
      Vary: Accept-Encoding

> Позиционирование элементов

  • Система координат с нулевой точкой в верхнем левом углу
    - Для всех элементов SVG использует эту систему координат.
    - В ней нулевая точка (0,0) расположена в верхнем-левом углу эл-та <svg>.
    - Положительная ось X направлена вправо, а ось Y вниз.
    - В принципе, аналогичным образом позиционируются DOM-элементы в HTML.

  • Про единицы измерения в системе координат SVG

    ▪ Единицы измерения в общем случае
      - В общем случае 1px равен одному пикселю вашего монитора.

    ▪ Абсолютные и относительные единицы измерения
      - Однако, SVG имеет слово "Scalable" в своём названии не спроста.
      - Как в CSS есть абсолютные и относительные размеры шрифта,
        так и в SVG есть абсолютные и относительные единицы измерения.
      - Абсолютными являются такие, как пиксели или сантиметры.
      - А относительными, так называемые пользовательские пиксели.

  • Пользовательская система координат

    ▪ Случай, когда 1px на мониторе равен 1-му пользовательскому пикселю
      - В данном случае мы задаём размер SVG-элемента равный 100x100 единиц.
      - Поскольку мы не применяем viewBox или другие масштабирующие эффекты,
        получается, 1px на мониторе равен 1-му пользовательскому пикселю

          <svg width="100" height="100">

    ▪ Случай, когда 1-ин пользовательский пиксел равен 2px на мониторе
      - Чтобы получит такую картину, надо увеличить масштаб в 2 раза.
      - Для этого создадим SVG-элемент размерами 200x200px.
      - А viewBox зададим от (0,0) до (100,100).
      - Таким образом, мы увеличим масштаб SVG-изображения в 2 раза.
      - Что такое viewBox наглядно показано здесь: https://svg-art.ru/?p=1083

          <svg width="200" height="200" viewBox="0 0 100 100">

    ▪ Кроме масштабировия, есть ещё деформации
      - При деформациях соотношение экранного px и пользовательского
        также могут меняться.

    ▪ Постоянные величины (cm, in, и т.д)
      - Можно задавать размеры SVG-элементов и в постоынных величинах.
      - Тогда они рассчитываются при масштабировании, деформациях, и т.д,
        так, чтобы в результирующих изображениях появляться в размерах
        1:1.
      - Т.Е. 1 экранный пиксель д.б. равен 1 пикселю данного элемента.
      - Короче говоря, их затруднительно становится масштабировать и т.д.


Аn. Библиотека примеров и наработок на SVG

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Библиотека примеров

    1] Базовый пример: квадрат, круг, текст
    2] Наглядная демонстрация пользовательской системы координат

--------------------------------------

> Ссылки

  # Здесь можно вживую посмотреть все примеры
      https://jsfiddle.net/GermanM

> Введение
  - Это библиотека примеров на SVG.
  - Каждый пример представляет собой описание и ссылку на jsfiddle.
  - Коды примеров в этом документе отсутствуют по соображениям его размера.

> Библиотека примеров

  // 1] Базовый пример: квадрат, круг, текст //
  //-----------------------------------------//

    • Ссылка на jsfiddle
        https://jsfiddle.net/GermanM/gsssh8vo/

    • Описание примера
      - В этом примере мы создаём корневой SVG-элемент шириной 300px, высотой 200px.
      - И в него помещаем красный прямоугольник, зелёный круг и текст.

  // 2] Наглядная демонстрация пользовательской системы координат //
  //--------------------------------------------------------------//

    • Ссылка на jsfiddle
        https://jsfiddle.net/GermanM/3jq939Lv/

    • Описание примера
      - В этом примере наглядно показывается, что такое пользовательская система координат.








Базовый пример: квадрат, круг, текст


Б1. Основы D3.js

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Введение в D3: это JS-библиотека
  # Введение в D3: html + css + svg
  # Введение в D3: главной целью является визуализация данных
  # Введение в D3: кроссбраузерность, поддержка всеми кроме IE<=8

  # Основы D3: привязка произвольных данных к DOM
  # Основы D3: это не швейцарский нож, а направленный инструмент
  # Основы D3: повторное использование кода через компоненты и плагины
  # Основы D3: выборки
  # Основы D3: динамический свойства
  # Основы D3: enter & exit
  # Основы D3: transitions
  # Основы D3: нет автопрефиксера для браузерных префиксов

--------------------------------------

> Ссылки

> Введение
  - Цель этой главы сформировать общее представление о d3.
  - Получить цельную, общую картину мелким планом без лишних деталей.

> Введение в D3: это JS-библиотека
  - D3.js является js-библиотекой.
  - Используется для манипулирования документами на основе данных.
  - То есть, берутся какие-то элементы из DOM, и с ними проводятся манипуляции.

> Введение в D3: html + css + svg
  - Под капотом D3 использует html, css и svg.
  - Таким образом, D3 и canvas не имеют ничего общего.

> Введение в D3: главной целью является визуализация данных
  - D3 создана для удобной визуализации данных.

> Введение в D3: кроссбраузерность, поддержка всеми кроме IE<=8
  - Библиотека D3 является кроссбраузерной.
  - D3 поддерживается всеми современными браузерами.
  - D3 не поддерживается IE8 и ниже.

> Основы D3: привязка произвольных данных к DOM
  - В HTML есть понятие Document Object Model (DOM).
  - По сути, это структура документа, стстоящая из элементов.
  - D3 позволяет привязывать произвольные данные к элементам DOM.
  - Например, можно сгенерировать таблицу из массива чисел.
  - Или, например, создать бар-график на основе тех же данных.

> Основы D3: это не швейцарский нож, а направленный инструмент
  - D3 не является монолитным фреймворком, стремящемся решать все проблемы.
  - Он заточен лишь для решения 1-й задачи: 

      Эффективная манипуляция документами на основе данных.

  - Благодаря этому, D3 работает чрезвычайно быстро.
  - И может работать даже с огромными массивами данных.
  - Поддерживает динамическиеизменения и анимацию.

> Основы D3: повторное использование кода через компоненты и плагины
  - В D3 продумана тема повторного использования кода.
  - Ссылки на репозитории с ними см.в ссылках этого документа.

> Основы D3: выборки
  - Это типа D3-коллекций DOM-элементов.
  - С которыми потом с помощью D3 можно производить манипуляции.
  - Например, изменим "color" всех DOM-элементов p на "white":

      d3.selectAll("p").style("color", "white");

  - Получять эти коллекции можно, используя различные признаки.
  - Включая class, id, значения атрибутов, содержание.

> Основы D3: динамический свойства
  - Стили, атрибуты и прочие св-ва в D3 могут быть функциями.
  - Это даёт широкие возможности, и позволяет заготавливать эти функции.
  - В D3 есть множество подобного рода заготовленных функций.
  - Например, раскрасим случайным образом все DOM-элементы p:

      d3.selectAll("p").style("color", function() {
        return "hsl(" + Math.random() * 360 + ",100%,50%)";
      });  

> Основы D3: привязка данных к выборкам
  - К выборке можно привязать данные.
  - Чтобы потом на основе этих данных модифицировать выборку.
  - Однажды привязав данные, повторно можно их не привязывать.
  - Например, при обновлении выборки этого делать уже не обязательно.
  - Пример:

      d3.selectAll("p")
          .data([4, 8, 15, 16, 23, 42])
          .style("font-size", function(d) { return d + "px"; });  

> Основы D3: enter & exit
  - В D3 есть так называемые enter и exit выборки.
  - С их помощью можно создавать новые узлы для входящих данных.
  - И удалять старые узлы, которые больше не нужны.
  - Итак, домустим у нас есть данные, привязанные к выборке.
  - Каждый элемент в массиве данных связан с соотв.узлом из выборки.
  - Если узлов меньше, чем данных, то лишние эл-ты попадают в выборку enter.
  - Которую можно инициировать, добавив туда элементов. Пример:

      d3.select("body").selectAll("p")
        .data([4, 8, 15, 16, 23, 42])
        .enter()
        .append("p")
        .text(function(d) { return "I’m number " + d + "!"; });  

  - Если забыть об enter/exit элементах, то при работе с выборками будут 
    учитываться лишь те элементы, для которых есть данные.
  - Общим паттерном является разбить изначальную выборку на 3 части:

      ▪ Updating nodes
      ▪ Entering nodes to add
      ▪ Exiting nodes to remove

  - Пример:

        // Update…
        var p = d3.select("body").selectAll("p")
            .data([4, 8, 15, 16, 23, 42])
            .text(function(d) { return d; });

        // Enter…
        p.enter().append("p")
            .text(function(d) { return d; });

        // Exit…
        p.exit().remove();  

> Основы D3: transitions
  - D3 имеет встроенный функционал переходов (transitions) из CSS3.
  - Так что при изменении данных всё может плавно изменяться.
  - Это приминимо как к примитивным, так и к составным значениям.
  - Например, можно плавно изменить цвет фона документа на чёрный:

      d3.select("body").transition()
          .style("background-color", "black");  

> Основы D3: нет автопрефиксера для браузерных префиксов
  - Многие привыкли работать с CSS с автопрефиксером.
  - Однако, в D3 автопрефиксинга нет, нужно иметь это в виду.


Б2. D3-модуль: selections (svg v4.*)

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Справочник

    • Selecting Elements

      ▪ d3.selection        | Получить выборку из 1-го корневого элемента DOM [document.documentElement]
      ▪ d3.select           | Получить выборку из 1-го эл-та [по DOM-ссылке / 1-й по списку по селектору]
      ▪ d3.selectAll        | Получить выборку из N эл-тов [по массиву DOM-ссылок / по селектору]
      ▪ selection.select    | Получить выборку из N эл-тов на основе другой выборки [по селектору / по анонимной функции]
      ▪ selection.selectAll | Получить выборку из N эл-тов на основе другой выборки [по селектору / по анонимной функции]
      ▪ selection.filter    | Провести фильтрацию выборки [по селектору / по анонимной функции]
      ▪ selection.merge     | Объединить выборки [не произвольные, обычно ENTER + UPDATE]
      ▪ d3.matcher          | Возвращает функцию, которая возвращает true, если эл-т this соответствует указанному селектору [для внутреннего использования D3]
      ▪ d3.selector         | Возвращает функцию, которая возвращает первый для this элемент-потомок, соотв-ий указанному селектору [для внутреннего использования D3]
      ▪ d3.selectorAll      | Возвращает функцию, которая возвращает все для this элементы-потомки, соотв-щие указанному селектору [для внутреннего использования D3]
      ▪ d3.window           | Возвращает окно-владельца для указанного узла

    • Modifying Elements

      ▪ selection.classed   |
      ▪ selection.style     |
      ▪ selection.property  |
      ▪ selection.text      |
      ▪ selection.html      |
      ▪ selection.append    |
      ▪ selection.insert    |
      ▪ selection.remove    |
      ▪ selection.sort      |
      ▪ selection.order     |
      ▪ selection.raise     |
      ▪ selection.lower     |
      ▪ d3.creator          |

    • Joining Data

      ▪ selection.data      |
      ▪ selection.enter     |
      ▪ selection.exit      |
      ▪ selection.datum     |

    • Handling Events

      ▪ selection.on        |
      ▪ selection.dispatch  |
      ▪ d3.event            |
      ▪ d3.customEvent      |
      ▪ d3.mouse            |
      ▪ d3.touch            |
      ▪ d3.touches          |

    • Control Flow

      ▪ selection.each      |
      ▪ selection.call      |
      ▪ selection.empty     |
      ▪ selection.nodes     |
      ▪ selection.node      |
      ▪ selection.size      |

    • Local Variables

      ▪ d3.local            |
      ▪ local.set           |
      ▪ local.get           |
      ▪ local.remove        |
      ▪ local.toString      |

    • Namespaces

      ▪ d3.namespace        |
      ▪ d3.namespaces       |

--------------------------------------

> Ссылки

  # Ссылка на соотв.раздел документации D3 v4.*
      https://github.com/d3/d3/blob/master/README.md#selections-d3-selection

> Ведение
  - Это справочник по модулю Selections библиотеки D3 v4.*.

> Справочник

//--------------------//
// Selecting Elements //
//--------------------//

  // d3.selection //
  //--------------//
  // - d3.selection()
  // - Получить выборку из 1-го корневого элемента DOM [document.documentElement].

    • Проверка, является ли переменная D3-выборкой

      var selection = d3.selectAll("p");
      var is = selection instanceof d3.selection();   // true/false

    • Расширить прототип selection (например, добавить метод checked для проверки состояния чекбоксов)

      ▪ Расширить

          d3.selection.prototype.checked = function(value) {
            return arguments.length < 1
                ? this.property("checked")
                : this.property("checked", !!value);
          };
          d3.selectAll("input[type=checkbox]").checked(true);

      ▪ Использовать

          d3.selectAll("input[type=checkbox]").checked(true);

  // d3.select //
  //-----------//
  // - d3.select(selector)
  // - Получить выборку из 1-го эл-та [по DOM-ссылке / 1-й по списку по селектору].
  // - Если таковых найдено не будет, вернёт пустую выборку.
  // - Если такувых будет найдено много, вернёт лишь 1-й из них.

    • Если selector является css-селектором
      - Получить выборку из 1-го найденный элемента "a"

        var anchor = d3.select("a");

    • Если selector не является строкой
      - Тогда это должна быть DOM-ссылка (или функция, её возвращающая).
      - Пример ниже окрасит шрифт всех эл-тов "p" в документе в красный цвет:

          d3.selectAll("p").on("click", function() {
            d3.select(this).style("color", "red");
          });

  // d3.selectAll //
  //--------------//
  // - d3.selectAll(selector)
  // - Получить выборку из N эл-тов [по массиву DOM-ссылок / по селектору].
  // - Если ничего не найдёт, вернёт пустую выборку.

    • Если selector является css-селектором
      - Получить все элементы "p" в документе:

          var paragraph = d3.selectAll("p");

    • Если selector не является строкой
      - Тогда это должен быть массив ссылок на DOM-узлы.
      - Это полезно, когда таковой имеется.
      - Это также может быть псевдо-массив, как NodeList или argumetns.
      - Например, this.childNodes в обработчике событий, или document.links.
      - Например, покрасить все ссылки в красный цвет:

          d3.selectAll(document.links).style("color", "red");

  // selection.select  //
  //-------------------//
  // - selection.select(selector).
  // - Получить выборку из N эл-тов на основе другой выборки [по селектору / по анонимной функции].
  // - Для каждого эл-та из selection, выбрать среди его потомков 1-й
  //   элемент, который соответствует указанному selector.
  // - Если selector пуст или null, все эл-ты в новой выборке тоже будут пустые.
  // - Если эл-т из текущей выборки имеет связанные данные, то новый элемент,
  //   полученный среди его потомков, тоже будет связан с этими данными.
  // - Если для эл-та X найдено среди его потомков > 1 элементов, соответствующих
  //   selector, будет взят лишь 1-й из них.

    • Если selector является css-селектором
      - Для каждого эл-та "p" в док-те выбрать среди его потомков 1-й эл-т "b":

          var b = d3.selectAll("p").select("b");

    • Если selector не является css-селектором
      - А является функцией, она будет выполнена для каждого эл-та выборки.
      - В функцию будут переданы: d (данные), i (индекс), nodes и this (DOM-ссылка на текущий эл-т).
      - Функция должна возвращать 1-ин элемент.
      - Для каждого эл-та "p" в док-те выбрать 1-го предыдущего соседа:

          var previous = d3.selectAll("p").select(function() {
            return this.previousElementSibling;
          });

  // selection.selectAll //
  //---------------------//
  // - selection.selectAll(selector).
  // - Получить выборку из N эл-тов на основе другой выборки [по селектору / по анонимной функции].
  // - Для каждого эл-та из selection, выбрать среди его потомков ВСЕ
  //   элементы, которые соответствуют указанному selector.
  // - То есть, на 1-им элемент в selection м.б. найдено N элементов-потомков,
  //   соответствующих selector. Они будут сгруппированы по своим топовым узлам.
  // - Если соответствующих selector элементов для эл-та из selection не найдено,
  //   или если selector пуст или null, группа для этого индекса тоже будет пустая.
  // - Элементы в новой выборке не наследуют данные от элементов в старом.
  //   Используй selection.data для распространения данных в эл-ты новой выборки.

    • Если selector является css-селектором
      - Для каждого эл-та "p" в док-те выбрать среди его потомков ВСЕ эл-ты "b":

          var b = d3.selectAll("p").selectAll("b");

    • Если selector не является css-селектором
      - А является функцией, она будет выполнена для каждого эл-та выборки.
      - В функцию будут переданы: d (данные), i (индекс), nodes и this (DOM-ссылка на текущий эл-т).
      - Функция должна возвращать массив элементов (или псевдо-массив, вроде NodtList или arguments).
      - Или же пустой массив, если нет соответствующих элементов.
      - Для каждого эл-та "p" в док-те выбрать 1-ых предыдущего и следующего соседей:

          var sibling = d3.selectAll("p").selectAll(function() {
            return [
              this.previousElementSibling,
              this.nextElementSibling
            ];
          });

  // selection.filter //
  //------------------//
  // - selection.filter(filter).
  // - Провести фильтрацию выборки [по селектору / по анонимной функции].
  // - Вернёт новую выборку, содержащую лишь элементы, прошедшие фильтрацию.
  // - При этом индексы не сохраняются.

    • Если filter является css-селектором
      - Получить все эл-ты "tr" в документе, отфильтровать все нечётные:

          var even = d3.selectAll("tr").filter(":nth-child(even)");

      - Это примерно тоже самое, что сделать вот так:

          var even = d3.selectAll("tr:nth-child(even)");

    • Если selector не является css-селектором
      - А является функцией, она будет выполнена для каждого эл-та выборки.
      - В функцию будут переданы: d (данные), i (индекс), nodes и this (DOM-ссылка на текущий эл-т).
      - Получить все эл-ты "tr" в документе, отфильтровать все нечётные:

          var even = d3.selectAll("tr").filter(function(d, i) { return i & 1; });

      - Это примерно тоже самое, что сделать вот так:

          var even = d3.selectAll("tr").select(function(d, i) { return i & 1 ? this : null; });

  // selection.merge //
  //-----------------//
  // - selection.merge(other).
  // - Объединить выборки [не произвольные, обычно ENTER + UPDATE].
  // - Возвращает новую выборку, объединяя выботки selection с other.
  // - Результирующая выборка имеет то же число групп и родителей, что и selection.
  // - Обычно этот метод используется для объединения выборок enter и update после data-join.
  //   Мосле модификации эл-тов в выборках enter и update, можно их
  //   объединить, и выполнять операции сразу на всех эл-х выборки enter+update.

    • UPDATE

        var circle = svg.selectAll("circle").data(data) // UPDATE
            .style("fill", "blue");

    • EXIT

        circle.exit().remove();   // EXIT

    • ENTER, ENTER + UPDATE

        circle.enter().append("circle") // ENTER
          .style("fill", "green")
          .merge(circle)                // ENTER + UPDATE
          .style("stroke", "black");

  // d3.matcher //
  //------------//
  // - d3.matcher(selector).
  // - Возвращает функцию, которая возвращает true, если эл-т this соответствует указанному селектору [для внутреннего использования D3].
  // - Автопрефиксинг для браузерных префиксов не поддерживается.

    • Например, эти 2 выражения эквивалентны:

        var div = selection.filter("div");
        var div = selection.filter(d3.matcher("div"));

  // d3.selector //
  //-------------//
  // - d3.selector(selector).
  // - Возвращает функцию, которая возвращает первый для this элемент-потомок, соотв-ий указанному селектору [для внутреннего использования D3].

    • Например, эти 2 выражения эквивалентны:

        var div = selection.select("div");
        var div = selection.select(d3.selector("div"));

  // d3.selectorAll //
  //----------------//
  // - d3.selectorAll(selector).
  // - Возвращает функцию, которая возвращает все для this элементы-потомки, соотв-щие указанному селектору [для внутреннего использования D3].

    • Например, эти 2 выражения эквивалентны:

        var div = selection.selectAll("div");
        var div = selection.selectAll(d3.selectorAll("div"));

  // d3.window //
  //-----------//
  // - d3.window(node).
  // - Возвращает окно-владельца для указанного node.


