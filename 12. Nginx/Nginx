////==================================================////
////                                                  ////
////                       NGINX                      ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  
  # Официальный сайт NGINX
      http://nginx.org/

  # Официальный блог NGINX (много прикладных решений)
      https://www.nginx.com/blog/

  # 3rd Party Modules for NGINX
      https://www.nginx.com/resources/wiki/modules/

  # Задействованные книги

    1) Администрирование Сервера NGINX, Димитрий Айвалиотис
        https://drive.google.com/open?id=0B0fGmPog14Ynd0U2OXNFY0ltMDA

    2) NGINX: A Practical Guide To High Perfomance, Stephen Corona
        https://drive.google.com/open?id=0B0fGmPog14YnZmE1VUxmcHFkeDg  

    3) Instant Nginx Starter, Martin Fjordvald
        https://drive.google.com/open?id=0B0fGmPog14YnN2ZGMHNWZG1RR2M

    4) Nginx HTTP Server, Clément Nedelcu
        https://drive.google.com/open?id=0B0fGmPog14YnWXRaX295MXd1WVU

  # Блог Martin Fjordvald

    - [v] BLOG
        https://martinfjordvald.com

    - [v] NGINX CONFIGURATION PRIMER
        https://martinfjordvald.com/2010/07/nginx-primer/

    - [v] UNDERSTANDING THE NGINX CONFIGURATION INHERITANCE MODEL
        https://martinfjordvald.com/2012/08/understanding-the-nginx-configuration-inheritance-model/

    - WEBSOCKETS IN NGINX
        https://martinfjordvald.com/2013/02/websockets-in-nginx/

    - FASTCGI_PARAMS VERSUS FASTCGI.CONF – NGINX CONFIG HISTORY
        https://martinfjordvald.com/2013/04/nginx-config-history-fastcgi_params-versus-fastcgi-conf/

    - DEBUGGING NGINX ERRORS
        https://martinfjordvald.com/2013/06/debugging-nginx-errors/

    - OPTIMIZING NGINX FOR HIGH TRAFFIC LOADS
        https://martinfjordvald.com/2011/04/optimizing-nginx-for-high-traffic-loads/

    - SECURING NGINX + PHP WHEN USING PATH INFO
        https://martinfjordvald.com/2011/06/why-path-info-is-the-worst-php-feature-since-register-globals/

    - [1/2] 12,000 REQUESTS PER SECOND WITH NGINX, PHP AND MEMCACHED
        https://martinfjordvald.com/2010/09/12000-requests-per-second-with-nginx-php-and-memcached/

    - [2/2] IMPLEMENTING FULL-PAGE CACHING WITH NGINX AND PHP
        https://martinfjordvald.com/2011/02/implementing-full-page-caching-with-nginx-and-php/

    - HOW TO SOLVE “NO INPUT FILE SPECIFIED” WITH PHP AND NGINX
        https://martinfjordvald.com/page/4/

    - OPTIMIZED FILE UPLOADING WITH PHP & NGINX
        https://martinfjordvald.com/2010/08/file-uploading-with-php-and-nginx/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////

//-------------------------//
// А. Теоретические основы //
//-------------------------//

  А1. Общая информация об NGINX
  А2. Об этой методичке
  А3. Проблема 10000 соединений
  А4. Главный и рабочие процессы
  А5. Структура конфигурационного файла


//--------------------------//
// Б. Прикладная информация //
//--------------------------//

  Б1. Установка NGINX на Ubuntu: менеджер пакетов
  Б2. Установка NGINX на Ubuntu: сборка из исходных файлов
  Б3. Обновление NGINX до новой версии без его остановки
  Б4. Опции NGINX, остановка/перезагрузка через сигналы главному процессу
  Б5. Блочная директива server: виртуальные хосты в NGINX
  Б6. Обработка запросов статических файлов
  Б7. Блочная директива location
  Б8. Применение изменённого конфига к работающему NGINX


 Про кэширование:
 https://serversforhackers.com/nginx-caching/


//-------------------------------------------------//
// В. Справочник по нужным мне официальным модулям //
//-------------------------------------------------//

  --------  
  В1. Ядро  |? Встроенный в ядро NGINX функционал                     
  --------

                  |! events
    accept_mutex  |? Описание
                  |% [on | off]; По умолчанию: on





          accept_mutex          |
          accept_mutex_delay    |
          daemon                |
          debug_connection      |
          debug_points          |
          error_log             |
          env                   |
          events                |
          include               |
          lock_file             | 
          master_process        |
          multi_accept          |
          pcre_jit              |
          pid                   |
          ssl_engine            |
          thread_pool           |
          timer_resolution      |
          use                   |
          user                  |
          worker_aio_requests   |
          worker_connections    |
          worker_cpu_affinity   |
          worker_priority       |
          worker_processes      |
          worker_rlimit_core    |
          worker_rlimit_nofile  |
          working_directory     | 


    В2. ngx_http_core_module


    В3. ngx_http_access_module


    В4. ngx_http_autoindex_module


    В5. ngx_http_charset_module


    В6. ngx_http_empty_gif_module


    В7. ngx_http_fastcgi_module


    В8. ngx_http_headers_module


    В9. ngx_http_image_filter_module


    В10. ngx_http_limit_conn_module


    В11. ngx_http_proxy_module


    В12. ngx_http_rewrite_module


    В13. ngx_http_split_clients_module


    В14. ngx_http_ssl_module


    В15. ngx_http_status_module


    В16. ngx_http_stub_status_module


    В17. ngx_http_upstream_module


    В18. ngx_http_upstream_conf_module


    В19. ngx_http_userid_module




  //-----------------------------------------------//
  // Г. Справочник по нужным мне сторонним модулям //
  //-----------------------------------------------//

    Г1. array-var-nginx-module
          https://github.com/openresty/array-var-nginx-module

    Г2. Dynamic Upstream
          https://github.com/yzprofile/ngx_http_dyups_module

    Г3. nginx-ey-balancer
          https://github.com/ezmobius/nginx-ey-balancer

    Г4. Upstream Fair Balancer
          https://www.nginx.com/resources/wiki/modules/fair_balancer/

    Г5. Fancy Index
          https://www.nginx.com/resources/wiki/modules/fancy_index/

    Г6. Form Input
          https://www.nginx.com/resources/wiki/modules/form_input/

    Г7. Headers More
          https://github.com/openresty/headers-more-nginx-module

    Г8. HTTP Healthcheck
          https://github.com/cep21/healthcheck_nginx_upstreams

    Г9. HTTP Push
          https://github.com/slact/nginx_http_push_module

    Г10. Internal Redirect
          https://github.com/flygoast/ngx_http_internal_redirect/ 

    Г11. IP2Location
          https://github.com/chrislim2888/ip2location-nginx

    Г12. Limit Upstream Connection
          https://github.com/cfsego/nginx-limit-upstream/

    Г13. PageSpeed
          https://github.com/pagespeed/ngx_pagespeed

    Г14. HTTP Redis
          https://www.nginx.com/resources/wiki/modules/redis/

    Г15. Redis2
          https://www.nginx.com/resources/wiki/modules/redis2/

    Г16. Secure Download
          https://www.nginx.com/resources/wiki/modules/secure_download/

    Г17. Sticky upstream
          https://github.com/Qihoo360/ngx_http_subrange_module

    Г18. SysGuard
          https://github.com/alibaba/nginx-http-sysguard

    Г19. NGINX Upload Progress Module
          https://www.nginx.com/resources/wiki/modules/upload_progress/

    Г20. Zip
          https://www.nginx.com/resources/wiki/modules/zip/








  # В. Справочник директив NGINX

    В1. Директивы глобальной секции

      - user                | пользователь и группа, от имени которых работает nginx
      - worker_processes    | кол-во рабочих процессов, создаваемых сразу после запуска
      - error_log           | файл для записи в него сообщений об ошибках
      - pid                 | файл с ID главного процесса (переопределение значения, заданного на этапе компиляции)
      - use                 | метод обработки соединения (переопределение значения, заданного на этапе компиляции)
      - worker_connections  | MAX число соединений, одновременно открытых в 1-м рабочем процессе

    В2. Секция HTTP-сервера: клиентские директивы

      - chunked_transfer_encoding     | позволяет отключить специфицированный в стандарте HTTP/1.1 механизм поблочной передачи данных в ответе клиенту
      - client_body_buffer_size       | задаёт размер буфера для чтения тела запроса клиента
      - client_body_in_file_only      | используется для отладки или последующей обработки тела запроса клиента
      - client_body_in_single_buffer  | заставляет NGINX сохранить всё тело запроса клиента в 1-м буфере
      - client_body_temp_path         | определяет путь к каталогу для сохранения файлов с телами запросов клиентов
      - client_body_timeout           | задаёт время между последовательными операциями чтения тела запроса клиента
      - client_header_buffer_size     | задаёт размер буфера для чтения заголовка запроса клиента
      - client_header_timeout         | время, отведённое на чтение всего заголовка запроса
      - client_max_body_size          | максимальный размер тела запроса клиента
      - keepalive_disable             | запрещает соединения типа keep-alive для некоторых браузеров
      - keepalive_requests            | определяет, сколько запросов можно принять по одному соединению типа keep-alive
      - keepalive_timeout             | определяет, сколько времени соединение типа keep-alive может оставаться открытым
      - large_client_header_buffers   | задаёт максимальное число и размер буферов для чтения большого заголовка запроса клиента
      - msie_padding                  | разрешает или запрещает добавлять комментарии в ответы со статусом больше 400
      - msie_refresh                  | разрешает или запрещает отправлять MSIE-клиентам ответ Refresh вместо перенаправления

    В3. Секция HTTP-сервера: директивы хэш-таблиц

      - server_names_hash_bucket_size |
      - server_names_hash_max_size    |
      - types_hash_bucket_size        |
      - types_names_hash_max_size     |
      - variables_hash_bucket_size    |
      - variables_names_hash_max_size | 

    В4. Секция HTTP-сервера: директивы сокетов

      - lingering_close             |
      - lingering_time              |
      - lingering_timeout           |
      - reset_timedout_connection   |
      - send_lowat                  |
      - send_timeout                |
      - tcp_nodelay                 |
      - tcp_nopush                  | 





////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////

А1. Общая информация об NGINX

  --------------------------------------
  Подоглавление:

    # Расшифровка "NGINX"
    # Что такое NGINX
    # Кто создал NGINX
    # Статистика за август 2015
    # Лицензия распространения (en)
    # Лицензия распространения (ru)
    # Коммерческая поддержка
    # Обзор возможностей NGINX

  --------------------------------------

  > Расшифровка "NGINX"
    - NGINX читается, как "Engine X".

  > Что такое NGINX
    - Это: 

      # HTTP-сервер
      # Обратный прокси-сервер
      # Почтовый прокси-сервер
      # TCP прокси-сервер общего назначения

    - Вот небольшой, но ёмкий вводный абзац про NGINX:

        NGINX - один из серверов, написанных для решения 
        проблемы C10K. В отличие от традиционных серверов,
        NGINX не полагается на потоки для управления запросами.
        Вместо них он использует хорошо масштабируемую 
        архитектуру, основанную на событиях. Она использует
        малые, но, что важно, намного более предсказуемые
        под нагрузкой по размеру массивы памяти. Даже если
        Вы не планируете обрабатывать тысячи одновременных
        запросов, Вы всё ещё можете воспользоваться такими
        преимуществами NGINX, как высокая производительность
        и малое потребление памяти. NGINX легко масштабируется:
        от самых маленьких VPS до крупных серверных кластеров.

  > Кто создал NGINX
    - NGINX изначально написан Игорем Сысоевым.
    - Вот ссылка на его личный блог:

        http://sysoev.ru/

    - Родился в 1970 году, детство и школьные годы прошли в Алма-Ате.
    - В 1994 году я окончил МВТУ им. Баумана.
    - Сейчас живёт в Москве и работет в NGINX, Inc.
    - Email: igor@sysoev.ru

  > Статистика за август 2015
    - Ниже данные, согласно статистике компании Netcraft.
    - NGINX обслуживал или проксировал 22.61% самых нагруженных сайтов.
    - Пруфлинк:

        http://news.netcraft.com/archives/2015/08/13/august-2015-web-server-survey.html

  > Лицензия распространения (en)

    Copyright (C) 2002-2015 Igor Sysoev
    Copyright (C) 2011-2015 Nginx, Inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1.  Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
    2.  Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

        THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        SUCH DAMAGE.
 
  > Лицензия распространения (ru)
    (перевод мой непрофессиональный + google translate)

    Авторское право (C) 2002-2015 Игорь Сысоев
    Авторское право (C) 2011-2015 Nginx, Inc.
    Все права защищены.

    Распространение и использование в исходной и двоичной формах, с или без
    модификации, разрешается, при условии, что выполнены следующие условия:
    1.  При повторном распространении исходного кода должно оставаться 
        указанное выше уведомление об авторских правах, этот список 
        условий и последующий отказ от гарантий.
    2.  При распространении в двоичной форме, требуется воспроизводить указанное 
        выше уведомление об авторских правах, этот список условий и 
        последующий отказ от гарантий в документации и / или других 
        материалов, предоставленных с распространением.  

        ЭТО ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ АВТОРОМ B СОАВТОРАМИ-РАЗРАБОТЧИКАМИ 
        "КАК ЕСТЬ", И ЛЮБЫЕ ЯВНЫЕ ИЛИ НЕЯВНЫЕ ГАРАНТИИ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ,
        НЕЯВНЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ ЦЕЛИ, 
        НЕ ПРИЗНАЮТСЯ. НИ В КОЕМ СЛУЧАЕ АВТОР НЕ НЕСЕТ ОТВЕТСТВЕННОСТИ ЗА КАКИЕ-ЛИБО 
        ПРЯМЫЕ, КОСВЕННЫЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ, ШТРАФНЫЕ ИЛИ КОСВЕННЫЕ УБЫТКИ 
        (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ, ПРИОБРЕТЕНИЕМ ТОВАРОВ-ЗАМЕНИТЕЛЕЙ ИЛИ 
        УСЛУГ-ЗАМЕНИТЕЛЕЙ; ПОТЕРИ ДАННЫХ, ПОТРЕБИТЕЛЬСКИХ КАЧЕСТВ ИЛИ ПРИБЫЛИ, 
        ИЛИ ПРЕРЫВАНИЕМ БИЗНЕС-ДЕЯТЕЛЬНОСТИ) НЕЗАВИСИМО ОТ ПРИЧИНЫ И ИСТОЧНИКОВ 
        ОТВЕТСТВЕННОСТИ, НЕЗАВИСИМО ОТ КОНТРАКТА, СТРОГОЙ ОТВЕТСТВЕННОСТИ, 
        ИЛИ ПРАВОНАРУШЕНИЯ (В ТОМ ЧИСЛЕ ХАЛАТНОСТЬ), ВОЗНИКАЮЩИЕ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ 
        ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ ПРИ УСЛОВИИ ИНФОРМИРОВАНИЯ 
        О ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.

  > Коммерческая поддержка
    - Осуществляется компанией Nginx, Inc.

  > Обзор возможностей NGINX
    - Можно посмотреть на главной странице оф.сайта NGINX:

        http://nginx.org/ru/


А2. Об этой методичке

  --------------------------------------
  Подоглавление:

    # Что такое NGINX
    # О чём, и для чего эта методичка
    # Методичка разбита на 3 раздела

  --------------------------------------

  > Что такое NGINX
    - Высокопроизводительный веб-сервер, потребляющий мало ресурсов.
    - NGINX читается, как "Engine X".

  > О чём, и для чего эта методичка
    - Это методичка по работе с NGINX.
    - Её задача помогать настраивать NGINX под требуемые задачи.

  > Методичка разбита на 3 раздела

    А. Теоретические основы
      - Здесь подробно описаны теоретические основы по работе с NGINX.
      - Пространно рассматриваются различные аспекты этой работы.    

    Б. Прикладная информация и инструкции
      - Здесь сугубо прикладная информация, часто в виде инструкций.
      - Название главы из этого раздела часто отражает желаемую цель.

    В. Справочник директив NGINX
      - Здесь списки директив, их описание, примеры использования.
      - Директивы разбиты на тематические группы.


А3. Проблема 10000 соединений

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Расшифровка "C10K"
    # История термина
    # Рекоментации от Дэна

  --------------------------------------

  > Ссылки

      # Проблема 10000 соединений (wiki):  
          https://en.wikipedia.org/wiki/C10k_problem

      # The C10K problem (статья от Dan Kegel, en):
          http://www.kegel.com/c10k.html

  > Расшифровка "C10K"
    - Термин расшифровывается так: "Clients 10000".

  > История термина
    - Термин придумал Dan Kegel в 1999 году в своей статье.
    - Он ссылался в ней на сайт cdroom.com, выдерживающий тогда 10000
      одновременных соединений через 1-гигабитный канал интернета.
    - В этой статье он пишет, что "железо" перестало быть основным
      ограничивающим фактором (бутылочным горлышком) для обслуживания
      большого количества одновременных запросов.
    - И что теперь этим "бутылочным горлышком" стал неэффективный
      код, обслуживающий клиентские запросы.
    - Ссылка на эту его статью:

        http://www.kegel.com/c10k.html

  > Рекоментации от Дэна
    - Основная часть статьи Дэна посвящена рекомендациям и ссылкам,
      как оптимизировать сервер для того, чтобы он мог обслуживать
      10000 одновременных запросов от клиентов.


А4. Главный и рабочие процессы

  --------------------------------------
  Подоглавление:

    # Введение
    # Главный и рабочие процессы NGINX
    # NGINX использует события
    # Управление количеством рабочих процессов
    # Сигналы главному процессу

  --------------------------------------

  > Введение
    - Эта короткая глава про главный и рабочие процессы NGINX.
    - Просто короткая заметка для общего понимания вопроса.

  > Главный и рабочие процессы NGINX
    - У NGINX есть 1 главный, и N рабочих процессов.
    - Основные задачи главного процесса:

      1) Чтение и проверка конфигурации.
      2) Управление рабочими процессами.

    - Рабочие же процессы выполняют фактическую обработку запросов.

  > NGINX использует события
    - NGINX использует модель, основанную на событиях.
    - Практическая реализация этого зависит от ОС.
    - В итоге, запросы эффективно распределяются между рабочими процессами.

  > Управление количеством рабочих процессов
    - Управлять количеством рабочих процессов можно в конфиге.
    - Для этого применяется директива "worker_processes".
    - Оно может быть:

      1) Фиксированным, и равным явно заданному значению.
      2) Автоматически устанавливаться равным числу доступных процессорных ядер.

  > Сигналы главному процессу
    - Главному процессу можно посылать сигналы.
    - И, таким образом, управлять им.
    - Подробнее об этом смотри в главе Б3.


А5. Структура конфигурационного файла

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Комментарии в конфиге
    # Файлы-конфиги можно include'ить друг в друга
    
    # Модули, директивы, конфиг
    # Родные и сторонние модули
    # Простые и блочные директивы
    
    # Локальный и глобальный (main) контексты
    # Ограничения на контекст у директив
    # В NGINX есть всего 6 возможных контекстов
    # Основная настройка идёт в блоках http, server, location
    
    # Стандартная модель наследования директив
    # Можно выделить 4 группы директив в контексте наследования
    # Наследование для "нормальных директив"
    # Наследование для "директив - массивов"
    # Наследование для "директив - действий"
    # Наследование для "директив - действий" внутри контекстов Location
    # Наследование для "try_files - директив"

  --------------------------------------

  > Ссылки

    # Статья о наследовании директив в конфиге NGINX (en)
        https://blog.martinfjordvald.com/2012/08/understanding-the-nginx-configuration-inheritance-model/

  > Введение
    - В этой главе дан общий план структуры конфига NGINX.
    - Задачей этой главы является формирование общей картины о сабже.

  > Комментарии в конфиге
    - Часть строки после символа # считается комментарием.

  > Файлы-конфиги можно include'ить друг в друга
    - В любое место любого конфига можно подключить ещё конфиг.
    - Это делается с помощью директивы include. Например:

        include /opt/local/etc/nginx/mime.types;

    - Метасимволы в пути позволяют включить сразу нескольк файлов. Например:

        include /opt/local/etc/nginx/vhost/*.conf;

  > Модули, директивы, конфиг
    - NGINX состоит из ядра и подключаемых к нему модулей.
    - Ядро и модули настраиваются директивами.
    - Директивы прописываются в конфигурационном файле.

  > Родные и сторонние модули
    - Модули бывают родные и сторонние.
    - Подробнее о них:

      1) Родные модули
        - Это модули от разработчиков NGINX.
        - Все они перечислены в официальной документации:
            http://nginx.org/ru/docs/

      2) Сторонние модули
        - Это модули не от разработчиков NGIXN.
        - Такой модуль может написать любой.
        - Часть из них перечислена на оф.сайте nginx:
            https://www.nginx.com/resources/wiki/modules/

  > Простые и блочные директивы
    - Директивы бывают простые и блочные.
    - Подробнее о них:

      1) Простая директива
        - Состоит из имени и параметров, оканчивается точкой с запятой (;).
        - Например: 

            worker_processes auto;

      2) Блочная директива
        - Устроена практически также, как и простая.
        - Но в конце, вместо точки с запятой, следует блок.
        - Блок представляет из себя фигурные скобки: {}.
        - Внутри них помещаются дополнительные инструкции.
        - Вот пример блочной директивы, а у неё в блоке простая:

            events {
              worker_connections 768;
            }

        - Примеры блочных директив: events, http, server, location.

  > Локальный и глобальный (main) контексты
    - Контекст бывает локальным и глобальным.
    - Подробнее о них:

      1) Локальный контекст
        - Это пространство внутри фигурных скобок любой блочной директивы.
        - Пример простой директивы, помещённой в локальный контекст 
          блочной директивы http:

            http {
              sendfile off;
            }

      2) Глобальный контекст main
        - Это пространство вне фигурных скобок блочных директив.
        - Считается, что простая директива, помещённая в конфиге
          вне любого локального контекста, находится в глобальном
          контексте main.
        - Пример простой директивы, помещённой в глобальный 
          контекст (она находится в самом начале файла):

            Файл /etc/nginx/nginx.conf
            --------------------------
              user vagrant;
              ... прочие директивы ... 

  > Ограничения на контекст у директи
    - Каждая директива может находиться не в каждом контексте.
    - А лишь в тех контекстах, в которых ей находитсья позволено.
    - Для каждой директивы список допустимых контекстов указан в оф.справке.
    - Примеры:

      1) Директивы events и http могут находиться в контексте main.
      2) Директива server может находиться в контексте http.
      3) Директива location может находиться в контексте server.

  > В NGINX есть всего 6 возможных контекстов
    - Они перечислены ниже в порядке:

      # Main (глобальный)
      # Http
      # Server
      # If
      # Location
        
        # Вложенный Location
        # If в Location
        # limit_except 

  > Основная настройка идёт в блоках http, server, location
    - Основная часть настроек производится именно
      в указанных в заголовке блоках.
    - Причём, иерархия этих блоков выглядит так:
      http -> server -> location -> location -> ...

  > Стандартная модель наследования директив
    
    # Стандартная модель
      - Дочерний контекст наследует директивы родительского, но лишь
        те, которые разрешены в данном дочернем контексте.
      - Наследование директив контекста производится только потомками.
        Но не соседями, или родителяями.

    # Перезапись унаследованной директивы в дочернем контексте
      - Допустим, дочерний контекст унаследовал директиву X.
      - В нём можно её перезаписать, если нужно. Или оставить.

  > Можно выделить 4 группы директив в контексте наследования
    - Есть особенности в работе наследования для разных директив.
    - По этому признаку, можно выделить 4 таких группы директив:

      1) Нормальные директивы
        - Имеющие лишь одно значение в одном контексте.
        - Например, директива user в контексте main
          имеет лишь 1 значение vagrant:

            user vagrant;

      2) Директивы - массивы
        - Имеющие N значений в одном контексте.
        - Например, директива access_log может иметь
          несклько значений, т.к. на одном уровне допускается
          использование нескольких логов:

            http {
              access_log /path/to/log1.gz
              access_log /path/to/log2.gz
              access_log /path/to/log3.gz
            }

      3) Директивы - действия
        - Которые являются не только простой конфигурацией.
        - Но и осуществляют некое действие.
        - Например, директива rewrite, заменяющая uri, 
          если он совпадает с regex, причём, на одном уровне
          может быть сколько угодно rewrite, они будут выполняться
          последовательно:

            http {
              server {
                rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
                rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;              
              }
            }

      4) Try-files - директивы
        - Директивы try_files.
        - Которые проверяют существование указанных файлов в заданном
          порядке, и используют для обработки запроса первый найденный:

            http {
              server {
                try_files $uri $uri/index.html $uri.html =404;            
              }
            }

  > Наследование для "нормальных директив"
    - Это самый простой случай.
    - Они следуют стандартной модели наследования.
    - Это наглядно демонстрирует пример ниже:

        server {
            root /home/user/public_html;
         
            location /app {
                root /usr/share; # Итоговый URI: /usr/share/app
                                 # Full URI is ALWAYS appended.
            }
         
            location /app2 {
                // Наследует директиву root из контекста server
            }
        }

  > Наследование для "директив - массивов"
    - В целом, они также следуют стандартной модели наследования.
    - В плане наследования "сверху-вниз", возможности перезаписи
      унаследованных значений в дочернем контексте.
    - В замешательство лишь может вводить следующий момент.
      Допустим, в родительском контексте мы применили 3
      директивы access_log. Что будет, если:

      А) В дочернем мы НЕ применяем access_log
        - Дочерний контекст унаследует все 3 значения 
          директивы access_log от отдительского.

      Б) В дочернем мы применяем access_log N раз
        - Дочерний контекст не унаследуен ни одного
          значения директивы access_log от родительского.

    - Всё это наглядно демонстрирует пример ниже:

        server {
            
            # Определяем массив значений для директивы access_log
            access_log /var/log/nginx/access.log;
            access_log /var/log/nginx/access2.log;
            
            # Определяем массив значений для директивы fastcgi_param
            # Подключая внешний конфиг
            include fastcgi.conf;
         
            # Применяем блочную директиву location
            location ~ ^/calendar/.+\.php$ {
                
                # После исполнения этой строки, все значения access_log 
                # из контекста server теряются
                access_log /var/log/nginx/php-requests.log; 
         
                # Эта директива "перезаписыват" массив значений из родит.контекста
                fastcgi_param ENV debug; 

                # ... тут мы что-то делаем ...

                # Вдруг, нам понадобился массив значений fastcgi_param в этом контексте
                # Мы берём, и снова их тут определяем (подключая внешний конфиг)
                include fastcgi.conf;

                # ... тут мы делаем что-то ещё ...
            
            }
        }

  > Наследование для "директив - действий"
    - Не наследуются.
    - Такая директива применяется только к тому контексту,
      в котором была определена.
    - Могут определяться во многих контекстах, где разрешена.
    - Например, директива rewrite разрешена как в контексте
      server, так и в контексте location. Рассмотрим пример:

        server {

            # Всегда исполняется
            rewrite ^/booking(.*) /calendar$1 permanent;
         
            location /calendar {

                # Не заменяет директиву rewrite из контекста server
                # А, вместо этого, может исполняться "в дополнение" к ней
                rewrite ^ /index.php; 

            }
        }      

  > Наследование для "директив - действий" внутри контекстов Location
    - Не регламентируется документацией nginx.
    - Полностью зависит от того, как оно определено в модуле.
    - Поэтому, для каждой директивы выясняется на практике...
    - Допустим, вот пример "не регламентированной" работы директивы rewrite:

        server {
            location /calendar {

                # Будет исполнена, если location ниже не сработает
                rewrite ^ /static.php; 
         
                location ~ \.php$ {

                    # Если этот location сработал, тогда внеший rewrite - не исполнился
                    fastcgi_pass backend; # Outer location context rewrite is not executed. 
                
                }

            }
        }

  > Наследование для "try_files - директив"
    - В целом работает, как любая другая директива - действие.
    - Особенность будет, если поместить try_files в контекст server.
    - В этом случае NGINX создаёт псевдо - location, который является
      наименее точным из всех.
    - Это значит, что если запрос попадёт в любой из определённых
      location, try_files в контексте server не исполнится.
    - Это значит, что если у Вас есть location /, который матчится
      со всеми запросами, то try_files в контексте server 
      НИКОГДА не будет исполнен.
    - Всё это наглядно демонстрируется на примере ниже:

        server {

            # Этот try_files никогда не будет исполнен
            # Потому что ниже есть location /, который матчится с любым запросом
            try_files $uri /index.php;
         
            location / {
                # Всякие директивы
            }
         
            location ~ \.php$ {
                
                # Если запрос попадёт в этот location, try_files всй равно не исполнится
                # Даже если бы location / не был определён

            }
        }    


Б1. Установка NGINX на Ubuntu: менеджер пакетов

  --------------------------------------
  Подоглавление:

    # Введение
    # Инструкция

  --------------------------------------

  > Введение
    - Здесь описана установка NGINX на Ubuntu с помощью менеджера пакетов.

  > Инструкция

    1. Открыть окно терминала
    2. Установить NGINX
      - Введите в окне терминала следующую команду:

          sudo apt-get install nginx

      - NGINX будет установлен по адресу: /etc/nginx


Б2. Установка NGINX на Ubuntu: сборка из исходных файлов

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Примечания
    # Инструкция
    # Параметры команды configure

      --prefix=[путь]               | путь к каталогу с файлами сервера
      --sbin-path=[путь]            | задаёт путь к исполняемому файлу nginx
      --conf-path=[путь]            | задаёт путь к конфигурационному файлу nginx.conf
      --pid-path=[путь]             | задаёт путь к файлу с именем главного процесса nginx.pid
      --error-log-path=[путь]       | задаёт путь к логу ошибок и диагностики error.log
      --http-log-path=[путь]        | задаёт путь к логу запросов access.log
      --user=[имя]                  | задаёт имя непривилегированного пользователя, с правами которого будут выполняться рабочие процессы
      --group=[имя]                 | задаёт имя группы, с правами которой будут выполняться процессы

      --with-select_module          | разрешает сборку соотв.модуля (Этот модуль собирается автоматически, если на платформе не обнаружено более подходящего метода — kqueue, epoll или /dev/poll.)
      --without-select_module       | запрещает сборку соотв.модуля

      --with-poll_module            | разрешает сборку соотв.модуля (Этот модуль собирается автоматически, если на платформе не обнаружено более подходящего метода — kqueue, epoll или /dev/poll.)
      --without-poll_module         | запрещает сборку соотв.модуля

      --without-http_gzip_module    | запрещает сборку модуля сжатия ответов HTTP-сервера
      --without-http_rewrite_module | запрещает сборку модуля 
      --without-http_proxy_module   | запрещает сборку проксирующего модуля HTTP-сервера

      --with-http_ssl_module        | разрешает сборку модуля для работы HTTP-сервера по протоколу HTTPS (По умолчанию модуль не собирается. Для сборки и работы этого модуля нужна библиотека OpenSSL)
      --with-pcre=[путь]            | задаёт путь к исходным текстам библиотеки PCRE
      --with-pcre-jit               | собирает библиотеку PCRE с поддержкой JIT-компиляции

      --with-zlib=[путь]            | задаёт путь к исходным текстам библиотеки zlib

      --with-cc-opt=[параметры]     | задаёт дополнительные параметры, которые будут добавлены к переменной CFLAGS
      --with-ld-opt=[параметры]     | задаёт дополнительные параметры, которые будут использованы при линковке

  --------------------------------------

  > Ссылки

    # Где искать сторонние модули
        http://wiki.nginx.org/3rdPartyModules 

  > Введение
    - Здесь описана сборка NGINX на Ubuntu из исходных файлов.

  > Примечания

    # Куда установится nginx
      - При сборке из исходных файлов, по умолчанию, он установится в:
          /usr/local/nginx/
      - В то время, как при установке с помощью менеджера пакетов, в:
          /etc/nginx
      - Чаще всего, именно 2-й вариант предпочтителен.
      - Совет: при сборке из исходных файлов, явно указывать адрес установки.

    # При установке через менеджер пакета, её нельзя сконфигурировать
      - Часто требуется настроить комплектацию NGINX при его установке.
      - Но при установке через менеджер пакетов, этого сделать нельзя.
      - Зато при установке из исходных файлов, это сделать можно.

    # Из менеджера пакета устанавливается на самая свежая версия
      - Поскольку пакет обновляется не сразу вслез за NGINX и модулями.
      - А через некоторое время.

  > Инструкция

    1. Установить NGINX с помощю менеджера пакетов
      - Как это сделать, описано в следующей главе выше:
          "Б1. Установка NGINX на Ubuntu: менеджер пакетов".
      - Для чего это нужно, если можно сразу собрать NGINX из исходников?
      - Дело в том, что при установке из исходников надо ввести конфигурационную строку.
      - Эта строка велика, и придумывать её "с нуля" самому дело трудозатратное.
      - Лучше взять стандартную конф.строку, и изменить в ней то, что требуется.
      - А взять её можно из уже установленного NGINX.

    2. Установить необходимые при сборке из исходных файлов пакеты

      2.1. Установить библиотеку OpenSSL
        - Она понадобится в процессе сборки NGINX из исходных кодов.
        - Сначала установите пакет openssl:

            sudo apt-get install openssl

        - Затем установите openssl shared library.
        - Для этого произведите поиск последней версии соотв.пакета:

            apt-cache search libssl | grep SSL

        - Из результатов поиска возьмите имя пакета.
        - И выполните его установку:

            sudo apt-get install libssl0.9.8

      2.2. Установить библиотеку PCRE (Perl Compatible Regular Expressions)
        - Она понадобится в процессе сборки NGINX из исходных кодов.
        - Выполните следующий код в окне терминала для установки библиотеки:

            sudo apt-get install libpcre3 libpcre3-dev

      2.3. Установить пакет build-essential
        - Он потребуется для осуществления сборки из исходников.
        - Для этого, выполните следующий код в окне терминала:

            sudo apt-get install build-essential

      2.4. Установить пакет zlib1g-dev
        - Он потребуется для распаковки исходников NGINX.
        - Для этого, выполните следующий код в окне терминала:

            sudo apt-get install zlib1g-dev

    3. Скачать и распаковать исходники NGINX и нужных модулей
      
      3.1. Создать временный каталог /temp
        - И перейти в него.
        - Для этого, в окне терминала выполнить следующий код:

          mkdir /temp
          cd /temp

      3.2. Загрузить в /temp последнюю стабильную версию NGINX
        - Её название посмотреть по адресу: nginx.org/download/
        - На 02.09.2015 её название: "nginx-1.9.4.tar.gz   "
        - Выполнить следующий код (указав найденную версию):

            sudo wget nginx.org/download/nginx-1.9.4.tar.gz

      3.3. Загрузить в /temp необходимые nginx-модули
        - Любым способом.

      3.4. Распаковать в /temp скаченные архивы с nginx и модулями
        - И перейти в каталог с распакованными исходниками NGINX.
        - Ниже рассматривается лишь распаковка nginx (без модулей).
        - Для этого, выполнить следующий код:

            sudo tar -xvzf nginx-1.9.4.tar.gz      
            cd nginx-1.9.4
      
    4. Сохранить в файл /temp/oldconfig текущую конфигурацию NGINX
      - Она понадобится при сборке NGINX из исходных файлов.
      - Для этого, сначала создайте файл /temp/oldconfig:

          sudo touch /temp/oldconfig

      - Затем выведите конфиг установленного nginx в окно терминала:

          nginx -V

      - Скопируйте текст, который идёт после "configure arguments: ".
      - Откройте файл /temp/oldconfig в редакторе:

          sudo nano /temp/oldconfig

      - Вставьте в него скопированный текст, и сохраните.

    5. Изменить сохранённую в /temp/oldconfig конфигурационную строку
      - Допустим, мы хотим добавить модуль ngx_pagespeed-1.7.30.1-beta.
      - И, допустим, этот модуль лежит в каталоге /temp/ngx_pagespeed-1.7.30.1-beta.
      - Тогда, в конец конфиг.строки надо дописать:

          --add-module=/temp/ngx_pagespeed-1.7.30.1-beta

      - Допишите это в /temp/oldconfig, и сохраните файл.

    6. Выполнить предустановочное конфигурирование
      - Для этого, перво-наперво, перейти в каталог с исходниками nginx:

          cd /temp/nginx-1.9.4

      - В нём, выполнить команду ниже.
      - В неё заменить [конф. строка] на оную из /temp/oldconfig.

          ./configure [конф. строка]

      - Убедиться, что nginx не выдал на это ошибки.
      - В конце концов, должен быть создан файл Makefile.

    7. Выполнить сборку nginx
      - Для этого выполнить следующие команды в окне терминала:

          cd /temp/nginx-1.9.4
          make
          checkinstall

    8. Перезапустить nginx
      - Для этого выполнить следующую команду:

          sudo service nginx restart

  > Параметры команды configure
    - У команды configure есть ряд доступных параметров.
    - Они перечислены в оглавлении раздела.
    - Подробнее о них можно посмотреть по адресу:
        http://nginx.org/ru/docs/configure.html
    - Также в конф.строку можно добавлять параметры,
      добавляющие тот или иной модуль в сборку.
    - Справочник по "родным" модулям nginx можно глянуть тут (внизу):
        http://nginx.org/ru/docs/


Б3. Обновление NGINX до новой версии без его остановки

  --------------------------------------
  Подоглавление:

    # Введение
    # Что делает сингал reload
    # Инструкция по обновлению NGINX до новой версии без его остановки 

  --------------------------------------

  > Введение
    - Запустили какой-нибудь проект на NGINX, который сейчас работает.
    - Вышла новая версия NGINX, и надо обновить работающий NGINX.
    - Но любая остановка сервера, это убыток для компании.
    - Вопрос: как обновить работающий NGINX, не останавливая его?
    - В этой главе содержится ответ на этот вопрос.

  > Что делает сингал reload
    - Можно отправить сигнал reload серверу NGINX.
    - Для этого, надо в окне терминала ввести:

        nginx -s reload

    - Конфиг будет загружен заново, и будет открыт новый рабочий процесс.
    - Но главный процесс не изменится.

  > Инструкция по обновлению NGINX до новой версии без его остановки 

    1) Собрать и установить новую версию NGINX
    2) Найти ID работающего мастер-процесса NGINX
      - Для этого ввести в окне терминала:

          cat /var/run/nginx.pid

    3) Послать ему сигнал USR2
      - Это запустит новый главный процесс, и создаст новые рабочие процессы.
      - Для этого ввести в окне терминала:

          kill -USR2 [id старого главного процесса из 2]

      - Теперь, мы имеем 2 работающих главных процесса.

    4) Теперь надо мягко избавиться от старого главного процесса
      - Просто "убить" его командой kill нежелательно.
      - Это может оборвать обслуживание текущих запросов в обработке.
      - Лучше послать ему сигнал WINCH.
      - Тогда, старый главный процесс перестанет принимать новые
        запросы в обработку.
      - Для этого ввести в окне терминала:

          kill -WINCH [id старого главного процесса из 2]

      - С этого момента со всеми новыми запросами будет работать
        новый главный процесс.

    5) Теперь, осталось только прикончить старый главный процесс
      - Для этого ввести в окне терминала:

          kill -QUIT [id старого главного процесса из 2]


Б4. Опции NGINX, остановка/перезагрузка через сигналы главному процессу

  --------------------------------------
  Подоглавление:

    # Где конфиг NGINX, сменить путь к конфигу
    # Где исполняемый файл NGINX
    # Опции исполняемого файла

      -?, -h              | справка
      -v                  | версия
      -V                  | версия и конф.строка
      -t                  | проверить валидность конфига (синтаксис и наличие конфига и файлов, на которые ссылается)
      -T                  | то же, что t, но ещё выводит конфиг в STD output      
      -q                  | не показывать сообщ.не об ошибках во время проверки конф.строки
      -s [сигнал]         | отправить сигнал главному процессу: 
                            - stop      // остановить NGINX быстро
                            - quit      // остановить NGINX осторожно
                            - reload    // загрузить конфиг заново, открыть новый раб.процесс, осторожно закрыть старый
                            - reopen    // переоткрыть логи
      -p [префикс к пути] | установить префикс пути (по умолчанию: /usr/share/nginx)
      -c [путь]           | установить путь к конфигу
      -g [директивы]      | установить глобальные конф.директивы 
                            - Пример:
                                nginx -g "pid /var/run/nginx.pid; worker_processes `sysctl -n hw.ncpu`;"


  --------------------------------------

  > Где конфиг NGINX

    # При установке из источников
      - Если путь для конфига не был уточнён флагом --conf-path.
      - То: /usr/local/nginx/conf/nginx.conf

    # При установке из пакета на Ubuntu
      - Путь: /etc/nginx/nginx.conf

    # Для установленного NGINX узнать, где конфиг, можно так:
      - Ввести в окне терминала:

          nginx -t

    # Сменить путь к конфигу для установленного NGINX, можно так:
      - Ввести в окне терминала (заменив [путь] на путь к конфигу):

          ngins -c [путь]

  > Где исполняемый файл NGINX

    # При установке из пакета на Ubuntu
      - Путь: /usr/sbin/nginx
      - Соответственно, можно обращаться к нему просто по имени.

    # При установке из источников
      - Если путь для исп.файла не был уточнён флагом --sbin-path.
      - Путь: /usr/local/nginx/sbin/nginx

  > Опции исполняемого файла
    - См. оглавление.

 
Б5. Блочная директива server: виртуальные хосты в NGINX

  --------------------------------------
  Подоглавление:

    # Наглядный собирательный пример
    # Как NGINX решает, какой блок server использовать
    # Значения server_name: точные, с wildcards, с regexp

  --------------------------------------

  > Наглядный собирательный пример

    #-------------------------#
    # Это server по умолчанию #
    #-------------------------#
    # - Он отлавливает все запросы к NGINX с пустым HTTP-заголовком HOST
    # - Либо те запросы, к которых хост не подошёл ни к одному другому блоку server
    #   В том числе запросы, сделанные напрямую по IP адресу.
    # - И дропает их, немедленно закрывая соединение, и возвращая нестандартный код 444.
    server {  

      # Слушать порт 80, флаг "сервер по умолчанию"
      listen 80 default_server;  

      # Вернуть код 444, немедленно закрыть соединение
      return 444;

    }

    #-----------------------------------------------#
    # Это server для домена и поддоменов domain.com #
    #-----------------------------------------------#
    # - Он прослушивает порт 80.
    # - И обрабатывает все запросы к доменам и поддоменам domain.com.
    server {

      # Слушать порт 80
      listen 80;

      # Обрабатывать запросы с указанными хостами
      server_name domain.com *.domain.com;
   
      # Указать путь к каталогу с индексным файлом приложения
      # Эту директиву будут наследовать все location'ы
      root /home/domain.com;

      # Указать список имён, для поиска по ним индексноо файла в root
      # Эту директиву будут наследовать все location'ы
      index index.html index.php;

    }

    #-----------------------------------#
    # Это server для домена another.com #
    #-----------------------------------#
    # - Он прослушивает порт 80.
    # - С него мы хотим переадресовывать запросы на domain.com      
    server {

      # Слушать порт 80
      listen 80;

      # Указать хосты
      # Во 2-м хосте использован wildcard-символ * (матчится с чем угодно)
      # Например, будет матчиться с запросами: img.domain.com, www.domain.com
      server_name another.com;
      
      # Осуществить редирект
      return 301 $scheme://www.domain.com$request_uri;
  
    }

       
  > Как NGINX решает, какой блок server использовать

    1. Сначала отбирает по IP и порту
      - NGINX извлекает из запроса инфу об IP и порте запроса.
      - И отбирает блоки server, которые подходят по этим параметрам.
      - IP и порт, которые слушает блок, задаётся в нём директивой listen.
      - Значения по умолчанию для listen (если не определена): любой IP и порт 80.

    2. Затем отбирает по хосту
      - NGINX извлекает из HTTP-заголовка HOST инфу о хосте запроса.
      - И отбирает блоки server, которые подходят по этому параметру.
      - Хосты блока задаются директивой server_name.

    3. Затем из получившегося набора кандидатов выбирает лишь 1

      3.1. Если 0 кандидатов
        - То есть, ни один блок server не прошёл этап №2.
        - Тогда NGINX выбирает блок server по умолчанию.
        - Блоком server по умолчанию считается:

          1] Самый верхний блок server в конфиге
            - Но лишь если флаг default_server не использован
              ни в одной директиве listen ни в одном блоке server.

          2] Блок сервер, помеченный флагом default_server
            - То блок, в котором определена директива listen,
              которая помечена флагом default_server.

        - Рассмотрим пару примеров с запросом ivan.com к 80-му порту.
        - Пример №1. 
          - Хост ivan.com не подходит ни к одному из определённых блоков server.
          - Здесь сервер по умолчанию тот, который выше. Он и сработает.

            server {  
              listen 80;  
              server_name example.com;
            }
            server {  
              listen 80; 
              server_name foobar.com;
            }

        - Пример №2. 
          - Хост ivan.com не подходит ни к одному из определённых блоков server.
          - Здесь сервер по умолчанию тот, который ниже.
          - Потому что в нём есть директива listen с флагом default_server.
          - Он и сработает.

            server {  
              listen 80;  
              server_name example.com;
            }
            server {  
              listen 80 default_server; 
              server_name foobar.com;
            }            

      3.2. Если 1 кандидат
        - То есть, лишь один блок server прошёл этап №2.
        - Тогда он и используется.
        - Рассмотрим пример с запросом ivan.com к 80-му порту.

          - Здесь будет исполнен тот server, который ниже.
          - Потому что его server_name подходит к хосту запроса.

            server {  
              listen 80; 
              server_name foobar.com;
            }   
            server {  
              listen 80;  
              server_name ivan.com;
            }

      3.3. Если > 1 кандидата
        - То NGINX выбирает среди них лишь 1, и исполняет его.
        - Процесс выбора выглядит описан ниже.
        - Он продолжается до тех пор, пока 1 блок server не будет выбран.

          1] NGINX отбирает блоки server с точными server_name
            - То есть, не содержащими wildcards или regexp.
            - Пример точного server_name: www.example.com
            - И среди них выбирает тот блок, который определён выше в конфиге.

          2] NGINX отбирает блоки, у которых server_name начинается с *
            - То есть, содержащие wildcard *, и начинающиеся с него.
            - Пример такого server_name: *.example.com
            - И среди них выбирает тот блок, который определён выше в конфиге.

          3] NGINX отбирает блоки, у которых server_name заканчивается на *
            - То есть, содержащие wildcard *, и заканчивающиеся на него.
            - Пример такого server_name: www.example.*
            - И среди них выбирает тот блок, который определён выше в конфиге.

          4] NGINX отбирает блоки, у которых в server_name есть regexp
            - Пример такого server_name: ~^www[0-9]\.example\.com$;
            - И среди них выбирает тот блок, который определён выше в конфиге.


  > Значения server_name: точные, с wildcards, с regexp
    
    # От 1 и более значений
      - Директива server_name может содержать от 1 и более значений.
      - Например:

          server_name example1.com example2.com example3.com;

    # Всего 3 вида значений
      - Значения директивы server_name бывают: 

        1) Точные             // наиболе точные
        2) С wildcards        
        3) С regexp           // наименее точные

    # Рассмотрим подробнее каждый из 3 видов значений

      1) Точные
        - Не содержат ни wildcards, ни regexp.
        - Пример такого значения:

            server_name www.example.com;

      2) С wildcards
        - Содержит wildcard, но не содержит regexp.
        - Пример такого значения:

            server_name ~^www[0-9]\.example\.com$

      3) С regexp
        - Содержит регулярное выражение.
        - Оно должно начинатсья с символа ~.
        - Пример такого значения:

            server_name ~^www\.example[0-9]\.com$

        - Рассмотрим ещё пример использования группы захвата в regexp.
        - Синтаксис (?<domain>.+) означает именованную группу захвата.
        - NGINX записывает значение HOST из запроса в переменную $domain.
        - Которая становится доступной для использования.
        - И заменяет конструкцию (?<domain>.+) на значение из $domain.
        - Допустим, если в запросе к серверу заголовок HOST == zaste.ru
        - То $domain == "zaste.ru".
        - А server_name ~^(www\.)?zaste\.ru$; 

          server {  
            
              # Слушать порт 80.
              listen 80; 

              # Указать хост с помощью regexp с группой захвата 
              server_name ~^(www\.)?(?<domain>.+)$;  

              location / {    
                  root /sites/$domain;  
              }
          }        


Б6. Обработка запросов статических файлов

  --------------------------------------
  Подоглавление:

    # Введение
    # Наглядный собирательный пример
    # Показ статической страницы "Сервер на обслуживании"

  --------------------------------------

  > Введение
    - Одной из базовых задач NGINX является раздача статичесих файлов.
    - Таких, как html, css, js, images и т.д.
    - В этой главе рассмотрены основы организации оной.

  > Наглядный собирательный пример

    #-------------------------------------------#
    # Это server для раздачи статических файлов #
    #-------------------------------------------#
    # - Задачей этого серера является раздача статических файлов.
    # - Файлы хранятся в каталоге /home/images.sample.com/public
    # - Он прослушивает порт 80.
    # - И обрабатывает все запросы к домену sample.com
    # - Например, если запросить - http://example.com/some.html - 
    #   то сервер вернёт файл /home/images.sample.com/public/some.html
    # - А если запросить - http://example.com/ - то сервер вернёт
    #   файл /home/images.sample.com/public/index.php
    server {

      # Слушать порт 80
      listen 80;

      # Обрабатывать запросы с указанным хостом
      server_name sample.com;
   
      # Указать путь к каталогу public приложения
      # Эту директиву будут наследовать все location'ы
      root /home/images.sample.com/public;

      # Указать список имён, для поиска по ним индексноо файла в root
      # Эту директиву будут наследовать все location'ы
      index index.php;

    }

  > Показ статической страницы "Сервер на обслуживании"
    - Бывает, что сервер требуется остановить для проведения работ.
    - Тогда можно настроить nginx на показ статического документа.
    - И в этом документе уведомлять пользователей о ситуации.
    - Для этого надо в директиве index указать имя статич. html-документа.
    - А в директиве рут путь к каталогу, где лежит статич.документ.
    - Пример:

      #----------------------------------------------------------------------------#
      # Это server для показа статического html-документа "Сервер на обслуживании" #
      #----------------------------------------------------------------------------#
      # - Допустим, мы хотим показать статический документ maintenance.html
      # - А он лежит в каталоге /home/maintenance
      # - Документ будет показан при запросе: http://sample.com
      server {

        # Слушать порт 80
        listen 80;

        # Обрабатывать запросы с указанным хостом
        server_name sample.com;
     
        # Указать путь к каталогу с файлом maintenance.html
        # Эту директиву будут наследовать все location'ы
        root /home/maintenance;

        # Указать имя файла maintenance.html
        # Эту директиву будут наследовать все location'ы
        index maintenance.html;

      }    


Б7. Блочная директива location

  --------------------------------------
  Подоглавление:

    # Введение
    # Несколько важных примечаний о location
    # Наглядный собирательный пример
    # Синтаксис директивы location
    # Добавление URI к root; замена значения root оным из alias
    # Модификаторы того, как NGINX матчит location с URI запроса
    
      - Про модификаторы
      - Краткий обзор модификаторов
      - Порядок точности для NGINX при выборе из набора блоков location
      - Подробнее о модификаторе =
      - Использование модификатора = улучшает производительность
      - Подробнее о модификаторе [нет]
      - Модификатор [нет] и перекрывающиеся запросы
      - Подробнее о модификаторе ~ 
      - Подробнее о модификаторе ~*
      - Подробнее о модификаторе @

    # Как NGINX решает, какой блок location использовать
    # Именованные locations
    # Использование location для редиректа со старых адресов на новые

  --------------------------------------

  > Введение
    - NGINX позволяет себя гибко настроить на разных уровнях.
    - На уровне протокола в блоке http.
    - На уровне сервера в блоке server.
    - На уровне URI запроса в блоке location.
    - Настройку последнего и рассмотрим в этой главе.

  > Несколько важных примечаний о location
    - Только лишь один из всех блок location будет исполнен
    - Рекомендуется размещать общие директивы в настолько высоком предке, насколько возможно
    - Из набора подходящих блоков location nginx выбирает наиболее точный (по аналогии с servers)
      - Это хорошо описано в оф. справке по директиве location.

  > Наглядный собирательный пример





  > Синтаксис директивы location
    - Базовый синтаксис директивы выглядит так:

      location [модификатор] uri_matcher {

        # ... директивы ...

      }    

    - Где модификатор может как быть, так и отсутствовать.
    - Доступные значения: [ = | ~ | ~* | ^~ | @ ]

  > Добавление URI к root; замена значения root оным из alias
    - Location можно настроить в этом плане 2-мя способами:

      1) Чтобы он добавлял URI к значению root
        - И искал по получившемуся адресу запрашиваемые файлы.

      2) Или самому указать путь к каталогу, где искать
        - Используя директиву alias.
        - !!! Важно указывать слэш / в конце значения директивы !!!

    - Проще всего эти вещи объяснить на примерах.
    - Рассмотрим 2 примера, наглядно иллюстрирующих оба случая:

      1) Добавление URI к пути, указанному в root

        #-----------------#
        # Какой-то server #
        #-----------------#
        # - Он прослушивает порт 80.
        # - И обрабатывает все запросы к доменам domain.com.
        # - В ответ на запрос - http://domain.com/foobar/file.html - 
        #   сработает описанный ниже location, и он вернёт в ответ
        #   файл, находящийся по адресу: /home/domain.com/public/foobar/file.html
        server {

          # Слушать порт 80
          listen 80;

          # Обрабатывать запросы с указанными хостами
          server_name domain.com;
       
          # Указать путь к каталогу public приложения
          # Эту директиву будут наследовать все location'ы
          root /home/domain.com/public;

          # Указать список имён, для поиска по ним индексного файла в root
          # Эту директиву будут наследовать все location'ы
          index index.html index.php;

          # Указать location для URI "/foobar/"
          location /foobar/ {  
            
            # Наследует root у родительского блока server

          }        

        }

      2) Замена URI на путь, указанный в alias

        #-----------------#
        # Какой-то server #
        #-----------------#
        # - Он прослушивает порт 80.
        # - И обрабатывает все запросы к доменам domain.com.
        # - В ответ на запрос - http://domain.com/foobar/file.html - 
        #   сработает описанный ниже location, и он вернёт в ответ
        #   файл, находящийся по адресу: /home/some/file.html, сформированному
        #   на основе значения alias, определённого в блоке location.
        server {

          # Слушать порт 80
          listen 80;

          # Обрабатывать запросы с указанными хостами
          server_name domain.com;
       
          # Указать путь к каталогу public приложения
          # Эту директиву будут наследовать все location'ы
          root /home/domain.com/public;

          # Указать список имён, для поиска по ним индексного файла в root
          # Эту директиву будут наследовать все location'ы
          index index.html index.php;

          # Указать location для URI "/foobar/"
          location /foobar/ {  
            
            # Укажем прямо адрес каталога, где искать запрашиваемый файл
            # - Слэш / в конце здесь важен!
            # - Иначе вместо того, чтобы вернуть /home/some/file.php,
            #   он вернёт /home/somefile.php.
            alias /home/some/;

          }        

        }

  > Модификаторы того, как NGINX матчит location с URI запроса

    ------------------------
    Подоглавление:

      # Про модификаторы
      # Краткий обзор модификаторов
      # Порядок точности для NGINX при выборе из набора блоков location
      # Подробнее о модификаторе =
      # Использование модификатора = улучшает производительность
      # Подробнее о модификаторе [нет]
      # Модификатор [нет] и перекрывающиеся запросы
      # Подробнее о модификаторе ~ 
      # Подробнее о модификаторе ~*
      # Подробнее о модификаторе @

    ------------------------

    # Про модификаторы
      - Когда поступает запрос, NGINX извлекает его URI.
      - И по нему ищет, какие блоки location подходят под него.
      - В соотв. с синтаксисом, у кажжого блока указан uri_matcher.
      - Но как именно NGINX будет матчить URI с uri_matcher?
      - Вот этим то и можно управлять с помощью модификаторов к uri_matcher.

    # Краткий обзор модификаторов
      - Ниже перечислены все доступные модификаторы.
      - Они описывают, как будет матчиться uri_matcher с URI запроса.

        [нет]     // будет матчиться, как префикс к любому URI
        =         // будет матчиться в режиме точного сравнения
        ~         // будет матчиться, как регистрозависимый regexp
        ~*        // будет матчиться, как регистронезависимый regexp
        ^~        // будет матчиться, как префикс к любому URI, 
                  // - но этот location будет более важный, чем c
                  //   regexp-модификаторами ~ и ~*
        @         // именованный location для внутреннего пользования

    # Порядок точности для NGINX при выборе из набора блоков location
      - Ниже перечислены все доступные модификаторы.
      - Они отсортированы в порядке точности с точки зрения NGINX.
      - Сверху более точные, снизу менее точные.
      - Как мы знаем, NGINX в итоге исполнит лишь 1 location для запроса.
      - В случае, если ему надо выбирать из N блоков location, он выберет
        наиболее точный из них.
      - Итак:

          =       // точное сравнение
          ^~      // префикс (важнее, чем regexp-модификаторы)
          ~, ~*   // regexp (регистрозависимый и регистронезависимый)
          [нет]   // префикс

    # Подробнее о модификаторе = 
      - URI запроса должен быть точно равен паттерну блока location.
      - Паттерн блока location в этом случае может быть лишь строкой.
      - Использовать regexp в данном случае запрещено.
      - Пример: 

        server {    
          server_name website.com;    
          location = /abcd {    
            # ... всякие директивы ...    
          }
        }

      - В ответ на какие запросы сработает location из примера:

        http://website.com/abcd
        http://website.com/ABCD     // windows  - да  (в нём регистронезависимая ФС) 
                                       linux    - нет (в нём регистрозависимая ФС) 
        http://website.com/abcd?param1&param2

      - В ответ на какие запросы не сработает location из примера

        http://website.com/abcd/      // из-за наличие слэша / в конце 
        http://website.com/abcde      // URI не соответствует в точности URI из location

    # Использование модификатора = улучшает производительность
      - Часто бывает важно даже немного улучшить производительность.
      - Когда серверу приходится обрабатывать большое кол-во запросов.
      - Использование модификатора = улучшает производительность.
      - Поскольку NGINX совершае меньше работы для определения нужного location.

    # Подробнее о модификаторе [нет]
      - URI запроса должен начинаться с паттерна блока location.
      - Паттерн блока location в этом случае может быть лишь строкой.
      - Использовать regexp в данном случае запрещено.
      - Пример:

        server {    
          server_name website.com;    
          location /abcd {    
            # ... всякие директивы ...    
          }
        }      

      - В ответ на какие запросы сработает location из примера:

        http://website.com/abcd
        http://website.com/ABCD     // windows  - да  (в нём регистронезависимая ФС) 
                                       linux    - нет (в нём регистрозависимая ФС) 
        http://website.com/abcd?param1&param2        

      - В ответ на какие запросы не сработает location из примера

        http://website.com/abcd/      // из-за наличие слэша / в конце 
        http://website.com/abcde      // URI не соответствует паттерну

    # Модификатор [нет] и перекрывающиеся запросы
      - А что в случае перекрывающихся запросов?
      - Допустим, имеются 2 таких вот блока location:

        location /foobar/images {  
          # ... всякие директивы ...
        }
        location /foobar/ 
        {  
          # ... всякие директивы ...
        }

      - И поступает запрос: domain.con/foobar/images/1.gif
      - В этом случае, исполнится первый location.
      - Потому что его паттерн /foobar/images считается более точным.

    # Подробнее о модификаторе ~ 
      - URI запроса долже матчиться с паттерном-regexp'ом.
      - Причём, регистрозависимо.
      - Пример:

        server {    
          server_name website.com;    
          location ~ ^/abcd$ {    
            # ... всякие директивы ...    
          }
        } 

      - В ответ на какие запросы сработает location из примера:

        http://website.com/abcd
        http://website.com/ABCD     // windows  - да  (в нём регистронезависимая ФС) 
                                       linux    - нет (в нём регистрозависимая ФС)         
        http://website.com/abcd?param1&param2        

      - В ответ на какие запросы не сработает location из примера

        http://website.com/abcd/      // из-за наличие слэша / в конце 
        http://website.com/abcde      // URI не соответствует паттерну

    # Подробнее о модификаторе ~* 
      - URI запроса долже матчиться с паттерном-regexp'ом.
      - Причём, регистронезависимо.
      - Пример:

        server {    
          server_name website.com;    
          location ~* ^/abcd$ {    
            # ... всякие директивы ...    
          }
        } 

      - В ответ на какие запросы сработает location из примера:

        http://website.com/abcd
        http://website.com/ABCD     // везде, в т.ч. windows и linux
        http://website.com/abcd?param1&param2        

      - В ответ на какие запросы не сработает location из примера

        http://website.com/abcd/      // из-за наличие слэша / в конце 
        http://website.com/abcde      // URI не соответствует паттерну

    # Подробнее о модификаторе @
      - Определяет именованный location.
      - У клиентов нет доступа к этим блокам.
      - Но к ним можно делать внутренние запросы.
      - С помощью таких директив, как try_files или error_page.
      - Подробнее об именованных locations см. ниже.


  > Как NGINX решает, какой блок location использовать

    1. Сначала просматривает блоки location с модификатором =
      - NGINX извлекает из запроса инфу о URI запроса.
      - Затем берёт все location с модификатором =
      - Из них отбирает те, чей паттерн равен URI запроса.
      - Из итоговой выборки берёт тот location, который выше в конфиге.

    2. Затем просматривает блоки location без модификатора
      - NGINX извлекает из запроса инфу о URI запроса.
      - Затем берёт все location без модификатора.
      - Из них отбирает те, чей паттерн ТОЧНО равен URI запроса.
      - Из итоговой выборки берёт тот location, который выше в конфиге.

    3. Затем просматривает блоки location с модификатором ^~
      - NGINX извлекает из запроса инфу о URI запроса.
      - Затем берёт все location с модификатором ^~.
      - Из них отбирает те, с чьего паттерна НАЧИНАЕТСЯ URI запроса.
      - Из итоговой выборки берёт тот location, который выше в конфиге.

    4. Затем просматривает блоки location с модификаторами ~ или ~*
      - NGINX извлекает из запроса инфу о URI запроса.
      - Затем берёт все location с модификаторами ~ или ~*.
      - Из них отбирает те, чей паттерн матчится с указанным regexp.
      - Из итоговой выборки берёт тот location, который выше в конфиге.

    5. Затем просматривает блоки location без модификатора
      - NGINX извлекает из запроса инфу о URI запроса.
      - Затем берёт все location без модификатора.
      - Из них отбирает те, с чьего паттерна НАЧИНАЕТСЯ URI запроса.
      - Из итоговой выборки берёт тот location, который выше в конфиге.

  > Именованные locations

    # Общая информация
      - Определяет именованный location.
      - У клиентов нет доступа к этим блокам.
      - Но к ним можно делать внутренние запросы.
      - С помощью таких директив, как try_files или error_page.
      - Подробнее об именованных locations см. ниже.

    # Использование с try_files
      
      # Ловим все запросу, у которых URI начинается с /
      location / {
        
        # Указываем путь к каталогу
        root /home/my;

        # Пробуем по очереди найти и вернуть указанные файлы в указанном каталоге
        # А в конце, если ничего другого не найдено, именованный location
        try_files maintenance.html index.html @foobar;

      }

      # Именованный location (с именем foobar)
      location @foobar {  
        
        # А здесь можно как-то обработать ошибку
        # Например, вернуть код 404
        return 404;
      
      }      

  > Использование location для редиректа со старых адресов на новые
    - Допустим, был у нас форум по адресу: site.ru/forum
    - Но мы решили изменить его адрес на: forum.site.ru.
    - Просто так это сделать нельзя из-за ссылок.
    - Многочисленные сторонние ссылки на темы перестанут работать.
    - Чтобы этого не произошло, надо сделать редирект со старого
      адреса на новый адрес.
    - Вот, как это можно сделать:

        server {
            listen          80 default;
            server_name     www.domain.com;
         
            root            /home/domain.com;
         
            # Этот паттерн матчится с любым URI, начинающимся с /forum
            location ~ ^/forum/(?P.*)$ {
                return 301 $scheme://forum.domain.com/$1;
            }
        }
         
        server {
            listen          80;
            server_name     forum.domain.com;
         
            index           index.php;
            root            /home/domain.com/forum;
        }    


Б8. Применение изменённого конфига к работающему NGINX

  --------------------------------------
  Подоглавление:

    # Введение
    # Применение изменений

  --------------------------------------

  > Введение
    - Работает у нас сервер NGINX.
    - А мы открыли его конфиг, и внесли изменения.
    - Что нужно сделать, чтобы изменения применились?

  > Применение изменений
    - Нужно отправить главнопу процессу NGINX сигнал reload.
    - Для этого надо открыть окно терминала, и ввести:

        nginx -s reload










--------------------------------------------


                 А Р Х И В 


--------------------------------------------





Б2. Настройка NGINX

  --------------------------------------
  Подоглавление:

    # Общая информация о настройке NGINX

      - Где находится главный конфиг
      - Включаемые конфиги
      - Проверка правильности конфига
      - Основы формата конфига NGINX

    # Глобальная секция

      - Общая информация о глобальной секции
      - user                | пользователь и группа, от имени которых работает nginx
      - worker_processes    | кол-во рабочих процессов, создаваемых сразу после запуска
      - error_log           | файл для записи в него сообщений об ошибках
      - pid                 | файл с ID главного процесса (переопределение значения, заданного на этапе компиляции)
      - use                 | метод обработки соединения (переопределение значения, заданного на этапе компиляции)
      - worker_connections  | MAX число соединений, одновременно открытых в 1-м рабочем процессе

    # Секция HTTP-сервера

      - Общая информация о HTTP-секции
      - Пример настройки секции HTTP-сервера

      1]  Клиентские директивы

        - Общая информация о клиентских директивах
        - chunked_transfer_encoding     | позволяет отключить специфицированный в стандарте HTTP/1.1 механизм поблочной передачи данных в ответе клиенту
        - client_body_buffer_size       | задаёт размер буфера для чтения тела запроса клиента
        - client_body_in_file_only      | используется для отладки или последующей обработки тела запроса клиента
        - client_body_in_single_buffer  | заставляет NGINX сохранить всё тело запроса клиента в 1-м буфере
        - client_body_temp_path         | определяет путь к каталогу для сохранения файлов с телами запросов клиентов
        - client_body_timeout           | задаёт время между последовательными операциями чтения тела запроса клиента
        - client_header_buffer_size     | задаёт размер буфера для чтения заголовка запроса клиента
        - client_header_timeout         | время, отведённое на чтение всего заголовка запроса
        - client_max_body_size          | максимальный размер тела запроса клиента
        - keepalive_disable             | запрещает соединения типа keep-alive для некоторых браузеров
        - keepalive_requests            | определяет, сколько запросов можно принять по одному соединению типа keep-alive
        - keepalive_timeout             | определяет, сколько времени соединение типа keep-alive может оставаться открытым
        - large_client_header_buffers   | задаёт максимальное число и размер буферов для чтения большого заголовка запроса клиента
        - msie_padding                  | разрешает или запрещает добавлять комментарии в ответы со статусом больше 400
        - msie_refresh                  | разрешает или запрещает отправлять MSIE-клиентам ответ Refresh вместо перенаправления

      2]  Директивы ввода/вывода

        - aio                       | разрешает использование асинхронного ввода-вывода
        - directio                  | разрешает использовать зависящий от операционной системы флаг
        - directio_alignment        | устанавливает выравнивание для directio
        - open_file_cache           | настраивает кэш, в котором могут храниться дескрипторы открытых файлов
        - open_file_cache_errors    | разрешает или запрещает кэширование ошибок поиска файлов
        - open_file_cache_min_uses  | задаёт MIN число обращений к файлу, необходимое, чтобы дескриптор оставался в кэше open_file_cache
        - open_file_cache_valid     | задаёт время между последовательными проверками актуальности данных, хранящихся в кэше open_file_cache
        - postpone_output           | задаёт MIN размер порции данных, отправляемых клиенту
        - read_ahead                | задаёт ядру размер предчтения при работе с файлами
        - sendfile                  | разрешение использовать системный вызов sendfile
        - sendfile_max_chunk        | при установке в ненулевое значение, ограничивает объём данных, который может передан за один вызов sendfile()

      3]  Директивы хэш-таблиц

        - server_names_hash_bucket_size |
        - server_names_hash_max_size    |
        - types_hash_bucket_size        |
        - types_names_hash_max_size     |
        - variables_hash_bucket_size    |
        - variables_names_hash_max_size | 

      4]  Директивы сокетов

        - lingering_close             |
        - lingering_time              |
        - lingering_timeout           |
        - reset_timedout_connection   |
        - send_lowat                  |
        - send_timeout                |
        - tcp_nodelay                 |
        - tcp_nopush                  | 

    # Секция виртуального сервера


    # Секция местоположения


    # Секция почтового сервера


 
  --------------------------------------

  > Общая информация о настройке NGINX

    # Где находится главный конфиг
      - Основной конфиг лежит по адресу: /etc/nginx/nginx.conf

    # Включаемые конфиги
      - В любое место любого конфига можно подключить ещё конфиг.
      - Это делается с помощью директивы include. Например:

          include /opt/local/etc/nginx/mime.types;

      - Метасимволы в пути позволяют включить сразу нескольк файлов. Например:

          include /opt/local/etc/nginx/vhost/*.conf;

    # Проверка правильности конфига
      - Можно следующим образом.
      - Причём, проверяются и все включенные в него конфиги, рекурсивно.
      - Шаблон для проверки:

          nginx -t -с [ПУТЬ К КОНФИГУ.conf]

    # Основы формата конфига NGINX
      - Конфиг NGINX состоит из секций и директив.
      - Секции устроены следующим образом:

        <секция> {

          <директива> <параметры>;

        }

      - Фигурные скобки вводят новый конфигурационный контекст.
      - Каждая строка с директивой должна заканчиватсья точкой с запятой.


  > Глобальная секция

    //--------------------------------------//
    // Общая информация о глобальной секции //
    //--------------------------------------//    
      - Формат глобальной секции отличается от формата обычной секции.
      - Глобальная секция не заключается в фигурные скобки.
      - Директивы в конфиге, не заключённые в локальную секцию - находятся в глобальной.
      - Глобальная секция может включать как конфиг.директивы, так и секции.
      - Глобальная секция должна находиться в начале конфигурационного файла nginx.conf.


    //------// Контексты:     main
    // user // По умолчанию:  nobody nobody
    //------//
    // - Пользователь и группа, от имени которых работает nginx.
    // - Если группа опущена, то подразумевается группа, которая совпадает с именем пользователя.

      # мы хотим, чтобы nginx работала от имени пользователя 'www'
      user www;


    //------------------// Контексты:     main
    // worker_processes // По умолчанию:  1
    //------------------//
    // - Кол-во рабочих процессов, создаваемых сразу после запуска
    // - Эти процессы обрабатывают запросы на соединения со стороны клиентов.
    // - Сколько процессов задать, зависит от сервера.
    // - И в первую очередь, от дисковой подсистемы и сетевой инфраструктуры.
    // - Если решаются "счётные" задачи, то рекомендуется установить равным кол-ву ядер процессора.
    // - А если задачи, требующие интенсивного ввода-вывода, то: кол-во ядер умножить на 2.

      # рабочая нагрузка счетная и имеется 12 процессорных ядер
      worker_processes 12;

      # рабочая нагрузка требует интенсивного ввода-вывода, и имеется 12 процессорных ядер
      worker_processes 24;


    //-----------// Контексты:     main, http, server, location
    // error_log // По умолчанию:  logs/error.log error
    //-----------//
    // - Файл для записи в него сообщений об ошибках.
    // - Если ни в каком другом контексте такой директивы нет, то в него будут писаться все ошибки.
    // - 2-й параметр директивы фильтрует уровень сообщений, попадающих в журнал:
    //   debug,info,notice,warn error,crit,alert,emerg
    // - Сообщения уровня debug выводятся, только если nginx сконфигурирован с параметром --with-debug

      # явно задаем путь к обязательному журналу ошибок
      error_log /var/log/nginx/error.log;


    //-----// Контексты:     main
    // pid // По умолчанию:  nginx.pid
    //-----//
    // - Файл с ID главного процесса.
    // - Переопределяет значение, заданное на этапе конфигурирования и компиляции.

      # явно задаем путь к pid-файлу
      pid /var/run/nginx.pid.


    //-----// Контексты:     events
    // use // По умолчанию:  -
    //-----//
    // - Метод обработки соединения.
    // - Переопределяет значение, заданное на этапе конфигурирования и компиляции.
    // - И, если используется, должна содержаться в контексте events.
    // - Обычно не нуждается в переопределении.
    // - Разве что в случае, когда значение по умолчанию приводит к ошибкам.

      # создаем конфигурационный контекст для модуля 'events'
      events {

        # Мы работаем в системе Solaris и обнаружили, что при использовании
        # подразумеваемого по умолчанию механизма обработки соединений nginx
        # со временем перестает отвечать на запросы, поэтому переходим на 
        # следующий по качеству механизм
        use /dev/poll;

      }          


    //--------------------// Контексты:     events
    // worker_connections // По умолчанию:  512
    //--------------------//
    // - MAX число соединений, одновременно открытых в 1-м рабочем процессе.
    // - Сюда, в т.ч., входят соединения с клиентами, и проксируемыми серверами.
    // - Особенно важно это для обратных прокси-серверов.
    // - Чтобы достичь указанноо кол-во одновременно открытых соединений,
    //   может понадобиться настройка на уровне операционной системы.

        # произведение этого числа и значения worker_processes
        # показывает, сколько может быть одновременно открыто соединений 
        # для одной пары IP:порт
        worker_connections 2048;


  > Секция HTTP-сервера

    //--------------------------------//
    // Общая информация о HTTP-секции //
    //--------------------------------//
      - HTTP-секция доступна, только если NGINX не был собран с параметром --without-http.
      - Этот параметр отключает HTTP-модуль NGINX'а.
      - В этой секции описываются все аспекты работы с модулем HTTP.
      - Именно с ним вы чаще всего будете иметь дело.
      - Директив, описывающих работу HTTP-соединений много, поэтому они разбиты на категории.


    //--------------------------------------//
    // Пример настройки секции HTTP-сервера //
    //--------------------------------------//
    // - Ниже приведен пример конфигурационной секции модуля HTTP.
    // - Этот контекстный блок должен располагаться после всех глобаль-ных директив в файле nginx.conf

      http {

        include /opt/local/etc/nginx/mime.types;
        default_type application/octet-stream;
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        server_names_hash_max_size 1024;
        
      }    


    //------------------------------------------//
    // Общая информация о клиентских директивах //
    //------------------------------------------//
      - Директивы из этой категории относятся к самому соединению с клиентом.
      - А также, описывают некоторые аспекты поведения для клиентов разных типов.


    //---------------------------// Контексты:     http, server, location
    // chunked_transfer_encoding // По умолчанию:  on
    //---------------------------// Синтаксис:     chunked_transfer_encoding [on | off];
    // - Позволяет запретить формат передачи данных частями (chunked transfer encoding) в HTTP/1.1.
    // - Это может понадобиться при использовании программ, не поддерживающих chunked encoding, несмотря на требования стандарта.

      # Отключить механизм поблочной передачи данных
      chunked_transfer_encoding off;


    //-------------------------// Контексты:     http, server, location
    // client_body_buffer_size // По умолчанию:  8k | 16k (в зависимости от платформы)
    //-------------------------// Синтаксис:     client_body_buffer_size размер;
    // - Задаёт размер буфера для чтения тела запроса клиента.
    // - Если тело запроса больше заданного буфера, то всё тело запроса или только его часть записывается во временный файл.
    // - Увеличение размера позволяет предотвратить запись во временный файл на диске.
    // - По умолчани, для буфера выделяется 2 страницы памяти.
    // - На x86, других 32-битных платформах и x86-64 это 8K. На других 64-битных платформах это обычно 16K.

      # Установить размер буфера для чтения тела запроса клиента, равным 128 килобайт
      client_body_buffer_size 128k;


    //--------------------------// Контексты:     http, server, location
    // client_body_in_file_only // По умолчанию:  off
    //--------------------------// Синтаксис:     client_body_in_file_only [on | clean | off];
    // - Определяет, сохранять ли всё тело запроса клиента в файл.
    // - Директиву можно использовать для отладки и при использовании 
    //   переменной $request_body_file или метода $r->request_body_file модуля ngx_http_perl_module.
    // - Смысл возможных значений:
    //   
    //   off    | тело запроса принудительно не записывается в файл
    //   on     | тело запроса принудительно записывается в файл
    //   clean  | разрешает удалять временные файлы, оставшиеся по окончании обработки запроса
    //  

      # Выключить режим записи тела запроса в файл
      client_body_in_file_only off;

      # Включить режим записи тела запроса в файл
      client_body_in_file_only on;

      # Включить режим записи тела запроса в файл
      # При этом, удалять эти файлы после завершения запроса
      client_body_in_file_only clean;      


    //------------------------------// Контексты:     http, server, location
    // client_body_in_single_buffer // По умолчанию:  off
    //------------------------------// Синтаксис:     client_body_in_single_buffer [on | off];
    // - Определяет, сохранять ли всё тело запроса клиента в 1-м буфере.
    // - Директива рекомендуется при использовании переменной $request_body.
    // - Это позволяет уменьшить количество операций копирования.

      # Включить сохранение тела запроса клиента в 1-м буфере
      client_body_in_single_buffer on;


    //-----------------------// Контексты:     http, server, location
    // client_body_temp_path // По умолчанию:  client_body_temp
    //-----------------------// Синтаксис:     client_body_temp_path путь [уровень1 [уровень2 [уровень3]]];
    // - Задаёт каталог для хранения временных файлов с телами запросов клиентов.
    // - В каталоге может использоваться иерархия подкаталогов до трёх уровней.
    // - Например, при такой конфигурации: 
    //
    //    client_body_temp_path /spool/nginx/client_temp 1 2;
    //
    // - Путь к временному файлу будет следующего вида:
    //
    //    /spool/nginx/client_temp/7/45/00000123457
    //

      # Определить путь к каталогу для сохранения файлов с телами запросов
      client_body_temp_path /etc/nginx/client_body_temp;


    //---------------------// Контексты:     http, server, location
    // client_body_timeout // По умолчанию:  60s
    //---------------------// Синтаксис:     client_body_timeout [время];
    // - Задаёт таймаут при чтении тела запроса клиента.
    // - Таймаут устанавливается не на всю передачу тела запроса, а только между двумя последовательными операциями чтения.
    // - Если по истечении этого времени клиент ничего не передаст, 
    //   то клиенту возвращается ошибка 408 (Request Time-out).

      # Задать время между последовательными операциями чтения тела запроса клиента
      client_body_timeout 120s;


    //---------------------------// Контексты:     http, server
    // client_header_buffer_size // По умолчанию:  1k
    //---------------------------// client_header_buffer_size [размер];
    // - Задаёт размер буфера для чтения заголовка запроса клиента.
    // - Для большинства запросов достаточно буфера размером в 1K.
    // - Однако если в запросе есть длинные cookies, или же запрос пришёл от WAP-клиента, то он может не поместиться в 1K.
    // - Поэтому, если строка запроса или поле заголовка запроса не помещаются полностью в этот буфер, то выделяются буферы 
    //   большего размера, задаваемые директивой large_client_header_buffers

      # Задать размер буфера для чтения заголовка запроса клиента
      client_header_buffer_size 2k;


    //-----------------------// Контексты:     http
    // client_header_timeout // По умолчанию:  60s
    //-----------------------// Синтаксис:     client_header_timeout [время];
    // - Задаёт таймаут при чтении заголовка запроса клиента.
    // - Если по истечении этого времени клиент не передаст полностью 
    //   заголовок, то клиенту возвращается ошибка 408 (Request Time-out).

      # Задать время, отведённое на чтение всего заголовка запроса
      client_header_timeout 120s;


    //----------------------// Контексты:     http, server, location
    // client_max_body_size // По умолчанию:  1m
    //----------------------// Синтаксис:     client_max_body_size [размер];
    // - Задаёт максимально допустимый размер тела запроса клиента, указываемый в поле “Content-Length” заголовка запроса.
    // - Если размер больше заданного, то клиенту возвращается ошибка 413 (Request Entity Too Large).
    // - Браузеры не умеют корректно показывать эту ошибку.
    // - Установка параметра [размер] в 0 отключает проверку размера запроса клиента.

      # Задать максимальный размер тела запроса клиента
      client_header_timeout 2m;

      # Отключить проверку размера запроса клиента
      client_header_timeout 0;


    //-------------------// Контексты:     http, server, location
    // keepalive_disable // По умолчанию:  msie6
    //-------------------// Синтаксис:     keepalive_disable [none | браузер1...];
    // - Запрещает keep-alive соединения с некорректно ведущими себя браузерами.
    // - Параметры браузер указывают, на какие браузеры это распространяется.
    // - Значения:
    // 
    //    none      | разрешает keep-alive соединения со всеми браузерами
    //    msie6     | запрещает keep-alive соединения со старыми версиями MSIE после получения запроса POST 
    //    safari    | запрещает keep-alive соединения с Safari и подобными им браузерами на Mac OS X и подобных ей ОС
    // 

      # Запретить соединение типа keep-alive для браузера Microsoft IE 7
      keepalive_disable msie7;


    //--------------------// Контексты:     http, server, location
    // keepalive_requests // По умолчанию:  100
    //--------------------// Синтаксис:     keepalive_requests [число];
    // - Задаёт максимальное число запросов, которые можно сделать по одному keep-alive соединению.
    // - После того, как сделано максимальное число запросов, соединение закрывается.

      # Задать кол-во запросов, которые можно принять по одному соединению типа keep-alive
      keepalive_requests 200;


    //-------------------// Контексты:     http, server, location
    // keepalive_timeout // По умолчанию:  75s
    //-------------------// Сиеиаксис:     keepalive_timeout [таймаут] [заголовок_таймаута];
    // - Определяет таймаут для keep-alive соединения.
    // - Значения:
    // 
    //    [таймаут]             | таймаут, в течение которого keep-alive соединение с клиентом не будет закрыто со стороны сервера.
    //                            - значение 0 запрещает keep-alive соединения с клиентами
    //    [заголовок_таймаута]  | задаёт значение в поле “Keep-Alive: timeout=время” заголовка ответа
    // 
    // - Два параметра могут отличаться друг от друга.
    // - Поле “Keep-Alive: timeout=время” заголовка понимают Mozilla и Konqueror.
    // - MSIE сам закрывает keep-alive соединение примерно через 60 секунд.
    // 

      # Задать, сколько времени соединение типа keep-alive может оставаться открытым
      keepalive_timeout 75s;


    //-----------------------------// Контексты:     http, server
    // large_client_header_buffers // По умолчанию:  4 8k
    //-----------------------------// Синтаксис:     large_client_header_buffers [число] [размер];
    // - Задаёт максимальные [число] и [размер] буферов для чтения 
    //   большого заголовка запроса клиента.
    // - Строка запроса не должна превышать размера одного буфера,
    //   иначе клиенту возвращается ошибка 414 (Request-URI Too Large).
    // - Поле заголовка запроса также не должно превышать размера одного буфера,
    //   иначе клиенту возвращается ошибка 400 (Bad Request).
    // - Буферы выделяются только по мере необходимости.
    // - По умолчанию размер одного буфера равен 8K.
    // - сли по окончании обработки запроса соединение переходит в состояние 
    //   keep-alive, эти буферы освобождаются.
    // 

      # Задать максимальное число и размер буферов для чтения большого заголовка запроса клиента
      large_client_header_buffers 96k;


    //--------------// Контексты:     http, server, location
    // msie_padding // По умолчанию:  on
    //--------------// Синтаксис:     msie_padding on | off;
    // - Разрешает или запрещает добавлять комментарии в ответы со статусом больше 400.
    // - Для увеличения размера ответа до 512 байт при работе с MSIE.

      # Разрешить добавлять комментарии в ответы со статусом больше 400
      msie_padding on;


    //--------------// Контексты:     http, server, location
    // msie_refresh // По умолчанию:  off
    //--------------// Синтаксис:     msie_refresh on | off;
    // - Разрешает или запрещает выдавать для MSIE клиентов refresh’ы вместо перенаправлений.

      # Разршить отправлять MSIE-клиентам ответ Refresh вместо перенаправления
      msie_refresh on;     


    //-----// Контексты:     http, server, location
    // aio // По умолчанию:  off
    //-----// Синтаксис:     aio on | off | threads[=pool];
    // 
    // # Общая информация 
    //  - Разрешает или запрещает использование файлового асинхронного ввода-вывода (AIO) во FreeBSD и Linux.
    //  - В Linux AIO можно использовать только начиная с версии ядра 2.6.22.
    //  - Кроме того, необходимо также дополнительно включить directio, иначе чтение будет блокирующимся.
    // 
    // # Выравнивание блоков на границу 512 байт (или 4К для XFS) в Linux
    //  - В Linux directio можно использовать только для чтения блоков, выравненных на границу 512 байт (или 4К для XFS).
    //  - Невыравненный конец файла будет читаться блокированно
    //  - То же относится к запросам с указанием диапазона запрашиваемых байт 
    //    (byte-range requests) и к запросам FLV не с начала файла: 
    //    чтение невыравненных начала и конца ответа будет блокирующимся.
    //  
    // # AIO и Sendfile
    //  - При одновременном включении AIO и sendfile в Linux для файлов, размер 
    //    которых больше либо равен указанному в директиве directio, 
    //    будет использоваться AIO, а для файлов меньшего размера или 
    //    при выключенном directio — sendfile.
    // 
    // # Читать и отправлять файлы можно в многопоточном режиме
    //  - Кроме того, читать и отправлять файлы можно в многопоточном режиме (1.7.11), 
    //    не блокируя при этом рабочий процесс
    //  - По умолчанию поддержка многопоточности выключена.
    //  - Её сборку следует разрешить с помощью конфигурационного параметра --with-threads.
    //  - В настоящий момент многопоточность совместима только с методами epoll, kqueue и eventport.
    //  - Отправка файлов в многопоточном режиме поддерживается только на Linux.
    // 
    // # Пул потоков 
    //  - Операции чтения или отправки файлов будут обрабатываться потоками из указанного пула.
    //  - Если пул потоков не задан явно, используется пул с именем “default”.
    //  - Имя пула может быть задано при помощи переменных:
    // 
    //      aio threads=pool$disk;
    // 
    // 

      # Включить AIO
      location /video/ {
        aio            on;
        directio       512;
        output_buffers 1 128k;
      }

      # Одновременное использование AIO и Sendfile
      location /video/ {
        sendfile       on;
        aio            on;
        directio       8m;
      }      

      # Применение AIO в многопоточном режиме
      location /video/ {
        sendfile       on;
        aio            threads;
      }      


    //----------// Контексты:     http, server, location
    // directio // По умолчанию:  off
    //----------// Синтаксис:     directio [размер | off];
    // - Разрешает использовать флаги O_DIRECT (FreeBSD, Linux), 
    //   F_NOCACHE (Mac OS X) или функцию directio() (Solaris) 
    //   при чтении файлов, размер которых больше либо равен указанному.
    // - Директива автоматически запрещает (0.7.15) использование sendfile для данного запроса.
    // - Рекомендуется использовать:
    // 
    //    1) Для больших файлов
    //    2) При использовании AIO в Linux
    // 
    // 

      # Использовать directio для больших файлов
      directio 4m;

      # Включить directio
      directio on;


    //--------------------// Контексты:     http, server, location
    // directio_alignment // По умолчанию:  512
    //--------------------// Синтаксис:     directio_alignment [размер];
    // - Устанавливает выравнивание для directio.
    // - Обычно значения по умолчанию (512 байт) достаточно.
    // - Но при использовании ФС XFS в Linux рекомендуется увеличить до 4k.

      # Установить выравнивание для directio равным 4k
      directio_alignment 4k;


    //-----------------// Контексты:     http, server, location
    // open_file_cache // По умолчанию:  off
    //-----------------// Синтаксис:     open_file_cache off;  ... или ...  open_file_cache [max=N] [inactive=время];
    // - Задаёт кэш, в котором могут храниться:
    // 
    //  1) дескрипторы открытых файлов, информация об их размерах и времени модификации
    //  2) информация о существовании каталогов
    //  3) нформация об ошибках поиска файла — “нет файла”, “нет прав на чтение” и тому подобное
    // 
    // - !!! Кэширование ошибок нужно разрешить отдельно директивой open_file_cache_errors
    // - Значения параметров:
    // 
    //    off           | запрещает кэш
    //    max           | задаёт MAX число элементов в кэше
    //                    - при переполнении кэша, удаляются наименее востребованные элементы (LRU)
    //    inactive      | задаёт время, после которого элемент кэша удаляется, если к нему не было обращений в течение этого времени
    //                    - по умолчанию 60 секунд
    // 
    // 

      # Примеры использования
      open_file_cache          max=1000 inactive=20s;
      open_file_cache_valid    30s;
      open_file_cache_min_uses 2;
      open_file_cache_errors   on;


    //------------------------// Контексты:     http, server, location
    // open_file_cache_errors // По умолчанию:  off
    //------------------------// Синтаксис:     open_file_cache_errors [on | off];
    // - Разрешает или запрещает кэширование ошибок поиска файлов в open_file_cache.

      # Разрешить кэширование ошибок поиска файлов в кэше open_file_cache
      open_file_cache_errors on;


    //--------------------------// Контексты:     http, server, location
    // open_file_cache_min_uses // По умолчанию:  1
    //--------------------------// Синтаксис:     open_file_cache_min_uses [число];
    // - Задаёт минимальное [число] обращений к файлу в течение времени, 
    //   заданного параметром [inactive] директивы open_file_cache, 
    //   необходимых для того, чтобы дескриптор файла оставался открытым в кэше

      # Задать MIN число обращений к файлу, необходимое, чтобы дескриптор оставался в кэше open_file_cache
      open_file_cache_errors 5;


    //-----------------------// Контексты:     http, server, location
    // open_file_cache_valid // По умолчанию:  60s
    //-----------------------// Синтаксис:     open_file_cache_valid [время]; 
    // - Определяет время, через которое следует проверять актуальность информации об элементе в open_file_cache.

      # Задать время между последовательными проверками актуальности данных, хранящихся в кэше open_file_cache
      open_file_cache_valid 120s;


    //-----------------// Контексты:     http, server, location
    // postpone_output // По умолчанию:  1460
    //-----------------// Синтаксис:     postpone_output [размер];
    // - Если это возможно, то отправка данных клиенту будет отложена 
    //   пока nginx не накопит по крайней мере указанное количество 
    //   байт для отправки.
    // - Значение 0 запрещает отложенную отправку данных.

      # Задать MIN размер порции данных, отправляемых клиенту
      postpone_output 1460;


    //------------// Контексты:     http, server, location
    // read_ahead // По умолчанию:  0
    //------------// Синтаксис:     read_ahead [размер];
    // - Задаёт ядру размер предчтения при работе с файлами.
    // - На Linux используется системный вызов posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL), 
    //   поэтому параметр [размер] там игнорируется.

      # Задать ядру размер предчтения при работе с файлами.
      read_ahead 100;


    //----------// Контексты:     http, server, location, if в location
    // sendfile // По умолчанию:  off
    //----------// Синтаксис:     sendfile [on | off];
    // 
    // # Общая информация
    //  - Разрешение использовать системный вызов sendfile().
    // 
    // # Использование AIO для подгрузки данных для sendfile()
    //  - Начиная с nginx 0.8.12 и FreeBSD 5.2.1, можно использовать 
    //    aio для подгрузки данных для sendfile().
    //  - В такой конфигурации функция sendfile() вызывается с флагом 
    //    SF_NODISKIO, в результате чего она не блокируется на диске, 
    //    а сообщает об отсутствии данных в памяти.
    //  - После этого nginx инициирует асинхронную подгрузку данных, читая один байт.
    //  - При этом ядро FreeBSD подгружает в память первые 128K байт файла, однако при 
    //    последующих чтениях файл подгружается частями только по 16K
    //  - Изменить это можно с помощью директивы read_ahead.  
    //    

      # Включить sendfile
      sendfile on;

      # Использование AIO для подгрузки данных для sendfile() в FreeBSD:
      location /video/ {
        sendfile       on;
        tcp_nopush     on;
        aio            on;
      }      


    //--------------------// Контексты:     http, server, location
    // sendfile_max_chunk // По умолчанию:  0
    //--------------------// Синтаксис:     sendfile_max_chunk [размер];
    // - При установке в ненулевое значение, ограничивает объём данных, который может передан за один вызов sendfile().
    // - Без этого ограничения одно быстрое соединение может целиком захватить рабочий процесс.

      # Ограничить объём данных, который может передан за один вызов sendfile().
      sendfile_max_chunk 100k;


    //-------------------------------// Контексты:     
    // server_names_hash_bucket_size // По умолчанию:  
    //-------------------------------//
    // - 


    //----------------------------// Контексты:     
    // server_names_hash_max_size // По умолчанию:  
    //----------------------------//
    // - 


    //------------------------// Контексты:     
    // types_hash_bucket_size // По умолчанию:  
    //------------------------//
    // - 


    //---------------------------// Контексты:     
    // types_names_hash_max_size // По умолчанию:  
    //---------------------------//
    // - 


    //----------------------------// Контексты:     
    // variables_hash_bucket_size // По умолчанию:  
    //----------------------------//
    // - 


    //-------------------------------// Контексты:     
    // variables_names_hash_max_size // По умолчанию:  
    //-------------------------------//
    // - 


    //-----------------// Контексты:     
    // lingering_close // По умолчанию:  
    //-----------------//
    // - 


    //----------------// Контексты:     
    // lingering_time // По умолчанию:  
    //----------------//
    // - 


    //-------------------// Контексты:     
    // lingering_timeout // По умолчанию:  
    //-------------------//
    // - 


    //---------------------------// Контексты:     
    // reset_timedout_connection // По умолчанию:  
    //---------------------------//
    // - 


    //------------// Контексты:     
    // send_lowat // По умолчанию:  
    //------------//
    // - 


    //--------------// Контексты:     
    // send_timeout // По умолчанию:  
    //--------------//
    // - 


    //-------------// Контексты:     
    // tcp_nodelay // По умолчанию:  
    //-------------//
    // - 


    //------------// Контексты:     
    // tcp_nopush // По умолчанию:  
    //------------//
    // - 






  > Секция виртуального сервера




  > Секция местоположения


  > Секция почтового сервера  




















