////==================================================////
////                                                  ////
////                       Bash                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Руководства //
  //-------------//

    # Краткое руководство по Bash programming
        http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html

    # Более полное руководство по Bash programming (en + ru)
        http://tldp.org/LDP/Bash-Beginners-Guide/html/
        http://rus-linux.net/nlib.php?name=/MyLDP/BOOKS/Bash-Guide-1.12-ru/bash-guide-index.html

  // Cheet sheets //
  //--------------//

    # Bourne-Again SHell and Linux CLI by Martin Bruchanov
        http://bruxy.regnet.cz/linux/bash_cheatsheet/bash_cheatsheet.pdf

    # Bash CheatSheet for UNIX Systems
        https://gist.github.com/LeCoupa/122b12050f5fb267e75f

  // Прочее //
  //--------//

    # Здесь много экспертной информации о Bash
        http://wiki.bash-hackers.org/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Bash

    А1. Вводная информация
    А2. Встроенные команды
    А3. Опции исполнения

    А4. Bash scripting: основы скриптинга и отладки
    А5. Bash scripting: среда
    А6. Bash scripting: регулярные выражения
    А7. Bash scripting: потоковый редактор GNU sed
    А8. Bash scripting: условные операции
    А9. Bash scripting: интерактивные скрипты
    А10. Bash scripting: циклы
    А11. Bash scripting: переменные, массивы, операции с ними
    А12. Bash scripting: функции
    А13. Bash scripting: сигналы

  # Б.  Рецепты и наработки

    Б1.



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////

А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # UNIX shell

      - Интерпретирует команды пользователя
      - Команды могут быть приняты в интерактивном режиме, или в файле
      - Шелл-скрипты интерпретируются, а не компилируются
      - Шелл обеспечивает окружение
      - Bash это shell проекта GNU

    # Фичи bash

      - Расширенный набор опций исполнения
      - Startup-конфиги bash
      - Интерактивные скрипты
      - Улучшенные условные операции [[, [, test
      - Арифметика с помощью let
      - Алиасы
      - Одномерные массивы
      - История недавно песещённых каталогов
      - Управление prompt-строкой

    # Какие конфиги считывает при старте

      - Интерактивный, аутентифицированный
      - Интерактивный, не аутентифицированный
      - Не интерактивный
      - SH-режим
      - POSIX-режим
      - Remote-режим
      - Режим UID != EUID

    # Отличия поведения интерактивных от не интерактивных скриптов

      - Читает startup-файлы
      - Job-control вкл по умолчанию
      - Prompt-строки не пусты
      - Команды считываются из командной строки,
      - Не выходит после EOF
      - История команд вкл по умолчанию
      - Alias Expansion включено
      - Сигнал SIGTERM игнорируется
      - Сигнал SIGINT ловится и обрабатывается
      - При выходе отправляет SIGHUP всем задачам
      - Команды выполняются сразу после чтения
      - Bash проверяет почту периодически
      - Выход при встрече unreferenced variables выкл
      - Выход при ошибках в redirection выкл
      - Выход в POSIX-режиме built-ins returning errors выкл
      - Ошибка в exec не приведёт к выходу из шелла
      - Ошиби парсинга не приводят к выходи из шелла
      - Простая проверка орфографии для cd вкл по умолчанию
      - Авто выход после истечения времени в TMOUT вкл

    # Исполнение команд

      - 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Исполнение скомпилированных команд
      - Исполнение встроенных команд
      - Исполнение команд из скрипта

    # Полная картина работы Bash в мелком масштабе

      - Bash-синтаксис
      - Bash-команды
      - Bash-функции
      - Bash-переменные
      - Bash-расширения
      - Bash-переадресация
      - Исполнение команд в Bash
      - Поиск команд в Bash
      - Bash-скрипты

  --------------------------------------

  > Ссылки

    # Вводная глава в руководстве про Bash
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_01.html

  > Введение
    - Эта глава с краткой вводной информацией о Bash.

  > UNIX shell

    • Интерпретирует команды пользователя
    • Команды могут быть приняты в интерактивном режиме, или в файле
    • Шелл-скрипты интерпретируются, а не компилируются

      ▪ Что делает шелл
        - Шелл считывает скрипт строку за строкой.
        - В каждой строке ищет имеющиеся в системе команды.

      ▪ Что происходило бы при компиляции
        - Но не происходит, ведь шелл интерпретирует, а не компилирует.
        - Компилятор преобразовывал бы программу в машинный код.
        - В итоге получая исполняемый файл, который можно использовать в шелл-скрипте.

    • Шелл обеспечивает окружение
      - Помипо передачи скрипта ядру, у шелла есть ещё важная задача.
      - Это организация индивидуальной среды окружения.

    • Bash это shell проекта GNU
      - Это бесплатный шелл от проекта GNU для UNIX-систем.
      - Он объединяет преимущества Korn shell (ksh) и C shell (csh), включая:

        ▪ Режим редактирования в командной строке
        ▪ Неограниченный размер истории команд
        ▪ Управления задачами
        ▪ Функции и алиасы
        ▪ Неограниченные индексированные массивы
        ▪ Целочисленная арифметика по основаниями от 2 до 64

      - Bash является sh-совемстимым шеллом.
      - Он может выполнить 99% sh-скриптов без необходимости их подстроить под Bash.

  > Фичи bash

    # Расширенный набор опций исполнения
      - Список всех опций исполнения доступен здесь:
          https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

    # Startup-конфиги bash
      - Bash перед исполнением скрипта считывает и применяет конфиги.
      - Какие именно зависит от обстоятельств.
      - Подробности в разделе ниже.

    # Интерактивные скрипты

      • Что такое интерактивные скрипты
        - Которые читают/пишут в пользовательский терминал.
        - То есть их ввод и вывод подключены к терминалу.
        - Включить bash в интерактивном режиме можно:

          ▪ Вызвав его без аргументов-не-опций: bash
          ▪ Кроме того случае, когда опцией является строка со скриптом.
          ▪ Или когда шеллу приказано читать из STDIN

      • Как проверить, в интерактивном или нет режиме исполняется скрипт
        - Для этого надо проверить содержимое спец.параметра -
        - Проверяем:

            echo $-

        - В интерактивном режиме он выдаст: himBH
        - В неинтерактивном режиме он будет пуст.

      • Отличия в поведении интерактивных, от не интерактивных скриптов
        - Имеются некоторые отличия, подробности в разделе ниже

    # Улучшенные условные операции [[, [, test
      - Сабж.

    # Арифметика с помощью let
      - Работать с арифметиком можно командой let.
      - Это одно из дополнений, внесённых шеллом bash.

    # Алиасы

      • Работать с алиасами можно командами alias / unalias.
      • Любой алиас срабатывает только на следующей строке кода.
        - Поэтому определить и использовать алиас на 1-й строке нельзя.
      • Алиасы и функции
        - Алиасы применяются при чтении определения функции, а не когда она исполняется
        - Потому что функция считается 1-й командой.
        - Алиасы из функции будут недоступными, пока она не будет выполнена.

    # Одномерные массивы
      - Bash обеспечивает переменные - одномерные массивы.
      - Любую переменную можно использовать в качестве массива.
      - Ключевое слово declare явно определяет массив.
      - Ограничений на размер массива нет.

    # История недавно песещённых каталогов

      • pushd
        - Ключевое слово pushd добавляет каталог в историю.
        - Это происходит каждый раз при смене текущего каталога.

      • popd
        - Ключевое слово popd удаляет каталог из истории.
        - И меняет текущий каталог на извлечённых из истории.

      • dirs
        - Содержимое истории можно просмотреть ключевым словом dirs.

    # Управление prompt-строкой
      - Подробнее про управление сабжем см. в методичке по Ubuntu.
      - А также на сайте GNU: https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html

  > Какие конфиги считывает при старте

    # Интерактивный, аутентифицированный
      - Интерактивный режим, аутентифицированный пользователь / или с опцией --login
      - Интерактивный значит, что ты можешь вводить команды.
      - Аутентифицированный, значит от лица аутентифицированного пользователя.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.bash_profile, ~/.bash_login or ~/.profile: first existing readable file is read
        • ~/.bash_logout upon logout.

    # Интерактивный, не аутентифицированный
      - Интерактивный режим, не аутентифицированный пользователь
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Не интерактивный
      - Не интерактивный режим
      - Все скрипты из файлов выполняются в неинтерактивном режиме.
      - Считывает следующие конфиги:

        • defined by BASH_ENV

    # SH-режим
      - Выполняется командой sh
      - Bash старается вести себя, как sh.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.profile

    # POSIX-режим
      - Как включить режим POSIX:

        • Встроенной командой set: set -o posix
        • Выполнив скрипт с опцией --posix

      - Тогда bash будет стараться max соблюдать стандарты POSIX.
      - Установка переменной среды POSIXLY_CORRECT, это не тоже самое.
      - Считывает следующие конфиги:

        • defined by ENV variable.

    # Remote-режим
      - Исполняемые с удалённой машины
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Режим UID != EUID
      - Вызов в случае, когда UID не совпадает с EUID
      - В этом случае конфиги не читаются.

  > Отличия поведения интерактивных от не интерактивных скриптов

    # Читает startup-файлы
    # Job-control вкл по умолчанию
    # Prompt-строки не пусты
    # Команды считываются из командной строки,
      - Используя опцию readline
    # Не выходит после EOF
      - Применяя опцию шелла ignoreeof.
    # История команд вкл по умолчанию
      - И хранитя в файле по адресу $HISTFILE
      - По умолчанию это ~/.bash_history.
    # Alias Expansion включено
    # Сигнал SIGTERM игнорируется
      - В отсутствии ловушек.
    # Сигнал SIGINT ловится и обрабатывается
      - Поэтому ctrl-c не приводит к немедленному выходу.
      - А шелл запрашивает подтверждения.
    # При выходе отправляет SIGHUP всем задачам
      - Используется опция huponexit
    # Команды выполняются сразу после чтения
    # Bash проверяет почту периодически
    # Выход при встрече unreferenced variables выкл
    # Выход при ошибках в redirection выкл
    # Выход в POSIX-режиме built-ins returning errors выкл
    # Ошибка в exec не приведёт к выходу из шелла
    # Ошиби парсинга не приводят к выходи из шелла
    # Простая проверка орфографии для cd вкл по умолчанию
    # Авто выход после истечения времени в TMOUT вкл

  > Исполнение команд

    # 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Bash может выполнять 3-ри типа команд:

        • Скомпилированные команды
        • Встроенные в шелл команды
        • Команды из скриптов

    # Исполнение скомпилированных команд

      • Fork
        - При исполнении такой программы Bash создаёт точную копию себя.
        - Этот дочерний процесс имеет ту же среду окружения, что и его родитель.
        - Только ID этого процесса другое.
        - Описанный выше процесс называют ветвлением/форкингом (forking).

      • Exec
        - После форка адресное пространство нового процесса перезаписывается.
        - Это происходит с помощью exec-вызова к системе.

      • Механизм Fork-and-Exec
        - Он подменяет одну команду другой, оставляя ту же среду окружения.
        - Этот механизм используется для создания всех процессов в UNIX/Linux.
        - Даже 1-ый процесс init форкается в процессе загрузки системы в
          так называемой bootstrapping-процедуре.

    # Исполнение встроенных команд

      • Встроенные команды
        - Это встроенные в сам шелл команды.
        - Они необходимы для обеспечения определённого функционала.
        - Обеспечить который извне какими-то командами и т.д. нельзя.

      • Не создаётся новый процесс
        - Если простая команда начинается с имени встроенной.

      • 3-ри типа встроенных команд

        ▪ Встроенные команды Bourne Shell

            :, ., break, cd, continue, eval, exec, exit, export,
            getopts, hash, pwd, readonly, return, set, shift,
            test, [, times, trap, umask and unset.

        ▪ Встроенные команды Bash

            alias, bind, builtin, command, declare, echo, enable,
            help, let, local, logout, printf, read, shopt, type,
            typeset, ulimit and unalias.

        ▪ Особые встроенные команды
          - При выполнении в POSIX-режиме есть определённые особенности.
          - Они касаются встроенных команд:

            ▪ Во время поиска команды, команда сначала ищется среди
              специальных встроенных команд, а затем — среди функций
              командной оболочки.

            ▪ Если специальная встроенная команда возвращает состояние
              ошибки, то в неинтерактивном режиме происходит выход из
              командной оболочки.

            ▪ Инструкции присваивания, предшествующие команде, оказывают
              эффект на среду оболочки только после завершения команды.

          - Специальные встроенные команды:

            :, ., break, continue, eval, exec, exit, export,
            readonly, return, set, shift, trap and unset.

    # Исполнение команд из скрипта

      • Построчно считывает, интерпретирует, исполняет
        - Для скриптов bash делает форк и создаёт новый дочерний процесс.
        - Этот саб-шелл считывает строки из скрипта, по одной за раз.
        - Каждая строка считывается, интерпретируется и выполняется.
        - Так, как если бы они вводились в интерактивном режиме с клавиатуры.

      • Родительский процесс ждёт
        - Сабж ждёт завершения выполнения скрипта.
        - Дочерний процесс завершается, когда в скрипте кончаются строки.
        - В интерактивном режиме, род.проц. оживает, и запрашивает новую строку.

  > Полная картина работы Bash в мелком масштабе

    # Bash-синтаксис

      • Разбивает ввод на слова и операторы
        - Шелл считывает ввод и разбивает на слова и операторы.
        - Но если ввод закомментирован, то этого не происходит.

      • Трансляция в команды
        - Затем слова/операторы транслируются в команды/конструкции.
        - Каждая из которых может вернуть в результате некий статус.
        - Который интерпретатор может интерпретировать и обработать.

      • Механизм Fork-and-Exec применяется только после:

        ▪ Bash считывает ввод из файла / строки / терминала

        ▪ Ввод разбивается на слова и операторы
          - Делает он это, следуя правилам использования кавычек.
          - Эти лексемы разделяются метасимволами.
          - Выполняется подстановка алиасов.

        ▪ Анализ и подстановка
          - Bash проводит анализ и подстановку в лексемах.

        ▪ Прочее
          - Bash выполняет различные доп.действия.
          - Разбивает лексемы на списки имён файлов / команд / аргументов.

        ▪ Перенаправление
          - Производится, если это необходимо.
          - Операторы перенаправления и их операнды удаляются из списка аргументов.

        ▪ Выполняет команды

        ▪ Ждёт, собирает статусы
          - Это не обязательно.
          - Bash может подождать, пока команды будут выполнены.
          - И собрать статусы.

    # Bash-команды

      • Простые команды
        - Простая bash-команда состоит из команды и аргументов.
        - Например:

          touch file1 file2 file3

      • Составные команды
        - Состоят из набора простых команд.
        - Которые м.б. объединены друг с другом разными путями:

          ▪ Через pipeline (вывод одной команды во ввод другой)
          ▪ Условными операторами
          ▪ Циклами
          ▪ ... Каким-либо другим образом

        - Например:

          ls | more
          gunzip file.tar.gz | tar xvf -

    # Bash-функции

      • Зачем нужны
        - Это способ сгруппировать команды для использования в будущем.
        - Вызвать все эти команды можно будет по имени функции.
        - Все сгруппированные команды будут выполнены обычным образом.

      • Дочерний процесс не создаётся
        - При вызове функции дочерний процесс не создаётся.
        - Все команды выполняются в текущем процессе шелла.

    # Bash-переменные
      - Переменные в Bash хранят значения и доступны по имени.
      - Переменная может иметь значение и от 0 и более атрибутов.
      - Создать переменную можно встроенной командой declare.
      - Удалить переменную можно встроенной командой unset.

    # Bash-расширения
      - Сабж применяется каждый раз после разбития строки на лексемы.
      - Что это за bash-расширения:

        ▪ Brace expansion                   | раскрытие фигурных скобок
        ▪ Tilde expansion                   | замена символа "тильда"
        ▪ Parameter and variable expansion  | подстановка параметров и переменных
        ▪ Command substitution              | подстановка команд
        ▪ Arithmetic expansion              | раскрытие арифметических выражений
        ▪ Word splitting                    | разбиение на отдельные слова
        ▪ Filename expansion                | подстановка имен файлов

    # Bash-переадресация
      - Перед выполнением команды её input/output может быть перенаправлен.
      - Это можно сделать с помощью спец.нотации, интерпретируемой шеллом.
      - Перенаправление также м.б. использовано для открытия/закрытия файлов.

    # Исполнение команд в Bash

      • Помечает переменные
        - Некоторые слова парсер пометил, как переменные.
        - Все эти пометки сохраняются для дальнейшего использования.

      • Выполнение bash-расширений
        - Расширения применяются для не помеченных в кач-ве переменых частей команд.

      • Выявление команды и аргументов
        - Первое оставшееся после расширений слово, это команда.
        - Остальные слова, это её аргументы.

      • Выполнение переадресаций
        - Сабж.

      • Затем происходит расширение переменных
        - Подставляются их строковые значения.
        - Если имени команды нет, то переменные изменят текущую среду командной оболочки.

    # Поиск команд в Bash
      - Важной задачей Bash является поиск команд.
      - Bash делает это следующим образом:

        • Сначала ищет функцию
          - Проветяет, содержит ли команда слэши.
          - Если нет, сначала ищет среди доступных фунций по имени.

        • Затем ищет встроенную команду

        • Ищет команду в PATH
          - Если это не функция и не встроенная команда.
          - Bash хранит весь PATH в памяти, поиск по нему быстр.

        • Исполняет команду в дочернем процессе
          - Если команда найдена или содержит слэши.
          - Шелл выполняет её в дочернем процессе.

        • Решает, что это шелл-скрипт
          - Если выполнение проваливается.
          - Потому что файл ни является исполняемым, ни каталогом.

        • Шелл ждёт окончания работы команды
          - Если она не была запущена асинхронно.
          - И получает её статус.

    # Bash-скрипты
      - Шеллу 1-ым аргументом можно передать <имя>.
      - Если без параметров -c/-s, будет создан неинтерактивный
        дочерний шелл-процесс.
      - Последний сначала искать файл <имя> в так:

        • Сначала заглянет в текущий каталог.
        • Затем посмотрит в PATH.



А2. Встроенные команды

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным командам Bourne shell и Bash

      • Bourne shell

        - :         | Оператор "двоеточие", см.примеры
        - .         | Алиас для source, выполняет скрипт в текущем процессе
        - break     | Выход из циклов for/while/until/select
        - cd        | Изменить текущий рабочий каталог на directory
        - continue  | Перейти к следующей итерации цикла for/while/until/select
        - eval      | Аналог source, но выполняет не скрипт из файла, а команду из аргументов
        - exec      | Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес
        - exit      | Завершить текущий шелл или скрипт
        - export    | Экспортирует переменную/функцию NAME в среду окружения
        - getopts   | Команда для парсинга аргументов командной строки
        - hash      | Запоминает полные pathname команд с именами [name]
        - pwd       | Вывести абсолютный путь к текущему каталогу
        - readonly  | Пометить каждую name как readonly
        - return    | Остановить шелл-функцию и вернуть [n] тому, кто её вызвал
        - shift     | Сдвинуть все позиционные параметры влево на n пунктов
        - test, [   | Выполнить условное выражение, вернуть true/false
        - times     | Выводит затраченное скриптом и его детьми время
        - trap      | Назначить обработчик события
        - umask     | Назначить umask для создания файлов в шелле.
        - unset     | Удалить переменные/функции name

      • Bash

        - alias     | Назначить алиас name со значением value.
        - bind      | Назначить гоячие клавиши
        - builtin   | Выполнить встроенную команду шелла
        - caller    | Возвращает контекст вызова любой активной подпрограммы
        - command   | Аналог buildin, только не для встроенных команд - запустить команду в обход функции
        - declare   | Декларирует переменные и присваивает им атрибуты
        - echo      | Выводит args, разделённые пробелом, заканчивающиеся newline'ом
        - enable    | Вкл / Выкл встроенные шелл-команды
        - help      | Вывести help для встроенных команд
        - let       | Позволяет проводить арифметические операции
        - local     | Создать локальную переменную name со значением value
        - logout    | Выйти из аккаунта
        - mapfile   |
        - printf    |
        - read      |
        - shopt     |
        - type      |
        - typeset   |
        - ulimit    |
        - unalias   |

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по Bourne Shell build-in commands
        https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#Bourne-Shell-Builtins

    # Оф.справочник GNU по Bash build-in commands
        http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

  > Введение
    - Эта глава является справочником по встроенным командам.
    - Причём, именно встроенным командам Bourne shell и Bash.
    - Оные для POSIX-режима не рассматриваются.

  > Справочник по встроенным командам Bash

    // : //
    //---//
    // - Оператор "двоеточие", см.примеры
    // - Подоглавление примеров:
    //
    //  • Плейсхолдер для "ничего не делать"
    //  • Вставка коммента прямо в строке команды
    //  • Алиас для true
    //  • Вкл/Выкл многословныый режим в командах
    //  • Назначить значение var, если это не команда, и такой переменной ещё нет
    //  • Сделать заготовку функции (типа надо её написать)
    //  • Написать блок с комментами aka /* */
    //  • Выполнить команду, но не показывать её вывод
    //

      # Формат

        : [arguments]

      # Описание
        - Исторически, у Bourne Shell небыло встроенных true/false.
        - Вместо true использовалась : , а вместо false let 0.
        - В наши дни, можно наравне использовать : и true.

      # Примеры

        • Плейсхолдер для "ничего не делать"
            for ((x=0;x<100000;++x)) ; do : ; done
            if command; then :; else ...; fi

        • Вставка коммента прямо в строке команды
            command ; command ; : we need a comment in here for some reason ; command

        • Алиас для true
            while : ; do command ; done

        • Вкл/Выкл многословныый режим в командах
            #!/bin/bash
            if [[ "$VERBOSE" == "" || "$VERBOSE" == "0" ]]; then
                vecho=":"     # no "verbose echo"
            else
                vecho=echo    # enable "verbose echo"
            fi
            $vecho "Verbose echo is ON"

        • Назначить значение var, если это не команда, и такой переменной ещё нет
            : "${var:=$1}"

        • Сделать заготовку функции (типа надо её написать)
            future_function () { :; }

        • Написать блок с комментами aka /* */
            : << 'SKIP'
            your code block here
            SKIP

        • Выполнить команду, но не показывать её вывод
            : `some_command`

    // . //
    //---//
    // - Алиас для source, выполняет скрипт в текущем процессе.

      # Формат

        . filename [arguments]

      # Описание

        • Главное
          - Команда . является алиасом для команды source.
          - Если просто исполнить какой-нибудь скрипт:

            some_script

          - То в процессе Fork-and-Exec будет создан дочерний процесс.
          - Этот процесс будет иметь копию родительского окружения.
          - И скрипт будет выполнен в этом дочернем процессе.
          - Любые изменения окружения этим скриптом не отразятся на род.окружении.
          - Например, скрипт назначает какие-либо алиасы:

              alias ls="ls -a"

          - После завершения скрипта этого алиаса не будет в родит.окружении.
          - Как изменить ситуацию? Не создавать дочерний процесс.
          - А выполнить скрипт в том же процессе шелла, из которого он вызван.
          - Это можно сделать так (эти команды делают одно и тоже):

              . some_script
              source some_script

        • Как шелл ищет скрипт
          - Если filename не содержит слэш, ищет в PATH.
          - Если в PATH не нашёл, ищет в текущем каталоге.

        • Позиционные параметры ($1, $2, ...)
          - [arguments] становятся позиционными параметрами.

        • Return-статус
          - Это статус последней выполненной команды.
          - Или 0, если ни одна команда не была выполнена.
          - Если filename не найден, return-статус не нулевой.

    // break //
    //-------//
    // - Выход из циклов for/while/until/select.

      # Формат

        break [n]

      # Описание
        - Осуществляет выход из циклов for/while/until/select.
        - Параметр n позволяет выйти из n циклов (для вложенных циклов).
        - Параметр n должен быть >= 1. Иначе return status 0.
        - По умолчанию n == 1.

      # Примеры

        while :
          echo 1
          break
          echo 2
        done

    // cd //
    //----//
    // - Изменить текущий рабочий каталог на directory.

      # Формат

        cd [-L|[-P [-e]] [-@] [directory]

      # Опции

        -L    | [по умолчанию] не игнорировать символические ссылки
        -P    | игнорировать символические ссылки
        -e    | (может идти вместе с -P) вернуть unsuccessful status если после смены текущего каталога он не м.б. определён
        -@    | доп.атрибуты, связанные с файлом, как каталогом (для систем, поддерживающих это)

      # Описание

        • Если directory не указана
          - Используется путь из переменной среды HOME.
          - То есть оно переходит в домашний каталог.

        • Любые доп.аргументы после directory игнорируются
          - Сабж.

        • Переменная среды CDPATH
          - Это аналог PATH, только для команды CD.
          - Формат CDPATH такой же: "<path>:<path>:..."

        • Если directory == -, это конвертируется в directory == $OLDPWD
          - То есть cd - значит перейти к предыдущему каталогу.

        • При применении CDPATH и - абс.путь нового каталога выводится в STDOUT
          - Сабж.

        • Return-статус
          - 0, если каталог успешно сменён. Иначе, не 0.

      # Примеры

        • Перейти в домашний каталог
            cd
            cd ~

        • Вернуться в предыдущий каталог
            cd -

        • Использование CDPATH
          - Допустим, у нас есть каталог "/c/WebDev/projects".
          - В нём лежат 3 каталога: "proj1", "proj2", "proj3.
          - Добавим "/c/WebDev/projects" в CDPATH:

              export CDPATH="/c/WebDev/projects"

          - Теперь можно переходить в каталоги с проектами так:

              cd proj1
              cd proj2
              cd proj3

    // continue //
    //----------//
    // - Перейти к следующей итерации цикла for/while/until/select.

      # Формат

        continue [n]

      # Описание
        - Перейти к следующей итерации цикла for/while/until/select.
        - Параметр n (д.б. >= 1) позволяет сделать это для n циклов.
        - По умолчанию n == 1.
        - Если n < 1, return-статус 0.

    // eval //
    //------//
    // - Аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Формат

        eval [arguments]

      # Описание
        - Объединяет аргументы, разделённые пробелами, в команду.
        - Выполняет эту команду в текущем процессе, не создавая дочерний.
        - Работает аналогично eval-функциями из других языков программирования.
        - То есть eval это почти аналог: bash -c "bash code…"
        - Но с разницей, что дочерний процесс не создаётся.
        - Короче, eval это аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Примеры

        • Выполнить указанный код в текущем процессе

          { myCode=$(</dev/stdin); } <<\EOF
          ... arbitrary bash code here ...
          EOF
          eval "$myCode"

        • Определить набор одинаковых функций с именами от f до n

          main() {
              local fun='() { echo "$FUNCNAME"; }' x

              for x in {f..n}; do
                  eval "${x}${fun}"
              done

              "$@"
          }
          main "$@"

    // exec //
    //------//
    // - Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес.

      # Формат

        exec [-cl] [-a name] [command [arguments]] [redirection...]

      # Описание

        • Если command присутствует
          - Заменяет текуший процесс шелла новой программой command.
          - При этом никакого нового процесса не создаётся.

        • Если command отсутствует
          - Переадресации применяются к текущему шеллу, без выполнения command.

        • Return-статус
          - В случае ошибок переадресации, возвращает 1, иначе 0.
          - В случае ошибок exec:

            ▪ Неинтерактивный шелл отваливается, если execfail шелла не включена.
            ▪ В интерактивном шелле, exec возвращает ошибку.

      # Опции

        -a name   | передаёт name как 0-й аргумент программе
        -l        | добавляет префикс "-" 0-вому аргументу программы, также, как программа login
        -c        | выполняет программу с очищенной средой

      # Примеры

        • Обёртка вокруг программы

            myprog=/bin/ls
            echo "This is the wrapper script, it will exec $myprog"

            # do some vodoo here, probably change the arguments etc.
            # well, stuff a wrapper is there for

            exec "$myprog" "$@"

        • Открыть файл, как ввод для скрипта

            # open it
            exec 3< input.txt

            # for example: read one line from the file(-descriptor)
            read -u 3 LINE
            # or
            read LINE <&3

            # finally, close it
            exec 3<&-

        • Переадресовать stdout и stderr скрипта в файл

            exec >/var/adm/my.log 2>&1

            # script continues here...

    // exit //
    //------//
    // - Завершить текущий шелл или скрипт.

      # Формат

        exit [N]

      # Описание
        - N обозначает возвращаемый при выходе код родительскомупроцессу.
        - Если N не указана, возвращает код последней выполненной команды.
        - Ловушка при выходе выполняется перед выходом из шелла.
        - За исключением случая, когда команда exit не часть исполняющейся ловушки.

      # Примеры

        • Завершить работу текущего шелла

            exit

        • Завершить работу скрипта с кодом 0

            #/bin/bash
            # ... некий код ...
            exit 0

    // export //
    //--------//
    // - Экспортирует переменную/функцию NAME в среду окружения.

      # Формат

        export [-fn] [NAME[=VALUE] ...]
        export -p

      # Описание

        • Главное
          - Экспортирует переменную/функцию NAME в среду окружения.
          - Соответственно, всё это будет доступно и дочерним процессам.

        • Функция или переменная
          - Если опция -f указана, то функция.
          - Если не указана, то переменная.

        • Если указано VALUE
          - То при экспорте переменной назначается значение VALUE.

        • Return-статус

            0	      no error
            !=0	    invalid option
            !=0	    a given NAME is invalid

      # Опции

        -f    | экспортировать функцию, а не переменную
        -n    | отменить экспорт NAME
        -p    | показать список всех экспортированных переменных

      # Примеры

        • Вывести список всех экспортированных в среду переменных

          export
          export -p

        • Экспортировать переменную с указанным значением

          export CDPATH="/c/WebDev/projects"

    // getopts //
    //---------//
    // - Команда для парсинга аргументов командной строки.

      # Формат

        getopts optstring name [args]


      # Описание

        • Похожая команда getopt
          - Есть сабж без "s" на конце.
          - В отличие от от getopts, getopt не встроенная команда.

        • Преимущества getopts

          ▪ Нет нужды пропускать позиционные параметры через внешнюю программу.
          ▪ Getopts может установить переменные среды, полезные при парсинге.
          ▪ Нет нужды иметь дело с разными реализациями getopt и их багами.
          ▪ Getopts определена в POSIX.

        ▪ Недостаток getopts
          - Не может парсить GNU-style long options вроде --myoption.
          - А также XF86-style long options вроде -myoption.

      # Примеры
        - См. http://wiki.bash-hackers.org/howto/getopts_tutorial

    // hash //
    //------//
    // - Запоминает полные pathname команд с именами [name].

      # Формат

        hash [-r] [-p filename] [-dt] [name]

      # Опции

        -p  | не исктать в PATH, использовать name как путь к команде
        -r  | забыть все запомненные локации
        -d  | забыть все запомненные локации для каждой name
        -t  | выводить pathname для каждого name

      # Описание
        - В результате эти pathname не надо искать припоследующих вызовах.
        - Команды ищутся в PATH.
        - Любые ранее запомненные pathname отбрасываются.

      # Примеры

        • Показать, какие команды и сколько раз были использованы

            hash

    // pwd //
    //-----//
    // - Вывести абсолютный путь к текущему каталогу.

      # Формат

          pwd [-LP]

      # Опции

        -L    | выведенный путь может содержать символические ссылки
        -P    | выведенный путь не будет содержать символических ссылок

      # Примеры

        • Вывести абсолютный путь к текущему каталогу

            pwd

    // readonly //
    //----------//
    // - Пометить каждую name как readonly.

      # Формат

        readonly [-aAf] [-p] [name[=value]] …

      # Описание
        - Значения этих name не м.б. изменены низлежащим кодом.
        - По умолчанию, каждая name является переменной.

      # Опции

        -f    | каждое имя является шелл-функцией
        -a    | каждое имя является переменной с индексированным.массивом
        -A    | каждое имя является переменной с ассоц.массивом
        -Aa   | в этом случае A имеет приоритет
        -p    | если name отсутствуют, или -p указана, просто выводится список всех readonly

      # Примеры

        • Вывести список всех readonly

            readonly
            readonly -p

        • Сделать указанную переменную readonly

            readonly var="123"

    // return //
    //--------//
    // - Остановить шелл-функцию и вернуть [n] тому, кто её вызвал.

      # Формат

        return [n]

      # Описание
        - Если [n] не передано, возвращает статус последней команды.
        - Также return может остановить скрипт, вызванный через source.

    // shift //
    //-------//
    // - Сдвинуть все позиционные параметры влево на n пунктов.

      # Формат

          shift [n]

      # Описание
        - Было:     n+1 … $#
        - Стало:    $1 … $#-n
        - Удалены:  $# to $#-n+1
        - 0 <= n <= $#

    // test, [ //
    //---------//
    // - Выполнить условное выражение, вернуть true/false.

      # Формат

          test expr

      # Описание

        • Отдельные аргументы
          - Каждый оператор и операнд д.б. отдельными аргументами.

        • Нет опций
          - Не принимает никаких опций.
          - Не принимает аргумент --, означающий конец опций.

        • При использовании [
          - Последним аргументом должен быть ]

      # Операторы для комбинирования выражений

        • ! expr            | не
        • ( expr )          | приоритет
        • expr1 -a expr2    | и
        • expr1 -o expr2    | или

      # Примеры
        - Подробнее см.в главе: "А8. Bash scripting: условные операции"

    // times //
    //-------//
    // - Выводит затраченное скриптом и его детьми время.

      # Формат

          times


    // trap //
    //------//
    // - Назначить обработчик события.

      # Формат

          trap [-lp] [arg] [sigspec …]

      # Описание
        - Код arg выполняется при возбуждении событий sigspec.

      # Форматы sigspec

        • Имя сигнала с префиксом SIG. Например: SIGTERM.
        • Имя сигнала без префикса SIG. Например: TERM.
        • Номер сигнала, см.справку: trap -l

      # Комментарии по arg

        • Если отсутствует или "-", назначается обработчик по умолчанию.
        • Если пустая строка, то никакой обработки не происходит.

      # Опции

        -l    | Вывести все доступные события и их номера
        -p    | При вызове trap без аргументов, или с -p, выводит список назначенных обработчиков

      # Примеры
        - Подробнее см.здесь: http://wiki.bash-hackers.org/commands/builtin/trap

        • Вывести список назначенных обработчиков

            trap

        • Вывести все доступные события и их номера

            trap -l

        • Игнорировать событие SIGINT (терминал не будет закрываться с помощью ctrl-c)

            trap '' INT

    // umask //
    //-------//
    // - Назначить umask для создания файлов в шелле.

      # Формат

          umask [-p] [-S] [mode]

      # Описание

        • Если mode начинается с цифры
          - То он воспринимается, как 8-ричное значение.
          - По аналогии с chmod, например: 644, 777.

        • Если mode не начинается с цифры
          - Он воспринимается как маска в символьном виде.
          - По аналогии с chmod, например: rwxrwxrwx

      # Опции

        -S    | Тоже, что -p, но в символьном формате
        -p    | При вызове umask без аргументов, или с -p, выводит текущий umask шелла.

      # Примеры

        • Вывести текущий umask шелла в восьмеричном формате

            umask       | 0002
            umask -p    | umask 0002

        • Вывести текущий umask шелла в символьном формате

            umask -S    | u=rwx,g=rwx,o=rx

    // unset //
    //-------//
    // - Удалить переменные/функции name.

      # Формат

          unset [-fnv] [name]

      # Опции

        -v    | name это имена переменных среды
        -f    | name это имена функций (а по умолчанию, переменных)
        -n    | если name это пер-ая с атр-ом nameref, будет удалена name, а не то, куда она ссылается

      # Описание
        - Если опции -v, -f не применены, name это переменные.
        - А если пер-ые name не найдены, тогда ищутся функции name.
        - Переменные и функции readonly нельзя удалить.

    // alias //
    //-------//
    // - Назначить алиас name со значением value.

      # Формат

          alias [-p] [name[=value] …]

      # Опции

        -p    | без аргументов, или с -p, вывести все назначенные алиасы

      # Примеры

        • Вывести все назначенные алиасы

            alias
            alias -p

        • Назначить алиас

            alias ls="ls -a"

        • Удалить алиас

            unalias ls

    // bind //
    //------//
    // - Назначить гоячие клавиши.

      # Формат

          bind [-m keymap] [-lpsvPSVX]
          bind [-m keymap] [-q function] [-u function] [-r keyseq]
          bind [-m keymap] -f filename
          bind [-m keymap] -x keyseq:shell-command
          bind [-m keymap] keyseq:function-name
          bind readline-command

      # Опции

        -m keymap               | назначить горячие клавиши
        -l                      | вывести имена всех Readline-функций
        -p                      | вывести список существующих связок горячих клавиш с Readline-функциями
        -P                      | вывести список всех Readline-функций, и есть ли для них горячие клавиши, и какие
        -v                      | вывести имена Readline-переменных и значений в таком формате, чтобы м.б. использовать в Readline init файле
        -V                      | вывести имена Readline-переменных и значений
        -s                      | Display Readline key sequences bound to macros and the strings they output in such a way that they can be used as input or in a Readline initialization file.
        -S                      | Display Readline key sequences bound to macros and the strings they output.
        -f filename             | Read key bindings from filename.
        -q function             | Query about which keys invoke the named function.
        -u function             | Unbind all keys bound to the named function.
        -r keyseq               | Remove any current binding for keyseq.
        -x keyseq:shell-command | Cause shell-command to be executed whenever keyseq is entered.
        -X                      | List all key sequences bound to shell commands and the associated commands in a format that can be reused as input.

      # Описание
        - Позволяет назначить горячие клавиши.
        - Подробнее см.: http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

      # Примеры

        • Назначить на F6 команда "exit\n" (выход из терминала)
          - Здесь [17~ это код клавиши.
          - Посмотреть код любой клавиши в терминале можно так: alt-<клавиша>
          - Назначить:

            bind '"\e[17~":"exit\n"'

    // builtin //
    //---------//
    // - Выполнить встроенную команду шелла.

      # Формат

          builtin [shell-builtin [args]]

      # Описание
        - Ты определи функцию с именем, как у встроенной команды.
        - Как теперь вызвать последнюю? С помощью buildin.

    // caller //
    //--------//
    // - Возвращает контекст вызова любой активной подпрограммы.
    // - Например, шелл-функции или запущенного через source скрипта.

      # Формат

          caller [expr]

      # Описание

        • Без expr
          - Выводит номер строки и имя source файла текущей подпрограммы.

        • Expr - это положительный int
           - Выводит номер строки.
           - Выводит имя подпрограммы.
           - Выводит имя source файла текущей подпрограммы.
           - Соответствующие указанной позиции в текущем call stack.

    // command //
    //---------//
    // - Аналог buildin, только не для встроенных команд - запустить команду в обход функции.

      # Формат

          command [-pVv] command [arguments …]

      # Описание
        - Ты определи функцию с именем, как у команды.
        - Как теперь вызвать последнюю? С помощью command.
        - Ищет как обычные, так и встроенные команды.

      # Опции

        -p    | использовать значение PATH по умолчанию (а не реальное текущее)
        -v    | вывести инфу о найденной команде
        -V    | вывести более подробную инфу о найденной команде

      # Зачем нужна -p
        - В текущей среде PATH могла быть модифицирована.
        - Что может привести к тому, что command не найдёт стандартные утилиты.
        - Опция -p использует не тронутую PATH по умолчанию.


    // declare //
    //---------//
    // - Декларирует переменные и присваивает им атрибуты.

      # Формат

          declare [-aAfFgilnrtux] [-p] [name[=value] …]

      # Опции

        -p

          • Если name заданы
            - Выведет атрибуты и значения для каждого name.
            - Все опции кроме -f,-F игнорируются.

          • Если name не заданы
            - Выведет все атрибуты и значения.
            - Имеющие атрибуты, заданные доп.опциями.

        -F    | не отображать определения функций, только имена и атрибуты
        -g    | при декларировании в скрипте (в иных случаях игнорируется), создавать переменные в глобальном пр.имён

        -a    | Each name is an indexed array variable (see Arrays).
        -A    | Each name is an associative array variable (see Arrays).
        -f    | Use function names only.
        -i    | The variable is to be treated as an integer; arithmetic evaluation (see Shell Arithmetic) is performed when the variable is assigned a value.
        -l    | When the variable is assigned a value, all upper-case characters are converted to lower-case. The upper-case attribute is disabled.
        -n    | Give each name the nameref attribute, making it a name reference to another variable. That other variable is defined by the value of name.
                All references and assignments to name, except for changing the -n attribute itself, are performed on the variable referenced by name’s value. The -n attribute cannot be applied to array variables.
        -r    | Make names readonly. These names cannot then be assigned values by subsequent assignment statements or unset.
        -t    | Give each name the trace attribute. Traced functions inherit the DEBUG and RETURN traps from the calling shell. The trace attribute has no special meaning for variables.
        -u    | When the variable is assigned a value, all lower-case characters are converted to upper-case. The lower-case attribute is disabled.
        -x    | Mark each name for export to subsequent commands via the environment.

      # Описание

        • Использование + вместо - выключает атрибут
          - Кроме случая с +a, не позволяющего разрушить массив.
          - И кроме +r, не позволяющего удалить readonly-атрибут.

        • В функции declare делает каждое name локальным
          - Как и команда local.
          - Но только если не использовать опцию -g.

        • Если передано value, то name присваивается это value.

    // echo //
    //------//
    // - Выводит args, разделённые пробелом, заканчивающиеся newline'ом.

      # Формат

          echo [-neE] [arg …]

      # Опции

        -n    | trailing newline is suppressed
        -e    | включить интерпретацию символов после \
        -E    | отключить интерпретацию символов после \

      # Какие \ конструкции может интерпретировать echo

        \a          | alert (bell)
        \b          | backspace
        \c          | подавить последующие вывод
        \e, \E      | escape
        \f          | form feed
        \n          | new line
        \r          | carriage return
        \t          | horizontal tab
        \v          | vertical tab
        \\          | backslash
        \0nnn       | the eight-bit character whose value is the octal value nnn (zero to three octal digits)
        \xHH        | the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
        \uHHHH      | the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
        \UHHHHHHHH  | the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)


    // enable //
    //--------//
    // - Вкл / Выкл встроенные шелл-команды.

      # Формат

          enable [-a] [-dnps] [-f filename] [name …]

    // help //
    //------//
    // - Вывести help для встроенных команд.

      # Формат

          help [-dms] [pattern]

      # Опции

        -d    | отобразить короткое описание каждого pattern
        -m    | отобразить описание для каждого pattern в man-стиле
        -s    | отобразить только короткий usage synopsis для каждого pattern

      # Описание

        • Если pattern указан
          - Выводит хелп по указанной встроенной команде.

      # Примеры

    // let //
    //-----//
    // - Позволяет проводить арифметические операции.

      # Формат

          let expression [expression …]

      # Описание
        - Подробнее см.здесь: http://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic

      # Обратите внимание на пробел
        - Пробел разделяет выражения, как видно по формату.
        - Внутри одного выражения пробелы не допускаются.

      # Пример

        let x=2+2 y=2+3
        echo $x $y        // 4 5

    // local //
    //-------//
    // - Создать локальную переменную name со значением value.

      # Формат

          local [option] name[=value] …

      # Опции
        - Такие же, как у declare.

      # Описание
        - local можно использовать только внутри функции.
        - Создаваемая переменная будет видна только в функции, и её детях.

    // logout //
    //--------//
    // - Выйти из аккаунта.

      # Формат

          logout [n]

      # Описание
        - Возвращает статус n родителю шелла.

    // mapfile //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры

    // printf //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // read //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // shopt //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // type //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // typeset //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры



    // ulimit //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // unalias //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры




А3. Опции исполнения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным командам Bash

      -c                    |
      -i                    |
      -l                    |
      -r                    |
      -s                    |
      -D                    |
      -O                    |
      +O                    |
      --                    |

      --debugger            |
      --dump-po-strings     |
      --dump-strings        |
      --help                |
      --init-file filename  |
      --rcfile filename     |
      --login               |
      --noediting           |
      --noprofile           |
      --norc                |
      --posix               |
      --restricted          |
      --verbose             |
      --version             |

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по встроенным командам
        https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

  > Введение
    - Эта глава является справочником по опциям исполнения Bash.

  > Справочник по встроенным командам Bash

    // -c //
    //----//
    // -


    // -i //
    //----//
    // -


    // -l //
    //----//
    // -


    // -r //
    //----//
    // -


    // -s //
    //----//
    // -


    // -D //
    //----//
    // -


    // -O //
    //----//
    // -


    // +O //
    //----//
    // -


    // -- //
    //----//
    // -


    // --debugger  //
    //-------------//
    // -


    // --dump-po-strings //
    //-------------------//
    // -


    // --dump-strings //
    //----------------//
    // -


    // --help //
    //--------//
    // -


    // --init-file filename //
    //----------------------//
    // -


    // --rcfile filename //
    //-------------------//
    // -


    // --login //
    //---------//
    // -


    // --noediting //
    //-------------//
    // -


    // --noprofile //
    //-------------//
    // -


    // --norc //
    //--------//
    // -


    // --posix //
    //---------//
    // -


    // --restricted //
    //--------------//
    // -


    // --verbose //
    //-----------//
    // -


    // --version //
    //-----------//
    // -









