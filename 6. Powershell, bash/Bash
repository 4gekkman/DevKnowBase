////==================================================////
////                                                  ////
////                       Bash                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Руководства //
  //-------------//

    # Краткое руководство по Bash programming
        http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html

    # Более полное руководство по Bash programming (en + ru)
        http://tldp.org/LDP/Bash-Beginners-Guide/html/
        http://rus-linux.net/nlib.php?name=/MyLDP/BOOKS/Bash-Guide-1.12-ru/bash-guide-index.html

  // Cheet sheets //
  //--------------//

    # Bourne-Again SHell and Linux CLI by Martin Bruchanov
        http://bruxy.regnet.cz/linux/bash_cheatsheet/bash_cheatsheet.pdf

    # Bash CheatSheet for UNIX Systems
        https://gist.github.com/LeCoupa/122b12050f5fb267e75f

  // Прочее //
  //--------//

    # Здесь много экспертной информации о Bash
        http://wiki.bash-hackers.org/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Bash

    А1. Вводная информация
    А2. Встроенные команды
    А3. Опции исполнения

    А4. Bash scripting: основы скриптинга и отладки
    А5. Bash scripting: среда [написать по запросу]
    А6. Bash scripting: регулярные выражения
    А7. Bash scripting: потоковый редактор GNU sed
    А8. Bash scripting: условные операции
    А9. Bash scripting: интерактивные скрипты
    А10. Bash scripting: циклы
    А11. Bash scripting: переменные, массивы, операции с ними
    А12. Bash scripting: функции
    А13. Bash scripting: сигналы

  # Б.  Рецепты и наработки

    Б1.



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////

А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # UNIX shell

      - Интерпретирует команды пользователя
      - Команды могут быть приняты в интерактивном режиме, или в файле
      - Шелл-скрипты интерпретируются, а не компилируются
      - Шелл обеспечивает окружение
      - Bash это shell проекта GNU

    # Фичи bash

      - Расширенный набор опций исполнения
      - Startup-конфиги bash
      - Интерактивные скрипты
      - Улучшенные условные операции [[, [, test
      - Арифметика с помощью let
      - Алиасы
      - Одномерные массивы
      - История недавно песещённых каталогов
      - Управление prompt-строкой

    # Какие конфиги считывает при старте

      - Интерактивный, аутентифицированный
      - Интерактивный, не аутентифицированный
      - Не интерактивный
      - SH-режим
      - POSIX-режим
      - Remote-режим
      - Режим UID != EUID

    # Отличия поведения интерактивных от не интерактивных скриптов

      - Читает startup-файлы
      - Job-control вкл по умолчанию
      - Prompt-строки не пусты
      - Команды считываются из командной строки,
      - Не выходит после EOF
      - История команд вкл по умолчанию
      - Alias Expansion включено
      - Сигнал SIGTERM игнорируется
      - Сигнал SIGINT ловится и обрабатывается
      - При выходе отправляет SIGHUP всем задачам
      - Команды выполняются сразу после чтения
      - Bash проверяет почту периодически
      - Выход при встрече unreferenced variables выкл
      - Выход при ошибках в redirection выкл
      - Выход в POSIX-режиме built-ins returning errors выкл
      - Ошибка в exec не приведёт к выходу из шелла
      - Ошиби парсинга не приводят к выходи из шелла
      - Простая проверка орфографии для cd вкл по умолчанию
      - Авто выход после истечения времени в TMOUT вкл

    # Исполнение команд

      - 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Исполнение скомпилированных команд
      - Исполнение встроенных команд
      - Исполнение команд из скрипта

    # Полная картина работы Bash в мелком масштабе

      - Bash-синтаксис
      - Bash-команды
      - Bash-функции
      - Bash-переменные
      - Bash-расширения
      - Bash-переадресация
      - Исполнение команд в Bash
      - Поиск команд в Bash
      - Bash-скрипты

  --------------------------------------

  > Ссылки

    # Вводная глава в руководстве про Bash
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_01.html

  > Введение
    - Эта глава с краткой вводной информацией о Bash.

  > UNIX shell

    • Интерпретирует команды пользователя
    • Команды могут быть приняты в интерактивном режиме, или в файле
    • Шелл-скрипты интерпретируются, а не компилируются

      ▪ Что делает шелл
        - Шелл считывает скрипт строку за строкой.
        - В каждой строке ищет имеющиеся в системе команды.

      ▪ Что происходило бы при компиляции
        - Но не происходит, ведь шелл интерпретирует, а не компилирует.
        - Компилятор преобразовывал бы программу в машинный код.
        - В итоге получая исполняемый файл, который можно использовать в шелл-скрипте.

    • Шелл обеспечивает окружение
      - Помипо передачи скрипта ядру, у шелла есть ещё важная задача.
      - Это организация индивидуальной среды окружения.

    • Bash это shell проекта GNU
      - Это бесплатный шелл от проекта GNU для UNIX-систем.
      - Он объединяет преимущества Korn shell (ksh) и C shell (csh), включая:

        ▪ Режим редактирования в командной строке
        ▪ Неограниченный размер истории команд
        ▪ Управления задачами
        ▪ Функции и алиасы
        ▪ Неограниченные индексированные массивы
        ▪ Целочисленная арифметика по основаниями от 2 до 64

      - Bash является sh-совемстимым шеллом.
      - Он может выполнить 99% sh-скриптов без необходимости их подстроить под Bash.

  > Фичи bash

    # Расширенный набор опций исполнения
      - Список всех опций исполнения доступен здесь:
          https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

    # Startup-конфиги bash
      - Bash перед исполнением скрипта считывает и применяет конфиги.
      - Какие именно зависит от обстоятельств.
      - Подробности в разделе ниже.

    # Интерактивные скрипты

      • Что такое интерактивные скрипты
        - Которые читают/пишут в пользовательский терминал.
        - То есть их ввод и вывод подключены к терминалу.
        - Включить bash в интерактивном режиме можно:

          ▪ Вызвав его без аргументов-не-опций: bash
          ▪ Кроме того случае, когда опцией является строка со скриптом.
          ▪ Или когда шеллу приказано читать из STDIN

      • Как проверить, в интерактивном или нет режиме исполняется скрипт
        - Для этого надо проверить содержимое спец.параметра -
        - Проверяем:

            echo $-

        - В интерактивном режиме он выдаст: himBH
        - В неинтерактивном режиме он будет пуст.

      • Отличия в поведении интерактивных, от не интерактивных скриптов
        - Имеются некоторые отличия, подробности в разделе ниже

    # Улучшенные условные операции [[, [, test
      - Сабж.

    # Арифметика с помощью let
      - Работать с арифметиком можно командой let.
      - Это одно из дополнений, внесённых шеллом bash.

    # Алиасы

      • Работать с алиасами можно командами alias / unalias.
      • Любой алиас срабатывает только на следующей строке кода.
        - Поэтому определить и использовать алиас на 1-й строке нельзя.
      • Алиасы и функции
        - Алиасы применяются при чтении определения функции, а не когда она исполняется
        - Потому что функция считается 1-й командой.
        - Алиасы из функции будут недоступными, пока она не будет выполнена.

    # Одномерные массивы
      - Bash обеспечивает переменные - одномерные массивы.
      - Любую переменную можно использовать в качестве массива.
      - Ключевое слово declare явно определяет массив.
      - Ограничений на размер массива нет.

    # История недавно песещённых каталогов

      • pushd
        - Ключевое слово pushd добавляет каталог в историю.
        - Это происходит каждый раз при смене текущего каталога.

      • popd
        - Ключевое слово popd удаляет каталог из истории.
        - И меняет текущий каталог на извлечённых из истории.

      • dirs
        - Содержимое истории можно просмотреть ключевым словом dirs.

    # Управление prompt-строкой
      - Подробнее про управление сабжем см. в методичке по Ubuntu.
      - А также на сайте GNU: https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html

  > Какие конфиги считывает при старте

    # Интерактивный, аутентифицированный
      - Интерактивный режим, аутентифицированный пользователь / или с опцией --login
      - Интерактивный значит, что ты можешь вводить команды.
      - Аутентифицированный, значит от лица аутентифицированного пользователя.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.bash_profile, ~/.bash_login or ~/.profile: first existing readable file is read
        • ~/.bash_logout upon logout.

    # Интерактивный, не аутентифицированный
      - Интерактивный режим, не аутентифицированный пользователь
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Не интерактивный
      - Не интерактивный режим
      - Все скрипты из файлов выполняются в неинтерактивном режиме.
      - Считывает следующие конфиги:

        • defined by BASH_ENV

    # SH-режим
      - Выполняется командой sh
      - Bash старается вести себя, как sh.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.profile

    # POSIX-режим
      - Как включить режим POSIX:

        • Встроенной командой set: set -o posix
        • Выполнив скрипт с опцией --posix

      - Тогда bash будет стараться max соблюдать стандарты POSIX.
      - Установка переменной среды POSIXLY_CORRECT, это не тоже самое.
      - Считывает следующие конфиги:

        • defined by ENV variable.

    # Remote-режим
      - Исполняемые с удалённой машины
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Режим UID != EUID
      - Вызов в случае, когда UID не совпадает с EUID
      - В этом случае конфиги не читаются.

  > Отличия поведения интерактивных от не интерактивных скриптов

    # Читает startup-файлы
    # Job-control вкл по умолчанию
    # Prompt-строки не пусты
    # Команды считываются из командной строки,
      - Используя опцию readline
    # Не выходит после EOF
      - Применяя опцию шелла ignoreeof.
    # История команд вкл по умолчанию
      - И хранитя в файле по адресу $HISTFILE
      - По умолчанию это ~/.bash_history.
    # Alias Expansion включено
    # Сигнал SIGTERM игнорируется
      - В отсутствии ловушек.
    # Сигнал SIGINT ловится и обрабатывается
      - Поэтому ctrl-c не приводит к немедленному выходу.
      - А шелл запрашивает подтверждения.
    # При выходе отправляет SIGHUP всем задачам
      - Используется опция huponexit
    # Команды выполняются сразу после чтения
    # Bash проверяет почту периодически
    # Выход при встрече unreferenced variables выкл
    # Выход при ошибках в redirection выкл
    # Выход в POSIX-режиме built-ins returning errors выкл
    # Ошибка в exec не приведёт к выходу из шелла
    # Ошиби парсинга не приводят к выходи из шелла
    # Простая проверка орфографии для cd вкл по умолчанию
    # Авто выход после истечения времени в TMOUT вкл

  > Исполнение команд

    # 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Bash может выполнять 3-ри типа команд:

        • Скомпилированные команды
        • Встроенные в шелл команды
        • Команды из скриптов

    # Исполнение скомпилированных команд

      • Fork
        - При исполнении такой программы Bash создаёт точную копию себя.
        - Этот дочерний процесс имеет ту же среду окружения, что и его родитель.
        - Только ID этого процесса другое.
        - Описанный выше процесс называют ветвлением/форкингом (forking).

      • Exec
        - После форка адресное пространство нового процесса перезаписывается.
        - Это происходит с помощью exec-вызова к системе.

      • Механизм Fork-and-Exec
        - Он подменяет одну команду другой, оставляя ту же среду окружения.
        - Этот механизм используется для создания всех процессов в UNIX/Linux.
        - Даже 1-ый процесс init форкается в процессе загрузки системы в
          так называемой bootstrapping-процедуре.

    # Исполнение встроенных команд

      • Встроенные команды
        - Это встроенные в сам шелл команды.
        - Они необходимы для обеспечения определённого функционала.
        - Обеспечить который извне какими-то командами и т.д. нельзя.

      • Не создаётся новый процесс
        - Если простая команда начинается с имени встроенной.

      • 3-ри типа встроенных команд

        ▪ Встроенные команды Bourne Shell

            :, ., break, cd, continue, eval, exec, exit, export,
            getopts, hash, pwd, readonly, return, set, shift,
            test, [, times, trap, umask and unset.

        ▪ Встроенные команды Bash

            alias, bind, builtin, command, declare, echo, enable,
            help, let, local, logout, printf, read, shopt, type,
            typeset, ulimit and unalias.

        ▪ Особые встроенные команды
          - При выполнении в POSIX-режиме есть определённые особенности.
          - Они касаются встроенных команд:

            ▪ Во время поиска команды, команда сначала ищется среди
              специальных встроенных команд, а затем — среди функций
              командной оболочки.

            ▪ Если специальная встроенная команда возвращает состояние
              ошибки, то в неинтерактивном режиме происходит выход из
              командной оболочки.

            ▪ Инструкции присваивания, предшествующие команде, оказывают
              эффект на среду оболочки только после завершения команды.

          - Специальные встроенные команды:

            :, ., break, continue, eval, exec, exit, export,
            readonly, return, set, shift, trap and unset.

    # Исполнение команд из скрипта

      • Построчно считывает, интерпретирует, исполняет
        - Для скриптов bash делает форк и создаёт новый дочерний процесс.
        - Этот саб-шелл считывает строки из скрипта, по одной за раз.
        - Каждая строка считывается, интерпретируется и выполняется.
        - Так, как если бы они вводились в интерактивном режиме с клавиатуры.

      • Родительский процесс ждёт
        - Сабж ждёт завершения выполнения скрипта.
        - Дочерний процесс завершается, когда в скрипте кончаются строки.
        - В интерактивном режиме, род.проц. оживает, и запрашивает новую строку.

  > Полная картина работы Bash в мелком масштабе

    # Bash-синтаксис

      • Разбивает ввод на слова и операторы
        - Шелл считывает ввод и разбивает на слова и операторы.
        - Но если ввод закомментирован, то этого не происходит.

      • Трансляция в команды
        - Затем слова/операторы транслируются в команды/конструкции.
        - Каждая из которых может вернуть в результате некий статус.
        - Который интерпретатор может интерпретировать и обработать.

      • Механизм Fork-and-Exec применяется только после:

        ▪ Bash считывает ввод из файла / строки / терминала

        ▪ Ввод разбивается на слова и операторы
          - Делает он это, следуя правилам использования кавычек.
          - Эти лексемы разделяются метасимволами.
          - Выполняется подстановка алиасов.

        ▪ Анализ и подстановка
          - Bash проводит анализ и подстановку в лексемах.

        ▪ Прочее
          - Bash выполняет различные доп.действия.
          - Разбивает лексемы на списки имён файлов / команд / аргументов.

        ▪ Перенаправление
          - Производится, если это необходимо.
          - Операторы перенаправления и их операнды удаляются из списка аргументов.

        ▪ Выполняет команды

        ▪ Ждёт, собирает статусы
          - Это не обязательно.
          - Bash может подождать, пока команды будут выполнены.
          - И собрать статусы.

    # Bash-команды

      • Простые команды
        - Простая bash-команда состоит из команды и аргументов.
        - Например:

          touch file1 file2 file3

      • Составные команды
        - Состоят из набора простых команд.
        - Которые м.б. объединены друг с другом разными путями:

          ▪ Через pipeline (вывод одной команды во ввод другой)
          ▪ Условными операторами
          ▪ Циклами
          ▪ ... Каким-либо другим образом

        - Например:

          ls | more
          gunzip file.tar.gz | tar xvf -

    # Bash-функции

      • Зачем нужны
        - Это способ сгруппировать команды для использования в будущем.
        - Вызвать все эти команды можно будет по имени функции.
        - Все сгруппированные команды будут выполнены обычным образом.

      • Дочерний процесс не создаётся
        - При вызове функции дочерний процесс не создаётся.
        - Все команды выполняются в текущем процессе шелла.

    # Bash-переменные
      - Переменные в Bash хранят значения и доступны по имени.
      - Переменная может иметь значение и от 0 и более атрибутов.
      - Создать переменную можно встроенной командой declare.
      - Удалить переменную можно встроенной командой unset.

    # Bash-расширения
      - Сабж применяется каждый раз после разбития строки на лексемы.
      - Что это за bash-расширения:

        ▪ Brace expansion                   | раскрытие фигурных скобок
        ▪ Tilde expansion                   | замена символа "тильда"
        ▪ Parameter and variable expansion  | подстановка параметров и переменных
        ▪ Command substitution              | подстановка команд
        ▪ Arithmetic expansion              | раскрытие арифметических выражений
        ▪ Word splitting                    | разбиение на отдельные слова
        ▪ Filename expansion                | подстановка имен файлов

    # Bash-переадресация
      - Перед выполнением команды её input/output может быть перенаправлен.
      - Это можно сделать с помощью спец.нотации, интерпретируемой шеллом.
      - Перенаправление также м.б. использовано для открытия/закрытия файлов.

    # Исполнение команд в Bash

      • Помечает переменные
        - Некоторые слова парсер пометил, как переменные.
        - Все эти пометки сохраняются для дальнейшего использования.

      • Выполнение bash-расширений
        - Расширения применяются для не помеченных в кач-ве переменых частей команд.

      • Выявление команды и аргументов
        - Первое оставшееся после расширений слово, это команда.
        - Остальные слова, это её аргументы.

      • Выполнение переадресаций
        - Сабж.

      • Затем происходит расширение переменных
        - Подставляются их строковые значения.
        - Если имени команды нет, то переменные изменят текущую среду командной оболочки.

    # Поиск команд в Bash
      - Важной задачей Bash является поиск команд.
      - Bash делает это следующим образом:

        • Сначала ищет функцию
          - Проветяет, содержит ли команда слэши.
          - Если нет, сначала ищет среди доступных фунций по имени.

        • Затем ищет встроенную команду

        • Ищет команду в PATH
          - Если это не функция и не встроенная команда.
          - Bash хранит весь PATH в памяти, поиск по нему быстр.

        • Исполняет команду в дочернем процессе
          - Если команда найдена или содержит слэши.
          - Шелл выполняет её в дочернем процессе.

        • Решает, что это шелл-скрипт
          - Если выполнение проваливается.
          - Потому что файл ни является исполняемым, ни каталогом.

        • Шелл ждёт окончания работы команды
          - Если она не была запущена асинхронно.
          - И получает её статус.

    # Bash-скрипты
      - Шеллу 1-ым аргументом можно передать <имя>.
      - Если без параметров -c/-s, будет создан неинтерактивный
        дочерний шелл-процесс.
      - Последний сначала искать файл <имя> в так:

        • Сначала заглянет в текущий каталог.
        • Затем посмотрит в PATH.



А2. Встроенные команды

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным командам Bourne shell и Bash

      • Bourne shell

        - :         | Оператор "двоеточие", см.примеры
        - .         | Алиас для source, выполняет скрипт в текущем процессе
        - break     | Выход из циклов for/while/until/select
        - cd        | Изменить текущий рабочий каталог на directory
        - continue  | Перейти к следующей итерации цикла for/while/until/select
        - eval      | Аналог source, но выполняет не скрипт из файла, а команду из аргументов
        - exec      | Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес
        - exit      | Завершить текущий шелл или скрипт
        - export    | Экспортирует переменную/функцию NAME в среду окружения
        - getopts   | Команда для парсинга аргументов командной строки
        - hash      | Запоминает полные pathname команд с именами [name]
        - pwd       | Вывести абсолютный путь к текущему каталогу
        - readonly  | Пометить каждую name как readonly
        - return    | Остановить шелл-функцию и вернуть [n] тому, кто её вызвал
        - shift     | Сдвинуть все позиционные параметры влево на n пунктов
        - test, [   | Выполнить условное выражение, вернуть true/false
        - times     | Выводит затраченное скриптом и его детьми время
        - trap      | Назначить обработчик события
        - umask     | Назначить umask для создания файлов в шелле.
        - unset     | Удалить переменные/функции name

      • Bash

        - alias     | Назначить алиас name со значением value.
        - bind      | Назначить гоячие клавиши
        - builtin   | Выполнить встроенную команду шелла
        - caller    | Возвращает контекст вызова любой активной подпрограммы
        - command   | Аналог buildin, только не для встроенных команд - запустить команду в обход функции
        - declare   | Декларирует переменные и присваивает им атрибуты
        - echo      | Выводит args, разделённые пробелом, заканчивающиеся newline'ом
        - enable    | Вкл / Выкл встроенные шелл-команды
        - help      | Вывести help для встроенных команд
        - let       | Позволяет проводить арифметические операции
        - local     | Создать локальную переменную name со значением value
        - logout    | Выйти из аккаунта
        - mapfile   | Читает строки из стандартного ввода в индексированный массив
        - printf    | Получить строку в заданном формате
        - read      | Считать 1 строку из stdin или файла, и записать слова из неё в name1,name2,...
        - readarray | Считать строки из stdin в индексированный массив array
        - source    | Синоним для встроенной команды . Bourne Shell
        - type      | Показать какой код реально скрывается за именем команды
        - typeset   | Это синоним declare, оставлен для совместимости с Korn shell
        - ulimit    | Обеспечить контроль за ресурсами доступными процессам, запущенным шеллом
        - unalias   | Удалить алиас name

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по Bourne Shell build-in commands
        https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#Bourne-Shell-Builtins

    # Оф.справочник GNU по Bash build-in commands
        http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

    # Справочник с примерами из man pages
        http://ss64.com/bash/

  > Введение
    - Эта глава является справочником по встроенным командам.
    - Причём, именно встроенным командам Bourne shell и Bash.
    - Оные для POSIX-режима не рассматриваются.

  > Справочник по встроенным командам Bash

    // : //
    //---//
    // - Оператор "двоеточие", см.примеры
    // - Подоглавление примеров:
    //
    //  • Плейсхолдер для "ничего не делать"
    //  • Вставка коммента прямо в строке команды
    //  • Алиас для true
    //  • Вкл/Выкл многословныый режим в командах
    //  • Назначить значение var, если это не команда, и такой переменной ещё нет
    //  • Сделать заготовку функции (типа надо её написать)
    //  • Написать блок с комментами aka /* */
    //  • Выполнить команду, но не показывать её вывод
    //

      # Формат

        : [arguments]

      # Описание
        - Исторически, у Bourne Shell небыло встроенных true/false.
        - Вместо true использовалась : , а вместо false let 0.
        - В наши дни, можно наравне использовать : и true.

      # Примеры

        • Плейсхолдер для "ничего не делать"
            for ((x=0;x<100000;++x)) ; do : ; done
            if command; then :; else ...; fi

        • Вставка коммента прямо в строке команды
            command ; command ; : we need a comment in here for some reason ; command

        • Алиас для true
            while : ; do command ; done

        • Вкл/Выкл многословныый режим в командах
            #!/bin/bash
            if [[ "$VERBOSE" == "" || "$VERBOSE" == "0" ]]; then
                vecho=":"     # no "verbose echo"
            else
                vecho=echo    # enable "verbose echo"
            fi
            $vecho "Verbose echo is ON"

        • Назначить значение var, если это не команда, и такой переменной ещё нет
            : "${var:=$1}"

        • Сделать заготовку функции (типа надо её написать)
            future_function () { :; }

        • Написать блок с комментами aka /* */
            : << 'SKIP'
            your code block here
            SKIP

        • Выполнить команду, но не показывать её вывод
            : `some_command`

    // . //
    //---//
    // - Алиас для source, выполняет скрипт в текущем процессе.

      # Формат

        . filename [arguments]

      # Описание

        • Главное
          - Команда . является алиасом для команды source.
          - Если просто исполнить какой-нибудь скрипт:

            some_script

          - То в процессе Fork-and-Exec будет создан дочерний процесс.
          - Этот процесс будет иметь копию родительского окружения.
          - И скрипт будет выполнен в этом дочернем процессе.
          - Любые изменения окружения этим скриптом не отразятся на род.окружении.
          - Например, скрипт назначает какие-либо алиасы:

              alias ls="ls -a"

          - После завершения скрипта этого алиаса не будет в родит.окружении.
          - Как изменить ситуацию? Не создавать дочерний процесс.
          - А выполнить скрипт в том же процессе шелла, из которого он вызван.
          - Это можно сделать так (эти команды делают одно и тоже):

              . some_script
              source some_script

        • Как шелл ищет скрипт
          - Если filename не содержит слэш, ищет в PATH.
          - Если в PATH не нашёл, ищет в текущем каталоге.

        • Позиционные параметры ($1, $2, ...)
          - [arguments] становятся позиционными параметрами.

        • Return-статус
          - Это статус последней выполненной команды.
          - Или 0, если ни одна команда не была выполнена.
          - Если filename не найден, return-статус не нулевой.

    // break //
    //-------//
    // - Выход из циклов for/while/until/select.

      # Формат

        break [n]

      # Описание
        - Осуществляет выход из циклов for/while/until/select.
        - Параметр n позволяет выйти из n циклов (для вложенных циклов).
        - Параметр n должен быть >= 1. Иначе return status 0.
        - По умолчанию n == 1.

      # Примеры

        while :
          echo 1
          break
          echo 2
        done

    // cd //
    //----//
    // - Изменить текущий рабочий каталог на directory.

      # Формат

        cd [-L|[-P [-e]] [-@] [directory]

      # Опции

        -L    | [по умолчанию] не игнорировать символические ссылки
        -P    | игнорировать символические ссылки
        -e    | (может идти вместе с -P) вернуть unsuccessful status если после смены текущего каталога он не м.б. определён
        -@    | доп.атрибуты, связанные с файлом, как каталогом (для систем, поддерживающих это)

      # Описание

        • Если directory не указана
          - Используется путь из переменной среды HOME.
          - То есть оно переходит в домашний каталог.

        • Любые доп.аргументы после directory игнорируются
          - Сабж.

        • Переменная среды CDPATH
          - Это аналог PATH, только для команды CD.
          - Формат CDPATH такой же: "<path>:<path>:..."

        • Если directory == -, это конвертируется в directory == $OLDPWD
          - То есть cd - значит перейти к предыдущему каталогу.

        • При применении CDPATH и - абс.путь нового каталога выводится в STDOUT
          - Сабж.

        • Return-статус
          - 0, если каталог успешно сменён. Иначе, не 0.

      # Примеры

        • Перейти в домашний каталог
            cd
            cd ~

        • Вернуться в предыдущий каталог
            cd -

        • Использование CDPATH
          - Допустим, у нас есть каталог "/c/WebDev/projects".
          - В нём лежат 3 каталога: "proj1", "proj2", "proj3.
          - Добавим "/c/WebDev/projects" в CDPATH:

              export CDPATH="/c/WebDev/projects"

          - Теперь можно переходить в каталоги с проектами так:

              cd proj1
              cd proj2
              cd proj3

    // continue //
    //----------//
    // - Перейти к следующей итерации цикла for/while/until/select.

      # Формат

        continue [n]

      # Описание
        - Перейти к следующей итерации цикла for/while/until/select.
        - Параметр n (д.б. >= 1) позволяет сделать это для n циклов.
        - По умолчанию n == 1.
        - Если n < 1, return-статус 0.

    // eval //
    //------//
    // - Аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Формат

        eval [arguments]

      # Описание
        - Объединяет аргументы, разделённые пробелами, в команду.
        - Выполняет эту команду в текущем процессе, не создавая дочерний.
        - Работает аналогично eval-функциями из других языков программирования.
        - То есть eval это почти аналог: bash -c "bash code…"
        - Но с разницей, что дочерний процесс не создаётся.
        - Короче, eval это аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Примеры

        • Выполнить указанный код в текущем процессе

          { myCode=$(</dev/stdin); } <<\EOF
          ... arbitrary bash code here ...
          EOF
          eval "$myCode"

        • Определить набор одинаковых функций с именами от f до n

          main() {
              local fun='() { echo "$FUNCNAME"; }' x

              for x in {f..n}; do
                  eval "${x}${fun}"
              done

              "$@"
          }
          main "$@"

    // exec //
    //------//
    // - Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес.

      # Формат

        exec [-cl] [-a name] [command [arguments]] [redirection...]

      # Описание

        • Если command присутствует
          - Заменяет текуший процесс шелла новой программой command.
          - При этом никакого нового процесса не создаётся.

        • Если command отсутствует
          - Переадресации применяются к текущему шеллу, без выполнения command.

        • Return-статус
          - В случае ошибок переадресации, возвращает 1, иначе 0.
          - В случае ошибок exec:

            ▪ Неинтерактивный шелл отваливается, если execfail шелла не включена.
            ▪ В интерактивном шелле, exec возвращает ошибку.

      # Опции

        -a name   | передаёт name как 0-й аргумент программе
        -l        | добавляет префикс "-" 0-вому аргументу программы, также, как программа login
        -c        | выполняет программу с очищенной средой

      # Примеры

        • Обёртка вокруг программы

            myprog=/bin/ls
            echo "This is the wrapper script, it will exec $myprog"

            # do some vodoo here, probably change the arguments etc.
            # well, stuff a wrapper is there for

            exec "$myprog" "$@"

        • Открыть файл, как ввод для скрипта

            # open it
            exec 3< input.txt

            # for example: read one line from the file(-descriptor)
            read -u 3 LINE
            # or
            read LINE <&3

            # finally, close it
            exec 3<&-

        • Переадресовать stdout и stderr скрипта в файл

            exec >/var/adm/my.log 2>&1

            # script continues here...

    // exit //
    //------//
    // - Завершить текущий шелл или скрипт.

      # Формат

        exit [N]

      # Описание
        - N обозначает возвращаемый при выходе код родительскомупроцессу.
        - Если N не указана, возвращает код последней выполненной команды.
        - Ловушка при выходе выполняется перед выходом из шелла.
        - За исключением случая, когда команда exit не часть исполняющейся ловушки.

      # Примеры

        • Завершить работу текущего шелла

            exit

        • Завершить работу скрипта с кодом 0

            #/bin/bash
            # ... некий код ...
            exit 0

    // export //
    //--------//
    // - Экспортирует переменную/функцию NAME в среду окружения.

      # Формат

        export [-fn] [NAME[=VALUE] ...]
        export -p

      # Описание

        • Главное
          - Экспортирует переменную/функцию NAME в среду окружения.
          - Соответственно, всё это будет доступно и дочерним процессам.

        • Функция или переменная
          - Если опция -f указана, то функция.
          - Если не указана, то переменная.

        • Если указано VALUE
          - То при экспорте переменной назначается значение VALUE.

        • Return-статус

            0	      no error
            !=0	    invalid option
            !=0	    a given NAME is invalid

      # Опции

        -f    | экспортировать функцию, а не переменную
        -n    | отменить экспорт NAME
        -p    | показать список всех экспортированных переменных

      # Примеры

        • Вывести список всех экспортированных в среду переменных

          export
          export -p

        • Экспортировать переменную с указанным значением

          export CDPATH="/c/WebDev/projects"

    // getopts //
    //---------//
    // - Команда для парсинга аргументов командной строки.

      # Формат

        getopts optstring name [args]


      # Описание

        • Похожая команда getopt
          - Есть сабж без "s" на конце.
          - В отличие от от getopts, getopt не встроенная команда.

        • Преимущества getopts

          ▪ Нет нужды пропускать позиционные параметры через внешнюю программу.
          ▪ Getopts может установить переменные среды, полезные при парсинге.
          ▪ Нет нужды иметь дело с разными реализациями getopt и их багами.
          ▪ Getopts определена в POSIX.

        ▪ Недостаток getopts
          - Не может парсить GNU-style long options вроде --myoption.
          - А также XF86-style long options вроде -myoption.

      # Примеры
        - См. http://wiki.bash-hackers.org/howto/getopts_tutorial

    // hash //
    //------//
    // - Запоминает полные pathname команд с именами [name].

      # Формат

        hash [-r] [-p filename] [-dt] [name]

      # Опции

        -p  | не исктать в PATH, использовать name как путь к команде
        -r  | забыть все запомненные локации
        -d  | забыть все запомненные локации для каждой name
        -t  | выводить pathname для каждого name

      # Описание
        - В результате эти pathname не надо искать припоследующих вызовах.
        - Команды ищутся в PATH.
        - Любые ранее запомненные pathname отбрасываются.

      # Примеры

        • Показать, какие команды и сколько раз были использованы

            hash

    // pwd //
    //-----//
    // - Вывести абсолютный путь к текущему каталогу.

      # Формат

          pwd [-LP]

      # Опции

        -L    | выведенный путь может содержать символические ссылки
        -P    | выведенный путь не будет содержать символических ссылок

      # Примеры

        • Вывести абсолютный путь к текущему каталогу

            pwd

    // readonly //
    //----------//
    // - Пометить каждую name как readonly.

      # Формат

        readonly [-aAf] [-p] [name[=value]] …

      # Описание
        - Значения этих name не м.б. изменены низлежащим кодом.
        - По умолчанию, каждая name является переменной.

      # Опции

        -f    | каждое имя является шелл-функцией
        -a    | каждое имя является переменной с индексированным.массивом
        -A    | каждое имя является переменной с ассоц.массивом
        -Aa   | в этом случае A имеет приоритет
        -p    | если name отсутствуют, или -p указана, просто выводится список всех readonly

      # Примеры

        • Вывести список всех readonly

            readonly
            readonly -p

        • Сделать указанную переменную readonly

            readonly var="123"

    // return //
    //--------//
    // - Остановить шелл-функцию и вернуть [n] тому, кто её вызвал.

      # Формат

        return [n]

      # Описание
        - Если [n] не передано, возвращает статус последней команды.
        - Также return может остановить скрипт, вызванный через source.

    // shift //
    //-------//
    // - Сдвинуть все позиционные параметры влево на n пунктов.

      # Формат

          shift [n]

      # Описание
        - Было:     n+1 … $#
        - Стало:    $1 … $#-n
        - Удалены:  $# to $#-n+1
        - 0 <= n <= $#

    // test, [ //
    //---------//
    // - Выполнить условное выражение, вернуть true/false.

      # Формат

          test expr

      # Описание

        • Отдельные аргументы
          - Каждый оператор и операнд д.б. отдельными аргументами.

        • Нет опций
          - Не принимает никаких опций.
          - Не принимает аргумент --, означающий конец опций.

        • При использовании [
          - Последним аргументом должен быть ]

      # Операторы для комбинирования выражений

        • ! expr            | не
        • ( expr )          | приоритет
        • expr1 -a expr2    | и
        • expr1 -o expr2    | или

      # Примеры
        - Подробнее см.в главе: "А8. Bash scripting: условные операции"

    // times //
    //-------//
    // - Выводит затраченное скриптом и его детьми время.

      # Формат

          times


    // trap //
    //------//
    // - Назначить обработчик события.

      # Формат

          trap [-lp] [arg] [sigspec …]

      # Описание
        - Код arg выполняется при возбуждении событий sigspec.

      # Форматы sigspec

        • Имя сигнала с префиксом SIG. Например: SIGTERM.
        • Имя сигнала без префикса SIG. Например: TERM.
        • Номер сигнала, см.справку: trap -l

      # Комментарии по arg

        • Если отсутствует или "-", назначается обработчик по умолчанию.
        • Если пустая строка, то никакой обработки не происходит.

      # Опции

        -l    | Вывести все доступные события и их номера
        -p    | При вызове trap без аргументов, или с -p, выводит список назначенных обработчиков

      # Примеры
        - Подробнее см.здесь: http://wiki.bash-hackers.org/commands/builtin/trap

        • Вывести список назначенных обработчиков

            trap

        • Вывести все доступные события и их номера

            trap -l

        • Игнорировать событие SIGINT (терминал не будет закрываться с помощью ctrl-c)

            trap '' INT

    // umask //
    //-------//
    // - Назначить umask для создания файлов в шелле.

      # Формат

          umask [-p] [-S] [mode]

      # Описание

        • Если mode начинается с цифры
          - То он воспринимается, как 8-ричное значение.
          - По аналогии с chmod, например: 644, 777.

        • Если mode не начинается с цифры
          - Он воспринимается как маска в символьном виде.
          - По аналогии с chmod, например: rwxrwxrwx

      # Опции

        -S    | Тоже, что -p, но в символьном формате
        -p    | При вызове umask без аргументов, или с -p, выводит текущий umask шелла.

      # Примеры

        • Вывести текущий umask шелла в восьмеричном формате

            umask       | 0002
            umask -p    | umask 0002

        • Вывести текущий umask шелла в символьном формате

            umask -S    | u=rwx,g=rwx,o=rx

    // unset //
    //-------//
    // - Удалить переменные/функции name.

      # Формат

          unset [-fnv] [name]

      # Опции

        -v    | name это имена переменных среды
        -f    | name это имена функций (а по умолчанию, переменных)
        -n    | если name это пер-ая с атр-ом nameref, будет удалена name, а не то, куда она ссылается

      # Описание
        - Если опции -v, -f не применены, name это переменные.
        - А если пер-ые name не найдены, тогда ищутся функции name.
        - Переменные и функции readonly нельзя удалить.

    // alias //
    //-------//
    // - Назначить алиас name со значением value.

      # Формат

          alias [-p] [name[=value] …]

      # Опции

        -p    | без аргументов, или с -p, вывести все назначенные алиасы

      # Примеры

        • Вывести все назначенные алиасы

            alias
            alias -p

        • Назначить алиас

            alias ls="ls -a"

        • Удалить алиас

            unalias ls

    // bind //
    //------//
    // - Назначить гоячие клавиши.

      # Формат

          bind [-m keymap] [-lpsvPSVX]
          bind [-m keymap] [-q function] [-u function] [-r keyseq]
          bind [-m keymap] -f filename
          bind [-m keymap] -x keyseq:shell-command
          bind [-m keymap] keyseq:function-name
          bind readline-command

      # Опции

        -m keymap               | назначить горячие клавиши
        -l                      | вывести имена всех Readline-функций
        -p                      | вывести список существующих связок горячих клавиш с Readline-функциями
        -P                      | вывести список всех Readline-функций, и есть ли для них горячие клавиши, и какие
        -v                      | вывести имена Readline-переменных и значений в таком формате, чтобы м.б. использовать в Readline init файле
        -V                      | вывести имена Readline-переменных и значений
        -s                      | Display Readline key sequences bound to macros and the strings they output in such a way that they can be used as input or in a Readline initialization file.
        -S                      | Display Readline key sequences bound to macros and the strings they output.
        -f filename             | Read key bindings from filename.
        -q function             | Query about which keys invoke the named function.
        -u function             | Unbind all keys bound to the named function.
        -r keyseq               | Remove any current binding for keyseq.
        -x keyseq:shell-command | Cause shell-command to be executed whenever keyseq is entered.
        -X                      | List all key sequences bound to shell commands and the associated commands in a format that can be reused as input.

      # Описание
        - Позволяет назначить горячие клавиши.
        - Подробнее см.: http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

      # Примеры

        • Назначить на F6 команда "exit\n" (выход из терминала)
          - Здесь [17~ это код клавиши.
          - Посмотреть код любой клавиши в терминале можно так: alt-<клавиша>
          - Назначить:

            bind '"\e[17~":"exit\n"'

    // builtin //
    //---------//
    // - Выполнить встроенную команду шелла.

      # Формат

          builtin [shell-builtin [args]]

      # Описание
        - Ты определи функцию с именем, как у встроенной команды.
        - Как теперь вызвать последнюю? С помощью buildin.

    // caller //
    //--------//
    // - Возвращает контекст вызова любой активной подпрограммы.
    // - Например, шелл-функции или запущенного через source скрипта.

      # Формат

          caller [expr]

      # Описание

        • Без expr
          - Выводит номер строки и имя source файла текущей подпрограммы.

        • Expr - это положительный int
           - Выводит номер строки.
           - Выводит имя подпрограммы.
           - Выводит имя source файла текущей подпрограммы.
           - Соответствующие указанной позиции в текущем call stack.

    // command //
    //---------//
    // - Аналог buildin, только не для встроенных команд - запустить команду в обход функции.

      # Формат

          command [-pVv] command [arguments …]

      # Описание
        - Ты определи функцию с именем, как у команды.
        - Как теперь вызвать последнюю? С помощью command.
        - Ищет как обычные, так и встроенные команды.

      # Опции

        -p    | использовать значение PATH по умолчанию (а не реальное текущее)
        -v    | вывести инфу о найденной команде
        -V    | вывести более подробную инфу о найденной команде

      # Зачем нужна -p
        - В текущей среде PATH могла быть модифицирована.
        - Что может привести к тому, что command не найдёт стандартные утилиты.
        - Опция -p использует не тронутую PATH по умолчанию.


    // declare //
    //---------//
    // - Декларирует переменные и присваивает им атрибуты.

      # Формат

          declare [-aAfFgilnrtux] [-p] [name[=value] …]

      # Опции

        -p

          • Если name заданы
            - Выведет атрибуты и значения для каждого name.
            - Все опции кроме -f,-F игнорируются.

          • Если name не заданы
            - Выведет все атрибуты и значения.
            - Имеющие атрибуты, заданные доп.опциями.

        -F    | не отображать определения функций, только имена и атрибуты
        -g    | при декларировании в скрипте (в иных случаях игнорируется), создавать переменные в глобальном пр.имён

        -a    | Each name is an indexed array variable (see Arrays).
        -A    | Each name is an associative array variable (see Arrays).
        -f    | Use function names only.
        -i    | The variable is to be treated as an integer; arithmetic evaluation (see Shell Arithmetic) is performed when the variable is assigned a value.
        -l    | When the variable is assigned a value, all upper-case characters are converted to lower-case. The upper-case attribute is disabled.
        -n    | Give each name the nameref attribute, making it a name reference to another variable. That other variable is defined by the value of name.
                All references and assignments to name, except for changing the -n attribute itself, are performed on the variable referenced by name’s value. The -n attribute cannot be applied to array variables.
        -r    | Make names readonly. These names cannot then be assigned values by subsequent assignment statements or unset.
        -t    | Give each name the trace attribute. Traced functions inherit the DEBUG and RETURN traps from the calling shell. The trace attribute has no special meaning for variables.
        -u    | When the variable is assigned a value, all lower-case characters are converted to upper-case. The lower-case attribute is disabled.
        -x    | Mark each name for export to subsequent commands via the environment.

      # Описание

        • Использование + вместо - выключает атрибут
          - Кроме случая с +a, не позволяющего разрушить массив.
          - И кроме +r, не позволяющего удалить readonly-атрибут.

        • В функции declare делает каждое name локальным
          - Как и команда local.
          - Но только если не использовать опцию -g.

        • Если передано value, то name присваивается это value.

    // echo //
    //------//
    // - Выводит args, разделённые пробелом, заканчивающиеся newline'ом.

      # Формат

          echo [-neE] [arg …]

      # Опции

        -n    | trailing newline is suppressed
        -e    | включить интерпретацию символов после \
        -E    | отключить интерпретацию символов после \

      # Какие \ конструкции может интерпретировать echo

        \a          | alert (bell)
        \b          | backspace
        \c          | подавить последующие вывод
        \e, \E      | escape
        \f          | form feed
        \n          | new line
        \r          | carriage return
        \t          | horizontal tab
        \v          | vertical tab
        \\          | backslash
        \0nnn       | the eight-bit character whose value is the octal value nnn (zero to three octal digits)
        \xHH        | the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
        \uHHHH      | the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
        \UHHHHHHHH  | the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)


    // enable //
    //--------//
    // - Вкл / Выкл встроенные шелл-команды.

      # Формат

          enable [-a] [-dnps] [-f filename] [name …]

    // help //
    //------//
    // - Вывести help для встроенных команд.

      # Формат

          help [-dms] [pattern]

      # Опции

        -d    | отобразить короткое описание каждого pattern
        -m    | отобразить описание для каждого pattern в man-стиле
        -s    | отобразить только короткий usage synopsis для каждого pattern

      # Описание

        • Если pattern указан
          - Выводит хелп по указанной встроенной команде.

      # Примеры

    // let //
    //-----//
    // - Позволяет проводить арифметические операции.

      # Формат

          let expression [expression …]

      # Описание
        - Подробнее см.здесь: http://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic

      # Обратите внимание на пробел
        - Пробел разделяет выражения, как видно по формату.
        - Внутри одного выражения пробелы не допускаются.

      # Пример

        let x=2+2 y=2+3
        echo $x $y        // 4 5

    // local //
    //-------//
    // - Создать локальную переменную name со значением value.

      # Формат

          local [option] name[=value] …

      # Опции
        - Такие же, как у declare.

      # Описание
        - local можно использовать только внутри функции.
        - Создаваемая переменная будет видна только в функции, и её детях.

    // logout //
    //--------//
    // - Выйти из аккаунта.

      # Формат

          logout [n]

      # Описание
        - Возвращает статус n родителю шелла.

    // mapfile //
    //---------//
    // - Читает строки из стандартного ввода в индексированный массив.

      # Формат

        mapfile [-n count] [-O origin] [-s count] [-t] [-u fd]
            [-C callback] [-c quantum] [array]

      # Описание
        - Читает строки из стандартного ввода в индексированный массив.
        - Либо из файлового дескриптора, если опция -u применена.

      # Опции

        -n count    | Copy at most count lines. If count is 0, all lines are copied.
        -O origin   | Begin assigning to array at index origin. The default index is 0.
        -s count    | Discard the first count lines read.
        -t          | Remove a trailing newline from each line read.
        -u          | Read lines from file descriptor fd instead of the standard input.
        -C callback | Evaluate callback each time quantumP lines are read. The -c option specifies quantum.
        -c quantum  | Specify the number of lines read between each call to callback.

      # Примечания

        • Если C указано без c
          - То quantum == 5000.

        • mapfile очистить array перед его наполнением
          - Если явно не указан origin.

    // printf //
    //--------//
    // - Получить строку в заданном формате.

      # Формат

          printf [-v var] format [arguments]

      # Опции

        -v var    | записать вывод в переменную var, а не в stdout

      # Описание
        - Посмотреть спецификации можно так: man printf

    // read //
    //------//
    // - Считать 1 строку из stdin или файла, и записать слова из неё в name1,name2,...

      # Формат

          read [-ers] [-a aname] [-d delim] [-i text] [-n nchars]
              [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]

      # Опции

        -a aname    | The words are assigned to sequential indices of the array variable aname, starting at 0. All elements are removed from aname before the assignment. Other name arguments are ignored.
        -d delim    | The first character of delim is used to terminate the input line, rather than newline.
        -e          | Readline (see Command Line Editing) is used to obtain the line. Readline uses the current (or default, if line editing was not previously active) editing settings.
        -i text     | If Readline is being used to read the line, text is placed into the editing buffer before editing begins.
        -n nchars   | read returns after reading nchars characters rather than waiting for a complete line of input, but honor a delimiter if fewer than nchars characters are read before the delimiter.
        -p prompt   | read returns after reading exactly nchars characters rather than waiting for a complete line of input, unless EOF is encountered or read times out. Delimiter characters encountered in the input are not treated specially and do not cause read to return until nchars characters are read.
        -r          | Display prompt, without a trailing newline, before attempting to read any input. The prompt is displayed only if input is coming from a terminal.
        -s          | If this option is given, backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used as a line continuation.
        -t timeout  | Silent mode. If input is coming from a terminal, characters are not echoed.
        -u fd       | Cause read to time out and return failure if a complete line of input (or a specified number of characters) is not read within timeout seconds

    // readarray //
    //-----------//
    // - Считать строки из stdin в индексированный массив array.
    // - Изи из файлового дескриптора fd, заданного опцией -u.

      # Формат

          readarray [-n count] [-O origin] [-s count] [-t] [-u fd]
              [-C callback] [-c quantum] [array]

    // source //
    //--------//
    // - Синоним для встроенной команды . Bourne Shell.

      # Формат

          source filename


    // type //
    //------//
    // - Показать какой код реально скрывается за именем команды.

      # Формат

          type [-afptP] [name …]

      # Опции

        -t    | вывести тип: alias/function/builtin/file/keyword
        -p    | для типов 'file' вернуть имя файла на диске
        -P    | аналог -p, но работает не только для 'file'
        -a    | вернуть все места, где доступен исполняемый file (если -p не указана, алиасы и функции не учитываются)
        -f    | type не ищет шелл-функции

      # Примеры

        • Проверить, что скрывается за алиасом

          type ls     // ls --color=auto

        • Узнать тип скрывающейся за именем сущности
          - Выводом будет лишь 1 слово.
          - Одно из: alias/function/builtin/file/keyword
          - Узнать:

            type -t ls    // alias
            type -t type  // builtin
            type type     // type is a shell builtin

        • Показать все места, где определена команда grep
          - Вводим:

              type -a grep

          - Получаем:

              grep is aliased to `grep --color=auto'
              grep is /bin/grep

    // typeset //
    //---------//
    // - Это синоним declare, оставлен для совместимости с Korn shell.

      # Формат

          typeset [-afFgrxilnrtux] [-p] [name[=value] …]

      # Описание



      # Примеры



    // ulimit //
    //--------//
    // - Обеспечить контроль за ресурсами доступными процессам, запущенным шеллом.

      # Формат

          ulimit [-abcdefilmnpqrstuvxHST] [limit]

      # Опции

         -S   Change and report the soft limit associated with a resource.
         -H   Change and report the hard limit associated with a resource.

         -a   All current limits are reported.
         -c   The maximum size of core files created.
         -d   The maximum size of a process's data segment.
         -f   The maximum size of files created by the shell(default option)
         -l   The maximum size that can be locked into memory.
         -m   The maximum resident set size.
         -n   The maximum number of open file descriptors.
         -p   The pipe buffer size.
         -s   The maximum stack size.
         -t   The maximum amount of cpu time in seconds.
         -u   The maximum number of processes available to a single user.
         -v   The maximum amount of virtual memory available to the process.

      # Описание



      # Примеры



    // unalias //
    //---------//
    // - Удалить алиас name.

      # Формат

          unalias [-a] [name … ]



А3. Опции исполнения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Формат
    # Предисловие
    # Справочник по опциям исполнения

      -c                    | Read and execute commands from the first non-option argument after processing the options, then exit. Any remaining arguments are assigned to the positional parameters, starting with $0.
      -i                    | Force the shell to run interactively. Interactive shells are described in Interactive Shells.
      -l                    | Make this shell act as if it had been directly invoked by login
      -r                    | Make the shell a restricted shell (see The Restricted Shell).
      -s                    | If this option is present, or if no arguments remain after option processing, then commands are read from the standard input.
                              This option allows the positional parameters to be set when invoking an interactive shell.
      -D                    | A list of all double-quoted strings preceded by ‘$’ is printed on the standard output.
      -O, +O                | shopt_option is one of the shell options accepted by the shopt builtin (see The Shopt Builtin)
      --                    | A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments

      --debugger            | Arrange for the debugger profile to be executed before the shell starts. Turns on extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin).
      --dump-po-strings     | A list of all double-quoted strings preceded by ‘$’ is printed on the standard output in the GNU gettext PO (portable object) file format. Equivalent to -D except for the output format.
      --dump-strings        | Equivalent to -D.
      --help                | Display a usage message on standard output and exit successfully.
      --init-file filename  | Execute commands from filename (instead of ~/.bashrc) in an interactive shell.
      --rcfile filename     | Equivalent to --init-file.
      --login               | Equivalent to -l.
      --noediting           | Do not use the GNU Readline library (see Command Line Editing) to read command lines when the shell is interactive.
      --noprofile           | Don’t load the system-wide startup file /etc/profile or any of the personal initialization files ~/.bash_profile, ~/.bash_login, or ~/.profile when Bash is invoked as a login shell.
      --norc                | Don’t read the ~/.bashrc initialization file in an interactive shell. This is on by default if the shell is invoked as sh.
      --posix               | Change the behavior of Bash where the default operation differs from the POSIX standard to match the standard. This is intended to make Bash behave as a strict superset of that standard. See Bash POSIX Mode, for a description of the Bash POSIX mode.
      --restricted          | Make the shell a restricted shell (see The Restricted Shell).
      --verbose             | Equivalent to -v. Print shell input lines as they’re read.
      --version             | Show version information for this instance of Bash on the standard output and exit successfully.

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по опциям исполнения
        https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

  > Введение
    - Эта глава является справочником по опциям исполнения Bash.

  > Формат

      bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o option] [-O shopt_option] [argument …]
      bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o option] [-O shopt_option] -c string [argument …]
      bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o option] [-O shopt_option] [argument …]

  > Предисловие
    - Назначить опцию для текущего шелла можно командой set.

  > Справочник по встроенным командам Bash
    - См.: man bash.


А4. Bash scripting: основы скриптинга и отладки

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Где писать скрипты, как выбирать имя

      - Писать bash-скрипты можно в nano
      - Включить подсветку синтаксиса в nano
      - При выборе имени проверять свободно ли
      - Добавь каталог со скриптами в PATH

    # Как запускать скрипты

      - Если каталог и . не в PATH
      - Если каталог или . в PATH
      - Запуск скрипта в текущем процессе
      - Запуск скрипта в подпроцессе
      - Запуск скрипта указанным шеллом

    # Выбор шелла и комменты

      - Любой скрипт начинается с выбора шелла
      - Как писать комменты в скрипте

    # Дебаггинг скриптов

      - Запуск целого скрипта в debug-режиме опцией -x
      - Отладка лишь части внутри скрипта с помощью set -x, set +x
      - Старая добрая отладка с помощью echo

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по сабжу
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_02.html

  > Введение
    - В этой главе рассмотрим основы создания и запуска bash-скрипта.

  > Где писать скрипты, как выбирать имя

    # Писать bash-скрипты можно в nano
      - Вообще их писать можно в любом текстовом редакторе.
      - В общей папке можно, например, использовать notepad в Windows.
      - Но удобнее, всё же, писать прямо в терминале в nano.

    # Включить подсветку синтаксиса в nano
      - Редактор nano поддерживает подсветку синтаксисов для ряда языков.
      - В том числе и для bash-скриптов.
      - Посмотреть весь список поддерживаемых языков можно так:

          ls /usr/share/nano/

      - Включить любую из этих подсветок можно в конфиге nano: ~/.nanorc
      - Включим подсветку для bash:

          touch ~/.nanorc
          sudo nano ~/.nanorc

            include "/usr/share/nano/sh.nanorc"

    # При выборе имени проверять свободно ли

      • Добавляй .sh в конец своих скриптов
        - В принципе, это не обязательно.
        - Но это уменьшает вероятность конфликтов с существующими командами.

      • Проверяй, не существует ли уже такая команда
        - С помощью which / whereis / locate .
        - Например:

            which test    // ищет путь к команде
            whereis test  // ищет бинарник, исходник и справку для команды
            locate test   // ищет файлы по имени

    # Добавь каталог со скриптами в PATH
      - В Linux это делается очень просто.
      - Допустим, каталог со скриптами: "/c/WebDev/projects/bash_sandbox"
      - Добавим его в конец PATH на постоянной основе:

        export PATH="$PATH:/c/WebDev/projects/bash_sandbox"

      - Теперь скрипты из этого каталога будут доступны где угодно.

  > Как запускать скрипты

    # Если каталог и . не в PATH
      - Если каталог со скриптом и каталог . не добавлены в PATH.
      - Тогда запустить скрипт в этом каталоге можно так:

          ./script.sh

    # Если каталог или . в PATH
      - Если каталог со скриптом или каталог . добавлены в PATH.
      - Хотя добавлять в PATH . строго не рекомендуется.
      - Тогда запускать скрипт в этом каталоге можно так:

          script.sh

    # Запуск скрипта в текущем процессе
      - Иногда требуется запустить скрипт в текущем процессе.
      - Например, чтобы в этом скрипте назначить алиасы.
      - Или поназначать переменные именно для этой среды.
      - Это можно сделать со помощью встроенной команды source.
      - Команда . (точка) является синонимом команды source.
      - Примеры:

          source script.sh
          . script.sh

    # Запуск скрипта в подпроцессе
      - Обычно скрипт запускается в подпроцессе.
      - Запускается механизм Fork-and-Exec.
      - Создаётся подпроцесс с точной копией окружения родителя.
      - В этом подпроцессе-шелле выполняется указанный скрипт.
      - Потом, этот подпроцесс вместе со всей средой удаляется.
      - Минус: скрипт никак не может повлиять на среду родителя.
      - Например, установить для неё алиасы.
      - Вот, как можно запустить скрипт в подпроцессе:

          ./script    // если каталог со скриптом и . не в path
          script      // если каталог со скриптом или . в path

    # Запуск скрипта указанным шеллом
      - Редко может понадобиться указать, каким шеллом выполнять скрипт.
      - Примеры:

          rbash script.sh
          sh script.sh
          bash script.sh

  > Выбор шелла и комменты

    # Любой скрипт начинается с выбора шелла
      - Выбрать шелл можно в первой не пустой строке скрипта.
      - Она должна содержать конструкцию вида: #!<путь к шеллу>.
      - Примеры:

          #!/bin/bash
          #!/bin/sh

      - В Ubuntu по умолчанию используется /bin/sh
      - Поэтому если явно не указать #!/bin/bash, будут проблемы.

    # Как писать комменты в скрипте
      - Используя #
      - Коммент может быть как всей строкой, так и в конце строки.
      - Примеры:

          # строка-коммент
          echo "123"    # коммент в конце строки

  > Дебаггинг скриптов

    # Запуск целого скрипта в debug-режиме опцией -x
      - Можно запустить в debug-режиме целый скрипт.
      - Он будет запущен в подпроцессе.
      - Тогда в stdout будут поступать отладочные данные.
      - Сделать это можно опцией -x
      - Пример:

          bash -x script.sh

    # Отладка лишь части внутри скрипта с помощью set -x, set +x
      - Можно запустить в debug-режиме лишь часть скрипта.
      - Которая между командами set -x и set +x.
      - Применять это внутри скрипта можно сколько угодно раз.
      - Пример (код скрипта):

          .. код не для отладки ..

          set -x
          .. код для отладки ..
          set +x

          .. код не для отладки ..

      - Ещё можно применять set -o и set +o.
      - Это будет выводить ввод из stdin так, как он считывается.

    # Старая добрая отладка с помощью echo
      - Выводим содержимое переменных с помощью echo.
      - Разбрасываем: echo "1", echo "2" по коду.
      - Ищем место, где код прервал своё выполнение.
      - И так далее.


А5. Bash scripting: среда [написать по запросу]

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А6. Bash scripting: регулярные выражения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Общая информация о RegExp в bash

      - Что такое RegExp
      - Конкатенация RegExp
      - Объединение RegExp с помощью оператора | (infix)
      - Про приоритетность
      - Экранирование метасимволов

    # Матасимволы RegExp

      .	        | Matches any single character.
      ?	        | The preceding item is optional and will be matched, at most, once.
      *	        | The preceding item will be matched zero or more times.
      +	        | The preceding item will be matched one or more times.
      {N}	      | The preceding item is matched exactly N times.
      {N,}	    | The preceding item is matched N or more times.
      {N,M}	    | The preceding item is matched at least N times, but not more than M times.
      -	        | represents the range if it's not first or last in a list or the ending point of a range in a list.
      ^	        | Matches the empty string at the beginning of a line; also represents the characters not in the range of a list.
      $	        | Matches the empty string at the end of a line.
      \b	      | Matches the empty string at the edge of a word.
      \B	      | Matches the empty string provided it's not at the edge of a word.
      \<	      | Match the empty string at the beginning of word.
      \>	      | Match the empty string at the end of word.

    # Использование RegExp с командой grep

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по сабжу
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html

  > Введение
    - Эта глава про использование регулярных выражений в bash.

  > Общая информация о RegExp в bash

    # Что такое RegExp
      - Паттерн для описания набора строк.
      - Конструируются по аналогии с арифметическими выражениями.
      - Используются различные операторы для комбинации меньших выражений.

    # Конкатенация RegExp
      - Два регулярных выражения могут быть конкатенированы.
      - Тогда матчинг будет происходить уже с этим результатом.

    # Объединение RegExp с помощью оператора | (infix)
      - Два регулярных выражения м.б. объединены оператором |
      - Результирующее RegExp матчит любую строку, которую
        матчит любая из объединённых частей.

    # Про приоритетность
      - Repetition takes precedence over concatenation, which in turn takes precedence over alternation.
      - A whole subexpression may be enclosed in parentheses to override these precedence rules.

    # Экранирование метасимволов
      - Метасимволы можно экранировать бэкслэшем \

  > Матасимволы RegExp
    - См.оглавление.

  > Использование RegExp с командой grep

    # Что делает команда grep
      - Применяет к файлу или входящему потоку указанное RegExp.
      - Ищет строки, содержащие соотв-щую RegExp строку.
      - Выводит эти найденные строки в stdout (по умолчанию).

    # Примеры

      • Вывести все работающие процессы, содержащие node в имени

          ps aux | grep node

      • Вывести все строки из /etc/passwd, содержащие root

          grep root /etc/passwd
          grep -n root /etc/passwd                      // указывать ещё в начале номер строки

      • Вывести все строки из /etc/passwd, НЕ содержащие root

          grep -v bash /etc/passwd | grep -v nologin    // инвертировать RegExp




А7. Bash scripting: потоковый редактор GNU sed


  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А8. Bash scripting: условные операции

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А9. Bash scripting: интерактивные скрипты

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А10. Bash scripting: циклы

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А11. Bash scripting: переменные, массивы, операции с ними

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А12. Bash scripting: функции

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А13. Bash scripting: сигналы

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


