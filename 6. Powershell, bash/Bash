////==================================================////
////                                                  ////
////                       Bash                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Руководства //
  //-------------//

    # Краткое руководство по Bash programming
        http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html

    # Более полное руководство по Bash programming (en + ru)
        http://tldp.org/LDP/Bash-Beginners-Guide/html/
        http://rus-linux.net/nlib.php?name=/MyLDP/BOOKS/Bash-Guide-1.12-ru/bash-guide-index.html

  // Cheet sheets //
  //--------------//

    # Bourne-Again SHell and Linux CLI by Martin Bruchanov
        http://bruxy.regnet.cz/linux/bash_cheatsheet/bash_cheatsheet.pdf

    # Bash CheatSheet for UNIX Systems
        https://gist.github.com/LeCoupa/122b12050f5fb267e75f

  // Прочее //
  //--------//

    # Здесь много экспертной информации о Bash
        http://wiki.bash-hackers.org/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Bash

    А1. Вводная информация
    А2. Встроенные команды
    А3. Опции исполнения

    А4. Bash scripting: основы скриптинга и отладки
    А5. Bash scripting: среда
    А6. Bash scripting: регулярные выражения
    А7. Bash scripting: потоковый редактор GNU sed
    А8. Bash scripting: условные операции
    А9. Bash scripting: интерактивные скрипты
    А10. Bash scripting: циклы
    А11. Bash scripting: переменные, массивы, операции с ними
    А12. Bash scripting: функции
    А13. Bash scripting: сигналы

  # Б.  Рецепты и наработки

    Б1.



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////

А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # UNIX shell

      - Интерпретирует команды пользователя
      - Команды могут быть приняты в интерактивном режиме, или в файле
      - Шелл-скрипты интерпретируются, а не компилируются
      - Шелл обеспечивает окружение
      - Bash это shell проекта GNU

    # Фичи bash

      - Расширенный набор опций исполнения
      - Startup-конфиги bash
      - Интерактивные скрипты
      - Улучшенные условные операции [[, [, test
      - Арифметика с помощью let
      - Алиасы
      - Одномерные массивы
      - История недавно песещённых каталогов
      - Управление prompt-строкой

    # Какие конфиги считывает при старте

      - Интерактивный, аутентифицированный
      - Интерактивный, не аутентифицированный
      - Не интерактивный
      - SH-режим
      - POSIX-режим
      - Remote-режим
      - Режим UID != EUID

    # Отличия поведения интерактивных от не интерактивных скриптов

      - Читает startup-файлы
      - Job-control вкл по умолчанию
      - Prompt-строки не пусты
      - Команды считываются из командной строки,
      - Не выходит после EOF
      - История команд вкл по умолчанию
      - Alias Expansion включено
      - Сигнал SIGTERM игнорируется
      - Сигнал SIGINT ловится и обрабатывается
      - При выходе отправляет SIGHUP всем задачам
      - Команды выполняются сразу после чтения
      - Bash проверяет почту периодически
      - Выход при встрече unreferenced variables выкл
      - Выход при ошибках в redirection выкл
      - Выход в POSIX-режиме built-ins returning errors выкл
      - Ошибка в exec не приведёт к выходу из шелла
      - Ошиби парсинга не приводят к выходи из шелла
      - Простая проверка орфографии для cd вкл по умолчанию
      - Авто выход после истечения времени в TMOUT вкл

    # Исполнение команд

      - 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Исполнение скомпилированных команд
      - Исполнение встроенных команд
      - Исполнение команд из скрипта

    # Полная картина работы Bash в мелком масштабе

      - Bash-синтаксис
      - Bash-команды
      - Bash-функции
      - Bash-переменные
      - Bash-расширения
      - Bash-переадресация
      - Исполнение команд в Bash
      - Поиск команд в Bash
      - Bash-скрипты

  --------------------------------------

  > Ссылки

    # Вводная глава в руководстве про Bash
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_01.html

  > Введение
    - Эта глава с краткой вводной информацией о Bash.

  > UNIX shell

    • Интерпретирует команды пользователя
    • Команды могут быть приняты в интерактивном режиме, или в файле
    • Шелл-скрипты интерпретируются, а не компилируются

      ▪ Что делает шелл
        - Шелл считывает скрипт строку за строкой.
        - В каждой строке ищет имеющиеся в системе команды.

      ▪ Что происходило бы при компиляции
        - Но не происходит, ведь шелл интерпретирует, а не компилирует.
        - Компилятор преобразовывал бы программу в машинный код.
        - В итоге получая исполняемый файл, который можно использовать в шелл-скрипте.

    • Шелл обеспечивает окружение
      - Помипо передачи скрипта ядру, у шелла есть ещё важная задача.
      - Это организация индивидуальной среды окружения.

    • Bash это shell проекта GNU
      - Это бесплатный шелл от проекта GNU для UNIX-систем.
      - Он объединяет преимущества Korn shell (ksh) и C shell (csh), включая:

        ▪ Режим редактирования в командной строке
        ▪ Неограниченный размер истории команд
        ▪ Управления задачами
        ▪ Функции и алиасы
        ▪ Неограниченные индексированные массивы
        ▪ Целочисленная арифметика по основаниями от 2 до 64

      - Bash является sh-совемстимым шеллом.
      - Он может выполнить 99% sh-скриптов без необходимости их подстроить под Bash.

  > Фичи bash

    # Расширенный набор опций исполнения
      - Список всех опций исполнения доступен здесь:
          https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

    # Startup-конфиги bash
      - Bash перед исполнением скрипта считывает и применяет конфиги.
      - Какие именно зависит от обстоятельств.
      - Подробности в разделе ниже.

    # Интерактивные скрипты

      • Что такое интерактивные скрипты
        - Которые читают/пишут в пользовательский терминал.
        - То есть их ввод и вывод подключены к терминалу.
        - Включить bash в интерактивном режиме можно:

          ▪ Вызвав его без аргументов-не-опций: bash
          ▪ Кроме того случае, когда опцией является строка со скриптом.
          ▪ Или когда шеллу приказано читать из STDIN

      • Как проверить, в интерактивном или нет режиме исполняется скрипт
        - Для этого надо проверить содержимое спец.параметра -
        - Проверяем:

            echo $-

        - В интерактивном режиме он выдаст: himBH
        - В неинтерактивном режиме он будет пуст.

      • Отличия в поведении интерактивных, от не интерактивных скриптов
        - Имеются некоторые отличия, подробности в разделе ниже

    # Улучшенные условные операции [[, [, test
      - Сабж.

    # Арифметика с помощью let
      - Работать с арифметиком можно командой let.
      - Это одно из дополнений, внесённых шеллом bash.

    # Алиасы

      • Работать с алиасами можно командами alias / unalias.
      • Любой алиас срабатывает только на следующей строке кода.
        - Поэтому определить и использовать алиас на 1-й строке нельзя.
      • Алиасы и функции
        - Алиасы применяются при чтении определения функции, а не когда она исполняется
        - Потому что функция считается 1-й командой.
        - Алиасы из функции будут недоступными, пока она не будет выполнена.

    # Одномерные массивы
      - Bash обеспечивает переменные - одномерные массивы.
      - Любую переменную можно использовать в качестве массива.
      - Ключевое слово declare явно определяет массив.
      - Ограничений на размер массива нет.

    # История недавно песещённых каталогов

      • pushd
        - Ключевое слово pushd добавляет каталог в историю.
        - Это происходит каждый раз при смене текущего каталога.

      • popd
        - Ключевое слово popd удаляет каталог из истории.
        - И меняет текущий каталог на извлечённых из истории.

      • dirs
        - Содержимое истории можно просмотреть ключевым словом dirs.

    # Управление prompt-строкой
      - Подробнее про управление сабжем см. в методичке по Ubuntu.
      - А также на сайте GNU: https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html

  > Какие конфиги считывает при старте

    # Интерактивный, аутентифицированный
      - Интерактивный режим, аутентифицированный пользователь / или с опцией --login
      - Интерактивный значит, что ты можешь вводить команды.
      - Аутентифицированный, значит от лица аутентифицированного пользователя.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.bash_profile, ~/.bash_login or ~/.profile: first existing readable file is read
        • ~/.bash_logout upon logout.

    # Интерактивный, не аутентифицированный
      - Интерактивный режим, не аутентифицированный пользователь
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Не интерактивный
      - Не интерактивный режим
      - Все скрипты из файлов выполняются в неинтерактивном режиме.
      - Считывает следующие конфиги:

        • defined by BASH_ENV

    # SH-режим
      - Выполняется командой sh
      - Bash старается вести себя, как sh.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.profile

    # POSIX-режим
      - Как включить режим POSIX:

        • Встроенной командой set: set -o posix
        • Выполнив скрипт с опцией --posix

      - Тогда bash будет стараться max соблюдать стандарты POSIX.
      - Установка переменной среды POSIXLY_CORRECT, это не тоже самое.
      - Считывает следующие конфиги:

        • defined by ENV variable.

    # Remote-режим
      - Исполняемые с удалённой машины
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Режим UID != EUID
      - Вызов в случае, когда UID не совпадает с EUID
      - В этом случае конфиги не читаются.

  > Отличия поведения интерактивных от не интерактивных скриптов

    # Читает startup-файлы
    # Job-control вкл по умолчанию
    # Prompt-строки не пусты
    # Команды считываются из командной строки,
      - Используя опцию readline
    # Не выходит после EOF
      - Применяя опцию шелла ignoreeof.
    # История команд вкл по умолчанию
      - И хранитя в файле по адресу $HISTFILE
      - По умолчанию это ~/.bash_history.
    # Alias Expansion включено
    # Сигнал SIGTERM игнорируется
      - В отсутствии ловушек.
    # Сигнал SIGINT ловится и обрабатывается
      - Поэтому ctrl-c не приводит к немедленному выходу.
      - А шелл запрашивает подтверждения.
    # При выходе отправляет SIGHUP всем задачам
      - Используется опция huponexit
    # Команды выполняются сразу после чтения
    # Bash проверяет почту периодически
    # Выход при встрече unreferenced variables выкл
    # Выход при ошибках в redirection выкл
    # Выход в POSIX-режиме built-ins returning errors выкл
    # Ошибка в exec не приведёт к выходу из шелла
    # Ошиби парсинга не приводят к выходи из шелла
    # Простая проверка орфографии для cd вкл по умолчанию
    # Авто выход после истечения времени в TMOUT вкл

  > Исполнение команд

    # 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Bash может выполнять 3-ри типа команд:

        • Скомпилированные команды
        • Встроенные в шелл команды
        • Команды из скриптов

    # Исполнение скомпилированных команд

      • Fork
        - При исполнении такой программы Bash создаёт точную копию себя.
        - Этот дочерний процесс имеет ту же среду окружения, что и его родитель.
        - Только ID этого процесса другое.
        - Описанный выше процесс называют ветвлением/форкингом (forking).

      • Exec
        - После форка адресное пространство нового процесса перезаписывается.
        - Это происходит с помощью exec-вызова к системе.

      • Механизм Fork-and-Exec
        - Он подменяет одну команду другой, оставляя ту же среду окружения.
        - Этот механизм используется для создания всех процессов в UNIX/Linux.
        - Даже 1-ый процесс init форкается в процессе загрузки системы в
          так называемой bootstrapping-процедуре.

    # Исполнение встроенных команд

      • Встроенные команды
        - Это встроенные в сам шелл команды.
        - Они необходимы для обеспечения определённого функционала.
        - Обеспечить который извне какими-то командами и т.д. нельзя.

      • Не создаётся новый процесс
        - Если простая команда начинается с имени встроенной.

      • 3-ри типа встроенных команд

        ▪ Встроенные команды Bourne Shell

            :, ., break, cd, continue, eval, exec, exit, export,
            getopts, hash, pwd, readonly, return, set, shift,
            test, [, times, trap, umask and unset.

        ▪ Встроенные команды Bash

            alias, bind, builtin, command, declare, echo, enable,
            help, let, local, logout, printf, read, shopt, type,
            typeset, ulimit and unalias.

        ▪ Особые встроенные команды
          - При выполнении в POSIX-режиме есть определённые особенности.
          - Они касаются встроенных команд:

            ▪ Во время поиска команды, команда сначала ищется среди
              специальных встроенных команд, а затем — среди функций
              командной оболочки.

            ▪ Если специальная встроенная команда возвращает состояние
              ошибки, то в неинтерактивном режиме происходит выход из
              командной оболочки.

            ▪ Инструкции присваивания, предшествующие команде, оказывают
              эффект на среду оболочки только после завершения команды.

          - Специальные встроенные команды:

            :, ., break, continue, eval, exec, exit, export,
            readonly, return, set, shift, trap and unset.

    # Исполнение команд из скрипта

      • Построчно считывает, интерпретирует, исполняет
        - Для скриптов bash делает форк и создаёт новый дочерний процесс.
        - Этот саб-шелл считывает строки из скрипта, по одной за раз.
        - Каждая строка считывается, интерпретируется и выполняется.
        - Так, как если бы они вводились в интерактивном режиме с клавиатуры.

      • Родительский процесс ждёт
        - Сабж ждёт завершения выполнения скрипта.
        - Дочерний процесс завершается, когда в скрипте кончаются строки.
        - В интерактивном режиме, род.проц. оживает, и запрашивает новую строку.

  > Полная картина работы Bash в мелком масштабе

    # Bash-синтаксис

      • Разбивает ввод на слова и операторы
        - Шелл считывает ввод и разбивает на слова и операторы.
        - Но если ввод закомментирован, то этого не происходит.

      • Трансляция в команды
        - Затем слова/операторы транслируются в команды/конструкции.
        - Каждая из которых может вернуть в результате некий статус.
        - Который интерпретатор может интерпретировать и обработать.

      • Механизм Fork-and-Exec применяется только после:

        ▪ Bash считывает ввод из файла / строки / терминала

        ▪ Ввод разбивается на слова и операторы
          - Делает он это, следуя правилам использования кавычек.
          - Эти лексемы разделяются метасимволами.
          - Выполняется подстановка алиасов.

        ▪ Анализ и подстановка
          - Bash проводит анализ и подстановку в лексемах.

        ▪ Прочее
          - Bash выполняет различные доп.действия.
          - Разбивает лексемы на списки имён файлов / команд / аргументов.

        ▪ Перенаправление
          - Производится, если это необходимо.
          - Операторы перенаправления и их операнды удаляются из списка аргументов.

        ▪ Выполняет команды

        ▪ Ждёт, собирает статусы
          - Это не обязательно.
          - Bash может подождать, пока команды будут выполнены.
          - И собрать статусы.

    # Bash-команды

      • Простые команды
        - Простая bash-команда состоит из команды и аргументов.
        - Например:

          touch file1 file2 file3

      • Составные команды
        - Состоят из набора простых команд.
        - Которые м.б. объединены друг с другом разными путями:

          ▪ Через pipeline (вывод одной команды во ввод другой)
          ▪ Условными операторами
          ▪ Циклами
          ▪ ... Каким-либо другим образом

        - Например:

          ls | more
          gunzip file.tar.gz | tar xvf -

    # Bash-функции

      • Зачем нужны
        - Это способ сгруппировать команды для использования в будущем.
        - Вызвать все эти команды можно будет по имени функции.
        - Все сгруппированные команды будут выполнены обычным образом.

      • Дочерний процесс не создаётся
        - При вызове функции дочерний процесс не создаётся.
        - Все команды выполняются в текущем процессе шелла.

    # Bash-переменные
      - Переменные в Bash хранят значения и доступны по имени.
      - Переменная может иметь значение и от 0 и более атрибутов.
      - Создать переменную можно встроенной командой declare.
      - Удалить переменную можно встроенной командой unset.

    # Bash-расширения
      - Сабж применяется каждый раз после разбития строки на лексемы.
      - Что это за bash-расширения:

        ▪ Brace expansion                   | раскрытие фигурных скобок
        ▪ Tilde expansion                   | замена символа "тильда"
        ▪ Parameter and variable expansion  | подстановка параметров и переменных
        ▪ Command substitution              | подстановка команд
        ▪ Arithmetic expansion              | раскрытие арифметических выражений
        ▪ Word splitting                    | разбиение на отдельные слова
        ▪ Filename expansion                | подстановка имен файлов

    # Bash-переадресация
      - Перед выполнением команды её input/output может быть перенаправлен.
      - Это можно сделать с помощью спец.нотации, интерпретируемой шеллом.
      - Перенаправление также м.б. использовано для открытия/закрытия файлов.

    # Исполнение команд в Bash

      • Помечает переменные
        - Некоторые слова парсер пометил, как переменные.
        - Все эти пометки сохраняются для дальнейшего использования.

      • Выполнение bash-расширений
        - Расширения применяются для не помеченных в кач-ве переменых частей команд.

      • Выявление команды и аргументов
        - Первое оставшееся после расширений слово, это команда.
        - Остальные слова, это её аргументы.

      • Выполнение переадресаций
        - Сабж.

      • Затем происходит расширение переменных
        - Подставляются их строковые значения.
        - Если имени команды нет, то переменные изменят текущую среду командной оболочки.

    # Поиск команд в Bash
      - Важной задачей Bash является поиск команд.
      - Bash делает это следующим образом:

        • Сначала ищет функцию
          - Проветяет, содержит ли команда слэши.
          - Если нет, сначала ищет среди доступных фунций по имени.

        • Затем ищет встроенную команду

        • Ищет команду в PATH
          - Если это не функция и не встроенная команда.
          - Bash хранит весь PATH в памяти, поиск по нему быстр.

        • Исполняет команду в дочернем процессе
          - Если команда найдена или содержит слэши.
          - Шелл выполняет её в дочернем процессе.

        • Решает, что это шелл-скрипт
          - Если выполнение проваливается.
          - Потому что файл ни является исполняемым, ни каталогом.

        • Шелл ждёт окончания работы команды
          - Если она не была запущена асинхронно.
          - И получает её статус.

    # Bash-скрипты
      - Шеллу 1-ым аргументом можно передать <имя>.
      - Если без параметров -c/-s, будет создан неинтерактивный
        дочерний шелл-процесс.
      - Последний сначала искать файл <имя> в так:

        • Сначала заглянет в текущий каталог.
        • Затем посмотрит в PATH.



А2. Встроенные команды

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным командам Bourne shell и Bash

      • Bourne shell

        - :         | Оператор "двоеточие", см.примеры
        - .         | Алиас для source, выполняет скрипт в текущем процессе
        - break     | Выход из циклов for/while/until/select
        - cd        | Изменить текущий рабочий каталог на directory
        - continue  | Перейти к следующей итерации цикла for/while/until/select
        - eval      | Аналог source, но выполняет не скрипт из файла, а команду из аргументов
        - exec      | Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес
        - exit      | Завершить текущий шелл или скрипт
        - export    | Экспортирует переменную/функцию NAME в среду окружения
        - getopts   | Команда для парсинга аргументов командной строки
        - hash      |
        - pwd       |
        - readonly  |
        - return    |
        - set       |
        - shift     |
        - test      |
        - [         |
        - times     |
        - trap      |
        - umask     |
        - unset     |

      • Bash

        - alias     |
        - bind      |
        - builtin   |
        - command   |
        - declare   |
        - echo      |
        - enable    |
        - help      |
        - let       |
        - local     |
        - logout    |
        - printf    |
        - read      |
        - shopt     |
        - type      |
        - typeset   |
        - ulimit    |
        - unalias   |

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по Bourne Shell build-in commands
        https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#Bourne-Shell-Builtins

    # Оф.справочник GNU по Bash build-in commands
        http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

  > Введение
    - Эта глава является справочником по встроенным командам.
    - Причём, именно встроенным командам Bourne shell и Bash.
    - Оные для POSIX-режима не рассматриваются.

  > Справочник по встроенным командам Bash

    // : //
    //---//
    // - Оператор "двоеточие", см.примеры
    // - Подоглавление примеров:
    //
    //  • Плейсхолдер для "ничего не делать"
    //  • Вставка коммента прямо в строке команды
    //  • Алиас для true
    //  • Вкл/Выкл многословныый режим в командах
    //  • Назначить значение var, если это не команда, и такой переменной ещё нет
    //  • Сделать заготовку функции (типа надо её написать)
    //  • Написать блок с комментами aka /* */
    //  • Выполнить команду, но не показывать её вывод
    //

      # Формат

        : [arguments]

      # Описание
        - Исторически, у Bourne Shell небыло встроенных true/false.
        - Вместо true использовалась : , а вместо false let 0.
        - В наши дни, можно наравне использовать : и true.

      # Примеры

        • Плейсхолдер для "ничего не делать"
            for ((x=0;x<100000;++x)) ; do : ; done
            if command; then :; else ...; fi

        • Вставка коммента прямо в строке команды
            command ; command ; : we need a comment in here for some reason ; command

        • Алиас для true
            while : ; do command ; done

        • Вкл/Выкл многословныый режим в командах
            #!/bin/bash
            if [[ "$VERBOSE" == "" || "$VERBOSE" == "0" ]]; then
                vecho=":"     # no "verbose echo"
            else
                vecho=echo    # enable "verbose echo"
            fi
            $vecho "Verbose echo is ON"

        • Назначить значение var, если это не команда, и такой переменной ещё нет
            : "${var:=$1}"

        • Сделать заготовку функции (типа надо её написать)
            future_function () { :; }

        • Написать блок с комментами aka /* */
            : << 'SKIP'
            your code block here
            SKIP

        • Выполнить команду, но не показывать её вывод
            : `some_command`

    // . //
    //---//
    // - Алиас для source, выполняет скрипт в текущем процессе.

      # Формат

        . filename [arguments]

      # Описание

        • Главное
          - Команда . является алиасом для команды source.
          - Если просто исполнить какой-нибудь скрипт:

            some_script

          - То в процессе Fork-and-Exec будет создан дочерний процесс.
          - Этот процесс будет иметь копию родительского окружения.
          - И скрипт будет выполнен в этом дочернем процессе.
          - Любые изменения окружения этим скриптом не отразятся на род.окружении.
          - Например, скрипт назначает какие-либо алиасы:

              alias ls="ls -a"

          - После завершения скрипта этого алиаса не будет в родит.окружении.
          - Как изменить ситуацию? Не создавать дочерний процесс.
          - А выполнить скрипт в том же процессе шелла, из которого он вызван.
          - Это можно сделать так (эти команды делают одно и тоже):

              . some_script
              source some_script

        • Как шелл ищет скрипт
          - Если filename не содержит слэш, ищет в PATH.
          - Если в PATH не нашёл, ищет в текущем каталоге.

        • Позиционные параметры ($1, $2, ...)
          - [arguments] становятся позиционными параметрами.

        • Return-статус
          - Это статус последней выполненной команды.
          - Или 0, если ни одна команда не была выполнена.
          - Если filename не найден, return-статус не нулевой.

    // break //
    //-------//
    // - Выход из циклов for/while/until/select.

      # Формат

        break [n]

      # Описание
        - Осуществляет выход из циклов for/while/until/select.
        - Параметр n позволяет выйти из n циклов (для вложенных циклов).
        - Параметр n должен быть >= 1. Иначе return status 0.
        - По умолчанию n == 1.

      # Примеры

        while :
          echo 1
          break
          echo 2
        done

    // cd //
    //----//
    // - Изменить текущий рабочий каталог на directory.

      # Формат

        cd [-L|[-P [-e]] [-@] [directory]

      # Опции

        -L    | [по умолчанию] не игнорировать символические ссылки
        -P    | игнорировать символические ссылки
        -e    | (может идти вместе с -P) вернуть unsuccessful status если после смены текущего каталога он не м.б. определён
        -@    | доп.атрибуты, связанные с файлом, как каталогом (для систем, поддерживающих это)

      # Описание

        • Если directory не указана
          - Используется путь из переменной среды HOME.
          - То есть оно переходит в домашний каталог.

        • Любые доп.аргументы после directory игнорируются
          - Сабж.

        • Переменная среды CDPATH
          - Это аналог PATH, только для команды CD.
          - Формат CDPATH такой же: "<path>:<path>:..."

        • Если directory == -, это конвертируется в directory == $OLDPWD
          - То есть cd - значит перейти к предыдущему каталогу.

        • При применении CDPATH и - абс.путь нового каталога выводится в STDOUT
          - Сабж.

        • Return-статус
          - 0, если каталог успешно сменён. Иначе, не 0.

      # Примеры

        • Перейти в домашний каталог
            cd
            cd ~

        • Вернуться в предыдущий каталог
            cd -

        • Использование CDPATH
          - Допустим, у нас есть каталог "/c/WebDev/projects".
          - В нём лежат 3 каталога: "proj1", "proj2", "proj3.
          - Добавим "/c/WebDev/projects" в CDPATH:

              export CDPATH="/c/WebDev/projects"

          - Теперь можно переходить в каталоги с проектами так:

              cd proj1
              cd proj2
              cd proj3

    // continue //
    //----------//
    // - Перейти к следующей итерации цикла for/while/until/select.

      # Формат

        continue [n]

      # Описание
        - Перейти к следующей итерации цикла for/while/until/select.
        - Параметр n (д.б. >= 1) позволяет сделать это для n циклов.
        - По умолчанию n == 1.
        - Если n < 1, return-статус 0.

    // eval //
    //------//
    // - Аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Формат

        eval [arguments]

      # Описание
        - Объединяет аргументы, разделённые пробелами, в команду.
        - Выполняет эту команду в текущем процессе, не создавая дочерний.
        - Работает аналогично eval-функциями из других языков программирования.
        - То есть eval это почти аналог: bash -c "bash code…"
        - Но с разницей, что дочерний процесс не создаётся.
        - Короче, eval это аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Примеры

        • Выполнить указанный код в текущем процессе

          { myCode=$(</dev/stdin); } <<\EOF
          ... arbitrary bash code here ...
          EOF
          eval "$myCode"

        • Определить набор одинаковых функций с именами от f до n

          main() {
              local fun='() { echo "$FUNCNAME"; }' x

              for x in {f..n}; do
                  eval "${x}${fun}"
              done

              "$@"
          }
          main "$@"

    // exec //
    //------//
    // - Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес.

      # Формат

        exec [-cl] [-a name] [command [arguments]] [redirection...]

      # Описание

        • Если command присутствует
          - Заменяет текуший процесс шелла новой программой command.
          - При этом никакого нового процесса не создаётся.

        • Если command отсутствует
          - Переадресации применяются к текущему шеллу, без выполнения command.

        • Return-статус
          - В случае ошибок переадресации, возвращает 1, иначе 0.
          - В случае ошибок exec:

            ▪ Неинтерактивный шелл отваливается, если execfail шелла не включена.
            ▪ В интерактивном шелле, exec возвращает ошибку.

      # Опции

        -a name   | передаёт name как 0-й аргумент программе
        -l        | добавляет префикс "-" 0-вому аргументу программы, также, как программа login
        -c        | выполняет программу с очищенной средой

      # Примеры

        • Обёртка вокруг программы

            myprog=/bin/ls
            echo "This is the wrapper script, it will exec $myprog"

            # do some vodoo here, probably change the arguments etc.
            # well, stuff a wrapper is there for

            exec "$myprog" "$@"

        • Открыть файл, как ввод для скрипта

            # open it
            exec 3< input.txt

            # for example: read one line from the file(-descriptor)
            read -u 3 LINE
            # or
            read LINE <&3

            # finally, close it
            exec 3<&-

        • Переадресовать stdout и stderr скрипта в файл

            exec >/var/adm/my.log 2>&1

            # script continues here...

    // exit //
    //------//
    // - Завершить текущий шелл или скрипт.

      # Формат

        exit [N]

      # Описание
        - N обозначает возвращаемый при выходе код родительскомупроцессу.
        - Если N не указана, возвращает код последней выполненной команды.
        - Ловушка при выходе выполняется перед выходом из шелла.
        - За исключением случая, когда команда exit не часть исполняющейся ловушки.

      # Примеры

        • Завершить работу текущего шелла

            exit

        • Завершить работу скрипта с кодом 0

            #/bin/bash
            # ... некий код ...
            exit 0

    // export //
    //--------//
    // - Экспортирует переменную/функцию NAME в среду окружения.

      # Формат

        export [-fn] [NAME[=VALUE] ...]
        export -p

      # Описание

        • Главное
          - Экспортирует переменную/функцию NAME в среду окружения.
          - Соответственно, всё это будет доступно и дочерним процессам.

        • Функция или переменная
          - Если опция -f указана, то функция.
          - Если не указана, то переменная.

        • Если указано VALUE
          - То при экспорте переменной назначается значение VALUE.

        • Return-статус

            0	      no error
            !=0	    invalid option
            !=0	    a given NAME is invalid

      # Опции

        -f    | экспортировать функцию, а не переменную
        -n    | отменить экспорт NAME
        -p    | показать список всех экспортированных переменных

      # Примеры

        • Вывести список всех экспортированных в среду переменных

          export
          export -p

        • Экспортировать переменную с указанным значением

          export CDPATH="/c/WebDev/projects"

    // getopts //
    //---------//
    // - Команда для парсинга аргументов командной строки.

      # Формат

        getopts optstring name [args]

      # Описание

        • Похожая команда getopt
          - Есть сабж без "s" на конце.
          - В отличие от от getopts, getopt не встроенная команда.

        • Преимущества getopts

          ▪ Нет нужды пропускать позиционные параметры через внешнюю программу.
          ▪ Getopts может установить переменные среды, полезные при парсинге.
          ▪ Нет нужды иметь дело с разными реализациями getopt и их багами.
          ▪ Getopts определена в POSIX.

        ▪ Недостаток getopts
          - Не может парсить GNU-style long options вроде --myoption.
          - А также XF86-style long options вроде -myoption.

      # Примеры



    // hash //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // pwd //
    //-----//
    // -

      # Формат



      # Описание



      # Примеры



    // readonly //
    //----------//
    // -

      # Формат



      # Описание



      # Примеры



    // return //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // set //
    //-----//
    // -

      # Формат



      # Описание



      # Примеры



    // shift //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // test //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // [ //
    //---//
    // -

      # Формат



      # Описание



      # Примеры



    // times //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // trap //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // umask //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // unset //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // alias //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // bind //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // builtin //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры



    // command //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры



    // declare //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры



    // echo //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // enable //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // help //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // let //
    //-----//
    // -

      # Формат



      # Описание



      # Примеры



    // local //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // logout //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // printf //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // read //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // shopt //
    //-------//
    // -

      # Формат



      # Описание



      # Примеры



    // type //
    //------//
    // -

      # Формат



      # Описание



      # Примеры



    // typeset //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры



    // ulimit //
    //--------//
    // -

      # Формат



      # Описание



      # Примеры



    // unalias //
    //---------//
    // -

      # Формат



      # Описание



      # Примеры




А3. Опции исполнения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным командам Bash

      -c                    |
      -i                    |
      -l                    |
      -r                    |
      -s                    |
      -D                    |
      -O                    |
      +O                    |
      --                    |

      --debugger            |
      --dump-po-strings     |
      --dump-strings        |
      --help                |
      --init-file filename  |
      --rcfile filename     |
      --login               |
      --noediting           |
      --noprofile           |
      --norc                |
      --posix               |
      --restricted          |
      --verbose             |
      --version             |

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по встроенным командам
        https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

  > Введение
    - Эта глава является справочником по опциям исполнения Bash.

  > Справочник по встроенным командам Bash

    // -c //
    //----//
    // -


    // -i //
    //----//
    // -


    // -l //
    //----//
    // -


    // -r //
    //----//
    // -


    // -s //
    //----//
    // -


    // -D //
    //----//
    // -


    // -O //
    //----//
    // -


    // +O //
    //----//
    // -


    // -- //
    //----//
    // -


    // --debugger  //
    //-------------//
    // -


    // --dump-po-strings //
    //-------------------//
    // -


    // --dump-strings //
    //----------------//
    // -


    // --help //
    //--------//
    // -


    // --init-file filename //
    //----------------------//
    // -


    // --rcfile filename //
    //-------------------//
    // -


    // --login //
    //---------//
    // -


    // --noediting //
    //-------------//
    // -


    // --noprofile //
    //-------------//
    // -


    // --norc //
    //--------//
    // -


    // --posix //
    //---------//
    // -


    // --restricted //
    //--------------//
    // -


    // --verbose //
    //-----------//
    // -


    // --version //
    //-----------//
    // -









