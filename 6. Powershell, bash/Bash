////==================================================////
////                                                  ////
////                       Bash                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Руководства //
  //-------------//

    # Краткое руководство по Bash programming
        http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html

    # Более полное руководство по Bash programming (en + ru)
        http://tldp.org/LDP/Bash-Beginners-Guide/html/
        http://rus-linux.net/nlib.php?name=/MyLDP/BOOKS/Bash-Guide-1.12-ru/bash-guide-index.html

  // Cheet sheets //
  //--------------//

    # Bourne-Again SHell and Linux CLI by Martin Bruchanov
        http://bruxy.regnet.cz/linux/bash_cheatsheet/bash_cheatsheet.pdf

    # Bash CheatSheet for UNIX Systems
        https://gist.github.com/LeCoupa/122b12050f5fb267e75f

  // Прочее //
  //--------//

    # Здесь много экспертной информации о Bash
        http://wiki.bash-hackers.org/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Bash

    А1. Вводная информация
    А2. Встроенные команды
    А3. Опции исполнения

    А4. Bash scripting: основы скриптинга и отладки
    А5. Bash scripting: среда [написать по запросу]
    А6. Bash scripting: регулярные выражения
    А7. Bash scripting: потоковый редактор GNU sed
    А8. Bash scripting: условные операции
    А9. Bash scripting: интерактивные скрипты
    А10. Bash scripting: циклы
    А11. Bash scripting: переменные, массивы, операции с ними
    А12. Bash scripting: функции
    А13. Bash scripting: сигналы [написать по запросу]

  # Б.  Рецепты и наработки

    Б1.



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////

А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # UNIX shell

      - Интерпретирует команды пользователя
      - Команды могут быть приняты в интерактивном режиме, или в файле
      - Шелл-скрипты интерпретируются, а не компилируются
      - Шелл обеспечивает окружение
      - Bash это shell проекта GNU

    # Фичи bash

      - Расширенный набор опций исполнения
      - Startup-конфиги bash
      - Интерактивные скрипты
      - Улучшенные условные операции [[, [, test
      - Арифметика с помощью let
      - Алиасы
      - Одномерные массивы
      - История недавно песещённых каталогов
      - Управление prompt-строкой

    # Какие конфиги считывает при старте

      - Интерактивный, аутентифицированный
      - Интерактивный, не аутентифицированный
      - Не интерактивный
      - SH-режим
      - POSIX-режим
      - Remote-режим
      - Режим UID != EUID

    # Отличия поведения интерактивных от не интерактивных скриптов

      - Читает startup-файлы
      - Job-control вкл по умолчанию
      - Prompt-строки не пусты
      - Команды считываются из командной строки,
      - Не выходит после EOF
      - История команд вкл по умолчанию
      - Alias Expansion включено
      - Сигнал SIGTERM игнорируется
      - Сигнал SIGINT ловится и обрабатывается
      - При выходе отправляет SIGHUP всем задачам
      - Команды выполняются сразу после чтения
      - Bash проверяет почту периодически
      - Выход при встрече unreferenced variables выкл
      - Выход при ошибках в redirection выкл
      - Выход в POSIX-режиме built-ins returning errors выкл
      - Ошибка в exec не приведёт к выходу из шелла
      - Ошиби парсинга не приводят к выходи из шелла
      - Простая проверка орфографии для cd вкл по умолчанию
      - Авто выход после истечения времени в TMOUT вкл

    # Исполнение команд

      - 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Исполнение скомпилированных команд
      - Исполнение встроенных команд
      - Исполнение команд из скрипта

    # Полная картина работы Bash в мелком масштабе

      - Bash-синтаксис
      - Bash-команды
      - Bash-функции
      - Bash-переменные
      - Bash-расширения
      - Bash-переадресация
      - Исполнение команд в Bash
      - Поиск команд в Bash
      - Bash-скрипты

  --------------------------------------

  > Ссылки

    # Вводная глава в руководстве про Bash
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_01.html

  > Введение
    - Эта глава с краткой вводной информацией о Bash.

  > UNIX shell

    • Интерпретирует команды пользователя
    • Команды могут быть приняты в интерактивном режиме, или в файле
    • Шелл-скрипты интерпретируются, а не компилируются

      ▪ Что делает шелл
        - Шелл считывает скрипт строку за строкой.
        - В каждой строке ищет имеющиеся в системе команды.

      ▪ Что происходило бы при компиляции
        - Но не происходит, ведь шелл интерпретирует, а не компилирует.
        - Компилятор преобразовывал бы программу в машинный код.
        - В итоге получая исполняемый файл, который можно использовать в шелл-скрипте.

    • Шелл обеспечивает окружение
      - Помипо передачи скрипта ядру, у шелла есть ещё важная задача.
      - Это организация индивидуальной среды окружения.

    • Bash это shell проекта GNU
      - Это бесплатный шелл от проекта GNU для UNIX-систем.
      - Он объединяет преимущества Korn shell (ksh) и C shell (csh), включая:

        ▪ Режим редактирования в командной строке
        ▪ Неограниченный размер истории команд
        ▪ Управления задачами
        ▪ Функции и алиасы
        ▪ Неограниченные индексированные массивы
        ▪ Целочисленная арифметика по основаниями от 2 до 64

      - Bash является sh-совемстимым шеллом.
      - Он может выполнить 99% sh-скриптов без необходимости их подстроить под Bash.

  > Фичи bash

    # Расширенный набор опций исполнения
      - Список всех опций исполнения доступен здесь:
          https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

    # Startup-конфиги bash
      - Bash перед исполнением скрипта считывает и применяет конфиги.
      - Какие именно зависит от обстоятельств.
      - Подробности в разделе ниже.

    # Интерактивные скрипты

      • Что такое интерактивные скрипты
        - Которые читают/пишут в пользовательский терминал.
        - То есть их ввод и вывод подключены к терминалу.
        - Включить bash в интерактивном режиме можно:

          ▪ Вызвав его без аргументов-не-опций: bash
          ▪ Кроме того случае, когда опцией является строка со скриптом.
          ▪ Или когда шеллу приказано читать из STDIN

      • Как проверить, в интерактивном или нет режиме исполняется скрипт
        - Для этого надо проверить содержимое спец.параметра -
        - Проверяем:

            echo $-

        - В интерактивном режиме он выдаст: himBH
        - В неинтерактивном режиме он будет пуст.

      • Отличия в поведении интерактивных, от не интерактивных скриптов
        - Имеются некоторые отличия, подробности в разделе ниже

    # Улучшенные условные операции [[, [, test
      - Сабж.

    # Арифметика с помощью let
      - Работать с арифметиком можно командой let.
      - Это одно из дополнений, внесённых шеллом bash.

    # Алиасы

      • Работать с алиасами можно командами alias / unalias.
      • Любой алиас срабатывает только на следующей строке кода.
        - Поэтому определить и использовать алиас на 1-й строке нельзя.
      • Алиасы и функции
        - Алиасы применяются при чтении определения функции, а не когда она исполняется
        - Потому что функция считается 1-й командой.
        - Алиасы из функции будут недоступными, пока она не будет выполнена.

    # Одномерные массивы
      - Bash обеспечивает переменные - одномерные массивы.
      - Любую переменную можно использовать в качестве массива.
      - Ключевое слово declare явно определяет массив.
      - Ограничений на размер массива нет.

    # История недавно песещённых каталогов

      • pushd
        - Ключевое слово pushd добавляет каталог в историю.
        - Это происходит каждый раз при смене текущего каталога.

      • popd
        - Ключевое слово popd удаляет каталог из истории.
        - И меняет текущий каталог на извлечённых из истории.

      • dirs
        - Содержимое истории можно просмотреть ключевым словом dirs.

    # Управление prompt-строкой
      - Подробнее про управление сабжем см. в методичке по Ubuntu.
      - А также на сайте GNU: https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html

  > Какие конфиги считывает при старте

    # Интерактивный, аутентифицированный
      - Интерактивный режим, аутентифицированный пользователь / или с опцией --login
      - Интерактивный значит, что ты можешь вводить команды.
      - Аутентифицированный, значит от лица аутентифицированного пользователя.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.bash_profile, ~/.bash_login or ~/.profile: first existing readable file is read
        • ~/.bash_logout upon logout.

    # Интерактивный, не аутентифицированный
      - Интерактивный режим, не аутентифицированный пользователь
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Не интерактивный
      - Не интерактивный режим
      - Все скрипты из файлов выполняются в неинтерактивном режиме.
      - Считывает следующие конфиги:

        • defined by BASH_ENV

    # SH-режим
      - Выполняется командой sh
      - Bash старается вести себя, как sh.
      - Считывает следующие конфиги:

        • /etc/profile
        • ~/.profile

    # POSIX-режим
      - Как включить режим POSIX:

        • Встроенной командой set: set -o posix
        • Выполнив скрипт с опцией --posix

      - Тогда bash будет стараться max соблюдать стандарты POSIX.
      - Установка переменной среды POSIXLY_CORRECT, это не тоже самое.
      - Считывает следующие конфиги:

        • defined by ENV variable.

    # Remote-режим
      - Исполняемые с удалённой машины
      - Считывает следующие конфиги:

        • ~/.bashrc

    # Режим UID != EUID
      - Вызов в случае, когда UID не совпадает с EUID
      - В этом случае конфиги не читаются.

  > Отличия поведения интерактивных от не интерактивных скриптов

    # Читает startup-файлы
    # Job-control вкл по умолчанию
    # Prompt-строки не пусты
    # Команды считываются из командной строки,
      - Используя опцию readline
    # Не выходит после EOF
      - Применяя опцию шелла ignoreeof.
    # История команд вкл по умолчанию
      - И хранитя в файле по адресу $HISTFILE
      - По умолчанию это ~/.bash_history.
    # Alias Expansion включено
    # Сигнал SIGTERM игнорируется
      - В отсутствии ловушек.
    # Сигнал SIGINT ловится и обрабатывается
      - Поэтому ctrl-c не приводит к немедленному выходу.
      - А шелл запрашивает подтверждения.
    # При выходе отправляет SIGHUP всем задачам
      - Используется опция huponexit
    # Команды выполняются сразу после чтения
    # Bash проверяет почту периодически
    # Выход при встрече unreferenced variables выкл
    # Выход при ошибках в redirection выкл
    # Выход в POSIX-режиме built-ins returning errors выкл
    # Ошибка в exec не приведёт к выходу из шелла
    # Ошиби парсинга не приводят к выходи из шелла
    # Простая проверка орфографии для cd вкл по умолчанию
    # Авто выход после истечения времени в TMOUT вкл

  > Исполнение команд

    # 3-ри типа команд: скомпилированые / встроенные / скрипты
      - Bash может выполнять 3-ри типа команд:

        • Скомпилированные команды
        • Встроенные в шелл команды
        • Команды из скриптов

    # Исполнение скомпилированных команд

      • Fork
        - При исполнении такой программы Bash создаёт точную копию себя.
        - Этот дочерний процесс имеет ту же среду окружения, что и его родитель.
        - Только ID этого процесса другое.
        - Описанный выше процесс называют ветвлением/форкингом (forking).

      • Exec
        - После форка адресное пространство нового процесса перезаписывается.
        - Это происходит с помощью exec-вызова к системе.

      • Механизм Fork-and-Exec
        - Он подменяет одну команду другой, оставляя ту же среду окружения.
        - Этот механизм используется для создания всех процессов в UNIX/Linux.
        - Даже 1-ый процесс init форкается в процессе загрузки системы в
          так называемой bootstrapping-процедуре.

    # Исполнение встроенных команд

      • Встроенные команды
        - Это встроенные в сам шелл команды.
        - Они необходимы для обеспечения определённого функционала.
        - Обеспечить который извне какими-то командами и т.д. нельзя.

      • Не создаётся новый процесс
        - Если простая команда начинается с имени встроенной.

      • 3-ри типа встроенных команд

        ▪ Встроенные команды Bourne Shell

            :, ., break, cd, continue, eval, exec, exit, export,
            getopts, hash, pwd, readonly, return, set, shift,
            test, [, times, trap, umask and unset.

        ▪ Встроенные команды Bash

            alias, bind, builtin, command, declare, echo, enable,
            help, let, local, logout, printf, read, shopt, type,
            typeset, ulimit and unalias.

        ▪ Особые встроенные команды
          - При выполнении в POSIX-режиме есть определённые особенности.
          - Они касаются встроенных команд:

            ▪ Во время поиска команды, команда сначала ищется среди
              специальных встроенных команд, а затем — среди функций
              командной оболочки.

            ▪ Если специальная встроенная команда возвращает состояние
              ошибки, то в неинтерактивном режиме происходит выход из
              командной оболочки.

            ▪ Инструкции присваивания, предшествующие команде, оказывают
              эффект на среду оболочки только после завершения команды.

          - Специальные встроенные команды:

            :, ., break, continue, eval, exec, exit, export,
            readonly, return, set, shift, trap and unset.

    # Исполнение команд из скрипта

      • Построчно считывает, интерпретирует, исполняет
        - Для скриптов bash делает форк и создаёт новый дочерний процесс.
        - Этот саб-шелл считывает строки из скрипта, по одной за раз.
        - Каждая строка считывается, интерпретируется и выполняется.
        - Так, как если бы они вводились в интерактивном режиме с клавиатуры.

      • Родительский процесс ждёт
        - Сабж ждёт завершения выполнения скрипта.
        - Дочерний процесс завершается, когда в скрипте кончаются строки.
        - В интерактивном режиме, род.проц. оживает, и запрашивает новую строку.

  > Полная картина работы Bash в мелком масштабе

    # Bash-синтаксис

      • Разбивает ввод на слова и операторы
        - Шелл считывает ввод и разбивает на слова и операторы.
        - Но если ввод закомментирован, то этого не происходит.

      • Трансляция в команды
        - Затем слова/операторы транслируются в команды/конструкции.
        - Каждая из которых может вернуть в результате некий статус.
        - Который интерпретатор может интерпретировать и обработать.

      • Механизм Fork-and-Exec применяется только после:

        ▪ Bash считывает ввод из файла / строки / терминала

        ▪ Ввод разбивается на слова и операторы
          - Делает он это, следуя правилам использования кавычек.
          - Эти лексемы разделяются метасимволами.
          - Выполняется подстановка алиасов.

        ▪ Анализ и подстановка
          - Bash проводит анализ и подстановку в лексемах.

        ▪ Прочее
          - Bash выполняет различные доп.действия.
          - Разбивает лексемы на списки имён файлов / команд / аргументов.

        ▪ Перенаправление
          - Производится, если это необходимо.
          - Операторы перенаправления и их операнды удаляются из списка аргументов.

        ▪ Выполняет команды

        ▪ Ждёт, собирает статусы
          - Это не обязательно.
          - Bash может подождать, пока команды будут выполнены.
          - И собрать статусы.

    # Bash-команды

      • Простые команды
        - Простая bash-команда состоит из команды и аргументов.
        - Например:

          touch file1 file2 file3

      • Составные команды
        - Состоят из набора простых команд.
        - Которые м.б. объединены друг с другом разными путями:

          ▪ Через pipeline (вывод одной команды во ввод другой)
          ▪ Условными операторами
          ▪ Циклами
          ▪ ... Каким-либо другим образом

        - Например:

          ls | more
          gunzip file.tar.gz | tar xvf -

    # Bash-функции

      • Зачем нужны
        - Это способ сгруппировать команды для использования в будущем.
        - Вызвать все эти команды можно будет по имени функции.
        - Все сгруппированные команды будут выполнены обычным образом.

      • Дочерний процесс не создаётся
        - При вызове функции дочерний процесс не создаётся.
        - Все команды выполняются в текущем процессе шелла.

    # Bash-переменные
      - Переменные в Bash хранят значения и доступны по имени.
      - Переменная может иметь значение и от 0 и более атрибутов.
      - Создать переменную можно встроенной командой declare.
      - Удалить переменную можно встроенной командой unset.

    # Bash-расширения
      - Сабж применяется каждый раз после разбития строки на лексемы.
      - Что это за bash-расширения:

        ▪ Brace expansion                   | раскрытие фигурных скобок
        ▪ Tilde expansion                   | замена символа "тильда"
        ▪ Parameter and variable expansion  | подстановка параметров и переменных
        ▪ Command substitution              | подстановка команд
        ▪ Arithmetic expansion              | раскрытие арифметических выражений
        ▪ Word splitting                    | разбиение на отдельные слова
        ▪ Filename expansion                | подстановка имен файлов

    # Bash-переадресация
      - Перед выполнением команды её input/output может быть перенаправлен.
      - Это можно сделать с помощью спец.нотации, интерпретируемой шеллом.
      - Перенаправление также м.б. использовано для открытия/закрытия файлов.

    # Исполнение команд в Bash

      • Помечает переменные
        - Некоторые слова парсер пометил, как переменные.
        - Все эти пометки сохраняются для дальнейшего использования.

      • Выполнение bash-расширений
        - Расширения применяются для не помеченных в кач-ве переменых частей команд.

      • Выявление команды и аргументов
        - Первое оставшееся после расширений слово, это команда.
        - Остальные слова, это её аргументы.

      • Выполнение переадресаций
        - Сабж.

      • Затем происходит расширение переменных
        - Подставляются их строковые значения.
        - Если имени команды нет, то переменные изменят текущую среду командной оболочки.

    # Поиск команд в Bash
      - Важной задачей Bash является поиск команд.
      - Bash делает это следующим образом:

        • Сначала ищет функцию
          - Проветяет, содержит ли команда слэши.
          - Если нет, сначала ищет среди доступных фунций по имени.

        • Затем ищет встроенную команду

        • Ищет команду в PATH
          - Если это не функция и не встроенная команда.
          - Bash хранит весь PATH в памяти, поиск по нему быстр.

        • Исполняет команду в дочернем процессе
          - Если команда найдена или содержит слэши.
          - Шелл выполняет её в дочернем процессе.

        • Решает, что это шелл-скрипт
          - Если выполнение проваливается.
          - Потому что файл ни является исполняемым, ни каталогом.

        • Шелл ждёт окончания работы команды
          - Если она не была запущена асинхронно.
          - И получает её статус.

    # Bash-скрипты
      - Шеллу 1-ым аргументом можно передать <имя>.
      - Если без параметров -c/-s, будет создан неинтерактивный
        дочерний шелл-процесс.
      - Последний сначала искать файл <имя> в так:

        • Сначала заглянет в текущий каталог.
        • Затем посмотрит в PATH.



А2. Встроенные команды

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным командам Bourne shell и Bash

      • Bourne shell

        - :         | Оператор "двоеточие", см.примеры
        - .         | Алиас для source, выполняет скрипт в текущем процессе
        - break     | Выход из циклов for/while/until/select
        - cd        | Изменить текущий рабочий каталог на directory
        - continue  | Перейти к следующей итерации цикла for/while/until/select
        - eval      | Аналог source, но выполняет не скрипт из файла, а команду из аргументов
        - exec      | Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес
        - exit      | Завершить текущий шелл или скрипт
        - export    | Экспортирует переменную/функцию NAME в среду окружения
        - getopts   | Команда для парсинга аргументов командной строки
        - hash      | Запоминает полные pathname команд с именами [name]
        - pwd       | Вывести абсолютный путь к текущему каталогу
        - readonly  | Пометить каждую name как readonly
        - return    | Остановить шелл-функцию и вернуть [n] тому, кто её вызвал
        - shift     | Сдвинуть все позиционные параметры влево на n пунктов
        - test, [   | Выполнить условное выражение, вернуть true/false
        - times     | Выводит затраченное скриптом и его детьми время
        - trap      | Назначить обработчик события
        - umask     | Назначить umask для создания файлов в шелле.
        - unset     | Удалить переменные/функции name

      • Bash

        - alias     | Назначить алиас name со значением value.
        - bind      | Назначить гоячие клавиши
        - builtin   | Выполнить встроенную команду шелла
        - caller    | Возвращает контекст вызова любой активной подпрограммы
        - command   | Аналог buildin, только не для встроенных команд - запустить команду в обход функции
        - declare   | Декларирует переменные и присваивает им атрибуты
        - echo      | Выводит args, разделённые пробелом, заканчивающиеся newline'ом
        - enable    | Вкл / Выкл встроенные шелл-команды
        - help      | Вывести help для встроенных команд
        - let       | Позволяет проводить арифметические операции
        - local     | Создать локальную переменную name со значением value
        - logout    | Выйти из аккаунта
        - mapfile   | Читает строки из стандартного ввода в индексированный массив
        - printf    | Получить строку в заданном формате
        - read      | Считать 1 строку из stdin или файла, и записать слова из неё в name1,name2,...
        - readarray | Считать строки из stdin в индексированный массив array
        - source    | Синоним для встроенной команды . Bourne Shell
        - type      | Показать какой код реально скрывается за именем команды
        - typeset   | Это синоним declare, оставлен для совместимости с Korn shell
        - ulimit    | Обеспечить контроль за ресурсами доступными процессам, запущенным шеллом
        - unalias   | Удалить алиас name

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по Bourne Shell build-in commands
        https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#Bourne-Shell-Builtins

    # Оф.справочник GNU по Bash build-in commands
        http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

    # Справочник с примерами из man pages
        http://ss64.com/bash/

  > Введение
    - Эта глава является справочником по встроенным командам.
    - Причём, именно встроенным командам Bourne shell и Bash.
    - Оные для POSIX-режима не рассматриваются.

  > Справочник по встроенным командам Bash

    // : //
    //---//
    // - Оператор "двоеточие", см.примеры
    // - Подоглавление примеров:
    //
    //  • Плейсхолдер для "ничего не делать"
    //  • Вставка коммента прямо в строке команды
    //  • Алиас для true
    //  • Вкл/Выкл многословныый режим в командах
    //  • Назначить значение var, если это не команда, и такой переменной ещё нет
    //  • Сделать заготовку функции (типа надо её написать)
    //  • Написать блок с комментами aka /* */
    //  • Выполнить команду, но не показывать её вывод
    //

      # Формат

        : [arguments]

      # Описание
        - Исторически, у Bourne Shell небыло встроенных true/false.
        - Вместо true использовалась : , а вместо false let 0.
        - В наши дни, можно наравне использовать : и true.

      # Примеры

        • Плейсхолдер для "ничего не делать"
            for ((x=0;x<100000;++x)) ; do : ; done
            if command; then :; else ...; fi

        • Вставка коммента прямо в строке команды
            command ; command ; : we need a comment in here for some reason ; command

        • Алиас для true
            while : ; do command ; done

        • Вкл/Выкл многословныый режим в командах
            #!/bin/bash
            if [[ "$VERBOSE" == "" || "$VERBOSE" == "0" ]]; then
                vecho=":"     # no "verbose echo"
            else
                vecho=echo    # enable "verbose echo"
            fi
            $vecho "Verbose echo is ON"

        • Назначить значение var, если это не команда, и такой переменной ещё нет
            : "${var:=$1}"

        • Сделать заготовку функции (типа надо её написать)
            future_function () { :; }

        • Написать блок с комментами aka /* */
            : << 'SKIP'
            your code block here
            SKIP

        • Выполнить команду, но не показывать её вывод
            : `some_command`

    // . //
    //---//
    // - Алиас для source, выполняет скрипт в текущем процессе.

      # Формат

        . filename [arguments]

      # Описание

        • Главное
          - Команда . является алиасом для команды source.
          - Если просто исполнить какой-нибудь скрипт:

            some_script

          - То в процессе Fork-and-Exec будет создан дочерний процесс.
          - Этот процесс будет иметь копию родительского окружения.
          - И скрипт будет выполнен в этом дочернем процессе.
          - Любые изменения окружения этим скриптом не отразятся на род.окружении.
          - Например, скрипт назначает какие-либо алиасы:

              alias ls="ls -a"

          - После завершения скрипта этого алиаса не будет в родит.окружении.
          - Как изменить ситуацию? Не создавать дочерний процесс.
          - А выполнить скрипт в том же процессе шелла, из которого он вызван.
          - Это можно сделать так (эти команды делают одно и тоже):

              . some_script
              source some_script

        • Как шелл ищет скрипт
          - Если filename не содержит слэш, ищет в PATH.
          - Если в PATH не нашёл, ищет в текущем каталоге.

        • Позиционные параметры ($1, $2, ...)
          - [arguments] становятся позиционными параметрами.

        • Return-статус
          - Это статус последней выполненной команды.
          - Или 0, если ни одна команда не была выполнена.
          - Если filename не найден, return-статус не нулевой.

    // break //
    //-------//
    // - Выход из циклов for/while/until/select.

      # Формат

        break [n]

      # Описание
        - Осуществляет выход из циклов for/while/until/select.
        - Параметр n позволяет выйти из n циклов (для вложенных циклов).
        - Параметр n должен быть >= 1. Иначе return status 0.
        - По умолчанию n == 1.

      # Примеры

        while :
          echo 1
          break
          echo 2
        done

    // cd //
    //----//
    // - Изменить текущий рабочий каталог на directory.

      # Формат

        cd [-L|[-P [-e]] [-@] [directory]

      # Опции

        -L    | [по умолчанию] не игнорировать символические ссылки
        -P    | игнорировать символические ссылки
        -e    | (может идти вместе с -P) вернуть unsuccessful status если после смены текущего каталога он не м.б. определён
        -@    | доп.атрибуты, связанные с файлом, как каталогом (для систем, поддерживающих это)

      # Описание

        • Если directory не указана
          - Используется путь из переменной среды HOME.
          - То есть оно переходит в домашний каталог.

        • Любые доп.аргументы после directory игнорируются
          - Сабж.

        • Переменная среды CDPATH
          - Это аналог PATH, только для команды CD.
          - Формат CDPATH такой же: "<path>:<path>:..."

        • Если directory == -, это конвертируется в directory == $OLDPWD
          - То есть cd - значит перейти к предыдущему каталогу.

        • При применении CDPATH и - абс.путь нового каталога выводится в STDOUT
          - Сабж.

        • Return-статус
          - 0, если каталог успешно сменён. Иначе, не 0.

      # Примеры

        • Перейти в домашний каталог
            cd
            cd ~

        • Вернуться в предыдущий каталог
            cd -

        • Использование CDPATH
          - Допустим, у нас есть каталог "/c/WebDev/projects".
          - В нём лежат 3 каталога: "proj1", "proj2", "proj3.
          - Добавим "/c/WebDev/projects" в CDPATH:

              export CDPATH="/c/WebDev/projects"

          - Теперь можно переходить в каталоги с проектами так:

              cd proj1
              cd proj2
              cd proj3

    // continue //
    //----------//
    // - Перейти к следующей итерации цикла for/while/until/select.

      # Формат

        continue [n]

      # Описание
        - Перейти к следующей итерации цикла for/while/until/select.
        - Параметр n (д.б. >= 1) позволяет сделать это для n циклов.
        - По умолчанию n == 1.
        - Если n < 1, return-статус 0.

    // eval //
    //------//
    // - Аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Формат

        eval [arguments]

      # Описание
        - Объединяет аргументы, разделённые пробелами, в команду.
        - Выполняет эту команду в текущем процессе, не создавая дочерний.
        - Работает аналогично eval-функциями из других языков программирования.
        - То есть eval это почти аналог: bash -c "bash code…"
        - Но с разницей, что дочерний процесс не создаётся.
        - Короче, eval это аналог source, но выполняет не скрипт из файла, а команду из аргументов.

      # Примеры

        • Выполнить указанный код в текущем процессе

          { myCode=$(</dev/stdin); } <<\EOF
          ... arbitrary bash code here ...
          EOF
          eval "$myCode"

        • Определить набор одинаковых функций с именами от f до n

          main() {
              local fun='() { echo "$FUNCNAME"; }' x

              for x in {f..n}; do
                  eval "${x}${fun}"
              done

              "$@"
          }
          main "$@"

    // exec //
    //------//
    // - Заменить текущий процесс указанной программой, выполняя её НЕ как новый процес.

      # Формат

        exec [-cl] [-a name] [command [arguments]] [redirection...]

      # Описание

        • Если command присутствует
          - Заменяет текуший процесс шелла новой программой command.
          - При этом никакого нового процесса не создаётся.

        • Если command отсутствует
          - Переадресации применяются к текущему шеллу, без выполнения command.

        • Return-статус
          - В случае ошибок переадресации, возвращает 1, иначе 0.
          - В случае ошибок exec:

            ▪ Неинтерактивный шелл отваливается, если execfail шелла не включена.
            ▪ В интерактивном шелле, exec возвращает ошибку.

      # Опции

        -a name   | передаёт name как 0-й аргумент программе
        -l        | добавляет префикс "-" 0-вому аргументу программы, также, как программа login
        -c        | выполняет программу с очищенной средой

      # Примеры

        • Обёртка вокруг программы

            myprog=/bin/ls
            echo "This is the wrapper script, it will exec $myprog"

            # do some vodoo here, probably change the arguments etc.
            # well, stuff a wrapper is there for

            exec "$myprog" "$@"

        • Открыть файл, как ввод для скрипта

            # open it
            exec 3< input.txt

            # for example: read one line from the file(-descriptor)
            read -u 3 LINE
            # or
            read LINE <&3

            # finally, close it
            exec 3<&-

        • Переадресовать stdout и stderr скрипта в файл

            exec >/var/adm/my.log 2>&1

            # script continues here...

    // exit //
    //------//
    // - Завершить текущий шелл или скрипт.

      # Формат

        exit [N]

      # Описание
        - N обозначает возвращаемый при выходе код родительскомупроцессу.
        - Если N не указана, возвращает код последней выполненной команды.
        - Ловушка при выходе выполняется перед выходом из шелла.
        - За исключением случая, когда команда exit не часть исполняющейся ловушки.

      # Примеры

        • Завершить работу текущего шелла

            exit

        • Завершить работу скрипта с кодом 0

            #/bin/bash
            # ... некий код ...
            exit 0

    // export //
    //--------//
    // - Экспортирует переменную/функцию NAME в среду окружения.

      # Формат

        export [-fn] [NAME[=VALUE] ...]
        export -p

      # Описание

        • Главное
          - Экспортирует переменную/функцию NAME в среду окружения.
          - Соответственно, всё это будет доступно и дочерним процессам.

        • Функция или переменная
          - Если опция -f указана, то функция.
          - Если не указана, то переменная.

        • Если указано VALUE
          - То при экспорте переменной назначается значение VALUE.

        • Return-статус

            0	      no error
            !=0	    invalid option
            !=0	    a given NAME is invalid

      # Опции

        -f    | экспортировать функцию, а не переменную
        -n    | отменить экспорт NAME
        -p    | показать список всех экспортированных переменных

      # Примеры

        • Вывести список всех экспортированных в среду переменных

          export
          export -p

        • Экспортировать переменную с указанным значением

          export CDPATH="/c/WebDev/projects"

    // getopts //
    //---------//
    // - Команда для парсинга аргументов командной строки.

      # Формат

        getopts optstring name [args]


      # Описание

        • Похожая команда getopt
          - Есть сабж без "s" на конце.
          - В отличие от от getopts, getopt не встроенная команда.

        • Преимущества getopts

          ▪ Нет нужды пропускать позиционные параметры через внешнюю программу.
          ▪ Getopts может установить переменные среды, полезные при парсинге.
          ▪ Нет нужды иметь дело с разными реализациями getopt и их багами.
          ▪ Getopts определена в POSIX.

        ▪ Недостаток getopts
          - Не может парсить GNU-style long options вроде --myoption.
          - А также XF86-style long options вроде -myoption.

      # Примеры
        - См. http://wiki.bash-hackers.org/howto/getopts_tutorial

    // hash //
    //------//
    // - Запоминает полные pathname команд с именами [name].

      # Формат

        hash [-r] [-p filename] [-dt] [name]

      # Опции

        -p  | не исктать в PATH, использовать name как путь к команде
        -r  | забыть все запомненные локации
        -d  | забыть все запомненные локации для каждой name
        -t  | выводить pathname для каждого name

      # Описание
        - В результате эти pathname не надо искать припоследующих вызовах.
        - Команды ищутся в PATH.
        - Любые ранее запомненные pathname отбрасываются.

      # Примеры

        • Показать, какие команды и сколько раз были использованы

            hash

    // pwd //
    //-----//
    // - Вывести абсолютный путь к текущему каталогу.

      # Формат

          pwd [-LP]

      # Опции

        -L    | выведенный путь может содержать символические ссылки
        -P    | выведенный путь не будет содержать символических ссылок

      # Примеры

        • Вывести абсолютный путь к текущему каталогу

            pwd

    // readonly //
    //----------//
    // - Пометить каждую name как readonly.

      # Формат

        readonly [-aAf] [-p] [name[=value]] …

      # Описание
        - Значения этих name не м.б. изменены низлежащим кодом.
        - По умолчанию, каждая name является переменной.

      # Опции

        -f    | каждое имя является шелл-функцией
        -a    | каждое имя является переменной с индексированным.массивом
        -A    | каждое имя является переменной с ассоц.массивом
        -Aa   | в этом случае A имеет приоритет
        -p    | если name отсутствуют, или -p указана, просто выводится список всех readonly

      # Примеры

        • Вывести список всех readonly

            readonly
            readonly -p

        • Сделать указанную переменную readonly

            readonly var="123"

    // return //
    //--------//
    // - Остановить шелл-функцию и вернуть [n] тому, кто её вызвал.

      # Формат

        return [n]

      # Описание
        - Если [n] не передано, возвращает статус последней команды.
        - Также return может остановить скрипт, вызванный через source.

    // shift //
    //-------//
    // - Сдвинуть все позиционные параметры влево на n пунктов.

      # Формат

          shift [n]

      # Описание
        - Было:     n+1 … $#
        - Стало:    $1 … $#-n
        - Удалены:  $# to $#-n+1
        - 0 <= n <= $#

    // test, [ //
    //---------//
    // - Выполнить условное выражение, вернуть true/false.

      # Формат

          test expr

      # Описание

        • Отдельные аргументы
          - Каждый оператор и операнд д.б. отдельными аргументами.

        • Нет опций
          - Не принимает никаких опций.
          - Не принимает аргумент --, означающий конец опций.

        • При использовании [
          - Последним аргументом должен быть ]

      # Операторы для комбинирования выражений

        • ! expr            | не
        • ( expr )          | приоритет
        • expr1 -a expr2    | и
        • expr1 -o expr2    | или

      # Примеры
        - Подробнее см.в главе: "А8. Bash scripting: условные операции"

    // times //
    //-------//
    // - Выводит затраченное скриптом и его детьми время.

      # Формат

          times


    // trap //
    //------//
    // - Назначить обработчик события.

      # Формат

          trap [-lp] [arg] [sigspec …]

      # Описание
        - Код arg выполняется при возбуждении событий sigspec.

      # Форматы sigspec

        • Имя сигнала с префиксом SIG. Например: SIGTERM.
        • Имя сигнала без префикса SIG. Например: TERM.
        • Номер сигнала, см.справку: trap -l

      # Комментарии по arg

        • Если отсутствует или "-", назначается обработчик по умолчанию.
        • Если пустая строка, то никакой обработки не происходит.

      # Опции

        -l    | Вывести все доступные события и их номера
        -p    | При вызове trap без аргументов, или с -p, выводит список назначенных обработчиков

      # Примеры
        - Подробнее см.здесь: http://wiki.bash-hackers.org/commands/builtin/trap

        • Вывести список назначенных обработчиков

            trap

        • Вывести все доступные события и их номера

            trap -l

        • Игнорировать событие SIGINT (терминал не будет закрываться с помощью ctrl-c)

            trap '' INT

    // umask //
    //-------//
    // - Назначить umask для создания файлов в шелле.

      # Формат

          umask [-p] [-S] [mode]

      # Описание

        • Если mode начинается с цифры
          - То он воспринимается, как 8-ричное значение.
          - По аналогии с chmod, например: 644, 777.

        • Если mode не начинается с цифры
          - Он воспринимается как маска в символьном виде.
          - По аналогии с chmod, например: rwxrwxrwx

      # Опции

        -S    | Тоже, что -p, но в символьном формате
        -p    | При вызове umask без аргументов, или с -p, выводит текущий umask шелла.

      # Примеры

        • Вывести текущий umask шелла в восьмеричном формате

            umask       | 0002
            umask -p    | umask 0002

        • Вывести текущий umask шелла в символьном формате

            umask -S    | u=rwx,g=rwx,o=rx

    // unset //
    //-------//
    // - Удалить переменные/функции name.

      # Формат

          unset [-fnv] [name]

      # Опции

        -v    | name это имена переменных среды
        -f    | name это имена функций (а по умолчанию, переменных)
        -n    | если name это пер-ая с атр-ом nameref, будет удалена name, а не то, куда она ссылается

      # Описание
        - Если опции -v, -f не применены, name это переменные.
        - А если пер-ые name не найдены, тогда ищутся функции name.
        - Переменные и функции readonly нельзя удалить.

    // alias //
    //-------//
    // - Назначить алиас name со значением value.

      # Формат

          alias [-p] [name[=value] …]

      # Опции

        -p    | без аргументов, или с -p, вывести все назначенные алиасы

      # Примеры

        • Вывести все назначенные алиасы

            alias
            alias -p

        • Назначить алиас

            alias ls="ls -a"

        • Удалить алиас

            unalias ls

    // bind //
    //------//
    // - Назначить гоячие клавиши.

      # Формат

          bind [-m keymap] [-lpsvPSVX]
          bind [-m keymap] [-q function] [-u function] [-r keyseq]
          bind [-m keymap] -f filename
          bind [-m keymap] -x keyseq:shell-command
          bind [-m keymap] keyseq:function-name
          bind readline-command

      # Опции

        -m keymap               | назначить горячие клавиши
        -l                      | вывести имена всех Readline-функций
        -p                      | вывести список существующих связок горячих клавиш с Readline-функциями
        -P                      | вывести список всех Readline-функций, и есть ли для них горячие клавиши, и какие
        -v                      | вывести имена Readline-переменных и значений в таком формате, чтобы м.б. использовать в Readline init файле
        -V                      | вывести имена Readline-переменных и значений
        -s                      | Display Readline key sequences bound to macros and the strings they output in such a way that they can be used as input or in a Readline initialization file.
        -S                      | Display Readline key sequences bound to macros and the strings they output.
        -f filename             | Read key bindings from filename.
        -q function             | Query about which keys invoke the named function.
        -u function             | Unbind all keys bound to the named function.
        -r keyseq               | Remove any current binding for keyseq.
        -x keyseq:shell-command | Cause shell-command to be executed whenever keyseq is entered.
        -X                      | List all key sequences bound to shell commands and the associated commands in a format that can be reused as input.

      # Описание
        - Позволяет назначить горячие клавиши.
        - Подробнее см.: http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

      # Примеры

        • Назначить на F6 команда "exit\n" (выход из терминала)
          - Здесь [17~ это код клавиши.
          - Посмотреть код любой клавиши в терминале можно так: alt-<клавиша>
          - Назначить:

            bind '"\e[17~":"exit\n"'

    // builtin //
    //---------//
    // - Выполнить встроенную команду шелла.

      # Формат

          builtin [shell-builtin [args]]

      # Описание
        - Ты определи функцию с именем, как у встроенной команды.
        - Как теперь вызвать последнюю? С помощью buildin.

    // caller //
    //--------//
    // - Возвращает контекст вызова любой активной подпрограммы.
    // - Например, шелл-функции или запущенного через source скрипта.

      # Формат

          caller [expr]

      # Описание

        • Без expr
          - Выводит номер строки и имя source файла текущей подпрограммы.

        • Expr - это положительный int
           - Выводит номер строки.
           - Выводит имя подпрограммы.
           - Выводит имя source файла текущей подпрограммы.
           - Соответствующие указанной позиции в текущем call stack.

    // command //
    //---------//
    // - Аналог buildin, только не для встроенных команд - запустить команду в обход функции.

      # Формат

          command [-pVv] command [arguments …]

      # Описание
        - Ты определи функцию с именем, как у команды.
        - Как теперь вызвать последнюю? С помощью command.
        - Ищет как обычные, так и встроенные команды.

      # Опции

        -p    | использовать значение PATH по умолчанию (а не реальное текущее)
        -v    | вывести инфу о найденной команде
        -V    | вывести более подробную инфу о найденной команде

      # Зачем нужна -p
        - В текущей среде PATH могла быть модифицирована.
        - Что может привести к тому, что command не найдёт стандартные утилиты.
        - Опция -p использует не тронутую PATH по умолчанию.


    // declare //
    //---------//
    // - Декларирует переменные и присваивает им атрибуты.

      # Формат

          declare [-aAfFgilnrtux] [-p] [name[=value] …]

      # Опции

        -p

          • Если name заданы
            - Выведет атрибуты и значения для каждого name.
            - Все опции кроме -f,-F игнорируются.

          • Если name не заданы
            - Выведет все атрибуты и значения.
            - Имеющие атрибуты, заданные доп.опциями.

        -F    | не отображать определения функций, только имена и атрибуты
        -g    | при декларировании в скрипте (в иных случаях игнорируется), создавать переменные в глобальном пр.имён

        -a    | Each name is an indexed array variable (see Arrays).
        -A    | Each name is an associative array variable (see Arrays).
        -f    | Use function names only.
        -i    | The variable is to be treated as an integer; arithmetic evaluation (see Shell Arithmetic) is performed when the variable is assigned a value.
        -l    | When the variable is assigned a value, all upper-case characters are converted to lower-case. The upper-case attribute is disabled.
        -n    | Give each name the nameref attribute, making it a name reference to another variable. That other variable is defined by the value of name.
                All references and assignments to name, except for changing the -n attribute itself, are performed on the variable referenced by name’s value. The -n attribute cannot be applied to array variables.
        -r    | Make names readonly. These names cannot then be assigned values by subsequent assignment statements or unset.
        -t    | Give each name the trace attribute. Traced functions inherit the DEBUG and RETURN traps from the calling shell. The trace attribute has no special meaning for variables.
        -u    | When the variable is assigned a value, all lower-case characters are converted to upper-case. The lower-case attribute is disabled.
        -x    | Mark each name for export to subsequent commands via the environment.

      # Описание

        • Использование + вместо - выключает атрибут
          - Кроме случая с +a, не позволяющего разрушить массив.
          - И кроме +r, не позволяющего удалить readonly-атрибут.

        • В функции declare делает каждое name локальным
          - Как и команда local.
          - Но только если не использовать опцию -g.

        • Если передано value, то name присваивается это value.

    // echo //
    //------//
    // - Выводит args, разделённые пробелом, заканчивающиеся newline'ом.

      # Формат

          echo [-neE] [arg …]

      # Опции

        -n    | trailing newline is suppressed
        -e    | включить интерпретацию символов после \
        -E    | отключить интерпретацию символов после \

      # Какие \ конструкции может интерпретировать echo

        \a          | alert (bell)
        \b          | backspace
        \c          | подавить последующие вывод
        \e, \E      | escape
        \f          | form feed
        \n          | new line
        \r          | carriage return
        \t          | horizontal tab
        \v          | vertical tab
        \\          | backslash
        \0nnn       | the eight-bit character whose value is the octal value nnn (zero to three octal digits)
        \xHH        | the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
        \uHHHH      | the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
        \UHHHHHHHH  | the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)


    // enable //
    //--------//
    // - Вкл / Выкл встроенные шелл-команды.

      # Формат

          enable [-a] [-dnps] [-f filename] [name …]

    // help //
    //------//
    // - Вывести help для встроенных команд.

      # Формат

          help [-dms] [pattern]

      # Опции

        -d    | отобразить короткое описание каждого pattern
        -m    | отобразить описание для каждого pattern в man-стиле
        -s    | отобразить только короткий usage synopsis для каждого pattern

      # Описание

        • Если pattern указан
          - Выводит хелп по указанной встроенной команде.

      # Примеры

    // let //
    //-----//
    // - Позволяет проводить арифметические операции.

      # Формат

          let expression [expression …]

      # Описание
        - Подробнее см.здесь: http://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic

      # Обратите внимание на пробел
        - Пробел разделяет выражения, как видно по формату.
        - Внутри одного выражения пробелы не допускаются.

      # Пример

        let x=2+2 y=2+3
        echo $x $y        // 4 5

    // local //
    //-------//
    // - Создать локальную переменную name со значением value.

      # Формат

          local [option] name[=value] …

      # Опции
        - Такие же, как у declare.

      # Описание
        - local можно использовать только внутри функции.
        - Создаваемая переменная будет видна только в функции, и её детях.

    // logout //
    //--------//
    // - Выйти из аккаунта.

      # Формат

          logout [n]

      # Описание
        - Возвращает статус n родителю шелла.

    // mapfile //
    //---------//
    // - Читает строки из стандартного ввода в индексированный массив.

      # Формат

        mapfile [-n count] [-O origin] [-s count] [-t] [-u fd]
            [-C callback] [-c quantum] [array]

      # Описание
        - Читает строки из стандартного ввода в индексированный массив.
        - Либо из файлового дескриптора, если опция -u применена.

      # Опции

        -n count    | Copy at most count lines. If count is 0, all lines are copied.
        -O origin   | Begin assigning to array at index origin. The default index is 0.
        -s count    | Discard the first count lines read.
        -t          | Remove a trailing newline from each line read.
        -u          | Read lines from file descriptor fd instead of the standard input.
        -C callback | Evaluate callback each time quantumP lines are read. The -c option specifies quantum.
        -c quantum  | Specify the number of lines read between each call to callback.

      # Примечания

        • Если C указано без c
          - То quantum == 5000.

        • mapfile очистить array перед его наполнением
          - Если явно не указан origin.

    // printf //
    //--------//
    // - Получить строку в заданном формате.

      # Формат

          printf [-v var] format [arguments]

      # Опции

        -v var    | записать вывод в переменную var, а не в stdout

      # Описание
        - Посмотреть спецификации можно так: man printf

    // read //
    //------//
    // - Считать 1 строку из stdin или файла, и записать слова из неё в name1,name2,...

      # Формат

          read [-ers] [-a aname] [-d delim] [-i text] [-n nchars]
              [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]

      # Опции

        -a aname    | The words are assigned to sequential indices of the array variable aname, starting at 0. All elements are removed from aname before the assignment. Other name arguments are ignored.
        -d delim    | The first character of delim is used to terminate the input line, rather than newline.
        -e          | Readline (see Command Line Editing) is used to obtain the line. Readline uses the current (or default, if line editing was not previously active) editing settings.
        -i text     | If Readline is being used to read the line, text is placed into the editing buffer before editing begins.
        -n nchars   | read returns after reading nchars characters rather than waiting for a complete line of input, but honor a delimiter if fewer than nchars characters are read before the delimiter.
        -p prompt   | read returns after reading exactly nchars characters rather than waiting for a complete line of input, unless EOF is encountered or read times out. Delimiter characters encountered in the input are not treated specially and do not cause read to return until nchars characters are read.
        -r          | Display prompt, without a trailing newline, before attempting to read any input. The prompt is displayed only if input is coming from a terminal.
        -s          | If this option is given, backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used as a line continuation.
        -t timeout  | Silent mode. If input is coming from a terminal, characters are not echoed.
        -u fd       | Cause read to time out and return failure if a complete line of input (or a specified number of characters) is not read within timeout seconds

    // readarray //
    //-----------//
    // - Считать строки из stdin в индексированный массив array.
    // - Изи из файлового дескриптора fd, заданного опцией -u.

      # Формат

          readarray [-n count] [-O origin] [-s count] [-t] [-u fd]
              [-C callback] [-c quantum] [array]

    // source //
    //--------//
    // - Синоним для встроенной команды . Bourne Shell.

      # Формат

          source filename


    // type //
    //------//
    // - Показать какой код реально скрывается за именем команды.

      # Формат

          type [-afptP] [name …]

      # Опции

        -t    | вывести тип: alias/function/builtin/file/keyword
        -p    | для типов 'file' вернуть имя файла на диске
        -P    | аналог -p, но работает не только для 'file'
        -a    | вернуть все места, где доступен исполняемый file (если -p не указана, алиасы и функции не учитываются)
        -f    | type не ищет шелл-функции

      # Примеры

        • Проверить, что скрывается за алиасом

          type ls     // ls --color=auto

        • Узнать тип скрывающейся за именем сущности
          - Выводом будет лишь 1 слово.
          - Одно из: alias/function/builtin/file/keyword
          - Узнать:

            type -t ls    // alias
            type -t type  // builtin
            type type     // type is a shell builtin

        • Показать все места, где определена команда grep
          - Вводим:

              type -a grep

          - Получаем:

              grep is aliased to `grep --color=auto'
              grep is /bin/grep

    // typeset //
    //---------//
    // - Это синоним declare, оставлен для совместимости с Korn shell.

      # Формат

          typeset [-afFgrxilnrtux] [-p] [name[=value] …]

      # Описание



      # Примеры



    // ulimit //
    //--------//
    // - Обеспечить контроль за ресурсами доступными процессам, запущенным шеллом.

      # Формат

          ulimit [-abcdefilmnpqrstuvxHST] [limit]

      # Опции

         -S   Change and report the soft limit associated with a resource.
         -H   Change and report the hard limit associated with a resource.

         -a   All current limits are reported.
         -c   The maximum size of core files created.
         -d   The maximum size of a process's data segment.
         -f   The maximum size of files created by the shell(default option)
         -l   The maximum size that can be locked into memory.
         -m   The maximum resident set size.
         -n   The maximum number of open file descriptors.
         -p   The pipe buffer size.
         -s   The maximum stack size.
         -t   The maximum amount of cpu time in seconds.
         -u   The maximum number of processes available to a single user.
         -v   The maximum amount of virtual memory available to the process.

      # Описание



      # Примеры



    // unalias //
    //---------//
    // - Удалить алиас name.

      # Формат

          unalias [-a] [name … ]



А3. Опции исполнения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Формат
    # Предисловие
    # Справочник по опциям исполнения

      -c                    | Read and execute commands from the first non-option argument after processing the options, then exit. Any remaining arguments are assigned to the positional parameters, starting with $0.
      -i                    | Force the shell to run interactively. Interactive shells are described in Interactive Shells.
      -l                    | Make this shell act as if it had been directly invoked by login
      -r                    | Make the shell a restricted shell (see The Restricted Shell).
      -s                    | If this option is present, or if no arguments remain after option processing, then commands are read from the standard input.
                              This option allows the positional parameters to be set when invoking an interactive shell.
      -D                    | A list of all double-quoted strings preceded by ‘$’ is printed on the standard output.
      -O, +O                | shopt_option is one of the shell options accepted by the shopt builtin (see The Shopt Builtin)
      --                    | A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments

      --debugger            | Arrange for the debugger profile to be executed before the shell starts. Turns on extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin).
      --dump-po-strings     | A list of all double-quoted strings preceded by ‘$’ is printed on the standard output in the GNU gettext PO (portable object) file format. Equivalent to -D except for the output format.
      --dump-strings        | Equivalent to -D.
      --help                | Display a usage message on standard output and exit successfully.
      --init-file filename  | Execute commands from filename (instead of ~/.bashrc) in an interactive shell.
      --rcfile filename     | Equivalent to --init-file.
      --login               | Equivalent to -l.
      --noediting           | Do not use the GNU Readline library (see Command Line Editing) to read command lines when the shell is interactive.
      --noprofile           | Don’t load the system-wide startup file /etc/profile or any of the personal initialization files ~/.bash_profile, ~/.bash_login, or ~/.profile when Bash is invoked as a login shell.
      --norc                | Don’t read the ~/.bashrc initialization file in an interactive shell. This is on by default if the shell is invoked as sh.
      --posix               | Change the behavior of Bash where the default operation differs from the POSIX standard to match the standard. This is intended to make Bash behave as a strict superset of that standard. See Bash POSIX Mode, for a description of the Bash POSIX mode.
      --restricted          | Make the shell a restricted shell (see The Restricted Shell).
      --verbose             | Equivalent to -v. Print shell input lines as they’re read.
      --version             | Show version information for this instance of Bash on the standard output and exit successfully.

  --------------------------------------

  > Ссылки

    # Оф.справочник GNU по опциям исполнения
        https://www.gnu.org/software/bash/manual/html_node/Invoking-Bash.html

  > Введение
    - Эта глава является справочником по опциям исполнения Bash.

  > Формат

      bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o option] [-O shopt_option] [argument …]
      bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o option] [-O shopt_option] -c string [argument …]
      bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o option] [-O shopt_option] [argument …]

  > Предисловие
    - Назначить опцию для текущего шелла можно командой set.

  > Справочник по встроенным командам Bash
    - См.: man bash.


А4. Bash scripting: основы скриптинга и отладки

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Где писать скрипты, как выбирать имя

      - Писать bash-скрипты можно в nano
      - Включить подсветку синтаксиса в nano
      - При выборе имени проверять свободно ли
      - Добавь каталог со скриптами в PATH

    # Как запускать скрипты

      - Если каталог и . не в PATH
      - Если каталог или . в PATH
      - Запуск скрипта в текущем процессе
      - Запуск скрипта в подпроцессе
      - Запуск скрипта указанным шеллом

    # Выбор шелла и комменты

      - Любой скрипт начинается с выбора шелла
      - Как писать комменты в скрипте

    # Дебаггинг скриптов

      - Запуск целого скрипта в debug-режиме опцией -x
      - Отладка лишь части внутри скрипта с помощью set -x, set +x
      - Старая добрая отладка с помощью echo

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по сабжу
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_02.html

  > Введение
    - В этой главе рассмотрим основы создания и запуска bash-скрипта.

  > Где писать скрипты, как выбирать имя

    # Писать bash-скрипты можно в nano
      - Вообще их писать можно в любом текстовом редакторе.
      - В общей папке можно, например, использовать notepad в Windows.
      - Но удобнее, всё же, писать прямо в терминале в nano.

    # Включить подсветку синтаксиса в nano
      - Редактор nano поддерживает подсветку синтаксисов для ряда языков.
      - В том числе и для bash-скриптов.
      - Посмотреть весь список поддерживаемых языков можно так:

          ls /usr/share/nano/

      - Включить любую из этих подсветок можно в конфиге nano: ~/.nanorc
      - Включим подсветку для bash:

          touch ~/.nanorc
          sudo nano ~/.nanorc

            include "/usr/share/nano/sh.nanorc"

    # При выборе имени проверять свободно ли

      • Добавляй .sh в конец своих скриптов
        - В принципе, это не обязательно.
        - Но это уменьшает вероятность конфликтов с существующими командами.

      • Проверяй, не существует ли уже такая команда
        - С помощью which / whereis / locate .
        - Например:

            which test    // ищет путь к команде
            whereis test  // ищет бинарник, исходник и справку для команды
            locate test   // ищет файлы по имени

    # Добавь каталог со скриптами в PATH
      - В Linux это делается очень просто.
      - Допустим, каталог со скриптами: "/c/WebDev/projects/bash_sandbox"
      - Добавим его в конец PATH на постоянной основе:

        export PATH="$PATH:/c/WebDev/projects/bash_sandbox"

      - Теперь скрипты из этого каталога будут доступны где угодно.

  > Как запускать скрипты

    # Если каталог и . не в PATH
      - Если каталог со скриптом и каталог . не добавлены в PATH.
      - Тогда запустить скрипт в этом каталоге можно так:

          ./script.sh

    # Если каталог или . в PATH
      - Если каталог со скриптом или каталог . добавлены в PATH.
      - Хотя добавлять в PATH . строго не рекомендуется.
      - Тогда запускать скрипт в этом каталоге можно так:

          script.sh

    # Запуск скрипта в текущем процессе
      - Иногда требуется запустить скрипт в текущем процессе.
      - Например, чтобы в этом скрипте назначить алиасы.
      - Или поназначать переменные именно для этой среды.
      - Это можно сделать со помощью встроенной команды source.
      - Команда . (точка) является синонимом команды source.
      - Примеры:

          source script.sh
          . script.sh

    # Запуск скрипта в подпроцессе
      - Обычно скрипт запускается в подпроцессе.
      - Запускается механизм Fork-and-Exec.
      - Создаётся подпроцесс с точной копией окружения родителя.
      - В этом подпроцессе-шелле выполняется указанный скрипт.
      - Потом, этот подпроцесс вместе со всей средой удаляется.
      - Минус: скрипт никак не может повлиять на среду родителя.
      - Например, установить для неё алиасы.
      - Вот, как можно запустить скрипт в подпроцессе:

          ./script    // если каталог со скриптом и . не в path
          script      // если каталог со скриптом или . в path

    # Запуск скрипта указанным шеллом
      - Редко может понадобиться указать, каким шеллом выполнять скрипт.
      - Примеры:

          rbash script.sh
          sh script.sh
          bash script.sh

  > Выбор шелла и комменты

    # Любой скрипт начинается с выбора шелла
      - Выбрать шелл можно в первой не пустой строке скрипта.
      - Она должна содержать конструкцию вида: #!<путь к шеллу>.
      - Примеры:

          #!/bin/bash
          #!/bin/sh

      - В Ubuntu по умолчанию используется /bin/sh
      - Поэтому если явно не указать #!/bin/bash, будут проблемы.

    # Как писать комменты в скрипте
      - Используя #
      - Коммент может быть как всей строкой, так и в конце строки.
      - Примеры:

          # строка-коммент
          echo "123"    # коммент в конце строки

  > Дебаггинг скриптов

    # Запуск целого скрипта в debug-режиме опцией -x
      - Можно запустить в debug-режиме целый скрипт.
      - Он будет запущен в подпроцессе.
      - Тогда в stdout будут поступать отладочные данные.
      - Сделать это можно опцией -x
      - Пример:

          bash -x script.sh

    # Отладка лишь части внутри скрипта с помощью set -x, set +x
      - Можно запустить в debug-режиме лишь часть скрипта.
      - Которая между командами set -x и set +x.
      - Применять это внутри скрипта можно сколько угодно раз.
      - Пример (код скрипта):

          .. код не для отладки ..

          set -x
          .. код для отладки ..
          set +x

          .. код не для отладки ..

      - Ещё можно применять set -o и set +o.
      - Это будет выводить ввод из stdin так, как он считывается.

    # Старая добрая отладка с помощью echo
      - Выводим содержимое переменных с помощью echo.
      - Разбрасываем: echo "1", echo "2" по коду.
      - Ищем место, где код прервал своё выполнение.
      - И так далее.


А5. Bash scripting: среда [написать по запросу]

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


А6. Bash scripting: регулярные выражения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Общая информация о RegExp в bash

      - Что такое RegExp
      - Конкатенация RegExp
      - Объединение RegExp с помощью оператора | (infix)
      - Про приоритетность
      - Экранирование метасимволов

    # Матасимволы RegExp

      .	        | Matches any single character.
      ?	        | The preceding item is optional and will be matched, at most, once.
      *	        | The preceding item will be matched zero or more times.
      +	        | The preceding item will be matched one or more times.
      {N}	      | The preceding item is matched exactly N times.
      {N,}	    | The preceding item is matched N or more times.
      {N,M}	    | The preceding item is matched at least N times, but not more than M times.
      -	        | represents the range if it's not first or last in a list or the ending point of a range in a list.
      ^	        | Matches the empty string at the beginning of a line; also represents the characters not in the range of a list.
      $	        | Matches the empty string at the end of a line.
      \b	      | Matches the empty string at the edge of a word.
      \B	      | Matches the empty string provided it's not at the edge of a word.
      \<	      | Match the empty string at the beginning of word.
      \>	      | Match the empty string at the end of word.

    # Использование RegExp с командой grep

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по сабжу
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html

  > Введение
    - Эта глава про использование регулярных выражений в bash.
    - Там применяются регулярные выражения в POSIX-стиле.
    - Почти такие, же как в PHP, только в последнем в PCRE-стиле.
    - Отличия здесь: http://php.net/manual/ru/reference.pcre.pattern.posix.php
    - Регулярки можно применять прямо в командной строке.

  > Общая информация о RegExp в bash

    # Что такое RegExp
      - Паттерн для описания набора строк.
      - Конструируются по аналогии с арифметическими выражениями.
      - Используются различные операторы для комбинации меньших выражений.

    # Конкатенация RegExp
      - Два регулярных выражения могут быть конкатенированы.
      - Тогда матчинг будет происходить уже с этим результатом.

    # Объединение RegExp с помощью оператора | (infix)
      - Два регулярных выражения м.б. объединены оператором |
      - Результирующее RegExp матчит любую строку, которую
        матчит любая из объединённых частей.

    # Про приоритетность
      - Repetition takes precedence over concatenation, which in turn takes precedence over alternation.
      - A whole subexpression may be enclosed in parentheses to override these precedence rules.

    # Экранирование метасимволов
      - Метасимволы можно экранировать бэкслэшем \

  > Матасимволы RegExp
    - См.оглавление.

  > Использование RegExp с командой grep

    # Что делает команда grep
      - Применяет к файлу или входящему потоку указанное RegExp.
      - Ищет строки, содержащие соотв-щую RegExp строку.
      - Выводит эти найденные строки в stdout (по умолчанию).
      - Подробности см. в: man grep.

    # Примеры

      • Вывести все работающие процессы, содержащие node в имени

          ps aux | grep node

      • Вывести все строки из /etc/passwd, содержащие root

          grep root /etc/passwd
          grep -n root /etc/passwd                      // указывать ещё в начале номер строки

      • Вывести все строки из /etc/passwd, НЕ содержащие root

          grep -v bash /etc/passwd | grep -v nologin    // инвертировать RegExp

      • Вывести кол-во строк (цифру), содержащих root

          grep -c root /etc/passwd

      • Провести регистро-независимый поиск

          grep -i root /etc/passwd


А7. Bash scripting: потоковый редактор GNU sed

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Вместо предисловия

      - Что такое sed?

        ▪ Определение sed
        ▪ Сохранение результатов
        ▪ Редактор не изменяет оригинальный файл
        ▪ Работает на основе RegExp
        ▪ Указать действие можно командой редактирования

      - Часто используемые команды редактирования sed

        ▪ a\          | Append text below current line.
        ▪ c\          | Change text in the current line with new text.
        ▪ d           | Delete text.
        ▪ i\          | Insert text above current line.
        ▪ p           | Print text.
        ▪ r           | Read a file.
        ▪ s           | Search and replace text.
        ▪ w           | Write to a file.

      - Часто используемые опциии sed

        ▪ -e SCRIPT   | Add the commands in SCRIPT to the set of commands to be run while processing the input.
        ▪ -f          | Add the commands contained in the file SCRIPT-FILE to the set of commands to be run while processing the input.
        ▪ -n          | Silent mode.
        ▪ -V          | Print version information and exit.

    # Примеры применения

      - Вывести строки, содержащие паттерн
      - Удалить строки, содержащие паттерн
      - Обработка диапазонов сотрок
      - Найти и заменить

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по сабжу
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html

  > Введение
    - В этой главе рассмотрен потоковый редактор GNU sed.

  > Вместо предисловия

    # Что такое sed?

      • Определение sed

          GNU sed - потоковый редактор (Stream EDitor), позволяющий
          производить базовые трансформации текста, считываемого
          из файла или из входного потока через пайп.

      • Сохранение результатов
        - Изменённые результаты отправляются прямиком в stdout.
        - Сохранить результаты в файл, можно переадресовав вывод в файл.
        - Например:

            sed 's/erors/errors/g' file > file

      • Редактор не изменяет оригинальный файл
        - Сабж.

      • Работает на основе RegExp
        - Редактор может искать подстроки, используя RegExp.
        - И как-либо их изменять, удалять.

      • Указать действие можно командой редактирования
        - Команды редактирования подобны тем, что применяются в vi.
        - Список этих команд смотри ниже.

    # Часто используемые команды редактирования sed

      • a\    | Append text below current line.
      • c\    | Change text in the current line with new text.
      • d     | Delete text.
      • i\    | Insert text above current line.
      • p     | Print text.
      • r     | Read a file.
      • s     | Search and replace text.
      • w     | Write to a file.

    # Часто используемые опциии sed

      • -e SCRIPT   | Add the commands in SCRIPT to the set of commands to be run while processing the input.
      • -f          | Add the commands contained in the file SCRIPT-FILE to the set of commands to be run while processing the input.
      • -n          | Silent mode.
      • -V          | Print version information and exit.

  > Примеры применения

    # Вывести строки, содержащие паттерн

      • Вывести все строки из файла file, содержащие "erors"

          sed -n '/erors/p' file

      • Вывести все строки из файла file, которые матчатся с паттерном

          sed -n '/^This.*errors.$/p' file

    # Удалить строки, содержащие паттерн

      • Вывести все строки из файла file, не содержащие "erors"

          sed '/erors/d' file

    # Обработка диапазонов сотрок

      • Вывести все строки из файла file, кроме строк со 2-й по 4-ю

          sed '2,4d' file

      • Вывести все строки из файла file, начиная с 3-й строки

          sed '3,$d' file

      • Вывести все строки, начиная от строки, которая включет
        паттерн №1, и до строки, которая включает паттерн №2

          sed -n '/a text/,/This/p' file

    # Найти и заменить

      • Вывести все строки, заменив в них "erors" на "errors"
        - Опция g говорит о том, что замену надо делать не 1, а везде.

          sed 's/erors/errors/g' file

      • Вставить подстроку "> " в начало каждой строки в файле

          sed 's/^/> /' file

      • Вставить подстроку "EOL" в конец каждой строки в файле

          sed 's/$/EOL/' file

      • Применить сразу несколько find-and-replace

          sed -e 's/erors/errors/g' -e 's/last/final/g' file

А8. Bash scripting: условные операции

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Основы использования if

      - Самый короткий формат: if .. then .. fi
      - Выражения для подстановки в if

        ▪ [ -a FILE ]	                | True if FILE exists.
        ▪ [ -b FILE ]	                | True if FILE exists and is a block-special file.
        ▪ [ -c FILE ]	                | True if FILE exists and is a character-special file.
        ▪ [ -d FILE ]	                | True if FILE exists and is a directory.
        ▪ [ -e FILE ]	                | True if FILE exists.
        ▪ [ -f FILE ]	                | True if FILE exists and is a regular file.
        ▪ [ -g FILE ]	                | True if FILE exists and its SGID bit is set.
        ▪ [ -h FILE ]	                | True if FILE exists and is a symbolic link.
        ▪ [ -k FILE ]	                | True if FILE exists and its sticky bit is set.
        ▪ [ -p FILE ]	                | True if FILE exists and is a named pipe (FIFO).
        ▪ [ -r FILE ]	                | True if FILE exists and is readable.
        ▪ [ -s FILE ]	                | True if FILE exists and has a size greater than zero.
        ▪ [ -t FD ]	                  | True if file descriptor FD is open and refers to a terminal.
        ▪ [ -u FILE ]	                | True if FILE exists and its SUID (set user ID) bit is set.
        ▪ [ -w FILE ]	                | True if FILE exists and is writable.
        ▪ [ -x FILE ]	                | True if FILE exists and is executable.
        ▪ [ -O FILE ]	                | True if FILE exists and is owned by the effective user ID.
        ▪ [ -G FILE ]	                | True if FILE exists and is owned by the effective group ID.
        ▪ [ -L FILE ]	                | True if FILE exists and is a symbolic link.
        ▪ [ -N FILE ]	                | True if FILE exists and has been modified since it was last read.
        ▪ [ -S FILE ]	                | True if FILE exists and is a socket.
        ▪ [ FILE1 -nt FILE2 ]	        | True if FILE1 has been changed more recently than FILE2, or if FILE1 exists and FILE2 does not.
        ▪ [ FILE1 -ot FILE2 ]	        | True if FILE1 is older than FILE2, or is FILE2 exists and FILE1 does not.
        ▪ [ FILE1 -ef FILE2 ]	        | True if FILE1 and FILE2 refer to the same device and inode numbers.
        ▪ [ -o OPTIONNAME ]	          | True if shell option "OPTIONNAME" is enabled.
        ▪ [ -z STRING ]	              | True of the length if "STRING" is zero.
        ▪ [ -n STRING ] or [ STRING ]	| True if the length of "STRING" is non-zero.
        ▪ [ STRING1 == STRING2 ]	    | True if the strings are equal. "=" may be used instead of "==" for strict POSIX compliance.
        ▪ [ STRING1 != STRING2 ]	    | True if the strings are not equal.
        ▪ [ STRING1 < STRING2 ]	      | True if "STRING1" sorts before "STRING2" lexicographically in the current locale.
        ▪ [ STRING1 > STRING2 ]	      | True if "STRING1" sorts after "STRING2" lexicographically in the current locale.
        ▪ [ ARG1 OP ARG2 ]	          | "OP" is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if "ARG1" is equal to,

      - Комбинирование выражений внутри []

        ▪ [ ! EXPR ]          | True if EXPR is false.
        ▪ [ ( EXPR ) ]        | Returns the value of EXPR. This may be used to override the normal precedence of operators.
        ▪ [ EXPR1 -a EXPR2 ]  | True if both EXPR1 and EXPR2 are true.
        ▪ [ EXPR1 -o EXPR2 ]  | True if either EXPR1 or EXPR2 is true.

      - Команды после then

        ▪ Команда / программа / скрипт / шелл стейтмент
        ▪ then и fi должны быть отдельными выражениями

      - Простые примеры применения if .. then .. fi

        ▪ Проверить существование файла
        ▪ Проверить наличие опции у шелла
        ▪ Проверить exit-статус предыдущей выполненной команды
        ▪ Проверить наличие $USER в /etc/passwd
        ▪ Провести сравнение чисел
        ▪ Провести сравнение строк

    # Отличия [ от [[
    # Формат: if .. then .. else .. fi

      • Формат: if .. then .. else .. fi
      • Сравнение значения с glob-паттерном
      • Проверить наличие $USER в /etc/passwd
      • Проверка позиционных аргументов
      • Проверка, содержащая переменные
      • Проверка кол-ва позиционных аргументов
      • Проверка существования файла

    # Формат: if .. then .. elif .. else  ..fi

      • Формат: if .. then .. elif .. else  ..fi
      • Проверка места на диске

    # Вложенные if

      • Внутри if-выражений м.б. другие if-выражения, и т.д.
      • Пример вложенных if (проверка на високосный год)

    # Boolean-операторы && и ||
    # Использование exit в if-операциях
    # Использование case

      • Формат case-выражений
      • Пример case-выражений

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по сабжу
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_07.html

  > Введение
    - Эта глава описывает условные операции в bash.

  > Основы использования if

    # Самый короткий формат: if .. then .. fi

        if TEST-COMMANDS; then CONSEQUENT-COMMANDS; fi

    # Выражения для подстановки в if
      - Это так называемые "Primary expressions".
      - Это шаблоны для подстановки в качестве if-условия.
      - См.их список в оглавлении.

    # Комбинирование выражений внутри []
      - Выраженяи в if можно комбинировать несколькими способами.
      - Эти способы перечислены в оглавлении.
      - Подробную информацию об этом можно получить в man:

          man [
          man test    // test это синоним [

    # Команды после then

      • Команда / программа / скрипт / шелл-выражение
        - После then может быть любое из перечисленных.
        - Валидная UNIX-команда, исполняемая программа.
        - Может быть шелл-скрипт или шелл-выражение (кроме fi).

      • then и fi должны быть отдельными выражениями
        - В скрипте они должны быть на разных строках (fi под then).
        - В терминале они должны быть отделены точкой с запятой ;

    # Простые примеры применения if .. then .. fi

      • Проверить существование файла

          #!/bin/bash

          echo "This scripts checks the existence of the messages file."
          echo "Checking..."
          if [ -f /var/log/messages ]
            then
              echo "/var/log/messages exists."
          fi
          echo
          echo "...done."

      • Проверить наличие опции у шелла

        ▪ В скрипте

            #!/bin/bash
            if [ -o noclobber ]
              then
              echo "Your files are protected against accidental overwriting using redirection."
            fi

        ▪ Тоже самое в терминале

            if [ -o noclobber ] ; then echo ; echo "your files are protected against overwriting." ; echo ; fi

      • Проверить exit-статус предыдущей выполненной команды

          if [ $? -eq 0 ]
            then
            echo echo 'That was a good job!'
          fi

      • Проверить наличие $USER в /etc/passwd

        ▪ Вариант №1

            if ! grep $USER /etc/passwd
              then
              echo "your user account is not managed locally"
            fi

        ▪ Вариант №2

          grep $USER /etc/passwd
          if [ $? -ne 0 ]
            then
            echo "your user account is not managed locally"
          fi

      • Провести сравнение чисел

          num=10
          if [ "$num" -gt "150" ]
            then
            then echo ; echo "you've worked hard enough for today."
          fi

      • Провести сравнение строк

          if [ "$(whoami)" != 'root' ]; then
            echo "You have no permission to run $0 as non-root user."
            exit 1;
          fi

  > Отличия [ от [[

    • [[ предотвращает зазбитие значений переменных на слова
      - К примеру, есть такая переменная: VAR="var with spaces"
      - Использовать такую переменную в [ надо так: "$VAR".
      - А вот в [[ можно без кавычек: $VAR

    • [[ предотвращает расширение литеральных строк до pathname
      - Литералы с wildcatds не пытаются превратиться в filenames.

    • == и != работают в [[ следующим образом
      - Сравнивают значение слева с glob-паттерном справа.
      - Например: [[ "value" == val* ]]

  > Формат: if .. then .. else .. fi

    # Формат: if .. then .. else .. fi

        if TEST-COMMANDS; then CONSEQUENT-COMMANDS; else CONSEQUENT-COMMANDS; fi

    # Сравнение значения с glob-паттерном

        gender="male"
        if [[ "$gender" == "f*" ]]
          then echo "Pleasure to meet you, Madame."
          else echo "How come the lady hasn't got a drink yet?"
        fi

    # Проверить наличие $USER в /etc/passwd

        if ! grep ^$USER /etc/passwd 1> /dev/null
          then echo "your user account is not managed locally"
          else echo "your account is managed from the local /etc/passwd file"
        fi

    # Проверка позиционных аргументов

        if [ "$1" == fish ]; then
          echo "Hmmmm fish...."
        else
          echo "Tux don't like that"
        fi

    # Проверка, содержащая переменные

        weight="$1"
        height="$2"
        idealweight=$[$height - 110]

        if [ $weight -le $idealweight ] ; then
          echo "You should eat a bit more fat."
        else
          echo "You should eat a bit more fruit."
        fi

    # Проверка кол-ва позиционных аргументов

        if [ ! $# == 2 ]; then
          echo "Usage: $0 weight_in_kilos length_in_centimeters"
          exit
        fi

    # Проверка существования файла

        FILENAME="$1"

        echo "Properties for $FILENAME:"

        if [ -f $FILENAME ]; then
          echo "Size is $(ls -lh $FILENAME | awk '{ print $5 }')"
          echo "Type is $(file $FILENAME | cut -d":" -f2 -)"
          echo "Inode number is $(ls -i $FILENAME | cut -d" " -f1 -)"
          echo "$(df -h $FILENAME | grep -v Mounted | awk '{ print "On",$1", \
        which is mounted as the",$6,"partition."}')"
        else
          echo "File does not exist."
        fi

  > Формат: if .. then .. elif .. else  ..fi

    # Формат: if .. then .. elif .. else  ..fi

        if TEST-COMMANDS; then CONSEQUENT-COMMANDS; elif TEST-COMMANDS; than CONSEQUENT-COMMANDS; else CONSEQUENT-COMMANDS; fi

    # Проверка места на диске

        space=`df -h | awk '{print $5}' | grep % | grep -v Use | sort -n | tail -1 | cut -d "%" -f1 -`
        alertvalue="80"

        if [ "$space" -ge "$alertvalue" ]; then
          echo "At least one of my disks is nearly full!" | mail -s "daily diskcheck" root
        else
          echo "Disk space normal" | mail -s "daily diskcheck" root
        fi

  > Вложенные if

    # Внутри if-выражений м.б. другие if-выражения, и т.д.
      - Кол-во уровней вложенности не ограничено.

    # Пример вложенных if (проверка на високосный год)

        year=`date +%Y`

        if [ $[$year % 400] -eq "0" ]; then
          echo "This is a leap year.  February has 29 days."
        elif [ $[$year % 4] -eq 0 ]; then
                if [ $[$year % 100] -ne 0 ]; then
                  echo "This is a leap year, February has 29 days."
                else
                  echo "This is not a leap year.  February has 28 days."
                fi
        else
          echo "This is not a leap year.  February has 28 days."
        fi

  > Boolean-операторы && и ||
    - В if-выражениях можно использовать булевы операторы.

  > Использование exit в if-операциях

    # Про команду exit, и статус-код в $?
      - Эта команда завершает выполнение всего скрипта.
      - Её можно передать аргумент, статус завершения.
      - Этот аргумент передаётся родителю в переменную $?.
      - Статус 0 означает успех, любое другое - неудачу.
      - Если аргумент не передать, возвращаетку значение $?.

    # Пример совместного использования exit и if

      penguin.sh
      ---------------------------------
        if [ "$menu" == "fish" ]; then
          if [ "$animal" == "penguin" ]; then
            echo "Hmmmmmm fish... Tux happy!"
          elif [ "$animal" == "dolphin" ]; then
            echo "Pweetpeettreetppeterdepweet!"
          else
            echo "*prrrrrrrt*"
          fi
        else
          if [ "$animal" == "penguin" ]; then
            echo "Tux don't like that.  Tux wants fish!"
            exit 1
          elif [ "$animal" == "dolphin" ]; then
            echo "Pweepwishpeeterdepweet!"
            exit 2
          else
            echo "Will you read this sign?!"
            exit 3
          fi
        fi

      feed.sh
      ---------------------------------
        export menu="$1"
        export animal="$2"

        feed="/nethome/anny/testdir/penguin.sh"

        $feed $menu $animal

        case $? in

        1)
          echo "Guard: You'd better give'm a fish, less they get violent..."
          ;;
        2)
          echo "Guard: It's because of people like you that they are leaving earth all the time..."
          ;;
        3)
          echo "Guard: Buy the food that the Zoo provides for the animals, you ***, how
        do you think we survive?"
          ;;
        *)
          echo "Guard: Don't forget the guide!"
          ;;
        esac

  > Использование case

    # Формат case-выражений

        case EXP in

          case1)
            CMDs
            ;;

          case2)
            CMDs
            ;;

          ...

        esac

    # Пример case-выражений

        case "$1" in
                start)
                    start
                    ;;

                stop)
                    stop
                    ;;

                status)
                    status anacron
                    ;;
                restart)
                    stop
                    start
                    ;;
                condrestart)
                    if test "x`pidof anacron`" != x; then
                        stop
                        start
                    fi
                    ;;

                *)
                    echo $"Usage: $0 {start|stop|restart|condrestart|status}"
                    exit 1

        esac

А9. Bash scripting: интерактивные скрипты

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Вместо предисловия

      • Преимущества не интерактивных скриптов
      • Преимущества интерактивных скриптов
      • Интерактивные скрипты и CLI-приложения
      • Комментирование в интерактивных скриптах (echo, printf)
      • При запросах инфы, лучше сообщить больше

    # Обработка пользовательского ввода

      • Использование встроенной команды read

        ▪ Формат команды read
        ▪ Как работает команда read

          ▪ Команда read, как двойник echo
          ▪ Команда read считывает 1-ну строку
          ▪ name1 = 1-е слово, name2 = 2-е слово, ..., nameN = n-е слово
          ▪ Если слов передано меньше, чем определено аргументов
          ▪ С помощью бэкслэша \ можно экранировать спец.символы
          ▪ Если не задать аргументов name, строка считается в REPLY

        ▪ Опции команды read

          ▪ -a name     | The words are assigned to sequential indexes of the array variable ANAME, starting at 0. All elements are removed from ANAME before the assignment. Other NAME arguments are ignored.
          ▪ -d delim    | The first character of DELIM is used to terminate the input line, rather than newline.
          ▪ -e          | readline is used to obtain the line.
          ▪ -n nchars   | read returns after reading NCHARS characters rather than waiting for a complete line of input.
          ▪ -p prompt   | Display PROMPT, without a trailing newline, before attempting to read any input. The prompt is displayed only if input is coming from a terminal.
          ▪ -r          | If this option is given, backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used as a line continuation.
          ▪ -s          | Silent mode. If input is coming from a terminal, characters are not echoed.
          ▪ -t timeout  | Cause read to time out and return failure if a complete line of input is not read within TIMEOUT seconds. This option has no effect if read is not reading input from the terminal or from a pipe.
          ▪ -u FD       | Read input from file descriptor FD.

        ▪ Несколько простых примеров

          ▪ Запросить год и сообщить, високосный ли он
          ▪ Имитация скрипта регистрации
          ▪ Применение heredoc

        ▪

      •
      •
      •
      •

  --------------------------------------

  > Ссылки

    # Ссылка на главу оф.документации по интерактивным скриптам
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_08.html

  > Введение
    - Эта глава раскрывает тему интерактивных скриптов.
    - Оные являются ключём к написанию CLI-приложений на bash.

  > Вместо предисловия

    # Преимущества не интерактивных скриптов

      • Скрипт каждый раз отрабатывает одинаково предсказуемо.
      • Скрипт выполняется в фоновом режиме.

    # Преимущества интерактивных скриптов

      • Интерактивные скрипты более гибкие.
      • Пользователь может кастомизировать поведение скрипта.
      • Скрипт может докладывать пользователю в процессе выполнения.

    # Интерактивные скрипты и CLI-приложения
      - Интерактивные скрипты являются ключём к созданию CLI-приложений.
      - CLI-приложение представляет единую точку входя для широкого функционала.
      - Этот функционал может включать в себя набор различных инструментов.
      - Зная одну лишь команду-точку-входа, пользователь может это использовать.

    # Комментирование в интерактивных скриптах (echo, printf)
      - Пусть скрипт комментирует то, что он делает.
      - То есть выводит информацию об этом через echo, printf.
      - Лучше больше комментариев, чем меньше.

    # При запросах инфы, лучше сообщить больше
      - Интерактивные скрипты могут запрашивать у пользователя ввод.
      - Лучше при этом сообщить больше инфы о том, что требуется, чем меньше.
      - Иначе пользователь может не понять, чего от него хотят.

  > Обработка пользовательского ввода

    # Использование встроенной команды read

      • Формат команды read

          read [options] NAME1 NAME2 ... NAMEN

      • Как работает команда read

        ▪ Команда read, как двойник echo
          - Команда echo выводит в stdout переданные name1, name2, ...
          - Команда read читает в stdin переданные name1, name2, ...

        ▪ Команда read считывает 1-ну строку
          - Считывается 1-на строка из stdin.
          - Либо из файлового дескриптора из опции -u.

        ▪ name1 = 1-е слово, name2 = 2-е слово, ..., nameN = n-е слово
          - Считанная строка разбивается на слова.
          - Описанным выше образом заполняются аргументы.

        ▪ Если слов передано меньше, чем определено аргументов
          - Лишние аргументы получают пустые значения.

        ▪ С помощью бэкслэша \ можно экранировать спец.символы
          - Сабж.

        ▪ Если не задать аргументов name, строка считается в REPLY
          - В переменную REPLY.

      • Опции команды read
        - См.оглавление.
        - Или man: man read

      • Несколько простых примеров

        ▪ Запросить год и сообщить, високосный ли он

            #!/bin/bash
            # This script will test if you have given a leap year or not.

            echo "Type the year that you want to check (4 digits), followed by [ENTER]:"

            read year

            if (( ("$year" % 400) == "0" )) || (( ("$year" % 4 == "0") && ("$year" % 100 !=
            "0") )); then
              echo "$year is a leap year."
            else
              echo "This is not a leap year."
            fi

        ▪ Имитация скрипта регистрации

            #!/bin/bash

            # This is a program that keeps your address book up to date.

            friends="/var/tmp/michel/friends"

            echo "Hello, "$USER".  This script will register you in Michel's friends database."

            echo -n "Enter your name and press [ENTER]: "
            read name
            echo -n "Enter your gender and press [ENTER]: "
            read -n 1 gender
            echo

            grep -i "$name" "$friends"

            if  [ $? == 0 ]; then
              echo "You are already registered, quitting."
              exit 1
            elif [ "$gender" == "m" ]; then
              echo "You are added to Michel's friends list."
              exit 1
            else
              echo -n "How old are you? "
              read age
              if [ $age -lt 25 ]; then
                echo -n "Which colour of hair do you have? "
                read colour
                echo "$name $age $colour" >> "$friends"
                echo "You are added to Michel's friends list.  Thank you so much!"
              else
                echo "You are added to Michel's friends list."
                exit 1
              fi
            fi

        ▪ Применение heredoc

            #!/bin/bash

            # This script provides an easy way for users to choose between browsers.

            echo "These are the web browsers on this system:"

            # Start here document
            cat << BROWSERS
            mozilla
            links
            lynx
            konqueror
            opera
            netscape
            BROWSERS
            # End here document

            echo -n "Which is your favorite? "
            read browser

            echo "Starting $browser, please wait..."
            $browser &

А10. Bash scripting: циклы

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Цикл for

      • Синтаксис цикла for
      • Описание цикла for
      • Примеры использования for

        ▪ Конвертировать все *.html в текущем каталоге в *.php

    # Цикл while

      • Синтаксис цикла while
      • Примеры использования while

        ▪ Открыть 4 терминала
        ▪ Вложенные циклы while
        ▪ Генерировать файл каждые 5 минут
        ▪ Получение ввода от пользователя, предоставление выбора из списка
        ▪ Вычисление среднего

    # Цикл until

      • Синтаксис цикла until
      • Примеры использования until

        ▪ Скрипт, проверяющий наличие свободного места на диске

    # Переадресация и циклы

      • Переадресация ввода из файла в цикл с test-командой read
      • Переадресация вывода команды на ввод цикла с test-командой read

    # Break / Continue

      • Break
      • Continue
      • Примеры break / continue

    # Встроенная команда select: лёгкая генерация меню

      • Синтаксис select
      • Описание select
      • Примеры select

        ▪ Выбрать из списка файл, который надо сделать приватным
        ▪ Тоже самое, но с пунктом для выхода из цикла

    # Встроенная команда shift

      • Сдвигает все позиционные аргументы влево на n
      • Примеры работы с shift

        ▪ Обработать каждый файл из вывода команды find
        ▪ Установить пакеты, переданные в позиционных аргументах

  --------------------------------------

  > Ссылки

    # Оф.документация по циклам в bash
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_09.html

  > Введение
    - В этой главе рассматриваются циклы в bash.

  > Цикл for

    # Синтаксис цикла for

      • В одну строку

          for NAME [in LIST ]; do COMMANDS; done

      • В несколько строк

          for NAME [in LIST ]; do
            COMMANDS
          done

    # Описание цикла for

      • NAME
        - NAME может быть любой переменной. Часто используют i.

      • LIST
        - LIST может быть любым списком слов, строк, чисел.
        - Которые м.б. литералами, или генерироваться командой.

      • COMMANDS
        - Может быть любыми командами, скриптами, программам, шелл-выражениями.

      • Как меняется значение NAME
        - При первом цикле NAME получает 1-е значение из LIST.
        - При втором цикле NAME получает 2-е значение из LIST.
        - И так далее.
        - Цикл заканчивается, когда значения в LIST заканчиваются.

    # Примеры использования for

      • Конвертировать все *.html в текущем каталоге в *.php

          #!/bin/bash
          # specific conversion script for my html files to php
          LIST="$(ls *.html)"
          for i in "$LIST"; do
               NEWNAME=$(ls "$i" | sed -e 's/html/php/')
               cat beginfile > "$NEWNAME"
               cat "$i" | sed -e '1,25d' | tac | sed -e '1,21d'| tac >> "$NEWNAME"
               cat endfile >> "$NEWNAME"
          done


  > Цикл while

    # Синтаксис цикла while

      • В одну строку

          while CONTROL-COMMAND; do CONSEQUENT-COMMANDS; done

      • В несколько строк

          while CONTROL-COMMAND; do
            CONSEQUENT-COMMANDS
          done

    # Примеры использования while

      • Открыть 4 терминала

          i="0"
          while [ $i -lt 4 ]
          do
          xterm &
          i=$[$i+1]
          done

      • Вложенные циклы while

          #!/bin/bash

          # This script copies files from my homedirectory into the webserver directory.
          # (use scp and SSH keys for a remote directory)
          # A new directory is created every hour.

          PICSDIR=/home/carol/pics
          WEBDIR=/var/www/carol/webcam

          while true; do
            DATE=`date +%Y%m%d`
            HOUR=`date +%H`
            mkdir $WEBDIR/"$DATE"

            while [ $HOUR -ne "00" ]; do
              DESTDIR=$WEBDIR/"$DATE"/"$HOUR"
              mkdir "$DESTDIR"
              mv $PICDIR/*.jpg "$DESTDIR"/
              sleep 3600
              HOUR=`date +%H`
            done
          done

      • Генерировать файл каждые 5 минут

          #!/bin/bash
          while true; do
          touch pic-`date +%s`.jpg
          sleep 300
          done

      • Получение ввода от пользователя, предоставление выбора из списка

          #!/bin/bash

          # This script provides wisdom

          FORTUNE=/usr/games/fortune

          while true; do
          echo "On which topic do you want advice?"
          cat << topics
          politics
          startrek
          kernelnewbies
          sports
          bofh-excuses
          magic
          love
          literature
          drugs
          education
          topics

          echo
          echo -n "Make your choice: "
          read topic
          echo
          echo "Free advice on the topic of $topic: "
          echo
          $FORTUNE $topic
          echo

          done

      • Вычисление среднего

          #!/bin/bash

          # Calculate the average of a series of numbers.

          SCORE="0"
          AVERAGE="0"
          SUM="0"
          NUM="0"

          while true; do

            echo -n "Enter your score [0-100%] ('q' for quit): "; read SCORE;

            if (("$SCORE" < "0"))  || (("$SCORE" > "100")); then
              echo "Be serious.  Common, try again: "
            elif [ "$SCORE" == "q" ]; then
              echo "Average rating: $AVERAGE%."
              break
            else
              SUM=$[$SUM + $SCORE]
              NUM=$[$NUM + 1]
              AVERAGE=$[$SUM / $NUM]
            fi

          done

          echo "Exiting."

  > Цикл until

    # Синтаксис цикла until

      • В одну строку

          until TEST-COMMAND; do CONSEQUENT-COMMANDS; done

      • В несколько строк

          until TEST-COMMAND; do
            CONSEQUENT-COMMANDS;
          done

    # Описание цикла until
      - Цикл until напоминает цикл while.
      - Но он работает, пока TEST-COMMAND выполняется успешно.
      - Как только команда проваливается, цикл завершается.

    # Примеры использования until

      • Скрипт, проверяющий наличие свободного места на диске

          #!/bin/bash

          # This script copies files from my homedirectory into the webserver directory.
          # A new directory is created every hour.
          # If the pics are taking up too much space, the oldest are removed.

          while true; do
            DISKFUL=$(df -h $WEBDIR | grep -v File | awk '{print $5 }' | cut -d "%" -f1 -)

            until [ $DISKFUL -ge "90" ]; do

                    DATE=`date +%Y%m%d`
                    HOUR=`date +%H`
                    mkdir $WEBDIR/"$DATE"

                    while [ $HOUR -ne "00" ]; do
                            DESTDIR=$WEBDIR/"$DATE"/"$HOUR"
                            mkdir "$DESTDIR"
                            mv $PICDIR/*.jpg "$DESTDIR"/
                            sleep 3600
                            HOUR=`date +%H`
                    done

            DISKFULL=$(df -h $WEBDIR | grep -v File | awk '{ print $5 }' | cut -d "%" -f1 -)
            done

            TOREMOVE=$(find $WEBDIR -type d -a -mtime +30)
            for i in $TOREMOVE; do
              rm -rf "$i";
            done

          done

  > Переадресация и циклы

    # Переадресация ввода из файла в цикл с test-командой read
      - Допустим, есть какой-нибудь файл с N строками.
      - Можно скормить этот файл циклу while.
      - У которого в качестве test-команды будет команда read.
      - Цикл будет обрабатывать файл строка за строкой.
      - Пока строки в файле не закончатся.
      - Пример:

          while read; do CONSEQUENT-COMMANDS; done < file

    # Переадресация вывода команды на ввод цикла с test-командой read
      - А можно считывать данные не из файла, а из stdout какой-нибудь команды.
      - Вот живой пример:

          #!/bin/bash

          # This script creates a subdirectory in the current directory, to which old
          # files are moved.
          # Might be something for cron (if slightly adapted) to execute weekly or
          # monthly.

          ARCHIVENR=`date +%Y%m%d`
          DESTDIR="$PWD/archive-$ARCHIVENR"

          mkdir "$DESTDIR"

          # using quotes to catch file names containing spaces, using read -d for more
          # fool-proof usage:
          find "$PWD" -type f -a -mtime +5 | while read -d $'\000' file

          do
          gzip "$file"; mv "$file".gz "$DESTDIR"
          echo "$file archived"
          done

  > Break / Continue

    • Break
      - Эта встроенная команда позволяет прервать любой цикл.
      - Также можно прервать n вложенных циклов.
      - Для этого надо передать команде break число n.
      - n == 1 по умолачнию, и должно быть >= 1.
      - Break также работает для case.

    • Continue
      - Эта встроенная команда позволяет немедленно перейти к след.итерации цикла.
      - Также можно сделать это для n вложенных циклов.
      - Для этого надо передать команде continue число n.
      - n == 1 по умолачнию, и должно быть >= 1.

    • Примеры break / continue

      ▪ Пример с case

          #!/bin/bash

          # This script provides wisdom
          # You can now exit in a decent way.

          FORTUNE=/usr/games/fortune

          while true; do
          echo "On which topic do you want advice?"
          echo "1.  politics"
          echo "2.  startrek"
          echo "3.  kernelnewbies"
          echo "4.  sports"
          echo "5.  bofh-excuses"
          echo "6.  magic"
          echo "7.  love"
          echo "8.  literature"
          echo "9.  drugs"
          echo "10. education"
          echo

          echo -n "Enter your choice, or 0 for exit: "
          read choice
          echo

          case $choice in
               1)
               $FORTUNE politics
               ;;
               2)
               $FORTUNE startrek
               ;;
               3)
               $FORTUNE kernelnewbies
               ;;
               4)
               echo "Sports are a waste of time, energy and money."
               echo "Go back to your keyboard."
               echo -e "\t\t\t\t -- \"Unhealthy is my middle name\" Soggie."
               ;;
               5)
               $FORTUNE bofh-excuses
               ;;
               6)
               $FORTUNE magic
               ;;
               7)
               $FORTUNE love
               ;;
               8)
               $FORTUNE literature
               ;;
               9)
               $FORTUNE drugs
               ;;
               10)
               $FORTUNE education
               ;;
               0)
               echo "OK, see you!"
               break
               ;;
               *)
               echo "That is not a valid choice, try a number from 0 to 10."
               ;;
          esac
          done

      ▪ Конвертирует имена вайлов в нижний регистр

          #!/bin/bash

          # This script converts all file names containing upper case characters into file# names containing only lower cases.

          LIST="$(ls)"

          for name in "$LIST"; do

          if [[ "$name" != *[[:upper:]]* ]]; then
          continue
          fi

          ORIG="$name"
          NEW=`echo $name | tr 'A-Z' 'a-z'`

          mv "$ORIG" "$NEW"
          echo "new name for $ORIG is $NEW"
          done

  > Встроенная команда select: лёгкая генерация меню

    # Синтаксис select

      • В одну строку

          select WORD [in LIST]; do RESPECTIVE-COMMANDS; done

      • В несколько строк

          select WORD [in LIST]; do
            RESPECTIVE-COMMANDS;
          done

    # Описание select

      • Что происходит с List
        - Он превращяется в список элементов.
        - Этот результат отправляется в stderr.
        - Каждому элементу присваивается номре.

      • Если [in LIST] не передано
        - То используются позиционные параметры.
        - Как если бы было написано: in $@

      • Что вообще происходит
        - Выводится список всех элементов, каждый из которых имеет номер.
        - Выводится сообщение из переменной PS3 (типа, выбери пункт).
        - Считывается 1-на строка с помощью read.
        - Если эта строка содержит номер эл-та, значение WORD присваивается
          имени элемента.
        - Если эта строка пуста, опять выводятся все эл-ты и запрашивается ввод.
        - Если эта строка содержит EOF, цикл завершает работу.

    # Примеры select

      • Выбрать из списка файл, который надо сделать приватным.

          #!/bin/bash

          echo "This script can make any of the files in this directory private."
          echo "Enter the number of the file you want to protect:"

          select FILENAME in *;
          do
               echo "You picked $FILENAME ($REPLY), it is now only accessible to you."
               chmod go-rwx "$FILENAME"
          done

      • Тоже самое, но с пунктом для выхода из цикла

          #!/bin/bash

          echo "This script can make any of the files in this directory private."
          echo "Enter the number of the file you want to protect:"

          PS3="Your choice: "
          QUIT="QUIT THIS PROGRAM - I feel safe now."
          touch "$QUIT"

          select FILENAME in *;
          do
            case $FILENAME in
                  "$QUIT")
                    echo "Exiting."
                    break
                    ;;
                  *)
                    echo "You picked $FILENAME ($REPLY)"
                    chmod go-rwx "$FILENAME"
                    ;;
            esac
          done
          rm "$QUIT"

  > Встроенная команда shift

    # Сдвигает все позиционные аргументы влево на n
      - Сабж.

    # Примеры работы с shift

      • Обработать каждый файл из вывода команды find

          #!/bin/bash

          # This script can clean up files that were last accessed over 365 days ago.

          USAGE="Usage: $0 dir1 dir2 dir3 ... dirN"

          if [ "$#" == "0" ]; then
            echo "$USAGE"
            exit 1
          fi

          while (( "$#" )); do

          if [[ $(ls "$1") == "" ]]; then
            echo "Empty directory, nothing to be done."
            else
            find "$1" -type f -a -atime +365 -exec rm -i {} \;
          fi

          shift

          done

      • Установить пакеты, переданные в позиционных аргументах

          #!/bin/bash
          if [ $# -lt 1 ]; then
                  echo "Usage: $0 package(s)"
                  exit 1
          fi
          while (($#)); do
            yum install "$1" << CONFIRM
          y
          CONFIRM
          shift
          done

А11. Bash scripting: переменные, массивы, операции с ними

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Переменные

      - Обычные переменные
      - Применение declare
      - Константы

    # Массивы

      - Создание массивов

        ▪ Общее описание массивов
        ▪ Неявное определение массива
        ▪ Явное определение массива
        ▪ Определение массива с массовым добавлением значений
        ▪ Добавление значений в массив

      - Обращение к элементам массива

        ▪ Обязательные фигурные скобки
        ▪ Обращение к массиву без {} ссылается на 0-й элемент
        ▪ Примеры обращения к элементам массива

      - Удаление элементов из массива
      - Примеры работы с массивами

    # Операции с переменными и массивами

      • Арифметика
      • Размер переменной
      • Трансформация переменной
      • Удаление подстрок
      • Замена части имён переменных

  --------------------------------------

  > Ссылки

    # Глава из оф.документации про переменные и массивы
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_10.html

  > Введение
    - В этой главе раскрывается тема переменных и массивов.
    - Массивы редко используются, поскольку они ломают совместимость,
      т.к. не все шеллы их используют.

  > Переменные

    # Обычные переменные

        VAR=12
        echo $VAR   // 12

        VAR=string
        echo $VAR   // string

    # Применение declare
      - С помощью declare можно ограничить доступные переменной значения.
      - А так, вообще то, переменные bash могут содержать любые типы значений.
      - Синтаксис declare:

          declare OPTION(s) VARIABLE=value

      - Опции declare:

          -a	Variable is an array.
          -f	Use function names only.
          -i	The variable is to be treated as an integer; arithmetic evaluation is performed when the variable is assigned a value (see Section 3.4.6).
          -p	Display the attributes and values of each variable. When -p is used, additional options are ignored.
          -r	Make variables read-only. These variables cannot then be assigned values by subsequent assignment statements, nor can they be unset.
          -t	Give each variable the trace attribute.
          -x	Mark each variable for export to subsequent commands via the environment.

      - Примеры:

          declare -i VARIABLE=12
          VARIABLE=string
          echo $VARIABLE          // 0
          declare -p VARIABLE     // declare -i VARIABLE="0"

          OTHERVAR=blah
          declare -p OTHERVAR     // declare -- OTHERVAR="blah"

    # Константы
      - Их можно задавать встроенной командой readonly.
      - Константы после их задания больше нельзя изменять.
      - Подробнее про readonly см.: man readonly
      - Примеры:

          readonly TUX=penguinpower
          TUX=Mickeysoft              // bash: TUX: readonly variable

  > Массивы

    # Создание массивов

      • Общее описание массивов
        - Массив это переменная, содержащая много значений.
        - Любое из этих значений может также быть массивом.
        - Нет ограничений на размер или глубину вложенности массивов.
        - Индексирование массивов начинается с 0.

      • Неявное определение массива
        - Определим массив ARR со значением value под индексом 0:

            ARR[0]=value

      • Явное определение массива

          declare -a ARR

      • Определение массива с массовым добавлением значений

          ARR=(value1 value2 value3)

      • Добавление значений в массив

          ARR[n]=value

    # Обращение к элементам массива

      • Обязательные фигурные скобки
        - При обращении к эл-м массива нужно использовать {}

      • Обращение к массиву без {} ссылается на 0-й элемент
        - Сабж.

      • Примеры обращения к элементам массива

        ARRAY=(one two three)
        echo ${ARRAY[*]}          // one two three
        echo $ARRAY[*]            // one[*]
        echo ${ARRAY[2]}          // three
        ARRAY[3]=four
        echo ${ARRAY[*]}          // one two three four

    # Удаление элементов из массива

        unset ARRAY[1]
        echo ${ARRAY[*]}      // one three four
        unset ARRAY
        echo ${ARRAY[*]}      // (нет вывода)

    # Примеры работы с массивами

      • Распространение конфигов apach по хостам

          #!/bin/bash

          if [ $(whoami) != 'root' ]; then
                  echo "Must be root to run $0"
                  exit 1;
          fi
          if [ -z $1 ]; then
                  echo "Usage: $0 </path/to/httpd.conf>"
                  exit 1
          fi

          httpd_conf_new=$1
          httpd_conf_path="/usr/local/apache/conf"
          login=htuser

          farm_hosts=(web03 web04 web05 web06 web07)

          for i in ${farm_hosts[@]}; do
                  su $login -c "scp $httpd_conf_new ${i}:${httpd_conf_path}"
                  su $login -c "ssh $i sudo /usr/local/apache/bin/apachectl graceful"

          done
          exit 0

      • Выбрать одного из списка в соответствии с заданными условиями

          #!/bin/bash
          # This is get-tester-address.sh
          #
          # First, we test whether bash supports arrays.
          # (Support for arrays was only added recently.)
          #
          whotest[0]='test' || (echo 'Failure: arrays not supported in this version of
          bash.' && exit 2)

          #
          # Our list of candidates. (Feel free to add or
          # remove candidates.)
          #
          wholist=(
               'Bob Smith <bob@example.com>'
               'Jane L. Williams <jane@example.com>'
               'Eric S. Raymond <esr@example.com>'
               'Larry Wall <wall@example.com>'
               'Linus Torvalds <linus@example.com>'
             )
          #
          # Count the number of possible testers.
          # (Loop until we find an empty string.)
          #
          count=0
          while [ "x${wholist[count]}" != "x" ]
          do
             count=$(( $count + 1 ))
          done

          #
          # Now we calculate whose turn it is.
          #
          week=`date '+%W'`    	# The week of the year (0..53).
          week=${week#0}       	# Remove possible leading zero.

          let "index = $week % $count"   # week modulo count = the lucky person

          email=${wholist[index]}     # Get the lucky person's e-mail address.

          echo $email     	# Output the person's e-mail address.

  > Операции с переменными и массивами

    # Арифметика
      - Стандартная, как и в большинстве других языков.

    # Размер переменной

      • Кол-во символов в переменной, или кол-во элементов в массиве
        - Можно узнать так: ${#VAR}

      • Кол-во позиционных параметров
        - Можно узнать так: ${#*} или ${#@}

      • Примеры получения размера переменной

        echo $SHELL             // /bin/bash
        echo ${#SHELL}          // 9

        ARRAY=(one two three)
        echo ${#ARRAY}          // 3

    # Трансформация переменной

      • ${VAR:-WORD}
        - Если VAR пуста или не определена, подставляется значение WORD.
        - Иначе подставляется VAR.
        - Примеры:

            echo ${TEST:-test}    // test
            echo $TEST            //

            export TEST=a_string
            echo ${TEST:-test}    // a_string

            echo ${TEST2:-$TEST}  // a_string

            [ -z "${COLUMNS:-}" ] && COLUMNS=80

      • ${VAR:=WORD}
        - Если VAR пуста или не определена, она инициируется значением WORD.
        - Примеры:

            echo $TEST2             // .. пусто ..
            echo ${TEST2:=$TEST}    // a_string
            echo $TEST2             // a_string

      • $(VAR:?WORD)
        - Если VAR пуста или не определена, выводит WORD в stdout.
        - И при этом неинтерактивный скрипт завершает свою работу.
        - Пример:

            #!/bin/bash

            # This script tests whether a variable is set.  If not,
            # it exits printing a message.

            echo ${TESTVAR:?"There's so much I still wanted to do..."}
            echo "TESTVAR is set, we can proceed."

    # Удаление подстрок

      • ${VAR:OFFSET:LENGTH}
        - Вырезает и возвращает кусок из VAR.
        - LENGTH определяет кол-во символов, которые надо сохранить.
        - Начинать сохранение надо с позиции OFFSET.
        - Пример:

            export STRING="thisisaverylongname"
            echo ${STRING:4}                    // isaverylongname
            echo ${STRING:6:5}                  // avery

      • ${VAR#WORD} и ${VAR##WORD}

        ▪ Значение
          - Удалить из VAR значения, которые матчатся с WORD.
          - WORD матчит начало каждого значения в VAR.
          - ${VAR%WORD} и ${VAR%%WORD} матчат конец.

        ▪ Если VAR это * или @
          - Операция применяется к каждому позиционному параметру.
          - По очереди, и записывает результаты в итоговый список.

        ▪ Если VAR это массив с * или @
          - Операция применяется к каждому элементу массива.
          - По очереди, и записывает результаты в итоговый список.

        ▪ Примеры

            echo ${ARRAY[*]}        // one two one three one four
            echo ${ARRAY[*]#one}    // two three four
            echo ${ARRAY[*]#t}      // one wo one hree one four
            echo ${ARRAY[*]#t*}     // one wo one hree one four
            echo ${ARRAY[*]##t*}    // one one one four

      • ${VAR#WORD} и ${VAR##WORD}
        - Аналоги ${VAR#WORD} и ${VAR##WORD}.
        - Только матчат конец.
        - Пример:

            echo $STRING          // thisisaverylongname
            echo ${STRING%name}   // thisisaverylong

    # Замена части имён переменных

      • ${VAR/PATTERN/STRING}
        - Заменить только первый найденный match.
        - Пример:

            echo ${STRING/name/string}    // thisisaverylongstring

      • ${VAR//PATTERN/STRING}
        - Заменить все найденне match'.

А12. Bash scripting: функции

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Введение в функции в bash

      • Общая информация про функции
      • Функция выполняется в шелле, где она определена (без новых процессов)
      • Имя функции должно быть уникальным в пределах шелл-скрипта
      • Есть ряд встроенных команд, которые шелл ищет перед поиском среди функций

    # Синтаксис функций в bash

      • Вариант определения функции №1
      • Вариант определеняи функции №2
      • Примечания по синтаксису
      • Замечания во избежание частых ошибок

        ▪ Фигурные скобки д.б. отделены от тела пробелами
        ▪ Тело функции должно заканчиваться на ; или новой строкой

    # Позиционные параметры в функциях

      • Функции, как мини-скрипты

        ▪ Могут принимать параметры
        ▪ Могут использовать локальные переменные
        ▪ Могут возвращать значения вызвавшему их шеллу
        ▪ И функции также имеют позиционные параметры

      • Позиционные параметры функции

        ▪ Спец.параметр # содержит кол-во позиционных параметров.
        ▪ Позиционный параметр 0 не изменяем, и содержит путь к вызвавшему функцию шеллу
        ▪ Переменная среды bash FUNCNAME содержит имя ф-ии на время её выполнения
        ▪ Позиц.параметры $1, $2, ..., $n содержат аргументы функции

      • Простой пример использования позиционных параметров в функции
      • Set, unset и which, а ещё, функции сохраняются после определения

        ▪ После определения функции в скрипте, она сохраняется
        ▪ Просмотреть все функции, которые знает шелл, можно командой set
        ▪ Узнать, знает ли шелл о функции, можно командой which
        ▪ Заставить шелл забыть функцию можно командой unset

    # Примеры использования функций в скриптах

      • Регулярно используемые функции в sturtup-скрипт

  --------------------------------------

  > Ссылки

    # Оф.справка по функциям в bash
        http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_11.html

  > Введение
    - Эта глава раскрывает тему функций в bash.

  > Введение в функции в bash

    • Общая информация про функции
      - Функции в шелл являются способом сгруппировать команды.
      - А потом их все разом вызвать, обратившись к функции по имени.
      - При вызове функции, все команды из неё выполняются обычным образом.

    • Функция выполняется в шелле, где она определена (без новых процессов)
      - Сабж.

    • Имя функции должно быть уникальным в пределах шелл-скрипта
      - Сабж.

    • Есть ряд встроенных команд, которые шелл ищет перед поиском среди функций
      - Следует избегать называть функции этими именами.
      - Вот список данных встроенных команд:

          break, :, ., continue, eval, exec, exit, export, readonly,
          return, set, shift, trap and unset.

  > Синтаксис функций в bash

    • Вариант определения функции №1
      - Эквивалентен варианту №2.
      - Использует встроенную команду function.
      - Код:

          function FUNCTION { COMMANDS; }

    • Вариант определеняи функции №2
      - Эквивалентен варианту №1.
      - Не использует встроенную команду function.
      - Код:

          FUNCTION () { COMMANDS; }

    • Примечания по синтаксису
      - Команды между фигурными скобками составляют тело функции.
      - Тело исполняется каждый раз при вызове функций.

    • Замечания во избежание частых ошибок

      ▪ Фигурные скобки д.б. отделены от тела пробелами
        - Иначи они будут неправильно интерпретированы.

      ▪ Тело функции должно заканчиваться на ; или новой строкой

  > Позиционные параметры в функциях

    • Функции, как мини-скрипты

      ▪ Могут принимать параметры
      ▪ Могут использовать локальные переменные
      ▪ Могут возвращать значения вызвавшему их шеллу
        - С помощью встроенной команды return.
        - После возврата значения выполняется следующая команда,
          которая идёт сразу после вызова функции в родительском скрипте.
        - Значения # и позиционных параметров восстанавливаются на те,
          которыми они были до вызова функции.
      ▪ И функции также имеют позиционные параметры

    • Позиционные параметры функции

      ▪ Спец.параметр # содержит кол-во позиционных параметров.

          f () { echo $#; }
          f                         // 0
          f 1                       // 1
          f 1 2                     // 2
          f 1 2 3                   // 3

      ▪ Позиционный параметр 0 не изменяем, и содержит путь к вызвавшему функцию шеллу

          f () { echo $0; }
          f                 // /bin/bash

      ▪ Переменная среды bash FUNCNAME содержит имя ф-ии на время её выполнения

          f () { echo $FUNCNAME; }
          f                         // f

      ▪ Позиц.параметры $1, $2, ..., $n содержат аргументы функции

          f () { echo $1 $2 $3; }
          f 1 2 3                   // 1 2 3

    • Простой пример использования позиционных параметров в функции

          #!/bin/bash

          echo "This script demonstrates function arguments."
          echo

          echo "Positional parameter 1 for the script is $1."
          echo

          test ()
          {
          echo "Positional parameter 1 in the function is $1."
          RETURN_VALUE=$?
          echo "The exit code of this function is $RETURN_VALUE."
          }

          test other_param

    • Set, unset и which, а ещё, функции сохраняются после определения

      ▪ После определения функции в скрипте, она сохраняется
        - И может быть вызвана из шелла.

      ▪ Просмотреть все функции, которые знает шелл, можно командой set

          set

      ▪ Узнать, знает ли шелл о функции, можно командой which

          which <имя функции>

      ▪ Заставить шелл забыть функцию можно командой unset

          unset <имя функции>

  > Примеры использования функций в скриптах

    # Регулярно используемые функции в sturtup-скрипт
      - Можно написать скрипт /etc/functions.sh
      - В нём сделать библиотеку своих скриптов.
      - И эти скрипты д.б. в системи и после перезагрузки.
      - Для этого в startup-скрипт надо добавить:

          . /etc/functions.sh

      - Это исполнит скрипт в текущем шелле, без создания дочернего подпроцесса.
      - В результате чего определения всех функций из скрипта запишутся в текущее окружение.
      - И это будет происходить каждый раз при старте машины.



А13. Bash scripting: сигналы [написать по запросу]

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

  --------------------------------------

  > Ссылки


  > Введение


