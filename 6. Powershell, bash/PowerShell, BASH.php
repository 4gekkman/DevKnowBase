<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Powershell, Bash






-------------------------------------------------- */












/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:


  Общие:

    > Здесь можно скачать ConEmu последней версии:
          https://code.google.com/p/conemu-maximus5/

    > Увесистая статья про ConEmu на habr:
          http://habrahabr.ru/post/164687/


  PowerShell:

    > "Руководство пользователя Windows PowerShell" на technet.microsoft.com:
          http://technet.microsoft.com/ru-ru/library/cc196356.aspx

    > Тема со сжатой ёмкой справкой о PowerShell на cyberforum.ru:
          http://www.cyberforum.ru/powershell/thread634851.html

    > Несколько видео-кастов о Windows PowerShell 3.0
          http://www.youtube.com/playlist?list=PLU4HoaX9cJ1DWsDTaRD3D-zAtNzlPblf8

    > Как создать постоянный псевдоним в PowerShell (статья eng):
          http://www.powershellatoms.com/desktop-management/creating-persistent-aliases-in-powershell/

    > Книги:
        - Ли Холмс:   "Windows PowerShell 3.0. Карманный справочник"  (2013)
        - Wilson E.:  "Windows PowerShell 3.0 (Step by Step)"         (2013)


  Bash:

    > Статья "введение в bash"
          http://linuxgeeks.ru/bash-intro.htm

    > Здесь можно скачать Git Bash для Windows последней версии
          http://git-scm.com/downloads

    > Свежий (2012) учебник по Bash на английском
          http://tldp.org/LDP/abs/html/

    > Старый (2004) учебник по Bash на русском
          http://www.opennet.ru/docs/RUS/bash_scripting_guide/

    > Подробно о том, как работает команда CURL:
          http://curl.haxx.se/
          http://curl.haxx.se/docs/manpage.html




*****************************************************
Оглавление:


> ConEmu
  > Что такое terminal?
  > Что такое shell?
  > Альтернативный терминал для windows - ConEmu
    > Зачем он нужен? Чем плох стандартный терминал?
    > Какие shell'ы поддерживает терминал ComEmu?
    > Установка ConEmu
    > Настройка default'ного shell для ComEmu

> Powershell
  > Основное назначение
  > Общая информация
  > Основы Windows PowerShell
    > PowerShell, как CLI
      > Операционная система: графически интерфейс, интерфейс командная строка
      > Как работает CLI?
    > PowerShell основана на объектах
      > Результат работы PowerShell - объект
    > Командлеты
      > Что такое командлет?
      > Командлеты бывают: встроенные/пользовательские
      > А кроме командлетов?
      > Как PowerShell анализирует вводимые команды
      > PowerShell и C#
    > Система имён команд в PowerShell
  > Концепция "конвейер" и объекты в PowerShell
    > В чём состоит концепция "конвейер команд" в PowerShell?
    > Как создать конвейер в PowerShell?
    > Как работает конвейер?
    > Зачем нужен конвейер?
    > Что идёт по конвейеру: объекты или текст?
    > Несколько примеров работы конвейера
    > Как посмотреть содержимое объекта?
  > Как установить CURL в PowerShell?

  > Справочник команд
    > Оглавление
    > Примеры использования

> Bash
  > Основное назначение
  > Как добавлять постоянные alias в bash



*****************************************************



||                            ||
================================
 ConEmu
================================
||                            ||


> Общее

  > Что такое terminal?
    > Общая информация
      > Terminal = tty = text input/output environment.
      > Таким образом, в контексте этого учебного файла, терминал -
        это оболочка для shell.

    > Зачем нужны терминалы?
      > Чтобы принимать команды и выводить ответы shell'a на экран.

    > В Windows есть стандартный терминал?
      > Да, это консольное окошко.

    > А какие есть не стандартные терминалы?
      > Один из них - ConEmu. О нём ниже.

  > Что такое shell?
    > Shell - это интерпретатор командной строки.
    > Shell может быть подключен к любому терминалу, если последний
      поддерживает этот вид Shell, и поддерживает функцию подключения
      иных shell, кроме стандартного.

  > Альтернативный терминал для Windows - ConEmu
    > Зачем он нужен? Чем плох стандартный терминал?
      > Стандартный терминал убог, в нём мало функций.
      > ConEmu красив и функционален. Среди прочего:
        - Цветноц вывод
        - Появление в стиле "Quake"
        - Можно использовать любые шрифты
        - Полупрозрачность
        - Горячие клавиши
        - ... и многое другое, полный список здесь:
                https://code.google.com/p/conemu-maximus5/

    > Какие shell'ы поддерживает терминал ComEmu?
      > Любые.

    > Установка ConEmu
      1. Скачать portable-версию с официального сайта.
      2. Использовать.

    > Настройка default'ного shell для ComEmu
      > Имеется в виду shell, который будет по умолчанию запускаться
        при запуске ComEmu
      > Причём, поскольку в ComEmu есть вкладки, то имеется возможность
        настроить его так, что при его запуске по умолчанию будут открываться
        несколько разных shell в разных вкладках.
      > Процесс настройки:
        1. Пройти по пути:
              Settings -> Startup -> Tasks
        2. Нажать на плюсик (добавить новый task).
        3. В окошке "task name" написать имя подключаемого shell.
        4. В большом окошке написать путь к запускающему shell файлу .exe,
           если надо со всеми опциями.
        5. Перейти обратно в меню Startup.
        6. Там выбрать опцию "Specified named task", где в drop-down меню
           выбрать созданный ранее task по его имени.
        7. Нажать кнопку Save settings

    > Настройка открытия нескольких shell в разных вкладках
      1.  Для этого надо создать файл tasks.txt. Удобно создать его в той же
          папке, в которой хранится файл ConEmu.exe.
      2.  В файле написать следующее:
          - Значения tasks, которые должны выполниться, каждое с новой строки.
          - Пример (будет запущено 3 shell'а, в разных вкладках):

              powershell.exe -new_console:a
              C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe
              "C:\Program Files (x86)\Git\bin\sh.exe" --login -i

      3.  Пройти по адресу:
            Settings -> Startup
      4.  Выбрать radio-box "Tasks file" и указать путь к созданному в
          п.2 файлу.
      5.  Нажать кнопку Save settings




||                            ||
================================
 PowerShell
================================
||                            ||


> PowerShell


  > Основное назначение

    > В Windows - Powershell, а не bash
      > Что ни говори, в windows удобнее работать с помощью powershell,
        чем с bash.
      > Powershell изначально создан для windows, а bash - для unix.
      > Достаточно хотя бы того, что Git Bash для windows не поддерживает
        UTF8, как следствие русские имена папок и файлов командой ls
        отображаются, как ??????? (на 05.01.2014).

    > Зачем мне тогда Git Bash?
      > Для работы с Git.
      > Для этого также можно использовать различные графические оболочки.
      > А кроме них, Git также встроен в PHPStorm.


  > Общая информация
    > Последняя версия PowerShell: 3.0 (на 05.01.2014).
    > Windows PowerShell является оболочкой командной строки и средой
      для исполнения скриптов, предоставляя мощь .NET Framework пользователям
      командной строки и создателям скриптов.


  > Основы Windows PowerShell

    > PowerShell, как CLI
      > Операционная система: графически интерфейс, интерфейс командная строка
        > Работать с операционной системой, можно используя 2 интерфейса:
          - Графический
          - Интерфейс командной строки (CLI - Command Line Interface)
        > В самых первых операционных системах был только CLI-интерфейс,
          а в большинстве современных - присутствуют оба варианта.
        > PowerShell - это CLI-интерфейс в операционной системе Windows.

      > Как работает CLI?
        > В CLI для взаимодействия с ОС пользователю необходимо заранее знать
          имена нужных ему команд.
        > Большинство CLI содержит имена команд, которые были придуманы десятки
          лет назад. Их не меняют для обратной совместимости.
        > PowerShell спроектирован таким образом, что многие команды обладают
          свомством многоимённости - к ним можно обратиться, используя несколько
          разных имён. Среди них старые имена из различных CLI, и новое, часто
          человекопонятное имя.

    > PowerShell основана на объектах
      > Результат работы PowerShell - объект
        > Выходным элементом любой команды в PowerShell является объект.
        > Выходной объект всегда можно послать на вход другой команды.
        > Таким образом, PowerShell позволяет пересылать между командами
          объекта, а не просто текст.
        > Если раньше использовались средства обработки текста для обработки
          данных командной строки, то в PowerShell можно получить доступ
          к данным с помощью обычных команд обработки объектов оболочки
          PowerShell.

    > Командлеты
      > Что такое командлет?
        > Командлет - внутренняя двоичная команда Windows PowerShell.
        > Название "командлеты" используется из-за их специальной природы.

      > Командлеты бывают: встроенные/пользовательские
        > Встроенные в PS командлеты могут дополняться пользовательскими
          командлетами. Причём интеграция полная, встроенные и пользовательские
          командлеты равноправны в среде PowerShell.

      > А кроме командлетов?
        > Кроме командлетов PowerShell поддерживает скрипты, аналогичные
          скриптам оболочки UNIX и пакетным файлам cmd.exe, но имеющие в
          имени файла расширение PS1.
        > PS позволяет также создавать внутренние функции, которые могут
          использоваться в интерфейсе, и в скриптах.

      > Как PowerShell анализирует вводимые команды
        > При вводе команды в оболочке PowerShell производится автоматический
          разбор и предварительная обработка всех вводимых данных.
        > Разработчики командлетов не должны синтаксически анализировать команды.

      > PowerShell и C#
        > Оболочка PowerShell имеет синтаксические особенности и ключевые
          слова, сходные с применяемыми в языке C#, т.к. она основана на
          .NET Framework.
        > Зная PowerShell, гораздо легче изучать C#.
        > Для пользователей, не занимающихся программированием на C#, такое
          сходство не так важно.

    > Система имён команд в PowerShell

      > Недостаток системы имён в старых CLI
        > Для работы с CLI нужно запоминать нужные команды, другого выхода нет.
        > Чем сложнее их запомнить, тем сложнее учиться работать с CLI.
        > В старых CLI имена для команд выбирались в целом бессистемно,
          так что запомнить их не просто. Это и есть их недостаток.

      > Система имён "Глагол-Существительное" в PowerShell
        > В PowerShell используют систему имён "Глагол-Существительное".
        > Глагол не всегда является глаголом языка, но всегда обозначает,
          что делает эта команда.
        > Существительное описывает объект, на который воздействует команда.
        > Примеры:

            Get-Process, Stop-Process, Get-Service, Stop-Service

      > Как система имён в PowerShell облегчает обучение?
        > Как видно из примеров выше, часто по имени команды можно понять,
          что именно эта команда делает. Это облегчает обучение.
        > Разработчики PowerShell постарались как можно чаще использовать
          одни и те же глаголы и существительные, в разных сочетаниях.
          Таким образом, если взглянуть на обычный набор из 10 глаголов и
          10 существительных, то при помощи их можно образовать 100 различных
          имён команд, а выучить надо всего 20 слов.

      > Команда не обязательно является командлетом
        > Команда - это не обязательно командлет только из-за того, что он
          имеет схему именования глагол-существительное.
        > Это может быть и внутренняя функция. Например, команда очистки
          окна консоли Clear-Host - является внутренней функцией, в чём можно
          убедиться при выполнении на ней команды Get-Command:

            Get-Command -Name Clear-Host

          На экран выводится сообщение о том, что CommandType = Function

      > Имена параметров в PowerShell
        > В старых CLI обычно не используются согласованные имена параметров.
          Иногда параметры вообще не имеют имён. Если же параметр имеет имя,
          то часто оно состоит из одного знака или аббревиатуры, которую
          можно быстро ввести, но которую трудно понять новичкам.
        > В PowerShell имеются рекомендации разработчикам для стандартизации
          имён параметров. Хотя это и не гарантирует, что каждый командлет
          будет всегда соответствовать стандартам, такие рекомендации способствуют
          стандартизации.
        > В PowerShell при использовании параметров перед их именами всегда
          стоит символ "-", что позволяет оболочке PowerShell легко идентифицировать
          их как параметры.
          > В примере выше параметр имеет имя Name, но вводится как -Name.


  > Концепция "конвейер" и объекты в PowerShell

    > В чём состоит концепция "конвейер команд" в PowerShell?
      > У каждой команды могут быть входы и выходы.
      > Концепция конвеёера состоит в том, что на вход следующей команды-сегмента
        конвейера подаётеся выход предыдущей команды-сегменты конвейера.

    > Как создать конвейер в PowerShell?
      > Для этого использую символ Pipe "|"
      > При этом вывод каждой команды используется, как ввод для следующей.

    > Как работает конвейер?
      > Как ряд соединённых между собой сегментов трубы.
      > Элементы перемещаются по конвейеру слева направо, и проходят
        через каждый сегмент.
      > Конвейер действует на каждый элемент отдельно.

    > Зачем нужен конвейер?
      > Допустим, нам надо пропустить некий элемент через несколько команд
        подряд. В этом случае удобно было бы использовать конвейер. Запускаем
        наш элемент на вход 1-го сегмента конвейера, и получаем итоговый
        результат на выходе последнего эл-та конвейера. Очень удобно.

    > Что идёт по конвейеру: объекты или текст?
      > В PowerShell по конвейеру пускаются объекты, а не текст.
      > Вся нужная информация упаковывается и передаётся в объектах, потому
        что с объектом - как единым блоком - легче управляться, чем с разрозненными
        кусками текста.
      > При выводе объекта в консоль, выводится его текстовое представление,
        которое осуществляется методом ToString объекта.

    > Несколько примеров работы конвейера:

      > Команда Get-Member ставится в конце конвейера, и выводит на экран
        все свойства и методы объекта, который в неё поступит:

          Get-Command | Get-Member

      > Команды группы Format-* ставят в конец конвейера для того, чтобы
        отформатировать вывод в желаемом формате:

          # Отформатировать вывод в виде списка
          Get-Command | Format-List

          # Отформатировать вывод в виде таблицы
          Get-Command | Format-Table

    > Как посмотреть содержимое объекта?
      > Для того, чтобы исследовать содержимое объекта, есть специальная
        команда Get-Member.
      > В передать в неё объект для исследования можно 2-мя способами:
        - Задать объект в параметре -InputObject
        - Поставить Get-Member в конце конвейера
      > Пример можно наблюдать выше.


  > Как установить CURL в PowerShell?

    1. Скачать и установить Git Bash
          http://git-scm.com/downloads

    2. Прописать указанный ниже путь в переменную среды PATH:
          C:\Program Files (x86)\Git\bin

    3. Всё. Теперь curl будет запускаться из PowerShell, а установить
       Composer можно при помощи простой команды:

          curl -s http://getcomposer.org/installer | php



  > Справочник команд


    > Оглавление




      Управление местоположением:
      =========================
      # Get-Location  | gl, pwd | Получить текущее месторасположение
      # Set-Location  | sl, cd  | Установить текущее месторасположение
      # Get-ChildItem | ls      | Получает и выводит список элементов в текущей (по умолчанию) или указанных папках


      Работа с файлами и папками:
      =========================
      # New-Item      | ni   | Создать новый элемент в текущей папке.
      # Remove-Item   | ri   | Удалить указанные элементы.
      # Rename-Item   | ren  | Переименовать элемент.
      # Move-Item     | move | Переместить элемент из одного места в другое.
      # Copy-Item     | copy | Скопировать элемент из одного места в другое.
      # Invoke-Item   | ii   | Выполнить действие "по умолчанию" для этого элемента
      # Get-Item      | gi   | Получить объект элемента по указанному адресу
      # Set-Item      | si   | Изменить значение элемента на указанное по указанному адресу


      Важные команды (не попавшие в другие категории):
      =========================
      # Get-Help         |       | Отображает справку об указанной команде
      # Get-Command      | gcm   | Ищет команду по заданной строке
      # Update-Help      |       | Загружает обновлённую справку на компьютер
      # Clear-Host       | clear | Очистить окно консоли
      # Get-Service      | gsv   | Отображает список сервисов на локальном или удалённом компьютере
      # Stop-Service     | spsv  | Остановить 1 или более запущенных сервисов
      # Start-Service    | sasv  | Запустить 1 или более остановленных сервисов
      # Get-Member       | gm    | Получает свойства и методы объекта
      # Get-Process      | gps   | Отображает список процессов на локальном или удалённом компьютере
      # Stop-Process     | kill  | Останавливает 1 или более запущенных процессов
      # Start-Process    | start | Запускает 1 или более процессов на локальном компьютере
      # Stop-Computer    |       | Выключает локальный или удалённый компьютер
      # Restart-Computer |       | Перезагружает ОС на локальном или удалённом компьютере
      # Rename-Computer  |       | Переименовать компьютер
      # Get-Date         |       | Получить текущую дату и время
      # Set-Date         |       | Установить дату и время
      # Get-Module       | gmo   | Возвращает импортированные в текущей сессии модули
      # Get-Alias        | gal   | Возвращает список псевдонимов для текущей сессии
      # Set-Alias        | sal   | Создаёт/изменяет псевданим для командлета в текущей сессии
      # Format-List      | fl    | Форматирует вывод как список параметров, каждый из которых появляется в отдельной строке
      # Format-Table     | ft    | Форматирует вывод как таблицу
      # Out-Host         | oh    | Ставится в конец конвейера, для постраничного вывода большого объёма данных
      # Out-File         |       | Отправляет выходы в файл, ставится в коней конвейера
      # Out-String               | Ставится в конец конвейера, накапливает входные строки и возвращает одну большую выходную
                                   > С помощью параметра stream можно настроить команду так,
                                     чтобы она выдавала на выход по 1-й строке за раз
      # Get-Content      |       | Прочитать содержимое элемента
                                   > Читает содержимое по 1-й строке за раз, и возвращает
                                     набор объектов, каждый из которых представляет отдельную строку


    > Примеры использования


      # Get-Help                | Отображает справку об указанной команде
        -Category      | Отображает помощь только для элементов в указанной категории:
                         > Alias/Cmdlet/Function/Provider/Workflow/HelpFile
                         > Концептуальная справка (About_) находится в HelpFile
        -Component     | ?
        -Detailed      | Отобразить справку + параметры + примеры
        -Examples      | Отобразить только примеры
        -Full          | Detailed + входные/выходыне типы объектов + доп.инфа
        -Functionality | Отображает справку для эл-тов с указанной функциональностью
        -Name          | Имя команды, справка по которой нужна
        -Online        | Отобразить онлай-версию справки в браузере по умолчанию
        -Parameter     | Отображать датальное описание только указанных параметров, плейсхолдеры разрешены
        -Path          | ?
        -Role          | Отобразить справку для указанной роли пользователя (админ, юзер и т.д.)
        -ShowWindow    | Отобразить справку в отдельном окне с поиском и настройками

          1. Получить справку о команде Get-Help:

                Get-Help

          2. Получить локальную справку о команде с именем Get-Command:

                Get-Help Get-Command        | способ 1
                Get-Command -?              | способ 2
                Help Get-Command            | способ 3

          3. Получить из интернета справку о команде с именем Get-Command:

                Get-Help Get-Command -online

          4. Вывести на экран примеры использования команды Get-Command:

                Get-Help Get-Command -examples

          5. Вывести на экран детальные сведения о команде Get-Command:

                Get-Help Get-Command -detailed

          6. Вывести на экран технические сведения о команде Get-Command:

                Get-Help Get-Command -full

          7. Получить список параметров, доступных для указанной команды:

             1) Для этого сначала смотрим, какие свойства и методы есть
                у того объекта, для которого мы хотим получить список парамеров:

                Get-Command Invoke-WebRequest | Get-Members

             2) Теперь увидив, что там есть св-во parameters, выводим его
                содержимое на экран:

                (Get-Command Invoke-WebRequest).parameters

          8. Получить подробную справку по всем параметрам, которые доступны
             для использования с данной командой (на примере Invoke-WebRequest):

                 Get-Help Invoke-WebRequest -parameter *

             Или можно получить справку по конкретному параметру (например, uri):

                 Get-Help Invoke-WebRequest -parameter uri

          9. Получить краткую справку по всем командам, которые заканчиваются
             на "-item" (команды для работы с файлами и папками):

                 Get-Help *-item

          10. Получить справку по команде Get-Help в отдельном окне с поиском:

                 Get-Help Get-Help -ShowWindow


      # Get-Command             | Ищет команду по заданной строке
        -All           | Показать вообще все команды
        -ArgumentList  | Получить информацию о команде или функции, когда она используется с указанными параметрами (аргументами)
        -CommandType   | Получает только указанные типы команд
                         > По умолчанию стоят: Cmdlet/Workflow/Alias
                         > Доступны: Alias/All/Application/Cmdlet/ExternalScript/Filter/Script/Workflow
        -Module        | Получить команды из указанного модуля
        -Name          | Получить команды с указанными именем, плейсхолдера разрешены.
        -Noun          | Получить команды (Cmdlet/function/workflow/alias) с указанным существительным (2 часть команды)
        -Syntax        | Получить только указанные данны о командах
        -TotalCount    | Получить указанное число команд. Так можно ограничить их кол-во в выводе.
        -Verb          | Получить команды (Cmdlet/function/workflow/alias) с указанным глаголом (1 часто команды)
        -ListImported  | Получить только команды в текущей сессии
        -ParameterName | Получить команды в сессии, у которых есть указанные параметры, плейсхолдеры поддерживаются
        -ParameterType | Получить команды в сессии, у которых есть параметры указанных типов, плейсхолдеры поддерживаются

        1. Получить список всех доступных командлетов/функций/процессов/псевдонимов,
           в Т.Ч. перечисленных в переменной PATH:

              Get-Command *

        2. Получить список всех командлетов:

              Get-Command -Type Cmdlet

        3. Получить информацию о команде по её псевдониму:

              Get-Command dir

        4. Получить список всех команд, у которых глагол = Get:

              Get-Command Get-*             | Способ 1
              Get-Command -Verb Get         | Способ 2

        5. Получить список всех команд, у которых существительное = Service:

              Get-Command *-Service         | Способ 1
              Get-Command -Noun Service     | Способ 2

        6. Получить список всех команд, у которых есть параметр Recurse:

              gcm -ParameterName recurse

        7. Получить список всех команд, которые заканчиваются на "Computer":

              gcm -name *computer

        8. Получить все команды из модуля Management:

              # Получить список всех доступных модулей можно командой:
              Get-Module -ListAvailable

              # Получить все команды из модуля Management
              gcm -Module Microsoft.PowerShell.Management


      # Update-Help             | Загружает обновлённую справку на компьютер

        1. Обновить справку для всех модулей

              Update-Help


      # Clear-Host              | Очистить окно консоли
        - Нет параметров

        1. Очистить окно консоли

              Clear-Host


      # Get-Service             | Отображает список сервисов на локальном или удалённом компьютере
        -ComputerName      | Получить сервисы на указанном компьютере (по умолчанию - localhost)
        -DependentServices | Получить только сервисы, которые зависят от указанного
        -DisplayName       | Получить только сервисы с указанными DisplayName. Плейсхолдеры разрешены.
        -Exclude           | Исключить указанные сервисы. Плейсхолдеры разрешены.
        -Include           | Получить только указанные сервисы. Плейсхолдеры разрешены.
        -InputObject       | Указать объекты ServiceController, представляющие сервисы, которые надо получить.
        -Name              | Указать name сервисов, которые надо получить.
        -RequiredServices  | Получтить только те сервисы, которые требуются длу указанного сервиса.

        1. Отобразить все имеющиеся сервисы на локальном компьютере:

              Get-Service

        2. Найти и отобразить все сервисы на локальном компьютере,
           имя (name) которых начинается с Apache

              Get-Service Apache*         | способ 1
              Get-Service -name Apache*   | способ 2

        3. Найти и отобразить все сервисы на локальном компьютере,
           имя (displayname) которых начинается с Apache

              Get-Service -displayname Apache*

        4. Найти и отобразить все сервисы на локальном компьютере,
            имя которых начинается с "win", исключая WinRM сервисы:

              get-service -name win* -exclude winrm


      # Stop-Service            | Остановить 1 или более запущенных сервисов
        -DisplayName       | Остановить только сервисы с указанными DisplayName. Плейсхолдеры разрешены.
        -Exclude           | Исключить (не останавливать) указанные сервисы. Плейсхолдеры разрешены.
        -Include           | Остановить только указанные сервисы. Плейсхолдеры разрешены.
        -Force             | Остановить сервис, даже если от него зависят другие сервисы
        -InputObject       | Указать объекты ServiceController, представляющие сервисы, которые надо получить.
        -Name              | Указать name сервисов, которые надо остановить.
        -PassThru          | Передаёт объект через пайп (по умолчанию Rename-Item не генерирует никаких выходных данных)
        -Confirm           | Запросить подтверждение операции
        -WhatIf            | Что случится, если командлет будет запущен (на самом деле он не запускается)

        1. Остановить сервис "SysmonLog" на локальном компьютере:

              Stop-Service sysmonlog

        2. Найти сервис с displayname = "telnet" на локальном компьютере,
           и сразу остановить его:

              Get-Service -displayneme telnet | Stop-Service


      # Start-Service           | Запустить 1 или более остановленных сервисов
        -DisplayName       | Запустить только сервисы с указанными DisplayName. Плейсхолдеры разрешены.
        -Exclude           | Исключить (не запускать) указанные сервисы. Плейсхолдеры разрешены.
        -Include           | Запустить только указанные сервисы. Плейсхолдеры разрешены.
        -InputObject       | Указать объекты ServiceController, представляющие сервисы, которые надо получить.
        -Name              | Указать name сервисов, которые надо запустить.
        -PassThru          | Передаёт объект через пайп (по умолчанию Rename-Item не генерирует никаких выходных данных)

        1. Запустить сервис "SysmonLog" на локальном компьютере:

              Start-Service sysmonlog

        2. Найти сервис с displayname = "telnet" на локальном компьютере,
           и сразу запустить его:

              Get-Service -displayneme telnet | Start-Service


      # Get-Member              | Получает свойства и методы объекта
        -Force       | Показывает больше всяких разных свойств
        -InputObject | Указать объект, чьи свойства надо извлечь
        -MemberType  | Извлечь только свойства указанных типов:
                       AliasProperty/All/CodeMethod/CodeProperty/Event/MemberSet/MemberSet/Method/Methods/Noteproperty/ParameterizedProperty/Properties/Property/PropertySet/ScriptMethod/ScriptProperty
        -Name        | Указать имя 1 или нескольких свойств, информацию о которых надо извлечь
        -Static      | Извлекает только статические свойства и методы объекта
        -View        | Извлекает только указанные типы свойств:
                       Base/Adapted/Extended/All

        1. Получить список элементов (свойств, методов, псевдонимов,
           событий и т.д.), которые содержит объект, который возвращает
           команда Get-Service. Для этого подадим этот объект на вход
           команды Get-Member:

              Get-Service | Get-Member


      # Get-Process             | Отображает список процессов на локальном или удалённом компьютере
        -ComputerName    | Получить процессы, запущенные на указанных компьютерах (по умолчанию localhost)
        -FileVersionInfo | Получить информацию о версии программы, которая запущена в процессе
        -Id              | Получить 1 или более процессов с указанными ID
        -InputObject     | Определяет 1 или более объектов-процессов
        -Module          | Получить модули, которые были загружены процессами
        -Name            | Получить 1 или более процессов по их name

        1. Получить список процессов, запущенных на локальном компьютере:

              Get-Process

        2. Вывести на экран всю возможноую информацию о процессе explorer:

              Get-Process explorer | Format-List *

        3. Найти все процессы, имя которых начинается с "KMP":

              Get-Process kmp*


      # Stop-Process            | Останавливает 1 или более запущенных процессов
        -Force       | Останавливает выбранный процесс без запроса подтверждения
        -Id          | Отстанавливает процесс с указанным ID.
        -inputObject | Останавливает процессы, представленные указанными объектами процессов
        -Name        | Остановливает процессы с указанными name
        -PassThru    | Передаёт объект через пайп (по умолчанию Rename-Item не генерирует никаких выходных данных)
        -Confirm     | Запросить подтверждение операции
        -WhatIf      | Что случится, если командлет будет запущен (на самом деле он не запускается)

        1. Остановить процесс, у которого name = "notepad"

              Start-Process notepad           | сначала запустим его
              Stop-Process -name notepad      | а затем остановим

        2. Остановить процесс с ID=3952. Но перед остановкой спросить у пользователя
           подтверждение (параметр -confirm). Для отображения данных тут
           присутствует параметр -passthru (без него ничего бы не отобразилось):

              stop-process -id 3952 -confirm -passthru

        3. Остановить

              Stop-Process -name kmp*

      # Start-Process                 | Запускает 1 или более процессов на локальном компьютере
        -ArgumentList           | Список параметров, с которыми запускать данный процесс
        -Credential             | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)             |
        -FilePath               | Указать [путь]\имя файла программы, которая запускается в процессе
        -LoadUserProfile        |
        -NoNewWindow            | Стартовать новый процесс в консоли. Не создавать окно (по умолчанию создаётся)
        -PassThru               | Возвращать объект процесса при его старте (по умолчанию никакого output не генерируется)
        -RedirectStandardError  | Записывать ошибки, генерируемые процессом, в указанный файл.
        -RedirectStandardInput  | Подавать input в процесс из указанного файла.
        -RedirectStandardOutput | Записывать output процесса в указанный файл.
        -UseNewEnvironment      | Использовать новые переменные среды для процесса.
                                  > По умолчанию процесс стартует с переменными среды компьютера и пользователя.
        -Verb                   | Указать действия при старте процесса (зависят от расширения файла)
                                  > Посмотреть доступные действия можно создав объект New-Object для целевого файла,
                                    и заглянув в его свойство Verbs.
        -Wait                   | Ждёт, пока указанный процесс завершится, перед приёмом новых входных данных.
        -WindowStyle            | Определяет состояние окна для нового процесса:
                                  Normal/Hidden/Minimized/Maximized (по умолчанию Normal)
        -WorkingDirectory       | Определяет путь к папке, где находится выполняемый файл, который запускается в процессе; по умолчанию - current directory.

        1. Запустить процесс, который использует notepad++.exe:

              Start-Process "C:\Program Files (x86)\Notepad++\notepad++.exe"

        2. Запустить PowerShell с привелегиями администратора:

              Start-Process powershell -verb runAs

        3. Как вывести на экран список доступных параметров (на примере powershell):

              $startExe = new-object System.Diagnostics.ProcessStartInfo -args PowerShell.exe
              $startExe.verbs

              Результат:
                open
                pintostartscreen
                runas
                runasuser


      # Stop-Computer           | Выключает локальный или удалённый компьютер

        1. Выключить локальный компьютер:

              Stop-Computer

        2. Выключить локальный компьютер (localhost) и еще 2 удалённых:

              Stop-Computer -computername Server01, Server02, localhost


      # Restart-Computer        | Перезагружает ОС на локальном или удалённом компьютере

        1. Перезагрузить локальный компьютер:

              Restart-Computer

        2. Перезагрузить локальный компьютер (localhost) и еще 2 удалённых:

              Restart-Computer -computername Server01, Server02, localhost


      # Rename-Computer         | Переименовать компьютер

        1. Переименовать локальный комеьютер в Server044 и затем перезагрузить
           его, чтобы изменения вступили в силу:

              Rename-Computer -NewName Server044 -DomainCredential Domain01\Admin01 -Restart


      # Get-Date                | Получить текущую дату и время

        1. Отобразить текущие дату и время:

              Get-Date

        2. Отобразить только дату:

              Get-Date -DisplayHint Date

        3. Отобразить только время:

              Get-Date -DisplayHint Time

        4. Отобразить дату и время в указанном формате:

              Get-Date -UFormat "%Y / %m / %d / %A / %Z"


      # Set-Date                | Установить дату и время

        1. Установить текущие дату и время на компьютере из переменной $t:

              $t = Get-Date
              Set-Date -date $t

        2. Добавить к текущим системным дате и времени 3 дня:

              Set-Date -Date (Get-Date).AddDays(3)

        3. Отнять от текущих системных даты и времени 10 минут:

              Set-Date -adjust -0:10:0 -displayHint time


      # Get-Module              | Возвращает импортированные в текущей сессии модули

        1. Получить модули, установленные в течение текущей сессии:

              Get-Module

        2. Получить модули, которые установлены на этом компьютере, и могут
           быть импортированы в течение текущей сессии:

              Get-Module -ListAvailable


      # Get-Alias               | Возвращает список псевдонимов для текущей сессии
        -Definition | Возвращает псевдонимы для указанного элемента
                      > Этот параметр называется Definition, потому что он ищет
                        имя элемента в св-ве Definition объекта-псевдонима.
                      > Плейсхолдеры разрешены
        -Exclude    | Не искать указанные здесь псевдонимы.
        -Name       | Возвращает элементы для указанного псевдонима, плейсхолдеры разрешены
        -Scope      | Возвращает только псевдонимы для указанной области видимости: Global/Local/Script

        1. Получить все псевдонимы для текущей сессии:

              Get-Alias

        2. Получить все псевдонимы, которые начинаются на "g" или "s",
           кроме тех, что начинаются с "get":

              Get-Alias -Name g*, s* -Exclude Get-*

        3. Получить все алиасы заданной команды. В этом примере, получим все
           алиасы команды Get-ChildItem:

              Get-Alias -Definition Get-ChildItem

        4. Получить имя команды по её псевдониму. В этом примере, получим
           имя команды с псевдонимом ls:

              Get-Alias ls

        5. Получить все алиасы для команд, имя которых начинается с "-PSSession",
           кроме тех, которые начинаются с "e":

              Get-Alias -Definition "*-PSSession" -Exclude e* -Scope Global


      # Set-Alias               | Создаёт/изменяет псевданим для командлета в текущей сессии
        -Description    | Описание псевданима
        -Force          | Если установлен, создаётся read-only псевдоним
        -Name           | Указать имя для устанавливаемого псевдонима
        -Option         | Установить значение свойства Options псевдонима:
                          None/ReadOnly/Constant/Private/AllScope
        -Value          | Имя команды, для которой устанавливается псевдоним
        -PassThru       | Передаёт объект через пайп (по умолчанию Set-Alias не генерирует никаких выходных данных)
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)

        1. Создать псевдоним "list" для команды Get-ChildItem, который будет
           действовать в течение текущей сессии:

              Set-Alias -name list -value Get-ChildItem

        2. Сделать так, чтобы существующий псевдоним "list" большен не указывал
           на команду Get-ChildItem, а указывал на команду Get-Location

              Set-Alias list Get-Location

        3. Связать псевдоним np с исполняемым файлом notepad.exe для текущей
           сессии. В результате чего notepad будет запускаться, если ввести
           команду np:

              Set-Alias np c:\windows\notepad.exe       | Вариант 1
              Set-Alias np ${env:windir}\notepad.exe    | Вариант 2

        4. Создать функцию CD32, и создать для неё псевдоним go. При вводе
           "go" будет выполняться эта функция:

              function CD32 { Set-Location c:\windows\system32 }
              Set-Alias go CD32

        5. Как создать постоянный псевдоним в powershell, который держится
           не в течение сессии до 1-го закрытия оболочки, а на постоянной
           основе?

            1) Концепция такова:

                Каждый раз, когда ты создаёшь новый экземпляр powershell,
                выполняется скрипт твоего профиля ("profile script").
                Так что этот скрипт - лучший претендент на то, чтобы запихнуть
                команды по созданию псевдонимов в него.

                Для работы с псевдонимами нам пригодятся 2 команды:
                - Export-Alias
                - Import-Alias

                Концепция такова:
                > Когда у нас появляются новые псевдонимы, мы экспортируем
                  их в .txt файл с помощью команды Export-Alias. В этом файле
                  мы храним все наши псевдонимы.
                > В файл "profile script" мы добавляем команду Import-Alias,
                  которая импортирует из вышеуказанного .txt файла все псевдонимы
                  прямо в текущую сессию.

                Примеры использовани этих команд:
                - Export-Alias c:\aliases.txt               | экспорт псевдонимов в .txt файл
                - Export-Alias c:\aliases.txt –noclobber    | не перезаписывать существующие
                - Export-Alias c:\aliases.txt -append       | добавить не существующие, не перезаписывать существующие
                - Import-Alias c:\aliases.txt               | импортировать псевдонимы из .txt файла в текущую сессию

            2) Посмотреть полный путь к текущему "profile script" можно,
               введя команду ниже. Причём:
               - Даже если команда вернёт путь, это ещё не значит, что файл
                 физически существует по данному пути.

                    $profile

            3) Проверить, существует ли физически "profile script" по пути
               $profile можно с помощью команды Test-Path:
               - True: существует
               - False: не существует

                    Test-Path $profile

            4) Создать файл "profile script" можно одной из следующих команд:

                    notepad $profile                            | вариант 1
                    New-Item -path $profile -type file -force   | вариант 2

            5) Открыть созданный файл "profile script" можно той же командой:

                    notepad $profile

            6) Всё, теперь можно в этот файл писать любые команды, и они
               будут выполняться каждый раз при старте powershell.

            7) Добавим в файл команду, которая меняет папку "по умолчанию"
               при запуске powershell. Добавим в "profile script" команду:

                    Set-Location "C:\Users\Administrator\Desktop\Practice\Web Library"

            8) Добавим команду, импортирующую сохранённые в .txt файле псевдонимы
               прямо в текущую сессию:

                    Import-Alias "C:\Program Files\ConEmuPack\ps_aliases.txt"

            9) Чтобы "profile script" мог исполниться, надо проверить какая
               установлена политика выполнения скриптов (execution policy).
               > По умолчанию в PowerShell установлена политика: "restricted",
                 что означает, что скрипт не выполнится, и будет ошибка.
               > Список всех доступных "execution policy" можно посмотреть
                 по ссылке ниже:
                        http://technet.microsoft.com/ru-RU/library/hh847748.aspx
               > Узнать текущую "execution policy" можно с помощью команды:

                      Get-ExecutionPolicy

               > Посмотреть список политик на разных уровнях, которые влияют на
                 текущую сессию, можно с помощью команды:

                      Get-ExecutionPolicy -List

               > Изменить текущую "execution policy" можно с помощью команды
                 Set-ExecutionPolicy, PowerShell должен быть запущен с правами
                 администратора.
               > По умолчанию "execution policy" командой Set-ExecutionPolicy
                 меняется для уровня LocalMachine. Поставим для же для
                 этого уровня значение AllSigned:

                      Set-ExecutionPolicy RemoteSigned

               > Чтобы изменить "execution policy" для другого уровня можно
                 воспользоваться следующим шаблоном:

                      Set-ExecutionPolicy --ExecutionPolicy <PolicyName> -Scope <scope>

               > Чтобы удалить "execution policy" на уровне LocalMachine:

                      Set-ExecutionPolicy Undefined

               > Чтобы удалить "execution policy" на любом уровне, можно
                 воспользоваться следующим шаблоном:

                      Set-ExecutionPolicy Undefined -scope LocalMachine


      # Format-List             | Форматирует вывод как список параметров, каждый из которых появляется в отдельной строке
        -DisplayError   | Отображает ошибки в командной строки
        -Force          | Отображать всю информацию об ошибках
        -GroupBy        | Сгруппировать вывод по указанному полю
        -Property       | Через запятую указать св-ва, которые надо выводить (если не указать, будут выведены все)
        -ShowError      | Послать ошибки через пайп


        1. Получить полную справку по всем параметрам команды New-Item,
           и отформатировать вывод в виде списка:

                Get-Help New-Item -parameter * | format-list

        2. Получить ту же самую справку, но только чтобы в выводе присутствовали
           только поля name, desctiption

                Get-Help New-Item -parameter * | format-list -property name, description


      # Format-Table            | Форматирует вывод как таблицу
        -AutoSize       | Подогнать ширину колонок по размеру данных
        -Wrap           | !! Подогнать высоту ячеек (не обрезать, переносить текст)
        -DisplayError   | Отображает ошибки в командной строки
        -Force          | Отображать всю информацию об ошибках
        -GroupBy        | Сгруппировать вывод по указанному полю
        -HideTableHeaders  | Спрятать заголовки таблицы
        -InputObject    | Вхоной объект или объекты для форматирования
        -Property       | Через запятую указать св-ва, которые надо выводить (если не указать, будут выведены все)
        -ShowError      | Послать ошибки через пайп


        1. Получить полную справку по всем параметрам команды New-Item,
           и отформатировать вывод в виде таблицы:

                Get-Help New-Item -parameter * | Format-Table

        2. Получить ту же самую справку, но только чтобы в выводе присутствовали
           только поля name, desctiption. С помощью параметра -Wrap сделать так,
           чтобы текст в ячейках не был обрезан, а был перенесён:

                Get-Help New-Item -parameter * | Format-Table -property name, description -Wrap


      # Out-Host             | Ставится в конец конвейера, для постраничного вывода большого объёма данных
        -InputObject  | Указать объекты, которые надо выводить в консоль.
        -Paging       | Отображать по 1 странице за раз и ждать команды от пользователя,
                        чтобы показать ещё одну.

            1. Команда Get-Command (gcm) выдаёт очень большой объём данных
               на выходе. Так, что он не умещается в консоль. Воспользовавшись
               концепцией конвейера и командой Out-Host с параметром -paging,
               организовать постраничный вывод этих больших объёмов данных:

                  gcm | oh -paging


      # Out-File         |       | Отправляет выходы в файл, ставится в коней конвейера
        -Append       | Если выходной файл существует, добавить вывод к его содержимому
        -Encoding     | Кодировка. По умолчанию Unicode.
                        > Unicode/UTF7/UTF8/UTF32/ASCII/BigEndianUnicode/Default/OEM
        -FilePath     | Путь к файлу для вывода. Плейсхолдеры разрешены, но результат должен быть 1.
        -Force        | Позволяет команде перезаписать уже существующий read-only файл.
        -InputObject  | Указать входной объект
        -NoClobber    | Не перезаписывать контент выходного файла, если он существует
                        > По умолчанию (без этой опции) контент будет перезаписан
                        > Если применены одновременно -NoClobber и -Append, то
                          данные будут добавлены к уже существующим в файле данным
        -Width        | Указать MAX кол-во симсолов в каждой строке вывода, лишние будут обрезаны
        -LiteralPath  | Путь к файлу для вывода. Плеёсхолдеры запрещены.
        -Confirm      | Запросить подтверждение операции
        -WhatIf       | Что случится, если командлет будет запущен (на самом деле он не запускается)


            1. Сохранить список запущенных на компьютере процессов
               в файл процессы.txt в текущей папке:

                  Get-Process | Out-File -filepath .\процессы.txt

            2. Найти все команды, кончающиеся на item, и сохранить
               результат в файл процессы.txt. Содержимое файла не должно
               быть перезаписано, а новые данные должны быть добавлены
               в конец:

                  Get-Command *-item | Out-File -noclobber -append -filepath .\процессы.txt


      # New-Item      | Создать новый элемент в текущей папке.
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Force          | Позволяет перезаписать read-only элемент + если надо создает новые папки автоматом
        -ItemType       | Тип элемента (file, folder, ...)
        -Name           | Имя элемента
        -Path           | Путь. Можно указать здесь, а можно в Name. Плейсхолдеры разрешены.
        -Value          | Значение. Можно также передать значение через пайп на вход New-Item
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Создать в текущей директории "." текстовый файл "text.txt",
             и записать в него строку "Это мой текст, детка":

                  New-Item -path . -name text.txt -itemtype "file" -value "Это мой текст, детка"

          2. Создать в текущей директории новую директорию "NewFolder":

                  New-Item -name NewFolder -itemtype "directory"

          3. Создать новый файл для "profile script":

                  new-item -path $profile -itemtype file -force

          4. Создать одной командой 2 файла (надо писать их path чере запятую):

                  New-Item -itemtype "file" -path fileOne.txt, fileTwo.txt



      # Remove-Item   | Удалить указанные элементы.
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Exclude        | Не удатять указанные эл-ты. Плейсхолдеры разрешены (например, *.txt)
        -Include        | Удалить только указанные эл-ты. Плейсхолдеры разрешены (например, *.txt)
        -Filter         |
        -Force          | Позволяет удалять read-only или hidden файлы, которые в ином случае бы не удалились
        -Path           | Путь к эл-там, которые должны быть удалены
        -Recurse        | Удаляет указанные эл-ты по указанному Path и рекурсивно вглубь
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Удалить из директории c:\Test все файлы, в имени которых
             встречается точка . :

                  Remove-Item C:\Test\*.*

          2. Удалить файл fileTwo.txt из текущей директории:

                  Remove-Item fileTwo.txt

          3. Удалить из текущий директории все элементы, которые кончаются
             на ".doc", но у которых в имени нет символа "1":

                  Remove-Item * -include *.doc -exclude *1*

          4. Удалить из указанной директории, а также из всех её поддиректорий
             все файлы типы .txt:

                  Remove-Item C:\Text\ -include *.txt -Recurse

             ... и даже "hidden" и "read-only":

                  Remove-Item C:\Text\ -include *.txt -Recurse -Force


      # Rename-Item   | Переименовать элемент.
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Force          | Позволяет переименовать read-only или hidden файлы, которые в ином случае бы не удалились
        -NewName        | Новое имя эл-та. Без пути, только имя.
        -PassThru       | Передаёт объект через пайп (по умолчанию Rename-Item не генерирует никаких выходных данных)
        -Path           | Путь к элементу, который надо переименовать
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Переименовать файл fileOne.txt в текущей директории в
             superFile.txt:

                  Rename-Item fileOne.txt -NewName superFile.txt

          2. Переименовать файл superFile.txt по адресу "C:\Users\Administrator\Desktop\Practice\Web Library"
             в megaTonFile.txt:

                  Rename-Item -path "C:\Users\Administrator\Desktop\Practice\Web Library\superFile.txt" -NewName megaTonFile.txt


      # Move-Item     | Переместить элемент из одного места в другое.
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Force          | Позволяет переместить read-only или hidden файлы, которые в ином случае бы не удалились
        -Destination    | Путь, куда переместить элемент.
        -Exclude        | Не перемещать указанные эл-ты. Плейсхолдеры разрешены (например, *.txt)
        -Include        | Переместить только указанные эл-ты. Плейсхолдеры разрешены (например, *.txt)
        -PassThru       | Передаёт объект через пайп (по умолчанию Rename-Item не генерирует никаких выходных данных)
        -Path           | Путь к элементу, который надо переместить
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Переместить файл megaTonFile.txt из текущей папки в папку \NewFolder:

                Move-Item -path megaTonFile.txt -destination .\NewFolder

          2. Переместить файл megaTonFile.txt из папки \NewFolder в текущую:

                Move-Item -path .\NewFolder\megaTonFile.txt -destination .

          3. Переместить все файлы .txt из текущей папки в папку \NewFolder:

                Move-Item -path .\*.txt -destination .\NewFolder

          4. Переместить все файлы .txt из папки .\NewFolder\ в текущую:

                Move-Item -path .\NewFolder\*.txt -destination .

          5. Переместить все файлы .txt из текущей папки и всех её подпапок
             в папку .\NewFolder:

                Get-ChildItem -path .\*.txt -recurse | Move-Item -destination .\NewFolder


      # Copy-Item     | Скопировать элемент из одного места в другое.
        -Container
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Force          | Позволяет скопировать read-only файл или псевдоним, которые в ином случае нельзя было бы
        -Destination    | Путь, куда скопировать элемент.
        -Exclude        | Не копировать указанные эл-ты. Плейсхолдеры разрешены (например, *.txt)
        -Include        | Копировать только указанные эл-ты. Плейсхолдеры разрешены (например, *.txt)
        -PassThru       | Передаёт объект через пайп (по умолчанию Rename-Item не генерирует никаких выходных данных)
        -Path           | Путь к элементу, который надо переместить
        -Recurse        | Копирует указанные эл-ты рекурсивно
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Скопировать файл text.txt из текущей папки в текущую же папку,
             но с именем text2.txt:

                Copy-Item text.txt -destination text2.txt

          2. Скопировать файл text.txt из текущей папки в папку .\NewFolder:

                Copy-Item text.txt -destination .\NewFolder


      # Invoke-Item   | Выполнить действие "по умолчанию" для этого элемента
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Exclude        | Не выполнять для указанных эл-тов. Плейсхолдеры разрешены (например, *.txt)
        -Include        | Выполнять только для указанных эл-тов. Плейсхолдеры разрешены (например, *.txt)
        -Path           | Путь к элементу, для которого надо выполнить действие "по умолчанию"
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Открыть проводник windows и в нём указанную папку:
             - Действие по умолчанию - это то, что происходит, когда 2 раза
               кликаешь мышкой по элементу.
             - Для папки - это открыть эту папку в проводнике Windows.

                Invoke-Item "C:\Users\Administrator\Desktop\Practice\Web Library"

          2. Запустить файл text.txt в текущей папке:

                Invoke-Item text.txt

          3. Запустить все .txt файлы в этой папке (не рекурсивно):

                Invoke-Item *.txt


      # Get-Item      | Получить объект элемента по указанному адресу
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Exclude        | Не выполнять для указанных эл-тов. Плейсхолдеры разрешены (например, *.txt)
        -Include        | Выполнять только для указанных эл-тов. Плейсхолдеры разрешены (например, *.txt)
        -Force          | Позволяет команде установить значения эл-тов, которые в ином случае бы не установились
        -Path           | Путь к элементу
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Получить элемент, представляющий текущую папку:

                Get-Item .

          2. Получить все эл-ты, находящиеся в текущей папке:

                Get-Item *

          3. Получить папку по указанному адресу:

                Get-Item C:\

          4. Получить объект текущей папки и посмотреть все его свойства и
             методы:

                (Get-Item .) | Get-Member

          5. Получить дату и время, когда в текущей папке последний раз
             что-либо изменялось:

                (Get-Item .).LastAccessTime

          6. Получить дату и время создания текущей папки:

                (Get-Item .).CreationTime


      # Set-Item      | Изменить значение элемента на указанное по указанному адресу
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Exclude        | Не выполнять для указанных эл-тов. Плейсхолдеры разрешены (например, *.txt)
        -Include        | Выполнять только для указанных эл-тов. Плейсхолдеры разрешены (например, *.txt)
        -Force          | Позволяет команде установить значения эл-тов, которые в ином случае бы не установились
        -Value          | Указывает новое значение для элемента
        -Path           | Путь к элементу
        -Confirm        | Запросить подтверждение операции
        -WhatIf         | Что случится, если командлет будет запущен (на самом деле он не запускается)
        -UseTransaction | Использовать транзакционный метод создания элемента (если что не так, будет откат)

          1. Создать псевдоним "np" для notepad.exe:

                Set-Item -path alias:np -value c:\windows\notepad.exe

          2. Изменить значение переменной среды "UserRole" на "Administrator"

                Set-Item -path env:UserRole -value Administrator

          3. Изменить значение функции prompt так, чтобы она показывала
             время перед путём:
             - В командной строки перед каждой командой в powershell обычно
               отображается надпись "PS <путь к текущей папке>".
             - Так вот, эту надпись выводит функцию prompt. Если её изменить,
               то надпись может быть и другая.

                Set-Item -path function:prompt -value {'PS '+ $(Get-Date -format t) + " " + $(Get-Location) + '> '}


      # Get-Location  | gl, pwd | Получить текущее месторасположение
        -PSDrive        | Получить текущее местоположение на указанном диске PowerShell
        -PSProvider     | Получить текущее положение на диске, поддерживаемом указанным проводником Windows PowerShell
        -Stack          | Отобразить положение в текущем стеке расположений
        -StackName      | Отобразить положение в указанном по имени стеке расположений
        -UseTransaction | Использовать транзации

          1. Получить текущее месторасположение на текущем PS-диске:

              Get-Location  | Способ 1
              gl            | Способ 2
              pwd           | Способ 3


      # Set-Location  | sl, cd  | Установить текущее месторасположение
        -LiteralPath    | Путь к новому местоположению, плейсхолдеры запрещены.
        -PassThru       | Вернуть следующий объект, который представляет местоположение: System.Management.Automation.PathInfo
        -Path           | Путь к новому местоположению
        -StackName      | Указать альтернативное местоположение для перехода "назад" вслучае надобности
                          > При переходе "назад" по умолчанию будет стоять старое местоположение
        -UseTransaction | Использовать транзакции.

          1. Перейти в корень диска C:\

              Set-Location C:\      | Вариант 1
              cd C:\                | Вариант 2
              sl C:\                | Вариант 3

          2. Перейти в корень диска HKLM:

              Set-Location HKLM:


      # Out-String               | Ставится в конец конвейера, накапливает входные строки и возвращает одну большую выходную
                                   > С помощью параметра stream можно настроить команду так,
                                     чтобы она выдавала на выход по 1-й строке за раз
        -InputObject | Объекты, из которых будут извлечены строки
        -Stream      | Посылает строки для каждого объекта по 1-й за раз
        -Width       | Ограничивает MAX кол-во символов в одной строки вывода за раз

          1.


      # Get-Content              | Прочитать содержимое элемента
                                   > Читает содержимое по 1-й строке за раз, и возвращает
                                     набор объектов, каждый из которых представляет отдельную строку
        -Credential     | Имя аккаунта, от чьего имени выполняем операцию (по умолчанию current user)
        -Exclude        | Исплючить указанные файлы. Плейсхолдеры допустимы.
        -Include        | Включить указанные файлы. Плейсхолдуры допустимы.
        -Filter         |
        -Force          | Отмахнуться от ограничений, которые могут не дать команде успешно выполнитсья.
        -LiteralPath    | Путь к элементу, без плейсхолдеров.
        -Path           | Путь к элементу, плейсхолдеры допустимы
        -ReadCount      | Сколько строк посылается через пайп за раз (по умолчанию 1)
        -TotalCount     | Ограничить MAX кол-во читаемых с начала файла строк (по умолчанию -1 - не ограничено)
        -Tail           | Ограничить MAX кол-во читаемых с конца файла строк (по умолчанию -1 - не ограничено)
        -UseTransaction | Использовать транзакции

         1. Прочитать контент файла composer.php из текущей директории.
            Читать по 1-й строке за раз, и сразу выполнять с помощью
            интерпретатора PHP:

              Get-Content -path composer.php | php


      # Get-ChildItem | ls      | Получает и выводит список элементов в текущей (по умолчанию) или указанных папках
        -Exclude        | Исключить следующие эл-ты из вывода
        -Include        | Выводить только указанные эл-ты
        -Filter         |
        -Force          | Позволяет получить эл-ты, которые без этого параметра нельзя было бы получить, такие как скрытые или системные файлы
        -LiteralPath    | Один или несколько путей к папкам (по умолчанию - текущая папка), плейсхолдеры запрещены.
        -Name           | Получает только именя эл-тов, без всего остального
        -Path           | Один или несколько путей к папкам (по умолчанию - текущая папка), плейсхолдеры разрешены.
        -Recurse        | Получить также рекурсивно эл-ты из всех дочерних папок.
        -UseTransaction | Использовать транзакции

        1. Получить список эл-тов в текущей папке:

            Get-ChildItem       | способ 1
            ls                  | способ 2





||                            ||
================================
 Bash
================================
||                            ||



> Bash

  > Основное назначение
    > Работать с Git.
    > Для всего остального в Windows - использовать PowerShell.

  > Как добавлять постоянные alias в bash

    > Команда alias
      > С помощью команды alias можно сделать так, чтобы набор bash-команд
        выполнялся при вводе назначенного имени.

    > Постоянные alias
      > Если просто использовать команду alias в bash, то эффект сохранится
        только в течение текущей сессии. А как только шел будет закрыт,
        эффект пропадёт.
      > Чтобы сделать действие alias постоянным, надо создать конфигурационный
        файл для bash по адресу ~/.bashrc
        > В баше символ ~ означает "домашняя директория".
        > Посмотреть её можно, введя в баш: echo ~
        > Создать вышеуказанный файл можно командой:

            notepad ~/.bashrc

    > Назначить alias для composer
      > Задача
        > Папка в которой лежит composer.phar уже должна быть добавлена в
          PATH Windows.
        > Bash видит содержимое PATH. Но если в нём просто написать composer,
          то это не сработает. Надо писать полное имя с расширением: composer.phar.
        > Полная команда выглядит так:

            composer.phar

        > Задача в том, чтобы сократить её до: composer
      > Решение
        > Надо сохранить в конфиге баша .bashrc следующую команду:

          alias composer='php composer.phar'






-------------------------------------------------- */





















