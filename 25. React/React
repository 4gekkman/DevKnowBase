////=================================================////
////                                                 ////
////                  Facebook React                 ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Сайт React
        https://facebook.github.io/react/

    # GitHub репозиторий React
        https://github.com/facebook/react

    # Документация React
        https://facebook.github.io/react/docs

    # Блог React
        https://facebook.github.io/react/blog/

    # Официально одобренные дополнительные инструменты
        https://github.com/facebook/react/wiki/Complementary-Tools

    # Официально одобренные примеры кода
        https://github.com/facebook/react/wiki/Examples

    # Туториал
        https://facebook.github.io/react/docs/tutorial.html

  // Неофициальные ресурсы //
  //-----------------------//

    # Качественный код от сообщества React
        https://github.com/reactjs

    # React.js курс для начинающих (от maxfarseer@gmail.com)
        https://maxfarseer.gitbooks.io/react-course-ru/content/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Основы

    А1. Что такое React
    А2. Плюсы и минусы React
    А3. Hello world на React
    А4. Думай в стиле React

  # Б.  Туториал

    Б1.

  # В.  Справочники

    Г1.

  # Я.  Рецепты и наработки

    Я1.


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Что такое React

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Факты о React

      ▪ React, это open source проект
      ▪ React, это JS библиотека
      ▪ React нужен для отрисовки пользовательских интерфейсов
      ▪ React декларативен
      ▪ В основе React лежат компоненты
      ▪ React может использоваться с любым стеком технологий
      ▪ Нисходящий поток данных
      ▪ React уже сейчас используется на многих крупных сайтах

    # История React кратко

      ▪ React создал Jordan Walke
      ▪ Он создал React под впечатлением от XHP
      ▪ Впервые React засветился в 2011-м
      ▪ А React Native впервые засветился в 2015-м

    # Особенности React

      ▪ Однонаправленный нисходящий поток данных
      ▪ Виртуальный DOM
      ▪ Синтаксис JSX
      ▪ React Native

  --------------------------------------

  > Ссылки

    # Официальный сайт React
        https://facebook.github.io/react/

    # Страница про React в Wiki (en)
        https://en.wikipedia.org/wiki/React_(JavaScript_library)

  > Введение
    - В этой главе собраны общие сведения про React.

  > Факты о React

    • React, это open source проект
      - Входит в TOP-2 всех open source проектов Facebook.
      - И находится на 6-м месте на github по кол-ву присвоенных
        звёзд за всё время.

    • React, это JS библиотека
      - React, это JS библиотека.
      - Не фреймворк, а именно библиотека.

    • React нужен для отрисовки пользовательских интерфейсов
      - То есть, он помогает создавать клиентские интерфейсы.
      - Об этом так и пишут на официальном сайте React:
        "A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES".

    • React декларативен
      - Создаёшь простые представления для каждого состояния приложения.
      - И React обновляет и отрисовывает представление именно того
        компонента, для которых изменились данные.

    • В основе React лежат компоненты
      - Вся разработка на React построена вокруг компонентов.
      - Компоненты React могут быть вложены друг в друга, как матрёшки,
        образуя древообразную структуру.
      - Совокупность этих компонентов и образуют Rich UI.

    • React может использоваться с любым стеком технологий
      - PHP, NodeJS, и т.д.
      - Создатели React не проектировали его для какого-то конкретного стека.
      - Но всё же, лучше всего использовать его с NodeJS, поскольку
        это даёт расширенные возможности, например, возможность рендеринга
        стартовых состояний представлений на сервере.

    • Нисходящий поток данных
      - Выше упоминалось, что в React компоненты образуют древообразную структуру.
      - И в этой структуре данные могут течь лишь вниз, от корня по веткам.
      - То есть, компоненты-детки никак не могут изменять своих компонентов-родителей.

    • React уже сейчас используется на многих крупных сайтах
      - https://www.airbnb.ru
      - https://feedly.com
      - http://bleacherreport.com
      - https://imgur.com
      - https://www.netflix.com

  > История React кратко

    • React создал Jordan Walke
      - Программист из Facebook.

    • Он создал React под впечатлением от XHP
      - XHP, это дополнение к PHP, и грязный хак, созданный в Facebook.
      - Он позволяет использовать синтаксис XML для создания кастомных
        и реюзабельных HTML-элементов.

    • Впервые React засветился в 2011-м
      - В новострой ленте Facebook, и в 2012-м на instagram.com.

    • А React Native впервые засветился в 2015-м
      - На конференции Facebook's React.js.

  > Особенности React

    • Однонаправленный нисходящий поток данных

      ▪ Как работает 2-направленный binding в Knockout
        - В KO ты создаёшь в модели какое-нибудь свойство.
        - И связываешь это свойство с каким-нибудь DOM-элементом.
        - Например, это значение какого-нибудь текстового input.
        - Направление 1: ты меняешь значение св-ва в модели,
                         и меняется значение в представлении.
        - Направление 2: ты меняешь значение св-ва в представлении,
                         и меняется св-во в модели.


           input                ko.observable
           --------   ------>   ---------
           | View |             | Model |
           --------   <------   ---------


      ▪ Как работает 1-направленный binding в React

        ▪ Данные текут вниз
          - Props, States, Handlers, Styles - всё это может быть
            передано деткам через props.
          - Props не могут изменяться детками, а States могут.

        ▪ События текут вверх
          - Через переданные родителями обработчики событий.

        ▪ Иллюстрация

              --------------------
              | Parent component |
              --------------------
                ||           /\
                ||           ||
                || data      || events
                ||           ||
                ||           ||
                \/           ||
              -------------------
              | Child component |
              -------------------

    • Виртуальный DOM

      ▪ DOM в памяти
        - React создаёт в памяти копию реального DOM.

      ▪ Сначала калькуляции, потом изменения реального DOM
        - Когда требуется, React не сразу вносит изменерия в реальный DOM.
        - Сначала он вносит все изменения в виртуальный DOM.
        - Потом составляет план изменений в реальный DOM, исходя из
          минимизации "стоимости" этих изменений. Чем меньше "стоимость",
          тем быстрее эти изменения будут проведены.
        - И лишь после этого вносит изменения в реальный DOM, в соотв. с планом.
        - Это позволяет существенно повысить производительность.

      ▪ Это даёт возможность разработчику не париться по поводу производительности
        - Я имею в виду в той части проблем, которые решает виртуальный DOM.
        - То есть писать код так, как если бы всё представление должно было бы
          перерисовываться при каждом изменении.
        - Но этого не будет происходить благодаря такой вот умной системе виртуального DOM.

    • Синтаксис JSX

      ▪ Что такое JSX
        - XML-надстрока над JS от разработчиков React.
        - JSX не является, и не будет являться частью ECMAScript.

      ▪ Суть JSX
        - Ты пишешь код на JSX в JS-файле.
        - Затем специальный препроцессором обрабатываешь этот файл.
        - JSX-код преобразуется транспайлером в обычный JS-код.

      ▪ Зачем нужен JSX

        ▪ В JS нет многострочных текстов
          - А ведь как-то надо писать многострочную разметку для компонентов.
          - Есть разные костыли, позволяющие писать многострочные тексты.
          - Но разработчики React решили создать свой костыль в виде JSX.

        ▪ React-специфичные фишки
          - Весь JSX код потом преобразуется транспайлером в JS.
          - Что позволило разработчикам React включить фантазию, и приправить
            всё это дело функционалом на свой вкус.
          - Например, возможность подключать прямо в JSX дочерние компоненты.

        ▪ Никто не заставляет использовать JSX
          - Как видно из примера ниже, можно обходиться и без JSX вообще.
          - Однако, работа без JSX - удобство сомнительное.

        ▪ Пример одного и того же кода

          ▪ Без JSX

              class HelloMessage extends React.Component {
                render() {
                  return React.createElement(
                    "div",
                    null,
                    "Hello ",
                    this.props.name
                  );
                }
              }
              ReactDOM.render(React.createElement(HelloMessage, { name: "John" }), mountNode);

          ▪ С JSX

              class HelloMessage extends React.Component {
                render() {
                  return <div>Hello {this.props.name}</div>;
                }
              }
              ReactDOM.render(<HelloMessage name="John" />, mountNode);

    • React Native
      - Библиотеки React Native представлены в 2015-м году.
      - Они позволяют писать нативные iOS- и Android-приложения,
        используя архитектуру React.


А2. Плюсы и минусы React

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Плюсы

      • React быстрее Knockout / Angular

        ▪ Реакт разрабатывался с акцентом на скорость
        ▪ React реализует браузерно-независимые системы DOM и событий
        ▪ Тест скорости говорит, что React быстрее Knockout / Angular

      • Компонентный подход, реюзабельность компонентов

        ▪ Два подхода: не компонентный / компонентный
        ▪ Компоненты React лучше компонентов Knockout
        ▪ Компонентный подход средних/крупных приложений

      • React Native (мобильные приложения)

        ▪ Можно делать мобильные приложения на Javascript/React
        ▪ React Native использует ту же архитектуру, что React

      • Хорошая поддержка (Facebook & Instagram & Community)

        ▪ Разработку поддерживают крупные компании
        ▪ Вокруг React большое сообщество

      • Трендовая и востребованная всеми библиотека

        ▪ Используется во многих проектах
        ▪ Востребована работодателями, много вакансий
        ▪ Обрастает большим кол-вом доп.кода и документации
        ▪ Легче найти специалистов

      • Возможность рендерить стартовые состояния на сервере (для NodeJS)

        ▪ Что очень важно для SEO
        ▪ Ускорение стартовой загрузки документов

      • Хорошо подходит для командной разработки

        ▪ Каждый может работать над своим компонентом
        ▪ Тимлид может контролировать, как потом эти компоненты должны взаимодействовать

      • Хорошая масштабируемость

        ▪ Благодаря компонентному подходу, React-приложения хорошо масштабируются

    # Минусы

      • Сложнее и запутаннее, чем KnockoutJS
      • Документация хуже, чем у KnockoutJS
      • Не поддерживает браузеры <= IE8
      • React не лучший вариант для малых приложений
      • Придётся использовать JSX
      • Придётся использовать много доп.инструментов

  --------------------------------------

  > Ссылки

      # Тест скорости работы React / Knockout / Angular
          https://www.codementor.io/reactjs/tutorial/reactjs-vs-angular-js-performance-comparison-knockout

      # Официальный сайт React Native
          https://facebook.github.io/react-native/

  > Введение
    - Кратко рассматриваются наиболее выдающиеся плюсы и минусы React.
    - Я буду сравнивать с KnockoutJS, т.к. хорошо её знаю, и имею большой опыт.

  > Плюсы

    • React быстрее Knockout / Angular

      ▪ Реакт разрабатывался с акцентом на скорость
        - Есть основания предполагать, что React будет быстрее Knockout.

      ▪ React реализует браузерно-независимые системы DOM и событий
        - Для ускорения работы, и кроссбраузерности.

      ▪ Тест скорости говорит, что React быстрее Knockout / Angular
        - См.ссылку в разделе "Ссылки" выше.

    • Компонентный подход, реюзабельность компонентов

      ▪ Два подхода: не компонентный / компонентный

        1) Не компонентный подход
          - KnockoutJS разрабатывался с не компонентным подходом.
          - Где в одной модели всё смешивалось в кучу.
          - Очень часто, по принципу: 1 документ, 1 модель.
          - И лишь в поздних версиях появились компоненты.
          - Этот подход лучше годится для малых и средних приложений.

        2) Компонентный подход
          - ReactJS изначально разрабатывался с компонентным подходом.
          - В нём нет другого варианта, только писать компоненты, и всё.
          - Этот подход лучше годится для средних и крупных приложений.

      ▪ Компоненты React лучше компонентов Knockout
        - Потому React изначально разрабатывался с компонентным подходом.
        - И в нём всё заточено под работу с компонентами.

      ▪ Компонентный подход средних/крупных приложений
        - Например, у нас интернет магазин, в котором есть товарные позиции.
        - Эти товарные позиции встречаются в 10 разных документах этого магазина.
        - Без компонентного подхода, в каждом документе понадобилось бы использовать
          свою отдельную копию модели товарных позиций.
        - С компонентным подходом, надо создать лишь 1-ин компонент, который
          и использовать во всех 10 документах.

    • React Native (мобильные приложения)

      ▪ Можно делать мобильные приложения на Javascript/React
        - Причём, это будут нативные мобильные приложения.

      ▪ React Native использует ту же архитектуру, что React
        - То есть, можно использовать знания Javascript/React для разработки моб.приложений.

    • Хорошая поддержка (Facebook & Instagram & Community)

      ▪ Разработку поддерживают крупные компании
        - В качестве разработчиков не выступают 1.5 человека.
        - А выступают крупные компании, Facebook и Instagram.
        - Так что вероятность внезапного прекращения поддержки мала.

      ▪ Вокруг React большое сообщество
        - Эта библиотека является трендовой.
        - Поэтому её изучают много людей.
        - И они пишут много кода и доп.инструментов по работе с ней.
        - А также много туториалов, гайдов и другой обучающей литературы.

    • Трендовая и востребованная всеми библиотека

      ▪ Используется во многих проектах
      ▪ Востребована работодателями, много вакансий
      ▪ Обрастает большим кол-вом доп.кода и документации
      ▪ Легче найти специалистов

    • Возможность рендерить стартовые состояния на сервере (для NodeJS)

      ▪ Что очень важно для SEO
        - SEO-роботы, в настоящий момент (2016), не исполняют JS.
        - Они видят только то, что им отдал сервер.
        - А то, что отрисовано после JS, они не видят.
        - А значит, и не учитывают это в индексации твоего сайта.
        - Поэтому, индексируемый контент надо рендерить на серваке.

      ▪ Ускорение стартовой загрузки документов
        - Как правило, сервак работает быстрее, чем комп клиента.
        - Поэтому, он может быстрее отрендерить JS в представлении, чем клиентю.
        - Что может существенно ускорить загрузку документов для клиентов.

    • Хорошо подходит для командной разработки

      ▪ Каждый может работать над своим компонентом
      ▪ Тимлид может контролировать, как потом эти компоненты должны взаимодействовать

    • Хорошая масштабируемость

      ▪ Благодаря компонентному подходу, React-приложения хорошо масштабируются
        - С ростом размера приложения, растёт и сложность его поддержки/развития.
        - У приложений с компонентным подходом, эта сложность растет медленнее,
          чем у приложений без компонентного подхода.
        - В результате "предел" роста существенно отодвигается вверх.


  > Минусы

    • Сложнее и запутаннее, чем KnockoutJS
      - На начальном этапе React замедляет работу.
      - Понять, как работают props, state и как взаимодействуют компоненты непросто.

    • Документация хуже, чем у KnockoutJS
      - У React не самая лучшая документация.
      - В ней плохо проработана категоризация.
      - Так что, новичкам придётся попотеть над ней.

    • Не поддерживает браузеры <= IE8
      - И никогда не будет.
      - Хотя, вроде бы, есть какие-то инструменты для этого.

    • React не лучший вариант для малых приложений
      - Придётся писать много кода, чтобы достичь малых результатов.
      - Для малых приложений намного удобнее использовать Knockout.

    • Придётся использовать JSX
      - Это XML-образный синтаксис для использования внути render в React.
      - В случае с knockout, мы могли использовать обычный HTML.
      - Здесь же приходится использовать JSX (писать на чистом JS не вариант).

    • Придётся использовать много доп.инструментов
      - Redux, babel, и т.д. Тысячи их.


А3. Hello world на React

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Hello World на React

  --------------------------------------

  > Ссылки

      # Туториал
          https://facebook.github.io/react/docs/tutorial.html

  > Введение
    - Это глава содержит лишь Hello World на React.
    - С комментариями.

  > Hello World на React

      // 1] React-компонент, который выводит строку "Hello, world!"
      var CommentBox = React.createClass({
        render: function() {
          return (
            <div className="helloworld">
              <span>Hello, world!</span>
            </div>
          );
        }
      });

      // 2] Отрисовка компонента CommentBox в конце эл-та с ID == content
      ReactDOM.render(
        <HelloWorld />,
        document.getElementById('content')
      );


А4. Думай в стиле React

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Этап №1: начни с дизайна
    # Этап №2: подготовь API
    # Этап №3: разбей весь UI на иерархию компонентов

      ▪ Нарисуй рамку вокруг каждого компонента
      ▪ Используй цвет при обведения компонентов рамками
      ▪ Как определить, что должно быть отдельным компонентом?
      ▪ Используй принцип: "один компонент - одно действие"
      ▪ Используй оригинальную модель данных из API сервера в компонентах React
      ▪ В итоге, в нашем примере мы выделяем 5 компонентов

    # Этап №4: создай статическую версию React-приложения

      ▪ Как этот этап выглядел в KnockoutJS
      ▪ Почему надо начинать с этого этапа, а не сразу наводить интерактивность?
      ▪ Используй для статической версии лишь props, не используй state
      ▪ Пиши компоненты либо сверху->вниз, либо снизу->вверх
      ▪ Что мы получаем в итоге, в конце этого этапа?
      ▪ Код статической версии React-приложения нашего примера

    # Этап №5: определи минимальную (но законченную) картину state приложения

      ▪ Аналогии с knockout, props - не наблюдаемые, state - наблюдаемые
      ▪ Три вопроса, помогающие понять, что НЕ добавлять в state
      ▪ Ещё раз подчёркиваем: не добавляй в state вторичные данные
      ▪ Наполни state наблюдаемыми

    # Этап №6: определи, какой компонент должен ВЛАДЕТЬ каким св-вом из state

      ▪ Инструкция: какой компонент должен владеть каким св-вом из state
      ▪ Определим, какие компоненты будут владеть state-свойствами нашего примера
      ▪ Обновим код приложения в нашем примере

    # Этап №7: добавь обратную связь

      ▪ В React автоматическая обратная связь отсутствует
      ▪ Добавь возможность компонентам-наследникам менять state компонентов-предков

    # Финальный код примера

  --------------------------------------

  > Ссылки

      # Думай в стиле React
          https://facebook.github.io/react/docs/thinking-in-react.html

  > Введение
    - В этой главе схематично описан ход разработки приложения на React.
    - Она учит "думать в стиле React" во время разработки приложений на React.
    - Глава построена на примере разработки таблицы с данными, и поиском.

  > Этап №1: начни с дизайна
    - Сначала подготовь дизайн документа, или хотя-бы его прототип.
    - Чтобы на основе дизайна продумать структуру будущего React-приложения.
    - Для нашего примера, используем этот дизайн:

        https://facebook.github.io/react/img/blog/thinking-in-react-components.png

  > Этап №2: подготовь JSON API
    - Затем на сервере подготовь API для работы с React-приложением на клиенте.
    - Например, это API должно возвращать стартовый набор данных в ответ на GET-запрос.
    - И возвращать необходимые данные в ответ на различные POST-запросы.
    - Все данные желательно передавать туда-сюда в формате JSON.
    - Например:

        [
          {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
          {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
          {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
          {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
          {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
          {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
        ];

  > Этап №3: разбей весь UI на иерархию компонентов

    • Нарисуй рамку вокруг каждого компонента
      - Определи, что можно считать компонентами на макете.
      - Обведи каждый прямоугольной рамкой.
      - Учти, что любой компонент может быть вложен в другой.

    • Используй цвет при обведения компонентов рамками
      - Каждому отличающемуся компоненту присваивай свой цвет.
      - Экземпляры одного и того же компонента обводи одним и тем же цветом.
      - Это как бы показывает, что все эти экземпляры относятся к 1-му компоненту.

    • Как определить, что должно быть отдельным компонентом?
      - А как определить, что должно быть отдельной функцией или объектом?
      - Используй здесь тот же самый принцип, он должен быть тебе знаком.

    • Используй принцип: "один компонент - одно действие"
      - Старайся следовать при разработке компонентов принципу "одного действия".
      - Когда один компонент, в идеале, ответственнен за одну вещь.
      - Если же компонен начинает разрастаться, можно дробить его на несколько.

    • Используй оригинальную модель данных из API сервера в компонентах React
      - Заранее спроектируй модель данных так, чтобы было с ними удобно работать.
      - Передавай эти данные с сервера клиенту в формате JSON.
      - Используй эти данные прямо в том же формате, в котором они поступили.
      - Это существенно упрощает дело, ведь не нужно писать преобразователи
        данных клиент->сервер, сервер->клиент.

    • В итоге, в нашем примере мы выделяем 5 компонентов
      - Вот их список, с соблюдением иерархии:

        ▪ FilterableProductTable    | Контейнер всего приложения
          ▪ SearchBar               | Работает со вводом пользователя в input
          ▪ ProductTable            | Выводит коллекцию данных, и фильтрует на основе ввода пользователя в input
            ▪ ProductCategoryRow    | Выводит заголовок каждой категории
            ▪ ProductRow            | Выводит строку с позицией внутри каждой категории

  > Этап №4: создай статическую версию React-приложения

    • Как этот этап выглядел в KnockoutJS
      - Грубо говоря, сверстай документ, и подключи к данным.
      - В Knockout этот этап подразумевал следующие шаги:

        1) Сверстать документ по макету.
        2) Подготовить модель, и подключить к вёрстке через data-bind'ы.
        3) Принять стартовые данные с сервера и интегрировать в модель.

      - В итоге, мы получали "статическую" версию knockout-приложения.
      - Она могла лишь выводить стартовые данные, которые отдавал сервер на GET-запрос.
      - Какой-либо функционал, позволяющий интерактивно взаимодействовать, отсутствовал.

    • Почему надо начинать с этого этапа, а не сразу наводить интерактивность?
      - Чтобы наводить интерактивность, надо видеть, что получается.
      - Программировать какой-либо интерактивный элемент, обновлять документ,
        и смотреть, что же получилось? Работает или нет?
      - Но если нет даже статической версии приложения, то интерактивную
        функциональность никак не отладить.

    • Используй для статической версии лишь props, не используй state
      - Для статических компонентов, используй props, а не state.
      - Это способ передавать данные от родительского компонента к дочернему
      - Потому что данные в props могут быть лишь прочитаны, но не изменены
        дочерним компонентом.
      - Не используй state, он предназначен для динамических, интерактивных компонентов.
        Для таких, у которых данных изменяются время от времени.

    • Пиши компоненты либо сверху->вниз, либо снизу->вверх

      ▪ Сверху->вниз лучше писать для мелких приложений
        - В нашем случае, это от FilterableProductTable и вниз по иерархии.
        - У нас приложение мелкое, так что лучше выбрать этот способ.

      ▪ Снизу->вверх лучше писать для крупных приложений
        - В крупных приложениях, вероятно, лучше писать наоборот, снизу вверх.
        - Ну, или в любом удобном порядке.
        - Следуя принципу, как съесть слона - по кусочкам.
        - Пишешь какой-нибудь мелкий компонент, отлаживаешь его, пишешь следующий.

    • Что мы получаем в итоге, в конце этого этапа?

      ▪ Библиотеку из 5-ти компонентов, которые можно повторно использовать

        ▪ FilterableProductTable    | Контейнер всего приложения
          ▪ SearchBar               | Работает со вводом пользователя в input
          ▪ ProductTable            | Выводит коллекцию данных, и фильтрует на основе ввода пользователя в input
            ▪ ProductCategoryRow    | Выводит заголовок каждой категории
            ▪ ProductRow            | Выводит строку с позицией внутри каждой категории

      ▪ Каждый компонент имеет лишь один метод render()
        - Поскольку, это статическая версия приложения.

      ▪ Компонент-контейнер в корне иерархии примет модель данных, как prop
        - Речь идёт о компоненте FilterableProductTable.
        - Он через prop примет переданные API-сервера в ответ на GET-запрос данные.

    • Код статической версии React-приложения нашего примера

      // 1] Компоненты

        // 1.1] FilterableProductTable
        class FilterableProductTable extends React.Component {
          render() {
            return (
              <div>
                <SearchBar />
                <ProductTable products={this.props.products} />
              </div>
            );
          }
        }

        // 1.2] SearchBar
        class SearchBar extends React.Component {
          render() {
            return (
              <form>
                <input type="text" placeholder="Search..." />
                <p>
                  <input type="checkbox" />
                  {' '}
                  Only show products in stock
                </p>
              </form>
            );
          }
        }

        // 1.3] ProductTable
        class ProductTable extends React.Component {
          render() {
            var rows = [];
            var lastCategory = null;
            this.props.products.forEach(function(product) {
              if (product.category !== lastCategory) {
                rows.push(<ProductCategoryRow category={product.category} key={product.category} />);
              }
              rows.push(<ProductRow product={product} key={product.name} />);
              lastCategory = product.category;
            });
            return (
              <table>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Price</th>
                  </tr>
                </thead>
                <tbody>{rows}</tbody>
              </table>
            );
          }
        }

        // 1.4] ProductCategoryRow
        class ProductRow extends React.Component {
          render() {
            var name = this.props.product.stocked ?
              this.props.product.name :
              <span style={{color: 'red'}}>
                {this.props.product.name}
              </span>;
            return (
              <tr>
                <td>{name}</td>
                <td>{this.props.product.price}</td>
              </tr>
            );
          }
        }

        // 1.5] ProductRow
        class ProductCategoryRow extends React.Component {
          render() {
            return <tr><th colSpan="2">{this.props.category}</th></tr>;
          }
        }

      // 2] Стартовые данные для отрисовки приложения
      // - Обычно, они передаются с сервера в формате JSON.
      // - Но в нашем примере, для наглядности, мы их захардкодим здесь.
      var PRODUCTS = [
        {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},
        {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},
        {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},
        {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},
        {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},
        {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}
      ];

      // 3] Отрисовка статического React-приложения
      // - До этой отрисовки в DOM документа React ещё ничего не отрисовывал.
      // - На этом шаге мы приказываем React'у сделать следующее:
      //
      //   1) Найти в документе элемент с ID == container
      //   2) В конце этого элемента отрисовать приложение
      //   3) Приложение построить на основе корневого компонента FilterableProductTable.
      //   4) Корневому компоненту через props передать данные PRODUCTS.
      //
      ReactDOM.render(
        <FilterableProductTable products={PRODUCTS} />,
        document.getElementById('container')
      );


  > Этап №5: определи минимальную (но законченную) картину state приложения

    • Аналогии с knockout, props - не наблюдаемые, state - наблюдаемые

      ▪ Не наблюдаемые св-ва в модели KO
        - Не предполагается, что эти св-ва будут как-то изменяться.
        - Даже если будут, KO никак не отслеживает их изменения.

      ▪ Наблюдаемые св-ва в модели KO
        - Предполагается, что эти св-ва будут изменяться.
        - KO отслеживает их изменения, перерисовывает интерфейсы.

      ▪ Параллель между KO и React
        - В props лежат не наблюдаемые свойства модели.
        - В state лежат наблюдаемые свойства модели.

      ▪ Почему рекомендуют в state класть MIN необходимый набор
        - Чем больше туда засунешь, тем ниже будет производительность.
        - У React, конечно, она и так одна из самых высоких из всех.
        - Однако, зачем своими руками снижать себе производительность?

    • Три вопроса, помогающие понять, что НЕ добавлять в state

      1. Это св-во передано родителем через props?
        - Если так, вероятно, его не надо добавлять в state.

      2. Значение этого св-ва остаётся неизменным со временем?
        - Если так, вероятно, его не надо добавлять в state.

      3. Это св-во является вторичным?
        - То есть, его можно вычислить на основе других свойств?
        - Если так, вероятно, его не надо добавлять в state.

    • Ещё раз подчёркиваем: не добавляй в state вторичные данные
      - Т.Е. таких, которые можно вычислить из других данных.
      - В Knockout вторичные данные обычно вычислялись в computed.
      - Вместо этого, добавляй в state только первичные данные.
      - Пример вторичных данных, которые не надо добавлять:

        ▪ Количество вещей в массиве
          - Количество мы и так можем посмотреть с помощью lenght.
          - Нет никакой необходимости добавлять такое св-во в state.

    • Наполни state наблюдаемыми
      - Но добавляй только первичные данные.
      - Рассмотрим свойства из нашего примера.
      - Определим, какие из них нам надо добавить в state, а какие нет:

      ▪ Добавить в state

        ▪ Значение из текстового input (поиск)
          - Это значение изменяется пользователем.
          - Очевидно, оно должно быть наблюдаемым.

        ▪ Значение checkbox (показывать только продукты в продаже)
          - Это значение изменяется пользователем.
          - Очевидно, оно должно быть наблюдаемым.

      ▪ Не добавлять в state

        ▪ Список продуктов (оригинал)
          - Он передан родителем через props.

        ▪ Список продуктов (фильтрованный)
          - Он может быть вычислен на основе имеющихся данных.
          - А именно, на основе оригинального списка продуктов,
            а также значений текстового input и checkbox.

  > Этап №6: определи, какой компонент должен ВЛАДЕТЬ каким св-вом из state

    • Инструкция: какой компонент должен владеть каким св-вом из state
      - Эту инструкцию можно применить к каждому из св-в в state.
      - К делу:

        1) Определи компоненты, которые отрисовывают что-то по этому св-ву
          - Это может быть 1 и более компонентов.

        2) Для всех из набора 1 найди общего предка
          - Этот предок не обязан состоять в наборе 1.
          - Это вполне может быть, например, компонент-обёртка всего приложения.

        3) Выбери компонент, который будет владеть св-вом из state
          - Это должен быть либо компонент, найденный в 2.
          - Либо любой компонент, находящийся выше найденного в 2 по иерархии.

        4) Если не получается найти компонент, которому есть смысл владить св-вом
          - Можно специально для этого создать отдельный компонент.
          - И разместить его в любом месте, но выше по иерархии, чем компонент из 2.

    • Определим, какие компоненты будут владеть state-свойствами нашего примера

      ▪ Значение из текстового input (поиск)

        1) SearchBar и ProductTable
          - Значение текстового input отображается в нём в SearchBar.
          - И оно также влияет на список выводимых продуктов в ProductTable.

        2) FilterableProductTable
          - Общим предком для SearchBar и ProductTable является FilterableProductTable.

        3) FilterableProductTable
          - Будем записывать это св-во в state компонента FilterableProductTable.

      ▪ Значение checkbox (показывать только продукты в продаже)

        1) SearchBar и ProductTable
          - Значение checkbox влияет на отображение в SearchBar.
          - И оно также влияет на список выводимых продуктов в ProductTable.

        2) FilterableProductTable
          - Общим предком для SearchBar и ProductTable является FilterableProductTable.

        3) FilterableProductTable
          - Будем записывать это св-во в state компонента FilterableProductTable.

    • Обновим код приложения в нашем примере
      - Наполним state в FilterableProductTable.
      - Передадим значение input из state в SearchBar и ProductTable, как props.
      - Передадим значение checkbox из state в SearchBar и ProductTable, как props.

  > Этап №7: добавь обратную связь

    • В React автоматическая обратная связь отсутствует

      ▪ Как дела обстоят в Knockout: двунаправленная связь
        - Там ты определяешь в модели наблюдаемое свойство.
        - Затем связываешь его с помощью data-bind с каким-нибудь DOM-элементом.
        - И у тебя образуется двунаправленная связь.
        - При изменении св-ва, меняется и элемент. И наоборот.
        - Это и называеют двунаправленной связью.

      ▪ Как дела обстоят в React: однонаправленная связь
        - В React ты добавляешь в state общего компонента-предка свойство.
        - Затем передаешь это свойство через props всем компонентам-потребителям.
        - И они, используя это свойство, что-то там у себя отрисовывают.
        - Например, они могут отрисовывать значение текстового input.
        - Однако, меняя значение этого input в браузере, св-во в state
          компонента-предка не меняется.
        - Это и называеют однонаправленной связью.

    • В React обновлять state компонента может только сам этот компонент
      - То есть, один компонент никак не может обновить state другого компонента.

    • Инициировать обновление state другого компонента можно через переданные колбэки
      - В нашем примере, FilterableProductTable в render, когда создаёт
        экземпляр SearchBar, передаёт ему колбэк onUserInput.
      - В SearchBar этот колбэк назначается с помощью onInput в качестве
        обработчика события input на текстовый input.
      - Когда он срабатывает, в качестве аргумента он получает от
        SearchBar актуальное значение текстового input, и с помощью
        setState обновляет state компонента FilterableProductTable.

  > Финальный код примера

    // 1] Компоненты

      // 1.1] Компонент FilterableProductTable
      class FilterableProductTable extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            filterText: '',
            inStockOnly: false
          };

          this.handleUserInput = this.handleUserInput.bind(this);
        }

        handleUserInput(filterText, inStockOnly) {
          this.setState({
            filterText: filterText,
            inStockOnly: inStockOnly
          });
        }

        render() {
          return (
            <div>
              <SearchBar
                filterText={this.state.filterText}
                inStockOnly={this.state.inStockOnly}
                onUserInput={this.handleUserInput}
              />
              <ProductTable
                products={this.props.products}
                filterText={this.state.filterText}
                inStockOnly={this.state.inStockOnly}
              />
            </div>
          );
        }
      }

      // 1.2] Компонент SearchBar
      class SearchBar extends React.Component {
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this);
        }

        handleChange() {
          this.props.onUserInput(
            this.refs.filterTextInput.value,
            this.refs.inStockOnlyInput.checked
          );
        }

        render() {
          return (
            <form>
              <input
                type="text"
                placeholder="Search..."
                value={this.props.filterText}
                ref="filterTextInput"
                onChange={this.handleChange}
              />
              <p>
                <input
                  type="checkbox"
                  checked={this.props.inStockOnly}
                  ref="inStockOnlyInput"
                  onChange={this.handleChange}
                />
                {' '}
                Only show products in stock
              </p>
            </form>
          );
        }
      }

      // 1.3] Компонент ProductTable
      class ProductTable extends React.Component {
        render() {
          var rows = [];
          var lastCategory = null;
          this.props.products.forEach((product) => {
            if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked && this.props.inStockOnly)) {
              return;
            }
            if (product.category !== lastCategory) {
              rows.push(<ProductCategoryRow category={product.category} key={product.category} />);
            }
            rows.push(<ProductRow product={product} key={product.name} />);
            lastCategory = product.category;
          });
          return (
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Price</th>
                </tr>
              </thead>
              <tbody>{rows}</tbody>
            </table>
          );
        }
      }

      // 1.4] Компонент ProductRow
      class ProductRow extends React.Component {
        render() {
          var name = this.props.product.stocked ?
            this.props.product.name :
            <span style={{color: 'red'}}>
              {this.props.product.name}
            </span>;
          return (
            <tr>
              <td>{name}</td>
              <td>{this.props.product.price}</td>
            </tr>
          );
        }
      }

      // 1.5] Компонент ProductCategoryRow
      class ProductCategoryRow extends React.Component {
        render() {
          return (<tr><th colSpan="2">{this.props.category}</th></tr>);
        }
      }

    // 2] Стартовые данные для отрисовки приложения
    // - Обычно, они передаются с сервера в формате JSON.
    // - Но в нашем примере, для наглядности, мы их захардкодим здесь.
    var PRODUCTS = [
      {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},
      {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},
      {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},
      {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},
      {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},
      {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}
    ];

    // 3] Отрисовка статического React-приложения
    // - До этой отрисовки в DOM документа React ещё ничего не отрисовывал.
    // - На этом шаге мы приказываем React'у сделать следующее:
    //
    //   1) Найти в документе элемент с ID == container
    //   2) В конце этого элемента отрисовать приложение
    //   3) Приложение построить на основе корневого компонента FilterableProductTable.
    //   4) Корневому компоненту через props передать данные PRODUCTS.
    //
    ReactDOM.render(
      <FilterableProductTable products={PRODUCTS} />,
      document.getElementById('container')
    );







