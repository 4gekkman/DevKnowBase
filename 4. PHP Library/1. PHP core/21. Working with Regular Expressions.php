<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Работа с регулярными выражениями в PHP


Прочее
> Узнать установленную на сервере версию PCRE


Модификаторы (флаги)
   > m      | мультистрочный поиск (влияет только на ^ и $ и символ перевода строки)
   > i      | регистронезависимый поиск
   > s      | метасимвол . в шаблоне будет соответствовать еще и переводу строки
   > x      | позволяет в шаблоне после # разместить коммент; пробелы и символы табуляции и пустой строки игнорируются
   > e      | действует только в preg_replace(). Выполняет замены, интерпретирует
                результат как PHP код, и использует результат для замены искомой строки.
              > [УСТАРЕЛ] В PHP > 5.5.0 не работает. Вместо него использовать preg_replace_callback().
   > A      | если установлен, то рег. выр. будет матчиться только, если оно заякорено на начало строки.
   > D      | если установлен, то $ соответствует только концу данных (а если нет, то еще символу перевода строки)
              > D игнорируется, если используется m
   > S      | пропускает regexp через pcre_study() для дополнительного изучения
              > Подробнее о "Studying the pattern" см. здесь: http://www.pcre.org/pcre.txt
   > U      | инвертирует жадность квантификаторов
              > если U установлен, то ? после квантификатора делает его наоборот - жадным
   > X      | любой обратный слэш \ и не спец. символ за ним трактуются как ошибка
   > J      |
   > u      | шаблоны обрабатываются, как UTF-8 строки

Синтаксис регулярных выражений PCRE
> \      | экранирование, непечатный символ в явной форме, либо стандартный символьный класс
> .      | матчится с любым символом, кроме \n (а если стоит модификатор s, то и с \n)
> x|y    | Альтернативный выбор. Матчит либо x, либо y.

    Комментарии
    > (?#    | комментарий в шаблоне, продолжающийся до ближайшей )
    > #      | (если использован модификатор x) комментарий до конца строки или до \n

    Якоря
    > ^      | Якорь. Соответствие началу строки.
               > Если используется модификатор m, то матчится еще и с позицией,
                 непосредственно после символа перевода строки \n
    > $      | Якорь. Соответствие концу строки.
               > Если используется модификатор m, то матчится еще и с позицией,
                 непосредственно перед символом перевода строки \n

    Квантификаторы
    >  *Примечание: модификатор U инвертирует жадность
    >  *Примечание: ? может быть применен к любому квантификатору

        > *      | жадный квантификатор - аналог {0,} - 0 или более повторений; ставится после символа, символьного класса или группы.
        > *?     | НЕ жадный квантификатор - аналог {0,} - 0 или более повторений; ставится после символа, символьного класса или группы.
        > +      | жадный квантификатор - аналог {1,} - 1 или более повторений; ставится после символа, символьного класса или группы.
        > +?     | НЕ жадный квантификатор - аналог {1,} - 1 или более повторений; ставится после символа, символьного класса или группы.
        > ?      | жадный квантификатор - аналог {0,1} - 0 или 1 повторение; ставится после символа, символьного класса или группы.
        > ??     | НЕ жадный квантификатор - аналог {0,1} - 0 или 1 повторение; ставится после символа, символьного класса или группы.
        > {n}    | квантификатор; ровно n раз; ставится после...
        > {n,m}  | жадный квантификатор; от n до m раз; ставится после...
        > {n,m}? | НЕ жадныйквантификатор; от n до m раз; ставится после...
        > {m,}   | жадный квантификатор; от m раз; ставится после...
        > {m,}?  | НЕ жадный квантификатор; от m раз; ставится после...

        > *+     | захватывающий квантификатор - аналог {0,}, вместо отката в случае неудачи завершает работу.
        > ++     | захватывающий квантификатор - аналог {1,}, вместо отката в случае неудачи завершает работу.

    Символьные классы
    > [xyz]      | Набор. Матчит любой из символов из набора
    > [^xyz]     | Набор. Матчит любой из символов НЕ из набора

        Непосредственно символьные классы
        > alnum   | буквы и цифры
        > alpha   | буквы
        > ascii   | символы с кодами 0 - 127
        > blank   | только пробел или символ табуляции
        > cntrl   | управляющие символы
        > digit   | десятичные цифры (аналог \d)
        > lower   | строчные буквы
        > upper   | заглавные буквы
        > graph   | печатные символы, исключая пробел
        > print   | печатные символы, включая пробел
        > punct   | печатные символы, исключая буквы и цифры
        > word    | символы "слова" (аналог \w)
        > xdigit  | шестнадцатеричные цифры
        > space   | пробельные символы (почти аналог \s)
          > В отличие от \s включает вертикальную табуляцию.

    Утверждения
    >  *Примечание: не матчатся ни с каким символом, а просто обозначают некие окружающие условия.
    >  *Примечание: в отличие от JS нормально работают с UTF-8
    >  *Примечание: \A \Z \z  в отличие от ^ $  не зависят от модификаторов m D

        > \b   | граница слова
        > \B   | не граница слова
        > \A   | начало данных (назависимо от многострочного режима)
        > \Z   | конец данных либо позиция перед последним переводом строки (независимо от многострочного режима)
                 > Подчеркиваю, перед ПОСЛЕДНИМ переводом. В отличие от $, который матчит все символы перевода строки в строке!
        > \z   | конец данных (независимо от многострочного режима)
        > \G   | аналог \А, только началом данных считает offset, заданный в функции preg_match или preg_match_all

        > (?=       | положительное утверждение вида Look Ahead (LA)
        > (?!       | отрицательное утверждение вида Look Ahead (LA)
        > (?<=      | положительное утверждение вида Look Behind (LB)
        > (?<!      | отрицательное утверждение вида Look Behind (LB)
        > LB должны быть фиксированной длины - демонстрация.
        > Несколько утверждений в 1 шаблоне - демонстрация.
        > Вложенные утверждения - демонстрация

    Подмаски
    > (x|y)      | Локализация альтернатив с помощью подмаски
    > (x)(y)     | Захват значений в скобках (см. обратные ссылки в Информации)
    > (?'name'x) | Задать захватываемому значению именованный ключ 'name'
    > (?:x)      | Не захватывающие скобки. Индекс под значение выделяется, а само значение == ''
                   > Используется в условных подмасках
    > (|:x)      | Не захватывающие скобки. Даже индекс не выделяется.
                   > Для организации альтернативы, в которой не совпавшие альтернативы
                     не будут занимать лишние индексы.
    > (?:(?i)x)  | Установка доп. модификатора в незахватывающую подмаску. Способ 1.
    > (?i:x)     | Установка доп. модификатора в незахватывающую подмаску. Способ 2.
    > \g{name}   | Абсолютная ссылка на захваченное значение подмаски прямо из RegExp
                   по имени name, если оно было задано.
    > \g{xy}     | Абсолютная ссылка на захваченное значение подмаски прямо из RegExp.
                   > x и y это числа от 0 до 9.
    > \g{xy}     | Относительная ссылка на захваченное значение подмаски прямо из RegExp.
                   > x и y это числа от -9 до 0.
    > (?(c)y)    | Условная подмаска. Если c == true (заматчилось), то матчить y.
    > (?(c)y|n)  | Условная подмаска. Если c == true (заматчилось), то матчить y. Иначе матчить n.
    > (?>        | Однократная подмаска. Запрещает "откаты" и матчит, только если совпала последовательность МАХ длины.

    > Внутренняя обратная ссылка   | на захваченное значение внутри этой же подмаски, где значение захватывается


Функции для работы с PCRE
> preg_replace            | поиск по RegExp, замена на указанную строку или массив
> preg_replace_callback   | поиск по RegExp, замена по callback функции
> preg_filter             | аналог preg_replace; но возвращает только заматченые строки.
> preg_match              | > возвращает 0 если матчей не найдено, либо 1 если найдено.
                              > Но для проверки наличия быстрее использовать strpos() или strstr()
                            > Может найти массив подмасок из 1-го вхождения
                            > Может найти 1-е вхождение и индекс смещения.
> preg_match_all          | возвращает кол-во найденных вхождений (может вернуть и 0)
                            > Может найти массив подмасок для всех и каждого вхождения
                            > Может найти индексы смещения для всех вхождений
> preg_grep               | принимает массив X, возвращает:
                            > Либо массив эл-тов из X, которые матчатся с RegExp
                            > Либо наоборот, массив эл-тов из Х, которые не матчатся с RegExp
> preg_split              | разбивает строку на массив подстрок с помощью RegExp
> preg_last_error         | возвращает код ошибки последнего регулярного выражения PCRE
> preg_quote              | экранирует служебные символы в регулярных выражениях


-------------------------------------------------- */





// #########################################
// --------------> Прочее <-------------- //

    // Узнать установленную на сервере версию PCRE
        echo PCRE_VERSION;  // 8.32 2012-11-30        (php 5.5.0)







// #######################################################
// --------------> Модификаторы (флаги) <-------------- //

// m      | мультистрочный поиск (влияет только на ^ и $ и символ перевода строки)
    $str = 'Петр \\nПетров';   // Внимание! После '\n' не должно быть пробелов!
    $reg = '#Петр*#mu';        // здесь еще обязательно u, иначене не сработает
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);      // 0, 11
    echo "<br></pre>";


// i      | регистронезависимый поиск
    $str = 'Иван Петрович';
    $reg = '#петрович#iu';  // здесь еще обязательно u, иначене сработает
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);      // 9
    echo "<br></pre>";

// s      | метасимвол . в шаблоне будет соответствовать еще и переводу строки


// x      | позволяет в шаблоне после # разместить коммент; пробелы и символы табуляции и пустой строки игнорируются
    $str = 'Иван Петрович';
    $reg = '|петрович# ЭТО ПОШЕЛ УЖЕ КОММЕНТАРИЙ |iux';  // здесь еще обязательно u, иначене сработает;
                                                         // После # до | идет комментарий в шаблоне
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);      // 9
    echo "<br></pre>";

// e      | действует только в preg_replace(). Выполняет замены, интерпретирует
//          результат как PHP код, и использует результат для замены искомой строки.
//          > [УСТАРЕЛ] В PHP > 5.5.0 не работает. Вместо него использовать preg_replace_callback().

    // Так это работало раньше.
        /*
        // Допустим, есть вот такой HTML код
        $html = '<h1>иван</h1> <h4>петров</h4> ';

        // Надо сделать так, чтобы все заголовки были в верхнем регистре
        $html = preg_replace(
            '(<h([1-6])>(.*?)</h\1>)e',                // шаблон RegExp
            '"<h$1>" . strtoupper("$2") . "</h$1>"',   // шаблон того, на что в итоге заменить найденную подстроку
            $html                                      // строка, в которой искать подстроки и выполнять замены
        );
        */

    // Сейчас вместо модификатора e используй preg_replace_callback()
    $html = '<h1>иван</h1> <h4>петров</h4> ';
    $html = preg_replace_callback(
        '#<h([1-6])>(.*?)</h\1>#',
        function ($m) {
            return "<h$m[1]>" . mb_strtoupper($m[2], 'UTF-8') . "</h$m[1]>";
        },
        $html
    );
    echo $html;

// A      |

// D      |

// S      |

// U      |

// X      |
    $str = 'Иван';
    $reg = '|и\o|uiX';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // ОШИБКА!

    // Вывести детали об ошибке
    echo "<br><pre>";
    print_r(error_get_last());
    echo "<br></pre>";


// J      |

// u      |
    // см. примеры выше - без него с кириллицей вообще ничего не работает.




// ######################################################################
// --------------> Синтаксис регулярных выражений PCRE <-------------- //



// ----------------- %%%%%%%%   общее   %%%%%%%%%%%%%%%%%%%%%%%%%%%%



// \      | экранирование, непечатный символ в явной форме, либо стандартный символьный класс
    // Функция №1 - экранирование
    // > Экранирует служебные символы:   . \ + * ? [ ^ ] $ ( ) { } = ! < > | : -
        $str = 'Найти +*?';
        $reg = '|\+\*\?|u';  // в рег. выражении символы + * ? служебные, и должны быть заэкранированы с помощью \
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 11

        echo "<br><pre>";
        print_r($mathes);
        echo "<br></pre>";

    // Функция №2 - непечатный символ
        // В конце куска строки "Найти +*?" находится невидимый непечатный символ \n
            $str = 'Найти +*?
                            ';
            $reg = '|\n|u';     // с помощью \ можно в шаблоне обозначать непечатные невидимые символы в видимом виде
            $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 15

            echo "<br><pre>";
            print_r($mathes);
            echo "<br></pre>";

    // Функция №3 - символьный класс (один из общих наборов)
        $str = 'Метро 2033';
        $reg = '|\d+|u';       // \d соответствует любой цифре
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 11

        echo "<br><pre>";
        print_r($mathes);
        echo "<br></pre>";

    // Функция №4 - утверждения
    $str = 'Метро 2033';
    $reg = '|\b2|u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 11

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

// .      | матчится с любым символом, кроме \n (а если стоит модификатор s, то и с \n)
    $str = 'Метро 2033';
    $reg = '|ро.+|ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

// x|y    | Альтернативный выбор. Матчит либо x, либо y.
    $str = 'Метро 2033';
    $reg = '%метро| 2033%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

    echo "<br><pre>";
    print_r($mathes);   // 2 совпадения: 'Метро' и ' 2033'
    echo "<br></pre>";



// ----------------- %%%%%%%%   комментарии   %%%%%%%%%%%%%%%%%%%%%%%%%%%%



// (?#    | комментарий в шаблоне, продолжающийся до ближайшей )
    $str = 'Метро 2033';
    $reg = '%метро|(?# это комментарий мазафака) 2033%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

    echo "<br><pre>";
    print_r($mathes);   // 2 совпадения: 'Метро' и ' 2033'  (все работает, комментарий никак не влияет)
    echo "<br></pre>";


// #      | (если использован модификатор x) комментарий до конца строки или до \n
    $str = 'Метро 2033';
    $reg = '%метро| 2033# это коммент до конца строки мазафака! %uix';  // использован модификатор x
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

    echo "<br><pre>";
    print_r($mathes);   // 2 совпадения: 'Метро' и ' 2033'  (все работает, комментарий никак не влияет)
    echo "<br></pre>";




// ----------------- %%%%%%%%   якоря   %%%%%%%%%%%%%%%%%%%%%%%%%%%%




// ^      | Якорь. Соответствие началу строки.
            // > Если используется модификатор m, то матчится еще и с позицией,
            //   непосредственно после символа перевода строки \n
    // Без модификатора m
        $str = 'aaa aaa';
        $reg = '%^a%';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 0

        echo "<br><pre>";
        print_r($mathes);  // (найдено 1 совпадение)
        echo "<br></pre>";

        // С модификатором m
        $str = 'aaa aaa';
        $reg = '%^a%m';  // использован модификатор m
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 0, 5

        echo "<br><pre>";
        print_r($mathes);  // (найдено 2 совпадения)
        echo "<br></pre>";

// $      | Якорь. Соответствие концу строки.
            // > Если используется модификатор m, то матчится еще и с позицией,
            //   непосредственно перед символом перевода строки \n
    // Без модификатора m
        $str = 'aaa aaa';
        $reg = '%.a$%';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 5

        echo "<br><pre>";
        print_r($mathes);
        echo "<br></pre>";

    // С модификатором m
        $str = 'aaa aaa';
        $reg = '%$%m';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 4, 8

        echo "<br><pre>";
        print_r($mathes);  // найдено 2 вхождения (1 - конец строки, 2 - конец данных)
        echo "<br></pre>";




// ----------------- %%%%%%%%   квантификаторы   %%%%%%%%%%%%%%%%%%%%%%%%%%%%




// *      | жадный квантификатор - аналог {0,} - 0 или более повторений; ставится после символа, символьного класса или группы.
    $str = 'Желтый колобок';
    $reg = '%Жел.*%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желтый колобок'
    echo "<br></pre>";

// *?      | НЕ жадный квантификатор - аналог {0,} - 0 или более повторений; ставится после символа, символьного класса или группы.
    $str = 'Желтый колобок';
    $reg = '%Жел.*?%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Жел'
    echo "<br></pre>";

// +      | жадный квантификатор - аналог {1,} - 1 или более повторений; ставится после символа, символьного класса или группы.
    $str = 'Желтый колобок';
    $reg = '%Жел.+%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желтый колобок'
    echo "<br></pre>";

// +?      | НЕ жадный квантификатор - аналог {1,} - 1 или более повторений; ставится после символа, символьного класса или группы.
    $str = 'Желтый колобок';
    $reg = '%Жел.+?%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желт'
    echo "<br></pre>";

// ?      | жадный квантификатор - аналог {0,1} - 0 или 1 повторение; ставится после символа, символьного класса или группы.
    $str = 'Желтый колобок';
    $reg = '%Желты.?%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желтый'
    echo "<br></pre>";

// ??      | НЕ жадный квантификатор - аналог {0,1} - 0 или 1 повторение; ставится после символа, символьного класса или группы.
    $str = 'Желтый колобок';
    $reg = '%Желты.??%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желты'
    echo "<br></pre>";

// {n}    | квантификатор (индиффирентен к жадности); ровно n раз; ставится после...
    $str = 'Желтый колобок';
    $reg = '%Желты.{3}%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желтый к'
    echo "<br></pre>";

// {n,m}  | жадный квантификатор; от n до m раз; ставится после...
    $str = 'Желтый колобок';
    $reg = '%Желты.{0,3}%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желтый к'
    echo "<br></pre>";

// {n,m}?  | НЕ жадный квантификатор; от n до m раз; ставится после...
    $str = 'Желтый колобок';
    $reg = '%Желты.{0,3}?%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желты'
    echo "<br></pre>";

// {m,}   | жадный квантификатор; от m раз; ставится после...
    $str = 'Желтый колобок';
    $reg = '%Желты.{0,}%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желтый колобок'
    echo "<br></pre>";

// {m,}?   | НЕ жадный квантификатор; от m раз; ставится после...
    $str = 'Желтый колобок';
    $reg = '%Желты.{0,}?%u';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 'Желты'
    echo "<br></pre>";

// ++     | захватывающий квантификатор - аналог {0,}, вместо отката в случае неудачи завершает работу.
//          > пояснение, что это такое - см. в Информации в конце файла
    // Пример присутствия совпадений
        $str = 'aabc';
        $reg = '%.*abc%';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // 'aabc'    найдено 1 совпадение
        echo "<br></pre>";

    // Пример отсутствия совпадений
        $str = 'aabc';
        $reg = '%.*+abc%';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // совпадений не найдено (почему, см. информацию в конце файла)
        echo "<br></pre>";




// ----------------- %%%%%%%%   символьные классы   %%%%%%%%%%%%%%%%%%%%%%%%%%%%




// [xyz]      | Набор. Матчит любой из символов из набора
    $str = 'acf';
    $reg = '%[ab][cd][ef]%';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// [^xyz]     | Набор. Матчит любой из символов НЕ из набора
    $str = '123abc';
    $reg = '%[^a-z]{3}abc%ui';  // не английские буквы
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// alnum   | буквы и цифры
    $str = '12=+_-';
    $reg = '%[12[:^alnum:]]+%';  // совпадает с 1, 2 и любой НЕ цифрой и НЕ буквой (рус., англ. и т.д.)
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// alpha   | буквы
    $str = '12Робинзон Крузо!';
    $reg = '%[ 12![:alnum:]]+%ui';  // совпадает с 1, 2, !, ' ' и любыми буквами (русскими, английскими и т.д.)
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// ascii   | символы с кодами 0 - 127
    $str = 'whats up bro';
    $reg = '%[ [:ascii:]]+%ui';  // совпадает ascii символами (0-127) и пробелом в любой комбинации
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// blank   | только пробел или символ табуляции
    $str = '1 2 12 21';
    $reg = '%[12[:blank:]]+%ui';  // совпадает c 1, 2 и пробелами в любой комбинации
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// cntrl   | управляющие символы


// digit   | десятичные цифры (аналог \d)
    $str = '45645635';
    $reg = '%[[:digit:]]+%ui';  // совпадает с любым количеством цифр от 1 и более
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// lower   | строчные буквы
    $str = 'Иван Петров';
    $reg = '%[[:lower:]]+%u';  // совпадает с любым количеством строчных букв
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 2 совпадения
    echo "<br></pre>";

// upper   | заглавные буквы
    $str = 'ивАн петрОв';
    $reg = '%[[:upper:]]+%u';  // совпадает с любым количеством заглавных букв
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 2 совпадения
    echo "<br></pre>";

// graph   | печатные символы, исключая пробел


// print   | печатные символы, включая пробел


// punct   | печатные символы, исключая буквы и цифры


// word    | символы "слова" (аналог \w)
    $str = 'ивАн петрОв';
    $reg = '%[[:word:]]%u';  // совпадает с буквами
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // по 1 совпадению на каждую букву целевой строки
    echo "<br></pre>";

// xdigit  | шестнадцатеричные цифры


// space   | пробельные символы (почти аналог \s)
//           > В отличие от \s включает вертикальную табуляцию.
    $str = '1 2 12 21';
    $reg = '%[12[:blank:]]+%ui';  // совпадает c 1, 2 и пробелами в любой комбинации
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";



// ----------------- %%%%%%%%   утверждения   %%%%%%%%%%%%%%%%%%%%%%%%%%%%




// \b   | Утверждение. Граница слова
    // Без \b будет найдено 2 совпадения "кар": в словах "Картошка" и "Макароны"
        $str = 'Путин Картошка, Макароны';
        $reg = '%кар%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // 2 совпадения
        echo "<br></pre>";

    // С \b будет найдено только 1 совпадение "кар": в слове "Картошка"
        $str = 'Путин Картошка, Макароны';
        $reg = '%\bкар%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // 1 совпадение в слове "Картошка"
        echo "<br></pre>";

// \B   | Утверждение. Не граница слова
    // Без \B будет найдено 2 совпадения "кар": в словах "Картошка" и "Макароны"
        $str = 'Путин Картошка, Макароны';
        $reg = '%кар%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // 2 совпадения
        echo "<br></pre>";

    // С \B будет найдено только 1 совпадение "кар": в слове "Макароны"
        $str = 'Путин Картошка, Макароны';
        $reg = '%\Bкар%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // 1 совпадение в слове "Макароны"
        echo "<br></pre>";

// \A   | Утверждение. Начало данных (назависимо от многострочного режима)
//        > Якорит регулярное выражение на начало данных
    // Без многострочного режима
        $str = 'Путин Картошка, Макароны';
        $reg = '%\AПутин%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // 1 совпадение - с начала данных
        echo "<br></pre>";

    // С многострочным режимом
    $str = 'Путин
Картошка,
Макароны';
    $reg = '%\AПутин%uim';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 1 совпадение - с начала данных (многострочный режим не повлиял)
    echo "<br></pre>";

// \Z   | Утверждение. Конец данных либо позиция перед последним переводом строки (независимо от многострочного режима)
//        > Подчеркиваю, перед ПОСЛЕДНИМ переводом. В отличие от $, который матчит все символы перевода строки в строке!
    $str = 'aaa
    aaa
    a';
    $reg = '%\Z%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 1 совпадение - в конце данных, потому что там же и последний перевод строки
    echo "<br></pre>";


// \z   | Утверждение. Конец данных (независимо от многострочного режима)
    $str = 'aaa
        aaa
        a';

    $reg = '%a\z%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // 1 совпадение - в самом конце перед концом данных
    echo "<br></pre>";

// \G   | Утверждение. Первая совпадающая позиция в строке
//        > аналог \А, только началом данных считает offset, заданный в функции preg_match или preg_match_all
    $str = 'Странные частицы';
    $reg = '%\Gчастицы%';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE, 17);  // смещение на 17 байт от начала данных (UTF-8 символ занимает 2 байта, а пробел 1 байт)

    echo "<br><pre>";
    print_r($mathes);   // совпадение найдено
    echo "<br></pre>";




// (?=       | положительное утверждение вида Look Ahead (LA)
    $str = 'Иван; Петров;';
    $reg = '%\w+(?=;)%ui';  // ищет любое слово, за которым следует символ ';'
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);   // найдено 2 совпадения: 'Иван' и 'Петров'     ';' в совпадения не входят!
    echo "<br></pre>";

// (?!       | отрицательное утверждение вида Look Ahead (LA)
    $str = 'Иван Иванов Иванушка Иваний';
    $reg = '%иван(?!( |ов|ий))%ui';  // отсеивает 'Иван', 'Иванов' и 'Иваний'
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 22

    echo "<br><pre>";
    print_r($mathes);   // найдено 1 совпадение    'Иван' в слове 'Иванушка'
    echo "<br></pre>";

// (?<=      | положительное утверждение вида Look Behind (LB)
    $str = 'Иван Петров';
    $reg = '%(?<=иван) Петров%ui';  // матчит все ' петров' перед которыми идет 'иван'
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 8

    echo "<br><pre>";
    print_r($mathes);   // найдено 1 совпадение    ' Петров' в фразе 'Иван Петров'
    echo "<br></pre>";

// (?<!      | отрицательное утверждение вида Look Behind (LB)
    $str = 'Петров Иван Сидоров Иван';
    $reg = '%(?<!петров) иван%ui';  // матчит все ' иван' перед которыми НЕ идет 'петров'
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 36

    echo "<br><pre>";
    print_r($mathes);   // найдено 1 совпадение    ' иван' в фразе 'Сидоров Иван'
    echo "<br></pre>";

// LB должны быть фиксированной длины - демонстрация.
    // Пример ошибки такого рода в регулярном выражении
    // > ОШИБКА КОМПИЛЯЦИИ! Потому что 'кот' в шаблоне переменной длины, а должен быть фиксированной
        /*
        $str = 'пёс был здесь';
        $reg = '%(?<=пёс|кот?) был здесь%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);   //
        echo "<br></pre>";
        */
    // Исправление ошибки предыдущего примера - 'кот' теперь фиксированной длины. Все ОК.
        $str = 'пёс был здесь';
        $reg = '%(?<=пёс|кот) был здесь%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

        echo "<br><pre>";
        print_r($mathes);   // найдено 1 совпадение    ' был здесь' в фразе 'пёс был здесь'
        echo "<br></pre>";

// Несколько утверждений в 1 шаблоне - демонстрация.
        $str = '123foo';
        $reg = '%(?<=\d{3})(?<!999)foo%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 3

        echo "<br><pre>";
        print_r($mathes);   // найдено 1 совпадение   'foo' в фразе '123foo'
        echo "<br></pre>";

// Вложенные утверждения - демонстрация
    // Пример №1
        // Совпадение найдено
            $str = 'пёскот';
            $reg = '%(?<=(?<!жираф)пёс)кот%ui';  // 'кот' перед которым есть 'пёс' перед которым нет 'жираф'
            $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

            echo "<br><pre>";
            print_r($mathes);   // найдено 1 совпадение   'кот' в фразе 'пёскот'
            echo "<br></pre>";

        // Совпадение НЕ найдено  (жираф все испортил) =)
            $str = 'жирафпёскот';
            $reg = '%(?<=(?<!жираф)пёс)кот%ui';  // 'кот' перед которым есть 'пёс' перед которым нет 'жираф'
            $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

            echo "<br><pre>";
            print_r($mathes);   // совпадений не найдено
            echo "<br></pre>";

    // Пример №2
        $str = '123abcпёс';
        $reg = '%(?<=\d{3}...(?<!999))пёс%ui';  // 'пёс' перед которым есть 3 символа только не '999', перед которыми есть 3 цифры
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);  // 6

        echo "<br><pre>";
        print_r($mathes);   // найдено 1 совпадение   'пёс' в фразе '123abcпёс'
        echo "<br></pre>";




// ----------------- %%%%%%%%   подмаски   %%%%%%%%%%%%%%%%%%%%%%%%%%%%




// (x|y)      | Локализация альтернатив с помощью подмаски
    $str = 'Котопёс и Кот-Бегемот';
    $reg = '%кот(опёс|-бегемот)%ui';  // соответствует "Котопёс" и "Кот-Бегемот"
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    // Посмотреть целиком содержание массива
    echo "<br><pre>";
    print_r($mathes);   // найдено 2 совпадения: "Котопёс" и "Кот-Бегемот"
    echo "<br></pre>";

    // Доступ к элементам массива
    $res = $mathes[0][0][0];  // 'Котопёс'     - найденная совпавшая строка целиком
    $res = $mathes[0][0][1];  // '0'           - байт, с которой она начинается в искомой строке
    $res = $mathes[0][1][0];  // 'Кот-Бегемот' - найденная совпавшая строка целиком
    $res = $mathes[0][1][1];  // '18'          - байт, с которой она начинается в искомой строке
    $res = $mathes[1][0][0];  // 'опёс'        - захваченная первыми скобками подстрока
    $res = $mathes[1][0][1];  // '6'           - байт, с которой она начинается в искомой строке
    $res = $mathes[1][1][0];  // '-Бегемот'    - захваченная первыми скобками подстрока
    $res = $mathes[1][1][1];  // '24'          - байт, с которой она начинается в искомой строке

// (x)(y)     | Захват значений в скобках (см. обратные ссылки в Информации)
    $str = 'Поздравляю с новым 2012-ым годом!';
    $reg = '%(\d{4})%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    // Посмотреть целиком содержание массива
    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

    // Доступ к элементам массива
    $res = $mathes[0][0][0];  // '2012' - найденная совпавшая строка целиком
    $res = $mathes[0][0][1];  // '35'   - байт, с которой она начинается в искомой строке
    $res = $mathes[1][0][0];  // '2012' - захваченная первыми скобками подстрока
    $res = $mathes[1][0][1];  // '35'   - байт, с которой она начинается в искомой строке

// (?'name'x) | Задать захватываемому значению именованный ключ 'name'
    $str = 'Пёс и Котопёс!';
    $reg = '%(?<dog>пёс) и Кото\g{dog}!%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

// (?:x)      | Не захватывающие скобки. Индекс под значение выделяется, а само значение == ''
//              > Используется в условных подмасках
//  > Результаты:
//    > Внешние скобки не захватили значение, и в индекс не попали
//    > Скобки (1) значение не захватили (нет совпадения), но индекс №1 теперь занят
//    > Скобки (2) значение захватили (есть совпадение), и заняли следующий свободный индекс: №2
    $str = '2 34';
    $reg = '%(?:(1)|(2)) 34%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

// (|:x)      | Не захватывающие скобки. Даже индекс не выделяется.
//              > Для организации альтернативы, в которой не совпавшие альтернативы
//                не будут занимать лишние индексы.
//  > Результаты:
//    > Внешние скобки не захватили значение, и в индекс не попали
//    > Скобки (1) значение не захватили (нет совпадения), и индекс НЕ ЗАНЯЛИ (в отличие от предыдущего примера)
//    > Скобки (2) значение захватили (есть совпадение), и заняли следующий свободный индекс: №1
    $str = '2 34';
    $reg = '%(?|(1)|(2)) 34%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

// (?:(?i)x)  | Установка доп. модификатора в незахватывающую подмаску. Способ 1.
    $str = 'Пётр Иванов';
    $reg = '%(?:(?i)иван)ов%u';  // для подстроки установлен доп. индекс i - без него совпадения не будет (из-за разного регистра)
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";

// (?i:x)     | Установка доп. модификатора в незахватывающую подмаску. Способ 2.
    $str = 'Пётр Иванов';
    $reg = '%(?i:иван)ов%u';  // для подстроки установлен доп. индекс i - без него совпадения не будет (из-за разного регистра)
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);
    echo "<br></pre>";


// \g{name}   | Абсолютная ссылка на захваченное значение подмаски прямо из RegExp
//                 по имени name, если оно было задано.

    // См. выше пример для (?'name'x)

// \g{xy}     | Абсолютная ссылка на захваченное значение подмаски прямо из RegExp.
//              > x и y это числа от 0 до 9.
    $str = 'Картинг и картошка';
    $reg = '%(карт)инг и \g{1}ошка%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// \g{xy}     | Относительная ссылка на захваченное значение подмаски прямо из RegExp.
//              > x и y это числа от -9 до 0.
    $str = '1 2 1 2';
    $reg = '%(1) (2) \g{-2} \g{-1}%ui';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// (?(c)y)    | Условная подмаска. Если c == true (заматчилось), то матчить y.
    // Условие - цифра (ссылка на захваченное значение подмаски)
        $str = 'котопёс';
        $reg = '%(кото)(?(1)пёс)%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // найдено 1 совпадение
        echo "<br></pre>";

    // Условие - (R)

    // Условие - утверждение

        // см. пример для (?(c)y|n)

// (?(c)y|n)  | Условная подмаска. Если c == true (заматчилось), то матчить y. Иначе матчить n.
    // Условие - цифра (ссылка на захваченное значение подмаски)
        $str = '123';
        $reg = '%(1)(?(1)23|34)%ui';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // найдено 1 совпадение
        echo "<br></pre>";

    // Условие - (R)

    // Условие - утверждение
        $str = 'кот';
        $reg = '%(?(?=[а-яёй])кот|пёс)%ui';  // если хот 1 буква из [а-яёй] есть в целевой строке, то ищет 'кот'; иначе ищет 'пёс'
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // найдено 1 совпадение
        echo "<br></pre>";

/* (?\>       | Однократная подмаска. Запрещает "откаты" и матчит, только если совпала последовательность МАХ длины.   */

    // Без однократной подмаски
        $reg = '%\d*.{4}%ui';  // ищет цифры, а после 4 любых символа
        $str = '12345abc';     // чтобы найти такую строку, потребуется сделать 1 откат
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // совпадение найдено
        echo "<br></pre>";

    // С однократной подмаской
    // > Не найдет совпадений, потому что здесь для этого надо сделать 1 откат,
    //   а однократная подмаска запрещает откаты и матчит только самые длинные значения
        $reg = '%(?>\d*).{4}%ui';  // ищет цифры, а после них abc
        $str = '12345';            // чтобы найти такую строку, потребуется сделать 1 откат
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

        echo "<br><pre>";
        print_r($mathes);  // совпадение найдено
        echo "<br></pre>";

// Внутренняя обратная ссылка   | на захваченное значение внутри этой же подмаски, где значение захватывается
// > Если она сработает, а никакое значение еще не захвачено, совпадения естественно не будет
    // Неработающий пример - ссылка на захваченное значение на 1-й итерации
    $str = '';
    $reg = '%(a\g{1})%ui';  // не совпадет ни с 1-й строкой

// Работающий пример - внутренняя обратная ссылка с помощью альтернативы.
    $reg = '%(a|b\g{1})+%ui';
    $str = 'a aba aaba aababaa';
    $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

    echo "<br><pre>";
    print_r($mathes);  // найдено 1 совпадение
    echo "<br></pre>";

// Работающий пример - внутренняя обратная ссылка с помощью квантификатора с минимумом == 0

    // Не смог придумать пример. Вообще, похоже это бесполезный пример.





// ############################################################
// --------------> Функции для работы с PCRE <-------------- //

// mixed preg_replace( mixed $pattern, mixed $replacement, mixed $subject [,
//                     int $limit = -1 [, int &$count ]] )
// > ищет по RegExp все вхождения и заменяет на указанную строку или массив
// > $pattern       - регулярное выражение (строка или массив строк)
// > $replacement   - строка или массив строк для замены
// > Подмаски, или обратные ссылки в $replacement
//   > Может содержать ссылки вида $x, где x из диапазона 0 - 99
//   > Эти ссылки будут заменены на подмаски из (здесь_подмаска)
//   > Подмаска $0 содержит весь $pattern, а начаниа я $1 - подмаски в порядке
//     их вхождения в шаблон слева-направо.
// > $subject -   строка или массив строк, в которых будет осуществлятсья поиск и замена.
//   > Если $subject массив, то и вернется массив с результатами. А если строка, то вернется строка.
// > $limit - МАХ кол-во замен каждого $pattern для каждого $subject; по умолчанию -1 (без ограничений)
// > $count - если указана, то будет заполнена количеством произведенных замен.
//
// > Если:  $pattern [массив строк],  $replacement [строка]
//     То:  > все шаблоны убудут заменены этой строкой
// > Если:  $pattern [строка],  $replacement [массив строк]
//     То:  строка будет заменена
// > Если:  $pattern [массив строк],  $replacement [массив строк]
//     То:  > будут заменены соответствующие (по индексу)  элементы
//          > если в элементов в $replacement < элементов в $pattern,
//            то все лишние эл-ты в $pattern будут заменены на ''
// > Возвращает:
//   > массив модифицированных строк, если $subject - массив
//   > модифицированую строку, если $subject - строка
//   > NULL в случае ошибки

    // Пример №1. Использование подмасок
        $str = 'April 15, 2013';
        $reg = '/(\w) (\d+), (\d+)/i';
        $rep = '${1}1, $3';
        $res = preg_replace($reg,$rep,$str);  // April1, 2013

        // Это работает и с русскими символами (UTF-8)
        $str = 'Апрель 15, 2013';
        $reg = '/(\w) (\d+), (\d+)/ui';       // Здесь дополнительно подключили флаг u
        $rep = '${1}1, $3';
        $res = preg_replace($reg,$rep,$str);  // Апрель1, 2013

    // Пример №2. Использование аргументов-массивов
        // Заменять будем в этой строке
        $str = 'большой красный молоток просвистел мимо меня.';

        // Шаблон - массив строк (ищем эти строки)
        $reg = [];
        $reg[0] = '/большой/';
        $reg[1] = '/красный/';
        $reg[2] = '/молоток/';

        // На замену - тоже массив строк (заменяем на эти строки)
        $rep = [];
        $rep[0] = 'скорый';
        $rep[1] = 'поезд';
        $rep[2] = 'Москва-Владивосток';

        // Результат
        $res = preg_replace($reg,$rep,$str);  // 'скорый поезд Москва-Владивосток просвистел мимо меня'

    // Пример №3. Замена пробелов вида '   '  на ' '
        $str = 'Вот     он!';
        $str = preg_replace('/\s\s+/',' ',$str);  // 'Вот он!'

    // Пример №4. Использование параметра count
        $count = 0;
        $res = preg_replace(
            '/\d/',             // (строка) регулярное выражение
            '*',                // (строка) на что заменять найденные вхождения
            'Земля 2033',       // (строка) где ищем вхождения
            -1,                 // заменять можно бесконечное кол-во раз
            $count              // сюда записать, сколько раз была произведена замена
        );
        echo "<br>Замена была произведена $count раз(а)";  // 4

// mixed preg_replace_callback( mixed $pattern, callable $callback, mixed $subject [,
//                              int $limit = -1 [, int &$count ]] )
// > поиск по RegExp, замена по callback функции
// > $pattern       - регулярное выражение (строка или массив строк)
// > $callback      - функция, которая должна вернуть строку или массив с заменой;
//                    > может быть анонимной функцией (как Function Expression из JS)
//                    > ей передаются подмаски
// > $subject -   строка или массив строк, в которых будет осуществлятсья поиск и замена.
//   > Если $subject массив, то и вернется массив с результатами. А если строка, то вернется строка.
// > $limit - МАХ кол-во замен каждого $pattern для каждого $subject; по умолчанию -1 (без ограничений)
// > $count - если указана, то будет заполнена количеством произведенных замен.
// > Возвращает:
//   > массив модифицированных строк, если $subject - массив
//   > модифицированую строку, если $subject - строка
//   > NULL в случае ошибки

    // Пример №1. Использование анонимной (function expression) функции в качестве callback-функции
    // Этот текст был использован в 2002 году
    // мы хотим обновить даты к 2003 году
        $text = "День дураков: 01/04/2002";
        // callback-функция
            function next_year($matches)
            {
                // как обычно: $matches[0] -  полное вхождение шаблона
                // $matches[1] - вхождение первой подмаски,
                // заключенной в круглые скобки, и так далее...
                return $matches[1].($matches[2]+1);
            }
        $res = preg_replace_callback(
            "|(\d{2}/\d{2}/)(\d{4})|",
            "next_year",
            $text);                     // День дураков: 01/04/2003


    // Пример №2. Использование анонимной (function expression) функции в качестве callback-функции
        // Допустим, есть вот такой HTML код
        $html = '<h1>иван</h1> <h4>петров</h4> ';

        // Надо сделать так, чтобы все заголовки были в верхнем регистре
        $html = preg_replace_callback(
            '#<h([1-6])>(.*?)</h\1>#',
            function ($m) {
                return "<h$m[1]>" . mb_strtoupper($m[2], 'UTF-8') . "</h$m[1]>";
            },
            $html
        );
        echo $html;  // ИВАН ПЕТРОВ


// int preg_match( string $pattern, string $subject [, array &$matches [,
//                 int $flags = 0 [, int $offset = 0 ]]] )
// > возвращает 0 если матчей не найдено, либо 1 если найдено.
// > $pattern - регулярное выражение
// > $subject - строка, в которой осуществляется поиск
// > &$matches - можно передать массив, структура которого будет:
//   > Если $flags == 0
//     > в [0] будет записана найденная подстрока
//     > в [1], [2] ... будет записана 1-ая подмаска, 2-ая подмаска ... соответственно.
//   > Если $flags == PREG_OFFSET_CAPTURE
//     > в каждой ячейке массива - [0], [1] ... - лежит по подмассиву
//       > В подмассиве в [0] лежит найденная подстрока
//       > В подмассиве в [1] лежит индекс, с которой она начинается
// > $offset - индекс, с которого начинать поиск (слева-направо)
//   > Это не будет считаться обрезкой строки, и шаблоны с ^ (к примеру) не сработают в этом месте.

    // Пример №1. Есть ли в тексте такая подстрока?
        $res = preg_match('|PHP|i', 'Курс специалиста по PHP');  // 1
        $res = preg_match('|PHP|i', 'Курс специалиста по JS');   // 0

    // Пример №2. Когда $flags == 0. Извлечение доменного имени.
        $reg = '#^(?:http://)?([^/]+)#i';
        $str = 'http://www.php.net/index.html';
        $res = preg_match($reg, $str, $mathes);
        $host = $mathes[1];  // www.php.net

    // Пример №3. Когда $flags == PREG_OFFSET_CAPTURE.
        $reg = '#\b\d\d\d\d\b#';
        $str = 'В 1991 году было то. А в 2013 году было сё.';
        $res = preg_match($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

            // Посмотрим, что в массиве $matches
            echo "<br><pre>";
            print_r($mathes);     // нашел только первое вхождение - 1991. И прекратил работу. 2013 не нашел.
            echo "<br></pre>";


// int preg_match_all( string $pattern, string $subject [, array &$mathes [,
//                     int $flags = PREG_PATTERN_ORDER [, $offset = 0 ]]] )
// > возвращает кол-во найденных вхождений (может вернуть и 0)
//   > второе и следующие вхождения ищен не сначала, а с конца прошлого вхождения.
// > $pattern - регулярное выражение
// > $subject - строка, в которой осуществляется поиск
// > &$matches - можно передать массив, структура которого будет:
//   > Если $flags == PREG_PATTERN_ORDER
//     > [0] - содержит массив полных вхождений
//     > [1], [2] ... - содержит массив вхождений 1-й подмаски, массив вхождий 2-й подмаски ... соответственно
//   > Если $flags == PREG_SET_ORDER
//     > [0] - содержит первый набор вхождений:
//       > [0][0] - первое полное вхождение
//       > [0][N] - N >= 1. N-ая подмаска из первого вхождения.
//   > Если $flags == PREG_OFFSET_CAPTURE
//     > в каждой ячейке массива - [0], [1] ... - лежит по подмассиву
//       > В подмассиве в [0] лежит вся найденная строка-совпадение
//       > В подмассиве в [0][1] лежит индекс, с которой она начинается
//       > [1][0] - 1 захваченная подстрока; [1][1] - индекс с которой она начинается.
//       > [2][0] - 2 захваченная подстрока ... и так далее
// > $offset - индекс, с которого начинать поиск (слева-направо)
//   > Это не будет считаться обрезкой строки, и шаблоны с ^ (к примеру) не сработают в этом месте.

    // Пример №1. Поиск всех телефонных номеров в тексте.
        preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
            "Звоните 555-1212 или 1-800-555-1212", $phones);

        // Посмотрим, что в массиве $phones
        echo "<br><pre>";
        print_r($phones);
        echo "<br></pre>";

    // Пример №2. Поиск всех вхождений и их смещений.
        $reg = '#\b\d\d\d\d\b#';
        $str = 'В 1991 году было то. А в 2013 году было сё.';
        $res = preg_match_all($reg, $str, $mathes, PREG_OFFSET_CAPTURE);

            // Посмотрим, что в массиве $matches
            echo "<br><pre>";
            print_r($mathes);     // нашел все вхождения, и 1991, и 2013
            echo "<br></pre>";

// array preg_grep( string $pattern, array $input [, int $flags = 0 ] )
// > принимает массив X, возвращает:
//   > Либо массив эл-тов из X, которые матчатся с RegExp
//   > Либо наоборот, массив эл-тов из Х, которые не матчатся с RegExp
//     > ... это если $flags == PREG_GREP_INVERT
$reg = '|PHP|';
$in = ['Курс PHP', 'Курс JS', 'PHP для начинающих', 'HTML для чайников'];

    // Найдем все записи, в которых есть PHP
    $res = preg_grep($reg, $in);

        echo "<br><pre>";
        print_r($res);       // 'Курс PHP' и 'PHP для начинающих'
        echo "<br></pre>";

    // Найдем все записи, в которых НЕТ PHP
    $res = preg_grep($reg, $in, PREG_GREP_INVERT);

        echo "<br><pre>";
        print_r($res);       // 'Курс JS' и 'HTML для чайников'
        echo "<br></pre>";

// array preg_split( string $pattern, string $subject [, int $limit = -1 [, int $flags = 0 ]] )
// > разбивает строку на массив подстрок с помощью RegExp
// > $pattern и $subject - соответственно рег. выражение и строка, которую надо разбить.
// > $limit - МАХ кол-во подстрок, которое вернет ф-ия. По умолчанию без ограничений.
// > $flags - можно настроит формат фозвращаемого массива:
//   > 0       | Стоит по умолчанию. Просто возвращает все подстроки.
//   > PREG_SPLIT_NO_EMPTY
//     > Вернет только не пустып подстроки
//   > PREG_SPLIT_DELIM_CAPTURE
//     > Вернет также и выражение в круглых скобках (указанное в рег. выр.)
//   > PREG_SPLIT_OFFSET_CAPTURE
//     > Меняет формат массива:
//       > Каждый элемент содержит еще один массив
//       > В каждом из них [0] - содержит найденную подстроку
//       > В каждом из них [1] - смещение этой подстроки в $subject
$str = 'Игра, Компьютер, Парень';
$reg = '$\B(,)\s\B$';

    // Просто разбивка строки $str на массив из 3-х строк
    $res = preg_split($reg, $str, null, 0);
    echo "<br><pre>";
    print_r($res);       // [0]=>'Игра', [1]=>'Компьютер', [2]=>'Парень'
    echo "<br></pre>";

    // Тоже самое, только еще будут выражения из круглых скобок
    $res = preg_split($reg, $str, null, PREG_SPLIT_DELIM_CAPTURE);
    echo "<br><pre>";
    print_r($res);       // [0]=>'Игра', [1]=>',', [2]=>'Компьютер', [4]=>'Парень'
    echo "<br></pre>";

    // А теперь разбивка + еще находит позиции подстрок в исходной строке $str
    $res = preg_split($reg, $str, null, PREG_SPLIT_OFFSET_CAPTURE);
    echo "<br><pre>";    // [0][0]=>'Игра', [0][1]=>0
    print_r($res);       // [1][0]=>'Компьютер, [1][1]=>10
    echo "<br></pre>";   // [2][0]=>'Парень', [2][1]=>30

// int preg_last_error( void )
// > возвращает код ошибки последнего регулярного выражения PCRE
//   > А именно, одну из констант, описанных здесь:  http://www.php.net/manual/ru/function.preg-last-error.php
    preg_match('/(?:\D+|<\d+>)*[!?]/', 'foobar foobar foobar');

    if (preg_last_error() == PREG_BACKTRACK_LIMIT_ERROR) {
        echo 'Был исчерпан лимит обратных ссылок!';
    }

// string preg_quote( string $str [, string $delimeter = NULL ] )
// > экранирует служебрые символы в регулярных выражениях
// > Служебными в PCRE считаются следующие символы:
//   >     . \ + * ? [ ^ ] $ ( ) { } = ! < > | : -
// > $delimiter - можно указать еще символ, который будет экранироваься
// > Возвращает строку с заэкранированными служебными символами
    $str = '\Здесь\ полно 2+2 всяких { } сп*цсимв*лов > :';
    $res = preg_quote($str);  // '\\Здесь\\ полно 2\+2 всяких \{ \} сп\*цсимв\*лов \> \:'



/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------

Ссылки
> Список изменений в разных версиях библиотеки PCRE
    http://www.pcre.org/changelog.txt
> PCRE инструкция
    http://www.php.net/manual/ru/book.pcre.php
  > Функции PCRE
      http://www.php.net/manual/ru/ref.pcre.php
  > Модификаторы PCRE
      http://www.php.net/manual/ru/reference.pcre.pattern.modifiers.php
  > Систаксис PCRE
      http://www.php.net/manual/ru/reference.pcre.pattern.syntax.php
  > Инструкция одного программиста:
      http://www.bitcetera.com/page_attachments/0000/0030/regex_in_a_nutshell.pdf
  > Памятка по RegExp с cyberforum.ru
      http://www.cyberforum.ru/php-regex/thread631382.html#a_quantifiers_possessive

  > Онлайн тестирование регулярных выражений:
      http://www.uvsoftium.ru/php/regexp.php

 О регулярных выражениях в общем
 > Регулярные выражения в широком смысле - это язык поиска и осуществления
   манипуляций с подстроками в тексте, основанный на использовании метасимволов.
 > Регулярное выражение - это строка. Которая является
                          ( паттерном | шаблоном | маской ) для поиска в другой строке.
   > Она состоит из:
     > Символов     - буквы, цифры, вообщел юбые символы.
     > Метасимволы  - зарезервированные сочетания символов, по сути языковые
                      конструкции, задающие правила поиска.
 > Например, при помощи регулярных выражений можно задать паттерны, позволяющие:
   > найти все последовательности символов «кот» в любом контексте, как то: «кот», «котлета», «терракотовый»;
   > найти отдельно стоящее слово «кот» и заменить его на «кошка»;
   > найти слово «кот», которому предшествует слово «персидский» или «чеширский»;
   > убрать из текста все предложения, в которых упоминается слово кот или кошка.
   > ... и еще много чего.

Регулярные выражения в PHP
> PCRE - Perl Compatible Regular Expressions
> Регулярные выражения встроены в стандартную сборку PHP, устанавливать
  что-то дополнительно не требуется.
> PHP поддерживает следующие версии регулярных выражений:
  > POSIX - устаревшие регулярные выражения
  > PCRE [наш выбор]
> В отличие от JS, в PHP нет модификатора g
  > Но зато есть много других модификаторов
  > А модификатор g заменяет функции по работе с регулярными выражениями
> В PHP регулярные выражения:
  > Заключаются в кавычки '' или ""
    > А в JS не заключаются.
  > Внутри кавычек заключается в разделители.
    > В отличие от JS (где разделителями могут быть только прямые слэши // ), в PHP
      разделителями могут быть произвольные символами, кроме:
      > буквенно-цифровых, обратного слэша \ , нулевого байта или пробела.
      > если разделитель попадается в шаблоне, его надо экранировать обратным слэшем \
  > В фигурные скобки {} можно заключать паттерны
    > Например: ${1}1 - {} помогают сказать PHP, что нас интересует $1, а не $11

Настройка в php.ini
> pcre.backtrack_limit
  > Лимит обратных ссылок      - по умолчанию == 100,000
  > Это довольно консервативно, можно установить и 100,000,000
> pcre.recursion_limit
  > Лимит на рекурсию      - по умолчанию == 100,000
  > Слишком высокое значение может превысить лимит стека и вызвать крушение системы.
  > Это довольно консервативно, можно установить и 100,000,000

Синтаксис регулярных выражений - некоторые особенности
> Якоря ( ^ и $ )
  > ^
    > Может стоять только первым символом шаблона или альтернативы (если
      в шаблоне используются альтернативы).
    > Шаблона называют "заякоренным" на начале - если все его альтернативы начинаются
      с символа ^. Это значит шаблон ограничен для совпадения исключительно
      началом строки.
    > Существуют и другие способы заякорить шаблон...
  > $
    > ... все тоже самое, только для конца строки ...
    > $ игнорируется, если используется модификатор m
> Альтернативный выбор |
  > PHP ищет среди указанных альтернатив слева направо, и найдя соответствие,
    прекращает поиск.
  > Если альтернативы используются в подмаске, то весь шаблон совпадает только
    в том случае, если совпадает одна из альтарнатив в подмаске.
> Квантификаторы   ? * + {}
  > С их помощью в шаблоне задается повторение куска шаблона
  > Повторение можно задать для следующих элементов шаблона:
    > символа, символьного класса или группы.
  > Квантификаторы бывают жадные, ленивые и захватывающие.
    > Жадный квантификатор:
      > Матчит самое длинное из всех возможных совпадений.
      > Пример:
        > Строка:     'Привет Бювет'
        > RegExp:     'П.*т'
        > Результат:  'Привет Бювет'
    > Ленивый квантификатор:
      > Матчит минимальный достаточный вариант из всех возможных совпадений.
      > Пример:
        > Строка:     'Привет Бювет'
        > RegExp:     'П.*?т'
        > Результат:  'Привет'
    > Захватывающий квантификатор:
      > В отличие от Ж и Л квантификаторов, не откатывает назад после неудачи.
      > Годно подробное объявнение на английском здесь: http://www.regular-expressions.info/possessive.html
      > Проще всего объяснить на примере:
        > Строка:         'aabc'
        > RegExp1:        '.*abc'            здесь жадный квантификатор
        > RegExp2:        '.*+abc'           здесь захватывающий квантификатор
        > Результат №1:   'aabc'
        > Резльтат №2:    совпадений не найдено

        > Пояснение - как отработал RegExp1 (итерации):
           Итарация     Действие                      Текущий результат
              > 1:    .* нашел первую букву a             'a'
              > 2:    .* нашел вторую букву a             'aa'
              > 3:    .* нашел букву b                    'aab'
              > 4:    .* нашел букву c                    'aabc'
              > 5:    не матчится со след. символом в
                      шаблоне 'a'. Откатываем на
                      последнюю букву ('c') назад         'aab'
              > 6:    не матчится со след. символом в
                      шаблоне 'a'. Откатываем на
                      последнюю букву ('b') назад         'aa'
              > 7:    смотрим следующий символ в
                      шаблоне: ('b'). Успех:              'aab'
              > 7:    смотрим следующий символ в
                      шаблоне: ('c'). Успех:              'aabc'
              -----------> Совпадение найдено!

        > Пояснение - как отработал RegExp2:
          > А вот захватывающий квантификатор никогда не откатывает назад,
            если что-то не матчится. И на этом заканчивает работу. Так что
            с примере выше на шаге №5 он бы закончил и ...
              -----------> Совпадение НЕ найдено!

> Утверждения
  > Само проверяемое утверждение в совпадение не входит
    > Например:
      > $str = 'Иван Петров';
      > $reg = '%Иван (?=Петров)%ui';
      > Результат: совпадение есть, совпавшая подстрока: "Иван ". Без "Петров"!!!
  > Утверждение - это проверка касательно символов, идущих до или после
    проверяемой позиции.
  > Примеры часто используемых стандартных утверждений:
    >    \b, \B, \A, \Z, \z, ^ и $
    > Но есть и более сложные кастомные утверждения. Они записываются как подмаски.
      > Есть 2 вида таких утверждений:
        > 1) Анализирующие впереди (look ahead - LA) - анализируют символы после текущей позиции, и утверждение должно находиться именно после.
          > Положительные утверждения для LA утверждений:
            > Начинаются с  (?=
          > Отрицательные утверждения для LB утверждений:
            > Начинаются с  (!=
        > 2) Анализирующие позади (look behind - LB) - анализируют символы перед текущей позиции, и утверждение должно находиться именно до.
          > Все LB утверждения имеют ограничение - все подстроки, которым они соответствуют,
            должны быть фиксированной длины. Однако, если используется альтернатива, альтарнативы
            должны быть тоже фиксированной длины, но могут отличаться под длинне друг от друга.
          > Положительные утверждения для LB утверждений:
            > Начинаются с  (?<=
          > Отрицательные утверждения для LB утверждений:
            > Начинаются с  (?<!
  > В одном шаблоне относительно одного и того же текста могут присутствовать несколько
    утверждений 1 вида. Они применяются к целевой строке НЕЗАВИСИМО.
    > Пример 1:
      > $reg = '%(?<=\d{3})(?<!999)foo%'
      > $str = '123foo';
      > Результат - совпадение найдено!
        > Тут 2 утверждения типа LB применяются к одному и тому же тексту 'foo'.
        > Сначала выполняется (?<=\d{3}) - есть ли перед foo 3 цифры?
        > Потом выполняется правое - нет ли перед foo цифр 999?
    > Пример 2:
      > $reg = '%(?<=\d{3})(?<!999)foo%'
      > $str = '123abcfoo';
      > Результат - совпадение найдено!
        > Тут 2 утверждения типа LB применяются к одному и тому же тексту 'foo'.
        > Сначала выполняется (?<=\d{3}...) - есть ли перед foo 3 цифры + 3 любых символа за ними?
        > Потом выполняется правое - нет ли перед foo цифр 999?
  > Утверждения могут быть вложенными без ограничений на уровни вложенности.


> Подмаски
  > Нужны для 3-х целей:
    1) Локализуют набор альтернатив
      > Например:   cat(aract|erpillar|)
    2) Захватывают подстроку, доступную для обратного вызова (см. далее)
    3) Позволяют вставить в шаблон кастомное утверждение(см. выше)
  > Подробнее о захвате подстроки
    > Если он не нужен в этой подмаске, то он должна начинаться с (либо ... либо):
      >  (?:         | и тогда захвата не будет. Однако место в массиве захваченных значений подмасок
                       все равно выделяется, просто оно остается пустым.
      >  |:x         | тогда и захвата не будет, и место в захваченном массиве подмасок не выделяется.
                       С помощью этого можно организовать альтернативу, в которой
                       не совпавшие альтернативы вообще не занимают место в захваченном массиве подмасок
    > Установка дополнительного модификатора для подмаски
      > Устанавливается в самой левой части подмаски. В этом случае даже если в ней
        есть альтернативы, то действует на всех них, потому что альтернативы берутся
        слева-направо.
      > Есть 2 способа установки дополнительного модификатора в незахватывающую подмаску:
        > 1) (?:(?i)подмаска)
        > 2) (?i:подмаска)
    > Захватывая подстроку, значению подмаски можно задать именованный ключ.
      Тогда к захваченному значению можно будет обращаться не только по порядковому
      индексу в захваченном массиве подмасок, но и по заданному ключу.
      > Синтаксис следующий:
        >  (?'name'pattern)    'name' - это ключ-строка
  > Обратные ссылки на захваченные значения
    > Захваченные значения подмасок помещаются в массив в порядке захвата
      с порядковыми индексами от 1 до 99 (больше подмасок быть не может).
    > Следующие обращения действуют вне символьных классов:
      > Обратиться к захваченным значениям из регулярного выражения можно так:
        > \1      | (устарело) обратиться к подмаске с индексом 1 (первое захваченное значение)
        > \10     | (устарело) это (обратный слэш + 2-значная цифра) может быть интерпретировано по разному:
          > Это либо ссылка на сотв. захваченное значение подмаски, но только в том случае,
            если есть столько захваченных значений в принципе.
          > А если нет, то как 2 8-ричных числа.
      > Чтобы избежать вышеобозначенных двусмысленностей и неудобств, для обращения
        к захваченным значениям используют \g   :
        > Абсолютные ссылки:
          > Обращение к захваченному значению по его номеру.
          > Примеры:
            > \g{21}    | обращение к 21 захваченному значению подмаски
            > \g{2}1    | обращение ко 2 захваченному значению подмаски, после которого в рег. выр. идет цифра 1
        > Относительные ссылки:
          > Обращение происходит относительно места вызова захваченного значения в шаблоне
          > Используются отрицательные индексы.
          > Примеры:
            > (foo)(bar)\g{-1} соответствует 'foobarbar'
            > (foo)(bar)\g{-2} соответствует 'foobarfoo'
        > По имени
          > Обратиться из рег. выр. к захваченному значению именованной подмаски
            можно по имени.
          > Пример:
            > \g{имя_подмаски}
    > Прямо в рег. выражении можно ссылаться захваченные значения.
      > НО должно присутствовать соответствующее число закрывающих скобок.
      > Захват значения не обязан предшествовать ссылке на него.
        > НО это касается только ссылок с порядковым номером от 1 до 9
    > Обратная ссылка на значение подмаски внутри самой этой подмаски
        (внутренняя обратная ссылка)
      > Нельзя так делать, если это первое сопоставление. Такая конструкция
        не матчится.
      > В таких случаях шаблон должен быть построен так, чтобы при первой итерации
        сопоставление с обратной ссылкой не проводилось. Есть 2 варианта:
        1) Альтернативы.
        2) Квантификаторы с минимумом == 0.
      > Примеры
        > Неработающий пример - ссылка на захваченное значение на 1-й итерации
          > (a\1) не соответствует ни 1 строке.
        > Пример - внутренняя обратная ссылка с помощью альтернативы.
          > $reg = '%(a|b\1)+%ui';
          > Соответствует:
            > 'a', 'aba', 'aaba', 'aababaa'
        > Пример - внутренняя обратная ссылка с помощью квантификатора с минимумом == 0
          > $reg = '%(a*\1)%ui';
          > В этом случае единственный вариант при первом цикле для совпадения -
            это отсутствие 'a'. Тогда в \1 лежит ''.
          > Соответствует:
            > любой строке, в которой нет 'a'.
  > Условные подмаски:
    > В PCRE реализована возможность подчинять шаблон условию либо выбирать из
      двух условных подмасок в зависимости от успеха сопоставления предыдущей подмаски
    > Есть 2 возможных синтаксиса. В случае успешного сопоставления condition
      используется yes-pattern. Иначе - no-pattern.
      1) (?(condition)yes-pattern)
      2) (?(condition)yes-pattern|no-pattern)
    > Причем condition здесь полюбому - утверждение.
    > И причем, condition может быть 3 типов, и от этого зависит дальнейшее:
      > condition - цифра       | это означает обратную ссылку на захваченное значение
                                  подмаски с соответствующим индексом.
      > condition == '(R)'      | условие будет true, если произведен рекурсивный вызов
                                  к шаблону или подмаске
      > condition - утверждение | true, если утверждение true
  > Однократные подмаски:
    > Во многих случаях существенно ускоряют поиск соответствия.
    > Записывается однократная подмаска так:  (?>
      > Пример:   (?>\d*)
    > Однократные подмаски являются не захватывающими.
    > Обычная логика работы регулярных выражений такая (на примере):
      > $reg = '%\d*abc%ui';  // ищет цифры, а после них abc
      > $str = '12345';
      > Вот что он делает:
        1. Сначала он ищет совпадения для \d. Находит максимальное число последовательных
             совпадений. В нашем случае это '12345'
        2. Затем он пытается найти совпадение для следующего символа RegEx - 'a',
           и не находит его.
        3. Тогда от решает откатить для \d на 1 совпадение назад - до '1234' и
           попытаться снова найти совпадение для 'a'.
        4. И так далее, и в конце он говорит, что совпадений для шаблона в указанной
           строке не найдено.
    > Использование однократной подмаски может изменить вышеописанную логику работы.
      А именно - на шаге №3 - где происходит откат назад на 1 значение, чтобы попытаться
      найти совпадение в этом случае. Однократные подмаски запрещают откаты, и по сути
      их использование говорит - матчить только с максимальной последовательностью.
      Вот как бы отработал пример выше с однократной подмаской:
      > $reg = '%(?>\d*)abc%ui';  // ищет цифры, а после них abc
      > $str = '12345';
        1. Сначала он ищет совпадения для \d. Находит максимальное число последовательных
             совпадений. В нашем случае это '12345'
        2. Затем он пытается найти совпадение для следующего символа RegEx - 'a',
           и не находит его.
        3. На этом поиски заканчивается, и он говорит, что совпадений для шаблона
           в указанной строке не найдено.

> Символьные классы
  > Символьный класс - это набор символов в квадратных скобках [] в шаблоне
    регулярного выражения. Матчица с одним из этих символов.
    > Чтобы добавить в класс символ ], надо его заэкранировать.
  > Если используется символ ^    - как здесь: [^ ... ]  , то логика работы
    инвертируется, и матчится любой символ не из набора.
    > Чтобы добавить в класс символ ^, надо его заэкранировать.
  > Символ '-' позволяет задать диапазон символов внутри символьного класса. Например:
    [0-9]  == [0123456789]
    > Чтобы добавить в класс символ -, надо его заэкранировать.
  > Символьные наборы вроде \d и \w можно добавлять прямо в символьный класс
    внутрь [].
  > Имента символьных классов вроде alnum или digit должны быть записаны в следующей форме:
    > [[:alnum:]]    - буква или цифра
    > [[:^alnum:]]   - не буква и не цифра








-------------------------------------------------- */
?> 





















