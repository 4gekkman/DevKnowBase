<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Сессии

Основы
> Регистрация сессионной переменной
> Удаление сессионной переменной
> Отслеживание прогресса загрузки файлов с помощью сессий
> Как убить сессию полностью

Функции
> session_start                  | Начинает новую или возобновляет существующую сессию
> session_write_close            | Сохраняет все данные сессии и закрывает ее
> session_destroy                | Удалить все из файла сессии
> session_status                 | Возвращает текущее состояние сессии
> session_cache_expire           | (возвращает | устанавливает новое) значение session.cache_expire
> session_cache_limiter          | (возвращает | устанавливает новое) значение session.cache_limiter
> session_name                   | (возвращает | устанавливает) имя сессии (имя сессионной куки)
> session_id                     | (возвращает | устанавливает) ID текущей сессии
> session_decode                 | Декодирует данные из переданной строки и заполняет ими массив $_SESSION
> session_save_path              | (возвращает | устанавливает) строку, содержащую текущий путь к директории для сохранения файлов сессии
> session_encode                 | Кодирует данные из $_SESSION и возвращает строку с результатом
> session_get_cookie_params      | Возвращает массив с информацией о cookie текущей сессии
> session_set_cookie_params      | Задает кастомные параметры сессионных кук до конца скрипта
> ini_get                        | Возвращает значение директивы из php.ini с переданным именем
> session_regenerate_id          | Генерирует новый id для текущей сессии, и заменяет им старый
> session_unset                  | Очищает все сессионные переменные текущей сессии

Пользовательский обработчик сессий (развить эту тему, если понадобится)
> http://www.php.net/manual/ru/function.session-set-save-handler.php
> http://www.php.net/manual/ru/class.sessionhandler.php
> http://www.php.net/manual/ru/class.sessionhandlerinterface.php





-------------------------------------------------- */



// --------------------> Основы <-------------------- //

// Регистрация сессионной переменной
// (на примере счетчика)
    // запуск сессии
    session_start();

    if(!isset($_SESSION['count'])) {
        // регистрация сессионной переменной
        $_SESSION['count'] = 0;
    } else {
        $_SESSION['count']++;
    }
    $r = $_SESSION['count'];
    echo 'count = ' . $r;

    // завершить текущую сессию и сохранить данные
    session_write_close();

// Удаление сессионной переменной
// > !! Не очищай целиком unset($_SESSION), иначе нельзя будет регистрировать сессионные переменные через $_SESSION
    session_start();             // запустить сессию
    $_SESSION['test'] = 10;
    $r = $_SESSION['test'];      // 10
    unset($_SESSION['test']);    // удалить переменную с индексом 'test'
    $r = $_SESSION['test'];      // undefined
    session_write_close();       // завершить текущую сессию и сохранить данные

// Отслеживание прогресса загрузки файлов с помощью сессий
?>
<form action="17. Sessions.php" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="<?php echo ini_get("session.upload_progress.name"); ?>" value="123" />
    <input type="file" name="file1" />
    <input type="file" name="file2" />
    <input type="submit" />
</form>
<?php

echo "<br><pre>";
print_r($_SESSION);
echo "<br></pre>";

// Как убить сессию полностью
    // 1. Очистить данные из файла сессии
    //    > При этом он не удалится, а так и останется висеть пустой, пока
    //      не пройдет время, указанное в session.gc_maxlifetime, и сборщик мусора его не удалит.
    // session_destroy();

    // 2. Очистить ID сессии
    // session_id('');

    // 3. Очистить сессионные куки пользователя (если они использовались)
    // setcookie(session_name(),"",time()-3600);


// --------------------> Функции <-------------------- //

// bool session_start( void )
// > Начинает новую, или возобновляет существующую сессию - если был передан
//   session ID с помощью GET или POST запроса, или сессионных кук.
// > Возвращает FALSE в случае неудачи; иначе TRUE.
    $r = session_start();   // TRUE

// void session_write_close( void )
// > Сохраняет все данные сессии и закрывает ее
// > Запускается автоматически после того, как скрипт заканчивает работу.
    session_write_close();

// bool session_destroy( void )
// > Удалить все из файла текущей сессии
//   > Соответственно, запускается после session_start()
    session_start();
        session_destroy();
    session_write_close();

// int session_status( void )
// > Возвращает текущее состояние сессии, а именно одно из:
//   > PHP_SESSION_DISABLED   | механизм сессий отключен
//   > PHP_SESSION_NONE       | механизм сессий включен, но сессия не создана
//   > PHP_SESSION_ACTIVE     | механизм сессий включен, и сессия создана
    $r = session_status();   // 1     == PHP_SESSION_NONE
    session_start();
    $r = session_status();   // 2     == PHP_SESSION_ACTIVE
    session_write_close();

// int session_cache_expire([string $new_cache_expire])
// > (возвращает | устанавливает новое) значение session.cache_expire
// > Если параметр не передан, то просто возвращает значение.
// > Если передан параметр, то устанавливает новое значение.
    $r = session_cache_expire();   // 180

// string session_cache_limiter( [string $cache_limiter] )
// > (возвращает | устанавливает новое) значение session.cache_limiter
    $r = session_cache_limiter();  // 'nocache'

// string session_name([ string $name ])
// > (возвращает | устанавливает) имя сессии
//   > Допустимы только символы: [a-z] [A-Z] [0-9]
//   > Которое используется, как название куки
//   > Поэтому эта функция должна быть запущена до session_start()
    $r = session_name();    // PHPSESSID

// string session_id([string $id])
// > (возвращает | устанавливает) ID текущей сессии
//   > Если используются сессионные куки, и с помощью этой функции был изменен
//     ID сессии, то будут посланы новые куки, не смотря на то, что это одна и таже сессия.
//     > Поэтому эта функция должна быть запущена до session_start()
//   > Допустимы только символы: [a-z] [A-Z] [0-9] [.] [-]
    $r = session_id();    // 75mtpl7e5gqmk2sbiep2vmhou2    это ID текущей сессии
                          // sess_75mtpl7e5gqmk2sbiep2vmhou2    это имя файла текущей сессии

// bool session_decode( string $data )
// > Декодирует данные из переданной строки $data и заполняет ими массив $_SESSION
// > Это не тоже самое, что unserialize(), а внутренний метод PHP, указанный в session.serialize_handler.
// > Запускается после session_start() (иначе работать не будет)
    //$fname = session_save_path() . "/sess_" . session_id();
    $fname = session_save_path() . '/sess_mysesstestfile';    // путь к моему вручную созданному для теста файлу сессии
    session_start();
    $r = session_decode(file_get_contents($fname));   // mySessTestVar = 20    Переменная, которую я вручную вписал в свой тестовый сессионный файл
    /*
    echo "<br><pre>";
    print_r($_SESSION);   // просмотреть содержимое массива $_SESSION
    echo "<br></pre>";
    */
    session_write_close();

// string session_save_path([ string $path ])
// > (возвращает | устанавливает) строку, содержащую текущий путь к директории для сохранения файлов сессии
    $r = session_save_path();    // C:\php-5.5.0-Win32-VC11-x64\tmp

// string session_encode( void )
// > Кодирует данные из $_SESSION и возвращает строку с результатом
// > Это не тоже самое, что unserialize(), а внутренний метод PHP, указанный в session.serialize_handler.
// > Запускается после session_start() (иначе работать не будет)
    session_start();
    $r = session_encode();   // count|i:17;mySessTestVar|i:20;
    session_write_close();

// array session_get_cookie_params( void )
// > Возвращает массив с информацией о cookie текущей сессии, который содержит:
//   > lifetime     - время жизни cookie в секундах
//   > path         - путь, где размещена хранимая информация
//   > domain       - домен cookie
//   > secure       - (TRUE | FALSE) должны ли куки передаваться только через HTTPS
//   > httponly     - (TRUE | FALSE) доступны ли куки только по протоколу HTTP
    $arr = session_get_cookie_params();

    echo "<br><pre>";
    print_r($arr);          // посмотреть переданные значения
    echo "<br></pre>";


// void session_set_cookie_params( int $lifetime [, string $path [, string $domain [,
//                                 bool $secure = false [, bool $httponly = false ]]]] )
// > Задает кастомные параметры сессионных кук до конца скрипта
// > Все эти параметры определены в php.ini, поэтому если их задать через эту функцию,
//   то действовать они будут только до конца скрипта.
// > Запускать фукнцию надо до session_start() - то есть до отправки, собственно, кук клиенту
// > Задает следующие параметры:
//   > lifetime     - время жизни cookie в секундах
//   > path         - путь, где размещена хранимая информация
//   > domain       - домен cookie
//   > secure       - (TRUE | FALSE) должны ли куки передаваться только через HTTPS
//   > httponly     - (TRUE | FALSE) доступны ли куки только по протоколу HTTP
    session_set_cookie_params(0, '/' ,'' ,'' ,'');



// string ini_get( string $varname )
// > Возвращает значение директивы из php.ini с переданным именем
// > Те же значения, что дает session_get_cookie_params, можно получить с помощью ini_get()
    $arr = [
        'lifetime' => ini_Get('session.cookie_lifetime'),
        'path' => ini_Get('session.cookie_path'),
        'domain' => ini_Get('session.cookie_domain'),
        'secure' => ini_Get('session.cookie_secure'),
        'httponly' => ini_Get('session.cookie_httponly'),
    ];
    /*
    echo "<br><pre>";
    print_r($arr);          // посмотреть переданные значения
    echo "<br></pre>";
    */

// bool session_regenerate_id([ bool $delete_old_session = false ])
// > Генерирует новый id для текущей сессии, и заменяет им старый
//   > При этом информация сессии сохраняется
// > Если $delete_old_session == TRUE, информация старой сессии удаляется; иначе сохраняется.
    session_start();
    $old_sessionid = session_id();
        session_regenerate_id();
    $new_sessionid = session_id();
    echo '<br>Старый ID сессии = ' . $old_sessionid;  // r20d6p2u8qf53gfj8rqu7va310
    echo '<br>Новый ID сессии = ' . $new_sessionid;   // e7id394r0vbk57ngev1fj4slo4
    session_write_close();

// void session_unset( void )
// > Очищает все сессионные переменные текущей сессии
    session_unset();




/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------



Ссылки:
> Официальное руководство по сессиям на php.net:
    http://www.php.net/manual/ru/book.session.php




*****************************************************
Оглавление:


  > Общая информация
  > Безопасность сессий. Как ее максимизировать?
  > Session ID
  > Отслеживание прогресса загрузки файлов с помощью сессий
  > Особенности некоторых настроек сессий
  > Опции и настройки сессий в файле php.ini


*****************************************************



> Общая информация
  > У HTTP-протокола нет механизмов сохранения данных между 2-мя и более страницами.
    Поэтому в PHP для этого были созданы механизмы Cookies и Sessions.
  > Поддержка сессий включена в PHP по умолчанию
  > Модель работы сессий:
    > Дается команда на создание сессии.
    > Запускается обработчик сессии. Либо стандартный, либо кастомный.
    > Далее возможны 2 пути (для стандартного обработчика):
      > Если session ID был передан либо через URL, либо получен от клиента в виде
        сессионной куки - то PHP идет в папку session.save_path, ищет там файл с
        названием, содержащим этот ID, и извлекает из него данные в суперглобальный
        массив $_SESSION.
      > Если session ID не был передан, то будет создана новая сессия.
        > В папке по адресу session.save_path создается новый файл с именем,
          содержащим ID сессии.
        > Клиенту отсылается сессионная кука с ID сессии.
        > PHP заполнит массив $_SESSION сессионной информацией.
        > После завершения работы PHP с помощью обработчика, указанного в
          session.serialize_handler, сериализует содержимое массива $_SESSION,
          и записывает в файл.
  > Нельзя использовать ссылки в сессионных переменных
  > Можно написать свой обработчик сессий или обертку для стандартных сессий
    с помощью session_set_save_handler().
    > Можно реализовать хранение сессий в базе данных.


> Безопасность сессий. Как ее максимизировать?
  > Обсуждение сессий на хабре: http://habrahabr.ru/post/35343/
  > Использовать только передачу session ID через сессионные куки, и не использовать
    его передачу через URL. Потому что URL могут подсмотреть, он также может быть
    сохранен где-нибудь поисковыми или статистическими системами, и в итоге наш
    ID сессии будет лежать в публичном доступе для всех.
    > Проблема отключенные кук у клиента
      > Клиент может у себя в браузере отключить куки. Тогда, если сессии настроены
        только на работу через сессионные куки, то они работать у такого клиента
        не будут. Что же делать?
        > Обойдемся без такого клиента. Безопасность важнее.
  > Использовать безопасное соединение HTTPS. Ведь если соединение не безопасное -
    HTTP - то ID сессии передается в виде простого текста, и прослушивающий канал
    злоумышленник легко может этот ID узнать.


> Session ID
  > Когда клиент посылает серверу запрос на доступ к его ресурсу, PHP проверяет,
    был ли послан вместе с запросом session ID, и если был, то находит с его помощью
    у себя файл, содержащий у себя в названии этот ID, и PHP скрипту становятся доступны
    данные из этого файла через суперглобальный массив $_SESSION
  > Session ID может быть послан вместе с запросом 2-мя способами, PHP использует
    те способы, которые указаны в php.ini:
    > Это может быть кука с ID от клиента
    > ID может быть послано в URL запроса
  > Отсутствие session ID хотя бы в одном из двух вышеуказанных вариантов сообщает
    PHP о том, что необходимо создать новую сессию и сгенерировать новый session ID.
  > PHP при запросе ресурса проводит проверку наличия session ID в следующих случаях:
    > Если в php.ini директива session.auto_start == 1
      > ! Если ты используешь этот способ старта сессии, сессионные куки у пользователя
        созданы не будут. А будут только если использовать session_start();
    > По явному запросу через вызов session_start();
    > По неявному запросу через вызов session_register();


> Отслеживание прогресса загрузки файлов с помощью сессий
  > Модель работы
    > Чтобы механизм отслеживание прогресса загрузки файла в PHP работал,
      нужно, чтобы в php.ini директива session.upload_progress.enabled == 1
  > Особенности
    > Не работает, если PHP запущен как fastcgi.


> Особенности некоторых настроек сессий
  > session.save_path
    > Надо сохранять файлы сессии туда, где доступ к ним не смогут получить
      посторониие. Иначе эти постороннии смогут получить доступ к данным пользователей в сессиях.
  > session.gc_maxlifetime
    > Допустим, на сайте > 1 скрипта PHP использую механизм сессий. И у них разные
      значения session.gc_maxlifetime. В этом случае скрипт с минимальным значением
      уничтожит все данные, если будет запущен, а с момента создания этих данных прошло
      указанное количество секунд. \
  > session.cookie_lifetime
    > Отметка времени устанавливается по отношению к серверному времени, которое
      не обязательно совпадает со временем на клиенте
  > session.use_only_cookies
    > Если этот параметр не установить в 1, то возможны атаки на клиентские куки
      путем размещения ID сессии в URL. Так что лучше всегда ставить 1.
  > session.cookie_httponly
    > Работает не во всех браузерах
    > Позволяет защититься от XSS атак, если == 1
  > session.bug_compat_42  и  session.bug_compat_warn
    > == 1 Включать при разработке, чтобы баги, связанные с этим, не стали невидимыми
    > == 0 Выключить на боевом сервере.
  > session.hash_function
    > 0   - MD5
    > 1   - SHA-1
    > Можно указать любой из расширения HASH. Их список здесь: http://www.php.net/manual/ru/ref.hash.php
    > Получить полный список доступных вариантом можно в коде функцией hash_algos()
  > session.upload_progress. ...
    > Прогресс загрузки НЕ будет обрабатываться, если:
      > session.upload_progress.enabled == 0
      > и не установлено session.upload_progress.name


> Опции и настройки сессий в файле php.ini:
  > Оригинальное описание можно найти здесь:
    http://www.php.net/manual/ru/session.configuration.php

      И М Я   П А Р А М Е Т Р А         К Р А Т К О Е   О П И С А Н И Е
    > session.save_path               | путь к директории для сохранения файлов сессии
    > session.name                    | название сессии, используемое как название соотв. куки; по умолчанию - PHPSESSID; только цифры и буквы;
    > session.save_handler            | имя обработчика, используемого для хранения и извлечения данных, связанных с сессией
    > session.auto_start              | (0 | 1) будет ли сессия запускаться автоматом при старте (по умолчанию 0)
    > session.serialize_handler       | имя обработчика, используемого для сериализации и десериализации данных сессии

    > session.gc_probability          | > Вероятность запуска сборщика мусора при каждой инициализации сессии
    > session.gc_divisor              |   = gc_probability / gc_divisor = 1 / 1000 (по умолчанию)
    > session.gc_maxlifetime          | > число секунд с момента создания файла сессии, по истечении которого он будет рассмотрен, как мусор, и удален сборщиком мусора; по умолчанию 1440 секунд = 24 минуты

    > session.cookie_lifetime         | определяет сколько живут сессионные куки в секундах с момента создания; по умолчанию 0 - до закрытия браузера.
    > session.cookie_path             | путь, для которого куки валидны; по умолчанию '/' - т.е. для всего сайта от корня
    > session.cookie_domain           | домен, для которого куки валидны; по умолчанию пусто.
    > session.cookie_secure           | должны ли куки передаваться только через HTTPS? По умолчанию 0.
    > session.cookie_httponly         | должны ли куки передаваться только через HTTP протокол? По умолчанию 0. Значит, куки не будут доступны, например, через JavaScript. Позволяет защититься от XSS атак.
    > session.use_cookies             | использовали ли куки для хранения ID сессии на стороне клиента? По умолчанию 1
    > session.use_only_cookies        | использовать ли ТОЛЬКО куки для хранения ID? Предотвращает атаки с размещением ID в URL. По умолчанию 1.

    > session.referer_check           | по умолчанию ''; сверяет указанное значение с полученным в заголовке referer; если не совпадают, то сессия считается недействительной. Это такое средство безопасности, чтобы убедиться, что клиент пришел откуда с моего домена (откуда ожидался).
    > session.entropy_file            | путь к файлу, который используется в качестве доп. источника энтропии при создании ID сессии
    > session.entropy_length          | кол-во байт, которые будут прочитаны из этого самого файла; по умолчанию 0
    > session.cache_limiter           | по умолчанию nocache; определяет метод контроля кэша, используемого для страниц сессий. Возможные значения: ( nocache | private | public )
    > session.cache_expire            | время жизни кэшированных страниц сессий в минутах; не работает, если session.cache_limiter: nocache
    > session.use_trans_sid           | если == 1, то ID сессии будет добавляться к URL в адресной строке браузера всегда. Не безопасно.
    > session.bug_compat_42           | можно ли инициализировать переменную сессии как глобальную, даже при отключенной register_globals?
    > session.bug_compat_warn         | предупреждать ли (warning), что bug_compat_42 включена?
    > session.hash_function           | возможность указать алгоритм хэширования, используемый для получения ID сессии
    > session.hash_bits_per_character | определить сколько бит хранится в каждом символе при преобразовании из 2-ного кода (по умолчанию 5)
    > url_rewriter.tags               | определяет какие теги будут переписаны при включении ID сессии при условии включенной  transparent sid; по умолчанию: a=href,area=href,frame=src,input=src,form=fakeentry,fieldset=

    > session.upload_progress.enabled | по умолчанию 1; отслеживание прогресс процесса загрузки файлов и заполнение соотв. переменной в $_SESSION
    > session.upload_progress.cleanup | по умолчанию 1; чистка информации о прогрессе загрузки файлов по завершении обработки POST-данных (загрузки). Отключать не рекомендуется.
    > session.upload_prorgess.prefix  | по умолчанию "upload_progress_"; уникальный префикс для ключа прогресса загрузки в массиве $_SESSION
    > session.upload_progress.name    | по умолчанию "PHP_SESSION_UPLOAD_PROGRESS"; ключ  в $_SESSION, в котором будет инфа о прогрессе = session.upload_prorgess.prefix + session.upload_progress.name ;
    > session.upload_progress.freq    | по умолчанию 1%; частота обновления инфы о прогрессе; либо каждые N байт, либо каждые M %-ов.
    > session.upload_progress.min_freq| по умолчанию 1 секунда; минимальная задержка между обновлениями

-------------------------------------------------- */
?>






















