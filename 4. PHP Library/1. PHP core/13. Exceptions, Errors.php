<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Исключения, ошибки - обработка и протоколирование

Ошибки
> show_error_types_status    | (пользовательская) Показывает статус 16 групп ошибок (вкл/выкл)
> debug_backtrace            | Позволяет определить всю цепочку вызовов функций, которая привела к вызову этой
                                функции (в которой запущена функция debug_backtrace). Возвращает массив со стеком вызовов.
> debug_print_backtrace      | Тоже самое, что debug_backtrace, только сразу выводит на экран.
> error_get_last             | Возвращает массив с информацией о последней произошедшей ошибке
> error_reporting            | С ее помощью можно Вкл/Выкл группы ошибок, попадающих в отчет
> error_log                  | Отправляет сообщение об ошибке в системный лог, файл, по email
> user_error                 | Вызывает пользовательскую ошибку/предупреждение/уведомление
> set_error_handler          | Установить пользовательскую функцио обработки ошибок
> set_exception_handler      | Установить пользовательский обработчик исключений
> restore_error_handler      | Вернуть предыдущий обработчик ошибок
> restore_exception_handler  | Вернуть предыдущий обработчик исключений


Исключения
> Принцип работы исключений в 1 примере - THROW, TRY, CATCH, FINALLY
> Класс Exception
  > Свойства: message,   | сообщение исключения
              code,      | код исключения
              file,      | файл, в котором вызвано исключение
              line       | строка, в которой произошло исключение
  > __construct       | конструктор класса Exception
  > getMessage        | возвращает сообщение исключения
  > getPrevious       | возвращает ссылку на предыдущее объект-исключение (переданное 3-м параметром при конструировании этого объекта)
  > getCode           | возвращает код исключения
  > getFile           | возвращает имя файла, в котором было создано исключение
  > getLine           | возвращает номер строки, в которой было создано исключение
  > getTrace          | возвращает трассировку стека исключения в виде массива (анало функции debug_backtrace)
  > getTraceAsString  | возвращает трассировку стека исключения в виде строки
  > __toString        | возвращает строковое представление этого объекта класса Exception
  > __clone           | пытается клонировать исключение, что приводит к фатальной ошибке (исключения нельзя клонировать)
> Класс ErrorException (наследник класса Exception)
  > __construct       | конструктор класса ErrorException
  > getSeverity       | возвращает критичность исключения в виде целого числа
  > Превращение сообщений об ошибках в объект класса ErrorException

-------------------------------------------------- */




########################################################
// --------------------> Ошибки <-------------------- //


// void | bool show_error_types_status( [string $name] )
// > (пользовательская) Показывает статус 16 групп ошибок (вкл/выкл)
/**
 * Если аргумент $name не передан, выводит на экран статусы всех 16 групп ошибок
 * (включено/выключено)
 * Если аргумент $name задан, то возвращает значение типа bool - если этот тип
 * ошибок включен, то 1. Иначе 0.
 * @author German Manvelov <4gekkman@gmail.com>
 * @version 1.0
 * @param string $name аргумент №1
 * @return void|bool см. описание
 */
function show_error_types_status($name='') {

    // Массив соответствия константы группы ошибок и ее имени
        $errors = [
            E_ERROR              => 'E_ERROR',
            E_WARNING            => 'E_WARNING',
            E_PARSE              => 'E_PARSE',
            E_NOTICE             => 'E_NOTICE',
            E_CORE_ERROR         => 'E_CORE_ERROR',
            E_CORE_WARNING       => 'E_CORE_WARNING',
            E_COMPILE_ERROR      => 'E_COMPILE_ERROR',
            E_COMPILE_WARNING    => 'E_COMPILE_WARNING',
            E_USER_ERROR         => 'E_USER_ERROR',
            E_USER_WARNING       => 'E_USER_WARNING',
            E_USER_NOTICE        => 'E_USER_NOTICE',
            E_STRICT             => 'E_STRICT',
            E_RECOVERABLE_ERROR  => 'E_RECOVERABLE_ERROR',
            E_DEPRECATED         => 'E_DEPRECATED',
            E_USER_DEPRECATED    => 'E_USER_DEPRECATED',
            E_ALL                => 'E_ALL'
        ];

    // Получить битовую маску с информацией о статусах всех групп ошибок
        $errLvl = error_reporting();

    // Вывести на экран результат списком, если $name == '' (не задан)
        if($name == '') {
            echo '<br><br><b>Статусы групп ошибок: </b><br>';
            $resArr = [];
            foreach ($errors as $key => $value) {
                if( $errLvl & $key ) {
                    $resArr[$value] = 1;
                } else {
                    $resArr[$value] = 0;
                }
            }

            // Вывести результаты на экран
            echo "<br><pre>";
            print_r($resArr);
            echo "<br></pre>";

            // Закончить функцию
            return 0;
        }

    // Если $name задан, вернуть 1, если эта группа ошибок включена, либо вернуть 0.
        $res = false;
        foreach ($errors as $key => $value) {
            if( $name == $value ) {
                $res = true;
            }
        }
        return $res;
}

    // Тест работы функции show_error_types_status() :
    show_error_types_status();


// array debug_backtrace([ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0 ]] )
// > Позволяет определить всю цепочку вызовов функций, которая привела к вызову этой
//   функции (в которой запущена функция debug_backtrace). Возвращает массив со стеком вызовов.
// > Вызывается
// > $options - битовая маска с опциями. Есть 2 возможные опции:
//   > DEBUG_BACKTRACE_PROVIDE_OBJECT  | заполнять ли элемент массива с ключем object
//   > DEBUG_BACKTRACE_IGNORE_ARGS     | игнорировать ли заполнение элемента массива с ключем args
// > $limit - ограничивает кол-во вызовов ф-ий, инфа о которых будет возвращена; 0 - значит вернуть все.
// > Возвращает индексированный массив массив, с индексами от 0 и выше.
//   [0] - содержит информацию о последнем вызове; [1] - о предпоследнем ... и т.д.
//   В каждом индексе содержится массив со следующими значениями:
//     > function | Имя текущей функции. См. также __FUNCTION__
//     > line     | Текущий номер строки. См. также __LINE__
//     > file     | Имя текущего файла. См. также __FILE__
//     > class    | Имя текущего класса. См. также __CLASS__
//     > object   | Текущий объект
//     > type     | Текущий тип вызова функции. Если это вызов метода объекта, будет
//                  выведено "->". Если это вызов статического метода класса,
//                  то "::". Если это простой вызов функции, не выводится ничего.
//     > args     | При нахождении внутри функции, будет выведен список аргументов этой
//                  функции. Если внутри включаемого файла, будет выведен список включаемых файлов.

    // Создать цепочку функций a() -> b() -> c(). Если вызвать a(), то будет вызвана b(),
    // и далее по цепочке c().
        // a()
        function a() {
            b();
        }

        // b()
        function b() {
            c();
        }

        // c()
        function c() {
            // Получить стек с информацией о вызовах функций в массив
            $arr = debug_backtrace();

            // Посмотрим, что в массиве
            echo "<br><pre>";
            print_r($arr);
            echo "<br></pre>";
        }

    // Запустить цепочку вызовов
        a();

// void debug_print_backtrace([ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0 ]] )
// > Тоже самое, что и debug_backtrace. Только сразу выводит информацию на экран.
// > Ничего не возвращает. Выводит урезанную по сравнению с debug_backtrace() информацию.

    // Создать цепочку функций a() -> b() -> c(). Если вызвать a(), то будет вызвана b(),
    // и далее по цепочке c().
        // a()
            function a1() {
                b1();
            }

        // b()
            function b1() {
                c1();
            }

        // c()
            function c1() {
                // Вывести на экран стек с информацией о вызовах функций в массив
                    debug_print_backtrace();
            }

        // Запустить цепочку вызовов
            a1();

// array error_get_last( void )
// > Возвращает массив с информацией о последней произошедшей ошибке
//   > Либо NULL, если ошибок не произошло.
// > Ключи массива:
//   > type     | номер ошибки
//   > message  | сообщение об ошибке
//   > file     | путь к файлу, в котором ошибка
//   > line     | номер строки файла, в котором ошибка

    // Специально создать ошибку
        echo $sdsdfgd;

    // Получить информацию о последней ошибке
        $arr = error_get_last();

    // Посмотреть содержимое полученного массива
        echo "<br><pre>";
        print_r($arr);
        echo "<br></pre>";
        /*
            [type] => 8
            [message] => Undefined variable: sdsdfgd
            [file] => C:\Users\Administrator\Desktop\Practice\3. PHP Library\PHP  -  base\13. Exceptions, Errors.php
            [line] => 198
         */

// int error_reporting([ int $level ])
// > С ее помощью можно Вкл/Выкл группы ошибок, попадающих в отчет
// > По сути происходит задание значения директивы error_reporting в php.ini на время выполнения этого скипта.
// > $level - битовая маска из именованных констант. Попавшие в эту маску константы включат соответствующие
//            группы ошибок. Остальные же будут выключены.
//   > Имена констант можно посмотреть здесь: http://www.php.net/manual/ru/errorfunc.constants.php
// > Возвращает:
//   > Текущую битовую маску, если $level не задан.
//   > Предыдущую битовую маску, если $level задан.

    // Выключить протоколирование ошибок
        error_reporting(0);
        error_reporting(~E_ALL);    // синоним error_reporting(0);
        show_error_types_status();  // вывести текущие статусы всех групп ошибок

    // Включать в отчет простые описания ошибок
        error_reporting(E_ERROR | E_WARNING | E_PARSE);
        show_error_types_status();

    // Включать в отчет E_NOTICE сообщения (добавятся сообщения о
    //непроинициализированных переменных или ошибках в именах переменных)
        error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);
        show_error_types_status();

    // Добавлять сообщения обо всех ошибках, кроме E_NOTICE
    // Это значение включено по умолчанию в php.ini
        error_reporting(E_ALL ^ E_NOTICE);
        show_error_types_status();

    // Добавлять в отчет все PHP ошибки (см. список изменений)
        error_reporting(E_ALL);
        ini_set('error_reporting', E_ALL);  // это синоним error_reporting(E_ALL);
        error_reporting(-1);                // это синоним error_reporting(E_ALL);
        show_error_types_status();

// bool error_log( string $message [, int $message_type = 0 [, string $destination [,
//                 string $extra_headers ]]] )
// > Отправляет сообщение об ошибке в системный лог, файл, по email
// > $message - строка с отправляемым сообщением.
// > $message_type - куда отправляется сообщение. Варианты:
//   > 0
//     > Что это означает - зависит от значения директивы error_log в php.ini:
//       > Если ничего не установлено, значит в лог веб-сервера (см. его конф. файл)
//       > Если установлено syslog - значит в syslog (UNIX) или event log (windows)
//       > Если установлен путь к файлу, то в него. Например: 'c:\phplog.log'. Но к нему должен быть доступ на запись.
//   > 1 - $message отправляется по e-mail, установленный в $destination. В $extra_headers можно задать доп. заголовки.
//   > 3 - $message записывается в указанный в $destination файл. Перенос строки автоматом НЕ добавляется в конце $message.
//   > 4 - Сообщение отправляется в лог веб-сервера (SAPI).
// *Примечание: эту функцию удобно использовать для дебага с программой, которая в режиме
//              онлайн выводит все поступающие в лог-файл сообщения.

    // Отправить сообщение в лог-файл
        error_log("\nСообщение №1 в лог-файл\n", 3, 'logfile.log');

    // Отправить сообщение по email
        error_log('Сообщение №2 по email', 1, '4gekkman@gmail.com');

    // Отправить сообщение в лог сервера
        error_log('Сообщение №3 в лог сервера', 4, '4gekkman@gmail.com');

// bool user_error( string $error_msg [, $error_type = E_USER_NOTICE ] )
// > Вызывает пользовательскую ошибку/предупреждение/уведомление
// > $error_msg - сообщение об ошибке. MAX 1024 символа.
// > $error_type - тип ошибки. Работает только с константами семейства E_USER_ :
//   > E_USER_ERROR        | тоже, что E_ERROR, только сгенерированные пользователем
//   > E_USER_WARNING      | тоже, что E_WARNING, только сгенерированные пользователем
//   > E_USER_NOTICE       | тоже, что E_NOTICE, только сгенерированные пользователем
//   > E_USER_DEPRECATED   | тоже, что E_DEPRECATED, только сгенерированные пользователем
// > Возвращает FALSE, если задан неправильный error_type. Иначе true.

    trigger_error("Не могу поделить на ноль", E_USER_WARNING);


// mixed set_error_handler( callable $error_handler [, int $error_types = E_ALL | E_STRICT ])
// Установить пользовательскую функцио обработки ошибок
// > $error_handler - колбек-функция-обработчик ошибок
//   > Должна соответствовать следующей сигнатуре:
//     > bool handler ( int $errno , string $errstr [, string $errfile [, int $errline [, array $errcontext ]]] )
//       > errno      | содержит номер ошибки
//       > errstr     | содержит сообщение об ошибке
//       > errfile    | содержит путь к файлу с ошибкой
//       > errline    | содержит номер строки в файле с ошибкой
//       > errcontext | содержит ссылки на все переменные контекста, в котором возникла ошибка. Нельзя модифицировать!
//   > Чтобы сбрость $error_handler в дефолтное состояние, нужно передать NULL вместо него.
// > $error_types - группы ошибок, которые будет обрабатывать функция $error_handler.
//                  Принимает значение в виде битовой маски.
//   > Стандартный обработчик PHP будет игнорировать ошибки, указанные в $error_types,
//     есди только $error_handler в ответ на соответствующую ошибку не вернет FALSE.
// > Возвращает:
//   > Строку с именем предыдущего обработчика (если есть).
//   > NULL, если нет предыдущего встроенного обработчика, или если ошибка в аргументах.
//   > Массив, содержащий имя класса и имя метода, если определенный обработчик является методом
// > *Примечание: вызов функции exit() также на совести пользовательской функции-обработчика.
// > ** Примечание: следующие группы ошибок не могут быть обработаны пользовательской функцией:
//      E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING и E_STRICT

    // Установить обработчик ошибок в его дефолтное состояние
        set_error_handler(null);

    // Объявить функцию, которую далее сделать пользовательским обработчиком ошибок
        function myErrorHandler($errno, $errstr) {

            // Массив соответствия константы группы ошибок и ее имени,
            //  которые может обработать пользовательский обработчик
                $errors = [
                    E_WARNING            => 'E_WARNING',
                    E_NOTICE             => 'E_NOTICE',
                    E_USER_ERROR         => 'E_USER_ERROR',
                    E_USER_WARNING       => 'E_USER_WARNING',
                    E_USER_NOTICE        => 'E_USER_NOTICE',
                    E_RECOVERABLE_ERROR  => 'E_RECOVERABLE_ERROR',
                    E_DEPRECATED         => 'E_DEPRECATED',
                    E_USER_DEPRECATED    => 'E_USER_DEPRECATED',
                    E_ALL                => 'E_ALL'
                ];

            // Если произошла одна из тех ошибок, которые пользовательский обработчик не
            // может обработать, вернуть false, чтобы передать ее стандартному обработчику
                $res = false;
                foreach ($errors as $key => $value) {
                    if($key == $errno) {
                        $res = $key;
                    }
                }
                if($res == false) {
                    return $res;
                }

            // Если эту ошибку обработать можно, то послать сообщение в лог-файл
            $msg = 'Произошла ошибка '.$errno."\n Сообщение об ошибке: ".$errstr;
            error_log($msg, 3, 'logfile.log');  // в результате в этот файл будет записано сообщение об ошибке
        }

    // Установить вышеобъявленную функцию в качестве пользовательского обработчика ошибок
        set_error_handler('myErrorHandler');

    // Искуственно вызвать пользовательскую ошибку (сообщение об ошибке будет записано в лог)
        trigger_error("Не могу поделить на ноль", E_USER_WARNING);

// callable set_exception_handler( callable $exception_handler )
// > Установить пользовательский обработчик исключений

    // Определить функцию-обработчик
    function exception_handler($exception) {
        echo 'Неперехватываемое исключение: ', $exception->getMessage(), '<br>';
    }

    // Назначить определенную функцию пользовательским обработчиком исключений
    set_exception_handler('exception_handler');

    // Вызвать исключение вне блока try, так что оно попадает в пользовательский обработчик
    throw new Exception('Неперехватываемое исключение');

    // Этот код и код далее не исполнится, так как исключение не поймано с помощью catch
    echo 'Не выполнено<br>';


// bool restore_error_handler( void )
// > Вернуть предыдущий обработчик ошибок
// > Всегда возвращает TRUE


// restore_exception_handler
// > Вернуть предыдущий обработчик исключений
// > Всегда возвращает TRUE







############################################################
// --------------------> Исключения <-------------------- //
echo '<br><br><b style="font-size: 20px; color:red;">Исключения</b><br><br>';


// Принцип работы исключений в 1 примере - THROW, TRY, CATCH, FINALLY
    try {
        throw new Exception('Возникла ошибка. Брошено исключение.');
    } catch( Exception $e) {
        echo 'В блоке catch поймано исключение. Его сообщение: ' . $e->getMessage() . '<br>';  // В блоке catch поймано исключение. Его сообщение: Возникла ошибка. Брошено исключение.
    } finally {                                                                                // finally вызывает в PHPstorm ошибку, потому что он еще не поддерживет PHP 5.5
        echo 'Выполняется блок finally.<br>';  // 'Выполняется блок finally.'
    }
    // продолжение нормального выполнения
    echo 'Продолжение нормального выполнения';

// Класс Exception

    // public __construct([ string $message='', [, int $code=0 [, Exception $previous=NULL ]]])
    // > конструктор класса Exception
    // > Параметр $previous (предыдущее исключение) - используется при создании цепочки исключений
    // > $message и $code - сообщение и код исключения
        try {
            throw new Exception('произошла ошибка!', 10);     // Создание нового объекта Exception с помощью конструктора
        } catch( Exception $e ) {
            echo "<br><br>Поймано исключение!<br>";
            echo "Сообщение исключения: ".$e->getMessage();   // 'произошла ошибка!'
            echo "<br>Код исключения: ".$e->getCode();        // 10
            echo "<br>Файл, в котором произошло исключение: ".
                $e->getFile();                                // 'C:\Users\Administrator\Desktop\Practice\3. PHP Library\PHP - base\13. Exceptions, Errors.php'
            echo "<br>Номер строки, вызвавшей исключение: ".
                $e->getLine();                                // 399
        }

    // final public string getMessage( void )
    // > возвращает сообщение исключения
        // см. пример выше

    // final public mixed getCode( void )
    // > возвращает код исключения
        // см. пример выше

    // final public string getFile( void )
    // > возвращает имя файла, в котором было создано исключение
        // см. пример выше

    // final public int getLine( void )
    // > возвращает номер строки, в которой было создано исключение
        // см. пример выше

    // final public Exception getPrevious( void )
    // > возвращает ссылку на предыдущее объект-исключение (переданное 3-м параметром при конструировании этого объекта)
    // > Пример ниже выводит информацию сначала о 2-м исключении, а затем о 1-м.
        function errorFunc() {
            try {
                throw new Exception('Исключение 1', 10);
            } catch ( Exception $e ) {
                throw new Exception('Исключение 2', 10, $e);
            }
        }
        try {
            errorFunc();
        } catch ( Exception $e ) {
            // Цикл обработки всех доступных объектов-исслючений
                while($e) {
                    echo '<br><br>Сообщение: '.$e->getMessage();
                    echo '<br>Код: '.$e->getCode();
                    echo '<br>Файл: '.$e->getFile();
                    echo '<br>Строка: '.$e->getLine();
                    $e = $e->getPrevious();
                }
        }

    // final public array getTrace( void )
    // > возвращает трассировку стека исключения в виде массива (анало функции debug_backtrace)
    //   Позволяет отследить всю цепочку вызовов функций и методов, которые привели к этому исключению

        // Объявить цепочку функций, в конце которой бросается исключение
        function errorfunc2() {
            throw new Exception();
        }

        function errorfunc3() {
            errorfunc2();
        }

        function errorfunc4() {
            errorfunc3();
        }

        // Вызвать первую в цепочке функцию и поймать исключение
        try {
            errorfunc4();
        } catch(Exception $e) {

            // Вывести данные из массива о цепочке вызовов (трассировку стека вызовов)
                echo "<br><pre>";
                print_r($e->getTrace());
                echo "<br></pre>";

            // Вывести те же данные, только в виде строки
                echo '<br>Те же данные в виде строки:<br>'.$e->getTraceAsString();

            // Вывести строковое представление объекта-исключения
                echo '<br><br>Строковое представление объекта-исключения: '.$e;
        }

    // final public string getTraceAsString( void )
    // > возвращает трассировку стека исключения в виде строки
        // См. пример выше

    // public string __toString( void )
    // > возвращает строковое представление этого объекта класса Exception
        // См. пример выше

    // final private void __clone( void )
    // > пытается клонировать исключение, что приводит к фатальной ошибке (исключения нельзя клонировать)


// Класс ErrorException (наследник класса Exception)

    // public __construct([ string $message='', [, $code=0 [, $severity=1 [, string $filename=__FILE__ [,
    //                    int $lineno = __LINE__ [, Exception $previous = NULL ]]]]]] )
    // > конструктор класса ErrorException
        // см. пример ниже

    // final public int getSeverity( void )
    // > возвращает критичность исключения в виде целого числа
        try {
            throw new ErrorException('Exception message', 0, 75);
        } catch( ErrorException $e ) {
            echo '<br>Критичность этого исключения равна: '.$e->getSeverity();  // Критичность этого исключения равна: 75
        }

    // Превращение сообщений об ошибках в объект класса ErrorException


        // Определить функцию-обработчик исключений
            function exception_error_handler($errno, $errstr, $errfile, $errline) {
                throw new ErrorException($errstr, $errno, 0, $errfile, $errline);
            }

        // Установить пользовательский обработчик событий
            set_error_handler('exception_error_handler');

        // Вызвать исключение
            strpos();

/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------

Ссылки
> Функции по работе с ошибками
    http://www.php.net/manual/ru/book.errorfunc.php
> Вывод сообщений об ошибках (безопасность)
    http://www.php.net/manual/ru/security.errors.php
> Константы ошибок:
    http://www.php.net/manual/ru/errorfunc.constants.php
> Исключения
    http://www.php.net/manual/ru/language.exceptions.php
> Предопределенные исключения Exception и ErrorException
    http://www.php.net/manual/ru/reserved.exceptions.php
> Стандартный набор классов-исключений (SPL):
    http://www.php.net/manual/ru/spl.exceptions.php


Ошибки
> Группы ошибок
  > Есть 16 различных наборов (групп) ошибок. Каждая группа имеет свою константу
    и битовую маску.
    > Здесь можно просмотреть и подробно прочитать о каждой группе:
      http://www.php.net/manual/ru/errorfunc.constants.php
  > Вот несколько этих наборов:
    > E_ERROR
      > Фатальная ошибка при выполнении кода (например, открытие файла, которого нет)
      > Значение битовой маски: 1
    > E_WARNING
      > Не фатальная ошибка при выполнении кода. Код продолжает выполняться.
      > Значение битовой маски: 2
    > E_PARSE
      > Ошибки при парсинге (до начала выполнения кода)
      > Значение битовой маски: 4
    > E_NOTICE
      > Предупреждение. Код продолжает выполняться.
      > Значение битовой маски: 8
    > E_ALL
      > Все поддерживаемые ошибки и исключения
      > Значение битовой маски: 32767
> Протоколирование ошибок
  > Общая информация
    > С помощью функций протоколирования возможно напрямую отправлять сообщения об ошибках
      на другие машины, по электронной почте (или на смс-шлюзы), записывать в системные
      журналы и файлы. Это позволяет выборочно следить за наиболее важными частями
      приложений и сайтов.
    > Функции протоколирования позволяют настраивать тип и детализацию информации
      об ошибках того или иного типа от простых уведомлений до трассировки функций,
      вызвавших ошибку.
> Безопасность и ошибки
  > Вывод полной информации об ошибки на экран на боевом сайте - это большая
    дыра в безопасности.
    > Злоумышленник может специально вводить в разных местах не верные данные,
      получать подробную информацию об ошибке, и таким образом прощупывать весь
      код, и узнать достаточно информации для взлома.
    > Чтобы этого избежать, на боевом сайте следует
    > Решить эту проблему можно следующими способами:
      > Можно просто установить display_errors = Off, и тогда все ошибки будут скрыты
        от пользователя.
        > Но делать это не рекомендуется, потому что функция error_reporting() тогда
          не будет производить никакого эффекта, и самому же получить доступ к системным
          сообщениям об ошибке будет труднее.
        > Если же ты все-таки это сделал, то надо сделать еще 2 вещи:
          > Включить директиву log_errors      (вести лог ошибок)
          > В директиве error_log указать путь к лог-файлу.
      > А можно при установленном display_errors = On настроить вывод сообщений
        об ошибке функцией error_reporting()
        > Константы-аргументы для функции здесь: http://www.php.net/manual/ru/errorfunc.constants.php
      > А можно написать собственную функцию-обработчик ошибок
        > Как описано здесь: http://www.php.net/manual/ru/errorfunc.examples.php
        > Указать display_errors = On; error_reporting(0);


Исключения
> Общая информация об исключениях:
  > Как связаны между собой исключения и ошибки?
    > Ошибки - это старый функциональный метод отслеживания ошибок. Исключения - новый
      объектно-ориентированный. Удобнее, конечно, пользоваться последним.
    > Внутренние функции PHP в основном используют сообщения об ошибках. И только новые
      расширения, использующие ООП, работают с исключениями. Но это не беда, ведь сообщения
      об ошибках легко можно преобразовать в исключения с помощью класса ErrorException и
      установки пользовательского обработчика ошибок (см. пример выше).
  > Суть исключения - исключительная ситуация, в которой скрипт не может дальше продолжать
    работу, если только исключение не было поймано с помощью catch.
> Общий принцип работы с исключениями:
  > Весь принцип в 1 предложении:
    > Код, бросающий исключение, должен быть заключен в блоке TRY, под ним идет 1 или
      несколько ловящих исключение блоков CATCH, код в каждом из которых выполняется только
      если поймано соответствующее исключение, а в конце идет блок FINALLY, который исполняется
      в любом случае перед продолжением нормального выполнения кода, даже если исключение
      не было брошено.
  > Подробнее об операторе THROW
    > Бросить исключение - т.е. создать объект класса Exception - можно с помощью оператора
      throw.
    > Код после оператора THROW исполнен не будет.
    > Генерируемый объект-исключение должен обязательно принадлежать к классу Exception,
      или быть его наследником, иначе PHP выдаст сообщение о непоправимой ошибке.
  > Подробнее о блоке TRY
    > Код, сгенерировавший исключение, должен быть в блоке TRY, чтобы его можно было
      перехватить.
    > Каждый блок TRY должен иметь от 1 (минимум) и более соответствующих ему блоков CATCH.
  > Подробнее о блоке CATCH
    > Идет после блока TRY
    > Код, обрабатывающий исключения, должен содержаться в блоке CATCH.
    > Если никаких исключений небыло поймано, то нормальное исполнение кода продолжится
      за последним блоком CATCH.
    > Исключения также могут быть сгенерированы прямо внутри блока CATCH.
    > Заключение ВСЕГО скрипта в блок try позволит исключить возможность выдачи
      пользователю только частично отрисованной страницы.
  > Подробнее о блоке FINALLY
    > Идет после всех блоков CATCH конкретного блока TRY
    > Появился в PHP >= 5.5
    > Является НЕ обязательным.
    > Вне зависимости от ничего, всегда выполняется после блоков TRY и CATCH перед
      нормальным продолжением выполнения кода.
  > Про пользовательский обработчий исключений, брошенных вне блоков TRY / CATCH
    > Если пользовательский обработчик запущен, то вернуться назад в скрипт уже невозможно.
      В конце пользовательского обработчика скрипт умрет ( die() ).
      Таким образом единственное назначение использования пользовательского обработчика
      исключений - это красиво завершить работу скрипта, например, отрисовав красивую
      картинку.
      > Это позволяет в случае возникновения критических ошибок не выводить важную
        инфу на экран, а вывести только то, что требуется. Плюс можно записать сведения
        об ошибке в лог или послать e-mail о ней. Все это делаеся в пользовательском
        обработчике исключений.
    > Если исключение, сгенерированное в блоке TRY / CATCH не будет перехвачено, то:
      > Если пользовательский обработчик исключений, брошенных вне блоков TRY / CATCH,
        не определен функцией set_exception_handler(), то PHP выдаст сообщение об ошибке
        Uncaught Exception (неперехваченное исключение).
      > Если же такой обработчик определен, то исключение попадет в него.
    > Также в пользовательский обработчик попадают все исключения, сгенерированные
      вне блоков TRY / CATCH.


> Классификация исключений
  > Стандартная библиотека PHP (SPL) предоставляет хороший набор встроенных классов-исключений:
    > Их полное описание можно найти здесь: http://www.php.net/manual/ru/spl.exceptions.php
  > LogicException (extends exception)    | ошибка в логике программы
    > BadFunctionCallException            | вызов не определенной callback функции, или не все аргументы в порядке
      > BadMethodCallException            | вызов не определенного callback метода, или не все аргументы в порядке
    > DomainException                     | значение не придерживается определенных действительных данных домена
    > InvalidArgumentException            | аргумент не совпадает с ожидаемым значением
    > LengthException                     | если длина является недопустимой
    > OutOfRangeException                 | запрос несуществующего индекса
  > RuntimeException (extends exception)  | ошибка, которая может быть найдена только во время исполнения программы
    > OutOfBoundsException                | значение не является действительным ключем
    > OverflowException                   | попытка добавления элемента в полный контейнер
    > RangeException                      | версия класса DomainException
    > UnderflowException                  | попытка провести недопустимую операцию над пустым контейнером
    > UnexpectedValueException            | значение не совпадает с набором значений
























-------------------------------------------------- */
?>