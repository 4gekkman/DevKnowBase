<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
PDO - PHP Database Object

Основное
  > Установка соединения с БД, обработка возможных ошибок
  > Установка постоянного соединения
  > PDO - работа с транзакциями
  > PDO - установка разных режимов обработки ошибок 2 способами
  > Использование подготовленных выражений
    > Пример с использованием именованных меток-заполнителей вида :name
    > Пример с использованием безымянных меток-заполнителей вида ?
    > Извлечь данные из указанной таблицы в массив
    > Извлечь данные из указанной таблицы в массив, передав параметры в execute()
    > Запустить выполнение процедуры с параметром, извлечь результат
  > LOB - Работа с большими объектами данных (такими как картинки, видео и т.д.)
    > Загрузить картинку в базу данных через HTML форму
    > Извлечь картинку из базы данных и отобразить на экране


Справочник по методам классов PDO
  > Класс PDO  | соединение между PHP и СУБД
    > PDO::__construct         | создает объект PDO, представляющий соединение с СУБД
    > PDO::exec                | выполняет SQL-запрос и возвращает кол-во задействованных строк
    > PDO::query               | выполняет SQL-запрос и возвращает результат в виде объекта PDOStatement
    > PDO::prepare             | подготавливает SQL-запрос к выполнению, и возвращает ассоциированный с этим объект PDOStatement
    > PDO::beginTransaction    | начать транзакцию
    > PDO::commit              | сделать коммит
    > PDO::rollBack            | сделать роллбек
    > PDO::inTransaction       | проверяет, есть ли активные транзакции
    > PDO::errorCode           | возвращает код SQLSTATE результата последней операции с БД
    > PDO::errorInfo           | расширенная инфа об ошибке, произошедшей при последнем обращении к БД
    > PDO::getAvailableDrivers | возвращает массив доступных драйверов PDO
    > PDO::getAttribute        | извлекает значение атрибута соединения с БД
    > PDO::setAttribute        | устанавливает значение атрибута соединения с Б
    > PDO::quote               | заключает строку в кавычки для использования в запросе
    > PDO::lastInsertId        | возвращает ID последней вставленной строки

  > Класс PDOStatement  | подготовленное выражение, а после его выполнения - результирующая таблица
    > PDOStatement::execute         | выпнить подготовленное (prepare) выражение
    > PDOStatement::closeCursor     | закрывает курсор, позволяет выполнить выражение снова
    > PDOStatement::fetchAll        | возвращает массив, содержащий все результирующие столбцы и строки
    > PDOStatement::fetchColumn     | возвращает 1 значение из следующей строки из результирующего набора
    > PDOStatement::fetch           | возвращает массив со следующей строкой из результирующего набора
    > PDOStatement::fetchObject     | аналог fetch, только возвращает результат в видео объекта
    > PDOStatement::setFetchMode    | настроить, куда PDO пристроит извлеченные данные (т.н. режим)
    > PDOStatement::bindColumn      | связать значения из колонки с переменной PHP
    > PDOStatement::bindParam       | связать метку-заполнитель из SQL-запроса с PHP-переменной (по ссылке)
    > PDOStatement::bindValue       | связать метку-заполнитель из SQL-запроса c PHP-переменной или значением (не по ссылке)
    > PDOStatement::columnCount     | возвращает кол-во колонок в результирующей таблице
    > PDOStatement::rowCount        | возвращает кол-во строк в результирующей таблице
    > PDOStatement::getAttribute    | получить значение атрибута утверждения
    > PDOStatement::getColumnMeta   | получить метаданные колонки в кач-ве результирующей таблицы
    > PDOStatement::setAttribute    | установить значение атрибута утверждения
    > PDOStatement::errorCode       | возвращает код SQLSTATE результата последней операции с БД
    > PDOStatement::errorInfo       | расширенная инфа об ошибке, произошедшей при последнем обращении к БД
    > PDOStatement::debugDumpParams | вывести подготовленное (prepared) SQL-выражение на экран
    > PDOStatement::nextRowset      | Получить доступ к следующему result set (если результат - много результирующих таблиц, как у некоторых сохраняемых процедур)

  > Класс PDOException   | тип исключения, возвращаемый PDO в случае ошибки




-------------------------------------------------- */


###########
// Основное


// Установка соединения с БД, обработка возможных ошибок

  # Определить параметры подключения
  $host = 'localhost:3308';
  $dbname = 'test';
  $username = 'root';
  $password = '';

  # Выполнить подключение к серверу MySQL в блоке try ... catch (для обработки ошибок)
    # (для удобства и дальнейшего использования создана функция)
  function connectMySQL($host,$dbname,$username,$password) {
    try {
      # Установить соединение
      $c = new PDO('mysql:host='.$host.';dbname='.$dbname, $username, $password);
      //$c->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, TRUE);

      # Включить отображение ошибок
      $c->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

      # Сообщить об успешном соединеии и вернуть его.
      echo '<br><b>Соединение установлено!<b><br>';
      return $c;

    } catch(PDOException $e) {
      # Вывести подробности о пойманом исключении и завершить скрипт.
      echo "<b>Поймано исключение!</b><br>";
      echo "Код исключения: ".$e->getCode().'<br>';
      echo "Сообщение: ".$e->getMessage().'<br>';
      echo "<br><pre>";
      print_r($e->getTrace());
      echo "<br></pre>";
      die();
    }
    return 0;
  };
  $connection = connectMySQL($host,$dbname,$username,$password);

  # Закрыть соединение с БД
  $connection = NULL;


// Установка постоянного соединения

  # Установить постоянное соединение (для краткости без блока try ... catch)
  $connection = new PDO('mysql:host='.$host.';dbname='.
    $dbname, $username, $password, array(PDO::ATTR_PERSISTENT => true));

  # Закрыть соединение
  $connection = NULL;


// Пример работы PDO с транзакциями

  # Установить соединение с сервером СУБД
  $connection = connectMySQL($host,$dbname,$username,$password);

  # Завернуть транзакцию в блок try ... catch
  try {
    # Явно начать транзакцию
    $connection->beginTransaction();

    # Тело транзакции - группа выражений для выполнения
    $connection->exec('USE test');
    $connection->exec("INSERT INTO rabbits (name,age) VALUES ('Багз Банни',31)");

    # Сделать коммит
    $connection->commit();

  } catch(Exception $e) {
    # Т.К. поймано исключение, сделать ролбек, и вывести сообщение об ошибке
    $connection->rollBack();
    echo 'Failed: ' . $e->getMessage();
  }

  # Извлечь все данные из таблицы rabbtis и вывести на экран (посмотреть, вставилось ли новое значение)
  try {
    $res = $connection->prepare("SELECT * FROM rabbits LIMIT 2");
    $res->execute();
    $arr = $res->fetchAll();
  } catch(Exception $e){
     echo $e->getMessage();
  }
    echo "<br><pre>";
    print_r($arr);
    echo "<br></pre>";

  # Закрыть соединение с СУБД
  $connection = NULL;


// PDO - установка разных режимов обработки ошибок 2 способами

  # Установка режима обработки ошибок с массивом параметров при создании объекта PDO

    # Установить режим PDO::ERRMODE_SILENT
    $pdo = connectMySQL($host,$dbname,$username,$password,
      array(PDO::ATTR_ERRMODE => PDO::ERRMODE_SILENT));
              $pdo = NULL;  # закрыть соединение

    # Установить режим PDO::ERRMODE_WARNING
    $pdo = connectMySQL($host,$dbname,$username,$password,
      array(PDO::ATTR_ERRMODE => PDO::ERRMODE_WARNING));
              $pdo = NULL;  # закрыть соединение

    # Установить режим PDO::ERRMODE_EXCEPTION
    $pdo = connectMySQL($host,$dbname,$username,$password,
      array(PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION));
              $pdo = NULL;  # закрыть соединение


  # Установка режима обработки ошибок с помощью метода PDO::setAttribute()

    # Установить соединение
		$pdo = connectMySQL($host,$dbname,$username,$password);

    # Установить режим PDO::ERRMODE_SILENT
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);

    # Установить режим PDO::ERRMODE_WARNING
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);

		# Установить режим PDO::ERRMODE_EXCEPTION
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    # Закрыть соединение
    $pdo = NULL;


// Использование подготовленных выражений

  # Пример с использованием именованных меток-заполнителей вида :name

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить SQL-выражение с метками-заполнителями
    $prepared = $pdo->prepare("INSERT INTO test.rabbits (name,age)
      VALUES (:name, :age)");  # Здесь :name и :age - метки-заполнители

    # Связать имена меток-заполнилетей с именами PHP-переменных
    $prepared->bindParam(':name', $name);
    $prepared->bindParam(':age', $age);

    # Вставить строку №1
    $name = 'Новый Кролик 1';
    $age = 101;
    $prepared->execute();  # выполнить подготовленное SQL-выражение с вышеуказанными значениями параметров

    # Вставить строку №2
    $name = 'Новый Кролик 2';
    $age = 102;
    $prepared->execute();  # выполнить подготовленное SQL-выражение с вышеуказанными значениями параметров

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # Пример с использованием безымянных меток-заполнителей вида ?
    # (практически тоже самое, что в предыдущем примере)

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить SQL-выражение с метками-заполнителями
    $prepared = $pdo->prepare("INSERT INTO test.rabbits (name,age)
        VALUES (?, ?)");  # Здесь :name и :age - метки-заполнители

    # Связать имена меток-заполнилетей с именами PHP-переменных
    $prepared->bindParam(1, $name);
    $prepared->bindParam(2, $age);

    # Вставить строку №1
    $name = 'Новый Кролик 3';
    $age = 101;
    $prepared->execute();  # выполнить подготовленное SQL-выражение с вышеуказанными значениями параметров

    # Вставить строку №2
    $name = 'Новый Кролик 4';
    $age = 102;
    $prepared->execute();  # выполнить подготовленное SQL-выражение с вышеуказанными значениями параметров

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # Извлечь данные из указанной таблицы в массив

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить SQL-выражение
    $prepared = $pdo->prepare("SELECT * FROM test.rabbits");

    # Выполнить подготовленное SQL-выражение и извлечь все данные в массив (способ №1)
    $prepared->execute();
    $dataArr1 = [];
    while($row = $prepared->fetch()) {
      array_push($dataArr1,$row);
    }     # теперь если выполнить var_dump($dataArr1), то можно увидеть все содержимое таблицы

    # Выполнить подготовленное SQL-выражение и извлечь все данные в массив (способ №2)
    $prepared->execute();
    $dataArr2 = $prepared->fetchAll();  # теперь если выполнить var_dump($dataArr2), то можно увидеть все содержимое таблицы

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # Извлечь данные из указанной таблицы в массив, передав параметры в execute()

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить SQL-выражение
    $prepared = $pdo->prepare("SELECT * FROM test.rabbits WHERE age = ?");

    # Выполнить подготовленное SQL-выражение и извлечь все данные в массив (способ №1)
    $prepared->execute(array(1));  # аргумент - массив параметров для подготовленного (выше) выражения
    $data = $prepared->fetchAll();
       #var_dump($data);  # содержит только данные из строки, в которой age = 1

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # Запустить выполнение процедуры с параметром, извлечь результат
    # Указать PDO, что параметр, передаваемый в процедуру имеет тип IN (бывают IN, OUT, INOUT, подробнее см. "8. Синтаксис SQL - DDS")

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить SQL-выражение
    $prepared = $pdo->prepare("CALL get_n_rabbits(?)");  # используется метка-заполнитель ?

    # Связать безымянную метку-заполнитель с переменной
    $value = 3;
    $prepared->bindParam(1, $value);

    # Выполнить подготовленное SQL-выражение и извлечь все данные в массив (способ №1)
    $prepared->execute();  # аргумент - массив параметров для подготовленного (выше) выражения
    $data = $prepared->fetchAll();
        #var_dump($data);  # извлечь результат

    # Закрыть соединение с СУБД
    $pdo = NULL;


// LOB - Работа с большими объектами данных (такими как картинки, видео и т.д.)
# > Весь пример закомментирован, чтобы примеры после него могли работать.
#   Чтобы этот пример заработал, надо просто снять комметарий  /* ... */

/*
  # Загрузить картинку в базу данных через HTML форму

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Очистить таблицу полностью перед загрузкой новой картинки
    $pdo->exec('DELETE FROM test.images');

    # Подготовить SQL-выражение
    $prepared = $pdo->prepare("INSERT INTO test.images (contenttype, imagedata)
      VALUES (?, ?)");  # используются безымянные метки-заполнители

    # Загрузить файл в массив $_FILES (реализовано в отдельном файле)
    require "some_files/file_upload_for_27.php";

    # Открыть поток загруженного файла
    $fp = fopen($_FILES[$filename]['tmp_name'], 'rb');

    # Привязать значения к безымянным меткам-заполнителям
    $prepared->bindParam(1, $_FILES[$filename]['type']);
    $prepared->bindParam(2, $fp, PDO::PARAM_LOB);

    # Выполнить вставку бинарного кода загруженного файла в базу данных (через транзакцию для обезопашивания данных)
    $pdo->beginTransaction();
    $prepared->execute();
    $pdo->commit();

    # Закрыть поток к файлу
    fclose($fp);

    # Закрыть соединение с СУБД
    $pdo = NULL;

  # Извлечь картинку из базы данных и отобразить на экране

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить и выполнить SQL-выражение
    $prepared = $pdo->prepare('SELECT contenttype, imagedata FROM test.images LIMIT 1');
    $prepared->execute();

    # Привязать извлекаемые из БД значения к PHP-переменным
    $prepared->bindColumn(1, $type, PDO::PARAM_STR, 256);
    $prepared->bindColumn(2, $lob, PDO::PARAM_LOB);

    # Извлечь из БД данные и поместить их в соответствующие привязанные PHP-переменные
    $prepared->fetch(PDO::FETCH_BOUND);

    # Этот способ описан в оф. руководстве, но он не работает (почем, описано здесь: http://blitzphp.blogspot.ru/2013/04/store-and-retrive-images-into-mysql.html)
      # Послать браузеру заголовок, содержащий content-type файла
      //header("Content-Type: $type");

      # Вывести содержимое файла в браузер
      //fpassthru($lob);

    # Вывести картинку на экран можно так
    $img_str = base64_encode($lob);
    echo '<img src="data:image/jpeg;base64,'.$img_str.'" alt="Alt text" />';

    # Закрыть соединение с СУБД
    $pdo = NULL;
*/


####################################
// Справочник по методам классов PDO

  ########################################################
  // Класс PDO  | представляет соединение между PHP и СУБД


  # public PDO::__construct() ( string $dsn [, string $username [, string $password
  #                             [, array $driver_options ]]] )
    # > Создает объект PDO, представляющий соединение с СУБД
    # > $dsn - data source name. Это стандартная строка с хостом и именем БД для подключения к СУБД.
    #   > Возможны 3 варианта передачи этой строки:
    #     > Просто передать строку.
    #     > Указать путь (локальный или удаленный) к текстовому файлу, содержащему эту строку.
    #     > Указать name, тогда PDO будет искать строку в php.ini в директиве pdo.dsn.name. name может быть любое.
    # > $username и $password - логин и пароль аккаунта СУБД
    # > $driver_options - массив key=>value опций подключений
    # > В случае успеха возвращает объект PDO

    # Определить параметры подключения
    $dsn = 'mysql:host=localhost:3308;dbname=test';
    $username = 'root';
    $password = '';

    # Установить соединение (блок try .. catch здесь опущен, но в реальном примере необходим)
    $pdo = new PDO($dsn, $username, $password);

    # Разорвать соединение
    $pdo = NULL;


  # public int PDO::exec( string $statement )
    # > Выполняет SQL-запрос и возвращает кол-во задействованных строк
    # > Этот метод не возвращает результат из операции SELECT, а просто выполняет SQL-запрос.
    # > Если требуется результат от выполнения SELECT, можно использовать (либо-либо):
    #   > PDO::query() - если требуетвы выполнить SQL-выражение 1 раз.
    #   > PDO::prepare() + PDOStatement::execute() - если много раз (производительность лучше)
    # > $statement - строка с SQL-выражением.
    # > Возвращает количество строк, которые были изменены или удалены выполненным
    #   SQL-выражнием.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # С помощью exec выполнить вставку строки в таблицу rabbits
    $count = $pdo->exec('INSERT INTO test.rabbits (name,age) VALUES ("Роджер",110)');
    echo '<br>В таблицу test.rabbtis вставлено '.$count.' значений';  # В таблицу test.rabbtis вставлено 1 значений

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # public PDOStatement PDO::query( string $statement )
  # public PDOStatement PDO::query( string $statement , int $PDO::FETCH_COLUMN , int $colno )
  # public PDOStatement PDO::query( string $statement , int $PDO::FETCH_CLASS , string $classname , array $ctorargs )
  # public PDOStatement PDO::query( string $statement , int $PDO::FETCH_INTO , object $object )
    # > Выполняет SQL-запрос и возвращает результат в виде объекта PDOStatement
    # > Рекомендуется применять, если данное SQL-выражение надо выполнить только 1 раз
    #   > Если же его надо выполнить > 1 раза за скрипт, то можно получить выигрыш в
    #     производительности, если вместо query подготовить выражение методом prepare,
    #     и затем выполнять методом execute().
    # > Если после выполнения метода query не извлечь (fetch) все данные из результирующей
    #   таблицы перед очередным применением query, то оно может закончиться неудачей.
    #   В таких случаях перед очередным вызовом query требуется освободить ресурсы базы
    #   данных, связанные с объекто PDOStatement с помощью метода closeCursor().
    # > Базовый синтаксис функции имеет 1 параметр. Однако, можно передать еще доп.
    #   параметры, которые будут восприняты так, как будто они переданы методом setFetchMode()
    # > $statement - строка, содержащая SQL-выражение.
    # > Возвращает объект PDOStatement в случае успеха, или FALSE в случае неудачи.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить и выполнить SQL-выражение, получить результирующая таблицу в объект PDOStatement
    $pdos = $pdo->query('SELECT * FROM test.rabbits LIMIT 2');

    # Извлечь в массив все столбцы и строки из результирующей таблицы объекта PDOStatement
    $resArr = $pdos->fetchAll();
    # var_dump($resArr);  # посмотреть содержание

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # public PDOStatement PDO::prepare( string $statement [, array $driver_options = array() ] )
    # > Подготавливает SQL-запрос к выполнению методом PDOStatement::execute().
    # > Строка SQL-выражения может содержать маркеры-заполнители, значения для которых
    #   будут подставлены во время выполнения этого выражения.
    #   > Маркеры-заполнители могут быть:
    #     > Именные, вида :name. Все имена должны быть уникальны.
    #     > Безымянные, вида ?
    #   > Запрещено в 1 SQL-выражении одновременно использовать и именные,
    #     и безымянные маркеры-заполнители.
    #   > Маркеры-заполнители удобно использовать, например, для связывания их со
    #     значением, которое ввел пользователь через HTML форму. При этом не вставляя
    #     это значение напрямую в SQL-выражение (увеличивает безопасность).
    # > Комбинацию PDO::prepare() и PDOStatement::execute() рекомендуется использовать
    #   в тех случаях, когда SQL-выражение потребуется выполнить не 1 раз в течение
    #   работы скрипта с разными параметрами.
    # > Для драйверов, не поддерживающих эту функцию, PDO эмулирует подготовленные выражения
    #   и связывание параметров.
    # > $statement - строка с SQL-выражением, может содержать метки-заполнители.
    # > $driver_options - массив типа key=>value параметров, который устанавливает
    #   значения атрибутов объекта PDOStatement, который возвращает метод prepare().
    #   > Чаще всего потребуется установить следующее, чтобы запросить прокручиваемый курсор:
    #     PDO::ATTR_CURSOR = PDO::CURSOR_SCROLL
    #   > См. полный список среди констант PDO.
    # > Возвращает объект PDOStatement в случае успеха (если сервер СУБД успешно
    #   подготовил SQL-выражение). В противном случае возвращает либо FALSE, либо
    #   вызывает PDOException.
    #   > Для СУБД и PDO-драйверов для них, не поддерживающих подготовленные SQL-выражения,
    #     PDO не взаимодействует с СУБД, так что PDO::prepare() не проверяет SQL-выражение.

    # Пример с имеными метками-заполнителями вида :name
      # В примерах ниже есть особенность. Параметры, значения которым переданы через
      # функцию execute() в виде массива с аргументами, воспринимаются, как имеющие
      # тип PDO::PARAM_STR. А атрибут LIMIT, например, требует число. Поэтому если
      # попытаться передать ему такой параметр, будет syntax error. Выход - связать
      # этот параметр с помощью bindParam с PHP-переменной и указать тип PDO::PARAM_INT.

      # Соединиться с сервером СУБД
      $pdo = connectMySQL($host,$dbname,$username,$password);

      # Подготовить SQL-выражение и получать PDOStatement объект
      $prepared = $pdo->prepare('SELECT * FROM test.rabbits LIMIT :num');

      # Связать параметр :num с PHP-переменной, и задать ему тип PDO::PARAM_INT
      $num = 2;
      $prepared->bindParam(':num', $num, PDO::PARAM_INT);

      # Выполнить подготовленное SQL-выражение
      $prepared->execute();

      # Извлечь в массив всю результирующую таблицу
      $resArr = $prepared->fetchAll();  # содержит 2 первые строки из таблицы rabbits

      # Закрыть соединение с СУБД
      $pdo = NULL;

    # Пример с безымянными метками-заполнителями вида ?

      # Соединиться с сервером СУБД
      $pdo = connectMySQL($host,$dbname,$username,$password);

      # Подготовить SQL-выражение и получать PDOStatement объект
      $prepared = $pdo->prepare('SELECT * FROM test.rabbits LIMIT ?');

      # Связать параметр :num с PHP-переменной, и задать ему тип PDO::PARAM_INT
      $num = 2;
      $prepared->bindParam(1, $num, PDO::PARAM_INT);

      # Выполнить подготовленное SQL-выражение
      $prepared->execute();

      # Извлечь в массив всю результирующую таблицу
      $resArr = $prepared->fetchAll();  # содержит 2 первые строки из таблицы rabbits

      # Закрыть соединение с СУБД
      $pdo = NULL;


  # public bool PDO::beginTransaction (void)
    # > Начать транзакцию. Выключает режим autocommit.
    # > Возвращает TRUE в случае успеха, иначе FALSE.
    # > Ниже пример того, как безопасно вставлять данные в таблицу. Особенно это
    #   актуально, если надо вставить большое по размеру значение, вроде картинки или
    #   видео. Запись в таблицу занимает некоторое время, и если призойдет какой-нибудь
    #   сбой (отключат электроичество, например), и при этом не были использованы транзакции,
    #   то в БД может записаться битый объект.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Начать транзакцию, выполнить вставку в таблицу, сбросить и закрыть транзакцию
    $pdo->beginTransaction();  # Начать транзакцию
    $pdo->query('INSERT INTO test.rabbits (name,age) VALUES ("Джон", 111)');
    $pdo->rollBack();

    # Начать транзакцию, выполнить вставку в таблицу, подтвердить и закрыть транзакцию
    $pdo->beginTransaction();  # Начать транзакцию
    $pdo->query('INSERT INTO test.rabbits (name,age) VALUES ("Джон", 111)');
    $pdo->commit();

    # Закрыть соединение с СУБД
    $pdo = NULL;

  # public bool PDO::commit(void)
    # > Сделать коммит.
    # > Пример см. выше.
    # > Возвращает TRUE в случае успеха, и FALSE в случае неудачи.

  # public bool PDO::rollBack(void)
    # > Сделать роллбек.
    # > Пример см. выше.
    # > Если открытых транзакций нет, и использовать этот мето, то будет вызвано PDOException.
    # > Возвращает TRUE в случае успеха, и FALSE в случае неудачи.

  # public bool PDO::inTransaction(void)
    # > Проверяет, есть ли сейчас активная транзакция.
    # > Работает только для тех СУБД и их драйвера, которые поддерживают транзакции.
    # > Возвращает TRUE, если здесь есть активная транзакция. Иначе FALSE.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Проверить, есть ли здесь и сейчас активная транзакция
    if($pdo->inTransaction()) echo '<br>Активная транзакция есть<br>';
    else                      echo '<br>Активной транзакции нет<br>';  # вернуло 'Активной транзакции нет'

    # Осуществить аналогичную проверку внутри транзакции
    $pdo->beginTransaction();
      if($pdo->inTransaction()) echo '<br>Активная транзакция есть<br>';  # вернуло 'Активная транзакция есть'
      else                      echo '<br>Активной транзакции нет<br>';
    $pdo->commit();

    # Закрыть соединение с СУБД
    $pdo = NULL;

  # public mixed PDO::errorCode( void )
    # > Возвращает код SQLSTATE (5 буквенно цифровых символов) результата последней операции с БД.
    # > Этот метод можно вызывать только для объектов PDO, и нельзя для объектов PDOStatement.
    # > Возвращает код, либо NULL - если никаких операций не проводилось при помощи объекта PDO.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Специально выполнить ошибочное SQL-выражение, поймать исключение, вывести код
    try {
      $pdo->exec('INSERT INTO bones(skull) VALUES ("lucy")');
    } catch(PDOException $e) {
      echo "<br>Get Code =".$e->getCode()."<br>";
    }

    # Вывести код с помощью errorCode(), убедиться в том, что коды одинаковые
    $errorCode = $pdo->errorCode();
      echo "<br>Error Code = $errorCode<br>";

    # Вывести содержимое массива, возвращаемого методом errorInfo()
      echo "<br><pre>";
      print_r($pdo->errorInfo());
      echo "<br></pre>";

    # Закрыть соединение с СУБД
    $pdo = NULL;

  # public array PDO::errorInfo(void)
    # > Возвращает массив с информацией об ошибке, связанной с последней операцией
    #   с объектом PDO.
    # > Этот массив состоит из следующих полей:
    #   > 0 => SQLSTATE
    #   > 1 => код ошибки драйвера
    #   > 2 => сообщение об ошибке драйвера
    # > Пример см. выше.

  # public static array PDO::getAvailableDrivers( void )
    # > Возвращает массив доступных драйверов PDO
    # > Это статический метод (т.е. его можно вызывать прямо из класса, а не из объекта)

    # Вывести массив доступных драйверов PDO на экран
    echo "<br><pre>";
    print_r(PDO::getAvailableDrivers());
    echo "<br></pre>";

  # public mixed PDO::getAttribute( int $attribute )
    # > Возвращает значение указаного атрибута подключения к СУБД.
    # > Список доступных атрибутов для извлечения из них значения доступен ниже.
    # > В случае успеха возвращает значение указанного атрибута. Иначе null.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Определить массив имен атрибутов, значения которых можно извлечь
    $attributes = array(
      "PDO::ATTR_AUTOCOMMIT", "PDO::ATTR_ERRMODE", "PDO::ATTR_CASE", "PDO::ATTR_CLIENT_VERSION",
      "PDO::ATTR_CONNECTION_STATUS", "PDO::ATTR_ORACLE_NULLS", "PDO::ATTR_PERSISTENT",
      "PDO::ATTR_PREFETCH", "PDO::ATTR_SERVER_INFO", "PDO::ATTR_SERVER_VERSION",
      "PDO::ATTR_TIMEOUT"
    );

    # Извлечь значения всех этих атрибутов в массив (попытка извлечь значения некоторых
    # атрибутов вызывают ошибку, так что используется блок try .. catch)
    $results = [];
    foreach($attributes as $x) {
      try{
        array_push($results, $pdo->getAttribute(constant($x)));
      } catch (PDOException $e) {
        array_push($results, $e->getMessage());
      }
    }

    # Вывести содержимое этого массива на экран
    echo "<br><pre>";
    print_r($results);
    echo "<br></pre>";

    # Закрыть соединение с СУБД
    $pdo = NULL;

  # public bool PDO::setAttribute( int $attribute, mixed $value )
    # > Устанавливает значение атрибута объекта PDO.
    # > Некоторые из наиболее часто используемых атрибутов описаны ниже:
    #   > PDO::ATTR_CASE
    #     > Устанавливает имена колонок в указанный регистр
    #     - PDO::CASE_LOWER    | в верхний
    #     - PDO::CASE_NATURAL  | оставить, как есть
    #     - PDO::CASE_UPPER    | в нижний
    #   > PDO::ATTR_ERRMODE
    #     > Устанавливает режим обработки ошибок (описано продробно ниже в ИНФОРМАЦИИ)
    #     - PDO::ERRMODE_SILENT    | в случае ошибки можно получить ее код
    #     - PDO::ERRMODE_WARNING   | кроме того, еще возникает warning
    #     - PDO::ERRMODE_EXCEPTION | вызывает исключение
    #   > PDO::ATTR_ORACLE_NULLS
    #     > (работает со всеми драйверами, не только с ORACLE) Настроить конверсию NULL и '' значений
    #     - PDO::NULL_NATURAL        | нет конверсии
    #     - PDO::NULL_EMPTY_STRING   | пустая строка конвертируется в null
    #     - PDO::NULL_TO_STRING      | null конвертируется в пустую строку
    #   > PDO::ATTR_STRINGIFY_FETCHES
    #     > Требует bool-значение. Конвертировать ли числа в строки при извлечении (fetch).
    #   > PDO::ATTR_STATEMENT_CLASS
    #     > Установить пользовательский класс для утверждений, наследующий от PDOStatement.
    #   > PDO::ATTR_TIMEOUT
    #     > Установить таймаут в секундах
    #     > Не все драйверы поддерживают эту опцию
    #   > PDO::ATTR_AUTOCOMMIT
    #     > Включить или выключить автокоммит (работает для СУБД MySQL)
    #   > PDO::ATTR_EMULATE_PREPARES
    #     > Включить / выключить эмуляцию подготовленных выражений.
    #   > PDO::MYSQL_ATTR_USE_BUFFERED_QUERY
    #     > Использовать буфферизованные запросы (доступно для MySQL)
    #   > PDO::ATTR_DEFAULT_FETCH_MODE
    #     > Установить режим извлечения (fetch mode) по умолчанию.
    #     > Описание всех режимов доступно в описании метода PDOStatement::fetch().
    # > Возвращает TRUE в случае успеха, и FALSE в случае неудачи.


  # public string PDO::quote( string $string [, int $parameter_type = PDO::PARAM_STR] )
    # > Заключает строку $string в кавычки (если надо), и экранирует в ней специальные
    #   символы
    # > Не рекомендуется использовать эту функцию для вставки пользовательского ввода
    #   в SQL-выражение. Лучше использовать PDO::prepare() + параметры. Это лучше
    #   по всем параметрам: быстрее, безопаснее, портативнее
    # > Не все драйверы PDO реализуют этот метод, особенно ODBC.
    # > $parameter_type - подсказка для драйверов о типе данных.
    # > Возвращает обработанную строку, которая теоретически безопасная для вставки
    #   в SQL выражение. Или возвращает FALSE если драйвер не поддерживает этот метод.


  # public string PDO::lastInsertId([ string $name = NULL])
    # > Возвращает ID последней вставленной строки, или последнее значение, которое
    #   выдал объект последовательнсти. Что именно будет возвращено, зависит от драйвера.
    # > Для некоторых драйверов можен возвращать что-то не членораздельное, потому что
    #   они могут даже не поддерживать автоинкременты.
    # > При работе с транзакциями следует быть осторожным:
    #   > Если вызывать этот метод после commit'а, то он вернет 0 вместо правильного значения.
    #   > А если до commit'а внутри транзакции, то вернет правильное значение.
    # > Возвращаемые значения:
    #   > Если имя последовательности не указано в параметре $name, метод возвращает
    #     строку, представляющую ID последней вставленной в БД строки.
    #   > Если имя последовательности указано в параметре $name, метод возвращает
    #     последний объект, извлеченной из указанной последовательности.
    #   > Если драйвер PDO для этой СУБД не поддерживет эту возможность, то метод
    #     возвращает исключение с кодом IM001 SQLSTATE



  ##################################################################################################
  // Класс PDOStatement  | подготовленное выражение, а после его выполнения - результирующая таблица

  # public bool PDOStatement::execute([ array $input_parameters ])
    # > Выпнить подготовленное (prepare) выражение.
    # > Подготовленное выражение может содержать маркеры-заполнители.
    #   > Маркеры-заполнители бывают именные и безымянные (подробнее см. выше в примерах)
    #   > Можно вызвать PDOStatement::bindParam() чтобы связать PHP-переменные с
    #     параметрами-маркерами. Связанные переменные передают свои значения выполняющемуся
    #     SQL-выражению, и получают назад новые значения (если есть)
    #   > Или можно передать массив только значений входных параметров.
    # > $input_parameters - массив значений, которые передаются маркерам-заполнителям
    #   в момент выполнения SQL-выражения. Должно быть передано столько же значений,
    #   сколько маркеров заполнителей.
    #   > Все значения имеют тип PDO::PARAM_STR. Если это не устраивает, то лучше вместо
    #     передачи массива со значениями в кач-ве аргумента метода execute() связать
    #     вышеуказанные маркеры-заполнители с PHP-переменными c помощью метода bindParam().
    #   > Нельзя послать > 1 значения одному параметру.
    #   > Нельзя послать больше значений, чем число маркеров-заполнителей в SQL-выражении.
    #   > Для именных параметров, ключи в input_parameters должны совпадать с соответствующими
    #     ключами в передаваемом массиве значений.
    # > Море примеров см. выше.
    # > Возвращает TRUE в случае успеха. Иначе FALSE.


  # PDOStatement::closeCursor     | закрывает курсор, позволяет выполнить выражение снова
    # > Освобождает подключение к серверу так, что другие SQL-выражения могут быть отправлены,
    #   но оставляет SQL-выражение в таком состоянии, что его снова требуется выполнить.
    # > Этот метод полезен для тех драйверов баз данных, которые не поддерживают выполнение
    #   объекта PDOStatement в то время, как из ранее выполненного объекта PDOStatement все
    #   еще не полностью извлечены (fetch) все данные (из его результирующей таблицы).
    # > Возвращает TRUE в случае успеха. Иначе FALSE.

    # Проверить, нужно ли с MySQL использовать этот метод, или при использовании этой
    #   СУБД нет описанной выше проблемы. Результат: MySQL работает и без нее.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить 2 разных SQL-выражения
    $statement1 = $pdo->prepare('SELECT * FROM test.rabbits');
    $statement2 = $pdo->prepare('SELECT * FROM test.rabbits LIMIT 10');

    # Выполнить первое выражение и извлечь не все, а только 1-ю строку/*
    $statement1->execute();
    $res1 = $statement1->fetch(); echo '<br>res1 = '; var_dump($res1);

    //$statement1->closeCursor();  # все работает в MySQL и без этой функции

    # Теперь попробовать проделать тоже самое со вторым SQL-выражением без closeCursor
    $statement2->execute();
    $res2 = $statement2->fetch(); echo '<br>res2 = '; var_dump($res2);

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # public array PDOStatement::fetchAll( [int $fetch_style [, mixed $fetch_argument [,
  #                                      array $ctor_args = array() ]]] )
    # > Извлекает все данные из результирующей таблицы.
    # > $fetch_style - тоже самое, что у fetch. По умолчанию тоже PDO::FETCH_BOTH.
    #   Плюс еще несколько вариантов:
    #   - PDO::FETCH_COLUMN
    #     > Извлечь значения только из 1-й колонки.
    #     > Номер колонки передается в $fetch_argument.
    #     > Чтобы извлечь только уникальные значения из указанной колонки, нужно передать
    #       побитовое ИЛИ констант PDO::FETCH_COLUMN и PDO::FETCH_UNIQUE.
    #     > Чтобы извлечь ассоциативный массив, сгруппированный по значениям указанной
    #       колонки, нужно передать побитовое ИЛИ констант PDO::FETCH_COLUMN и PDO::FETCH_GROUP.
    #   - FETCH_FUNC
    #     > Возвращает результат вызова функции, имя которой указано в $fetch_argument,
    #       и которая принимает значения из извлеченной строки, как параметры.
    # > $fetch_argument - имеет разное значение в зависимости от $fetch_style:
    #   - Для PDO::FETCH_COLUMN  | номер колонки, из которой извлекать значения
    #   - Для PDO::FETCH_CLASS   | имя класса, из которого создается объект
    #   - Для PDO::FETCH_FUNC    | имя функции
    # > Использование этого метода сильно нагружает систему и сеть. Возможно, вместо
    #   извлечения этих данных в PHP и манипуляции ими там, стоит осуществить все
    #   необходимые манипуляции с данными на сервере СУБД с помощью SQL-выражений.
    #   А уже затем извлечь конечный результат.
    # > Возвращает массив, содержащий все оставшиеся на момент извлечения строки из
    #   результирующей таблицы. Каждое значение в массиве содержит в себе массив/объект,
    #   содержащий значения соответствующей строки. Либо пустой массив, если fetch для
    #   этой строки потерпел неудачу, или не содержал результатов.

    # Пример fetchALL с $fetch_style = PDO::FETCH_ASSOC

      # Соединиться с сервером СУБД
      $pdo = connectMySQL($host,$dbname,$username,$password);

      # Подготовить и выполнить SQL-выражение, извлекающее 3 строки из таблицы
      $statement = $pdo->prepare('SELECT * FROM test.rabbits LIMIT 3');
      $statement->execute();

      # Извлечь первую строку из него
      $resultRow = $statement->fetch(PDO::FETCH_ASSOC);

      # Извлечь оставшиеся 2 строки
      $resultArr = $statement->fetchAll(PDO::FETCH_ASSOC);
        echo "<br>fetchAll(PDO::FETCH_ASSOC)<pre>";
        print_r($resultArr);
        echo "<br></pre>";

      # Закрыть соединение с СУБД
      $pdo = NULL;

    # Извлечь с помощью fetchALL значения только из 1 столбца

      # Соединиться с сервером СУБД
      $pdo = connectMySQL($host,$dbname,$username,$password);

      # Подготовить и выполнить SQL-выражение, извлекающее 3 строки из таблицы
      $statement = $pdo->prepare('SELECT * FROM test.rabbits LIMIT 3');
      $statement->execute();

      # Извлечь все значения из столбца name
      $resultArr = $statement->fetchAll(PDO::FETCH_COLUMN, 1);
        echo "<br>fetchAll(PDO::FETCH_COLUMN, 0) - только значения из столбца name<pre>";
        print_r($resultArr);
        echo "<br></pre>";

      # Закрыть соединение с СУБД
      $pdo = NULL;



  # public string PDOStatement::fetchColumn([ int $column_number = 0])
    # > Возвращает следующее поле или FALSE, если в результирующей таблице не осталось полей.
    # > $column_number - номер поля (колонки), который требуется извлечь (начинается с 0)
    # > При извлечении поля таким способом, остальные поля в этой строке этойрезультирующей
    #   таблицы "сгорают". Следующее fetchColumn() извлекает значение уже из следующей строки.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить и выполнить SQL-выражение, извлекающее 3 строки из таблицы
    $statement = $pdo->prepare('SELECT * FROM test.rabbits LIMIT 3');
    $statement->execute();

    # Извлечь 1 поле из 1 столбца
    $result = $statement->fetchColumn(0);
    echo '$statement->fetchColumn(0) = '.$result;

    # Извлечь 2 поле из 2 столбца
    $result = $statement->fetchColumn(1);
    echo '<br>$statement->fetchColumn(1) = '.$result;

    # Извлечь 3 поле из 3 столбца
    $result = $statement->fetchColumn(2);
    echo '<br>$statement->fetchColumn(1) = '.$result;

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # public mixed PDOStatement::fetch([ int $fetch_style [, int $cursor_orientation =
  #                                  PDO::FETCH_ORI_NEXT [, int cursor_offset = 0 ]]])
  # > Извлекает строку из результирующей таблицы объекта PDOStatement.
  # > $fetch_style - определяет, в каком виде PDO возвращает эту строку:
  #   - PDO::FETCH_ASSOC
  #     > Возвращает ассоциативный массив, где индексы - имена колонок, а значения
  #       - значения колонок.
  #   - PDO::FETCH_BOTH (по умолчанию)
  #     > Возвращает ассоциативный массив, в котором для каждого значения по 2 записи.
  #       Одно и тоже значение появляется в нем как с индексами с именами, соответствующими
  #       именам колонок, так и с индексами, соответствующими номерам колонок (начиная с 0).
  #   - PDO::FETCH_BOUND
  #     > Возвращает TRUE, и записывает значения из колонок результирующей таблицы в
  #       PHP-переменные, которые были связаны с колонками с помощью метода
  #       PDOStatement::bindColumn().
  #   - PDO::FETCH_CLASS
  #     > Создает новый объект указанного в setFetchMode() класса, записывает свойства,
  #       имена которых совпадают с именами колонок, и записывает в них соотв. значения.
  #       И возвращает ссылку на этот объект.
  #   - PDO::FETCH_INTO
  #     > В указанный в методе setFetchMode() объект любого класса записывает свойства,
  #       имена которых совпадают с именами колонок, и записывает в них соотв. значения.
  #       И возвращает ссылку на этот объект.
  #   - PDO::FETCH_LAZY
  #     > Аналог FETCH_OBJ, только объект типа PDORow, и есть доп. свойство queryString,
  #       содержащее SQL-запрос.
  #   - PDO::FETCH_NUM
  #     > Возвращает массив, проиндексированный номерами колонок, начиная с 0.
  #   - PDO::FETCH_OBJ
  #     > Возвращает анонимный объект, у которого имена свойств соответствуют именам
  #       колонок в результирующей таблице, а значения - значениям.
  # > $cursor_orientation - определяет положение курсора, откуда будет извлекаться
  #   строка. Должно быть одной из FETCH_ORI_ констант:
  #   - FETCH_ORI_NEXT   | поставить курсор на следующую строку
  #   - FETCH_ORI_PRIOR  | поставить курсор на предыдущую строку
  #   - FETCH_ORI_FIRS   | поставить курсор на 1 строку
  #   - FETCH_ORI_LAST   | поставить курсор на последнюю строку
  #   - FETCH_ORI_ABS    | поставить курсор на номер строки, заданный в $cursor_offset
  #   - FETCH_ORI_REL    | поставить курсор на позицию, смещенную на $cursor_offset строк от текущей
  # > $cursor_offset - см. выше.
  # > Возвращаемое значение зависит от выбранного $fetch_style. В случае неудачи
  #   возвращает FALSE.

  # Соединиться с сервером СУБД
  $pdo = connectMySQL($host,$dbname,$username,$password);

  # Подготовить и выполнить SQL-выражение
  $statement = $pdo->prepare('SELECT * FROM test.rabbits');
  $statement->execute();

  # Испытать на практике разные $fetch_style

    # FETCH_BOTH (который по умолчанию)
    $resultRow = $statement->fetch();  # здесь аргумент FETCH_BOTH указан по умолчанию
      echo "<br>FETCH_BOTH<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_ASSOC
    $resultRow = $statement->fetch(PDO::FETCH_ASSOC);
      echo "<br>FETCH_ASSOC<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_LAZY
    $resultRow = $statement->fetch(PDO::FETCH_LAZY);
      echo "<br>FETCH_LAZY<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_OBJ
    $resultRow = $statement->fetch(PDO::FETCH_OBJ);
      echo "<br>FETCH_OBJ<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_NUM
    $resultRow = $statement->fetch(PDO::FETCH_NUM);
      echo "<br>FETCH_NUM<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_CLASS
    $statement->setFetchMode( PDO::FETCH_CLASS, 'user');
    $statement->execute();
    $resultRow = $statement->fetch(PDO::FETCH_CLASS);
      echo "<br>FETCH_CLASS<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_INTO
    class user {}
    $user = new user();
    $statement->setFetchMode( PDO::FETCH_INTO, $user);
    $statement->execute();
    $resultRow = $statement->fetch(PDO::FETCH_INTO);
      echo "<br>FETCH_INTO<pre>";
      print_r($resultRow);
      echo "<br></pre>";

    # FETCH_BOUND
    $statement->execute();
    $statement->bindColumn(1, $id1, PDO::PARAM_INT);
    $statement->bindColumn(2, $name1, PDO::PARAM_STR);
    $statement->bindColumn(3, $age1, PDO::PARAM_INT);

    echo 'FETCH_BOUND';
    $resultRow = $statement->fetch(PDO::FETCH_BOUND);  # извлечь строку
    echo "<br>id = $id1, name = $name1, age = $age1<br>";

    $resultRow = $statement->fetch(PDO::FETCH_BOUND);  # извлечь следующую строку ...
    echo "<br>id = $id1, name = $name1, age = $age1<br>";

  # Закрыть соединение с СУБД
  $pdo = NULL;


  # public mixed PDOStatement::fetchObject([ string $class_name = "stdClass" [,
  #                                        array $ctor_args ]] )
    # > Аналог fetch с атрибуто $fetch_style равным FETCH_CLASS (см. описание выше)
    # > $class_name - имя класса, из которого будет создан объект.
    # > $ctor_args - элементы этого массива передаются конструктору.
    # > Возвращает объект указанного в $class_name класса со свойствами с именами, соответствующими
    #   именам стролбцов, и значениями с соответствующими значениями.
    # > Примеры для fetch с атрибуто $fetch_style равным FETCH_CLASS см. выше.


  # public bool PDOStatement::setFetchMode ( int $mode )
  # public bool PDOStatement::setFetchMode ( int $PDO::FETCH_COLUMN , int $colno )
  # public bool PDOStatement::setFetchMode ( int $PDO::FETCH_CLASS , string $classname , array $ctorargs )
  # public bool PDOStatement::setFetchMode ( int $PDO::FETCH_INTO , object $object )
    # > Назначает режим для fetch, а также некоторые доп. параметры.
    # > Этот метод абсолютно необходим при использовании с PDO::FETCH_CLASS и PDO::FETCH_INTO,
    #   в которых перед выполнением собственно операции fetch требуется назначить имя класса
    #   для первого, и переменную со ссылкой на объект для второго, а непосредственно в
    #   в операции fetch этого сделать невозможно (см. примеры выше)
    # > Возвращает TRUE в случае успеха, или FALSE в случае неудачи.
    # > $mode - режим работы fetch, одна из констант PDO::FETCH_*
    # > $colno - номер колонки.
    # > $classname - строка с именем класса
    # > $ctorargs - аргументы для конструктора
    # > $object - объект


  # public bool PDOStatement::bindColumn( mixed $column, mixed &$param [, int type [,
  #                                       $maxlen [, mixed $driverdata ]]])
    # > Связать поле из колонки с переменной PHP. При извлечении очередной строки с
    #   помощью fetch, этой переменной присваивается значение из соотв. колонки. При
    #   извлечении с помощью fetchALL, переменной присваивается последнее значение из колонки.
    #   > Так как информация о колонках еще не известна PDO до того, как SQL-выражение
    #     выполнено, то вызывать bindColumn() следует после execute().
    # > $column - номер колонки. Индекс начинается с 1. Либо можно использовать имя
    #             колоноки (оно регистрочувствительно).
    # > &$param - имя PHP-переменной, с которой будет связана колонка.
    # > $type - тип данных параметра, указанный одной из констант  PDO::PARAM_*.
    #   Доступные варианты:
    #   - PDO::PARAM_BOOL          | булевский тип
    #   - PDO::PARAM_NULL          | SQL NULL
    #   - PDO::PARAM_INT           | SQL INTEGER
    #   - PDO::PARAM_STR           | SQL CHAR, VARCHAR или др. текстовый тип
    #   - PDO::PARAM_LOB           | SQL large object data type
    #   - PDO::PARAM_INPUT_OUTPUT  | указывает на то, что это INOUT параметр (для сохраняемых процедур),
    #                                следует связать его побитовым ИЛИ с каким-нибудь из вышеперечисленных типов.
    #   - PDO::PARAM_STMT          | (не поддерживается ни 1 драйвером) recordset type
    # > $maxlen - подсказка для PDO.
    # > $driverdata - параметры для драйвера (опционально)
    # > Возвращает TRUE в случае успеха, иначе FALSE.
    # Примеры см. выше


  # public bool PDOStatement::bindParam( mixed $parameter, mixed &$variable [,
  #       int $data_type = PDO::PARAM_STR [, int $length [, mixed $driver_options ]]])
    # > Связать PHP-переменные и метки-заполнители (именные или безымянные) из SQL-выражения,
    #   которое было использовано при подготовке (prepare).
    # > В отличие от PDOStatement::bindValue(), переменная связывается с меткой-заполнителем,
    #   как ссылка, и будет опрошена только в момент вызова метода execute().
    #   > Т.Е. в отличие от bindValue, bindParam связывает параметры с PHP-переменными
    #     по ссылке, а не по значению.
    #   > Кроме того, bindParam не может связать значение с параметром, а только
    #     PHP-переменную, потому что значения нельзя передавать по ссылке.
    # > $parameter - идентификатор параметра. Если были использованы именные параметры
    #                вида :name, то это будет строка с именем парамтра ':name'.
    #                Если были использованые безымянные параметры вида ?, то это будет
    #                номер позиции параметра слева-направо в выражении (начиная с 1).
    # > &$variable - PHP-переменная, с который связывается параметр.
    # > $data_type - тип данных параметра, указанный одной из констант  PDO::PARAM_*.
    #                Описание всех констант см. в описании bindColumn выше.
    # > $length - длина типа данных.
    # > $driver_options - опции для драйвера.
    # > Возвращает TRUE в случае успеха, иначе FALSE.
    # Примеры см. выше.


  # public bool PDOStatement::bindValue( mixed $parameter, mixed $value [,
  #                                      int $data_type = PDO::PARAM_STR ])
    # > Связать значения и метки-заполнители (именные или безымянные) из SQL-выражения,
    #   которое было использовано при подготовке (prepare).
    # > В отличие от bindParam, bindValue может связать с параметром как PHP-переменную,
    #   так и значение.
    #   > Это происходит потому, что bindValue связывает их по значению, а не поссылке,
    #     как bindParam.
    # > $parameter - идентификатор параметра. Если были использованы именные параметры
    #                вида :name, то это будет строка с именем парамтра ':name'.
    #                Если были использованые безымянные параметры вида ?, то это будет
    #                номер позиции параметра слева-направо в выражении (начиная с 1).
    # > $value - значение, которое требуется связать с параметром.
    # > $data_type - тип данных параметра, указанный одной из констант  PDO::PARAM_*.
    #                Описание всех констант см. в описании bindColumn выше.
    # > Возвращает TRUE в случае успеха, иначе FALSE.

    # Пример bindValue с именованными параметрами
      # Соединиться с сервером СУБД
      $pdo = connectMySQL($host,$dbname,$username,$password);

      # Подготовить SQL-выражение
      $statement = $pdo->prepare('SELECT * FROM test.rabbits WHERE age < :age LIMIT :lim');

      # Связать параметры со значениями
      $statement->bindValue(':age', 4, PDO::PARAM_INT);
      $statement->bindValue(':lim', 2, PDO::PARAM_INT);

      # Выполнить SQL-выражение
      $statement->execute();

      # Извлечь и посмотреть результат
      $arr = $statement->fetchAll();
        echo "<br><pre>";
        print_r($arr);     # извлечено 2 значения, как и указано в :lim
        echo "<br></pre>";

      # Закрыть соединение с СУБД
      $pdo = NULL;

    # Пример bindValue с безымянными параметрами
      # Соединиться с сервером СУБД
      $pdo = connectMySQL($host,$dbname,$username,$password);

      # Подготовить SQL-выражение
      $statement = $pdo->prepare('SELECT * FROM test.rabbits WHERE age < ? LIMIT ?');

      # Связать параметры со значениями
      $statement->bindValue(1, 4, PDO::PARAM_INT);
      $statement->bindValue(2, 2, PDO::PARAM_INT);

      # Выполнить SQL-выражение
      $statement->execute();

      # Извлечь и посмотреть результат
      $arr = $statement->fetchAll();
        echo "<br><pre>";
        print_r($arr);     # извлечено 2 значения, как и указано во 2 параметре
        echo "<br></pre>";

      # Закрыть соединение с СУБД
      $pdo = NULL;



  # public int PDOStatement::columnCount( void )
    # > Возвращает число колонок в результирующей таблице из объекта PDOStatement.
    # > Если объект PDOStatement был возвращен методом PDO::query(), то количество
    #   столбцов сразу доступно, и можно использовать columnCount.
    # > Если объект PDOStatement был возвращен методом PDO::prepare(), то кол-во
    #   столбцов будет недоступно до тех пор, пока не будет вызван метод
    #   PDOStatement::execute().
    # > Если результирующая таблица окажется пуста, то columnCount возвращает 0.

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить и выполнить SQL-выражение
    $pdos = $pdo->query('SELECT * FROM test.rabbits LIMIT 5');

    # Вывести на экран кол-во столбцов и строк в результирующей таблице
    echo "<p>В результирующей таблице ".$pdos->columnCount()." столбцов
          и ".$pdos->rowCount()." строк.</p>";  # Выводит: "В результирующей таблице 3 столбцов и 5 строк."

    # Закрыть соединение с СУБД
    $pdo = NULL;

  # public int PDOStatement::rowCount ( void )
    # > Возвращает количество строк, затронутых последней SQL-операцией DELETE, INSERT
    #   или UPDATE, выполненной в соответствующем объекте PDOStatement.
    # > Если последней SQL-операцией была операция SELECT, то некоторые СУБД могут
    #   вернуть число строк в результирующей таблице, которую вернуло выражение.
    #   > Это поведение справедливо для MySQL.
    #   > Однако, это поведение не гарантировано для всех СУБД, и на него не стоит
    #     полагаться портируемым приложениям.
    # См. пример с SELECT выше.


  # public mixed PDOStatement::getAttribute ( int $attribute )
    # > Получает значение атрибута объекта PDOStatement.
    # > В настоящий момент общих для всех СУБД доступных атрибутов нет, а только
    #   специфичные для разных драйверов.
    # > Для MySQL ничего нет.
    # > Возвращает значение атрибута


  # public array PDOStatement::getColumnMeta ( int $column )
    # > Извлечь из результирующей таблицы метаданные указанной колонки в ассоциативный массив.
    # > $column - номер колонки, нумерация слева-направо, начинается с 0.
    # > Внимание! Функция экспериментальная. Может меняться без предупреждения. Особо
    #   полагаться на нее не стоит. Не все драйверы PDO ее поддерживают.
    # > Возвращает ассоциативный массив, содержащий значения следующих метаданных для
    #   одной колонки: см. http://www.php.net/manual/en/pdostatement.getcolumnmeta.php


  # PDOStatement::setAttribute    | установить значение атрибута утверждения
  # > Устанавливает значение атрибута объекта PDOStatement.
  # > В настоящий момент общих для всех СУБД доступных атрибутов нет, а только
  #   специфичные для разных драйверов.
  # > Для MySQL ничего нет.
  # > Возвращает TRUE в случае успеха, и FALSE в случае неудачи.


  # public string PDOStatement::errorCode ( void )
    # > Аналог PDO::errorCode() для объектов PDOStatement.
    # > Возвращает код SQLSTATE результата последней операции с объектом PDOStatement.

    # Пример работы errorCode() и errorInfo()

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить и выполнить намеренно ошибочное SQL-выражение
    try {
      $sth = $pdo->prepare('SELECT skull FROM bones');
      $sth->execute();
    } catch(PDOException $e) {
      echo '<p>Ошибка!</p>';
    }

    # Вывести информацию об ошибках
    echo '<p>Код ошибки: '.$sth->errorCode().'</p>';   # 42S02
    echo '<p>Подробнее об ошибке: </p>';
      echo "<br><pre>";
      print_r($sth->errorInfo());
      echo "<br></pre>";

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # PDOStatement::errorInfo
    # > Возвращает массив с информацией об ошибке, связанной с последней операцией
    #   с объектом PDOStatement.
    # > Этот массив состоит из следующих полей:
    #   > 0 => SQLSTATE
    #   > 1 => код ошибки драйвера
    #   > 2 => сообщение об ошибке драйвера
    # > Пример см. выше.


  # PDOStatement::debugDumpParams | вывести подготовленное (prepared) SQL-выражение на экран
    # > Выводит на экран различную информацию о состоянии объекта PDOStatement:
    #   - Используемое SQL выражение.
    #   - Количество параметров.
    #   - Список параметров, с их именами, типом (paramtype), их идентификаторами
    #     (имя ключа или позиция), значением, и позицией в запросе.
    # > Этот метод используется для наглядного дебага.
    # > Подсказка: output-control functions могут быть использованы для перехвата
    #   этого вывода и записи его в строку. Ссылка: http://www.php.net/manual/en/book.outcontrol.php

    # Соединиться с сервером СУБД
    $pdo = connectMySQL($host,$dbname,$username,$password);

    # Подготовить SQL-выражение с метками-заполнителями
    $prepared = $pdo->prepare("INSERT INTO test.rabbits (name,age)
          VALUES (:name, :age)");  # Здесь :name и :age - метки-заполнители

    # Связать имена меток-заполнилетей с именами PHP-переменных
    $prepared->bindParam(':name', $name);
    $prepared->bindParam(':age', $age);

    # Выполнить подготовленное SQL-выражение
    $prepared->execute();

    # Вывести на экран информацию для дебага
    echo "<br><pre>";
    print_r($prepared->debugDumpParams());
    echo "<br></pre>";

    # Закрыть соединение с СУБД
    $pdo = NULL;


  # PDOStatement::nextRowset
  # > Бывает, что SQL-выражение возвращает не 1 резульрирующую таблицу (как обычно),
  #   а больше. В этом случае, чтобы из PDO получить доступ к следующей результирующей
  #   таблице и используют метод nextRowset.
  # > Разумеется, у следующей результирующей таблицы может быть уже совсем другая
  #   структура.
  # > Возвращает TRUE в случае успеха, и FALSE в случае неудачи.
  # Пример. см. в руководстве: http://www.php.net/manual/en/pdostatement.nextrowset.php








##############################################
// Часто используемые техники при работе с PDO
























/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:
> Официальное руководство по PDO на php.net:
    http://www.php.net/manual/ru/book.pdo.php

> PDO-драйверы баз данных:
    http://www.php.net/manual/ru/pdo.drivers.php

> Значения констант PDO:
    http://www.php.net/manual/en/pdo.constants.php



*****************************************************
Оглавление:

  > Введение
  > Установка и настройка (Windows)
  > Установка соединени с БД и обработка возможных исключений
  > Использование постоянных соединений
  > О том, как PDO работает с транзакциями
  > Ошибки и их обработка
  > Подготовленные выражения и сохраняемые процедуры
  > LOB - Работа с большими объектами данных (такими как картинки, видео и т.д.).

  > Часто используемые техники при работе с PDO
    > Как запустить .sql из PHP с помощью PDO?


*****************************************************



> Введение
  > PHP Data Objects (PDO) - дополнение к PHP, представляющее собой интерфейс в ООП
    стиле для работы с базами данных в PHP.
  > PDO служит абстрактным слоем для доступа к данным, так что не зависимо от того,
    какая база данных используется, для работы используются одни и те же фукнции.
  > PDO доступен для PHP >= 5.1
  > Для работы с каждой отдельной СУБД, PDO требует соответствующий драйвер.


> Установка и настройка (Windows)
  > PDO и все основные драйверы доступны "из коробки".
  > Но это дополнение по умолчанию отключено. Требуется зайти в конфигурационный файл
    php.ini и вручную включить его.
    > В раздел Dynamic Extensions требуется добавить строчку:
        extension=php_pdo.dll
        > Этот шаг больше не требуется, начиная с PHP >= 5.3.0. С этой версии
          PDO больше не требует .dll файла, и его больше нет в папке ext.
    > Также в этом разделе имеются закомментированные строчки для добавления
      PDO драйверов для разных СУБД. Раскомментировать нужные. Выглядят они так:
            extension=php_pdo.dll
            extension=php_pdo_firebird.dll
            extension=php_pdo_informix.dll
            extension=php_pdo_mssql.dll
            extension=php_pdo_mysql.dll
            extension=php_pdo_oci.dll
            extension=php_pdo_oci8.dll
            extension=php_pdo_odbc.dll
            extension=php_pdo_pgsql.dll
            extension=php_pdo_sqlite.dll
      > Все эти .dll обычно хранятся в папке ".../php/ext". В любом случае, чтобы
        все заработало, они должны быть в папке, которая указана в файле php.ini
        в директиве extension_dir = 'здесь_адрес_папки'. По умолчанию здесь указана
        папка ".../php/ext".
    > После внесения изменений требуется перезагрузить веб сервер, и после этого они
      вступят в силу.


> Установка соединени с БД и обработка возможных исключений
  > Пример установки соединения с БД см. в примерах.
  > Если соединение установлено успешно, то переменная $connection (см. пример) получает
    объект класса PDO, который и олицетворяет собой соединение.
  > Выражение установки соединения всегда стоит заключать в блок TRY ... CATCH. Если
    этого не сделать, и возникнет ошибка, то на экран будет выведена вся информация,
    необходимая для дебага, включая логин и пароль к базе данных. А это не безопасно.
  > Открытое соединение остается активным, пока созданный объект PDO существует.
    Закрыть соединение можно, например, так:    $connection = NULL;
    Оно автоматически закрывается в конце работы скрипта.


> Использование постоянных соединений
  > Не рекомендуется, потому что может привести к ошибкам сегментации жесткого диска
    в случае аварийного обрыва PHP-процесса. Про ошибки сегментации читай в википедии:
      ru.wikipedia.org/wiki/Ошибка_сегментации
  > Чтобы установить постоянное соединение, требуется передать параметр
    PDO::ATTR_PERSISTENT => true в массиве опций соединения при подключении
    (см. пример выше).


> О том, как PDO работает с транзакциями
  > О транзакциях в подробностях можешь прочитать в методичке "4. SQL Library", в
    разделе "5. Storage engines and INNODB".
  > При подключении к серверу СУБД, PDO проверяет на уровне драйверов, поддерживает
    ли он транзакции. Поэтому если в определенных условиях (например, при работе с
    таблицами MySQL на движке MyISAM) транзакции недоступны, то функция
    PDO::beginTransaction() может все равно возвращать TRUE и не вызывать исключение,
    если сервер принимает запрос на старт транзакции.
  > При установлении соединения PDO должен работать в режиме Auto-Commit.
    > Если БД, к которой подключается PDO, поддерживает транзакции, то каждое
      выполняемое выражение будет выполняться в своей отдельной неявной транзакции
      сразу после отправки на сервер СУБД.
      > Также будет возможность явно начать транзакцию, наполнить ее выражениями,
        и сделать commit или rollback.
        > Для явного запуска транзакции используют фунтцию PDO::beginTransaction().
          > Если эта БД не поддерживает транзакции, то фукнция вызовет исключение PDOException.
        > Для коммита: PDO::commit().
        > Для роллбека: PDO::rollBack().
    > Если БД, к которой подключается PDO, не поддерживает транзакции, то работа
      продолжается без транзакций.
  > При закрытии соединения с сервером СУБД (в том числе в конце скрипта) для не закрытой
    транзакции PDO делает rollback. Это справедливо для транзакций, явно открытых с
    помощью функции PDO::beginTransaction().


> Ошибки и их обработка
  > Режим обработки ошибок PDO можно установить, передав константе PDO::ATTR_ERRMODE
    значение одного из 3 режимов. Сделать это можно 2 способами:
    > С помощью метода PDO::setAttribute(), например:
        $pdo->setAttribute(PDO::ATTR_ERRMODE, здесь_1_из_3_режимов);
    > Передать в массиве параметров в конструктор PDO при создании объекта, например:
        $dbh = new PDO($dsn, $user, $password, array(PDO::ATTR_ERRMODE => здесь_1_из_3_режимов));
  > PDO предлагает 3 режима обработки ошибок:
    - PDO::ERRMODE_SILENT (по умолчанию)
    - PDO::ERRMODE_WARNING
    - PDO::ERRMODE_EXCEPTION
    > Подробнее о ERRMODE_SILENT:
      > Никаких предупреждений или ошибок. С помощью методов PDO::errorCode() и PDO::errorInfo()
        можно получить код ошибки, применив их к объекту, в котором предположительно есть ошибка.
    > Подробнее о ERRMODE_WARNING:
      > ERRMODE_SILENT + сообщение E_WARNING.
    > Подробнее о ERRMODE_EXCEPTION:
      > ERRMODE_SILENT + вызов исключения PDOException.
      > Этот режим полезно использовать во время разработки.
  > Метод PDO::__construct() всегда будет вызывать в случае ошибки PDOException, вне
    зависимости от того, какой режим обработки ошибок установлен для PDO.
  > Не обработанные исключения фатальны для скрипта.


> Подготовленные выражения и сохраняемые процедуры
  > Преимущества подготовленных выражений перед не подготовленными в следующем:
    - Они ускоряют работу приложения, т.к. анализ/компиляцию/оптимизацию требуется
      провести всего 1 раз - во время подготовки приложения, а не каждый раз при
      его выполнении.
    - Приложение, которое использует только подготовленные выражения, лучше защищены
      от SQL инъекций.
  > Подготовленные выражения настолько полезны, что это единственная фунция, которую
    PDO эмулирует для драйверов, которые ее не поддерживают. Это позволяет убедиться
    в том, что приложение может использовать одну и ту же парадигму доступа к данным,
    не зависимо от используемой СУБД.


> LOB - Работа с большими объектами данных (такими как картинки, видео).
  > LOBs - Large Objects.
  > В роли большого объекта может выступать и символьная, и бинарная строка. В MySQL
    такого понятия (LOB) нет, но есть специальные типы из семейств TEXT и BLOB,
    предназначенные для хранения вот таких больших строк.
    > В руководстве по PDO написано, что обычно "большими" считаются объекты данных
      "около 4кб и выше".
  > Например, достаточно много места может занимать бинарный код какой-нибудь картинки.
    Любую картинку можно как сохранить в базу данных в колонку соответствующего типа,
    так и извлечь оттуда и отобразить (см. примеры выше).
  > PDO позволяет работать с LOBs, передав в вызов функции PDOStatement::bindParam()
    или функции PDOStatement::bindColumn() код типа PDO::PARAM_LOB (см. пример).




> Часто используемые техники при работе с PDO

  > Как запустить .sql из PHP с помощью PDO?
    > Это можно сделать в 2 этапа:
      - Прочитать содержимое .sql файла в строку.
      - С помощью PDO выполнить эту строку с SQL-кодом.
    > Пример:





-------------------------------------------------- */
?>


















