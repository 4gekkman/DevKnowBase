<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Все о работе с массивами

Основы
> Красивый просмотр содежания массива
> Определение массива
> Демонстрация того, как автоматом преобразовается тип ключа
> Чтение элементов массива
> Прямое разыменование возвращаемого функцией массива (PHP >= 5.4.0)
> Запись и удаление элементов массива и массива
> Красивый вывод массива любой размерности на экран
> Как сохранить массив в виде строки в куки, базу, файл... (сериализация)

Функции (выборка наиболее нужных)
> array_values                    | возвращает переиндексированный массив
> array_change_key_case (1 байт)  | Переводит все ключит типа string указанного массива в верхний или нижний регистр
>   array_change_key_case_unicode | ... Пользовательская юникод-версия функции
> array_chunk                     | Группирует элементы в массивы указанной длины внутри данного
> array_column (PHP >= 5.5.0)     | Получить массив значений (по ключу) одной колонки целевого 2-мерного массива
> array_combine                   | Создать 1 массив из 2-х (1-ключи, 2-й - значения)
> array_count_values              | Посчитать частоту повторения значений в массиве
> array_diff                      | Сравнивает массивы и возвращает разницу
> array_intersect                 | Возвращает массив, содержащий все значения array1, которые есть хоть в одном из остальных
> array_flip                      | Меняет местами ключи и их значения в массиве
> array_filter                    | Фильтрует массив с помощью callback функции
> array_key_exists                | Проверить, есть ли в массиве указанный ключ/индекс
> array_keys                      | Возвращает массив всех или указанных ключей массива
> array_values                    | Возвращает массив всех или указанных значений массива
> array_map                       | Применяет callback функцию ко всем элементам массива
> array_merge                     | Слить 2 или более массивов в 1
> array_pad                       | Дополнить массив указанными значениями до указанного размера
> array_pop                       | Вернуть и удалить последний элемент из массива
> array_push                      | Добавить 1 или несколько элементов в конец массива
> array_rand                      | Выбирает заданное кол-во случайных элементов массива
> array_reduce                    | Итеративно уменьшает массив к 1 значению, используя callback функцию
> array_reverse                   | Принимает массив и возвращает другой с элементами в обратном порядке
> array_replace                   | Замена элементов массива элементами других переданных массивов
> array_search                    | Ищет указанное значение в массиве
> array_shift                     | Удаляет и возвращает 1-е значение массива
> array_unshift                   | Добавляет 1 или несколько элементов в начало массива
> array_slice                     | Возвращает вырезку из массива
> array_splice                    | Удаляет часть элементов массива. Может их заменить на другие.
> array_unique                    | Убирает повторяющиеся значения из массива
> array_walk                      | Применяет пользовательскую callback функцию к каждому элементу массива
> sort                            | Сортирует массив однотипных элементов по значениям в порядке возрастания, не сохраняя ключи
> asort                           | Сортирует массив однотипных элементов по значениям в порядке возрастания, сохраняя ключи
> arsort                          | Сортирует массив однотипных элементов по значениям в порядке убывания, сохраняя ключи
> ksort                           | Сортирует массив по ключам в порядке возрастания
> krsort                          | Сортирует массив по ключам в порядке убывания
> usort                           | Сортирует по значениям с использованием callable функции для сравнения
> uksort                          | Сортирует по ключам с использованием callable функции для сравнения
> uasort                          |
> range                           | Создает массив, содержащий диапазон элементов с указанным шагом
> shuffle                         | Перемешивает элементы массива в случайном порядке
> count                           | Возвращает количество элементов в массиве (длина массива)




-------------------------------------------------- */


// ----------------------- БАЗА ----------------------- //

// Красивый просмотр содержания массива
/*

echo "<br><pre>";
print_r($i);
echo "<br></pre>";

*/

// Определение массива
    // Устаревший вариант
        $arr = array(
            'Ключ 1' => 'Значение 1',
            'Ключ 2' => 'Значение 2',
            'Ключ 3' => 'Значение 3'
        );
    // Новый вариант (PHP >= 5.4.0)
        $arr = [
            'Ключ 1' => 'Значение 1',
            'Ключ 2' => 'Значение 2',
            'Ключ 3' => 'Значение 3'
        ];
    // Определение без ключей
        $arr = [
            'Значение 1',         // ключ = 0            (присваивается автоматом)
            55 => 'Значение 2',
            'Значение 3'          // ключ = 55 + 1 = 56  (присваивается автоматом)
        ];
    // Определение 'На Лету'
    // > Если массив был не определен, то он будет создан
        $arr[] = 'Значение 1';    // ключ = 0            (присваивается автоматом)

// Демонстрация того, как автоматом преобразовается тип ключа
    // > Результат: у этого массива остается только 1 последний элемент и все
    //   > 1 => 'd'
        $arr = [
           1 => 'a',      // будет перезаписан следующей записью
           '1' => 'b',    // будет перезаписан следующей записью
           1.5 => 'c',    // будет перезаписан следующей записью
           TRUE => 'd',     // единственный элемент, который останется
        ];

// Чтение элементов массива
    // На примере 3-мерного массива
        $arr = [
            0 => '1 уровень',
            'Район' => 'Йокогама',
            [
                0 => '2 уровень',
                [
                    0 => '3 уровень элемент №0',
                    1 => '3 уровень элемент №1'
                ]
            ]
        ];
        $e = $arr['Район'];  // 'Йокогама'
        $e = $arr{0};        // '1 уровень'
        $e = $arr[1]{0};     // '2 уровень'    ( скобки [] и {} дают тот же результат, без разницы какие использовать )
        $e = $arr[1][1][1];  // '3 уровень элемент №1'


// Прямое разыменование возвращаемого функцией массива (PHP >= 5.4.0)
// (а раньше так было нельзя)
    function f() {
        return [1=>'Вася',2=>'Петя'];
    }
    $e = f()[1];  // Вася
    $e = f()[2];  // Петя

// Запись и удаление элементов массива и массива
    // Запись
        $arr[55] = 'Значение 1';
        $arr[56] = 'Значение 2';
        $arr[] = 'Значение 3';         // ключ = 57            (присваивается автоматом)
        $arr['Учитель'] = 'Онидзука';
    // Удаление элемента
        // > !!! ВНИМАНИЕ !!! Массив не будет переиндексирован после удаления элемента!
            unset($arr[55]);
    // Удаление элемента с переиндексацией (в стиле удалить и сдвинуть)
        unset($arr[56]);
        $arr = array_values($arr);  // переиндексация
    // Удаление массива
        unset($arr);

// Красивый вывод массива любой размерности на экран
    $arr = [1,2,3];
    echo "<br><pre>";
    print_r($arr);
    echo "<br></pre>";

// Как сохранить массив в виде строки в куки, базу, файл... (сериализация)
    $arr = [1,2,3];              // Array ( [0] => 1 [1] => 2 [2] => 3 )
    $str = serialize($arr);      // 'a:3:{i:0;i:1;i:1;i:2;i:2;i:3;}'   - это строка
    $arr = unserialize($str);    // Array ( [0] => 1 [1] => 2 [2] => 3 )




// ----------------------- Функции (выборка наиболее нужных) ----------------------- //


// array array_values( array $input )
// > Возвращает массив со всеми значениями $input, а также переиндексирует его
    $arr = array_values([1,2,3]);

// array array_change_key_case( array $input[, int $case = CASE_LOWER ] )
// > Переводит все ключит типа string указанного массива в верхний или нижний регистр
// > Возможны 2 значения $case: CASE_LOWER (по умолчанию) и CASE_UPPER
// > !!! Не работает с кириллицей
//       это связано с тем, что они занимают не 1, а 2 байта
    $arr = array_change_key_case(['John'=>1],CASE_UPPER);           // JOHN
    $arr = array_change_key_case(['John'=>1],CASE_LOWER);           // john

// array array_change_key_case_unicode( array $input[, int $case = CASE_LOWER ] )
// > Переводит все ключит типа string указанного массива в верхний или нижний регистр
// > Пользовательская юникод-версия функции
// > Возможны 2 значения $case: CASE_LOWER (по умолчанию) и CASE_UPPER
    function array_change_key_case_unicode($arr, $c = CASE_LOWER) {
        $c = ($c == CASE_LOWER) ? MB_CASE_LOWER : MB_CASE_UPPER;
        foreach ($arr as $k => $v) {
            $ret[mb_convert_case($k, $c, "UTF-8")] = $v;
        }
        return $ret;
    }
    $arr = array_change_key_case_unicode(['Иван'=>1],CASE_UPPER);   // ИВАН
    $arr = array_change_key_case_unicode(['Иван'=>1],CASE_LOWER);   // иван

// array array_chunk( array $input, int $size [, bool $preserve_keys = false ] )
// > Группирует элементы в массивы указанной длины внутри данного массива
// > size - размер каждого подмассива в количестве элементов
// > $preserve_keys - если TRUE, то ключи оригинального массива будут сохранены.
    $arr = array_chunk([1,2,3,4,5,6,7],2,true);  // [ [1,2], [3,4], [5,6], [7] ]

// array array_column( array $input, mixed $column_key [, mixed $index_key ] )
// > Получить массив значений (по ключу) одной колонки целевого 2-мерного массива
// > $column_key - ключ, по которому из каждого подмассива отбирается значение
// > $index_key - указать ключ, значение которого будет становиться индексом
//   для каждого из отобранных значений
    $arr = [
        [
           'Имя'     => 'Иван',
           'Фамилия' => 'Петров',
           10        => 'Иванова',
           'id'      => 5310
        ],
        [
            'id'      => 7890,
            'Имя'     => 'Василий',
            'Фамилия' => 'Краморов',
            10        => 'Сидорова',
        ]
    ];
    $e = array_column($arr,'Имя');           // [0] => Иван, [1] => Василий
    $e = array_column($arr,10);              // [0] => Иванова, [1] => Сидорова
    $e = array_column($arr,'Имя','id');      // [5310] => Иван, [7890] => Василий

// array array_combine( array $keys, array $values )
// > Создать 1 массив из 2-х (1-ключи, 2-й - значения)
    $arr = array_combine([0,1,2],['Ноль','Один','Два']);  // [0]=>'Ноль', [1]=>'Один', [2]=>'Два'

// array array_count_values( array $input )
// > Возвращает массив, ключами которого являются значения массива input, а значениями
//   - частота повторения значений input
    $arr = array_count_values(['а','а','б','б','в']);     // [a]=>2, [б]=>2, [в]=>1

// array array_diff( array $array1, array $array2, [, array $...] )
// > Сравнивает array1 с array2 и возвращает массив элементов, которые есть
//   array1, но нет в других.
// > Сравниваемые значения равны, если равны их переведенные в string значения
// > Есть еще ряд похожих встроенных функций с доп. функциональностью
    $arr = array_diff(['a'=>1,2,3,2],['b'=>1,4,2]);    // [1]=>3

// array array_intersect( array $array1, array $array2 [, array $ ... ] )
// > Возвращает массив, содержащий все значения array1, которые есть хоть
//   в одном из остальных
// > Индексы сохраняются
// > Есть еще ряд похожих встроенных функций с доп. функциональностью
    $arr = array_intersect(['a'=>1,2,3,2],['b'=>1,4,2]);  // [a]=>1, [0]=>2, [2]=>2


// array_flip
// > Меняет местами ключи и их значения в массиве
    $arr = array_flip(['Ключ 1'=>1,'Ключ 2'=>2]);  // [1]=>'Ключ 1', [2]=>'Ключ 2'

// array array_filter( array $input [, callable $callback = "" ] )
// > Фильтрует массив с помощью callback функции
//   > Если функция возвращает TRUE - значение остается, а если FALSE - удаляется.
// > Если callback-функция не задана, все значения массива = FALSE будут удалены
    function even($var) {
        return !($var & 1);  // если число четное - TRUE, если нет - FALSE
    }
    $arr = array_filter([1,2,3,4,5,6],'even');  // [1]=>2, [3]=>4, [5]=>6,

// bool array_key_exists( mixed $key, array $search )
// > Проверить, есть ли в массиве указанный ключ/индекс
// > Возвращает TRUE - если да, FALSE - если нет
    $e = array_key_exists('Жора',['Жора'=>20,'Коля'=>30]);  // TRUE

// array array_keys( array $input [, mixed $search_value = NULL [, bool $strict = false]] )
// > Возвращает массив всех или указанных ключей массива $input
// > $search_value - если указано, будут возвращены только ключи, содержащие
//   указанное значение
// > $strict - определяет, использовать ли строгое сравнение ===
    $arr = array_keys(['a'=>0,'h'=>1,'j'=>2]);  // [0]=>'a', [1]=>'h', [2]=>'j'
    $arr = array_keys(['a'=>0,'h'=>1], 1);      // [0]=>'h'

// array array_map( callable $callback, array $arr1 [, array $... ] )
// > Применяет функцию callback ко всем элементам массива $arr1, и возвращает
//   измененный массив (старый массив остается нетронутым)
// > Можно применить к нескольким массивам, но тогда количество аргументов
//   callback функции должно совпадать с их количеством
    function square($n) {
        return $n*$n;
    }
    $arr = [1,2,3];
    $arr = array_map('square',$arr);   // [0]=>1, [1]=>4, [2]=>9

// array array_merge( array $array1 [, array $... ] )
// > Слить 2 или более массивов в 1
// > Последний элемент затерает все предыдущие элементы с тем же строковым ключем
//   > А элементы с одинаковыми числовыми ключами не затерают друг друга, а добавляются в конец.
    $arr =  ['Один'=>1, 2=>2, 3];
    $arr2 = ['Один'=>4, 2=>5, 6];
    $arr = array_merge($arr,$arr2);  // [Один]=>4, [0]=>2, [1]=>3, [2]=>5, [3]=>6

// array array_pad( array $input, int $pad_size, mixed $pad_value )
// > Дополнить массив $input значениями $pad_value до размера $pad_size
    $arr = array_pad([1,2], 4, 0);   // [0]=>1, [1]=>2, [2]=>0, [3]=>0

// mixed array_pop( array &$array )
// > Вернуть и удалить последний элемент из массива
// > Т.К. массив передается в функцию по ссылке, то это обязательно должна быть
//   переменная, нельзя передать напрямую массив (вроде такого: [1,2,3]).
// > Функция проводит автоматическую переиндексацию
    $arr = [1,2,3];
    $e = array_pop($arr);  // [0]=>1, [1]=>2

    $arr[] = 10;           // [0]=>1, [1]=>2, [2]=>10

// int array_push( array &$array, mixed $var [, mixed $... ] )
// > Добавить 1 или несколько элементов в конец массива
// > Для добавления 1 элемента лучше использовать $array[] = элемент; (меньше затрат ресурсов)
// > Возвращает новое количество элементов в массиве
    $arr = [1,2,3];
    array_push($arr, 4,5,6);  // [0]=>1, [1]=>2, [2]=>3, [3]=>4, [4]=>5, [5]=>6

// mixed array_rand( array $input [, int $num_req = 1 ] )
// > Выбирает заданное кол-во случайных элементов массива
// > $num_req - сколько нужно выбрать элементов
// > Возвращает ключи выбранных элементов
    $arr = array_rand([1,2,3,4,5], 2);   // результаты каждый раз разные

// mixed array_reduce( array $input, callable $function [, mixed $inition = NULL ] )
// > Итеративно уменьшает массив к 1 значению, используя callback функцию
// > mixed callback( mixed &$result, mixed $item )
// > $inition - будет использовано как начальное значение $result
function sum1($result, $item) {
    return $result += $item;
}
    $e = array_reduce([1,2,3], 'sum1');       // 6
    $e = array_reduce([1,2,3], 'sum1', 10);   // 16

// array array_reverse( array $array [, bool $preserve_keys = false ] )
// > Принимает массив и возвращает другой с элементами в обратном порядке
// > Если $preserve_keys = TRUE, то числовые ключи будут сохранены. Нечисловые
//   же всегда сохраняются
    $arr = array_reverse([100=>0, 101=>1, 102=>2, 'Иван'=>3, 'Петр'=>4 ], TRUE);  // [Петр]=>4, [Иван]=>3, [102]=>2, [101]=>1, [100]=>0

// array array_replace( array $array, array $array1 [, array $...] )
// > Замена элементов массива элементами других переданных массивов
//   > Если ключ из 1 массива есть во 2-м массиве, его значение заменяется на значение из 2 массива.
//   > Если он присутствует только в 1 массиве, то его значение сохраняется неизменным.
//   > Если для замены переданы несколько массивов, то они будут обработаны в порядке
//     > передачи и более поздние массивы будут перезаписывать значения из предыдущих.
// > Возвращает результирующий массив
    $arr =  [100=>0, 101=>1, 102=>2];
    $arr2 = [100=>5, 103=>3];
    $arr = array_replace($arr, $arr2);  // [100]=>5, [101]=>1, [102]=>2, [103]=>3

// mixed array_search( mixed $needle, array $haystack [, bool $strict = false ] )
// > Ищет указанное значение $needle в массиве $haystack
// > Если $strict = TRUE, то поиск будет строгим (===). Будут проверяться типы
//   элементов, а объекты должны быть одними и теми же экземплярами.
// > Возвращает ключ найденного элемента
    $e = array_search('Жорик', ['Васек', 'Жорик', 'Петек'], TRUE);  // 1

// mixed array_shift( array &$array )
// > Удаляет и возвращает 1-е значение массива
// > Т.К. массив передается в функцию по ссылке, то это обязательно должна быть
//   переменная, нельзя передать напрямую массив (вроде такого: [1,2,3]).
// > Проводит автоматическую переиндексацию
//   > Все строковые ключи остаются без изменения
    $arr = [100=>0, 101=>1, 'а'=>2, 103=>3];
    $e = array_shift($arr);      // [0]=>1, [a]=>2, [1]=>3

// int array_unshift( array &$array, mixed $var [, mixed $... ] )
// > Добавляет 1 или несколько элементов в начало массива
// > Т.К. массив передается в функцию по ссылке, то это обязательно должна быть
//   переменная, нельзя передать напрямую массив (вроде такого: [1,2,3]).
// > Проводит автоматическую переиндексацию
//   > Все строковые ключи остаются без изменения
// > Возвращает новое количество элементов в массиве
    $arr = [101=>1, 'а'=>2];
    $e = array_unshift($arr, 4,5,[6,7]);  // [0]=>4, [1]=>5, [2]=>Array([0]=>6,[1]=>7), [3]=>1, [a]=>2

// array array_slice( array $array, int $offset, [, int $length = NULL [, bool preserve_keys = false ]] )
// > Возвращает вырезку из массива
// > $offset - с какого элемента от начала включительно начинать вырезку
// > $length - длина вырезки
// > $preserve_keys = TRUE - сохранить ключи (по умолчанию сбрасывает)
    $arr = array_slice([100=>0, 101=>1, 'а'=>2, 103=>3],1,2,TRUE);  // [101]=>1, [a]=>2

// array array_splice( array &$input, int $offset, [, int $length = 0 [, mixed $replacement ]] )
// > Удаляет часть элементов массива. Может их заменить на другие.
// > Т.К. массив передается в функцию по ссылке, то это обязательно должна быть
//   переменная, нельзя передать напрямую массив (вроде такого: [1,2,3]).
// > $offset - с какого элемента от начала включительно удалять
// > $length - длина
// > $replacement - элемент или массив, который будет вставлен на позицию $offset
//   > Его ключи не сохранятся
// > Возвращает массив, содержащий удаленные элементы
    $arr = [100=>0, 101=>1, 'а'=>2, 103=>3];     // [0]=>0, [1]=>500, [2]=>501, [3]=>3,
    $arr2 = array_splice($arr,1,2,[500,501]);

// array array_unique( array $array [, int $sort_flags = SORT_STRING ] )
// > Убирает повторяющиеся значения из массива $array
// > Ключи сохраняются
// > Возвращает результирующий массив
// > $sort_flags - как сравнивать элементы?
//   > SORT_STRING - как строки, SORT_NUMERIC - как числа, SORT_REGULAR - не менять типы, SORT_LOCALE_STRING - как строки в зависимости от установленной локали.
    $arr = array_unique(["a" => "green", "red", "b" => "green", "blue", "red"]);  // [a] => green, [0] => red, [1] => blue

// bool array_walk( array &$array, callable $funcname [, mixed $userdate = NULL ] )
// > Применяет пользовательскую callback функцию, обходя каждый элемент массива
// > callable funcname( mixed value, mixed key)
// > $userdate может быть передан в качестве 3-го параметра в funcname
// > Возвращает TRUE - в случае успеха, FALSE - в случае неудачи
// > Есть еще рекурсивный вариант этой функции - array_walk_recursive -
//   который может обходить каждый элемент массива с любым количеством измерений
    function plus2(&$value, $key) {
        $value += 2;
    }
    $arr = [1,2,3];                         // 3,4,5
    $result = array_walk($arr,'plus2');

// bool sort( array &$array, [, int $sort_flags = SORT_REGULAR ] )
// > Сортирует массив однотипных элементов по значениям в порядке возрастания, не сохраняя ключи
// > $sort_flags - указывает, как функции определять, какой элемент больше, а какой меньше
//   > SORT_REGULAR - без изменения типов, SORT_STRING  - приводить к строкам, SORT_NUMERIC - приводить к числам, SORT_LOCALE_STRING - приводить к строка и сравнивать в зависимости от текущей локали
    $arr = [100=>'c', 101=>'d', 102=>'a', 103=>'b'];
    sort($arr);     // [0]=>a, [1]=>b, [2]=>c, [3]=>d

// bool asort( array &$array, [, int $sort_flags = SORT_REGULAR ] )
// > Сортирует массив однотипных элементов по значениям в порядке возрастания, сохраняя ключи
// > $sort_flags - указывает, как функции определять, какой элемент больше, а какой меньше
//   > SORT_REGULAR - без изменения типов, SORT_STRING  - приводить к строкам, SORT_NUMERIC - приводить к числам, SORT_LOCALE_STRING - приводить к строка и сравнивать в зависимости от текущей локали
    $arr = [100=>'в', 101=>'г', 102=>'а', 103=>'б'];
    asort($arr);     // [102]=>а, [103]=>б, [100]=>в, [101]=>г

// bool arsort( array &$array, [, int $sort_flags = SORT_REGULAR ] )
// > Сортирует массив однотипных элементов по значениям в порядке убывания, сохраняя ключи
// > $sort_flags - указывает, как функции определять, какой элемент больше, а какой меньше
//   > SORT_REGULAR - без изменения типов, SORT_STRING  - приводить к строкам, SORT_NUMERIC - приводить к числам, SORT_LOCALE_STRING - приводить к строка и сравнивать в зависимости от текущей локали
    $arr = [100=>'в', 101=>'г', 102=>'а', 103=>'б'];
    arsort($arr);     // [101]=>г, [100]=>в, [103]=>б, [102]=>а

// bool ksort( array &$array [, int $sort_flags = SORT_REGULAR ] )
// Сортирует массив по ключам в порядке возрастания
// > $sort_flags - указывает, как функции определять, какой элемент больше, а какой меньше
//   > SORT_REGULAR - без изменения типов, SORT_STRING  - приводить к строкам, SORT_NUMERIC - приводить к числам, SORT_LOCALE_STRING - приводить к строка и сравнивать в зависимости от текущей локали
    $arr = [102=>'в', 101=>'г', 100=>'б'];
    ksort($arr);     // [100]=>в, [101]=>г, [102]=>а

// bool krsort( array &$array [, int $sort_flags = SORT_REGULAR ] )
// Сортирует массив по ключам в порядке убывания
// > $sort_flags - указывает, как функции определять, какой элемент больше, а какой меньше
//   > SORT_REGULAR - без изменения типов, SORT_STRING  - приводить к строкам, SORT_NUMERIC - приводить к числам, SORT_LOCALE_STRING - приводить к строка и сравнивать в зависимости от текущей локали
    $arr = [102=>'в', 101=>'г', 100=>'б'];
    krsort($arr);     // [102]=>а, [101]=>г, [100]=>в

// bool usort( array &$array, callable $cmp_function )
// > Сортирует по значениям с использованием callable функции для сравнения
// > Ключи НЕ сохраняются
//   > Есть абсолютно аналогичная функция uasort, в которой ключи сохраняются
// > int callback ( mixed $a, mixed $b )
//   > Должна возвращать целое число X
//   > Если X < 0, то значит $a < $b
//   > Если X == 0, то значит $a == $b
//   > Если X > 0, то значит $a > $b
$arr = ['Катя','Люба','Валька'];
    function whoAreMoreBeautifull($a, $b) {
        if($a=='Катя' && $b = 'Люба')   return 1;   // Катя красивее Любы
        if($a=='Люба' && $b = 'Катя')   return -1;

        if($a=='Валька' && $b = 'Люба')   return 1; // Валька красивее Любы
        if($a=='Люба' && $b = 'Валька')   return -1;

        if($a=='Валька' && $b = 'Катя')  return 1;  // Валька красивее Кати
        if($a=='Катя' && $b = 'Валька')  return -1;
    };
    usort($arr,'whoAreMoreBeautifull');  // отсортировать по красоте в порядке возрастания
                                         // Люба, Катя, Валька

// bool uksort( array &$array, callable $cmp_function )
// > Сортирует по ключам с использованием callable функции для сравнения
// > int callback ( mixed $a, mixed $b )
//   > Должна возвращать целое число X
//   > Если X < 0, то значит $a < $b
//   > Если X == 0, то значит $a == $b
//   > Если X > 0, то значит $a > $b
$arr = ['Один'=>1,'Три'=>3,'Два'=>2];
function f6($a,$b) {
    if($a=='Два' && $b=='Один')  return 1;   // Два > Один
    if($a=='Один' && $b=='Два')  return -1;

    if($a=='Три' && $b=='Два')  return 1;    // Три > Два
    if($a=='Два' && $b=='Три')  return -1;

    if($a=='Три' && $b=='Один')  return 1;   // Три > Один
    if($a=='Один' && $b=='Три')  return -1;
};
uksort($arr,'f6');   // [Один]=>1, [Два]=>2, [Три]=>3


// array range( mixed $start, mixed $end [, number $step = 1] )
// > Создает массив, содержащий диапазон элементов с указанным шагом
// > $step - инкремент между элементами последовательности
    $arr = range(0,100,10);   // тоже, что и [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

// bool shuffle( array &$array )
// Перемешивает элементы массива в случайном порядке
// > Т.К. массив передается в функцию по ссылке, то это обязательно должна быть
//   переменная, нельзя передать напрямую массив (вроде такого: [1,2,3]).
// > Его ключ за каждым элементом НЕ сохраняется, массив переиндексируется
    $arr = [0, 1, 2, 3];
    shuffle($arr);

// int count( mixed $var [, int $mode = COUNT_NORMAL ] )
// > Возвращает количество элементов в массиве
// > $mode - считать элементы в 1-мерном или многомерном массиве?
//   > $mode = COUNT_NORMAL (по умолчанию) - то считать в одномерном
//   > $mode = COUNT_RECURSIVE - считать в многомерном
    $result = count($arr);  // 4








/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------

> Здесь можно найти все функции по работе с массивами:
  > http://www.php.net/manual/ru/ref.array.php

> Массив в PHP - это упорядоченное отображение, которое устанавливает связь
  между значением и ключем.
> Значение может быть любого типа
> Ключ
  > Является не обязательным параметром при объявлении массива. Если не указан, то
    будет использован наибольший из имеющихся int ключей, увеличенный на 1.
  > может быть только 2-х типов:
    > String
      > При чтении по этому ключу его всегда надо заключать в '' (константы и переменные не надо)
    > Int
  > Массив может содержать одновременно ключи этих обоих типов, потому что PHP
    не делает различия между индексированными и ассоциативными массивами.
  > Ключ также подвергается следующим преобразованиям (на примерах):
    > "8" (тип string) будет преобразовано в 8 (тип int); а "08" - не будет.
    > 5.25 (тип float) будет преобразован в 5 (тип int)
    > TRUE (bool) преобразуется в 1 (int), а FALSE в 0.
    > NULL будет преобразован в ""
    > Типы Array и Object не могут быть использованы в качестве ключа.
  > Если в массиве несколько элементов используют один и тот же ключ, то последний
    будет использован, а остальные перезаписаны.
> Доступ к элементам массива
  > Скобки [] и {} дают тот же результат, без разницы какие использовать.
> Особенности удаления элементов массива
  > Если удалить все элементы массива, и задать новое значение без указания индекса,
    то автоматически присвоится индекс не 0, как можно было бы ожидать, а максимальный
    индекс + 1 среди удаленных значений. Чтобы этого избежать, надо переиндексировать
    массив.
> Чтобы напрямую изменять значения элементов массива из цикла Foreach,
надо копировать их в цикл не по значению, а по ссылке &value
  > Сделать указатели на value возможно, только если перебираемый массив
    является переменной.
  > Ссылка $value на последний элемент остается даже после окончания
    работы цикла. Рекомендуется уничтожить ее с помощью unset()
  > Не поддерживает возможность подавления ошибок префиксом @.
> Подробнее о сортировке массивов можно почитать здесь:
  > http://www.php.net/manual/ru/array.sorting.php


-------------------------------------------------- */
?> 
