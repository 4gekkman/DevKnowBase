<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
12. Namespaces
Пространства имён в PHP





-------------------------------------------------- */
// Место для тестов:

















/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальная справка по пространствам имён в PHP:
        http://php.net/manual/ru/language.namespaces.php

  > Часто задаваемые вопрсоы (FAQ) по пространствам имён в PHP:
        http://www.php.net/manual/ru/language.namespaces.faq.php

  > Статья про пространсва имён на хабре:
        http://habrahabr.ru/post/212773/


*****************************************************
Оглавление:

  > Общая информация о пространствах имён в PHP
    > Что такое инкапсуляция?
    > Примеры инкапсуляции
    > Что такое инкапсуляция в контексте пространств имён?
    > Что такое пространство имён?
    > Зачем используют пространства имён?
      > Чтобы решить эти 2 проблемы
      > Подробнее о 1: как пространства имён позволяют избежать конфликта имён?
        > Что такое конфликт имён?
        > Как избежать конфликта имён?
        > Пример
      > Подробнее о 2: как давать псевдонимы с помощью пространств имён?

  > Как определить пространство имён?
    > Чьи имена зависят от пространств имён?
    > Как определить пространство имён?
    > Где определять пространства имён?

  > Как определить несколько пр.имён в 1 PHP-файле?
    > Но нужно ли?
    > Доступны 2 синтаксиса
    > Подробнее о синтаксисе с фигурными скобками
    > Подробнее о синтаксисе без фигурных скобок

  > Глобальное пр.имён
    > Что такое глобальное пр.имён?
    > Как получить доступ к имени в глобальном пр.имён?

  > Правила, по которым PHP узнаёт, из какого пр.имён запрашивается эл-т
    > Как в файловой системе
    > Есть 2 способа указать имя в коде
      > 2 способа
      > Относительный путь
      > Абсолютный путь
      > Примеры
    > Особенность поведения относ.путей функций/констант/классов/интерфейсов
      > Общая информация
      > Функции и константы
      > Классы и интерфейсы
    > Относ.путь превращается в абсол. при импользовании динамич-их имён
      > Что такое динамические имена в PHP
      > Особенность совместного использования пр.имён и динамических имён

  > Как создать константу в желаемом пространстве имён?
    > В каком пр.имён создаёт константу операция define()
    > Примеры
    > Надо явно указывать в define(), в каком пр.имён создавать константу

  > Константа __NAMESPACE__ и ключевое слово namespace
    > Аналог this
    > Зачем они нужны?

  > Импорт имён/псевдонимы для имён
    > Импорт/псевдонимы поддерживаются только для имён этих 3-х сущностей
    > Что такое импорт?
    > Что такое псевдонимы?
    > Импорт не работает с динамическими именами
    > Присоединяемые файлы НЕ наследуют правила импорта из родительского
    > Примеры



*****************************************************


> Общая информация о пространствах имён в PHP

  > Что такое инкапсуляция?
    > Это механизм, делающие вещи X доступными только внутри вещей Y.
      Ключевое понятие здесь - изоляция.
    > Дано предельно общее определение, которое может быть уточнено
      в контексте конкретной области знаний.

  > Примеры инкапсуляции
    > Инкапсуляция в объектно-ориентированном программировании
      > Инкапсуляция - механизм языка программирования, ограничивающий
        доступ к составляющим объект компонентам (методам и свойствам). Он
        делает их приватными - доступными только внутри объекта.
    > Инкапсуляция в медицине
      > Образование капсулы вокруг чуждых для организмов веществ
        (инородных тел, паразитов и прочих).

  > Что такое инкапсуляция в контексте пространств имён?
    > Это механизм, делающий имена классов/интерфейсов/функций/констант
      доступными только из указанного пространства имён.

  > Что такое пространство имён?
    > Пространство имён - это папки, как в операционной системе.
    > В них вместо файлов хранятся имена классов/интерфейсов/функций/констант.
    > В одной и той же папке не могут находиться 2 одинаковых имени.
    > Сама по себе папка тоже имеет имя - это имя пространства имён.
      > Оно не должно содержать служебных слов PHP, иначе будет parse error.
      > Примеры того, как делать не надо:

          namespace Project/Classes/Function;   // Вызывает parse errors
          namespace Project/Abstract/Factory;   // Вызывает parse errors

  > Зачем используют пространства имён?

    > Чтобы решить эти 2 проблемы:
      1. Избежать конфликта имён.
      2. Улучшить читабельность кода, дав псевдонимы длинным именам

    > Подробнее о 1: как пространства имён позволяют избежать конфликта имён?

      > Что такое конфликт имён?
        > В большинстве случаев в проекте используют чужой код (зачем изобретать
          велосипед, когда многие вещи уже написали до тебя другие люди?).
          Это могут быть различные компоненты: библиотеки, фреймворки и др.
        > Каждый компонент в своём коде использует набор имён для
          классов/интерфейсов/функций/констант.
        > Очень вероятна такая ситуация, что если запустить все эти компоненты
          в 1-ом пространстве имён, то возникнет конфликт имён. Т.Е. окажется,
          что, например, в компоненте X и в компоненте Y использовано одно и тоже
          имя.
        > Результатом конфликта имён будет неправильная работа конфликтующих
          компонентов.

      > Как избежать конфликта имён?
        > Надо поместить весь набор имён каждого отдельного компонента
          в своё отдельное пространство имён - отдельную папку с именами.
        > Чтобы избежать конфликтов надо быть уверенным в том, что
          внутри каждого отдельного компонента нет конфликта имён.

      > Пример:
        > Допустим, для работы проекта нужны 3 компонента: x, y, z;
        > Чтобы их имена не конфликтовали друг с другом, делаем следующее:
          - Помещаем все имена компонента x в пространство имён '\x',
            компонента y в пространство имён '\y', а компонента z в
            простанство имён '\z'.
        > Допустим, что во всех 3-х компонентах была переменная var.
          Чтобы из проекта обратиться к неё надо сделать сделающее
          (использован абсолютный путь):

            \x\var    | обратиться к переменной var компонента x
            \y\var    | обратиться к переменной var компонента y
            \z\var    | обратиться к переменной var компонента z


    > Подробнее о 2: как давать псевдонимы с помощью пространств имён?



> Как определить пространство имён?

  > Чьи имена зависят от пространств имён?
    > Только имена перечисленных ниже сущностей:
      - классов
      - интерфейсов
      - функций
      - констант

  > Как определить пространство имён?
    > Нужно воспользоваться ключевым словом namespace.
    > Пример:

      <?php
        namespace MyProject;

        // ... код ...
      ?>

  > Как определить вложенное пространство имён?
    > По такому же принципу, как вложенную папку.
    > Пример:

      <?php
        namespace MyProject\sub1\sub2;

        // ... код ...
      ?>

    > При определении пространств имён никогда не используй:
      - Слэш /
      - Точку .


  > Где определять пространства имён?
    > В начале блока <?php ... ?> перед любым другим кодом.
    > За исключением:
      - Строк, начинающихся с ключевого слова declare.
      - Комментариев
      - Пробелов
      - Символов перевода строки
    > Одно и то же пространство имён может объявляться в нескольких разных
      файлах/PHP-блоках.
      > Пример:

          <?php
            // Определим функцию с именем number в пр.имён NS1
            namespace NS1;
            function number() { return 10; }
          ?>

          <?php
            // Определим функцию с именем number в пр.имён NS2
            namespace NS2;
            function number() { return 10; }
          ?>

          <?php
            // Определим функцию с именем string снова в пр.имён NS1
            namespace NS1;
            function string() { return 'John'; }
          ?>

          <?php
            // Получим доступ ко всем определённым ранее функциям:
            echo \NS1\number();       // 10
            echo \NS2\number();       // 20
            echo \NS1\string();       // 'John'
          ?>


> Как определить несколько пр.имён в 1 PHP-файле?

  > Но нужно ли?
    > Пр.имён созданы для того, чтобы объединить несколько PHP-файлов в 1-ом.
      А тут нам предлагают наоборот - объединить несколько пр.имён в 1-ом файле.
    > Но если вдруг понадобится, то вот, в этом разделе описано как это сделать.

  > Доступны 2 синтаксиса:
    > Синтаксисы:
      - С фигурными скобками
      - Без фигурных скобок
    > Только синтаксис с фигурными скобками позволяет в одном PHP-файле работать
      одновременно с кодом и в глобальном, и не в глобальных пр.имён.

  > Подробнее о синтаксисе с фигурными скобками
    > Синтаксис с фигурными скобками лучше:
      - Он нагляднее показывает, что происходит.
      - Используя его, можно также работать и с глобальным пр.имён.
    > При использовании синтаксиса с фигурными скобками, любой PHP-код
      запрещён за их пределами.
    > Пример комбинации в 1-ом PHP-файле PHP-кода в глобальном и не глобальных
      пространствах имён:

        <?php

          // Добавим код в пространстве имён MyProject1
          namespace MyProject1 {
            function number() { return 10; }
          }

          // Добавим код в глобальном пространстве имён
          namespace {
            function number() { return 20; }
          }

          // Добавим код в другом локальном пространстве имён MyProject2
          namespace MyProject2 {
            function number() { return 30; }
          }

          // Получим доступ ко всем определённым ранее функциям:
          echo \MyProject\number();     // 10
          echo number();                // 20
          echo \MyProject2\number();    // 30

        ?>

  > Подробнее о синтаксисе без фигурных скобок
    > Он позволяет в одном файле работать с несколькими пространствами имён,
      но не позволяет работать с глобальным.
    > Пример работы с несколькими неглобальными пр.имён:

        <?php

          // Далее код в пр.имён MyProject1
          namespace MyProject1;

          const MY_CONST = 10;
          function myFuncton() { return 10; }

          // Далее код в пр.имён MyProject2
          namespace MyProject2

          const MY_CONST = 20;
          function myFuncton() { return 20; }

        ?>


> Глобальное пр.имён

  > Что такое глобальное пр.имён?
    > Глобальное пространство имён - это корневая папка для всех прочих
      пространств имён.
    > Если явно не указать иного, все имена функций/констант/классов/интерфейсов
      при их определении всегда попадают в глобальное пространство имён.

  > Как получить доступ к имени в глобальном пр.имён?
    > Каково бы ни было текущее пр.имён, обратиться к глобальнопу пр.имён
      можно с помощью обратного слэша \ - его надо поставить перед именем.
    > Например:

        namespace {
          function myFunc() { return 10; }
        }

        namespace xxx {
          \myFunc();    // 10   (вызвали фукнцию myFunc из глобального пр.имён)
        }



> Правила, по которым PHP узнаёт, из какого пр.имён запрашивается эл-т

  > Как в файловой системе
    > Как вы помните, пр.имён - это папка для имён.
    > Так что здесь всё работает также, как в файловой системе.

  > Есть 2 способа указать имя в коде
    > 2 способа:
      - Относительный путь
      - Абсолютный путь
    > Относительный путь:
      > Любой путь, у которого нет слэша / в начале
      > Воспринимается, как путь относительно текущего пространства имён:

          текущее_пр.имён + введённый_относительный_путь

    > Абсолютный путь:
      > Начинается с символа /, который обозначает глобальное пр.имён.

    > Примеры:

      Пусть у нас будет текущее пр.имён SuperNamespace
      -----
        namespace SuperNamespace

      Следующие абсолютный и относительный пути соответствуют друг другу:
      -----
        /SuperNamespace/function();     // абсолютный
        function();                     // относительный

  > Особенность поведения относ.путей функций/констант/классов/интерфейсов

    > Общая информация
      > Если указать имя относительным способом, то в случае, если элемент
        с указанным именем отсутствует в текущем пространстве имён, поведение
        PHP для нижеуказанных групп элементов будет отличаться:
        - Функции/константы
        - Классы/интерфейсы

    > Функции и константы
      > PHP будет искать не найденные в текущем пр.имён функции и константы
        в глобальном пр.имён.
      > Пример:

          // Глобальное пр.имён
          namespace {
            function number() { return 10; }
          }

          // Локальное пр.имён, в котором нет функции number, но она в нём
          // вызывается, и будет автоматически найдена в глоб. пр.имён:
          namespace SuperNamespace {
            echo number();     // 10
          }

    > Классы и интерфейсы
      > PHP НЕ будет искать не найденные в текущем пр.имён функции и константы
        в глобальном пр.имён.
      > Поэтому чтобы получить доступ к любому классу/интерфейсу вне текущего
        пространства имён, надо использовать абсолютный путь.
      > Пример:

          namespace {

            // Полное абсолютное имя этого класса: \myClass
            class myClass {}

          }

          namespace SuperNamespace {

            // Полное абсолютное имя этого класса: \SuperNamespace\myClass
            class myClass {}

            // Обращение к классу \SuperNamespace\myClass:
            $object1 = new myClass();

            // Обращение к классу \myClass (используем абсолютное имя)
            $object2 = new \myClass();

          }

  > Относ.путь превращается в абсол. при импользовании динамич-их имён

    > Что такое динамические имена в PHP
      > Динамическим называют имя, которое может быть определено и изменено
        динамически.
      > Проще говоря, берут значение переменной типа string и используют
        его в качестве имени.
      > Пример:

          $x = 'hello';
          $$x = 'world';

          echo $x;      // 'hello'
          echo $$x;     // 'world;
          echo $hello;  // 'world'

    > Особенность совместного использования пр.имён и динамических имён
      > В том, что относительные имена воспринимаются, как абсолютные.
      > Пример:

          // Определим функцию funcname в глобальном пр.имён:
          namespace {
            function funcname() { echo __FUNCTION__.'<br>'; }
          }

          // Определим пр.имён namespacename
          namespace namespacename {

            // Определим функцию
            function funcname() { echo __FUNCTION__.'<br>'; }

            // Определим динамические имена
            $x = 'funcname';                  // относительное имя
            $y = 'namespacename\funcname';    // относительнео имя
            $z = '\namespacename\funcname';   // абсолютное имя

            // Убедимся, что все динамические имена воспринимаются
            // PHP, как абсолютные:
            $x();   // 'funcname'
            $y();   // 'namespacename\funcname'
            $z();   // 'namespacename\funcname'

          }


> Как создать константу в желаемом пространстве имён?

  > В каком пр.имён создаёт константу операция define()?
    > define() всегда создаёт константу в глобальном пространстве имён,
      если явно не указать иного.

  > Примеры:

    Создадим константу MYCONST в глобальном пространстве имён:
    -----
      define('MYCONST', 'some text');

    Создадим константу MYCONST в пространстве имён test 2-мя способами:
    -----

      Способ 1:
      -----
        define('test\MYCONST', 'some text');

      Способ 2:
      -----
        namespace test;
        define(__NAMESPACE__ . '\MYCONST', 'some text');

  > Надо явно указывать в define(), в каком пр.имён создавать константу.
    > Поэтому при использовании констант лучше всего явно квалифицировать имя
      константы именем пространства имён, это поможет избежать путаницы.
      Пример:

        // Определим пространство имён
        namespace NS;

        // Определим 2 константы
        define(__NAMESPACE__ .'\foo','111');    // в пространстве имён NS
        define('foo','222');                    // в глобальном пространстве имён

        // Обратимся к определённым константам
        echo foo;     // 111
        echo \foo;    // 222

        // Чтобы избежать путаницы, лучше квалифицировать имя константы полным
        // именем пространства имён:
        echo \NS\foo;   // 111
        echo \foo;      // 222


> Константа __NAMESPACE__ и ключевое слово namespace

  > Аналог this
    > Предназначение вышеуказанных сущностей - концептуально такое же, как
      у ключевого слова this в javascript.
    > __NAMESPACE__ и namespace содержат полное имя текущего пр.имён.
    > В глобальном пр.имён они содержат пустую строку.

  > Зачем они нужны?
    > Для динамического формирования имени.
    > Например, вот функция, которая использует __NAMESPACE__ для
      динамического формирования имени в зависимости от того, в каком
      пространстве имён она находится:

        function get($classname)
        {
            $a = __NAMESPACE__ . '\\' . 'myClass';
            return new $a;
        }


> Импорт имён/псевдонимы для имён

  > Импорт/псевдонимы поддерживаются только для имён этих 3-х сущностей
    > 3 сущности:
      - Пространства имён.
      - Классы
      - Интерфейсы
    > При импорте/создании_псевдонима имя пр.имён всегда воспринимается,
      как абсолютное, поэтому слэш \ в начале ставить не надо (это даже вредно).
    > Импорт/создании_псевдонима не оказывают влияния, если обратиться по
      абсолютному имени к элементу. А оказывают влияние только при обращении
      по относительному имени.
      > Пример:

        use My\Full\Classname as Another, My\Full\NSname;

        $obj = new Another;         // создает объект класса My\Full\Classname
        $obj = new \Another;        // создает объект класса Another
        $obj = new Another\thing;   // создает объект класса My\Full\Classname\thing
        $obj = new \Another\thing;  // создает объект класса Another\thing

    > Для импорта используют ключевое слово use.
      > Все use должны быть указаны в самом начале файла.
      > Все use должны быть указаны в глобальной области видимости,
        и не могут быть заключены в блок, поскольку импорт выполняется
        во время компиляции, а не во время исполнения.
      > Пример использования use:

        use My\Full\Classname

    > Для создания псевдонима используют ключевое слово as:

        use My\Full\Classname as Another;

  > Что такое импорт?
    > Понятие "импорт" применяют при создании псевдонима для класса/интерфейса.
    > Говорят "импорт", потому что после этого к этому классу/интерфейсу из
      другого пр.имён можно обращаться в текущем пр.имён просто по его имени
      (без префикса в виде имени пр.имён).
    > А вообще, "импорт" и "создание псевдонима" - это одно и тоже, при условии,
      что имя класса/интерфейса остаётся тем же, Т.Е. ключевое слово "as"
      не было использовано.

  > Что такое псевдонимы?
    > Создание псевдонима - это когда мы говорим: "в этом пр.имён воспринимай
      x как y\z\k\x, как будто это одно и тоже".
    > Создать псевдоним можно для имён 3-х вышеуказанных сущностей.

  > Импорт не работает с динамическими именами
    > Импорт выполняется во время компиляции.
    > Импорт не влияет на элементы с динамическими именами.
    > Пример:

        use My\Full\Classname as Another, My\Full\NSname;

        $obj = new Another; // экземпляр класса My\Full\Classname
        $a = 'Another';
        $obj = new $a;      // экземпляр класса Another

  > Присоединяемые файлы НЕ наследуют правила импорта из родительского
    > Сабж.
    > Правила импорта задаются на каждый файл отдельно.
    > Например, если с помощью include вставить файлы X и Y в файл Z,
      то X и Y НЕ унаследуют правила импорта из файла Z.

  > Примеры:

      // Текущее пр.имён: foo
      namespace foo;

      // Импорт и создание псевдонима Another для класса Classname
      // из пр.имён My\Full
      use My\Full\Classname as Another;

      // Создать псевдоним NSname для пр.имён My\Full\NSname
      use My\Full\NSname;

      // Импорт класса ArrayObject из глобального пр.имён:
      use ArrayObject;

      // Возможны несколько импортов/созданий_псевзонима в 1-й строке:
      use My\Full\Classname as Another,
          My\Full\NSname,
          ArrayObject;








-------------------------------------------------- */

