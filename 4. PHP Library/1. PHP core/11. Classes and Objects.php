<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Классы и объекты


База
> Красивый просмотр содержания объекта
> Определение класса, метода и свойства                     | class
> Ссылка на объект в контексте объекта                      | $this
> Создание нового объекта класса                            | new
> Является ли указанный объект экземпляром этого класса?    | instanceof
> Пример наследования класса                                | extends
> Расширение имени класса с помощью namespace               | namespace
> Объявление и использование константы                      | const
> Реализация автозагрузки файлов классов из указанной папки | spl_autoload_register
> Поведение конструктора при создании объекта класса-потомка| __construct() - магический метод
> Конструктору можно передавать любое кол-во аргументов     |
> Пример определения деструктора                            | __destruct() - магический метод
> Демонстрация работы области видимости свойств и методов   | public, protected, private
> Оператор разрешения области видимости                     | ::   self, parent, static
> Доступ к статическому свойству и методу через объект      | static
> Пример абстрактного класса и метода                       | abstract
> Пример класса-интерфейса                                  | interface
> Использование трейтов                                     | trait
> Перегрузка                                                | магические методы __get(), __set(), __isset(), __unset(), __call(), __callStatic()
> Итераторы объектов и встроенные интерфейсы                | Iterator, IteratorAggregate
> Магический метод преобразования объекта в строку          | __toString()  - магический метод
> Клонирование объекта                                      | clone, __clone()     - магический метод
> Возможность вызывать объект как функцию                   | __invoke() - магический метод
> Экспорт переменной функцией var_export()                  | __set_state() - магический метод
> Сериализация и ансериализация, и магические методы        | __sleep() и __wakeup()
> Запретить переопределение метода в дочерних классах
  Запретить возможность наследовать от класса               | final - ключевое слово
> Пример сравнения объектов
> Контроль типов функций и методов класса
> Позднее статическое связывание                            | static
> Объекты, ссылки на них, и их ID - примеры

Функции для работы с классами и объектами
> class_alias                 | создает псевдоним (alias) указанного класса
> class_exists                | проверяет, был ли объявлен указанный класс
> interface_exists            | проверяет, был ли объявлен указанный интерфейс
> interface_exists            | проверяет, был ли объявлен указанный интерфейс
> trait_exists                | проверяет, был ли объявлен указанный трейт
> get_class                   | возвращает имя класса
> get_parent_class            | возвращает имя родительского класса для объекта или класса
> get_called_class            | возвращает имя класса, из которого был вызван статический метод
> get_class_methods           | возвращает массив имен методов класса с учетом регистра
> get_class_vars              | возвращает массив объявленных по умолчанию имен свойств класса
> get_declared_classes        | возвращает массив имен объявленных классов текущего скрипта
> get_declared_interfaces     | возвращает массив имен объявленных интерфейсов текущего скрипта
> get_declared_traits         | возвращает массив имен объявленных трейтов текущего скрипта
> is_a                        | проверяет, принадлежит ли объект к указанному классу, или содержит этот класс в числе своих предков
> is_subclass_of              | проверяет, содержит ли объект в своем дереве предков указанный класс
> method_exists               | проверяет, существует ли метод в указанном классе
> property_exists             | проверяет, существует ли свойство в указанном классе



-------------------------------------------------- */



// ----------------------------> БАЗА <---------------------------- //



// Красивый просмотр содержания объекта
/*

echo "<br><pre>";
print_r($i);
echo "<br></pre>";

*/


// Определение класса, метода и свойства
    class myClass {
        // Свойство
        public $v = 'значение свойства';

        // Метод
        public function display_v() {
            echo $this->v;
        }
    }

// Псевдо-переменная $this - ссылка на объект в контексте объекта
// > $this определен только в контексте объекта
    class myClass1 {
        public function method() {
            if(isset($this)) {
                echo '$this определена';
            } else {
                echo '$this не определена';
            }
        }
    }
    $ob = new myClass1();    // создание нового экземпляра (объекта) класса
    $ob->method();           // $this определена        (вызов в контексте объекта)
    myClass1::method();      // $this не определена     (вызов не в контексте объекта)

// Создание нового объекта класса (директива new)
    class myClass2 {
        static public function getNew() {
            return new static;
        }
    }
    class child extends myClass2 {}
    $ob1 = new myClass2();       // способ 1
    $ob2 = new $ob1();           // способ 2
    $ob3 = myClass2::getNew();   // способ 3
    $ob4 = child::getNew();      // способ 4

// Является ли указанный объект экземпляром этого класса? (instanceof)
    $result = $ob instanceof myClass2;  // TRUE      (да, является)

// Пример наследования класса
class myClass3 {
    public $v = 'свойство класса myClass3';
    public function f() {
        echo $this->v;
    }
}
class myClass4 extends myClass3 {
    // переопределить унаследованное свойство $v
        public $v = 'свойство класса myClass4';
    // переопределить унаследованный метод $f
        public function f() {
            echo $this->v;
        }
    // вывести переопределенное свойство на экран
        public function f2() {
            $sClass = get_parent_class($this);
            $tmp = new $sClass;
            echo $tmp->v;
        }
}
$ob = new myClass4;
$ob->f();           // свойство класса myClass4
$ob->f2();          // свойство класса myClass3

// Расширение имени класса с помощью classname
/*
    namespace NM {
        class myClass5 {}
        echo myClass5::class;    // NS\myClass5    т.е. к ClassName добавилось NS
    }
*/

// Объявление и использование константы
    class myClass5 {
        const myConst = 'значение константы';  // объявить константу
        function showConst() {
            echo self::myConst . '\n';
        }
    }
    $ob = new myClass5;
    echo $ob::myConst;   // вывести константу
    $ob->showConst();    // вывести константу

// Реализация автозагрузки файлов классов из указанной папки
// > Чтобы не приходилось вручную икнклюдить файлы с классами к каждому скрипту,
//   можно один раз определить эту функцию, которая будет автоматом запускаться
//   каждый раз при использовании ранее не определенного класса или интерфейса,
//   и подгружать из указанной папки соответствующий класс или интерфейс.
    spl_autoload_register(
        function($class) {
            // загрузить класс с именем $class и расширением .class.php из папки classes
            include 'classes/' . $class . '.class.php';
        }
    );

// Поведение конструктора при создании объекта класса-потомка
// > см. подробнее Информация -> Конструкторы

    // Ситуация №1
    // > Класс-родитель:    есть свой конструктор
    // > Класс-потомок:     есть свой конструктор
    // > Результат: при создании объекта класса-потомка автоматом запускается его конструктор,
    //              а конструктор класса родителя нет.
    //   > Но конструктор класса-родителя тоже запустится автоматом, если в конструкторе
    //     класса-потомка прописать вручную его запуск    parent::__construct();
        class myClass5a {
            function __construct() {
                echo 'Конструктор а ';
            }
        }
        class myClass5b extends myClass5a {
            function __construct() {
                parent::__construct();                 // эта строка запускает конструктор класса-родителя а
                echo 'Конструктор b ';
            }
        }
        $ob = new myClass5b;  // Конструктор а Конструктор b     (запущены конструкторы и родителя, и потомка)

    // Ситуация №2
    // > Класс-родитель:    есть свой конструктор
    // > Класс-потомок:     НЕТ своего конструктора
    // > Результат: при создании объекта класса-потомка автоматом запускается
    //              унаследованный конструктор класса-родителя (за неимением иных)
        class myClass5с extends myClass5a {

        }
        $ob = new myClass5с;  // Конструктор а    (запущен конструктор класса-родителя)

    // Ситуация №3
    // > Класс-родитель:    НЕТ своего конструктора
    // > Класс-потомок:     есть свой конструктор
    // > Результат: при создании объекта класса-потомка автоматом запускается
    //              имеющийся у него конструктор.
        class myClass5d {}
        class myClass5e {
            function __construct() {
                echo 'Конструктор e ';
            }
        }
        $ob = new myClass5e;   // Конструктор e    (запущен конструктор класса-потомка)

// Конструктору можно передавать любое кол-во аргументов
// > Он как любая обычная функция может принимать массив аргументов переменной длины
//   > Который можно считывать функцией func_num_args()
    class myClass5f {
        function __construct() {
            $flag = 0;
            foreach (func_get_args() as $k => $v) {
                echo "<p>$k => " . $v . '</p>';
                $flag = 1;
            }
            if(!$flag) {
                echo "<p>" . 'Конструктор без аргументов!' . '</p>';
            }
        }
    }
    $ob = new myClass5f;
    $ob = new myClass5f(5,10);

// Пример определения деструктора
    class myClass6 {
        function __destruct() {
            echo "<p>" . 'Вызван деструктор объекта класса myClass6!' . '</p>';
        }
    }
    $ob = new myClass6;
    // exit();   // завершаю работу скрипта и тем самым вызываю декструкторы созданных объектов

// Демонстрация работы области видимости свойств и методов
    // класс-родитель
    class myClass7a {
        // Свойства
        public $x1    = 'public свойство';
        protected $x2 = 'protected свойство';
        private $x3   = 'private свойство';

        // Методы
        function showX1pub1() {              // то же, что public function ...
            echo "<p>" . $this->x1 . '</p>';
        }
        public function showX1pub2() {
            echo "<p>" . $this->x1 . '</p>';
        }
        protected function showX1prot() {
            echo "<p>" . $this->x1 . '</p>';
        }
        private function showX1priv() {
            echo "<p>" . $this->x1 . '</p>';
        }
    }
    // класс-наследник
    class myClass7b extends myClass7a {
        // Тест доступности свойств
        function showPub() {
            echo "<p>" . $this->x1 . '</p>';   // 'public свойство'
        }
        function showProt() {
            echo "<p>" . $this->x2 . '</p>';   // 'protected свойство'
        }
        function showPriv() {
            // echo "<p>" . $this->x3 . '</p>';   // ОШИБКА!  (нет доступа)
        }

        // Тест доступности методов (часть 1)
        function showX1I() {
            $this->showX1pub1();               // 'public свойство'
            $this->showX1pub2();               // 'public свойство'
            $this->showProt();                 // 'public свойство'
            // $this->showX1priv();                 // ОШИБКА!  (нет доступа)
        }
    }

    // Тест доступности методов (часть 2)
    $ob = new myClass7b;
    // $ob->showX1prot();   // ОШИБКА!  (нет доступа)


// Оператор разрешения области видимости
    // Использование вне объявления класса
        class myClass8a {
            const CONST_VALUE = 'Значение константы';
        }
        $ob = 'myClass8a';      // тоже самое, что $ob = new MyClass8a;
        $e = $ob::CONST_VALUE;  // Значение константы

    // Использование внутри объявления класса
        class myClass8b extends myClass8a {
            public static $x = 'Статическая переменная';
            public static function get() {
                echo parent::CONST_VALUE;  // Значение константы
                echo self::$x;             // Статическая переменная
            }
        }


// Доступ к статическому свойству и методу через объект
// > К свойству через -> НЕТ
// > К свойству через :: ДА  (PHP > 5.3.0)
// > К методу доступ ДА
    class myClass9 {
        public static $x = 'статическое свойство';
        public static function f() {
            echo "<p>" . 'Статический метод' . '</p>';
        }
    }
    $ob = new myClass9; $cn = 'myClass9';
    // Доступ к статическому методу
        $cn::f();            // ДА   (работает)
        $ob->f();            // ДА   (работает)
    // Доступ к статическому свойству
        $e = $ob::$x;        // ДА   статическое свойство
        //$ob->x;            // НЕТ  (нет доступа)

// Пример абстрактного класса и метода
    abstract class myClass10a {
        // Абстрактный метод должен определяь только необходимые аргументы
        abstract protected function f($name);
    }
    class myClass10b extends myClass10a {
        // Обязательное определение унаследованного абстрактного метода
        // > С тем же аргументом, и добавлением нового ($age)
        public function f($name) {
            echo "Имя = $name, возраст =  лет";
        }
    }
    $ob = new myClass10b;
    $ob->f('Иван', 10);

// Пример класса-интерфейса
    // Интерфейсы
    interface iMyInterface1 {
        const MYCONST1 = 'Константа интерфейса 1';
        public function echoName1($name);
    }
    interface iMyInterface2 extends iMyInterface1 {
        const MYCONST2 = 'Константа интерфейса 2';
        public function echoName2($name);
    }
    $e = iMyInterface1::MYCONST1;  // доступ к константе интерфейса
    $e = iMyInterface2::MYCONST2;  // доступ к константе интерфейса

    // Класс, реализующий интерфейс
    class myClass11 implements iMyInterface2 {
        // Реализация абстрактных методов интерфейсов (обязательно)
        public function echoName1($name) {
            echo "Имя = $name" . 1;
        }
        public function echoName2($name) {
            echo "Имя = $name" . 2;
        }

        // Добавление своего метода
        public function echoName3($name) {
            echo "Имя = $name" . 3;
        }
    }

// Использование трейтов

    // Пример использования трейта
        trait myTrait {
            public $x = 10;
            public function sayWorld() {
                echo 'World, $x =  ' . $this->x;
            }
        }
        class myClass12 {
            use myTrait;
        }
        $ob = new myClass12;
        $ob->sayWorld();  // World, $x = 10

    // Демонстрация приоритетов при перезаписи методов с одинаковыми именами
    // > А заодно демонстрация решения конфликтов между методами с одинаковыми
    //   названиями, вставленных трейтами, с помощью insteadof
    // > И также демонстрация работы оператора as, с помощью которого:
    //   > Выбранным методам трейта (именам) можно назначить псевдонимы
    //   > Можно поменять область видимости выбранного метода

        // Создание 2-х трейтов
            trait myTrait12a {
                public function f1() { echo 'Это метод f1 трейта myTrait12a'; }
            }
            trait myTrait12b {
                public function f1() { echo 'Это метод f1 трейта myTrait12a'; }
            }

        // класс-родитель
            class myClass12a {
                public function f1() { echo 'Это метод f1 трейта myClass12a'; }
            }

        // класс-наследник
            class myClass12b extends myClass12a {
                // Подключить к этому классу 2 вышеопределенных трета
                use myTrait12a, myTrait12b {
                    // использовать f1 из трейта myTrait12b, а не f1 из трейта myTrait12a
                    myTrait12b::f1 insteadof myTrait12a;

                    // ... а для f1 из myTrait12a использовать псевдоним f2
                    // > И заодно меняем его область видимости с public на private
                    myTrait12a::f1 as public f2;
                }
                public function f1() { echo 'Это метод f1 класса myClass12b'; }
            }
            $ob = new myClass12b;
            $ob->f1();  // Это метод f1 класса myClass12b
            $ob->f2();  // Это метод f1 трейта myTrait12a
                // Что произошло в результате?
                // > Метод f1 класса myClass12b перезаписал метод f1 трейта myTrait12b
                // > Метода f1 трейта myTrait12a остался доступен в классе myClass12b под псевдонимом f2

        // Пример трейтов, скомпанованых из трейтов
            trait myTrait12c {
                use myTrait12a, myTrait12b {
                    myTrait12b::f1 insteadof myTrait12a;  // Это обязательно, одной следующей строкой не обойтись
                    myTrait12b::f1 as public f2;          // во избежание конфликта имен дать одному из методов псевдоним
                }
            }

        // Абстрактные методы в трейтах
            trait myTrait12d {
                use myTrait12c;
                abstract public function congratulate($name);  // абстрактный метод
            }
            class myClass12c {
                use myTrait12d;  // вместе с трейтом подключился и абстрактный метод congratulate

                // ... его требуется определить во избежании ошибки
                public function congratulate($name) {
                    echo "<p>" . $name .'! Поздравляю! Это класс myClass12c.' . '</p>';
                }
            }
            $ob = new myClass12c;
            $ob->congratulate('Иван');  // Иван! Поздравляю! Это класс myClass12c

// Перегрузка
    // Перегрузка свойств
        class myClass13 {
            // Запускается при попытке записи в недоступное свойство
            public function __set($name, $value) {
                echo "<p>" . "Попытка записи значения $value в недоступное свойство $name" . '</p>';
            }

            // Запускается при попытке чтения из недоступного свойства
            public function __get($name) {
                echo "<p>" . "Попытка чтения из недоступного свойства $name" . '</p>';
            }

            // Запускается при попытке использования функции isset() на недоступном свойстве
            public function __isset($name) {
                echo "<p>" . "Попытка использования функции isset() на недоступном свойстве" . '</p>';
            }

            // Запускается при попытке использования функции unset() на недоступном свойстве
            public function __unset($name) {
                echo "<p>" . "Попытка использования функции unset() на недоступном свойстве" . '</p>';
            }
        }
        $ob = new myClass13;
        $ob->x = 10;          // Попытка записи значения 10 в недоступное свойство x
        $e = $ob->y;          // Попытка чтения из недоступного свойства y
        $e = isset($ob->y);   // Попытка использования функции isset() на недоступном свойстве
        unset($ob->y);        // Попытка использования функции unset() на недоступном свойстве

    // Перегрузка методов
        class myClass13a {
            // Запускается в контексте объекта при вызове недоступных методов
            public function __call($name, $arguments) {
                echo "<p>" . "Попытка вызвать недоступный метод $name в контексте объекта с аргументами " . implode(', ', $arguments) .'</p>';
            }
            // Запускается в статическом контексте при вызове недоступных методов
            public function __callStatic($name, $arguments) {
                echo "<p>" . "Попытка вызвать недоступный метод $name в статическом контексте с аргументами " . implode(', ', $arguments) .'</p>';
            }
        }
        $ob = new myClass13a;
        $ob->someMethod('Аргумент1', 10);      // Попытка вызвать недоступный метод someMethod в контексте объекта с аргументами Аргумент1, 10
        myClass13a::someMet('Аргумент2', 20);  // Попытка вызвать недоступный метод someMet в статическом контексте с аргументами Аргумент2, 20

// Итераторы объектов и встроенные интерфейсы
    // Итерирование видимых свойств объекта с помощью foreach
        class myClass14a {
            public $x1 = 'Public аргумент x1';
            protected  $x2 = 'Protected аргумент x2';
            private $x3 = 'Private аргумент x3';
            public $x4 = 'Public аргумент x4';
        }
        $ob = new myClass14a;
        foreach ($ob as $key => $value) {
            echo '<p> Объект: ' . get_class($ob) . ', ключ: ' . $key . ', значение: ' . $value . '</p>';
               // Результат:
               // myClass14a, ключ: x1, значение: Public аргумент x1
               // Объект: myClass14a, ключ: x4, значение: Public аргумент x4
               // > private и protected свойства foreach не увидил.
        }

// Реализация интерфейса Iterator
    class myClass14b implements Iterator {
        private $var = [];

        // Конструктор, принимающий массив аргументов для итерации
            public function __construct($array) {
                if(is_array($array)) {
                    $this->$var = $array;
                }
            }

        // Реализация всех необходимых методов интерфейса
            // Возвращает текущий элемент
                public function current() {
                    $var = current($this->var);
                    echo "текущий: $var\n";
                    return $var;
                }
            // Возвращает ключ текущего элемента
                public function key() {
                    $var = key($this->var);
                    echo "ключ: $var\n";
                    return $var;
                }
            // Переходит к следующему элементу
                public function next() {
                    $var = next($this->var);
                    echo "следующий: $var\n";
                    return $var;
                }
            // Возвращает итератор на первый элемент
                public function rewind() {
                    echo "перемотка в начало\n";
                    reset($this->var);
                }
            // Проверка корректности позиции
            // > Вызывается после rewind() и next()
                public function valid() {
                    $key = key($this->var);
                    $var = ($key !== NULL && $key !== FALSE);
                    echo "верный: $var\n";
                    return $var;
                }
    }
    $ar = [1,2,3];
    $ob = new myClass14b($ar);
    foreach ($ob as $k => $v) {
        echo '<p> Объект: ' . get_class($ob) . ', ключ: ' . $key . ', значение: ' . $value . '</p>';
    }


// Магический метод преобразования объекта в строку
// > Из этого метода нельзя бросать исключение, а то будет ошибка
// > public string __toString( void )
    class myClass15 {
        public $x;
        public function __construct($x) {
            $this->x = $x;
        }
        public function __toString() {
            return $this->x;
        }
    }
    $ob = new myClass15('Привет, Иван!');
    echo $ob;   // Привет, Иван!

// Клонирование объекта
    class myClass16 {
        public function __clone() {
            echo 'Объект клонирован';
        }
    }
    $ob = new myClass16;
    $ob2 = clone $ob;      // Объект клонирован

// Возможность вызывать объект как функцию
// > Этот магический метод вызывется при попытке выполнить объект, как функцию (PHP >5.3.0)
// > mixed __invoke( [$...] )
    class myClass17 {
        public function __invoke($x) {
            echo "<p>Попытка вызвать объект, как фукнцию с аргументом $x</p>";
        }
    }
    $ob = new myClass17;
    $ob(10);  // 10

// Метод, автоматом запускающийся при экспорте функцией var_export()
// > Этот статический метод вызывается для классов, экспортируемых функцией var_export()
    class myClass18 {
        public function __set_state() {
            echo "<p>Произошел экспорт объекта класса с помощью функции var_export()</p>";
        }
    }
    $ob = new myClass18;
    var_export($ob);  // myClass18::__set_state(array( ))

// Сериализация и ансериализация, и магические методы
    class mySeriClass {
        public $x = 10;
        public $y = 20;
        public function show() {
            echo '<p>$x = '. $this->x . ', $y = ' . $this->y . '</p>';
        }
    }
    $ob = new mySeriClass();
    $ob_serialized = serialize($ob);    // O:11:"mySeriClass":2:{s:1:"x";i:10;s:1:"y";i:20;}
    $ob = unserialize($ob_serialized);  // object(mySeriClass)#7 (2) { ["x"]=> int(10) ["y"]=> int(20) }
    $ob->show();                        // $x = 10, $y = 20


// Запретить переопределение метода в дочерних классах
// Запретить возможность наследовать от класса
    // Пример final-метода
        class myClass19a {
            final public function myFinalMethod() {
                echo "<p>Привет, Коля!</p>";
            }
        }
        class myClass19b extends myClass19a {
            // попытка переопределить final метод родительского класса
            // > Заканчивается фатальной ошибкой
            /*
               final public function myFinalMethod() {
                echo "<p>Привет, Петя!</p>";
            }
            */
        }
    // Пример final-класса
        final class myClass19c {}

        // Попытка унаследовать от myClass19c
        // > Заканчивается фатальной ошибкой
        // class myClass19d extends myClass19c {}

// Пример сравнения объектов
    class myClass20a {
        public $x = 10;
        public $y;
        public function f() {}
    }
    $ob = new myClass20a;
    $ob2 = new myClass20a;
        // Сравнение с помощью ==
        $bo = $ob == $ob2;  // TRUE

        // Сравнение с помощью ===
        $bo = $ob === $ob2; // FALSE

    $ob2 =& $ob;
        // Сравнение с помощью ===
        $bo = $ob === $ob2;  // TRUE

// Контроль типов функций и методов класса
    class myClass21a {
        // Первый параметр должен быть объектом класса someClass
        public function f1(someClass $obj) {}

        // Первый параметро должен быть массивом
        public function f2(array $arr) {}

        // Первый параметр должен быть итератором
        public function f3(Traversable $iterator) {}

        // Первый параметр должен быть типа callable
        public function f4(callable $callback) {}
    }

// Позднее статическое связывание
    class myClass22a {
        public static function who() {
            echo __CLASS__;
        }
        public static function name() {
            echo static::who();
        }
    }
    class myClass22b extends myClass22a {
        public static function who() {
            echo __CLASS__;
        }
    }
    myClass22a::who();  // myClass22a
    myClass22b::who();  // myClass22b

// Объекты, ссылки на них, и их ID - примеры
    class A {
        public $x;
        public function __construct($x) {
            $this->x = $x;
        }
    }
    // Демонстрация различия между ссылкой и ID
    $a1 = new A(1);  // $a1 == ID_1.1 объекта класса A
    $a2 = $a1;       // $a2 == ID_1.2 объекта класса A (id копии объекта $a1)
    $a3 =& $a1;      // $a3 - это ссылка (псевдоним) на объект $a1 (ID_1.1)
    $a3 = NULL;      // делает $a1==NULL, $a3 (все еще) ссылается на $a1, $a2==ID_1.2
    $a2 = NULL;      // делает $a2==NULL
    $a1 = new A(2);  // делает $a1==ID_2.1 (новый объект), $a3 (все еще) ссылается на
                     // $a1 (новый объект), $a2==NULL

    // Ссылка на ссылку на объект ссылается на ID
    $a4 =& new A(4);  // $a4 ссылается на ID_4.1
    $a5 = $a4;        // $a5 == ID_4.2 (id копии объекта с ID_4.1)
    $a6 =& $a4;       // $a6 ссылается на ссылку на ID_4.1, что в итоге означает, что
                      // $a6 ссылается на ID_4.1 (а не на переменную $a4)
    $a4 =& new A(40); // $a4 ссылается на ID_40.1, $a5 == ID_4.2, $a6 (все еще) ссылается на ID_4.1
    $a6 = NULL;       // делает ID_4.1 равным NULL, $a5 == ID_4.2, $a4 ссылается на ID_40.1, $a6 ссылается на NULL
    $a6 =& $a4;       // $a6 ссылается на ссылку на ID_40.1, а значит $a6 ссылается на ID_40.1
    $a7 =& $a6;       // $a7 ссылается на ID_40.1
    $a8 =& $a7;       // $a8 ссылается на ID_40.1
    $a5 = $a7;        // $a5 == ID_40.2 (копия)
    $a6 = null;       // делает ID_40.1 == NULL, и все переменные, ссылающиеся на этот ID тоже
                      // == NULL, $a5 == ID_40.2


// ---------> Функции для работы с классами и объектами <--------- //

// bool class_alias( string $original, string $alias [, bool $autoload = TRUE ] )
// > создает псевдоним $alias указанного класса $original
// > $autoload - нужно ли подгружать оригинальный класс, если он не был найден
    class fclass1a {}
    class_alias('fclass1a','fclass1b');   // создание псевдонима класса fclass1a
    $ob = new fclass1b;
    // Наглядное доказательство того, что fclass1b - псевдоним класса fclass1a
        $res = $ob instanceof fclass1b;  // 1
        $res = $ob instanceof fclass1a;  // 1

// bool class_exists( string $class_name [, bool $autoload = true ])
// > проверяет, был ли объявлен указанный класс
// > С PHP 5.0.2 не возвращает TRUE для объявленных интерфейсов
// > Возвращает TRUE, если класс был объявлен; иначе FALSE
    class fclass2 {}
    $res = class_exists('fclass2');   // 1
  //$res = class_exists('sdfgsdfg');  // 0

// bool interface_exists( string $interface_name [, bool $autoload = true ])
// > проверяет, был ли объявлен интерфейс
    interface ifclass3 {}
    $res = interface_exists('ifclass3');  // 1
  //$res = interface_exists('sdfgsdfg');  // 0

// bool trait_exists( string $traitname [, bool $autoload] )
// > проверяет, был ли объявлен указанный трейт
    trait myTrait7 {}
    $res = trait_exists('myTrait7');    // 1
    //$res = trait_exists('sdfgsdfg');  // 0

// string get_class( [object $object = NULL] )
// > возвращает имя класса для объекта $object
// > если параметро $object опущен внутри класса, то вернется имя этого класса
    class fclass3_5a {
        static public function f() {
            echo '<br>Имя этого класса: ' . get_class();
        }
    }
    fclass3_5a::f();         // Имя этого класса: fclass3_5a
    $res = get_class($ob);   // fclass1a

// string get_parent_class([ mixed $object ])
// > возвращает имя родительского класса для объекта или класса
// > если целевого класса нет родителя, то функция вернет FALSE
// > если функция вызвана без параметров вне объекта, она вернет FALSE
// > $object - объект или имя класса
    class fclass3_7a {}
    class fclass3_7b extends fclass3_7a {
        public function f() {
            echo '<br>Имя родительского класса этого класса: ' . get_parent_class();
        }
    }
    $res = get_parent_class('fclass3_7b');  // fclass3_7a
        $ob = new fclass3_7b();
        $ob->f();                           // Имя родительского класса этого класса: fclass3_7a

// string get_called_class( void )
// > возвращает имя класса, из которого был вызван статический метод
    class fclass4a {
        static public function f() {
            echo 'Статическая функция f() была вызвана из класса: ' . get_called_class();
        }
    }
    class fclass4b extends fclass4a {}
    fclass4a::f();   // Статическая функция f() была вызвана из класса fclass4a
    fclass4b::f();   // Статическая функция f() была вызвана из класса fclass4b

// array get_class_methods( mixed $class_name )
// > возвращает массив имен методов класса с учетом регистра
// > возвращает NULL в случае ошибки
    class fclass5 {
        public function f1() {}
        public function fuNKciYa2() {}
        public function magaZ3() {}
    }
    $arr = get_class_methods('fclass5');  // array(3) { [0]=> string(2) "f1" [1]=> string(9) "fuNKciYa2" [2]=> string(6) "magaZ3" }

// array get_class_vars( string $class_name )
// > возвращает массив объявленных по умолчанию имен свойств класса
// > С PHP >= 5.0.3 вернет только видимые из места вызова функции свойства
    class fclass6a {
        public $x1 = 10;
        protected $x2 = 20;
        private $x3 = 30;
        public $mySuperProp = 'super';
    }
    // Отсюда видны только 2 свойства: $x1 и $mySuperProp
    $arr = get_class_vars('fclass6a');  // array(2) { ["x1"]=> int(10) ["mySuperProp"]=> string(5) "super" }

// array get_declared_classes( void )
// > возвращает массив имен объявленных классов текущего скрипта
//   > включая все зарезервированные PHP и его расширениями
    $arr = get_declared_classes();    // длинный массив с именами объявленных в этом скрипте классов

// array get_declared_interfaces( void )
// > возвращает массив имен объявленных интерфейсов текущего скрипта
    $arr = get_declared_interfaces(); // массив имен объявленных в этом скрпите интерфейсов

// array get_declared_traits( void )
// > возвращает массив имен объявленных трейтов текущего скрипта
    $arr = get_declared_traits();     // массив имен объявленных в этом скрпите трейтов

// bool is_a( object $object, string $class_name [, $allow_string = false] )
// > проверяет, принадлежит ли объект к указанному классу, или содержит этот класс
//   в числе своих предков
// > $object - проверяемый объект
// > $class_name - имя класса
// > allow_string = false не допускает имя класса в виде строки в качестве параметра $object и предотвращает вызов автозагрузчика
// > Возвращает TRUE, если объект принадлежит к этому классу, или имеет его в числе своих предков
    class fclass7a {}
    class fclass7b extends fclass7a{}
    $ob = new fclass7a;
    $res = is_a($ob,'fclass7a');  // 1    (да, объект $ob принадлежит к классу fclass7a)
    $ob = new fclass7b;
    $res = is_a($ob,'fclass7a');  // 1    (да, объект $ob имеет класс fclass7b среди своих предков)

// bool is_subclass_of( mixed $object, string $class_name [, bool $allow_string = true])
// > проверяет, содержит ли объект в своем дереве предков указанный класс
// > $object - имя класса или экземпляр объекта
// > $class_name - имя класса
// > allow_string = false не допускает имя класса в виде строки в качестве параметра $object и предотвращает вызов автозагрузчика
// > возвращает TRUE, если да; иначе - FALSE
    class fclass8a {}
    class fclass8b extends fclass8a {}
    $ob = new fclass8b;
    $res = is_subclass_of($ob,'fclass8a');   // 1   (да, содержит)

// bool method_exists( mixed $object, string $method_name )
// > проверяет, существует ли метод в указанном классе
// > $object - имя класса или экземпляр объекта
// > Возвращает TRUE, если такой метод существует; инеча - FALSE
    class fclass9a {
        public function method123() {}
    }
    $ob = new fclass9a;
    $res = method_exists($ob,'method123');  // 1    (метод method123 существует в классе fclass9a)

// bool property_exists( mixed $class, string $property )
// > проверяет, существует ли свойство в указанном классе
// > $object - имя класса или экземпляр объекта
// > Возвращает TRUE, если такое свойство существует; инеча - FALSE
    class fclass10 {
        public $myprop = 10;
    }
    $ob = new fclass10;
    $res = property_exists($ob,'myprop');  // 1    (свойство myprop существует в классе fclass9a)



/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------

> В PHP переменная типа object не содержит сам объект, как значение. Она содержит ID
  объекта, который позволяет найти конкретный объект при обращении.
  > Когда объект передается как аргумент функции, возвращается или присваивается другой
    переменной, то эти результирующие переменные не являются ссылками, они содержат копию
    ID, оторый указывает на один и тот же объект.
> $this - псевдо-переменная, доступна если метод был вызван в контексте
  объекта. Является ссылкой на вызываемый объект.
> Для создания класса используется директива new
  > Классы рекомендуется объявлять до создание их экземпляров.
  > Если имя класса находится в пространстве имен, то его надо указывать
    после new полностью.
> Наследование
  > Класс может наследовать методы и свойства другого класса, используя ключевое
    слово extends.
  > Один класс может быть наследником только одиного другого класса.
  > Наследуемые методи и свойства могут быть переопределены за исключенимем случаев,
    когда они объявлены как final.
    > Для переопределения надо объявить их с теми же именами.
    > При переопределении методов число аргументов и их типы должны остаться
      теми же, иначе PHP выдаст ошибку.
    > К переопределенным свойствам и методам можно получить доступ
      с помощью parent::
  > Родительский класс должен быть определен до наследуемого.
> Свойства класса
  > Их также называют 'атрибуты' или 'поля'
  > Они определяются с помощью ключевых слов public, protected, или private
  > При определении свойства в правой части должно быть конкретное значение, а не
    выражение. Исключения: heredoc и nowdoc.
  > Доступ к свойствам:
    > $this->свойство   | для доступа в пределах метода класса к нестатическим свойствам
    > self::свойство    | для доступа к статическим свойствам
> Автозагрузка классов
  > Разработчики ООП приложений для каждого класса обычно создают отдельный файл.
    Чтобы не писать в начале каждого скрипта длинный список подгружаемых файлов
    с классами, можно использовать функцияю spl_autoload_register (PHP>5.1.2)
    > Функциональные выражения в spl_autoload_register можно использовать начиная
      с PHP > 5.3.0
> Конструкторы
  > void __construct ([ mixed $args [, $... ]] )
  > Это метод, который автоматически запускается при создании нового объекта.
  > При создании объекта класса-потомка, конструктор класса-родителя не запускается
    автоматом (естественно).
    > Кроме того случая, когда конструктор в классе-потомке не определен. Тогда,
      за отсутствием альтернатив, при создании объекта класса-потомка запускается
      конструктор класса-родителя.
    > Чтобы вручную вызвать конструктор, объявленный в родительском методе, нужно
      обратиться к методу parent::__construct() в конструкторе класса-потомка.
> Деструкторы
  > Это метод, который автоматически запускается при удалении объекта.
  > Будет вызван при освобождении всех ссылок на определенный объект или при
    завершении работы скрипта.
  > Деструкторы ведут себя во всем также, как и конструкторы.
    В том числе в том, что касается наследования.
> Область видимости
  > Область видимость задается свойству или методу при их определении.
  > Есть 3 вида области видимости:
    > Public      | доступ отовсюду
    > Protected   | доступ только у наследников и родителя
    > Privat      | доступ только изнутри класса, в котором объявлено свойство или метод
  > Свойства класса должны быть определены только с одним из этих 3-х ключевых слов
  > Метода класса также должны быть определены только с одним из этих 3-х ключевых слов
    > Методы, где определение модификатора отсутствует, определяются как Public.
  > Объекты одного типа имеют доступ к элементам с модификаторами private и protected
    друг друга.
> Оператор разрешение области видимости ::
  > Это лексема, позволяющая обращаться к статическим свойствам, константам и
    перегруженным свойствам или методам класса.
    > При обращении к этим элементам извне класса, необходимо использовать имя
      этого класса.
  > С помощью :: можно получить доступ к указанным элементам:
    > вне объявления класса
    > внутри объявления класса только с помощью ключевых слов:
      > self
      > parent
      > static
> Статические свойства и методы
  > Чтобы объявить свойство или метод статическим, надо поставить перед его
    именем при определении ключевое слово static.
    > Например: public static function f() {}
  > Объявление свойства или метода статическим позволяет обращаться к нему без
    создания объекта класса.
  > Статическое свойство не может быть доступно через объект класса, доступ к нему
    не может быть получен через оператор ->
  > Статический метод может быть вызван через объект класса.
  > Псевдо-переменная $this не доступна внутри static метода, так как статические
    методы вызываются без создания экземпляра класса.
> Абстрактные классы и методы
  > Зачем вообще нужны абстрактные классы и методы?
    > Объясню на примере. Допустим, в проекте есть ряд классов, у которых есть
      ряд методов с одинаковыми названиями. У некоторых из них реализация полностью
      идентична, а у других различна.
      > Можно сделать абстрактный класс, содержащий:
        > Не абстрактрые методы с реализацией. Это те самые методы, реализация у
          которых для описанных выше классов полностью идентична.
        > Абстрактные методы без реализации. А это те методы, в которых реализация
          различна. Я указываю их в абстрактном классе чтобы сказать: "эти методы
          должны быть здесь, но для каждого класса-потомка реализация у них своя".
      > Ну а дальше просто создаем неабстрактных наследников этого абстрактного
        класса, и кажодму из них пишем реализацию всех заявленных ранее
        абстрактных методов.
  > Абстрактный класс или метод можно объявить с помощью ключевого слова abstract. Например:
    > abstract class myAbstractClass {}
    > abstract public function f();
  > Нельзя создать экземпляр абстрактного класса.
  > Класс, содержащий хотя бы один абстрактный метод, также должне быть
    определен, как абстрактный.
  > Объявления абстрактных методов носят описательный характер, и не могут содержать
    реализации. Это значит, что не надо писать {} после метода. Например:
    > abstract public function f();    {} - не писать.
  > При наследовании от абстрактного класса, все методы, помеченные абстрактными в
    родительском классе должны быть определены в классе-потомке.
    > Их область видимости должна быть такая же, либо менее строгая.
    > Типы и количество обязательных аргументов должны совпадать.
> Интерфейсы объектов
  > Зачем вообще нужны интерфейсы?
    > Хорошее объяснение можно прочитать здесь: askdev.ru/php/6981/Зачем-в-PHP-нужны-абстрактные-классы-и-интерфейсы/
    > Но лучше иметь под рукой и свое краткое объяснение:
      > Интерфейс позволяет 2 и более программистам договориться между собой до
        начала работ. Они вместе составляют класс-интерфейс,
        который какбэ говорит: "вот эти классы, унаследованные от этого интерфейса,
        обязаны будут реализовывать вот такие методы, имеющие вот такие параметры,
        и возвращающие вот такие значения".
        > Например. У нас есть 2 программиста А и Б. Им надо написать 4 класса.
          Эти классы потом будут взаимодействовать между собой. Но как, ведь код
          классов еще не написан, неизвестны ни названия методов, ни параметры.
          Поэтому, наши программисты еще до начала работ садятся и совместно пишут
          интерфейсы для этих классов. А уже затем приступают к работе.
          И программисту А абсолютно по барабану, как внутренне реализованы те
          классы, что делает программис Б. Ведь у А есть интерфейс этих классов.
        > Еще пример. Вот есть телевизоры. Они бывают разных марок и принцип работы
          у них может быть разный, один ЭЛТ, другой ЖК, третий Плазменный.
          Обычный пользователь не должен знать внутреннюю реализацию телевизора.
          Но ему известен интерфейс - это пульт. И он знает, что происходит при
          нажатии на ту или иную кнопку. Этого ему достаточно.
  > Интерфейсы объектов позволяют создавать код, который указывает, какие методы
    и свойства должен включать класс, без необходимости описывания их функционала.
  > Названия классов-интерфейсов принято начинать с i
  > Классы-интерфейсы объявляются с использованием ключевого слова interface.
    > Например:   interface iMyClass {}
  > Тела методов интерфейсов должны отсутствовать (как у абстрактных методов)
  > Все методы класса-интерфейса должны быть public.
  > Для реализации интерфейса классом используется оператор implements
    > Класс может реализовывать несколько интерфейсов за раз:
      > class myClass implements iInterface1, iInterface2, ...
    > Класс НЕ может реализовывать 2 интерфейса с методами, имеющими одинаковые
      имена. Иначе это повлекло бы за собой неоднозначность.
  > Класс должен реализовывать все методы, описанные в интерфейсе.
    > Сигнатуры методов в интерфейсе (количество параметров и их типы) должны
      полностью совпадать с их реализацией в реализующих этот интерфейс классах.
  > Интерфейсы могут быть унаследованы друг от друга стандартным способом
    с помощью оператора extends
  > Константы в интерфейсе работаею также, как в обычном классе, за исключением
    того, что они не могут быть перекрыты наследующим классом или интерфейсом.
> Трейты
  > Трейт - это библиотека методов, которую можно вставлять в любой класс и
    использовать в нем. Это инструментарий для повторного использования кода.
    > Свойства тоже можно определять в трейте.
  > Трейт похож на класс, но нельзя создать экземпляр трейта.
  > Трейт можно создать с помощью ключевого слова trait
    > Например:   trait myTrait {...}
  > Вставить трейт в класс можно с помощю ключевого слова use
    > Например:   class myClass { use myTrait; }
    > Можно вставить несколько трейтов:   use myTrait1, myTrait2, ...
  > Приоритеты при использовании трейта:
    > Что будет если в классе появились 3 метода с одинаковым именем. Один он
      унаследовал, второй был вставлен с трейтом, а третий был определен в самом
      классе? Приоритеты расставлены следующим образом:
      > Вставленный с трейтом метод перезаписывает унаселедованный.
      > Определенный в классе метод имеет наивысший приоритет, и перезаписывает
        и унаследованный, и вставленный с трейтом.
    > А что будет, если 2 трейта вставляют метод с одним и тем же именем?
      Это приведет к фатальной ошибке. Поэтому требуется давать дополнительное
      разъяснение для PHP, какой же все-таки из методов использовать
      > Например (схема): use myTrait1, myTrait2 { method1 insteadof method2 }
  > Можно изменить область видимости для метода, вставленного в класс с помощью
    трейта. Для этого используется оператор as:
    > use myTrait1 { method1 as private }
    > Также этот оператор используется для назначения псевдонима для имени
      метода трейта. Чаще всего в ситуации, когда возникает конфликт имен
      методов, вставленных разными трейтами.
  > Трейт может целиком состоять из других трейтов
  > Трейты поддерживают абстрактные методы
  > В трейтах можно определить статические методы, но нельзя определить
    статические свойства. Но зато на последние можно ссылаться из методов
    трейта.
> Перегрузка
  > Интерпретация "перегрузки" в PHP отличается от остальных объектно-ориентированных
    языков. Традиционно перегрузка означает возможность иметь множество одноименных
    методов с разным количеством или разными типами аргументов. Но не в PHP.
  > В PHP суть перегрузки в следующем. При вызове недоступных свойств и методов
    запускаются так называемые "магические методы", в которые можно дописать
    свой код
    > Свойство или метод недоступно, если оно определено или не виднО в этом месте.
    > Например: я пытаюсь вызвать метод f1 из объекта o1. Но такой метод отсутствует.
      Автоматом запускается магический метод __call, в который я в определении
      класса объекта o1 дописал свой код.
  > Перегрузка свойств
    > Указанные ниже методы будут вызваны только в контексте объекта, и не будут
      вызваны в статическом контексте (напрямую из класса без объекта).
    > Для перегрузки свойств надо работать со следующими 4-мя магическими методами:
      > public void __set(string $name, mixed $value)
        > Будет выполнен при записи данных в недоступные свойства
      > public mixed __get(string $name)
        > Будет выполнен при чтении данных из недоступных свойств
      > public bool __isset(string $name)
        > Будет выполнен при использоватии isset() и empty() на недоступных свойствах
      > public void __unset(string $name)
        > Будет выполнен при вызове unset() на недоступном свойстве
  > Перегрузка методов
    > Для перегрузки методов надо работать со следующими 2-мя магическими методами:э
      > public mixed __call( string $name, array $arguments )
        > Вызывается в контексте объекта при вызове недоступных методов
      > public static mixed __ callStatic( string $name, array $arguments)
        > Вызывается в статическом контексте при вызове недоступных методов
> Итераторы
  > С помощью оператора foreach можно проитерировать все видимые свойства
    объекта.
    > Если использовать foreach вне определения класса на его объекте, то
      он увидит только его public свойства, а protected и private проигнорирует,
      т.к. они не видны.
  > В PHP 5 есть встроенный интерфейс Iterator.
    > Можно реализовать этот интерфейс и самому настроить, как будут итерироваться
      объекты класса, в которых этот интерфейс реализован, и какие данные будут
      доступны на каждой итерации.
    > Описание интерфейса Iterator здесь: http://www.php.net/manual/ru/class.iterator.php
    > Альтернативой интерфейсу Iterator служит другой встроенный интерфейс
      IteratorAggregate
      > В отличие от Iterator, в нем нужно реализовать только 1 метод, который
        возвращает объект класса, реализующего интерфейс Iterator.
      > Его описание можно найти здесь: http://www.php.net/manual/ru/class.iteratoraggregate.php
> Магические методы
  > Следующие имена зарезервированы для "магических" методов PHP
    > __construct()       | вызывается при создании объекта класса
    > __destruct()        | вызывается при уничтожении объекта класса
    > __call()            | (см. Перегрузка) вызывается в контексте объекта при вызове недоступного метода
    > __callStatic()      | (см. Перегрузка) вызывается в статическом контексте при вызове недоступного метода
    > __get()             | (см. Перегрузка) вызывается при записи в недоступные свойства
    > __set()             | (см. Перегрузка) вызывается при чтении из недоступных свойствв
    > __isset()           | (см. Перегрузка) вызывается при использовании функции isset() на недоступных свойствах
    > __unset()           | (см. Перегрузка) вызывается при использовании функции unset() на недоступных свойствах
    > __sleep()           | вызывается при сериализации до нее
    > __wakeup()          | вызывается при ансериализации до нее
    > __toString()        | вызывается при преобразовании объекта класса в строку
    > __invoke()          | вызывается при попытке вызвать объект, как функцию
    > __set_state()       | этот статический метод вызывается для классов, экспортируемых функцией var_export()
    > __clone             | вызывается у свежесозданного клона объекта
  > Сериализация и ансериализация и магические методы __sleep() и __wakeup()
    > Если в классе присутствует магический метод __sleep(), то он вызываеся при
      сериализации до нее.
      > Должен быть возвращен массив с именами переменных, которые этот объект должен
        серилизовать.
        > Недопустимо включать в этот массив имена приватных переменных из родительского
          класса.
    > Магический метод __unserialize() - если он есть в определении класса - запускается
      при ансериализации. Он может воссоздать все ресурсы объекта, принадлежавшие ему
      до сериализации.
> Клонирование объекта
  > Позволяет создать клон объекта какого-либо класса
  > Копию объекта можно создать, используя ключевое слово clone
  > В классе клонируемого объекта можно реализовать магический метод __clone(),
    который вызывается после клонирования свежесозданным объектом.
  > Любые свойства клонируемого объекта, являющиеся ссылками, в клонированном
    объекте также останутся ссылками.
  > Подробнее о нем здесь: http://www.php.net/manual/ru/language.oop5.cloning.php#object.clone
> Ключевое слово final
  > Если определить метод с final, запрещает переопределение этого метода в дочерних классах.
    > Например: final public function f() {}
  > Если определить класс с final, запрещает наследование от этого класса. Т.е. класс не
    может стать родителем. По сути, кастрация =)
    > Например: final class myClass {}
  > Отличие использования private от final с методами состоит в следующем:
    > private определяет область видимости, и private-метод не может быть вызван из
      дочернего класса, потому что не виден там.
    > final же определяет, можно ли переопределить метод в дочернем класса; при это вызвать
      final-метод из дочернего класса можно.
> Сравнение объектов
  > При использовании == 2 объекта равны, если:
    > Являются объектами одного и того же класса
    > Содержат одинаковые свойства
    > Соответствующие свойства содержат одинаковые значения
  > При использовании ===:
    > Переменные типа object считаются идентичными только если они ссылаются
      на один и тот же объект.
> Контроль типов функций и методов класса
  > Есть возможность заставлять параметры метода быть:
    > объектами - путем указания имени класса в качестве типа
      > все потомки этого класса также подойдут в качестве этого параметра
    > интерфейсами
      > все реализации этого интерфейса также подойдут в качестве параметра
    > массивами
    > коллбэком
  > Контроль типа не может быть использован со скалярными типами, такими как int или
    string. Трейты также недопустимы.
  > Контроль типов допускает значение типа NULL
> Позднее статическое связывание
  > Позволяет в статическом контексте из классов-наследников с помощью ключевого слова
    static указывать в унаследованных методах на себя
    > Проще всего это объяснить на примере, см. выше в оглавлении.
  > static:: может ссылаться только на статические поля класса.
> Сериализация объекта
  > Производится с помощью функции serialize().
    > Сохраняет имя класса все его свойства-значения в строку. Методы не сохраняются.
  > Десериализация проводится с помощью функции unserialize()
    > До осуществления десериализации должно присутствовать определения класса
      сериализованного объекта. Иначе PHP для десериализации использует класс
      __PHP_Incomplete_Class_Name, который не имеет методов, и сделает объект бесполезным.
  > В сериализацию и десериализацию можно вмешаться с помощью магических методов
    __sleep() и __wakeup() соответственно (см. выше "магические методы").






-------------------------------------------------- */
?>





















