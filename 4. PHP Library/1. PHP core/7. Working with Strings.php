<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Все о работе со строками


> Доступ к символам (байтам) в строке

Функции (выборка наиболее нужных)
> addslashes          | экранирует спецсимволы в строке слэшами
> stripslashes        | удаляет экранироване символов, добавленное addslashes
> explode             | разбивает строку на массив строк по указанному разделителю
> implode (или Join)  | склеивает массив строк в одну строку с указанным разделителем
> str_split           | преобразовать строку в массив символов
> lcfirst (1 байт)    | преобразует первый символ строки в нижний регистр (только 1-байтовые кодировки)
> ucfirst (1 байт)    | преобразует первый символ строки в верхний регистр (только 1-байтовые кодировки)
> ucwords             | преобразует в верхний регистр первый символ каждого слова в строке
> ltrim (1 байт)      | удаляет пробелы и указанные символы из начала строки (только 1-байтовые кодировки)
> rtrim (1 байт)      | удаляет пробелы и указанные символы из конца строки (только 1-байтовые кодировки)
> trim (1 байт)       | удаляет пробелы и указанные символы из начала и конца строки (только 1-байтовые кодировки)
  > mb_trim           | (польз.) UTF8-аналог функции trim
> md5                 | возвращает MD5-хэш строки
> sha1                | возвращает SHA1-хэш строки
> sprintf             | возвращает отформатированную по указанным правилам строку
> sscanf              | разбирает строку в соотв. с указанным форматом
> str_replace (1 байт)| заменяет все вхождения строки поиска на строки замены
 > mb_replace         | UTF8 аналог str_replace
> str_ireplace(1 байт)| регистронезависимо заменяет все вхождения строки поиска на строки замены
> preg_replace(1 байт)| выполняет поиск и замену по регулярному выражению
 > mb_ereg_replace    | UTF8 аналог preg_replace
> str_pad             | дополняет строку указанными символами до требующейся длины
> str_repeat          | возвращает повторяющуюся N раз строку
> str_shuffle (1 байт)| переставляет символы в строке случайным образом
> strlen              | возвращает длину строки в байтах (без учета завершающего байта)
> strstr              | возвращает подстроку начиная с первого вхождения указанного символа, и включая его
> strip_tags          | удаляет все NUL-байты, HTML и PHP тэги из строки
> strcspn (1 байт)    | возвращает длину участка из начала строки S1, которая не содержит ни 1 символа из строки S2
> strnatcasecmp       | сравнение строк без учета регистра
> strpbrk (1 байт)    | ищет в строке символы из указанного набора
> strpos              | возвращает позицию первого вхождения подстроки
> strtolower (1 байт) | преобразует строку в нижний регистр
 > mb_strtolower      | UTF8 аналог strtolower
> strtoupper (1 байт) | преобразует строку в верхний регистр
 > mb_strtoupper      | UTF8 аналог mb_strtoupper
> wordwrap            | осуществляет перенос строки по указаному количеству байт
> strtr               | функция для транслитерации - заменяет все вхождения ключей в переданном массиве на соответствующие значения
> htmlspecialchars    | возвращает строку, в которой преобразовала спец. символы в HTML-сущности
                        > Особенно полезно, когда парсишь чей-нибудь сайт функцией file()
> get_html_translation_table | возвращает таблицу преобразований, используемую функцией htmlspecialchars
> htmlspecialchars_decode | преобразует HTML-сущности обратно в соответствующие символы
> mb_detect_encoding  | Определяет кодировку в строке str
>
>

Многобайтные аналоги 1-байтных функций (которых нет по ссылкам в Информации)
> mb_replace          | UTF8-аналог 1-байтной str_replace()



-------------------------------------------------- */


// -------------> Функции (выборка наиболее нужных) <------------- //


// Доступ к символам (байтам) в строке
    $str = 'Привет';
    $symbol_1 = $str{0} . $str{1};  // 'П'  (в кириллице 1 символ занимает 2 байта)

// string addslashes( string $str )
// > экранирует спецсимволы в строке слэшами
    $str = addslashes("О'конор");   // О\'конор

// string stripslashes( string $str )
// > удаляет экранироване символов, добавленное addslashes
    $str = stripslashes('О\'конор');    // О'конор

// array explode( string $delimiter, string $str [, int $limit] )
// > разбивает строку на массив строк по указанному разделителю
// > возвращает <= $limit строк; если $limit < 0, то возвращает все, кроме
//   $limit последних; если $limit == 0, то $limit = 1 автоматом.
    $arr = explode(' ', 'Один два три', 5);   // [0]=>'Один', [1]=>'Два', [2]=>'Три',

// string implode( string $glue, array $pieces )      | псевдоним: Join
// > склеивает массив строк в одну строку с указанным разделителем
// > $glue это тоже, что $delimiter из explode
    $str = implode(' ', ['Иван', 'пришел', 'домой']);  // Иван пришел домой

// array str_split( string $string [, int $split_length = 1] )
// > преобразовать строку в массив символов
// > split_length - максимальная длина фрагмента (1 по умолчанию, подходит для 1 байтовых кодировок)
//   > для UTF8 и кириллицы надо указать 2
    $arr = str_split('Привет',2); var_dump($arr);  // [0]=>'П', [1]=>'р', [2]=>'и', [3]=>'в', [4]=>'е', [5]=>'т'
    $arr = str_split('Hi',1); var_dump($arr);      // [0]=>'H', [1]=>'i'

// string lcfirst( string $str )
// > преобразует первый символ строки в нижний регистр
// > !!! Не работает с кириллицей
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = lcfirst('Париж');  // Париж (НЕ сработало!)
    $str = lcfirst('John');   // john

// string ucfirst( string $str )
// > преобразует первый символ строки в нижний регистр
// > !!! Не работает с кириллицей
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = ucfirst('париж');  // париж (НЕ сработало!)
    $str = ucfirst('john');   // John

// string ucwords( string $str )
// > преобразует в верхний регистр первый символ каждого слова в строке
// > !!! Не работает с кириллицей
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = ucwords('blue blue sky');  //Blue Blue Sky

// string ltrim( string $str [, string $charlist] )
// > В $charlist можно послать строку, содержащую те символы, которые надо обрезать еще помимо пробелов
// > !!! При обрезке кириллических символов могут быть ошибки!
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = ltrim('.GHJYRПривет Ричард', 'GHJYR.');  // Привер Ричард
    $str = ltrim('ПППТрава', 'П');                  // �рава (!! ошибка!)

// string rtrim( string $str [, string $charlist] )
// > В $charlist можно послать строку, содержащую те символы, которые надо обрезать еще помимо пробелов
// > !!! При обрезке кириллических символов могут быть ошибки!
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = rtrim('Привет Ричард.GHJYR', 'GHJYR.');  // Привер Ричард

// string trim( string $str [, string $charlist] )
// > В $charlist можно послать строку, содержащую те символы, которые надо обрезать еще помимо пробелов
// > !!! При обрезке кириллических символов могут быть ошибки!
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = trim('fwee..Муравушка..ereg', 'fwerg.');  // Муравушка

// mb_trim
// > (польз.) UTF8-аналог функции trim
  if (!function_exists("mb_trim"))
  {
      function mb_trim( $string ) {
          return preg_replace( "/(^\s+)|(\s+$)/us", "", $string );
      }
  }


// string md5( string $str [,$raw_output = false] )
// > возвращает MD5-хэш строки
// > если raw_output == TRUE, то возвращается бинарная строка из 16 символов.
    $str = md5('Маша');  // 9ee3309645bd2c0775899fca14f311e1
    $str = md5('Маша');  // 9ee3309645bd2c0775899fca14f311e1

// string sha1( string $str [,$raw_output = false] )
// > возвращает SHA1-хэш строки
// > если raw_output == TRUE, то возвращается бинарная строка из 16 символов.
    $str = sha1('Маша');  // cae55361f5033ebfc89cc0f589848a12e3825f7f
    $str = sha1('Маша');  // cae55361f5033ebfc89cc0f589848a12e3825f7f

// string sprintf( string $format [, mixed $args [, mixed $...]] )
// > подробная инструкция тут: http://www.php.net/manual/ru/function.sprintf.php
    $a = 'Нагасаки';
    $b = 10;
    $format = 'Здание в районе %s имеет %d этажей';
    $str = sprintf($format,$a,$b);  // Здание в районе Нагасаки имеет 10 этажей

// mixed sscanf( string $str, string $format [, mixed &$...] )
// > &$... - необязательные переменные, переданные по ссылке, которым будут
//           переданы считанные значения
    // способ 1
        $day = 0; $month = ''; $year = 0;
        sscanf('24 января 1987 года','%d %s %d года', $day,$month,$year);
        echo $day .' '. $month .' '. $year;  // 24 января 1987
    // способ 2 (более прогрессивный)
        list($day,$month,$year) = sscanf('24 января 1987 года','%d %s %d года');
        echo $day .' '. $month .' '. $year;  // 24 января 1987

// mixed str_replace( mixed $search, mixed $replace, mixed $subject [, int &$count] )
// > заменяет все вхождения search в subject на replace
// > в $count будет записано количество произведенных замен
// > !!! При обрезке кириллических символов могут быть ошибки!
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции: mb_replace
    $arr = ['h','e','o','d','p','W'];
    $str = str_replace($arr,'','Hello, World of PHP');  // Hll, rl f PHP

// mixed str_ireplace( mixed $search, mixed $replace, mixed $subject [, int &$count] )
// > регистронезависимо (в отличие от str_replace) заменяет все вхождения
//   search в subject на replace
// > в $count будет записано количество произведенных замен
    $arr = ['h','e','o','d','p','W'];
    $str = str_ireplace($arr,'','Hello, World of PHP');  // ll, rl f
    echo $str;

// mixed preg_replace( mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] )
// > ищет совпадения в строке subject с шаблоном pattern и заменяет их на replacement
// > в $count будет записано количество произведенных замен
// > $limit - МАХ возможное число замен для каждой строки, по умолчанию -1 (без ограниений)
// > !!! С кириллицей не работает
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции: mb_ereg_replace
    $string = 'April 15, 2003';
    $pattern = '/(\w+) (\d+), (\d+)/i';
    $replacement = '${1}1,$3';
    $str = preg_replace($pattern, $replacement, $string);  // April1,2003

// string str_pad( string $input, int $pad_length, [, string $pad_string = ' ' [, int $pad_type = STR_PAD_RIGHT ]] )
// > дополняет строку указанными символами до требующейся длины
// > $pad_length передается в байтах
//   > 4 байта занимайт х/з что в этой функции
//   > 1 байт занимает символ конца строки
//   > английские символы - 1 байт, кириллические 2 байт,
//   > Значит, например, 2 русские буквы займут 4 + 1 + 4 = 9
//   > А 2 английские, например, 4 + 1 + 2 = 7
    $str = str_pad('Hello', 9, "Йо", STR_PAD_RIGHT);  // HelloЙо
    $str = str_pad('Hello', 9, "Yo", STR_PAD_RIGHT);  // HelloYoYo
    $str = str_pad('Hello', 9, "Йо", STR_PAD_LEFT);   // ЙоHello
    $str = str_pad('Hello', 13, "Йо", STR_PAD_BOTH);  // ЙоHelloЙо

// string str_repeat( string $input, int $multiplier )
// > возвращает повторяющуюся multiplier раз строку input
    $str = str_repeat('Хо',5);   // ХоХоХоХоХо


// string str_shuffle( string $str )
// > переставляет символы в строке случайным образом
// > !!! С кириллицей не работает
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = str_shuffle('Hello');  // eloHl
    echo $str;

// int strlen( string $string )
// > возвращает длину строки в байтах (без учета завершающего байта)
    $str = strlen('Троя');   // 8
    $str = strlen('John');   // 4

// string strstr( string $haystack, mixed $needle [, bool $before_needle = false ] )
// > возвращает подстроку начиная с первого вхождения указанного символа, и включая его
// > если before_needle == TRUE, возвращает часть строки до первого вхождения не включая
// > stristr - регистронезависимый вариант strstr
    $str = strstr('Моя_почта_собака_мэйл.рф', 'собака', false);  // собака_мэйл.рф
    $str = strstr('Моя_почта_собака_мэйл.рф', 'собака', true);   // Моя_почта_

// string strip_tags( string $str, [, string $allowable_tags] )
// > Удаляет все NUL-байты, HTML и PHP тэги из строки
//   > то, что внутри тегов - тоже удаляется напрочь
// > allowable_tags - можно указать тэги, которые не нужно удалять
    $str = strip_tags('<html><p>Привет <?php echo "Жульен" ?></p></html>','<p></p>');  // 'Привет '


// int strcspn( string $str1, string $str2 [, int $start [, int $length ]] )
// > возвращает длину участка из начала строки $str1, которая
//   не содержит ни 1 символа из строки $str2
// > $start - начальная позиция для сравнения
// > $length - длина сравнения
// > !!! С кириллицей не работает
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = strcspn('Hello','o');   // 4


// int strnatcasecmp( string $str1, string $str2 )
// > сравнение строк без учета регистра
// > возвращает -1, если $str1<$str2, и +1 если больше
// > strnatcmp() - регистрозависимый аналог этой функции
    $str = strnatcasecmp('Жора1','Жора');  // +1
    $str = strnatcasecmp('Жора','Жора1');  // -1

// string strpbrk( string $haystack, string $char_list )
// > ищет в строке haystack символы из набора char_list
// > возвращает строку, начиная с указанного символа
// > чувствителен к регистру
// > !!! С кириллицей не работает
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции
    $str = strpbrk('Good Very Country!','V');  // Very Country!

// int strpos( string $haystack, mixed $needle [, int $offset = 0] )
// > возвращает позицию (в байтах) первого вхождения подстроки needle в строку haystack
//   > возвращает false, если искомая строка не найдена
// > offset - позиция, с которой следует начинать поиск
// > в кириллице и UTF8 1 символ занимает 2 байта, помни об этом
    $str = strpos('Чашка чая','чая');   // 11 (чашка занимает 10 байт + 1 байт занимает пробел)

// string strtolower( string $str )
// > преобразует строку в нижний регистр
// > !!! С кириллицей не работает
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции mb_strtolower
    $str = strtolower('HELLO');  // hello

// string strtoupper( string $str )
// > преобразует строку в верхний регистр
// > !!! С кириллицей не работает
//       это связано с тем, что они занимают не 1, а 2 байта
//   > С кириллицей использовать UTF8-версию этой функции mb_strtoupper
    $str = strtoupper('hello');  // HELLO
    $str = mb_strtoupper('привет','UTF-8');  // ПРИВЕТ
    echo $str;

// string wordwrap( string $str [, int $width = 75 [, string $break = "\n" [, bool $cut = false]]] )
// > осуществляет перенос строки по указаному количеству байт
// > для 2-байтных кодировок (включая кириллицу) количество байт должно быть четным
// > $width - допустимая ширина строки
// > $break - символ переноса строки
// > $cut - разрезать последнее длинное слово или нет
    $str = wordwrap( 'Привет старуха Шапокляк, не видела крокодила Гену с Чебурашкой?', 20, '(_||_)');   // Привет(_||_)старуха(_||_)Шапокляк,(_||_)не видела(_||_)крокодила(_||_)Гену с(_||_)Чебурашкой?

// string strtr( string $str, string $from, string $to )
// string strtr( string $str, array $replace_pairs )
// > Возможны 2 варианта входных параметров, и 2 режима работы:
//   > 1 Режим
//     > Заменяет все вхождения $from в строку $str на $to
//     > Возвращает модифицированную строку
//   > 2 Режим
//     > Заменяет все вхождения ключей массива $replace_pairs в строку $string
//       на соответствующие ключам значения этого массива.
    $str = 'иван';
    $arr = ['и'=>'i','в'=>'v','а'=>'a','н'=>'n'];
    $str = strtr($str, $arr);    // 'ivan'       - это был простой пример транслитерации

// string htmlspecialchars( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [,
//                          string $encoding = 'UTF-8' [, bool double_encode = true ]]] )
// > Возвращает строку, в которой преобразовала спец. символы в HTML-сущности.
//   В HTML некоторые символы имеют специальное значение и для сохранения своего
//   значения должны быть преобразованы в HTML-сущности.
// > Особенно полезно, когда парсишь чей-нибудь сайт функцией file()
// > $flags - флаги, $encoding - кодировка (UTF-8 по умолчанию с PHP > 5.4.0)
// > Подробнее о том, какие производятся преобразования, о возможных значениях $flags -
//   здесь: http://www.php.net/manual/ru/function.htmlspecialchars.php
    $arr = file('http://www.ya.ru/');  // забирает страничку по URL
    /*  // посмотреть, что мы спарсили
    foreach ($arr as $line_num => $line) {
        echo "Строка #<b>{$line_num}</b> : " . htmlspecialchars($line) . "<br />\n";
    }
    */

// array get_html_translation_table([ int $table = HTML_SPECIALCHARS [,
//         int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = 'UTF-8' ]]] )
// > возвращает таблицу преобразований, используемую функцией htmlspecialchars
// > $table - указывает, какую таблицу преобразований вернуть:
//   > HTML_ENTITIES       -
//   > HTML_SPECIALCHARS   -
// > $flags - флаги. Их можно посмотреть здесь: http://www.php.net/manual/ru/function.get-html-translation-table.php
// > $encoding - кодировка (UTF-8 по умолчанию с PHP > 5.4.0)
// > Возвращает таблицу с Ключами: ориг. символами; Значениями: сущностями.
    $arr = get_html_translation_table(HTML_ENTITIES, ENT_QUOTES | ENT_HTML5);
    /*
    echo "<br><pre>";
    print_r($arr);         // посмотреть таблицу преобразований
    echo "<br></pre>";
    */

// string htmlspecialchars_decode( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 ])
// > преобразует HTML-сущности обратно в соответствующие символы
// > антипод функции htmlspecialchars()
// > $flags - флаги. Их можно посмотреть здесь: http://www.php.net/manual/ru/function.htmlspecialchars-decode.php
// > возвращает преобразованную строку
    $str = "<p>this -&gt; &quot;</p>\n";
    $r = htmlspecialchars_decode($str);  // this -> "

// string mb_detect_encoding( string $str [, mixed $encoding_list = mb_detect_order() [,
//                            bool $strict = false ]] )
// > Определяет кодировку в строке str
// > $encoding_list - массив возможных кодировок; если не задан, будет установлен функцией mb_detect_order()

    // Какая кодировка у строки на русском языке?
        $str = 'Некая строка';
        $res = mb_detect_encoding($str);  //  'UTF-8'

    // Какая кодировка у строки на английском языке?
        $str = 'Some string';
        $res = mb_detect_encoding($str);  // 'ASCII'

    // Какая кодировка у строки, включающей RUS и ENG символы?
        $str = 'Some string, некая строка';
        $res = mb_detect_encoding($str);  // 'UTF-8'




// -------------> Многобайтные аналоги 1-байтных функций (которых нет по ссылкам в Информации) <------------- //



// mb_replace
// > UTF8-аналог 1-байтной str_replace
function mb_replace($search, $replace, $subject, &$count=0) {
    if (!is_array($search) && is_array($replace)) {
        return false;
    }
    if (is_array($subject)) {
        // call mb_replace for each single string in $subject
        foreach ($subject as &$string) {
            $string = &mb_replace($search, $replace, $string, $c);
            $count += $c;
        }
    } elseif (is_array($search)) {
        if (!is_array($replace)) {
            foreach ($search as &$string) {
                $subject = mb_replace($string, $replace, $subject, $c);
                $count += $c;
            }
        } else {
            $n = max(count($search), count($replace));
            while ($n--) {
                $subject = mb_replace(current($search), current($replace), $subject, $c);
                $count += $c;
                next($search);
                next($replace);
            }
        }
    } else {
        $parts = mb_split(preg_quote($search), $subject);
        $count = count($parts)-1;
        $subject = implode($replace, $parts);
    }
    return $subject;
}






/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------

> Здесь можно найти все функции: http://www.php.net/manual/ru/book.strings.php

О 1-байтовых функциях и их UTF8-версиях
> Есть кодировки, в которых 1 символ занимает 1 байт. Их называют 1-байтовые.
  А есть, в которых 1 символ = 2 байта. К последним относится UTF-8 и кириллица.
> Все функции из ядра PHP изначально были написаны для 1-байтовых кодировок, и многие
  из них с 2-байтовыми не работают корректно вообще никак (в оглавлении они обозначены
  как '(1 байт)')
  > Часть из них имеют аналоги для работы с многобайтовыми строками
    > Их список и описание можно найти здесь: http://php.net/manual/ru/ref.mbstring.php
  > Но многие полезные функции не имеют официального многобайтового аналога, и поэтому
    такие аналоги были созданы сообществом.
    > Их можно найти здесь: https://github.com/FSX/php-utf8/tree/master/functions
    > Они не встроены в PHP, поэтому их надо использовать как пользовательские функции.

-------------------------------------------------- */
?>
