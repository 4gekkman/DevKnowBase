<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Сетевые функции, заголовки

Заголовки
> header                              | отправка http-заголовков клиенту
  > Location
  > Refresh
  > Content-Type
  > Cache-Control и Expires
  > Set-Cookie
  > ... и другие заголовки ...

Буферизация
> ob_start               | начать буферизацию вывода
> ob_end_flush()         | отправить содержимое буфера и выключить буферизацию
> ob_end_clean()         | удалить содержимое самого верхнего буфера и выключить буферизацию
> ob_get_contents()      | возвращает строку с содержимым буфера

Другие сетевые функции
> headers_sent            | закончен ни уже период отправки заголовков
> headers_list            | список переданных скриптом PHP заголовков, готовых к отправке
> apache_response_headers | Возвращает массив всех HTTP заголовков ответа Apache
> http_response_code      | (получить | установить) текущий код статуса ответа сервера
> header_remove           | удалить отправленный ранее заголовок из буфера

> dns_get_record          | возвращает массив DNS свойств характеристик хоста
> gethostbyaddr           | возвращает доменное имя по переданному IP адресу
> gethostbyname           | возвращает IPv4 адрес по имени хоста
> gethostbynamel          | возвращает массив IPv4 адресов, соответствующих имени хоста
> gethostname             | возвращает имя хоста, на котором запущен скрипт
> getprotobyname          | возвращает номер протокола по имени
> getprotobynumber        | возвращает имя протокола по номеру
> getservbyname           | возвращает номер порта, присвоенного службе или протоколу
> getservbyport           | возвращает имя службы или протокола, соответствующего указанному номеру порта
> ip2long                 | конвертирует ip вида a.b.c.d в 32-х битный 10-тичный формат
> long2ip                 | корвентирует ip из 32-х битного 10-тичного формата в стандратный вида a.b.c.d

Куки
> setcookie               | задает заголовок с куками, который будет послан клиенту
  > setrawcookie          | тоже, что setcookie, только без URL-кодирования - декодирования значения куки
> Установка куки - передача 1-го значения
  > Чтение значения из кук
  > Удаление куки
> Установка куки - передача массива
  > Чтение массива из кук.
  > Удаление массива кук



-------------------------------------------------- */




// ----------------> Заголовки <---------------- //


// void header( string $string [, bool $replace = true [, int $http_responce_code ]] )
// > отправка http-заголовков
// > функцию header можно вызывать, только если до нее клиенту еще не передавалось никаких
//   данных - html тегов, пустых строк, пробелов и т.п. Иначе будет ошибка.
// > $string              - строка, содержащая заголовок и его значение
// > $replace             - надо ли заменять предыдущий такой же заголовок
// > $http_response_code  - принудительно задает код ответа, работает, только если $string не пустая
// > Не возвращает никаких значений

// *Примечание: чтобы попробовать какой-либо заголовок в действии,
//              просто убери символы комментария // перед ним

    // 1. ##########################
    //    ### Заголовок Location ###
    //    ##########################
    //    > Указывает, откуда грузить код страницы
    //    > Пример:   header('Location: 15. Network functions, Headers, Cookies, Buffers .php');
    //    > Применяется в Технике Обнуления Последнего Запроса

    // 2. #########################
    //    ### Заголовок Refresh ###
    //    #########################
    //    > Этого заголовка нет в ОФ. спецификации. Настолько он древний.
    //
    //    Вариант работы №1:
    //    > Обнавляет страницу раз в X секунд. Пример:
    //      header("Refresh: 1");
    //
    //    Вариант работы №2:
    //    > Переадресация на указанный ресурс через X секунд. Пример:
    //      header("Refresh: 5; url=http://www.google.com");

    // 3. ##############################
    //    ### Заголовок Content-Type ###
    //    ##############################
    //    > Сообщает браузеру тип передаваемого контента (медиа-тип), на основании
    //      чего браузер запускает соответствующую программу обработки.
    //
    //    Примеры
    //    > Пример №1   - XML документ в кодировке UTF8
    //      header("Content-type: text/xml; charset=utf-8");
    //
    //    > Пример №2   - Обычный текстовый документ в кодировке UTF8
    //      header("Content-type: text/plain; charset=utf-8");
    //
    //    > Пример №3   - HTML документ в кодировке UTF8
    //      header("Content-type: text/html; charset=utf-8");
    //
    //    > Пример №4   - файл в кодировке UTF8
    //      header("Content-type: file/octet-stream; charset=utf-8");
    //      > Надо еще сказать браузеру, чтобы открыл окно загрузки, и указать имя файла:
    //        header("Content-disposition: attachment; filename=\"text.txt\"");
    //
    //    > Пример №5   - PDF файл в кодировке UTF8
    //      header("Content-type: application/pdf; charset=utf-8");
    //      > Надо еще сказать браузеру, чтобы открыл окно загрузки, и указать имя файла:
    //        header("Content-disposition: attachment; filename=\"text.pdf\"");

    // 4. #########################################
    //    ### Заголовки Cache-Control и Expires ###
    //    #########################################
    //
    //    > Запретить кэширование
    //      header("Cache-Control: no-store, no-cache, must-revalidate");
    //
    //    > Разрешить кэширование (разрешено по умолчанию, но все же) - типа Кэшируй Кэшируй
    //      header("Cache-Control: public");
    //      header("Expires: ".date("r", time()+3600*24*30));   // Будет актуально 1 месяц
    //
    //    > Указать дату, до которой страница будет считаться актуальной
    //      header("Expires: ".date("r"));

    // 5. ############################
    //    ### Заголовок Set-Cookie ###
    //    ############################
    //
    //    > Куки можно установить, послав заголовок:
    //      header("Set-Cookie: name=John; expires=Wed, 19 Sep 02 14:39:58 GMT");




// ----------------> Буферизация <---------------- //
// > Зачем нужна буферизация?
//   > Чтобы собрать вывод во внутренний буфер, не выводя эту информацию во вне,
//     а потом разом (в конце) вывести все это.
// > Callback функция будет запущена независимо от того, чем закончится буферизация.


    // пользовательская callback функция, обрабатывающая текст в буфере
    function sanitize_output($buffer)
    {
        // UTF8 аналог стандартной функции str_replace
        function mb_replace($search, $replace, $subject, &$count=0) {
            if (!is_array($search) && is_array($replace)) {
                return false;
            }
            if (is_array($subject)) {
                // call mb_replace for each single string in $subject
                foreach ($subject as &$string) {
                    $string = &mb_replace($search, $replace, $string, $c);
                    $count += $c;
                }
            } elseif (is_array($search)) {
                if (!is_array($replace)) {
                    foreach ($search as &$string) {
                        $subject = mb_replace($string, $replace, $subject, $c);
                        $count += $c;
                    }
                } else {
                    $n = max(count($search), count($replace));
                    while ($n--) {
                        $subject = mb_replace(current($search), current($replace), $subject, $c);
                        $count += $c;
                        next($search);
                        next($replace);
                    }
                }
            } else {
                $parts = mb_split(preg_quote($search), $subject);
                $count = count($parts)-1;
                $subject = implode($replace, $parts);
            }
            return $subject;
        }

        // заменить в выводе все "бутерброд" на "шаурма"
        $r = mb_replace("бутерброд", "шаурму", $buffer);
        return $r;
    }

    // Включить буферизацию
    ob_start("sanitize_output");
    ?>
    <!-- Сам, собственно, вывод -->
    <html>
    <body>
    <p>
        Вчера я сделал бутерброд с ветчиной, капустой, помидорами, луком и майонезом.
        Все это завернуто в лаваш.
    </p>
    </body>
    </html>
    <?PHP
    // Вывести все накопившееся в буфере, и выключить буферизацию
    ob_end_flush();  // Вчера я сделал шаурму с ветчиной, капустой, помидорами, луком и майонезом.
                     // Все это завернуто в лаваш.

    // Вывести содержимое буфера
    // > Примечание*: после выключения буферизации функцией ob_end_flush(),
    //   содержимое буфера не удалилось и остается доступным
    echo ob_get_contents();   // Вчера я сделал шаурму с ветчиной, капустой, помидорами, луком и майонезом.
                              // Все это завернуто в лаваш.

    // Удалить содержимое буфера
    // > Если запустить ob_end_clean без запуска буферизации функцией ob_start,
    //   и при этом директива output_buffering в php.ini не равна off, то
    //   текущий буфер скрипта будет опустошен, и весь вывод, который был в скрипте
    //   до этого места будет стерт из буфера, и, соответственн, не будет выведен.
    ob_start();        // сначала надо запустить буферизацию
    ob_end_clean();    // а потом остановить и удалить содержимое буфера

    ob_get_contents(); // ... содержимое буфера теперь пусто.


// ----------------> Другие сетевые функции <---------------- //

// bool headers_sent( [string &$file [, int &$line ]] )
// > Закончен ни уже период отправки заголовков. Это важно знать, ведь если да,
//   то отправлять еще заголовки уже не получится - их можно отправлять только
//   до начала отправки контента.
//   > Используя эту функцию, можно предотвратить ошибки, с этим связанные.
// > Если опциональные параметры file и line установлены, то функция
//   headers_sent() поместить имя текущего скрипта PHP в file; и номер строки,
//   с которой начинается вывод, в переменную line.
// > !!! Внимание, если в php.ini директива output_buffering не равна OFF,
//   то весь вывод буферизируется, и поэтому headers_sent() всегда будет = false
    $r = headers_sent();                 // false

// array headers_list( void )
// > список переданных скриптом PHP заголовков, готовых к отправке
    $arr = headers_list();  // массив передаваемых клиенту заголовков

// array apache_response_headers( void )
// > Возвращает массив всех HTTP заголовков ответа Apache
// > !!! Внимание, если в php.ini директива output_buffering не равна OFF,
//   то эта функция работать корректно не будет
    $arr = apache_response_headers();

// int http_response_code( [int $response_code] )
// > (получить | задать) текущий код статуса
//   > Получить текущий код статуса          - если параметр не задан
//   > Задать код статуса ответа сервера     - если параметр задан (код задается в параметре)
    http_response_code(404);     // установить код 404 (Not Found)
    $r = http_response_code();   // получить код: 404

    http_response_code(200);     // установить код 200 (OK)
    $r = http_response_code();   // получить код: 404

// void header_remove([ string $name ])
// > удалить отправленный ранее заголовок из буфера
    header("MyHeaderName: MyHeaderValue");  // послать заголовок
    header_remove('MyHeaderName');          // удалить указанный заголовок

// array dns_get_record( string $hostname [, int $type = DNS_ANY [, array &$authns [, array &$addtl ]]] )
// > возвращает массив DNS свойств характеристик хоста
// > $hostname - имя хоста, например 'www.ya.ru', а почта пишется в формате: ivan.gmail.com (а не ivan@gmail.com)
// > $type     - можно сузить круг искомых DNS записей; DNS_ANY - значит искать все.
// > Описание функции и значений в массиве: http://www.php.net/manual/ru/function.dns-get-record.php
    $arr = dns_get_record('ya.ru');
    /*
    echo "<br><pre>";
    print_r($arr);         // результат
    echo "<br></pre>";
    */

// string gethostbyaddr( string $ip_address )
// > возвращает доменное имя по переданному IP адресу
    $r = gethostbyaddr('87.250.250.3');   // www.yandex.ru

// string gethostbyname( string $hostname )
// > возвращает IPv4 адрес по имени хоста
    $r = gethostbyname('www.ya.ru');   // 87.250.250.203

// gethostbynamel
// > возвращает массив IPv4 адресов, соответствующих имени хоста
$arr = gethostbynamel('www.ya.ru');
    /*
    echo "<br><pre>";
    print_r($arr);        // результат из нескольких IPv4 адресов
    echo "<br></pre>";
    */

// string gethostname( void )
// > возвращает имя хоста, на котором запущен скрипт
// !!! Почему то возвращает каракули
    $r = gethostname();   // каракули ???

// int getprotobyname( string $name )
// > возвращает номер протокола по имени
    $arrNames=array("ip","icmp","ggp","tcp",
        "egp","pup","udp","hmp","xns-idp",
        "rdp","rvd" );
    //Reads the names of protocols into an array..
    for($i=0;$i<11;$i++) {
       $arrNums[] = getprotobyname($arrNames[$i]);
    }
    /*
    echo "<br><pre>";
    print_r($arrNums);        // результат - номера указанных выше протоколов
    echo "<br></pre>";
    */

// string getprotobynumber( int $number)
// > возвращает имя протокола по номеру
    unset($arrNames);
    for($i=0; $i<255; $i++) {
        if(getprotobynumber($i))
           $arrNames[] = getprotobynumber($i);
    }
    /*
    echo "<br><pre>";
    print_r($arrNames);        // результат - имена найденных по номеру протоколов
    echo "<br></pre>";
    */

// int getservbyname( string $service, string $protocol)
// > возвращает номер порта, присвоенного службе или протоколу
// > $service - имя службы; $protocol = ('tcp' | 'udp') - !! в нижнем регистре
    $services = array('http', 'ftp', 'ssh', 'telnet', 'imap',
        'smtp', 'nicname', 'gopher', 'finger', 'pop3', 'www');
    foreach ($services as $service) {
        $portNums[$service] = getservbyname($service, 'tcp');
    }
    /*
    echo "<br><pre>";
    print_r($portNums);        // результат - номера портов для указанных выше служб и протоколов
    echo "<br></pre>";
    */

// string getservbyport( int $port, string $protocol )
// > возвращает имя службы или протокола, соответствующего указанному номеру порта
// > $port - номер порта; $protocol = ('tcp' | 'udp') - !! в нижнем регистре

    // Просканируем порты от 0 до 1000
    for($i=0; $i<=1000; $i++) {
        if(getservbyport($i,'tcp'))
            $portNames[$i] = getservbyport($i,'tcp');
    }
    /*
    echo "<br><pre>";
    print_r($portNums);        // результат - найденные номера портов и имена служб и протоколов
    echo "<br></pre>";
    */

    // int ip2long( string $ip_address )
    // > конвертирует ip вида a.b.c.d в 32-х битный 10-тичный формат, и возвращает его в типе int
    $ip = gethostbyname('www.ya.ru');
    $r = 'Следующие URL эквивалинтны: ';
    $r .= 'www.ya.ru, ' . $ip . ', и ' . ip2long($ip);   // Следующие URL эквивалинтны: www.ya.ru, 93.158.134.3, и 1570670083

    // string long2ip( string $proper_address)
    // > корвентирует ip из 32-х битного 10-тичного формата в стандратный вида a.b.c.d
        $r = long2ip('1570670083');  // 93.158.134.3







// ----------------> Куки <---------------- //


// bool setcookie( string $name [, string $value [, int $expire = 0 [, string $path [,
//                 string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] )
// > задает заголовок с куками, который будет послан клиенту
// > если надо пропустить любой аргумент - используй ""; кроме expire, для него: 0
// > вернет true, если функция успешно отработала, иначе false.
// > Имеет аналог: функцию setrawcookie():
//   > тоже, что setcookie, только без URL-кодирования - декодирования значения куки
// > Параметры:
    // > $name: имя куки;
    // > $value: значение куки;
    // > $exprire: UNIX-время, при наступлении которого срок действия куки истекает.
    //   > Например: time()+60*60 (кука на 1 час); time()+60*60*24 (кука на 1 день); time()+60*60*24*30 (кука на 1 месяц).
    //   > Хранится же значение expire не в виде UNIX-метки, а в формате: 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'
    // > $path: путь к папке на сервере, из которой будет доступна эта кука
    //   > По умолчанию устанавливается папка, в которой лежит скрипт, из которой кука задавалась
    //   > Если задать '/', куки будут доступны во всем домене $domain
    //   > Если задать '/mySite/folder1', куки будут доступны только из директории /mySite/folder1 и ее поддиректорий
    // > $domain: домен, которому доступны куки.
    //   > Лучше указывать домент без www:  'ya.ru', потому что он включает доступ и
    //     всем поддоменам высших уровней, в т.ч. 'www.ya.ru', но не наоборот.
    // > $secure: указывает на то, что куки от клиента будут передаваться, только если
    //   установлено защищенное HTTPS соединение. Возможные значения: (TRUE | FALSE). По умолчанию: false.
    // > $httponly: если TRUE, то куки будут доступны только через HTTP протокол
    //   (а через, например, JavaScript - не доступны). Введено как мера от XSS атак и кражи кук.
    //   > возможные значения: (TRUE | FALSE);  по умолчанию: false;


// Операции с куками

    // Установка куки - передача 1-го значения
        $value = 'Значение куки';
        setcookie(
            'CookName',      // имя куки
            $value,      // значение куки
            time()+60*60*24,      // UNIX-время, при наступлении которого кука истечет
            '/',      // директория на сервере, скриптам из которой будет доступна кука
            '',      // (пропускаем, ставя '') домен, с которого будет доступна кука
            FALSE,      // будет ли кука передаваться от клиента на сервер, только если установлено HTTPS соединение
            TRUE       // будет ли кука передаваться только по HTTP протоколу
        );

        // Чтение значения из куки
            if(!empty($_COOKIE['CookName']))
                $r = $_COOKIE['CookName'];
            echo 'Значение куки по имени CookName = ' . $r;

        // Удаление куки
            if(!empty($_COOKIE['CookName']))
                setcookie('CookName', '', time()-3600);

    // Установка куки - передача массива
        $arr = [0=>'BMW', 1=>'Mercedes', 2=>'Audi'];
        for($i=0; $i<=2; $i++) {
            setcookie('cookArray['.$i.']',$arr[$i]);
        }

        // Чтение массива из кук.
            foreach ($_COOKIE['cookArray'] as $k => $v) {
                $arrRes[$k] = $v;
            }
            /*
            echo "<br><pre>";
            print_r($arrRes);    // посмотреть массив, полученный из кук клиента
            echo "<br></pre>";
            */

        // Удаление массива кук
            foreach ($_COOKIE['cookArray'] as $k => $v) {
                setcookie('cookArray['.$k.']', '', time()-3600);
            }





    /* --------------------------------------------------
    ---------------- И Н Ф О Р М А Ц И Я ----------------

    Заголовки
    > Заголовки по протоколу HTTP 1.1 должны быть отправлены полносью до отправки
      контента. Поэтому функция header(), отправляющая заголовки, может быть вызвана
      только до отправки какого-либо контента - html тегов, пробелов и так далее.
      Иначе будет ошибка.
      > Примечание 1: всякие внутренние вычисления могут проводиться, например $a = 10;
        Но если на экран будет хоть что-то выведено, даже пробел, то с этого момента
        заголовки отправлять уже нельзя.
      > Примечание 2: если в php.ini включена буферизация вывода этого PHP скрипта (см. ниже),
        то вывод контента не начнется до конца скрипта (если вывод не привысит указанных размеров),
        а значит, что послать header можно в любом месте скрипта.

    > Ссылки на справочные ресурсы о HTTP загловках:
      > Мой конспект-методичка по серверному программированию
        > Принципы работы заголовков.
      > http://www.faqs.org/rfcs/rfc2616.html
        > Официальная спецификация протокола HTTP 1.1 RFC 2616 (хрен разберешься)
      > ru.wikipedia.org/wiki/Заголовки_HTTP
        > Списки заголовков, методов запроса и кодов ошибок. В основном, без подробного описания.
      > http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
        > Лучшее подробное описание всех заголовков

    > Буферизация вывода PHP скрипта - это механизм, позволяющий регулировать, какое
      количество данных (кроме заголовков и кук) PHP должен придержать
      перед тем, как отправить клиенту.
      > Параметр output_buffering в php.ini:
      > Возможные значения:
        > off        - буферизация отключена.
        > 4096       - размер буфера в байтах (может быть и другое число)

    > Куки
      > Куки это связка Ключ - Значение, которую можно сохранить на указанное
        время на компе клиента. А когда он снова придет, достать оттуда.
        > Кука посылается, как HTTP заголовок, следовательно, должна быть послана,
          как и другие HTTP заголовки, до вывода любого контента.
      > После передачи клиенту cookie станут доступны:
        > Через массивы $_COOKIE ($HTTP_COOKIE_VARS), $_REQUEST
        > При следующей загрузке страницы.
      > $value куки будет сохранено на компьютере клиента
        > Не записывай туда секретные данные
        > После записи доступ к значению с именем, например, CookieName
          можно будет получить так: $_COOKIE['cookiename']
        > Перед отправкой клиенту функцией setcookie, значение $value подвергается
          автоматическому URL-кодированию. А при получении обратно - автоматическому
          декодированию.
          > Если это кодирование-декодирование не нужно, то вместо функции setcookie()
            используй функцию setrawcookie().
      > Чтобы удалить куку с именем Х нужно:
        > Отправить куку с именем Х, $value = '', $expire = time() - 3600;  (временем в прошлом)
          > Это запустит механизм удаления куки в браузере
      > Кукам не стоит задавать значени типа bool, потому что если задать значение FALSE -
        то это приведет к удалению этой куки. Вместо bool значений надо использовать 0 и 1 типа int.
      > !!! Безопасность: не стоит с куками использовать функции (un) serialize(), так как
        злоумышленник может изменить значение куки как ему захочется, и прописать туда любой
        код, так что при десериализации тебя, дружок, может ждать сюрприз.

    -------------------------------------------------- */
?>




































