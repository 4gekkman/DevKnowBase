<?php
/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
Ratchet






-------------------------------------------------- */













/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальный сайт Ratchet:
        http://socketo.me/

	> Пример работы с WebSocket и Ratchet
				http://habrahabr.ru/post/198954/

  > Статья на habr о реализации паттерна PubSub:
        http://habrahabr.ru/post/201658/

  > Делаем вебсокеты на PHP с нуля (ч 1/2)
        http://habrahabr.ru/company/ifree/blog/209864/

  > Делаем вебсокеты на PHP с нуля (ч 2/2)
        http://habrahabr.ru/company/ifree/blog/210228/


*****************************************************
Оглавление:

  > Введение в WebSockets, или зачем нужен Ratchet
    > Общая информация о том, как работает WEB через HTTP
    > Общая информация о том, как работает WEB через WebSockets
    > О поддержке технологии WebSockets на клиентской/серверной сторонах

  > Как выглядит процесс клиент/серверной коммуникации через WebSockets?
    > Мало живущие PHP-скрипты (WEB через HTTP)
    > Долго живущие PHP-скрипты (WEB через WebSockets)
    > Иллюстрация

  > Стандарт автозагрузки классов PSR-0 в PHP

  > Архитектура Ratchet: как всё устроено?
    > Ratchet состоит из компонентов
    > Архитектура "бутерброд"
    > Как событие проходит через "бутерброд"
    > Об объекте-соединении
      > Что такое объект-соединение
      > Наполнение объекта-соединения доп.свойствами
      > Как посмотреть текущее содержимое объекта-соединения?
      > Какие методы есть у объекта-соединения?
      > Зачем нужно хранить объекты-соединения?
      > Где хранить объекты-соединения?

  > Компоненты Ratchet: обзор и примеры
    > Обзор компонентов Ratchet
      > Подробнее об IoServer
      > Подробнее о WsServer
      > Подробнее о HttpServer
      > Подробнее о Router
      > Подробнее о SessionProvider
      > Подробнее о WampServer
      > Подробнее об OriginCheck
      > Подробнее о FlashPolicy
      > Подробнее о IpBlackList


  > Установка Ratchet с помощью Composer
    > Общая информация
    > Условия установки
    > Данные для вставки в соотв. параметры composer.json

  > Создание тестового приложения: ЧАТ в командной строке
  > Создание тестового приложения: ЧАТ в браузере


*****************************************************



> Введение в WebSockets, или зачем нужен Ratchet

  > Общая информация о том, как работает WEB через HTTP
    > Не имеет состояния. Ты делаешь запрос по адресу http://google.com, что при этом
      происходит? Твой браузер открывает сокет с адресом google.com и портом 80,
      отсылает HTTP-заголовки на сервер (Apache/Nginx), который буферизует это
      сообщение и отсылает серверному приложению (например, PHP). Серверное приложение
      решает, что делать с этим запросом, извлекает данные, генерирует HTML
      и отсылает это обратно на сервер (Apache/Nginx). Последний затем добавляет
      соответствующие HTTP-заголовки к телу запроса, и отсылает всё это обратно
      браузеру, который закрывает соединение.
    > Вебсайты поддерживают знание о том, кто ты такой, с помощью кук. Куки
      посылаются туда/сюда с каждым запросом, чтобы напоминать серверу: "эй,
      это я, тот же парень что в прошлый раз". Это, среди всего прочего, заставляет
      нести накладные расходы, а также может создавать уязвимости для хакеров.
    > Все и каждая коммуникация:
      - Инициируется клиентом
      - Не имеет состояния
      - Изолирована от других коммуникаций

  > Общая информация о том, как работает WEB через WebSockets
    > WebSockets - это двунаправленное, полнодуплексное, постоянное соединение
      браузера с сервером.
    > Если WebSocket-соединение установлено, оно остаётся открытым до тех пор,
      пока клиент или сервер не решат его закрыть.
    > Пока соединение открыто, клиент и сервер могут слать друг-другу сообщения
      в любых количествах и в любое время. Это делает программирование для веб
      полностью event driven, а не как раньше - когда взаимодействие мог инициировать
      только клиент.
    > Имеет состояние.
    > В любой момент, одно запущенное серверное приложение знает обо всех открытых
      соединениях, что позволяет ему взаимодействовать с любым количеством открытых
      соединений в любое время.

  > О поддержке технологии WebSockets на клиентской/серверной сторонах
    > На клиентской стороне
      > Все свежие версии основных браузеров имеют встроенную поддержку WebSockets:
        - Chrome
        - Safari
        - Firefox
        - Opera
        - IE>=10
    > На серверной стороне
      > Пока встроенной поддержки WebSockets на серверной стороне нет.
      > Поэтому и появился Ratchet:
        - Компоненты Ratchet могут составить полноценный сервер.
      > Чтобы обеспечить поддержку WebSockets на серверной стороне, ты
        соединяешь следующие компоненты:
        - Ratchet I/O Server Component
        - Ratchet WebSocket protocol interpreter
        - И свою бизнес-логику


> Как выглядит процесс клиент/серверной коммуникации через WebSockets?

  > Мало живущие PHP-скрипты (WEB через HTTP)
    > Ниже описана испытанная и правдивая природа работы WEB через
      протокол HTTP. Именно так всё и работало последние пару десятилетий.
    > Обычно пишут мало живущие PHP-скрипты. Каждый документ, открытый на
      клиентской стороне, запускает новый PHP-скрипт на серверной стороне,
      загружает ресурсы (такие как соединение с базой данных), выполняет
      твой код, закрывает ресурсы, шлёт выходные данные (HTML) назад
      клиенту и закрывает соединение.
    > При таком раскладе PHP-скрипты живут достаточно малое время.
      > В PHP>=5.3 присутствует сборщик мусора, который позволяет PHP-скриптам
        бороться с утечками памяти, и функционировать намног дольше чем до того,
        как появился этот самый сборщик мусора.

  > Долго живущие PHP-скрипты (WEB через WebSockets)
    > WEB через WebSockets работает несколько иначе:
      - На сервере выполняется только 1 скрипт, даже если клиент открыл
        много документов в браузере.
      - Все соединение остаются открытыми, пока их не закроют.
    > Некоторые вещи при написании PHP-скриптов в таких условиях придётся
      делать иначе. Например, нельзя использовать глобальные переменные,
      поскольку контекст запущенного процесса не ограничен одним соединением,
      как при работе с HTTP, а может быть связан со многими постоянными соединениями.
    > При таком раскладе средняя продолжительность жизни PHP-скриптов
      будет гораздо выше, чем при работе через HTTP, поскольку соединение
      остаётся открытым, и всё это время PHP-скрипт продолжает работать.

  > Иллюстрация
    > Иллюстрацию этого процесса можно посмотреть на картинке:
        "Процесс работы Ratchet.png"


> Стандарт автозагрузки классов PSR-0 в PHP
  > Подробнее об автозагрузке в PHP вообще, а также о 4-х архитектурах
    автозагрузки в Composer (в т.ч. о PSR-0), можно почитать в учебном
    файле composer.php.


> Архитектура Ratchet: как всё устроено?

  > Ratchet состоит из компонентов
    > Каждый компонент реализует свою версию интерфейса ComponentInterface.
    > Объект каждой из реализаций создаётся при старте скрипта...
    > ... и сразу после создания начинает "слушать" события.

  > Архитектура "бутерброд"
    > Архитектура Ratchet напоминает бутерброд:
      - Верхняя булка - это событие, запущенное клиентом (JavaScript)
      - Нижняя булка - это серверное приложение пользователя (PHP)
      - Между булками можно положить по вкусу слои из компонетов Ratchet.
    > Архитектура "бутерброд" позволяет разработчикам добавлять и убирать
      из "бутерброда" те или иные компоненты Ratchet, создавая необходимую
      функциональность.

  > Как событие проходит через "бутерброд"
    > Событие инициируется клиентом на том конце сокета (JavaScript)
    > Пришедшее на сервер событие становится объектом-соединением.
    > Этот объект представляет собой конкретное установленное соединение
      клиент-сервер на вебсокетах, и используется сервером для взаимодействия
      с клиентом.
    > Объект-соединение проходит последовательно через весь бутерброд
      компонентов Ratchet, сверху-вниз, от верхней булки к нижней.
    > Каждый слой навешивает на объект-событие всё новые свойства,
      в зависимости от того, для чего конкретный слой предназначен.

  > Об объекте-соединении

    > Что такое объект-соединение
      > Объект-соединение - это PHP-объект, который представляет соединение
        клиента с сервером.
      > У объекта есть свойства, которые содержат информацию о клиенте.

    > Наполнение объекта-соединения доп.свойствами
      > Чем через большее кол-во компонентов Ratchet пройдёт объект-соединение
        (см. "бутерброд"), тем больше дополнительных свойств он получит.
        > Например, ты можешь использовать или не использовать компонент
          SessionProvider.
          - Если ты выберешь использовать, то объект-соединение получит
            объект типа Synfony 2 Session. И к нему можно будет обращаться,
            например, вот так:

              $hello = $conn->Sesson->get('hello');

          - Если же ты выберешь не использовать, то у объекта-соединение $conn
            не будет свойства Session.

    > Как посмотреть текущее содержимое объекта-соединения?
      > Воспользоваться функцией var_dump.

    > Какие методы есть у объекта-соединения?
      > Объект-соединение реализует интерфейс ConnectionInterface:
            http://socketo.me/api/class-Ratchet.ConnectionInterface.html
      > Таким образом в начале пути у него есть 2 метода:
        - $Conn->Send(string $data)   | послать клиенту строку $data
        - $Conn->Close()              | закрыть соединение
      > Но по мере прохождения через "бутерброд" компонентов Ratchet могут
        появляться новые методы. Какие именно? См. документацию по
        каждому из компонентов Ratchet: в этом учебном файле или по ссылке
        на официальном сайте в разделе Components:
           http://socketo.me/api/class-Ratchet.ConnectionInterface.html

    > Зачем нужно хранить объекты-соединения?
      > Когда соединение установлена, взаимодействие между клиентом и
        сервером может быть двусторонним:
        - Клиент может слать серверу сообщения
        - Сервер может слать клиенту сообщения
      > В первом случае, когда событие вызывает клиент (JS), то
        объект-событие проходит через "бутерброд" компонентов Ratchet
        на наш сервер (PHP). И так каждый раз. Нет необходимости сохранять
        объект-соединение где-либо.
      > Во втором случае без сохранённого где-нибудь объекта-соединения
        послать сообщение клиенту (в соединение) не получится. Вот почему
        надо сохранять где-нибудь все объекты-соединения.

    > Где хранить объекты-соединения?
      > 2 наиболее распространённых варианта:
        - В массиве.
        - В SplObjectStorage - спец.классе для хранения объектов.
      > Подробнее о SplObjectStorage
        > Ссылка на описание на php.net:
            http://socketo.me/api/class-Ratchet.ConnectionInterface.html
        > Пример использования:

              <?php
              use Ratchet\Resource\ConnectionInterface;

              class MyApp {
                  // Создать св-во для хранения объектов-соединений
                  protected $connections;

                  public function __construct() {
                      // Инициировать св-во объектом типа SplObjectStorage
                      $this->connections = new \SplObjectStorage;
                  }

                  public function onOpen(ConnectionInterface $conn) {
                      // Добавить в хранилище новый объект-соединение
                      $this->connections->attach($conn);
                  }

                  public function onClose(ConnectionInterface $conn) {
                      // Удалить из хранилища указанный объект-соединение
                      $this->connections->detach($conn);
                  }
              }



> Компоненты Ratchet: обзор и примеры

  > Обзор компонентов Ratchet:
    - IoServer        | (обязателен) Это ядро Ratchet-приложения. Управляет:
                        - Получением новых соединений, инициированных клиентом.
                        - Чтением сообщений из этих соединений, записью сообщений в них.
                        - Закрытием соединений.
                        - Обработкой ошибок из твоего приложения.
    - WsServer        | Позволяет серверу коммуницировать с веб-браузерами, которые
                        поддерживают W3C WebSocket API.
                        - Совместим с WebSocket-протоколами: RFC6455, HyBi, Hixie76
    - HttpServer      | Отвечает за парсинг входящих HTTP-запросов.
                        - Не рекомендуется использовать в кач-ве HTTP-сервера
                        - Его предназначение - буферизовать данные до тех пор,
                          пока не будут переданы все HTTP-заголовки, и передавать их дальше.
                        - Его предназначение - обновление WebSocket-запросов,
                          т.к. для установки WebSocket-соединения обмен данными
                          сначала ведётся по протоколу HTTP.
    - Router          | Позволяет сделать так, что несколько WebSocket-приложений
                        могут быть запущены на одном сервере, разделённые конечными HTTP-точками
                        - Здесь используется Symfony Routing Component
    - SessionProvider | Добавляет объект Syfony2 Session к каждому объекту-соединению.
                        - Даёт read-only доступ к сессионным данным на сайте.
    - WampServer      | Позволяет использовать WAMP - высокоуровневую надстройку над WebSocket protocol
                        - Подробнее о WAMP здесь: http://wamp.ws/spec/
    - OriginCheck     | Помогает защитить сервак от нежелательных сайтов, которые
                        пытаются подключить пользователей к нашему серваку.
                        - При создании WebSocket-соединения, браузер клиента посылает
                          серваку в заголовке адрес сайта, на котором находится клиент.
                          OriginCheck авто-ки закроет соединение, если браузер в заголовке
                          пришлёт не ожидаемый адрес (адреса).
    - FlashPolicy     | Позволяет браузерам без встроенной поддержки WebSockets подключиться
                        к твоему Ratchet-приложению, используя Flash Sockets.
    - IpBlackList     | Позволяет указать список IP, соединения от которых не принимать.
                        - Надо ставить вплотную к IoServer в "бутерброде", чтобы нежелательные
                          подключения отсекались сразу.
    - MessageLogger   | Позволяет вести лог сообщений
                        - Код компонента здесь:
                            https://github.com/cboden/Ratchet-examples/blob/master/src/Ratchet/Cookbook/MessageLogger.php


  /  Подробнее об IoServer  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание
      > Обязателен для Ratchet-приложения, является его ядром.
      > Выполняет следующие функции:
        - Получением новых соединений, инициированных клиентом.
        - Чтением сообщений из этих соединений, записью сообщений в них.
        - Закрытием соединений.
        - Обработкой ошибок из твоего приложения.

    > Может обернуть следующие компоненты:
      # Пользовательский класс, представляющий его приложение.
        - Должен реализовывать интерфейс MessageComponentInterface.
        - С IoServer, может быть использован для telnet-клиентов или тестирования
      # WsServer
        - А WsServer необходим, чтобы браузерные клиенты могли подключиться.
          Без него, с одним IoServer, только telnet-клиенты могут подключиться к серваку.
      # FlashPolicy
      # IpBlackList

    > Может быть обёрнут следующими компонентами:
      > Обычно, никакими.
      > IoServer должен быть основой твоего Ratchet-приложения.

    > Возбуждает события:

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onMessage (ConnectionInterface $from, string $message)
        > Было отправлено сообщение.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка.

    > Методы для настройки
      # void run()
        > Переводит приложение в event loop, и начинает следить за входящими
          соединениями и передачей данных.

    > Функции (передающиеся объектам-соединениям):
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям):
      - string $remoteAddress   | IP-адрес клиента
      - int $resourceId         | Инкремент подключений, возрастающий при каждом подключении

    > Пример работы

        <?php
        // Приложение для работы в командной строке (чат)
        // - Клиенты могут подключиться только через telnet

          // Создать псевдоним
          use Ratchet\Server\IoServer;

          // Создать экземпляр IoServer
          // - В него завёрнут пользовательский класс Chat
          // - Сервер будет работать, используя порт 8080
          $server = IoServer::factory(
              new Chat(),
              8080
          );

          // Запустить сервер
          // - Теперь клиенты могут подключаться к нему через telnet
          $server->run();



  /  Подробнее о WsServer  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание
      > Обычно используется совместно с IoServer (99% случаев).
      > Позволяет серверу коммуницировать с веб-браузерами, которые
        поддерживают W3C WebSocket API. Т.Е. без WsServer Ratchet-приложение,
        у которого есть, например, только IoServer-компонент, не может
        коммуницировать с браузерами.
      > Совместим с WebSocket-протоколами: RFC6455, HyBi, Hixie76
      > Ratchet проходит успешно все не бинарные WebSocket тесты в
        Autobahn TestSuite.

    > Может обернуть следующие компоненты
      # Пользовательский класс, представляющий его приложение.
        - Должен реализовывать интерфейс MessageComponentInterface.
      # WampServer
      # SessionProvider
      # MessageLogger

    > Может быть обёрнут следующими компонентами
      # HttpServer

    > Возбуждает события

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onMessage (ConnectionInterface $from, string $message)
        > Было отправлено сообщение.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка.

    > Методы для настройки

      # void disableVersion(string $versionId)
        > Отключает указанную версию протокола WebSocket.
        > Часто отключают Hixie76, как плохую и устаревшую версию.
          Для этого надо передать $versionId = 0.

      # void setEncodingChecks(boolean #opt)
        > Вкл/Выкл проверку на UTF8.
        > Спецификация WebSockets указывает, что надо проверять входящие
          сообщения - их кодировка должна быть UTF8.
        > Но это и так делают все браузеры самостоятельно. Так что отключение
          этой повторной проверки может улучшить производительность.

    > Функции (передающиеся объектам-соединениям)
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям)
      - Guzzle\Http\Message\RequestInterface $request
        > A Guzzle Request object, содержащий всю информацию об изначальном HTTP-соединении.

    > Пример работы:

        <?php
        // Your shell script

          // Создать псевдонимы
          use Ratchet\WebSocket\WsServer;
          use Ratchet\Http\HttpServer;
          use Ratchet\Server\IoServer;

          // Создать новый экземпляр WsServer
          $ws = new WsServer(new MyChat);
          $ws->disableVersion(0);         // old, bad, protocol version

          // Завернуть ws в IoServer и запустить его
          $server = IoServer::factory(new HttpServer($ws));
          $server->run();


  /  Подробнее о HttpServer  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание
      > Этот компонент отвечает за парсинг входящих HTML-запросов.
      > Его задача буферизовать даннуе до тех пор, пока HTTP-запрос
        не будет получен полностью, и передать его дальше.
      > HttpServer не рекомендуется использовать в качестве обычного
        HTTP-сервера, потому что он для этого не предназначен.
      > Он предназначен для установки WebSocket-соединений, т.к. для
        этой самой установки клиент с сервером сначала должны связаться по HTTP.

    > Может обернуть следующие компоненты
      > WsServer
      > Router

    > Может быть обёрнут следующими компонентами
      > IoServer
      > IpBlackList

    > Возбуждает события

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onMessage (ConnectionInterface $from, string $message)
        > Было отправлено сообщение.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка.

    > Методы для настройки
      - Нет

    > Функции (передающиеся объектам-соединениям)
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям)
      - Нет

    > Пример работы

        <?php

          // Создать псевдонимы
          use Ratchet\Http\HttpServer;
          use Ratchet\Server\IoServer;

          // Создать экземпляр HttpServer
          $http = new HttpServer(new MyWebPage);

          // Завернуть $http в IoServer, создать его экземпляр и запустить
          $server = IoServer::factory($http);
          $server->run();


  /  Подробнее о Router  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание
      > Компонент Router состоит из частей компонента Symfony Routing.
      > Компонент Router позволяет одновременно множеству WebSocket-приложений
        быть запущенными на одном и том же сервере.
      > Компонент Router пославтяется внутри класса App, и включает
        UrlMatcher, чтобы сделать твою жизнь легче.

    > Может обернуть следующие компоненты
      - WsServer

    > Может быть обёрнут следующими компонентами
      - HttpServer

    > Возбуждает события

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onMessage (ConnectionInterface $from, string $message)
        > Было отправлено сообщение.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка.

    > Свойства для настройки
      $allowedOrigins   | массив строк - разрешенных URL.

    > Функции (передающиеся объектам-соединениям)
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям)
      - Нет

    > Пример работы
      > Рекомендуется использовать Router через App class, где вся сборка
        уже проведена за вас.


  /  Подробнее о SessionProvider  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание
      > SessionProvider добавляет каждому входящему объекту-соединение
        объект Symfony2 Session.
      > Последний даёт read-only доступ к сессионным данным на сайте.
      > SessionProvider не будет работать ни с какими стандартными
        обработчиками сессии. А будет только с одним из следующих:
        - MemcacheSessionHandler
        - MemcachedSessionHandler
        - PdoSessionHandler
        - (в разработке) RedisSessionHandler
      > Чтобы получить доступ к сессионным данным в Ratchet, надо, естественно,
        использовать тот же обработчик для сессий, что и в Ratchet.
      > Сессии работают одинаково что через WebSockets-сервер, что через
        обычный сервак. Так что они оба должны иметь доступ к сессионным кукам.
      > Чтобы сессионные данные могли быть расшарены между WebSockets-серваком
        и основным сайтом, они оба должны находитсья на одном и том же домене.
        > Для этого надо захостить их на одном домене, но с разными портами.
          Например, основной сайт на стандартном 80-м, а WebSockets сервак на 8080.
        > Или же можно захостить WebSocket-сервер на поддомене, например:
            websocket.mydomain.com:80
          Но тогда надо убедиться, что в php.ini прописана такая директива:
            session.cookie_domain = ".mydomain.com"

    > Может обернуть следующие компоненты
      # Пользовательский класс, представляющий его приложение.
        - Должен реализовывать интерфейс MessageComponentInterface.
      # WampServer

    > Может быть обёрнут следующими компонентами
      # WsServer

    > Возбуждает события

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onMessage (ConnectionInterface $from, string $message)
        > Было отправлено сообщение.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка.

    > Методы для настройки
      > Нет.

    > Функции (передающиеся объектам-соединениям)
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям)
      # Symfony\Component\HttpFoundation\Session $Session
        > Объект типа Symfony2 Session.

    > Пример работы:

      Файл server.php
      -----
        <?php

          // Создать псевдонимы
          use Ratchet\Session\SessionProvider;
          use Symfony\Component\HttpFoundation\Session\Storage\Handler;
          use Ratchet\App;

          // Создать новый объект Memcache
          $memcache = new Memcache;
          $memcache->connect('localhost', 11211);

          // Создать новый объект SessionProvider, завернуть в него $memcache
          $session = new SessionProvider(
              new MyApp,
              new Handler\MemcacheSessionHandler($memcache)
          );

          // Создать новый объект App
          $server = new App('localhost');

          // Зобавить в роут sessDemo и $session, и запустить
          $server->route('/sessDemo', $session);
          $server->run();

      Где-то внутри класса MyApp...
      -----
        <?php
            // Inside your MyApp class
            public function onOpen($conn) {
                $conn->send('Hello ' . $conn->Session->get('name'));
            }


  /  Подробнее о WampServer  /
  ===================================

    > Оглавление:
      - Общая информация
      - Реализация клиентской части
      - Топики
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Общая информация:

      > Как расшифровывается WAMP?
        > WAMP - WebSocket Application Messaging Protocol.
        > Официальный сайт WAMP со спецификациями и появнениями:
              http://wamp.ws/spec/

      > Какие недостатки у "голого" WebSocket?
        > Протокол WebSocket уже встроен во все современные браузеры.
        > Он позволяет осуществлять быстрый обмен текстовыми сообщениями
          между клиентом и сервером, в обоих направлениях.
        > Однако, WebSocket довольно низкоуровненен, и позволяет лишь обмениваться
          обычным текстом.
        > Между тем, современные веб-приложения часто требуют наличие высокоуровневых
          средств обмена сообщений, включающих такие паттерны, как:
          - Publish and Subscribe (PubSub)
          - Remote Procedure Calls (RPC)

      > Что такое PubSub?
        > Publish and Subscribe.
        > Это такой шаблон организации обмена сообщениями.
        > В нём принимают участие 3 стороны:
          - Публикатор
          - Подписчик
          - Брокер
        > Публикатор публикует топик (канал). Например:
          - Комментарии
          - Новости
          - Личные сообщения
          - и т.д.
        > Подписчик получает сообщение, если в тех топиках, на которые
          он подписан, что-либо меняется.
        > Брокер сидит между публикатором и подписчиком, и отвечает за доставку
          сообщений из топиков публикаторов подписчикам, которые на них подписаны.
          Т.К. у брокера есть весь список подписчиков, он пожет посылать им
          и свои собственные сообщения.

      > Что такое RPC?
        > Remote Procedure Calls (вызов процедуры удалённо)
        > Это такой шаблон организации обмена сообщениями.
        > В нём принимают участие 2 стороны:
          - Клиент.
          - Сервер.
        > Сервер обеспечивает методы или процедуру для вызова в хорошо
          известной конечной точке.
        > Клиент вызывает удаленные методы или процедуры, передавая этому
          методу или процедуре в их конечной точки какие-нибудь аргументы
          при вызове.
        > Сервер выполняет метод или процедуру, используя поддерживаемые аргументы,
          и возвращает результат вызова клиенту.

      > Как WAMP решает эти проблемы?
        > Технически, WAMP - официально зарегистрированный субпротокол
          протокола WebSockets. Т.Е. WAMP запускается поверх WebSockets.
        > WAMP использует JSON, как формат для сериализации сообщений.
        > WAMP реализует паттерны PubSub и RPC на протоколе WebSockets.


    > Реализация клиентской части
      > Если ты строишь своё приложение с использованием WAMP (что крайне
        рекомендуют на сайте Ratchet), то тебе понадобится JS-библиотека
        для реализации клиентской части.
      > AutobahnJS - как раз такая клиентская библиотека. Вот ссылка:
            http://autobahn.ws/js/


    > Топики
      > Компонент WampServer создаёт новый класс - Topic - который и
        передаётся твоему приложению.
      > Этот класс - контейнер, в котором хранятся все объекты-соединения,
        которые подписались на этот топик.
      > В этом классе есть также ряд полезных методов, таких как
        broadcast - для отправки сообщений всем подписчикам.
      > При вызове методов объекта-соединения, которые требуют "string $topic",
        можно передать класс Topic или его id.
      > Если ты знаком с другими формами передачи сообщений, топики
        эквивалентны каналам.


    > Может обернуть следующие компоненты
      # Пользовательский класс, представляющий его приложение.
        - Должен реализовывать интерфейс MessageComponentInterface.

    > Может быть обёрнут следующими компонентами
      > WsServer
      > SessionProvider

    > Возбуждает события:

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onCall (ConnectionInterface $conn, string $id, Topic $topic, array $params)
        > Клиент сделал RPC к серверу.
        > Ты должен послать callResult/callError в return.

      # onSubscribe (ConnectionInterface $conn, Topic $topic)
        > Клиент подписался на канал, и ожидает событий при публикации в этот топик.

      # onUnsubscribe (ConnectionInterface $conn, Topic $topic)
        > Клиент отписался от канала - отказался от получения сообщений из $topic

      # onPublish (ConnectionInterface $conn, Topic $topic, string $event)
        > Пользователь опубликовал данные в $topic.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка. Ты должен взамен вернуть
          Event Command тем объектам-подключениям, которые подписаны
          на топик $topic.

    > Методы для настройки
      > Нет.

    > Функции (передающиеся объектам-соединениям)

      # event (string $topic, string $msg)
        > Публикует (шлёт) данные клиенту, подписанному на топик $topic.

      # callResult (string $id, array $data)
        > Ответ на клиентский запрос.
        > Убедись, что передал соответствующий $id из события onCall.

      # callError (string $id, string $topic, string $desc = '', string $details = null)
        > Ответ на клиентский запрос, сообщающий о том, что в процессе
          обработки запроса возникла ошибка.
        > Убедись, что передал соответствующий $id из события onCall.

      # close
        > Закрывает соединение.

    > Cв-ва (передающиеся объектам-соединениям)
      - string $sessionId     | Уникальный ID, данный клиенту
      - array $subscriptions  | Коллекция доступных топиков


  /  Подробнее об OriginCheck  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Свойства для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание:
      > Помогает защитить сервак от нежелательных сайтов, которые
        пытаются подключить пользователей к нашему серваку.
        - При создании WebSocket-соединения, браузер клиента посылает
          серваку в заголовке адрес сайта, на котором находится клиент.
          OriginCheck авто-ки закроет соединение, если браузер в заголовке
          пришлёт не ожидаемый адрес (адреса).
      > Этот компонент поставляется внутри класса App.
      > По умолчанию Ratchet\App настроен так, чтобы принимать запросы только
        с того же домена, что был передан конструктору __construct класса App.

    > Может обернуть следующие компоненты
      - WsServer
      - Router

    > Может быть обёрнут следующими компонентами
      - HttpServer

    > Возбуждает события

      # onOpen (ConnectionInterface $conn)
        > Новые соединение клиент-сервер было открыто.

      # onClose (ConnectionInterface $conn)
        > Существующее соединение клиент-сервер было закрыто.

      # onMessage (ConnectionInterface $from, string $message)
        > Было отправлено сообщение.

      # onError (ConnectionInterface $from, Exception $error)
        > В соединении возникла ошибка.

    > Свойства для настройки
      - $allowedOrigins   | Массив строк из допустимых URL

    > Функции (передающиеся объектам-соединениям)
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям)
      > Нет.

    > Пример работы

        <?php

          // Назначить псевдонимы
          use Ratchet\Http\OriginCheck;
          use Ratchet\Http\HttpServer;
          use Ratchet\Server\IoServer;

          // Создать и настроить новый объект OriginCheck
          $checkedApp = new OriginCheck(new MyHttpApp, array('localhost'));
          $checkedApp->allowedOrigins[] = 'mydomain.com';

          // Создать новый объект IoServer, завернуть в него новый объект
          // HttpServer, завернуть в него объект $checkedApp
          $server = IoServer::factory(new HttpServer($checkedApp));

          // Запустить сервер
          $server->run();


  /  Подробнее о FlashPolicy  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание:
      > FlashPolicy позволяет браузерам без встроенной поддержки WebSockets
        подключиться к твоему Ratchet-приложению, используя Flash Sockets.
      > Для реализации WebSockets в браузерах без встроенной поддержки этого
        протокола, на клиентской стороне надо подключить библиотеку
        web-socket-js (сайт: https://github.com/gimite/web-socket-js)
      > Чтобы клиент на Flash мог коммуницировать с сервером через сокеты,
        он должен получить разрешение в виде XML на порт 843. Flash сделает
        такой запрос к серверу автоматически перед подключением к твоему
        WebSocket-серверу.
      > Как следствие, ты должен запускать 2 скрипта на сервере:
        - Один через порт 843 с FlashPolicy.
        - Один через порт 80 с твоим приложением.
      > Компонент FlashPolicy поставляется внутри класса App. Он запускается
        на порту 843, если ты запустишь его на порту 80. И он запускается
        на порту 8843 в любом ином случае.

    > Может обернуть следующие компоненты
      > Нет.

    > Может быть обёрнут следующими компонентами
      - IoServer
      - IpBlackList

    > Возбуждает события
      > Нет

    > Методы для настройки

      # FlashPolicy addAllowedAccess (string $domain, string $ports, bool $secure)
        > Белый лист сокетов (домен+порт) клиентов, и должно ли соединение
          быть обезопашено ($secure)

      # FlashPolicy setSiteControl (string $permittedCrossDomainPolicies)
        > Установить одно из следующих значений:
          - "All"
          - "Master-only"
          - "none"

    > Функции (передающиеся объектам-соединениям)
      > Нет

    > Cв-ва (передающиеся объектам-соединениям)
      > Нет

    > Пример работы

        <?php

          // Назначить псевдонимы
          use Ratchet\Server\FlashPolicy;
          use Ratchet\Server\IoServer;

          // Создать новый экземпляр объекта FlashPolicy
          $flash = new FlashPolicy;

          // Разрешить всем Flash Socket с любого домена подключаться к порту 8080
          $flash->addAllowedAccess('*', 8080);

          // Создать новый экземпляр IoServer на порту 843, завернуть
          // в него $flash, и запустить
          $server = IoServer::factory($flash, 843);
          $server->run();


  /  Подробнее о IpBlackList  /
  ===================================

    > Оглавление:
      - Описание
      - Может обернуть следующие компоненты
      - Может быть обёрнут следующими компонентами
      - Возбуждает события
      - Методы для настройки
      - Функции (передающиеся объектам-соединениям)
      - Cв-ва (передающиеся объектам-соединениям)
      - Пример работы

    > Описание
      > Если кто-либо совершает злонамеренные действия против твоего
        сервера, то ты можешь избавиться от них!
      > Компонент IpBlackList позволяет указать список IP, соединения
        от которых не принимать.
        - Надо ставить вплотную к IoServer в "бутерброде", чтобы нежелательные
          подключения отсекались сразу.

    > Может обернуть следующие компоненты
      # Пользовательский класс, представляющий его приложение.
        - Должен реализовывать интерфейс MessageComponentInterface.
      # FlashPolicy
      # HttpServer

    > Может быть обёрнут следующими компонентами
      - IoServer

    > Методы для настройки

      # IpBlackList blockAddress (string $address)
        > Указать адрес, который должен быть заблокирован.
        > Это может быть ip4, ip6, named address.

      # IpBlackList unblockAddress (string $address)
        > Указать адрес, ранее заблокированный, который должен быть разблокирован.

      # boolean isBlocked (string $address)
        > Проверить, заблокирован ли указанный адрес.

      # array getBlockedAddresses ()
        > Возвращает индексированный массив всех заблокированных адресов.

    > Функции (передающиеся объектам-соединениям)
      - send (string $message)    | Отправить сообщение (строку) клиенту
      - close ()                  | Закрыть соединение с клиентом

    > Cв-ва (передающиеся объектам-соединениям)
      > Нет.

    > Пример работы

        <?php

          // Назначить псевдонимы
          use Ratchet\Server\IpBlackList;
          use Ratchet\Server\IoServer;

          // Создать новый объект класса IpBlackList, в который завернуть
          // новый объект пользовательского прилоежния MyChat.
          $blackList = new IpBlackList(new MyChat);

          // Добавить адрес Google в stop-list указанный адрес
          $blackList->blockAddress('74.125.226.46');

          // Создать новый объект IoServer на порту 8080, заврнуть
          // в него $blackList, и запустить
          $server = IoServer::factory($blackList, 8080);
          $server->run();







> Установка Ratchet с помощью Composer

  > Общая информация:
    > Единственный способ установить Ratchet - с помощью Composer.
    > Пакет ресурсов Ratchet есть в главном репозитории композера -
      packagist.org. Так что для установки надо просто следовать
      стандартной процедуре установки зависимостей с помощью Composer.
    > Имя искомого пакета ресурсов:  cboden/ratchet
    > Если у тебя не установлен git, то применяя команду install надо
      применить с ней опцию --prefer-dist, и тем самым сказать:
      "устанавливай из архива, а не из git, потому что последнего у меня нет".

  > Условия установки (для примера, их можно менять):
    - Версия: "dev-master".
    - Пр.имён: "MyApp"
    - Тип автозагрузки: "PSR-0"

  > Данные для вставки в соотв. параметры composer.json в соотв. с
    определёнными выше условиями:

        {
            "autoload": {
                "psr-0": {
                    "MyApp": "src"
                }
            },
            "require": {
                "cboden/Ratchet": "0.3.*"
            }
        }


> Создание тестового приложения: ЧАТ в командной строке

  > Ссылки
    > Подробно о том, как делается этот чат, описано в официальной документации
      Ratchet у них на сайте:
          http://socketo.me/docs/hello-world

  > Отдельная папка
    > Создадим отдельную папку для нашего приложения.
    > Допустим, назовём её "Chat"

  > Загрузка Ratchet с помощью Composer
    > Создадим в папке "Chat" файл composer.json.
      Запишим в него следующее:

        {
            "autoload": {
                "psr-0": {
                    "MyApp": "src"
                }
            },
            "require": {
                "cboden/Ratchet": "0.3.*"
            }
        }

      > В autoload мы дали композеру понять, что пр.имён MyApp находится
        в папке src\MyApp относительно корня проекта.

    > Перейдём в консоли в папку Chat.
    > Выполним команду composer install. Ratchet и его зависимости будут
      установлены в папку Chat\vendor.

  > Создадим класс Chat
    > Корневая папка проекта у нас Chat.
      В ней лежит файл composer.json.
    > С помощью композера мы уже установили в неё Ratchet, теперь он лежит
      у нас по адресу Chat\vendor\cboden\Ratchet
    > В корневой папке создадим файл, в котором у нас будет класс чат:
        Chat\src\MyApp\chat.php
    > Почему именно src\MyApp? Потому что в comoser.json мы указали
      автозагрузчику композера в параметре autoload, что пространство
      имён MyApp находится в папке src\MyApp относительно корня проекта.
    > Класс Chat подробно описано в файле Chat.php

  > Создадим файл-сервер
    > Это будет сервер для запуска в командной строке.
    > Сохраним его по адресу:
        Chat\bin\chat-server.php
    > Здесь мы буде использовать класс IoServer, он:
      - Сохраняет установленные соединение
      - Передаёт данные между подключенными клиентами
      - Отлавливает ошибки
    > Мы просто создаём экземпляр класс IoServer и запускаем сервер
      методом run. Подробнее см. в самом файле.

  > Запустим сервер в командной строке
    > Для этого надо:
      - Открыть терминал.
      - Перейти в корневую папку проекта Chat
      - Запустить с помощью php наш подготовленный сервер:
          php bin\chat-server.php

  > Подключим 2 telnet-клиента к серверу и испытаем чат
    > Для этого:
      - Откроем еще 2 окна с терминала.
      - В каждой из них с помощью telnet подключимся к нашему серваку:
            telnet localhost 8080
      - При подключении каждого клиента на сервере будет выводиться сообщение
        о подключении.
      - Теперь начать писать в одно окно, и наблюдать, как написанное появляется
        в другом окне.
      - Также при вводе каждого символа на сервере появляется сообщение о том,
        что один из клиентов ввёл символ, и само сообщение.

  > Живой пример
    > См. по адресу:

      Web Library\4. PHP Library\3. Ratchet\Simple chat (console)


> Создание тестового приложения: ЧАТ в браузере

  > Ссылки
    > Подробно о том, как делается этот чат, описано в официальной документации
      Ratchet у них на сайте:
          http://socketo.me/docs/hello-world

  > Отдельная папка
    > Создадим отдельную папку для нашего приложения.
    > Допустим, назовём её "Chat (browser)"

  > Загрузка Ratchet с помощью Composer
    > Создадим в папке "Chat (browser)" файл composer.json.
      Запишим в него следующее:

        {
            "autoload": {
                "psr-0": {
                    "MyApp": "src"
                }
            },
            "require": {
                "cboden/Ratchet": "0.3.*"
            }
        }

      > В autoload мы дали композеру понять, что пр.имён MyApp находится
        в папке src\MyApp относительно корня проекта.

  > Создадим класс Chat
    > Корневая папка проекта у нас "Chat (browser)".
      В ней лежит файл composer.json.
    > С помощью композера мы уже установили в неё Ratchet, теперь он лежит
      у нас по адресу "Chat (browser)\vendor\cboden\Ratchet"
    > В корневой папке создадим файл, в котором у нас будет класс чат:
        "Chat (browser)\src\MyApp\chat.php"
    > Почему именно src\MyApp? Потому что в comoser.json мы указали
      автозагрузчику композера в параметре autoload, что пространство
      имён MyApp находится в папке src\MyApp относительно корня проекта.
    > Класс Chat подробно описано в файле Chat.php

  > Создадим Ratchet-сервер
    > Это будет сервер для работами с клиентами-браузерами.
    > Сохраним его по адресу:
        Chat\bin\chat-server.php
    > Здесь мы буде использовать класс IoServer, он:
      - Сохраняет установленные соединение
      - Передаёт данные между подключенными клиентами
      - Отлавливает ошибки
    > Мы просто создаём экземпляр класс IoServer и запускаем сервер
      методом run. Подробнее см. в самом файле.

  > Запустим сервер в командной строке
    > Для этого надо:
      - Открыть терминал.
      - Перейти в корневую папку проекта "Chat (browser)"
      - Запустить с помощью php наш подготовленный сервер:
          php bin\chat-server.php

  > Подготовим клиента
    > Это будет примитивный браузерный клиент.
    > Он будет состоять из 2 файлов:
      - client.html
      - client.js
    > В HTML-файле будет всего 2 элемента - текстовый инпут и кнопка.
    > В JS-клиенте будет 3 основных этапа:
      - Создание WebSocket-соединения с сервером.
      - Назначение обработчиков событий для созданного соединения
      - Назначение обработчика события клик на кнопке для отправки сообщения из текстового инпута.

  > Испытаем чат
    > Откроем 2 вкладки в браузере.
    > В каждой вкладке откроем по клиенту

  > Живой пример
    > См. по адресу:

      Web Library\4. PHP Library\3. Ratchet\Simple chat (browser)







-------------------------------------------------- */




















