2. View
Управление представлениями
Laravel 4.2

> Ссылки

    - Официальный справочник (см. Illuminate\View\Factory) (en):
        http://laravel.com/api/4.2/

    - Хорошая статья про композеры представлений (view composers) (en):
        http://culttt.com/2014/02/10/using-view-composers-laravel-4/


--------------------------------
Оглавление

2. View  | Управление представлениями  | v4.2 - Illuminate\View\View - view
                                         v4.2 - Illuminate\View\Factory

  > make      | Создаёт объект класса View из указанного файла
  > name      | Регистрирует имя $name за представлением $view
  > alias     | Регистрирует псевдоним $alias за представлением $view
  > of        | Создаёт объект класса View из именованного представления.
  > exists    | Определяет, существует ли указанный файл-представление

  -> nest     | Вложить в представление переменную, содержащую другое представление
  -> with     | Добавить в представление переменную с данными

  > share     | Расшарить переменную для всех представлений
  > composer  | Назначить представлению функцию-обарботчик событию composing
  > composers | Назначить представлениям функцию-обарботчик событию composing

--------------------------------

|---------------------------------------------------------
| > make (string $view, array $data = array(), array $mergeData = array())
|---------------------------------------------------------
| Создаёт объект класса View из указанного файла
|
|   $view        | Адрес или имя представления, из которого делаем объект класса View
|   $data        | Массив данных для передачи данных в представление
|   $mergeData   | ?
|
|   Возвращает:  | Объект класса View

  1. Создать из файла объект класса View и передать его в ответ на запрос
  ====================================================================

  - Допустим, у нас есть файл 'app/views/myViews/view1.blade.php'.
  - Создадим из него объект класса View, и передадим в ответ на запрос.

      Route::get('/', function(){

        $view = View::make('myViews/view1');

      });


  2. Создать объект класса View и передать в него данные
  ====================================================================

  - Передадим 2 строки: $name1 = 'ivan' и $name2 = 'lena'.

      Route::get('/', function(){

        $view = View::make('myViews/view1', array(
          'name1' => 'ivan',
          'name2' => 'lena'
        ));

      });

  - Доступ к этим данным в представлении есть по переменным $name1 и $name2.


|---------------------------------------------------------
| > name (string $view, string $name)
|---------------------------------------------------------
| Создаёт объект класса View из указанного файла
|
|   $view        | Адрес, из которого делаем объект класса View
|   $name        | Регистрирует имя $name за представлением $view
|
|   Возвращает:  | void

  1. Зарегистрировать имя за представлением
  ====================================================================

  - Зарегистрируем имя 'myView' за представлением 'app/views/myViews/view1.blade.php'.

      View::name('myViews/view1.blade.php', 'myView');


|---------------------------------------------------------
| > alias (string $view, string $alias)
|---------------------------------------------------------
| Регистрирует псевдоним $alias за представлением $view
|
|   $view        | Адрес или имя представления, из которого делаем объект класса View
|   $name        | Регистрирует имя $name за представлением $view
|
|   Возвращает:  | void

  1. Зарегистрировать псевдоним за представлением
  ====================================================================

  - Зарегистрируем псевдоним 'myView' за представлением 'app/views/myViews/view1.blade.php'.

      View::alias('myViews/view1.blade.php', 'myView');


|---------------------------------------------------------
| > of (string $view, mixed $data = array())
|---------------------------------------------------------
| Создаёт объект класса View из именованного представления.
|
|   $view        | Адрес или имя представления, связанное с его файлом методом name()
|   $data        | Массив данных для передачи данных в представление
|
|   Возвращает:  | Объект класса View

  1. Создать объект класса View из именованного представления
  ====================================================================

  - Зарегистрируем имя 'myView' за представлением 'app/views/myViews/view1.blade.php'.

      View::name('myViews/view1.blade.php', 'myView');

  - Создадим объект класса View из именованного представления

      $view = View::of('myView');

  - Создадим объект класса View из именованного представления...
  - ... и передадим в него пару значений.

      $view = View::of('myView', array(
        'param1' => 'value1',
        'param2' => 'value2'
      ));


|---------------------------------------------------------
| > exists (string $view)
|---------------------------------------------------------
| Определяет, существует ли указанный файл-представление
|
|   $view        | Адрес или имя файла, из которого делаем объект класса View
|
|   Возвращает:  | bool

  1. Проверить, существует ли файл-представление
  ====================================================================

  - По имени myView:

      $isExists = View::exists('myView');

  - По адресу 'app/views/myViews/view1.blade.php':

      $isExists = View::exists('myViews/view1');


|---------------------------------------------------------
| -> nest (string $key, string $view, array $data = array())
|---------------------------------------------------------
| Вложить в представление переменную, содержащую другое представление
|
|   $key        | Имя переменной для доступа к вложенному представлению из родительского
|   $view       | Адрес или имя представления, которое вкладываем
|   $data       | Массив с данными для передачи во вкладываемое представление

  1. Вложить одно представление в другое
  ====================================================================

  - Допустим, у нас есть 2 представления с именами 'child' и 'parent'.
  - Создадим объект класса View из 'parent', и вложим в него 'child'.
  - А заодно передадим и туда, и туда немного данных.

      Route::get('/', function(){

        $view = View::make('parent', array('param1'=>'ivan'))
                ->nest('ch', 'child', array('param2'=>'lena');

      });

  - В коде 'parent' теперь получить доступ к 'child' можно так:

      <html>
          <body>

              <?php echo $ch; ?>

          </body>
      </html>

  - Или так, если используется blade:

      <html>
          <body>

             {{ $ch; }}

          </body>
      </html>


|---------------------------------------------------------
| -> with (string|array $key, mixed $value = null)
|---------------------------------------------------------
| Добавить в представление переменную с данными
|
|   $key        | Имя переменной, по которому будут доступны вложенные данные в представлении
|   $value      | Значение

  1. Вложить в представление несколько переменных с данными
  ====================================================================

      Route::get('/', function() {

        // Создадим объект-представление
        $view = View::make('myView');

        // Передадим во $view переменную $name = 'ivan'
        $view->with('name', 'ivan');

        // Передадим во $view переменную $age = 14
        $view->with('age', 14);

        // Передадим во $view массив $arr = array('name'=>'ivan','age'=>14)
        $view->with('arr', array('name'=>'ivan','age'=>14));

      });


|---------------------------------------------------------
| > share (string $key, mixed $value = null)
|---------------------------------------------------------
| Расшарить переменную для всех представлений
|
|   $key        | Имя переменной, по которому будут доступны данные
|   $value      | Значение

  1. Расшарить переменную среди всех представлений
  ====================================================================

  - Допустим, вот такую строку можно добавить в файл 'app/start/global.php'.
  - Тогда он будет выполнятсья каждый раз при старте приложения.
  - И в каждом представлении будет доступна переменная $name == 'ivan'.

      View::share('name', 'ivan');


|---------------------------------------------------------
| > composer (array|string $views, Closure|string $callback, int|null $priority = null)
|---------------------------------------------------------
| Назначить представлению функцию-обарботчик событию composing
|
|   $views         | Адрес(а) / имя(на) представлений, которым назначить функуию-обработчик.
|   $callback      | Функция-обработчик события composing
|   $priority      | ?
|
| Особенности:
| - Событие composing возбуждается непосредственно перед рендерингом представления.
| - Рендеринг - получение DOM-структуры представления из его модели.
| - View::composer позволяет назначить представлению функцию-обработчик этого события.
| - Эта функция - либо анонимная, либо метод класса.
| - В Laravel такие обработчики называют "композер представления" (View Composer).
| - Их используют, если в представление каждый раз перед его рендерингом
|   надо передавать фиксированный набор данных.


  > Архитектура использования
    1.  У нас есть 2 варианта, где хранить код функции-обработчика.
        > Вариант 1: в методе compose класса-композера
          - Можно создать для таких классов отдельную папку. Например: 'composer'.
          - В эту папку можно складывать файлы композер-классов.
          - В 1-м файле лучше всего хранить только 1 композер-класс.
          - В 1-м композер-классе должен быть только 1 метод: compose.
          - В теле метода compose находится код функции-обработчика.
          - Все классы-композеры надо добавить в IoC с помощью нового
            service-provider.
          - Как создать и добавить service-provider, читай в соответствующем
            разделе.
        > Вариант 2: в анонимной функции
          - При назначении обработчика события composing в кач-ве колбэк-функции
            указывается анонимная функция, в которой и находится код.
    2.  Назначение функции-обрабочтика
        - Для этого можно создать отдельный файл composers.php
        - Назначение производится с помощью метода View::composer
        - Получить доступ к классам из п.1 можно либо через IoC (рекомендуется),
          либо просто подключив их к этому файлу.
        - В этом файле можно провести все необходимые назначения.
    3.  Подключение файла composers.php к проекту
        - Файл composers.php должен быть выполнен при появлении запроса.
        - Хороший вариант: подключить его с помощью require в файл
          'app/start/global.php'.

  > Примеры
    - Вот шаблон для класса-композера (см. архитектура ч.1):

        // Лежит в отдельном файле ProfileComposer.php
        class ProfileComposer {

          public function compose($view) {

            // Добавить в представление переменную $count со
            // значением User::count()
              $view->with('count', User::count());

          }

        }

    - Вот как в файле composers.php можно назначить представлению 'profile'
      функцию-обработчик в виде метода composer класса-композера 'ProfileComposer'
      события 'composing' (см. архитектура ч.2):

        // Назначим представлению 'profile'
          View::composer('profile', 'ProfileComposer');

        // ... а вообще можно назначить сразу нескольким представлениям:
          View::composer(array('profile', 'anotherProfile'), 'ProfileComposer');

    - Вот как в файле composers.php можно назначить представлению 'profile'
      функцию-обработчик в виде анонимной функции события 'composing'
      (см. архитектура ч.2):

        // Назначим представлению 'profile'
          View::composer('profile', function($view)
          {

              // Добавить в представление переменную $count со
              // значением User::count()
                $view->with('count', User::count());

          });

        // ... а вообще можно назначить сразу нескольким представлениям:
          View::composer(array('profile','dashboard'), function($view)
          {

              // Добавить в представление переменную $count со
              // значением User::count()
                $view->with('count', User::count());

          });

    - Есть возможность за раз назначить нескольким представлениям указанные
      функции-обработчики. Например:

        View::composers(array(
            'AdminComposer' => array('admin.index', 'admin.profile'),
            'UserComposer' => 'user',
        ));













