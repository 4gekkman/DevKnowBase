7. Eloquent
Laravel 4.2

> Ссылки

    - Официальный справочник (см. Illuminate\Database\Eloquent) (en):
        http://laravel.com/api/4.2/

    - Хорошая статья по работе с классом Collections, много примеров (en):
        http://daylerees.com/codebright/eloquent-collections

    - Использование событий в классе Model в Laravel (статья) (en):
        http://driesvints.com/blog/using-laravel-4-model-events


--------------------------------
Оглавление

7. Eloquent  | Eloquent  | v4.2 - Illuminate\Database\Eloquent

//|---------------------------|//
//|                           |//
//|  Builder (query builder)  |//
//|                           |//
//|---------------------------|//


  /////-------------------------/////
  /////         Основное        /////
  /////-------------------------/////

  > get             | выполнить запрос, как выражение SELECT

  > find            | найти 1 модель по её первичному ключу
  > findMany        | найти >=1 модель по её/их первичному(ым) ключу(ам)
  > findOrFail      | найти 1 модель по её первич.ключу, если не найдено - возбудить исключение

  > first           | выполнить запрос и вернуть 1-й результат
  > firstOrFail     | выполнить запрос и вернуть 1-й результат, а если его нет - возбудить исключение

  > where           | добавить атрибут where к запросу
  > orWhere         | добавить атрибут or where к запросу

  > delete          | удалить запись из базы данных
  > forceDelete     | запустить функцию удаления записи в таблице "по умолчанию" для удаления
  > onDelete        | зарегистрировать замену для функции удаления записи из таблицы "по умолчанию"
  > update          | обновить запись в базе данных

  /////-------------------------/////
  /////      Дополнительно      /////
  /////-------------------------/////

  > increment       | инкрементировать все поля указанного столбца указанным числом
  > decrement       | декрементировать все поля указанного столбца указанным числом

  > pluck           | извлечь значение 1-го поля модели Model из указанной колонки
  > chunk           | извлечь данные из таблицы траншами по N штук
  > lists           | извлечь массив значений из указанной колонки

  > paginate        | получить Paginator для результата запроса с N значениями на страницу
  > simplePaginate  | получить простой Paginator для результата запроса с N значениями на страницу, поддерживающий только prev и next

  /////-------------------------/////
  /////    Запросы со связями   /////
  /////-------------------------/////

  > with            | указать связь, для которой должна сработать упреждающая загрузка

  > has             | добавить условие-счётчик-связей в запрос
  > whereHas        | добавить условие-счётчик-связей в запрос с атрибутами where
  > orHas           | добавить условие-счётчик-связей в запрос с атрибутами or
  > orWhereHas      | добавить условие-счётчик-связей в запрос с атрибутами where и or


//|---------------------------|//
//|                           |//
//|         Collection        |//
//|                           |//
//|---------------------------|//


  /////------------------------------------/////
  /////      Извлечение 1-го элемента      /////
  /////------------------------------------/////

  > first               | получить самый 1-й элемент коллекции
  > last                | получить последний элемент в коллекции
  > find                | найти модель в коллекции по указанному первичному ключу
  > get                 | извлечь из коллекции элемент по указанному ключу (как у массива)
  > fetch               | получить элемент коллекции с указанным ключём

  /////------------------------------------/////
  ///// Извлечение подколлекции элементов  /////
  /////------------------------------------/////

  > all                 | получить из модели коллекцию всех элементов
  > take                | взять подколлекцию из первых/последних N эл-в коллекции
  > unique              | вернуть коллекцию лишь из уникальных эл-в коллекции
  > only                | получить подколлекцию только с эл-ми с указанными первичными ключами
  > except              | получить подколлекцию всех эл-в, кроме чьи ключи указаны
  > groupBy             | получить сгруппированную по указанному столбцу коллекцию
  > slice               | извлечь подколлекцию
  > intersect           | из 2-х коллекций получить 2-ну, с НЕ уникальными эл-ми
  > diff                | из 2-х коллекций получить 1-ну, с уникальными эл-ми

  /////------------------------------------/////
  /////   Манипуляция эл-ми в коллекции    /////
  /////------------------------------------/////

  > prepend             | добавить (push) эл-т в начало коллекции
  > push                | добавить (push) эл-т в конец коллекции
  > shift               | удалить 1-й эл-т коллекции, и вернуть его
  > pop                 | удалить последний эл-т из коллекции, и вернутье его
  > merge               | объединить указанные эл-ты с коллекцией
  > pull                | извлечь и вернуть эл-т с указанным ключём из коллекции (удалив)
  > put                 | втиснуть элемент в коллекцию, указав ключ
  > add                 | добавить элемент в конец коллекции
  > forget              | удалить эл-т с указанным ключём из коллекции
  > splice              | позволяет удалить/вставить на их место эл-ты

  /////------------------------------------/////
  /////     Сортировка эл-в коллекции      /////
  /////------------------------------------/////

  > sort                | сортировать коллекцию с помощью callback
  > sortBy              | сортировать коллекцию по указанному столбцу стандартным алгоритмом
  > sortByDesc          | сортировать коллекцию по указанному столбцу стандартным алгоритмом, в обратнмо порядке

  /////------------------------------------/////
  ///// Обработка эл-в callback-функциями  /////
  /////------------------------------------/////

  > each                | выполнить callback для каждого эл-та коллекции
  > map                 | возвращает коллекцию из элементов, обработанных и возвращенных callback-функцией
  > filter              | отфильтровать коллекцию с помощью callback
  > reject              | это фильтр наоборот
  > transform           | трансформировать каждый эл-т коллекции, используя callback
  > sum                 | пробежаться по эл-м коллекции и просуммировать возвращаемые callback-функцией значения

  /////------------------------------------/////
  /////                JSON                /////
  /////------------------------------------/////

  > jsonSerialize       | конвертировать объект-коллекцию в массив, который можно преобразовать в json
  > toArray             | преобразовать коллекцию в простой массив
  > toJson              | конвертировать коллекцию сразу в json-строку

  /////------------------------------------/////
  /////    Размеры, наличие, пустота       /////
  /////------------------------------------/////

  > contains            | есть ли в коллекции элемент с указанным первичным ключём
  > has                 | есть ли в коллекции элемент с указанным ключём (не первичным, а массива коллекции)
  > isEmpty             | пуста ли коллекция
  > count               | количество элементов в коллекции

  /////------------------------------------/////
  /////               Прочее               /////
  /////------------------------------------/////

  > max                 | получить максимально значение по указанному столбцу
  > min                 | получить минимальное значение по указанному столбцу
  > search              | искать в коллекции указанный элемент, и получить его индекс (в случ.успеха)
  > reverse             | изменить на обратный порядок эл-в в коллекции
  > shuffle             | перемешать элементы в коллекци
  > random              | извлечь случайным образом 1 (Model) или более (Collection) эл-в из коллекции
  > flip                | поменять местами ключи и значения всех эл-в коллекции
  > values              | сбросить ключи в коллекции

  /////------------------------------------/////
  ///// ..Для этих примеры по требованию.. /////
  /////------------------------------------/////

  > make                | создать новую Collection, если value уже не 1-но
  > keys                | получить массив ключей всех элементов коллекции
  > modelKeys           | получить массив первичных ключей
  > collapse            | свернуть коллекцию в один массив
  > flatten             | преобразовать многомерный массив коллекции в одномерный
  > keyBy               | ?
  > implode             | объединить значения в строку, склеив строкой glue
  > lists               | ?
  > reduce              | уменьшить коллекцию до 1 значения
  > chunk               | ?
  > load                | ?


//|---------------------------|//
//|                           |//
//|           Model           |//
//|                           |//
//|---------------------------|//


  /////------------------------------------/////
  /////               Свойства             /////
  /////------------------------------------/////

  > incrementing      | включёно ли у модели авто-инкрементирование? [true/false]
  > timestamps        | включено ли у модели авто-обслуж.столбцов 'updated_at', 'created_at'? [true/false]
  > exists            | существует ли модель? [true/false]
  > snakeAttributes   | указывает, используются ли snakeCased имена колонок в модели
  > manyMethods       | получить массив many-to-many связей

  /////------------------------------------/////
  /////  Преобразование в массив / JSON    /////
  /////------------------------------------/////

  > toJson                  | конвертировать модель в json-строку
  > jsonSerialize           | конвертировать модель в массив, который можно преобразовать в json
  > toArray                 | конвертировать модель в массив
  > attributesToArray       | конвертировать атрибуты модели в массив

  /////------------------------------------/////
  /////           Поиск моделей            /////
  /////------------------------------------/////

  > all                     | получить все модели из базы данных
  > find                    | найти модель по её первичному ключу
  > findOrNew               | найти модель по её первичному ключу, или вернуть новую статическую
  > findOrFail              | найти модель по её первичному ключу, или возбудить исключение

  /////------------------------------------/////
  ///// Операции insert / update / delete  /////
  /////------------------------------------/////

  > save                    | сохранить модель в базе данных
  > push                    | сохранить модель и все её связи в БД

  > create                  | создать новую модель и вернуть ссылку
  > firstOrCreate           | извлечь 1-ю запись, соотв-юю указанным атрибутам, или создать ей
  > firstOrNew              | извлечь 1-ю запись, соотв-юю указанным атрибутам, или экземпляризировать её

  > update                  | обновить модель в базе данных

  > delete                  | удалить модель из базы данных
  > destroy                 | уничтожить модели с указанными ID

  /////------------------------------------/////
  /////    Первич.ключи и ассоц.таблица    /////
  /////------------------------------------/////

  > getKey                  | получить значение столбца - первичного ключа модели
  > getKeyName              | получить имя столбца - первичного ключа модели
  > getQualifiedKeyName     | получить имя столбца - первичного ключа модели, квалифицированное именем таблицы
  > getTable                | получить имя таблицы, ассоциированной с моделью
  > setTable                | установить имя таблицы, ассоциированной с моделью
  > getIncrementing         | инкрементируются ли ID?
  > setIncrementing         | вкл/выкл инкрементирование ID

  /////------------------------------------/////
  /////     Работа с timestamps модели     /////
  /////------------------------------------/////

  > touch                   | обновить updated_at timestamp модели
  > usesTimestamps          | определить, использует ли модель авто-проставку timestamp'ов 'updated_at', 'created_at'
  > setCreatedAt            | установить значение столбца 'created_at'
  > setUpdatedAt            | установить значение столбца 'updated_at'
  > getCreatedAtColumn      | получить имя колонки для 'created at' значения
  > getUpdatedAtColumn      | получить имя колонки для 'updated at' значения
  > freshTimestamp          | получить свежий timestamp для модели, как объект Carbon
  > freshTimestampString    | получить свежий timestamp для модели, как строку

  /////------------------------------------/////
  ///// Создать экз-яр Model / Collection  /////
  /////------------------------------------/////

  > newCollection           | создать новый экземпляр Eloquent Collection
  > newInstance             | создать новый экземпляр данной модели
  > newFromBuilder          | создать новый экземпляр существующей модели
  > replicate               | клонировать модель, создав новый экземпляр
  > hydrate                 | создать коллекцию моделей из простых массивов
  > hydrateRaw              | создать коллекцию моделей из прямого запроса
  > updateOrCreate          | создать или обновить запись, соотв-юю указанным атрибутам, и заполнить её указанными значениями

  /////------------------------------------/////
  /////      Работа с Mass Assignment      /////
  /////------------------------------------/////

  > fill                    | заполнить модель из массива атрибутов
  > fillable                | назначить заполняемые атрибуты модели
  > guard                   | сделать указанные атрибуты модели охраняемыми
  > unguard                 | отключить ограничитель на mass assignment
  > reguard                 | включить ограничения на mass assignment
  > getFillable             | получить массив имёт столбцов, для которых включён mass assignment
  > isFillable              | узнать, может ли указанный столбец участвовать в mass assignment
  > isGuarded               | узнать, защищён ли указанный атрибут
  > totallyGuarded          | вернёт true, если все столбцы модели защищены от mass assignment
  > setUnguardState         | установить 'unguard' указанному состоянию

  /////------------------------------------/////
  /////    Работа с полями и мутаторами    /////
  /////------------------------------------/////

  > getAttribute            | извлечь значение из указанного столбца модели
  > setAttribute            | установить указанный атрибут для модели
  > getAttributes           | получить массив всех ключей-значений модели
  > setRawAttributes        | массово изменить значения в указанных в массиве столбцах на указанные
  > hasGetMutator           | определить, действует ли get-мутатор для указанного столбца
  > hasSetMutator           | определить, действует ли set-мутатор для указанного столбца
  > getMutatedAttributes    | получить массив имён столбцов, в которых поработали мутаторы
  > setAppends              | установить ассессоры для добавления в массивы модели
  > getDates                | получить массив атрибутов, который должен быть конвертирован в даты
  > fromDateTime            | сохранить DATETIME в строку

  /////------------------------------------/////
  /////       Работа с изменениями         /////
  /////------------------------------------/////

  > isDirty                 | определить, были ли изменены значения в модели или указанных столбцах
  > getDirty                | получить массив имён столбцов, изменённых с момента посл.синхронизации
  > getOriginal             | получить массив всех эл-в (ключ-значение) модели, со значениями, которые были сразу после посл.синхронизации
  > syncOriginal            | синхронизировать все исходные значения в столбцах модели с текущими
  > syncOriginalAttribute   | синхнонизировать исходный атрибут с его текущим значением

  /////------------------------------------/////
  /////      Работа с query builder        /////
  /////------------------------------------/////

  > query                   | начать запрашивать модель
  > on                      | начать запрашивать модель на указанном соединении
  > newQuery                | получить новый query builder для таблицы модели
  > newEloquentBuilder      | создать новый Eloquent query builder для модели

  /////------------------------------------/////
  /////      Работа с соединениями         /////
  /////------------------------------------/////

  > getConnection           | получить экземпляр Connection с БД, которое используе модель
  > getConnectionName       | получить имя соединения с БД, которое используе модель
  > setConnection           | назначить, какое соединение с БД использовать модели

  > resolveConnection       | создать экземпляр Connection для указанного имени соединения
  > getConnectionResolver   | создать новый экземпляр класса ConnectionResolver
  > setConnectionResolver   | установить экземпляр ConnectionResolver
  > unsetConnectionReslover | снять экземпляр ConnectionResolver

  /////------------------------------------/////
  /////        Работа с событиями          /////
  /////------------------------------------/////

  > saving                  | зарегистрировать событие "модель сохраняется" в диспетчере
  > saved                   | зарегистрировать событие "модель сохранена" в диспетчере
  > updating                | зарегистрировать событие "модель обновляется" в диспетчере
  > updated                 | зарегистрировать событие "модель обновлена" в диспетчере
  > creating                | зарегистрировать событие "модель создаётся" в диспетчере
  > created                 | зарегистрировать событие "модель создана" в диспетчере
  > deleting                | зарегистрировать событие "модель удаляется" в диспетчере
  > deleted                 | зарегистрировать событие "модель удалена" в диспетчере
  > flushEventListeners     | удалить все обработчики событий для модели
  > getObservableEvents     | получить список наблюдаемых событий модели
  > setObservableEvents     | назначить список наблюдаемых событий модели
  > addObservableEvents     | добавить значение в список наблюдаемых событий модели
  > removeObservableEvents  | удалить значение из списка наблюдаемых событий модели
  > getEventDispatcher      | получить экземпляр Dispatcher (диспетчер событий)
  > setEventDispatcher      | назначить экземпляр Dispatcher (диспетчер событий)
  > unsetEventDispatcher    | снять экземпляр Dispatcher (диспетчер событий)
  > observe                 | зарегистрировать класс-наблюдатель для модели

  /////------------------------------------/////
  /////        Работа со связями           /////
  /////------------------------------------/////

  > load                    | упреждающе загрузить связи для модели
  > with                    | указать связи для упреждающей загрузки для модели
  > hasOne                  | определить связь 1-1
  > morphOne                | определить полиморфную связь 1-1
  > belongsTo               | определить инверсную 1-1 или 1-много связь
  > morphTo                 | определить, полиморфную инверсную 1-1 или 1-много связь
  > hasMany                 | определить связь 1-много
  > hasManyThrough          |
  > morphMany               |
  > belongsToMany           |
  > morphToMany             |
  > morphedByMany           |
  > joiningTable            |
  > touchOwners             | тронуть (touch) владеющие связи модели
  > touches                 | определить, трогала ли модель указанные связи
  > getMorphClass           | получить имя класса для полиморфных связей
  > getTouchedRelations     | получить связи, которые трогали при сохранении
  > setTouchedRelations     | установить связи, которые трогать при сохранении
  > relationsToArray        | конвертировать связи модели в массив
  > getRelations            | получить массив всех загруженных связей для экземпляра
  > getRelation             | получить указанную связь
  > setRelation             | установить специальную связь для модели
  > setRelations            | установить массив спец.связей для модели

  /////------------------------------------/////
  /////              Прочее                /////
  /////------------------------------------/////

  > newPivot                | создать новый экземпляра класса Pivot
  > getPerPage              | узнать, сколько моделей возвращать на каждую страницу
  > setPerPage              | назначить, сколько моделей возвращать на каждую страницу
  > getForeignKey           | получить имя внешнего ключа по умолчанию для модели
  > getHidden               | получить скрытые атрибуты модели
  > setHidden               | установить скрытые атрибуты модели
  > setVisible              | установить видимые атрибуты модели

  > newQueryWithoutScope    | получить новый query builder для таблицы модели, без указанного global scope
  > newQueryWithoutScopes   | получить новый query builder для таблицы модели, вообще без global scope
  > applyGlobalScopes       | применить global scopes
  > removeGlobalScopes      | удалить global scopes





--------------------------------



///////////////////////===============================///////////////////////
///////////////////////                               ///////////////////////
///////////////////////    Builder (query builder)    ///////////////////////
///////////////////////                               ///////////////////////
///////////////////////===============================///////////////////////


|---------------------------------------------------------
| > get()
|---------------------------------------------------------
| - Выполнить запрос, как выражение SELECT
| - Collection|Builder[] get(array $columns = array('*'))

  - Найти строки, у которых в столбце 'votes' значение > 100,
    извлечь первые 10 из найденных, и вернуть их в виде массива
    экземпляров модели:

      $users = User::where('votes', '>', 100)->take(10)->get();


|---------------------------------------------------------
| > find()
|---------------------------------------------------------
| - Найти 1 модель по её первичному ключу
| - Model|Builder|null find(mixed $id, array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получить пользователя с id == 235

      $user = User::find(235);

  - При конвертации в строку, $user автоматом сконвертируется в JSON-строку.
  - Например:

      echo $user;   // {"id":235,"name":"ivan"}

  - А если передать функции массив, то работает также, как findMany:

      $user = User::find(array(235, 17));
      echo $user;   // [{"id":235,"name":"ivan"},{"id":17,"name":"petro"}]


|---------------------------------------------------------
| > findMany()
|---------------------------------------------------------
| - Найти >=1 модель по её первичному ключу
| - Model|Collection|Builder findMany(array $id, array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получить Collection пользователей с id == 235, и с ID == 17

      $user = User::findMany(array(235, 17));

  - При конвертации в строку, $user автоматом сконвертируется в JSON-строку.
  - Например:

      echo $user;   // [{"id":235,"name":"ivan"},{"id":17,"name":"petro"}]


|---------------------------------------------------------
| > findOrFail()
|---------------------------------------------------------
| - найти 1 модель по её первич.ключу, если не найдено - возбудить исключение
| - Model|Builder findOrFail(mixed $id, array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получить пользователя с несуществующим id == 555

      $user = User::findOrFail(555);  // Ошибка 500. No query results for model [M1_routes].

  - А если просто find?

      $user = User::find(555);  // null


|---------------------------------------------------------
| > first()
|---------------------------------------------------------
| - выполнить запрос и вернуть 1-й результат
| - Model|Builder|null first(array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получим модель первого пользователя:

      $firstuser = User::first();



|---------------------------------------------------------
| > firstOrFail()
|---------------------------------------------------------
| - выполнить запрос и вернуть 1-й результат, а если его нет - возбудить исключение
| - Model|Builder firstOrFail(array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Найдём все экземпляры, у которых id >= 555 (таких не существует).
  - И извлечём первый из них:

      $user = User::where('id', '>=', '9')->firstOrFail();  // Ошибка 500. No query results for model [M1_routes].

  - А если просто first?

      $user = User::where('id', '>=', '9')->firstOrFail();  // null


|---------------------------------------------------------
| > where()
|---------------------------------------------------------
| - добавить атрибут where к запросу
| - $this where(string $column, string $operator = null, mixed $value = null, string $boolean = 'and')

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Найдём все экземпляры, у которых id >= 9.

      $user = User::where('id', '>=', '9')->get();
      echo $user;   // [{"id":9,"name":"ivan"},{"id":10,"name":"petro"}]


|---------------------------------------------------------
| > orWhere()
|---------------------------------------------------------
| - одновременное использование нескольких where
| - Builder|Builder orWhere(string $column, string $operator = null, mixed $value = null)

  - Пусть у нас есть модель пользователей Users.
  - В этой таблице есть столбцы:  id   name
  - Из этой таблицы извлечь все экземпляры, у которых:

      Или: id >= 9,
      Или: name == 'Иван'

  - Т.Е. будут извлечены все экземпляры, подходящие под любое из условий.
  - Ищем:

      $user = User::where('id', '>=', '9')
                          ->orWhere('name', '==', 'Иван')
                          ->orWhere('name', '==', 'Пётр')
                          ->orWhere('age', '>=', '18')
                          ->get();

      echo $user;   // [{"id":5,"name":"Иван"},{"id":10,"name":"Петро"}]


|---------------------------------------------------------
| > delete()
|---------------------------------------------------------
| - удалить запись из базы данных
| - mixed delete()

  - Удалить пользователя с id == 235 из таблицы:

      $user = User::find(235);
      $user->delete();

  - Удалить из таблицы всех пользователей с ID >= 5:

      $users = User::where('id', '>=', '5');
      $users->delete();

  *Примечание по помоду мягкого удаления:
    - Если в модели User включено soft delete..
    - .. то операция delete не будет удалять соотв. записи.
    - Вместо этого им в столбце deleted_at будут проставлены свешие timestamp.
    - А чтоб уж наверняка удалить, надо использовать forceDelete().


|---------------------------------------------------------
| > forceDelete()
|---------------------------------------------------------
| - запустить функцию удаления записи в таблице "по умолчанию" для удаления
| - mixed forceDelete()

  - Наверняка удалить пользователя с id == 235 из таблицы:

      $user = User::find(235);
      $user->forceDelete();

  - Наверняка удалить из таблицы всех пользователей с ID >= 5:

      $users = User::where('id', '>=', '5');
      $users->forceDelete();


|---------------------------------------------------------
| > onDelete()
|---------------------------------------------------------
| - зарегистрировать замену для функции удаления записи из таблицы "по умолчанию"
| - void onDelete(Closure $callback)


    ?? не удалось найти рабочих примеров использования ??


|---------------------------------------------------------
| > update()
|---------------------------------------------------------
| - обновить запись в базе данных
| - int update(array $values)

  - Пусть у нас есть модель пользователей Users.
  - И в ней есть строка с id == 9, и name == 'Иван'.
  - Изменим в ней name на 'Пётр':

      $user = User::where('id', '=', '9');
      $user->update(array('name' => 'Пётр'));


|---------------------------------------------------------
| > increment()
|---------------------------------------------------------
| - инкрементировать все поля указанного столбца указанным числом
| - int increment(string $column, int $amount = 1, array $extra = array())

  - Инкрементировать все поля в столбце 'age' таблицы users на 1:

      User::increment('age');

  - Инкрементировать все поля в столбце 'age' таблицы users на 5:

      User::increment('age', 5);


|---------------------------------------------------------
| > decrement()
|---------------------------------------------------------
| - декрементировать все поля указанного столбца указанным числом
| - int decrement(string $column, int $amount = 1, array $extra = array())

  - Декрементировать все поля в столбце 'age' таблицы users на 1:

      User::decrement('age');

  - Декрементировать все поля в столбце 'age' таблицы users на 5:

      User::decrement('age', 5);


|---------------------------------------------------------
| > pluck()
|---------------------------------------------------------
| - извлечь значение 1-го поля модели Model из указанной колонки
| - С Collection не работает, только с Model.
| - mixed pluck(string $column)

  - Найдём пользователя с id == 5, и извлечём его имя:

      $user = Users::find(5);
      $name = $user->pluck('name');

  - Но вообще то имя можно извлечь проще, вот так:

      $name = $user->name;


|---------------------------------------------------------
| > chunk()
|---------------------------------------------------------
| - извлечь данные из таблицы траншами по N штук
| - void chunk(int $count, callable $callback)
| - $count: размер транша
| - $callback: колбэк, в котором идёт обработка траншей

  - Допустим, есть у нас таблица Users, в которой 10000 записей.
  - И нам надо получить все эти записи.
  - Можно сделать это разом, в 1 операцию:

      $users = User::get();

  - Но тут есть риск, что у сервера просто не хватит оперативки.
  - Поэтому, возможно, есть смысл извлекать данные по кусочкам.
  - Например, по 500 записей за 1 раз. Сделаем это:

    - Создадим новую коллекцию Collection:

        $results = new Illuminate\Database\Eloquent\Collection();

    - Будем извлекать юзеров по 500 штук, и добавлять в $users.
    - Будет 10000/500 = 20 операций извлечения по 500 штук.

        User::chunk(500, function($users_chunk) use (&$results){

          // Здесь мы перебираем коллекцию $users_chunk, и добавляем юзеров в $users
          foreach ($users_chunk as $user)
          {
              $results->add($user);   // и так 500 раз на каждом транше
          }

        });

    - Вулаля, у нас в $users коллекция пользователей из 10000 штук.


|---------------------------------------------------------
| > lists()
|---------------------------------------------------------
| - извлечь массив значений из указанной колонки
| - array lists(string $column, string $key = null)
| - $column: колонка
| - $key: ? (не понятно зачем нужен)

  - Допустим, есть у нас таблица Users, с колонками id и name.
  - Извлечём из неё массив всех значений в колонке name:

      $names = Users::lists('name');  // array (size=4)
                                           0 => string 'Иван' (length=4)
                                           1 => string 'Пётр' (length=4)
                                           2 => string 'Жора' (length=4)
                                           3 => string 'Коля' (length=4)


|---------------------------------------------------------
| > paginate()
|---------------------------------------------------------
| - получить Paginator для результата запроса с N значениями на страницу
| - Paginator paginate(int $perPage = null, array $columns = array('*'))

  См. справочный документ "8. Paginator"


|---------------------------------------------------------
| > simplePaginate()
|---------------------------------------------------------
| - получить простой Paginator для результата запроса с N значениями на страницу, поддерживающий только prev и next
| - Paginator simplePaginate(int $perPage = null, array $columns = array('*'))

  См. справочный документ "8. Paginator"


|---------------------------------------------------------
| > with()        | указать связь, для которой должна сработать упреждающая загрузка
| > has()         | добавить условие-счётчик-связей в запрос
| > whereHas()    | добавить условие-счётчик-связей в запрос с атрибутами where
| > orHas()       | добавить условие-счётчик-связей в запрос с атрибутами or
| > orWhereHas()  | добавить условие-счётчик-связей в запрос с атрибутами where и or
|---------------------------------------------------------
| - Это всё методы для работы с упреждающей загрузкой и связями
| - Эти темы хорошо описаны в справочном документе "laravel.txt".
| - См. следующие его главы:
|
|   12.8. Запросы с использованием связей       | has, whereHas
|   12.9. Упреждающая загрузка (Eager Loading)  | with
|





///////////////////////===============================///////////////////////
///////////////////////                               ///////////////////////
///////////////////////           Collection          ///////////////////////
///////////////////////                               ///////////////////////
///////////////////////===============================///////////////////////


|---------------------------------------------------------
| > first()
|---------------------------------------------------------
| - получить самый 1-й элемент коллекции
| - mixed|null first(Closure $callback = null, mixed $default = null)

  - Извлечём 1-го пользователя из модели Users:

      $firstUser = Users::all()->first();


|---------------------------------------------------------
| > last()
|---------------------------------------------------------
| - получить последний элемент в коллекции
| - mixed|null last()

  - Извлечём последнего пользователя из модели Users:

      $lastUser = Users::all()->last();


|---------------------------------------------------------
| > find()
|---------------------------------------------------------
| - найти модель в коллекции по указанному первичному ключу
| - Model find(mixed $key, mixed $default = null)

  - Допустим, у нас есть модель Users с пользователями.
  - В ней столбец ID используется в качестве первичного ключа.
  - Извлечём пользователя с ID = 37:

      $user = Users::all()->find('37');


|---------------------------------------------------------
| > get()
|---------------------------------------------------------
| - извлечь из коллекции элемент по указанному ключу (как у массива)
| - mixed get(mixed $key, mixed $default = null)
| - ключ: не какой-то столбец, а ключ, как у массива.
| - не особо нужная функция.

  - Допустим, у нас есть модель Users с пользователями.
  - Получим коллекцию всех элементов этой модели:

      $users = Users::all();

  - Первый эл-т в коллекции имеет ключ "0". Второй: "1". Третий: "2". И т.д.
  - Извлечём 1-й элемент коллекции:

      $user = $users::get('0');


|---------------------------------------------------------
| > fetch()
|---------------------------------------------------------
| - получить элемент коллекции с указанным ключём
| - Collection fetch(string $key)

  .. Примеров работы этой функции найти не удалось ..


|---------------------------------------------------------
| > all()
|---------------------------------------------------------
| - получить из модели коллекцию всех элементов
| - array all()

  - Допустим, у нас есть модель Users с пользователями.
  - Получим коллекцию всех элементов этой модели:

      $users = Users::all();


|---------------------------------------------------------
| > take()
|---------------------------------------------------------
| - взять подколлекцию из первых/последних N эл-в коллекции
| - Collection take(int $limit = null)
| - Первые: надо указать положительный $limit. Например, 10.
| - Последние: надо указать отрицательный $limit. Например, -10.

  - Допустим, у нас есть модель Users с пользователями.
  - Получим подколлекцию 10 первых элементов этой модели.
  - И извлечём из неё подколлекцию из первых 10 элементов:

      $users_first10 = Users::all()->take(10);

  - Получим подколлекцию из 10 последних элементов коллекции

      $users_last10 = Users::all()->take(-10);


|---------------------------------------------------------
| > unique()
|---------------------------------------------------------
| - вернуть коллекцию лишь из уникальных эл-в коллекции
| - Collection unique()

  - Допустим, у нас есть модель Users с пользователями.
  - И в ней есть повторяющиеся пользователи.
  - Получим коллекцию, из которой повторения исключены:

      $unique = Users::all()->unique();


|---------------------------------------------------------
| > only()
|---------------------------------------------------------
| - получить подколлекцию только с эл-ми с указанными первичными ключами
| - Collection only(mixed $keys)
| - $keys: массив первичных ключей, например: array(9,11,13)

  - Допустим, у нас есть модель Users с пользователями.
  - Первичным ключём в этой модели является столбец ID.
  - Получим подколлекцию, состоящую из пользователей с ID: 9, 11, 13

      $subcollection = Users::all()->only(array(9,11,13));


|---------------------------------------------------------
| > except()
|---------------------------------------------------------
| - получить подколлекцию всех эл-в, кроме чьи ключи указаны
| - Collection except(mixed $keys)
| - $keys: массив первичных ключей, например: array(9,11,13)

  - Допустим, у нас есть модель Users с пользователями.
  - Первичным ключём в этой модели является столбец ID.
  - Пусть в коллекции есть эл-ты с ID от 0 до 10.
  - Получим подколлекцию, состоящую из всех их, кроме тек, что с ID: 5,7,10:

      $subcollection = Users::all()->only(except(5,7,10));


|---------------------------------------------------------
| > groupBy
|---------------------------------------------------------
| - получить сгруппированную по указанному столбцу коллекцию
| - Collection groupBy(callable|string $groupBy)
| - $groupBy: по какому столбцу производить группировку?

  - Допустим, у нас есть модель Users с пользователями.
  - В ней есть столбец 'name'.
  - А среди пользователе есть такие, у которых одинаковые имена.
  - Получим коллекцию, в которой пользователи сгруппированы по столбцу 'name':

      $subcollection = Users::all()->groupBy('name');

  - Пример.

    - Пусть у нас есть такая вот таблица Users:

      id      name      age
      ---------------------
      1       Иван      18
      2       Пётр      19
      3       Иван      21
      4       Пётр      16
      5       Лена      14

    - Если просто извлечь из неё коллекцию и преобразовать в массив:

        $array = Users::all()->toArray();

    - То мы получим такой результат:

        array(size=6)

          0 =>                  1 =>                  2 =>
            array (size=3)        array (size=3)        array (size=3)
              'id'    =>  1         'id'    =>  2         'id'    =>  3
              'name'  =>  Иван      'name'  =>  Пётр      'name'  =>  Иван
              'age'   =>  18        'age'   =>  19        'age'   =>  21

          3 =>                  4 =>
            array (size=3)        array (size=3)
              'id'    =>  4         'id'    =>  5
              'name'  =>  Пётр      'name'  =>  Лена
              'age'   =>  16        'age'   =>  14

    - А если мы сгруппируем коллекцию по столбцу 'name' и преобразуем в массив:

        $array = Users::all()->groupBy('name')->toArray();

    - То мы получим такой результат:

        array(size=3)

          'Иван' =>
            array(size=2)
              0 => object   // Иван с id == 1
              1 => object   // Иван с id == 3

          'Пётр' =>
            array(size=2)
              0 => object   // Пётр с id == 2
              1 => object   // Пётр с id == 4

          'Пётр' =>
            array(size=1)
              0 => object   // Лена с id == 5


|---------------------------------------------------------
| > slice
|---------------------------------------------------------
| - извлечь подколлекцию
| - Collection slice(int $offset, int $length = null, bool $preserveKeys = false)
| - $offset: смещение от начала коллекции
| - $length: размер подколлекции, которую надо извлечь
| - $preserveKeys: сохранить ли в подколлекции старые ключи для элементов?

  - Допустим, у нас есть модель Users с пользователями.
  - Извлечём подколлекцию из 1-ых 2-х пользователей:

      $users = Users::all()->slice(0, 2);

  - Извлечём подколлекцию из 3-го и 4-го пользователей:

      $users = Users::all()->slice(2, 2);


|---------------------------------------------------------
| > intersect
|---------------------------------------------------------
| - из 2-х коллекций получить 2-ну, с НЕ уникальными эл-ми
| - Collection intersect(ArrayAccess|array $items)

  [.. пример по требованию ..]



|---------------------------------------------------------
| > diff
|---------------------------------------------------------
| - из 2-х коллекций получить 1-ну, с уникальными эл-ми
| - Collection diff(ArrayAccess|array $items)

  [.. пример по требованию ..]



|---------------------------------------------------------
| > prepend
|---------------------------------------------------------
| - добавить (push) эл-т в начало коллекции
| - void prepend(mixed $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Добавим в начало этой коллекции элемент со значением 10:

      $all->prepend(10);

  - Теперь в эл-те с индексом 0 лежит число 10:

      $value = $all->get(0);    // 10


|---------------------------------------------------------
| > push
|---------------------------------------------------------
| - добавить (push) эл-т в конец коллекции
| - void push(mixed $value)

  - Пусть у нас есть коллекция Users длиной 5 элементов (посл.индекс 4)
  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Добавим в конец этой коллекции элемент со значением 10:

      $all->push(10);

  - Теперь в эл-те с индексом 5 лежит число 10:

      $value = $all->get(5);    // 10


---------------------------------------------------------
| > shift
|---------------------------------------------------------
| - удалить 1-й эл-т коллекции, и вернуть его
| - mixed|null shift()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Удалим 1-й элемент из коллекции $all:

      $all->shift();


---------------------------------------------------------
| > pop
|---------------------------------------------------------
| - удалить последний эл-т из коллекции, и вернутье его
| - mixed|null pop()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Удалим последний элемент из коллекции $all:

      $all->pop();


---------------------------------------------------------
| > merge
|---------------------------------------------------------
| - объединить указанные эл-ты с коллекцией
| - Collection merge(ArrayAccess|array $items)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получим подколлекцию первых 2-х пользователей:

      $firstTwo = $all->take(2);

  - Получим подколлекцию последних 2-х пользователей:

      $lastTwo = $all->take(-2);

  - Объединим $lastTwo с $firstTwo именно в таком порядке:

      $result = $lastTwo->merge($firstTwo);


---------------------------------------------------------
| > pull
|---------------------------------------------------------
| - извлечь и вернуть эл-т с указанным ключём из коллекции (удалив)
| - mixed pull(mixed $key, mixed $default = null)
| - имеется в виду НЕ первич.ключ, а именно индекс массива в коллекции

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Извлечём из коллекции элемент с индексом 0:

      $item = $all->pull(0);


---------------------------------------------------------
| > put
|---------------------------------------------------------
| - втиснуть элемент в коллекцию, указав ключ
| - void put(mixed $key, mixed $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Допустим, в коллекции вот такие данные:

      Индекс в массиве коллекции    значение
      ---------------------------------------------------
      0                             Иван
      1                             Пётр
      2                             Лена
      3                             Ира
      4                             Коля

  - А нам надо втиснуть Васю с индексом 3, между Леной и Ирой.
  - Здесь нам и поможет put:

      $all->put('Вася');

  - В итоге коллекция выглядит так:

      Индекс в массиве коллекции    значение
      ---------------------------------------------------
      0                             Иван
      1                             Пётр
      2                             Лена
 !!!  3                             Вася
      4                             Ира
      5                             Коля


---------------------------------------------------------
| > add
|---------------------------------------------------------
| - добавить элемент в конец коллекции
| - $this add(mixed $item)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Добавим в конец коллекции значение 10:

      $all->add(10);


---------------------------------------------------------
| > forget
|---------------------------------------------------------
| - удалить эл-т с указанным ключём из коллекции
| - void forget(mixed $key)
| - это аналог pull, но в отличие от него удалённый эл-т не возвращает

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Удалим из коллекции элемент с индексом 0:

      $all->forget(0);


---------------------------------------------------------
| > splice
|---------------------------------------------------------
| - позволяет удалить/вставить на их место эл-ты
| - Collection splice(int $offset, int $length, mixed $replacement = array())
| - $offset: смещениею
| - $length: кол-во элементов, которые надо удалить
| - $replacement: массив элементов, которые надо вставить вместо удалённых

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получим подколлекцию первых 2-х пользователей:

      $firstTwo = $all->take(2);

  - Удалим 3 и 4 пользователей, и на их место вставим первых двух.
  - Т.Е. первые 2 пользователя повторянся на 3 и 4 местах коллекции:

      $all->splice(2,2, array( $firstTwo->get(0), $firstTwo->get(1) ));


---------------------------------------------------------
| > sort
|---------------------------------------------------------
| - сортировать коллекцию с помощью callback
| - $this sort(Closure $callback)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Отсортируем пользователей по возрасту в прямом порядке:

      $all->sort(function($a, $b) {

        $a = $a->age;
        $b = $b->age;

        if($a > $b) return 1;
        if($a < $b) return -1;
        return 0;

      });

  - Отсортируем пользователей по возрасту в обратном порядке:

      $all->sort(function($a, $b) {

        $a = $a->age;
        $b = $b->age;

        if($a < $b) return 1;
        if($a > $b) return -1;
        return 0;

      });


---------------------------------------------------------
| > sortBy
|---------------------------------------------------------
| - сортировать коллекцию по указанному столбцу стандартным алгоритмом
| - $this sortBy(Closure|string $callback, int $options = SORT_REGULAR, bool $descending = false)
| - $callback: по какому столбцу сортировать
| - $descending: сортировать ли в обратном порядке, true / false (по умолчанию).

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Отсортируем в прямом порядке по столбцу age:

      $all->sortBy('age');

  - Отсортируем в обратном порядке по столбцу age:

      $all->sortBy('age', SORT_REGULAR, true);


---------------------------------------------------------
| > sortByDesc
|---------------------------------------------------------
| - сортировать коллекцию по указанному столбцу стандартным алгоритмом
| - $this sortBy(Closure|string $callback, int $options = SORT_REGULAR, bool $descending = false)
| - $callback: по какому столбцу сортировать
| - $descending: сортировать ли в обратном порядке, true / false (по умолчанию).

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Отсортируем в обратном порядке по столбцу age:

      $all->sortByDesc('age');

  - Отсортируем в прямом порядке по столбцу age:

      $all->sortByDesc('age', SORT_REGULAR, true);


---------------------------------------------------------
| > each
|---------------------------------------------------------
| - выполнить callback для каждого эл-та коллекции
| - $this each(Closure $callback)
| - это тоже самое, что map, но в отличие от него меняет исходный массив

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Увеличим значение в столбце 'age' для каждого из пользователей на 1:

      $all->each(function($item){

        $item->age++;

      });


---------------------------------------------------------
| > map
|---------------------------------------------------------
| - возвращает коллекцию из элементов, обработанных и возвращенных callback-функцией
| - Collection map(Closure $callback)
| - это тоже самое, что each, но в отличие от него НЕ меняет исходный массив

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получим новую подколлекцию.
  - В ней увеличим значение в столбце 'age' для каждого из пользователей на 1:

      $anotherAll = $all->map(function($item){

        $item->age++;

      });


---------------------------------------------------------
| > filter
|---------------------------------------------------------
| - отфильтровать коллекцию с помощью callback
| - Collection filter(Closure $callback)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Отфильтровать всех пользователей возрастом менее 18 лет:

      $all->filter(function($item){

        if($item->age >= 18) return true;

      });


---------------------------------------------------------
| > reject
|---------------------------------------------------------
| - это filter наоборот
| - Collection reject(Closure|mixed $callback)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Отфильтровать всех пользователей возрастом менее 18 лет:

      $all->filter(function($item){

        if($item->age <=18) return true;

      });


---------------------------------------------------------
| > transform
|---------------------------------------------------------
| - трансформировать каждый эл-т коллекции, используя callback
| - $this transform(Closure $callback)

  .. примеров использования не нашёл ..


---------------------------------------------------------
| > sum
|---------------------------------------------------------
| - пробежаться по эл-м коллекции и просуммировать возвращаемые callback-функцией значения
| - mixed sum(Closure $callback)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Просуммируем возрасты всех пользователей:

      $sum = $all->sum(function($item){

        return $item->age;

      });


---------------------------------------------------------
| > jsonSerialize
|---------------------------------------------------------
| - конвертировать объект-коллекцию в массив, который можно преобразовать в json
| - array jsonSerialize()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить массив, готовый к преобразованию в json:

      $result = $all->jsonSerialize();


---------------------------------------------------------
| > toArray
|---------------------------------------------------------
| - преобразовать коллекцию в простой массив
| - array toArray()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Преобразовать $all в простой массив:

      $result = $all->toArray();


---------------------------------------------------------
| > toJson
|---------------------------------------------------------
| - конвертировать коллекцию сразу в json-строку
| - string toJson(int $options)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Преобразовать $all в json-стоку:

      $result = $all->toJson();


---------------------------------------------------------
| > contains
|---------------------------------------------------------
| - есть ли в коллекции элемент с указанным первичным ключём
| - bool contains(mixed $key)

  - Пусть у нас есть модуль пользователей Users.
  - Первичным ключём в этой модели является столбец ID.
  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Проверим, есть ли в $all пользователь с ID == 9

      $is = $all->contains(9);    // [true | false]


---------------------------------------------------------
| > has
|---------------------------------------------------------
| - есть ли в коллекции элемент с указанным ключём (не первичным, а массива коллекции)
| - bool has(mixed $key)

  - Пусть у нас есть модуль пользователей Users.
  - Первичным ключём в этой модели является столбец ID.
  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Проверим, есть ли в $all элемент с ключём 0 (1-й элемент в коллекции):

      $is = $all->has(9);    // [true | false]


----------------------------------------------------------
| > isEmpty
|---------------------------------------------------------
| - пуста ли коллекция
| - bool isEmpty()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Проверим, пуста ли она:

      $is = $all->isEmpty();    // [true | false]


----------------------------------------------------------
| > count
|---------------------------------------------------------
| - количество элементов в коллекции
| - int count()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Узнаем, сколько элементов в $all:

      $count = $all->count();


----------------------------------------------------------
| > max
|---------------------------------------------------------
| - получить максимально значение по указанному столбцу
| - mixed max(string $key)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Узнаем, сколько лет самому старшему пользователю:

      $age = $all->max('age');


----------------------------------------------------------
| > min
|---------------------------------------------------------
| - получить минимальное значение по указанному столбцу
| - mixed min(string $key)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Узнаем, сколько лет самому младшему пользователю:

      $age = $all->min('age');


----------------------------------------------------------
| > search
|---------------------------------------------------------
| - искать в коллекции указанный элемент, и получить его индекс (в случ.успеха)
| - mixed search(mixed $value, bool $strict = false)
| - В случае успеха возвращает индекс найденного эл-та. В противном случае false.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получим последний элемент коллекции:

      $last = $all->last();

  - Получим индекс последнего элемента коллекции:

      $lastElementIndex = $all->search($last);


----------------------------------------------------------
| > reverse
|---------------------------------------------------------
| - изменить на обратный порядок эл-в в коллекции
| - Collection reverse()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить такую же коллекцию, но с обратным порядком элементов:

      $all_reversed = $all->reverse();


----------------------------------------------------------
| > shuffle
|---------------------------------------------------------
| - перемешать элементы в коллекци
| - $this shuffle()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Перемешать элементы в произвольном порядке в $all

      $all->shuffle();


----------------------------------------------------------
| > random
|---------------------------------------------------------
| - извлечь случайным образом 1 (Model) или более (Collection) эл-в из коллекции
| - mixed random(int $amount = 1)
| - $amount: сколько надо извлечь элемент
| - Если извлекать > 1 элемента, то возвращает массив извлечённых эл-в.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Извлечь случайным образом 1 элемент из $all:

      $item = $all->random();     // извлечённый эл-т

  - Извлечь случайным образом коллекцию из 5 элементов из $all:

      $items = $all->random(5);   // массив извлечённых эл-в


----------------------------------------------------------
| > flip
|---------------------------------------------------------
| - поменять местами ключи и значения всех эл-в коллекции
| - Collection flip()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Создать новую коллекцию, аналог $all, только ключи и значения поменять местами:

      $all_flipped = $all->flip();


----------------------------------------------------------
| > values
|---------------------------------------------------------
| - сбросить ключи в коллекции
| - Collection values()
| - Полезно применять после взятия подколлекции, т.к. при этом ключи путаются.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Возьмём подколлекцию $all, отфильтруем всех, кого зовут не 'Иван':

      $sub = $all->filter(function($item){
        return $item->name == 'Иван';
      });

  - Теперь в $sub все ключи коллекции перепутаны.
  - Т.Е. они не идут как надо: 0,1,2,3 ...
  - А вместо этого там что-то вроде: 3,5,7,29,63
  - Чтобы исправить положение, применим value():

      $sub = $sub->value();

  - Теперь с ключами порядок: 0,1,2,3 ...




  ... делать примеры по требованию ...

  > make                | создать новую Collection, если value уже не 1-но
  > keys                | получить массив ключей всех элементов коллекции
  > modelKeys           | получить массив первичных ключей
  > collapse            | свернуть коллекцию в один массив
  > flatten             | преобразовать многомерный массив коллекции в одномерный
  > keyBy               | ?
  > implode             | объединить значения в строку, склеив строкой glue
  > lists               | ?
  > reduce              | ументшить коллекцию до 1 значения
  > chunk               | ?
  > load                | ?




///////////////////////===============================///////////////////////
///////////////////////                               ///////////////////////
///////////////////////             Model             ///////////////////////
///////////////////////                               ///////////////////////
///////////////////////===============================///////////////////////


----------------------------------------------------------
| > incrementing
|---------------------------------------------------------
| - включёно ли у модели авто-инкрементирование? [true/false]
| - bool $incrementing

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, включено ли авто-инкрементирование у этой модели:

      $is = $user->incrementing;


----------------------------------------------------------
| > timestamps
|---------------------------------------------------------
| - включено ли у модели авто-обслуж.столбцов 'updated_at', 'created_at'? [true/false]
| - bool $timestamps

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, включено ли авто-обслуживание столбцов 'updated_at', 'created_at'?

      $is = $user->incrementing;


----------------------------------------------------------
| > exists
|---------------------------------------------------------
| - существует ли модель? [true/false]
| - bool $exists

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, существует ли модель?

      $is = $user->exists;


----------------------------------------------------------
| > snakeAttributes
|---------------------------------------------------------
| - указывает, используются ли snakeCased имена колонок в модели
| - static bool $snakeAttributes

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, используются ли snakeCased имена колонок в модели:

      $is = $user->snakeAttributes;


----------------------------------------------------------
| > manyMethods
|---------------------------------------------------------
| - получить массив many-to-many связей
| - static array $manyMethods

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить массив many-to-many связей:

      $is = $user->manyMethods;


----------------------------------------------------------
| > toJson
|---------------------------------------------------------
| - конвертировать модель в json-строку
| - string toJson(int $options)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Конвертировать модель в json-строку:

      $json =  $user->toJson();


----------------------------------------------------------
| > jsonSerialize
|---------------------------------------------------------
| - конвертировать модель в массив, который можно преобразовать в json
| - array jsonSerialize()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Конвертировать модель в готовый к json-сериализации массив:

      $arr =  $user->jsonSerialize();


----------------------------------------------------------
| > toArray
|---------------------------------------------------------
| - конвертировать модель в массив
| - array toArray()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Конвертировать модель в массив:

      $arr =  $user->toArray();


----------------------------------------------------------
| > attributesToArray
|---------------------------------------------------------
| - конвертировать атрибуты модели в массив
| - array attributesToArray()
| - *Примечание: никакого отличия от toArray() я пока не вижу.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Конвертировать атрибуты модели в массив:

      $arr =  $user->toArray();


|---------------------------------------------------------
| > all()
|---------------------------------------------------------
| - получить из модели коллекцию всех элементов
| - array all()

  - Допустим, у нас есть модель Users с пользователями.
  - Получим коллекцию всех элементов этой модели:

      $users = Users::all();


|---------------------------------------------------------
| > find()
|---------------------------------------------------------
| - Найти 1 модель по её первичному ключу
| - Model|Builder|null find(mixed $id, array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получить пользователя с id == 235

      $user = User::find(235);

  - При конвертации в строку, $user автоматом сконвертируется в JSON-строку.
  - Например:

      echo $user;   // {"id":235,"name":"ivan"}

  - А если передать функции массив, то работает также, как findMany:

      $user = User::find(array(235, 17));
      echo $user;   // [{"id":235,"name":"ivan"},{"id":17,"name":"petro"}]


|---------------------------------------------------------
| > findOrNew()
|---------------------------------------------------------
| - найти модель по её первичному ключу, или вернуть новую статическую
| - public Collection|Model findOrNew(mixed $id, array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получить пользователя с несуществующим id == 555

      $user = User::findOrNew(555);  // Т.К. такого нет, создаётся новый


|---------------------------------------------------------
| > findOrFail()
|---------------------------------------------------------
| - найти 1 модель по её первич.ключу, если не найдено - возбудить исключение
| - Model|Builder findOrFail(mixed $id, array $columns = array('*'))

  - Пусть у нас есть модель пользователей Users.
  - Столбец id является первичным ключём модели.
  - Получить пользователя с несуществующим id == 555

      $user = User::findOrFail(555);  // Ошибка 500. No query results for model [M1_routes].

  - А если просто find?

      $user = User::find(555);  // null


|---------------------------------------------------------
| > save()
|---------------------------------------------------------
| - сохранить модель в базе данных
| - bool save(array $options = array())

  # Сохраниние экземпляра в БД производится методом save():

      // Создать новый объект-экземпляр модели User
        $user = new User;

      // Инициализировать св-во 'name' в созданном объекте:
        $user->name = 'John';

      // Сохранить созданный экземпляр в таблице БД:
        $user->save();

  # Изменение данных в БД через модель
    - Принцип простой: извлечь, изменить, запихнуть обратно.
    - Сначала находим в таблице БД нужную строку, извлекаем её
      в виде экземпляра модели.
    - Изменяем этот экземпляр как хотим.
    - Сохраняем его обратно в БД с помощью save().

        // Получить экземпляр модели, представляющий нужную строку таблицы БД
          $user = User::find(1);

        // Внести нужные изменения
          $user->email = 'john@foo.com';

        // Сохранить этот экземпляр обратно в БД
          $user->save();


|---------------------------------------------------------
| > push()
|---------------------------------------------------------
| - сохранить модель и все её связи в БД
| - bool push()

  - Сохраниние экземпляра в БД производится методом save():

      // Создать новый объект-экземпляр модели User
        $user = new User;

      // Инициализировать св-во 'name' в созданном объекте:
        $user->name = 'John';

      // Сохранить созданный экземпляр и все его связи в таблице БД:
        $user->push();


|---------------------------------------------------------
| > create()
|---------------------------------------------------------
| - создать новую модель и вернуть ссылку
| - public Model create(array $attributes)

|---------------------------------------------------------
| > firstOrCreate()
|---------------------------------------------------------
| - извлечь 1-ю запись, соотв-юю указанным атрибутам, или создать ей
| - public Model firstOrCreate(array $attributes)

|---------------------------------------------------------
| > firstOrNew()
|---------------------------------------------------------
| - извлечь 1-ю запись, соотв-юю указанным атрибутам, или экземпляризировать её
| - public Model firstOrNew(array $attributes)

  - Вот здесь как раз используется 'mass assignment'.
  - Конструктору класса-модели передаётся массив значений.
  - И он используется для инициализации св-ва экземпляра методом 'mass assignment'.
  - Но как известно, по умолчанию все св-ва находятся в guarded-списке.
  - Поэтому, чтобы их можно было инициализировать методом 'mass assignment'
    в функции create, надо сначала добавить их в fillable-список, как
    описано выше.

      //  Создать новый экземпляр модели и добавить его в БД как
          строку таблицы.

            $user = User::create(array('name' => 'John'));

      //  Найти в таблице БД все строки, в которых в столбце 'name'
          значение 'John'. Из них выбрать первую, превратить её в
          экземпляр модели и вернуть. А если ничего не найдено, то
          создать новый экземпляр модели и добавить его в БД как строку
          таблицы:

            $user = User::firstOrCreate(array('name' => 'John'));

      //  Найти в таблице БД все строки, в которых в столбце 'name'
          значение 'John'. Из них выбрать первую, превратить её в
          экземпляр модели и вернуть. А если ничего не найдено, то
          создать новый экземпляр модели и вернуть его:

            $user = User::firstOrNew(array('name' => 'John'));

|---------------------------------------------------------
| > update()
|---------------------------------------------------------
| - обновить модель в базе данных
| - bool|int update(array $attributes = array())

  # Изменение сразу нескольких строк с помощью функции update из 'query builder'
    - Найти в таблице все строки, у которых в столбце 'votes' значение
      > 100. И изменить в них в столбце 'status' значение на 2:

        $affectedRows = User::where('votes', '>', 100)->update(array('status' => 2));


|---------------------------------------------------------
| > delete()
|---------------------------------------------------------
| - удалить модель из базы данных
| - bool|null delete()

|---------------------------------------------------------
| > destroy()
|---------------------------------------------------------
| - уничтожить модели с указанными ID
| - int destroy(array|int $ids)

  # delete()  - удалить экземпляр модели из таблицы БД

    //  Получить экземпляр, представляющий строку таблицы, которую
        требуется удалить
      $user = User::find(1);

    //  Используя полученную ссылку удалить эту строку:
      $user->delete();

  # destroy()   - удалить >= 1 экземпляра модели из БД по id
    - Если известен id той строки, которую требуется удалить из таблицы БД,
      то удобнее пользоваться destroy(), чем delete().
    - Кроме того с помощь destroy() можно удалить несколько строк за раз.

    // Удалить из таблицы строку с id == 1
      User::destroy(1);

    // Удалить из таблицы строку с id == 1, 2, 3 (вариант 1)
      User::destroy(array(1, 2, 3));

    // Удалить из таблицы строку с id == 1, 2, 3 (вариант 2)
      User::destroy(1, 2, 3);

  # Удаление сразу нескольких строк с помощью функции delete из 'query builder'
    - Найти в таблице все строки, у которых в столбце 'votes' значение
      > 100. И удалить их.

        $affectedRows = User::where('votes', '>', 100)->delete();


|---------------------------------------------------------
| > getKey()
|---------------------------------------------------------
| - получить значение столбца - первичного ключа модели
| - mixed getKey()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить значение столбца - первичного ключа:

      $value = $user->getKey();


|---------------------------------------------------------
| > getKeyName()
|---------------------------------------------------------
| - получить имя столбца - первичного ключа модели
| - string getKeyName()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя столбца, который является первичным ключём:

      $primarykey_column_name = $user->getKeyName();    // 'id'


|---------------------------------------------------------
| > getQualifiedKeyName()
|---------------------------------------------------------
| - получить имя столбца - первичного ключа модели, квалифицированное именем таблицы
| - string getQualifiedKeyName()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя столбца - первичного ключа - квалифицированное именем таблицы:

      $name = $user->getQualifiedKeyName();   // "m1_routing.id"


|---------------------------------------------------------
| > getTable()
|---------------------------------------------------------
| - получить имя таблицы, ассоциированной с моделью
| - string getTable()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя таблицы, ассоциированной с моделью:

      $name = $user->getTable();   // "m1_routing"


|---------------------------------------------------------
| > setTable()
|---------------------------------------------------------
| - установить имя таблицы, ассоциированной с моделью
| - void setTable(string $table)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Назначить таблицу, которая будет ассоциирована с моделью, по имени:

      $name = $user->setTable('m1_routing');


|---------------------------------------------------------
| > getIncrementing()
|---------------------------------------------------------
| - инкрементируются ли ID? [true | false]
| - bool getIncrementing()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, включена ли инкрементация ID?

      $name = $user->getIncrementing();


|---------------------------------------------------------
| > setIncrementing()
|---------------------------------------------------------
| - вкл/выкл инкрементирование ID
| - void setIncrementing(bool $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Включить инкрементирование ID:

      $user->setIncrementing(true);

  - Выключить инкрементирование ID:

      $user->setIncrementing(false);


|---------------------------------------------------------
| > touch()
|---------------------------------------------------------
| - обновить updated_at timestamp модели
| - bool touch()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Обновить updated_at timestamp модели $user:

      $user->touch();


|---------------------------------------------------------
| > usesTimestamps()
|---------------------------------------------------------
| - определить, использует ли модель авто-проставку timestamp'ов 'updated_at', 'created_at'
| - bool usesTimestamps()
| - Возвращает true, если использует. В противном случае false.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Проверить, включено ли у модели автообновление столбцов 'updated_at', 'created_at':

      $is = $user->usesTimestamps();


|---------------------------------------------------------
| > setCreatedAt()
|---------------------------------------------------------
| - установить значение столбца 'created_at'
| - void setCreatedAt(mixed $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Установить значение столбца 'created_at' этой модели:

      $user->setCreatedAt('2013-07-06 21:44:48');


|---------------------------------------------------------
| > setUpdatedAt()
|---------------------------------------------------------
| - установить значение столбца 'updated_at'
| - void setUpdatedAt(mixed $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Установить значение столбца 'updated_at' этой модели:

      $user->setUpdatedAt('2013-07-06 21:44:48');


|---------------------------------------------------------
| > getCreatedAtColumn()
|---------------------------------------------------------
| - получить имя колонки для 'created at' значения
| - string getCreatedAtColumn()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя колонки для 'created at' значения

      $name = $user->getCreatedAtColumn();    // 'created_at'


|---------------------------------------------------------
| > getUpdatedAtColumn()
|---------------------------------------------------------
| - получить имя колонки для 'updated at' значения
| - string getUpdatedAtColumn()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя колонки для 'updated_at at' значения

      $name = $user->getUpdatedAtColumn();    // 'updated_at'


|---------------------------------------------------------
| > freshTimestamp()
|---------------------------------------------------------
| - получить свежий timestamp для модели, как объект Carbon
| - Carbon freshTimestamp()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя колонки для 'updated_at at' значения

      $carbon = $user->freshTimestamp();

  - Посмотрим, что внутри:

      $datetime = $carbon->date;                // '2014-09-12 18:48:30'
      $timezone_type = $carbon->timezone_type;  // 3
      $timezone = $carbon->timezone;            // 'Europe/Moscow'


|---------------------------------------------------------
| > freshTimestampString()
|---------------------------------------------------------
| - получить свежий timestamp для модели, как строку
| - string freshTimestampString()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить имя колонки для 'updated_at at' значения

      $str = $user->freshTimestampString();   // '2014-09-12 18:50:23'


|---------------------------------------------------------
| > newCollection()
|---------------------------------------------------------
| - создать новый экземпляр Eloquent Collection
| - Collection newCollection(array $models = array())

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Подготовить массив, из которого созданим новую коллекцию:

      $arr = array(1,2,3,4,5);

  - Создадим из массива $arr новую коллекцию:

      $new_collection = $user->newCollection($arr);


|---------------------------------------------------------
| > newInstance()
|---------------------------------------------------------
| - создать новый экземпляр данной модели
| - Model newInstance(array $attributes = array(), bool $exists = false)
| - $attributes: значения для записи в столбцы новой модели

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Подготовить массив значений для новой модели:

      $array = array('name' => 'Иван', 'age' => 18);

  - Создать новую модель, инициировав её значениями из $array:

      $new_model = $user-> newInstance($array);


|---------------------------------------------------------
| > newFromBuilder()
|---------------------------------------------------------
| - создать новый экземпляр существующей модели
| - Model newFromBuilder(array $attributes = array())

  .. примеров использования не нашёл ..


|---------------------------------------------------------
| > replicate()
|---------------------------------------------------------
| - клонировать модель, создав новый экземпляр
| - Model replicate(array $except = null)
| - В $except, похоже, можно указать имена столбцов, которые не попадут в клонированную модель
| - Причём столбец ID по умолчанию находится в $except

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Клонировать модель $user:

      $clone1 = $user->replicate();

  - Клонировать модель $user, но без столбцов 'id' и 'age':

      $clone = $user->replicate(array('id', 'age'));


|---------------------------------------------------------
| > hydrate()
|---------------------------------------------------------
| - создать коллекцию моделей из простых массивов
| - public Collection hydrate(array $items, string $connection = null)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Подготовить массив:

      $arr = array(1,2,3,4,5);

  - Создать коллекцию из $arr:

      $collection = $user->hydrate($arr);

  - Если конвертировать $collection в массив, получится вот что:

      $arr = $collection->toArray();

          array (size=5)
            0 =>
              array (size=1)
                0 => int 1
            1 =>
              array (size=1)
                0 => int 2
            2 =>
              array (size=1)
                0 => int 3
            3 =>
              array (size=1)
                0 => int 4
            4 =>
              array (size=1)
                0 => int 5

|---------------------------------------------------------
| > hydrateRaw()
|---------------------------------------------------------
| - создать коллекцию моделей из прямого запроса
| - public Collection hydrateRaw(string $query, array $bindings = array(), string $connection = null)

  .. примеров использования не нашёл ..


|---------------------------------------------------------
| > updateOrCreate()
|---------------------------------------------------------
| - создать или обновить запись, соотв-юю указанным атрибутам, и заполнить её указанными значениями
| - public Model updateOrCreate(array $attributes, array $values = array())

  .. примеров использования не нашёл ..


|---------------------------------------------------------
| > fill()
|---------------------------------------------------------
| - заполнить модель из массива атрибутов
| - $this fill(array $attributes)
| - заменяются значения только тех св-в модели, что присутствуют в $attributes

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Подготовить массив для заполнения модели:

      $arr = array('name' => 'Илья', 'age' => 18);

  - $user->fill($arr);


|---------------------------------------------------------
| > fillable()
|---------------------------------------------------------
| - назначить заполняемые атрибуты модели
| - $this fillable(array $fillable)
| - видимо, так можно переназначить $fillable в классе модели для текущего запроса

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Переназначить $fillable:

      $user->$fillable(array('name', 'age'));


|---------------------------------------------------------
| > guard()
|---------------------------------------------------------
| - сделать указанные атрибуты модели охраняемыми
| - $this guard(array $guarded)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Переназначить $guarded:

      $user->$guarded(array('name', 'age'));


|---------------------------------------------------------
| > unguard()
|---------------------------------------------------------
| - отключить ограничитель на mass assignment
| - public void unguard()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Отключить ограничитель на mass assignment:

      $user->$unguard();


|---------------------------------------------------------
| > reguard()
|---------------------------------------------------------
| - включить ограничения на mass assignment
| - public void reguard()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Включить ограничитель на mass assignment:

      $user->reguard();


|---------------------------------------------------------
| > getFillable()
|---------------------------------------------------------
| - получить массив имёт столбцов, для которых включён mass assignment
| - array getFillable()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить массив имёт столбцов, для которых включён mass assignment

      $arr = $user->getFillable();


|---------------------------------------------------------
| > isFillable()
|---------------------------------------------------------
| - узнать, может ли указанный столбец участвовать в mass assignment
| - bool isFillable(string $key)
| - $key: имя столбца

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, может ли участвовать в mass assignment столбец 'age':

      $arr = $user->isFillable('age');


|---------------------------------------------------------
| > isGuarded()
|---------------------------------------------------------
| - узнать, не может ли указанный столбец участвовать в mass assignment
| - bool isGuarded(string $key)
| - $key: имя столбца
| - По сути это тоже самое, что isFillable, только результат инвертирован.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, НЕ может ли участвовать в mass assignment столбец 'age':

      $arr = $user->isFillable('age');


|---------------------------------------------------------
| > totallyGuarded()
|---------------------------------------------------------
| - вернёт true, если все столбцы модели защищены от mass assignment
| - bool totallyGuarded()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Узнать, все ли столбцы модели защищены от mass assignment:

      $is = $user->totallyGuarded();


|---------------------------------------------------------
| > setUnguardState()
|---------------------------------------------------------
| - установить 'unguard' указанному состоянию
| - void setUnguardState(bool $state)

  .. примеров использования не нашёл ..


|---------------------------------------------------------
| > getAttribute()
|---------------------------------------------------------
| - извлечь значение из указанного столбца модели
| - mixed getAttribute(string $key)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Извлечём значение из столбца 'name', и узнаем, как же зовут $user'а:

      $name = $user->getAttribute('name');

  - Можно это сделать и более простым способом:

      $name = $user->name;


|---------------------------------------------------------
| > setAttribute()
|---------------------------------------------------------
| - установить указанный атрибут для модели
| - void setAttribute(string $key, mixed $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Присвоить значение в указанной колонке модели:

      $user->setAttribute('name', 'Иван');

  - Можно это сделать и более простым способом:

      $user->name = 'Иван';


|---------------------------------------------------------
| > getAttributes()
|---------------------------------------------------------
| - получить массив всех ключей-значений модели
| - array getAttributes()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить массив всех текущие атрибуты из модели

      $arr = $user->getAttributes();

  - Результат может выглядеть примерно так:

        array (size=4)
          'id' => int 8
          'host' => string 'lk.grumart.ru' (length=13)
          'from' => string '/m1/routing' (length=11)
          'to' => string '/i1' (length=3)


|---------------------------------------------------------
| > setRawAttributes()
|---------------------------------------------------------
| - массово изменить значения в указанных в массиве столбцах на указанные
| - void setRawAttributes(array $attributes, bool $sync = false)
| - $sync: сохранить ли изменения в модели в базу

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Подготовим массив:

      $arr = array('name'=>'Иван', 'age'=>18);

  - Изменить значения:

      $user->setRawAttributes($array);

  - Изменить значения и сохранить изменения в БД:

      $user->setRawAttributes($array, true);


|---------------------------------------------------------
| > hasGetMutator()
|---------------------------------------------------------
| - определить, действует ли get-мутатор для указанного столбца
| - bool hasGetMutator(string $key)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Определим, действует ли get-мутатор для столбца 'age':

      $is = $user->hasGetMutator('age');


|---------------------------------------------------------
| > hasGetMutator()
|---------------------------------------------------------
| - определить, действует ли set-мутатор для указанного столбца
| - bool hasSetMutator(string $key)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Определим, действует ли Set-мутатор для столбца 'age':

      $is = $user->hasSetMutator('age');


|---------------------------------------------------------
| > getMutatedAttributes()
|---------------------------------------------------------
| - получить массив имён столбцов, в которых поработали мутаторы
| - array getMutatedAttributes()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получим массив имён столбцов, в которых поработали мутаторы:

      $arr = $user->getMutatedAttributes();


|---------------------------------------------------------
| > setAppends()
|---------------------------------------------------------
| - установить ассессоры для добавления в массивы модели
| - void setAppends(array $appends)

  .. примеров использования не нашёл ..


|---------------------------------------------------------
| > getDates()
|---------------------------------------------------------
| - получить массив атрибутов, который должен быть конвертирован в даты
| - array getDates()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получим массив атрибутов, который должен быть конвертирован в даты:

      $arr = $user->getDates();


|---------------------------------------------------------
| > fromDateTime()
|---------------------------------------------------------
| - сохранить DATETIME в строку
| - string fromDateTime(DateTime|int $value)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Сохраним значение DATETIME в строку:

      $str = $user->fromDateTime(date('Y-m-d H:i:s'));  // '2014-09-12 21:14:36'


|---------------------------------------------------------
| > isDirty()
|---------------------------------------------------------
| - определить, были ли изменены значения в модели или указанных столбцах
| - bool isDirty(array|string|null $attributes = null)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Определить, были ли изменены значения в модели

      $is = $user->isDirty();

  - Определить, было ли изменено значения в указанном столбце модели:

      $is = $user->isDirty('name');

  - Определить, были ли изменены значения в указанных столбцах модели:

      $is = $user->isDirty(array('name', 'age'));


|---------------------------------------------------------
| > getDirty()
|---------------------------------------------------------
| - получить массив имён столбцов, изменённых с момента посл.синхронизации
| - array getDirty()

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить массив имён столбцов, изменённых с момента посл.синхронизации:

      $arr = $user->getDirty();


|---------------------------------------------------------
| > getOriginal()
|---------------------------------------------------------
| - получить массив всех эл-в (ключ-значение) модели, со значениями, которые были сразу после посл.синхронизации
| - array getOriginal(string $key = null, mixed $default = null)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Получить массив всех эл-в (ключ-значение) модели, со значениями,
    которые были сразу после посл.синхронизации:

      $arr = $user->getOriginal();

  - Выглядит это примерно так:

      array (size=4)
        'id' => int 8
        'host' => string 'lk.grumart.ru' (length=13)
        'from' => string '/m1/routing' (length=11)
        'to' => string '/i1' (length=3)


|---------------------------------------------------------
| > syncOriginal()
|---------------------------------------------------------
| - синхронизировать все исходные значения в столбцах модели с текущими
| - $this syncOriginal()

  - Т.Е. "исходными" после синхронизации станут текущие.
  - "Исходные" применяются в таких методах, как getDirty(), getOriginal() и т.д.

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Синхронизируем:

      $user->syncOriginal();


|---------------------------------------------------------
| > syncOriginalAttribute()
|---------------------------------------------------------
| - синхронизировать исходное значение в указанном столбце модели с текущим
| - $this syncOriginalAttribute(string $attribute)

  - Получим коллекцию всех эл-в модели Users:

      $all = Users::all();

  - Получить первую модель в коллекции:

      $user = $all->first();

  - Синхронизируем:

      $user->syncOriginal('name');



-------- Описать по требованию --------

  > query                   | начать запрашивать модель
  > on                      | начать запрашивать модель на указанном соединении
  > newQuery                | получить новый query builder для таблицы модели
  > newEloquentBuilder      | создать новый Eloquent query builder для модели


  > getConnection           | получить экземпляр Connection с БД, которое используе модель
  > getConnectionName       | получить имя соединения с БД, которое используе модель
  > setConnection           | назначить, какое соединение с БД использовать модели

  > resolveConnection       | создать экземпляр Connection для указанного имени соединения
  > getConnectionResolver   | создать новый экземпляр класса ConnectionResolver
  > setConnectionResolver   | установить экземпляр ConnectionResolver
  > unsetConnectionReslover | снять экземпляр ConnectionResolver

  > saving                  | зарегистрировать событие "модель сохраняется" в диспетчере
  > saved                   | зарегистрировать событие "модель сохранена" в диспетчере
  > updating                | зарегистрировать событие "модель обновляется" в диспетчере
  > updated                 | зарегистрировать событие "модель обновлена" в диспетчере
  > creating                | зарегистрировать событие "модель создаётся" в диспетчере
  > created                 | зарегистрировать событие "модель создана" в диспетчере
  > deleting                | зарегистрировать событие "модель удаляется" в диспетчере
  > deleted                 | зарегистрировать событие "модель удалена" в диспетчере
  > flushEventListeners     | удалить все обработчики событий для модели
  > getObservableEvents     | получить список наблюдаемых событий модели
  > setObservableEvents     | назначить список наблюдаемых событий модели
  > addObservableEvents     | добавить значение в список наблюдаемых событий модели
  > removeObservableEvents  | удалить значение из списка наблюдаемых событий модели
  > getEventDispatcher      | получить экземпляр Dispatcher (диспетчер событий)
  > setEventDispatcher      | назначить экземпляр Dispatcher (диспетчер событий)
  > unsetEventDispatcher    | снять экземпляр Dispatcher (диспетчер событий)
  > observe                 | зарегистрировать класс-наблюдатель для модели

  > load                    | упреждающе загрузить связи для модели
  > with                    | указать связи для упреждающей загрузки для модели
  > hasOne                  | определить связь 1-1
  > morphOne                | определить полиморфную связь 1-1
  > belongsTo               | определить инверсную 1-1 или 1-много связь
  > morphTo                 | определить, полиморфную инверсную 1-1 или 1-много связь
  > hasMany                 | определить связь 1-много
  > hasManyThrough          |
  > morphMany               |
  > belongsToMany           |
  > morphToMany             |
  > morphedByMany           |
  > joiningTable            |
  > touchOwners             | тронуть (touch) владеющие связи модели
  > touches                 | определить, трогала ли модель указанные связи
  > getMorphClass           | получить имя класса для полиморфных связей
  > getTouchedRelations     | получить связи, которые трогали при сохранении
  > setTouchedRelations     | установить связи, которые трогать при сохранении
  > relationsToArray        | конвертировать связи модели в массив
  > getRelations            | получить массив всех загруженных связей для экземпляра
  > getRelation             | получить указанную связь
  > setRelation             | установить специальную связь для модели
  > setRelations            | установить массив спец.связей для модели






