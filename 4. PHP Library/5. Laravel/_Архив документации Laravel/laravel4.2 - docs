=============================================================
Laravel
The PHP framework for web artisans


Ссылки:

	> Официальный сайт Laravel:
			http://laravel.com/

  > Документация по Laravel v4 на русском:
      http://laravel.ru/docs/v4/

  > Углублённые статьи и касты о разных фичах Laravel:
      https://laracasts.com/

  > Laravel IDE Helper Generator:
      https://github.com/barryvdh/laravel-ide-helper

  > Официальный форум Laravel. Ответы и вопросы:
      http://forumsarchive.laravel.io/

  > Laravel 'Cheat Sheet' - все команды, функции, техники в 1-м месте:
      http://cheats.jesse-obrien.ca/#


  > Laravel 4.1 API documentation:
      http://laravel.com/api/4.1/

  > Laravel Illuminate API documentation:
      http://laravel.com/api/index.html


  > Наглядное объяснение, что такое и зачем нужен IoC Container:
      http://stackoverflow.com/questions/18562752/understanding-ioc-containers-and-dependency-injection

  > Статья на хабре: "Laravel. Установка, настройка, создание и деплой приложения"
      http://habrahabr.ru/post/197454/

  > Monolog на git:
      https://github.com/seldaek/monolog

  > Что такое ORM (wiki):
      http://ru.wikipedia.org/wiki/ORM

  > "ORM и с чем его едят" - статья Михаила Стадника
      http://mikhailstadnik.com/few-words-about-orm

  > "Что такое ActiveRecord" - статья на wiki:
      http://ru.wikipedia.org/wiki/ActiveRecord

  > "Философия ActiveRecord" - статья на habr:
      http://habrahabr.ru/post/11525/

  > API класса Carbon - надстройки над DateTime для удобной работы:
      https://github.com/briannesbitt/Carbon

  > Книга "Getting started with Laravel 4" (en):
      http://books.google.ru/books?id=7DKhAgAAQBAJ&pg=PT196&lpg=PT196&dq=laravel+mail+embeddata&source=bl&ots=npqtbWkrTP&sig=vG9e9CTnAkRoamIuHG8MakHIl_w&hl=ru&sa=X&ei=zhokVOb8LsaaygOgvICYCA&ved=0CDQQ6AEwAw#v=onepage&q=laravel%20mail%20embeddata&f=false

*****************************************************
Оглавление:

  # Основы

    1.  Установка Laravel
    2.  Настройка Laravel
    3.  Как работает Laravel: обзор
    4.  Routing
    5.  Входы, куки, информация о запросе
    6.  Выходы, views, редиректы
    7.  Контроллеры
    8.  Ошибки и ведение лога
    9.  Artisan CLI

  # База данных

    10. Основы работы с БД в Laravel
    11. Query Builder (строилка запросов)
    12. Eloquent ORM
    13. Schema Builder (управление таблицами)
    14. Миграции и заселение
    15. Redis [см. отдельную справку]

  # Продвинутые знания

    16. Аутентификация
    17. Кэш
    18. События
    19. IoC контейнеры
    20. Service providers
    21. Фасады
    22. Вспомогательные функции общего назначения
    23. Почта
    24. Пагинация
    25. Queues: планировщик задач
    26. Сессии
    27. Шаблоны
    28. Валидация


*****************************************************

|--------------------------------------------------------------------------
| Основы
|--------------------------------------------------------------------------
|
| В этом разделе описаны основы работы с Laravel.
|


1.  Установка Laravel

  --------------------------------------
  Подоглавление:

    - Системные требования
    - Установка Laravel
    - Установка авто-дополнения команд Laravel в PHPStorm
    - Решение проблемы со "swiftmailer" при установке

  --------------------------------------

  > Системные требования
    - PHP >= 5.3.7
    - MCrypt PHP Extension


  > Установка Laravel

      1. Открыть консоль и перейти в папку, куда будем устанавливать.
      2.  Скачать composer в эту папку одной из следующих команд:

        php -r "eval('?>'.file_get_contents('https://getcomposer.org/installer'));"
        php -r "readfile('https://getcomposer.org/installer');" | php

      3. С помощью composer устанвоить Laravel в эту папку:

        php composer.phar create-project laravel/laravel [имя проекта] --prefer-dist


  > Установка авто-дополнения команд Laravel в PHPStorm

    > Введиние
      - По умолчанию в PHPStorm (<=v7.1.2) нет автокомплита для laravel.
      - Нет также и специального плагина, как для многих других фреймворков.
      - А без автокомплита работать гораздо менее удобно, чем с ним.

    > Решение
      - Поможет решить проблему "Laravel IDE Helper Generator".
      - Ссылка на него есть выше в ссылках.
      - Автокомплит устанавливается при установке нового проекта laravel.
      - Процесс установки:

      1. В "Laravel/composer.json" добавить следующее:

          {
            "require": {
              "barryvdh/laravel-ide-helper": "1.*"
            }
          }

      2. В каталоге Laravel выполнить команду:

          php ..\composer.phar update

      3. Добавить service-provider в 'Laravel/app/config/app.php':

          'providers' => array(
            ...

            'Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider',

          ),

      4. В папке Laravel выполнить следующие команды:

          php artisan clear-compiled
          php artisan ide-helper:generate

         - Это сгенерирует файл "_ide_helper.php" на основе файлов проекта.


  > Решение проблемы со "swiftmailer" при установке

    > Описание
      - При установке laravel через composer может возникать ошибка.
      - Ошибка связана со "swiftmailer".
      - Ошибка возникает при установке в глубоко зарытую поддиректорию.
      - Как следствие, установка не происходит до конца, и laravel не работает корректно.
      - Описание проблемы на форуми и её решение (eng):
          http://forumsarchive.laravel.io/viewtopic.php?pid=57658

    > Решение
      - Устанавливать новый проект laravel в папку "C:\laravel"
      - При такой установке ошибка возникать не будет, т.к. путь короткий.
      - Установленный laravel после установки переносить куда надо.


2.  Настройка Laravel

  --------------------------------------
  Подоглавление:

    - Введение в настройку
    - Как получить значение какого-либо параметра из PHP-кода?
    - Как установить значение какого-либо параметра из PHP-кода?
    - Как организовать пресеты настроек для разных сред запуска?
    - Как защитить важные конфигурационные данные (пароли, коды, ...)
    - Как перевести приложение в режим: "тех.обсллуживания"?
    - Декомпозиция настройки Laravel

  --------------------------------------

  > Введение в настройку
    - После установки настраивать что-либо необходимости нет.
    - Если устраивают настройки "по умолчанию", можно сразу приступать к работе.
    - Все настройки Laravel лежат в папке app/config.
    - Все настройки разбиты на группы.
    - Каждую группу представляет отдельный .php файл в папке config.
    - Каждый параметр .php файлах хорошо задокументирован.

  > Как получить значение какого-либо параметра из PHP-кода?
    - Это можно сделать через класс Config, используя метод get
    - Например, получим значение параметра 'appzone' из конфига 'config/app.php':

        Config::get('app.timezone');

    - А что, если запрашиваемого параметра не существует? Тогда мы можем
      указать значение "по умолчанию", которое будет возвращено в этом случае:

        $timezone = Config::get('app.timezone', 'UTC');

  > Как установить значение какого-либо параметра из PHP-кода?
    - Новое значение будет установлено не "на постоянку", а только на время текущего запроса.
    - Это можно сделать через класс Config, используя метод set
    - Например, установим в конфиге 'config/database.php' значение параметра
      'default' равным 'sqlite':

        Config::set('database.default', 'sqlite');

  > Как организовать пресеты настроек для разных сред запуска?

    > Введение в проблему
      - Приложение может быть запущено в разных средах.
      - Среда по умолчанию называется "production".
      - Для локальной разработки, например, на localhost.
      - Для продакшена, например, на продакшн сервере.
      - В разных средах некоторые настройки Laravel должны отличаться.
      - Было бы не удобно всё время их менять вручную, или хранить как-то отдельно.

    > Решение - пресеты настроек
      - Нужно создать пресеты настроек для требуемых сред.
      - Каждый пресет лежит в папке "app/config/{имя_пресета}".
      - Пресет представляет собой набор тех же .php файлов, что лежат в "app/config".
        Например: "app.php", "auth.php", ...
      - Не обязательно все файлы должны присутствовать в пресете. А в каждом
        файле не обязательно передавать все параметры. Достаточно передать
        лишь те, значния которых в данной среде надо изменить. И они будут
        перезаписывать стандартные пресеты при запуске приложения в данной среде.
      - Пример: допустим у нас пресет из 1-го файла "app.php", и при его
                использовании при запуске приложения в заданной среде будет
                изменён (перезаписан) лишь 1 параметр "timezone".

          app.php
          -----
            <?php
            return array(
              'timezone' => 'UTC'
            );

    > Laravel может автоматом распозновать среду и подключать заданный пресет
      - Для этого ему нужно запрограммировать правила распознавания.
      - Эти правила можно задать в файле "bootstrap/start.php".
      - А именно, в качестве аргумента функции $app->detectEnvironment.
      - Первый вариант: сопоставить имя пресета и имена компьютеров. И если
        приложение будет запущено на машине, имя которой будет совпадать с
        одним из указанных в массиве имён, этот пресет автоматом будет применён.
        Пример:

          $env = $app->detectEnvironment(array(

              'preset1' => array('имя среды №1', 'имя среды №2'),
              'preset2' => array('имя среды №3')

          ));

      - Второй вариант: вместо массива передать в метод анонимную фукнцию.
        Она может гибко вычислить имя среды, и вернуть его на выходе.
        Пример:

          $env = $app->detectEnvironment(function()
          {
              return $_SERVER['MY_LARAVEL_ENV'];
          });

      - Третий вариант: можно еще более гибко настроить условное применение
        пресетов в зависимости от среды. Для этого можно использовать метод
        App::environment для получения имени текущей среды, в которой запущено
        приложения, и основываясь на этом условным образом присваивать значение
        переменной $env. Пример:

          if (App::environment('local'))
          {
              // The environment is local
          }

          if (App::environment('local', 'staging'))
          {
              // The environment is either local OR staging...
          }


  > Как защитить важные конфигурационные данные (пароли, коды, ...)

    > Введение в проблему
      - Не безопасно хранить "секретные" конфигурационные данные в конфигах.
      - К таким данным относятся: пароли от БД, ключи к API, ключи шифрования и т.д.
      - Их кража может обернуться большими потерями.
      - А злоумышленник вполне может их просто напросто скачать с веб-сервера.

    > Решение:
      - Хранить все "секретные" данные в отдельном файле, начинающимся с точки.
      - Веб сервер не отображает такие файлы, и злоумышленник не может их скачать.
      - Сначала надо настроить Laravel, чтобы он узнавал среду, на котором его запускают.
      - Допустим настроили, и имя этой среды, например, задали: "local".
      - Тогда в корень приложения надо поместить файл ".env.local.php".
      - Корень - это папка, в которую установлен Laravel. Где лежит 'composer.json'.
      - Файл должен возвращать массив значений в формате ключ/значение.
        Например:

        Файл ".env.local.php"
        -----
          <?php
          return array(

              'mysql_password' => '12345',
              'encrypt_key'    => 'sgEIncSE32'

          );

      - Все возвращённые переменные будут доступны в суперглобальных массивах
        $_ENV и $_SERVER
      - При использовании git надо обязательно одбавить все .env файлы
        в .gitignore, чтобы они не выложились в открытый доступ на git.
      - Для "production" среды можно создать аналогичный файл, но с
        именем ".env.php".


  > Как перевести приложение в режим: "тех.обсллуживания"?

    > Введение в проблему
      - Иногда в приложение нужно внести изменение, и это требует времени.
      - Если приложение в продакшене, для пользователей на время обновления
        надо показать что-нибудь вроде: "сайт на тех.обслуживании".
      - Предусмотрен ли в Laravel для этого какой-нибудь функционал?

    > Решение
      - В Laravel приложение можно перевести в режим "обслуживания".
      - Для этого надо перейти в папку приложения и выполнить команду:

          php artisan down

      - А для выведения приложения из режима "обслуживания":

          php artisan up

      - Когда приложение находится в режиме "обслуживания", пользователи
        при заходе по любому роуту приложения будут видеть только
        одно заданное view. В нём то как раз и должно быть написано что-то вроде
        "Извините, сайт находится на тех. обслуживании".
      - Задать это view можно в файле "app/start/global.php". Например:

          App::down(function()
          {
              return Response::view('maintenance', array(), 503);
          });

      - Если анонимная функция, переданная методу down, вернёт NULL, то
        факт наличия включённого режима "обслуживания" будет проигнорирован
        для этого запроса.
      - Никакие отложенные задания (компонент Queue) при включённом в приложении
        режиме "обслуживания" выполняться не будут. А продолжат, только при
        переключении приложения в нормальный режим.


  > Декомпозиция настройки Laravel
    
    2.  Настройка Laravel
      2.1.  Настройка параметров в 'app.php'

        # debug     | Если true, показывает подробную информацию о возник-их ошибках.э
                      Если false, показывает минималистичную инфу.

        # url       | Используется как базовый URL при автогенерации URL при
                      использовании комант artisan

        # timezone  | Имя временной зоны

        # locale    | Имя локали

        # key       | Это должна быть строка из случайных 32 символов, используется
                      сервисом Illuminate encrypter для шифрования.

        # providers | Массив классов типа "service provider", которые будут
                      автоматом загружаться при запросе к приложению.
                      Можно добавлять свои.

        # manifest  | Путь к папке, в которой будет хранится список всех
                      "service provider". Используется при lazy load.

        # aliases   | Массив в формате ключ/значение, где ключ - псевдоним,
                      значение - путь к папке с классом. При старте приложения
                      каждому из классов в "значении" назначается соответствующий
                      псевдоним из "ключа". Можно добавлять свои.


      2.2.  Настройка параметров в 'auth.php'

        # driver   | Драйвер, который будет использован для аутентификации.
                     Доступные варианты: 'Eloquent', 'Database'

        # model    | Если driver == 'Eloquent', нужно указать, какую модель
                     использовать для извлечения пользователей.

        # table    | Если driver == 'Database', нужно указать, какую таблицу
                     в БД использовать для извлечения пользователей.

        # reminder | Это массив с параметрами для напоминальщиков паролей.


      2.3.  Настройка параметров в 'cache.php'

        # driver      | Какая технология будет использована для кеширования.
                        Доступные варианты:
                        "file", "database", "apc", "memcached", "redis", "array

        # path        | Если driver == 'File', надо указать путь к папке, в которой
                        будут храниться файлы кэша.

        # connection  | Если driver == 'database', можно указать соединение с БД,
                        которое будет использовано. Если null, то будет использовано
                        соединение "по умолчанию".

        # table       | Если driver == 'database', надо указать, какая таблица
                        в ДБ будет использована для хранения кэша.

        # memcached   | Если driver == 'memcached', то можно указать массив своих
                        memcached-серверов, которые будут использованы.

        # prefix      | При хранении кэша через memcached и apc, могут быть и другие
                        приложения, которые используют те же ключи и затрут кэш. Поэтому
                        надо добавить всем ключам некий префикс.


      2.4.  Настройка параметров в 'compile.php'

        #


      2.5.  Настройка параметров в 'database.php'

        # fetch       | Здесь можно настроить, в каком виде будут извлекаться
                        результаты из БД.
                        - По умолчанию: как экземпляры PHP stdClass object
                        - Но можно настроить, чтобы извлекались в виде массива

        # default     | Указать, какое из соединений, указанных в 'connections'
                        надо использовать "по умолчанию". Другие тоже можно
                        будет использовать с помощью коллекции соединений Database.

        # connections | Коллекция соединений с БД, которые сможет использовать
                        приложение. Для работы с ними используется PDO, так что
                        для каждой СУБД должен быть в наличии работающий драйвер.

        # migrations  | Указать таблицу для работы с миграциями

        # redis       | Настройки для работы с БД Redis


      2.6.  Настройка параметров в 'mail.php'

        # driver      | Какая технология будет использоваться для работы с почтой:
                        "smtp" (по умолчанию), "mail", "sendmail"

        # host        | Хост SMTP сервера, который будет использован приложением
                        для работы с почтой.

        # port        | SMPT порт, который будет использовать приложение для
                        доставки почты пользователям.

        # from        | Глобальный "From" адрес в виде массива с 2-мя параметрами:
                        'address' и 'name'.
                        - По умолчанию значения у них null, значет отключены.
                        - Если указать значения, то они будут использованы при отправки
                          каждого письма приложением.

        # encryption  | Протокол шифрования для отправки почты, по умолчанию "TLS"

        # username    | Имя пользователя для подключения к SMTP-серверу

        # password    | Пароль для подключения к SMTP-серверу

        # sendmail    | Если driver == 'sendmail', то надо указать путь к папке
                        с sendmain на этом сервере.

        # pretend     | - Если true, то письма на самом деле не будут отправлятсья
                          получателю, а будут записываться в логи приложения.
                          Это режим, который удобно использовать для разработки.
                        - Если false (по умолчанию), то будут.


      2.7.  Настройка параметров в 'queue.php'

        # default     | Указать, какая технология будет использоваться для
                        работы отложенными задачами. Доступные варианты:
                        "sync" (по умолчанию), "beanstalkd", "sqs", "iron"

        # connections | Коллекция соединений с queue-серверами

        # failed      | Указать соединение с БД и таблицу, куда будут
                        записываться отчёты о проваленных queue-заданиях.


      2.8.  Настройка параметров в 'remote.php'

        # default     | Имя соединения из коллекции connections, которое будет
                        использовано для всех SSH операций.

        # connections | Коллекция серверов и их настроек, которые будут доступны
                        Laravel через SSH

        # groups      | Список групп, каждая из которых содержит список имён
                        из коллекции connections. Используя имя группы, можно
                        сразу получить ко всем перечисленным в ней серверам за раз.


      2.9.  Настройка параметров в 'session.php'

        # driver          | Указать какая технология будет использоваться для
                            работы с сессиями. Доступные варианты:
                            "file", "cookie", "database", "apc", "memcached", "redis", "array"

        # lifetime        | Время в минутах, в течение которого хранятся
                            сессионные данные, и после которого они становятся expired

        # expire_on_close | Можно сделать так, чтобы сессионные данные становились
                            expired сразу после закрытия браузера, тогда надо указать true.
                            По умолчанию укзано false.

        # files           | Если driver == 'file', то надо указать папку, где будут
                            хранится сессионные файлы.

        # connection      | Если driver == "database', или driver == "redis", то
                            надо указать имя соединения из коллекции соединений
                            в файле database.php, которое будет использоваться.

        # table           | Если driver == "database', то надо указать таблицу в БД,
                            в которой будут хранитсья данные сессий.

        # lottery         | Некоторым технологиям по работе с сессиями надо вручную
                            периодически очищать своих хранилища от старых сессий.
                            Здесь указана вероятность запуска этого процесса на каждом
                            запросе (по умолчанию, случайная от 2% до 100%).

        # cookie          | Здесь указано имя сессионной куки, которая будет
                            содержать UID сессии. Используется для любой сессионной
                            технологии.

        # path            | Адрес (начиная от корня приложения), начиная с которого
                            будет проверяться доступность сессионной куки. По умолчанию
                            стоит корень приложения '/'

        # domain          | ?

        # secure          | Если true, сессионные куки отправляются обратно на сервер
                            только в случае, если используется защищённое HTTPS-соединение.
                            По умолчанию false.

      2.10.  Настройка параметров в 'view.php'

        # paths       | Здесь можно указать массив путей, в которых Laravel будет
                        искать представления (view). По умолчанию указан только
                        один путь: "app/views".

        # pagination  | ?


      2.11.  Настройка параметров в 'workbench.php'

        # name        | При создании новых пакетов с помощью команды "workbench"
                        artisan, для генерации файла composer.json понадобится
                        имя автора. Его можно указать сразу здесь.

        # email       | Аналогично, здесь сразу можно указать свой email.


3. Как работает Laravel: обзор

  --------------------------------------
  Подоглавление:

    - Введение
    - Жизненный цикл запроса в Laravel-приложении
    - Предназначение папки "app/start" и обзор файлов в ней
    - События объекта класса Application

  --------------------------------------

  > Введение
    - Это будет очень общий обзор того, как работает Laravel.
    - Здесь будет рассмотрен "жизненный цикл" запроса в Laravel-приложении.
    - Также будут рассмотрены "start"-файлы и события в приложении.

  > Жизненный цикл запроса в Laravel-приложении

    > Пошаговый обзор прохождения запроса через приложение

      1.  Запрос попадает в файл "public/index.php"
          - Все запросы к приложению всегда попадают в файл index.php.
            Даже если там в адресе указано что-угодно другое.
          - Смысл в том, чтобы принимать все запросы в 1-ну входную точку,
            внутри разруливать, и в конце возвращать нужный view.
          - Это реализовано с помощью файла "public/.htaccess" (для веб-сервера
            apache), в нём внутри в блоке "mod_rewrite" прописаны правила,
            переадресующие любой запрос на index.php.

      2.  Запускается файл "bootstrap/start.php"
          - Создаётся новый объект класса Application.
          - Он также служит как IoC container.
          - IoC container позволяет эффективно управлять зависимостями
            классов в PHP-приложении. В Laravel IoC - это контейнер, куда
            можно свалить всё, что может понадобиться в приложении. И из приложения
            получать к этому доступ по зарегистрированным именам.
          - Проводится идентификация среды, в которой запущено приложение.
          - Применяются конфиги, созданные специально для этой среды.
          - Регистрирует "Service Providers", указанные в массиве "providers"
            в конфиге "app/config/app.php", в свежесозданном IoC контейнере.
          - В основном, каждый service provider регистрирует в IoC контейнере
            одну или более переменную, содержащую анонимную функцию. Т.О. из
            приложения можно будет легко получить доступ к зарегистрированным
            в IoC контейнере вещам.

      3.  Загружаются файлы из папки "app/start"

      4.  Загружается файл "app/routes.php"

      5.  Request-объект засылается на вход Application-объекта, который
          на выходе возаращает Response-объект
          - Когда Application-объект получает Request-объект, он уже
            может с ним работать и понять, что запрашивал клиент.

      6.  Response-объект отсылается обратно клиенту.

  > Предназначение папки "app/start" и обзор файлов в ней

    > Введение
      - Start-файлы находятся в папке 'app/start'.
      - По умолчанию их 3: 'global.php', 'local.php', 'artisan.php'.
      - Предназначение папки start - исполнять некий код при старте приложения.
      - В любой из этих файлов (кроме artisan.php) можно добавить любой свой код.
      - В 'app/start' по умолчанию лежат 3 файла: 'global.php', 'local.php', 'artisan.php'.

    > 'global.php' и 'artisan.php'
      - Код в них выполняется каждый раз при запросе к приложению.
      - Не зависимо от среды, в которой выполняется Laravel-приложение.

    > 'local.php' и прочие файлы в папке start
      - Эти выполняются или не выполняются в зависимости от среды.
      - Выполняется, если имя файла и текущей действующей среды совпало.
      - Не выполняется, если не совпало.
      - Имя среды для сравнения Laravel смотрит в 'bootstrap/start.php'.

    > Можно добавлять свои файлы
      - В папку 'app/start' можно добавить файл с именем {name}.php
      - Это файл, который исполнится при запуске приложения в среде {name}.

  > События объекта класса Application

    > Введение
      - Этот объект генерирует ряд событий.
      - Для каждого из них можно назначить функцию-обработчик.
      - Назначить их можно как раз в файлах в папке 'app/start'.

    > Список и описание событий объекта класса Application

      # before
        - Запускается перед передачей объекта Request в приложение.
        - Пример назначения объекту класса Application функции-обработчика
          события 'before':

            App::before(function($request)
            {
                //
            });

      # matched
        - Запускается, когда $request приводит к запуску какого-либо
          route, ещё до его исполнения.
        - Узнать что за route будет запущен, можно из аргумента $route.
        - Пример назначения объекту класса Route функции-обработчика
          события 'matched':

            Route::matched(function($route, $request)
            {
                //
            });

      # after
        - Запускается после полной обработки объекта Request приложением.
        - Пример назначения объекту класса Application функции-обработчика
          события 'after':

            App::after(function($request, $response)
            {
                //
            });

      # finish
        - Запускается после того, как Response-объект отправлен обратно клиенту.
        - Это хороший момент, чтобы выполнить некие последние процедуры,
          которые требует твоё приложение.

      # shutdown
        - Запускается сразу после того, как обработчики события finish заканчивают работу.
        - Это последняя возможность что-нибудь сделать, пока скрипт полностью не
          завершился и не уничтожился.


4.  Routing

  --------------------------------------
  Подоглавление:

    - Введение
    - Наглядный пример
    - Декомпозиция описания Routing

  --------------------------------------

  > Введение
    - Routing - переводится как маршрутизация. А route - маршрутизатор.
    - Все роуты хранятся в файле "app/routes.php".
    - Роутов в routes.php может быть сколько угодно.
    - Роут на входе проверяет условия: метод запроса, адрес запроса.
    - Если условия выполняются - роут срабатывает. Иначе - не срабатывает.
    - Сработавший роут выполняет заданную в описании функцию.
    - Это может быть анонимная функция, описанная прямо в routes.php.
    - А может быть ссылка на метод контроллера. А контроллер при этом
      опиасан в отдельном файле в папке "app/controllers".

  > Наглядный пример
    - Этот роут реагирует на запрос методом GET к корню сайта.
    - Реакция состоит в выполнеии анонимной функции.
    - Анонимная функция просто возвращает строку.

        Route::get('/', function()
        {
            return 'Hello World';
        });

  > Декомпозиция описания Routing

    4.  Routing
      4.1.  Основы роутинга. Роутинг на анонимную функцию.
        - Роутинг можно проводить на анонимную функцию или на контроллер.
        - Здесь описаны основы роутинга на анонимную функцию.

      4.2.  Параметры роутинга.
        - В пути роута можно указывать плейсхолдеры.
        - Можно получить значение плейсхолдера в функции, которую исполняет роут.
        - С помощью where и RegExp можно задавать ограничения для плейсхолдеров.
        - С помощью Route::pattern можно задавать глобальные ограничения на конкретный
          плейсхолдер, действующие во всём файле routes.php.

      4.3.  Фильтры роутинга.
        - Фильтр - это колбэк функция.
        - Есть before-фильтры и after-фильтры.
        - Before-фильтр выполняется непосредственно перед исполнением роута.
        - Он полезен для отсеивания/переадресации запросов, аутентификации.
        - After-фильтр выполняется непосредственно после исполнения роута.
        - Он может получать response, полезен для записей в лог.

      4.4.  Именованные роуты.
        - Роутам можно задавать имена.
        - На именованные роуты можно делать редиректы по их имени.
        - Также по имени роута с помощью URL::route можно формировать URL.
        - Route::currentRouteName(): получить имя текущего запущенного роута

      4.5.  Группирование роутов.
        - Несколько роутов можно объединять в группы.
        - Это позволяет применить фильтр ко всей группе сразу.
        - Также это позволяет задать namespace для всей группы сразу.

      4.6.  Роутинг поддоменов.
        - Поддомен в пути роута также можно задавать с помощью плейсхолдера.
        - Это по сути тоже самое, что описано в 4.2.

      4.7.  Префиксинг группы роутов.
        - Группе роутов можно установить префикс.

      4.8.  Связывание роута с моделью.
        - Можно передать колбэк-функции роута экземпляр класса модели.
        - Можно использовать номер экземпляра как плейсхолдер в пути роута.

      4.9.  Возбуждение ошибки 404.
        - В колбэк-функции роута можно вручную возбудить ошибку 404.
        - Сделать это можно функцией: App::abort(404)

      4.10. Роутинг на контроллер.
        - Роутинг не обязательно надо осуществлять на анонимную функцию.
        - Иначе так можно засорить файл routes.php под завязку.
        - Если объём кода велик, стоит осуществлять роутинг на метод контроллера.
        - Контроллер - класс в отдельном файле.
        - Контроллеры в Laravel хранятся в папке "app/controllers".


  > 4.1.  Основы роутинга. Роутинг на анонимную функцию.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры роутинга на анонимную функцию

    --------------------------------------

    > Введение
      - Роутинг можно проводить на анонимную функцию или на контроллер.
      - Здесь описаны основы роутинга на анонимную функцию.
      - Такой роутинг стоит использовать, если объём кода не велик.
      - В противном случае стоит использовать роутинг на метод контроллера,
        т.о. вынеся большой объём кода в отдельный файл контроллера.

    > Примеры роутинга на анонимную функцию
      - Роут, реагирующий на запрос методом GET к корню сайта:

            Route::get('/', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запрос методом POST по адресу '/foo/bar' от корня:

            Route::post('foo/bar', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запросы методами GET и POST к корню сайта:

            Route::match(array('GET', 'POST'), '/', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запрос любым методом по адресу 'foo' от корня:

            Route::any('foo', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запрос методом GET по адресу 'foo' от корня,
        при этом запрос должен быть через протокол HTTPS:

            Route::get('foo', array('https', function()
            {
                return 'Must be over HTTPS';
            }));

      - Сгенерировать абсолютный URL к роуту можно так:

            $url = URL::to('foo');


  > 4.2.  Параметры роутинга.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры

    --------------------------------------

    > Введение
      - В пути роута можно указывать плейсхолдеры.
      - Можно получить значение плейсхолдера в функции, которую исполняет роут.
      - С помощью where и RegExp можно задавать ограничения для плейсхолдеров.
      - С помощью Route::pattern можно задавать глобальные ограничения на конкретный
        плейсхолдер, действующие во всём файле routes.php.

    > Примеры

      > Параметры роутинга
        - Как часть пути роута указывается 1 или более плейсхолдеров.
        - Их значения внутри роутинговой функции можно получить из аргументов.
        - Имена аргументов должны совпадать с именами соотв. плейсхолдеров.
        - В примере ниже использован плейсхолдер {id}.
        - Его значение внутри аноним.функции можно получить из аргумента $id.

            Route::get('user/{id}', function($id)
            {
                return 'User '.$id;
            });

      > Необязательные параметры роутинга
        - Можно сделать параметры роутинга необязательными.
        - Но при этом их возможное наличие будет предусмотрено конструкуией.
        - На необязательность указывает символ '?' в конце плейсхолдера.
        - В примере ниже использован плейсхолдер {name?}
        - Если в запросе плейсхолдер останется пуст, то значение $name будет null

            Route::get('user/{name?}', function($name = null)
            {
                return $name;
            });

      > Необязательные параметры роутинга с заданными значениями "по умолчанию"
        - Значение "по умолчанию" - чему будет равен параметр, если его плейсхолдер
          в пути не будет заполнен.
        - В предыдущем примере null является значением "по умолчанию" для $name.
        - А в примере ниже у параметра $name зачение по умолчанию: 'John'

            Route::get('user/{name?}', function($name = 'John')
            {
                return $name;
            });

      > Фильтрация параметров с помощью метода where и RegExp
        - Фильтр как бы говорит: "если параметр матчится с заданным RegExp,
          и все остальные условия выполнены, то запускай роут. Иначе - нет.".
        - В примере ниже {name} должен состоять из латинских букв в любом
          регистре, иначе роут не будет запущен:

            Route::get('user/{name}', function($name)
            {
                //
            })
            ->where('name', '[A-Za-z]+');

        - В примере ниже {id} должен состять полностью из цифр, иначе роут
          не будет вызван:

            Route::get('user/{id}', function($id)
            {
                //
            })
            ->where('id', '[0-9]+');

        - А вот как это делается сразу для нескольких параметров:

            Route::get('user/{id}/{name}', function($id, $name)
            {
                //
            })
            ->where(array('id' => '[0-9]+', 'name' => '[a-z]+'))

      > Фильтрация с помощью RegExp: глобальный паттерн
        - В примерах выше фильтрацию приходилось прописывать для каждого роута.
        - Вместо этого для конкретного параметра можно сделать перманентный фильтр.
        - Он будет действовать на все параметры в файле routes.php.
        - Сделать это можно с помощью метода Route::pattern
        - В примере ниже такой перманентный фильтр установлен для параметра {id}.
          Он должен состоять полностью из цифр, иначе роут не будет запущен:

            Route::pattern('id', '[0-9]+');

      > Доступ к значению параметров извне колбэк-функции роута
        - Допустим, надо получить доступ к значению параметров из фильтров
          (функций-обработчиков событий before и after).
        - Сделать это можно с помощью функции Route::input, как в примере ниже:

            Route::filter('foo', function()
            {
                if (Route::input('id') == 1)
                {
                    //
                }
            });


  > 4.3.  Фильтры роутинга.

    --------------------------------------
    Подоглавление:

      - Введение
      - Особенности
      - Примеры

    --------------------------------------

    > Введение
      - Фильтр - это колбэк функция.
      - Есть before-фильтры и after-фильтры.
      - Before-фильтр выполняется непосредственно перед исполнением роута.
        - Он полезен для отсеивания/переадресации запросов.
        - А также для аутентификации, проверки наличия доступа.
      - After-фильтр выполняется непосредственно после исполнения роута.
        - Он может получать response, полезен для записей в лог.
      - Есть несколько фильтров, которые по умолчанию работают в Laravel:
        'auth', 'auth.basic', 'guest', 'csrf'.
      - Все они находятся в файле 'app/filters.php'.

    > Особенности

      > Возврат значения из фильтра
        - Возврат значения с помощью return из before-фильтра воспринимается,
          как ответ на запрос.
        - Это значит, что роут и after-фильтры исполнены не будут.


    > Примеры

      > Определение фильтра
        - Ниже определении фильтра с именем 'old'
        - Он использует значение параметра age, который извлекает
          описанным в 4.2 способом.
        - Он условно возвращает значение с помощью return. Если оно будет
          возвращено, соответствующий роут и все after-фильтры исполнены не будут.

            Route::filter('old', function()
            {
                if (Input::get('age') < 200)
                {
                    return Redirect::to('home');
                }
            });

      > Назначение before-фильтра роуту
        - Назначим определённый выше фильтр old при определении роута.
        - В этом примере это роут на анонимную функцию.
        - Это будет before-фильтр.

            Route::get('user', array('before' => 'old', function()
            {
                return 'You are over 200 years old!';
            }));

      > Назначение нескольких before-фильтров роуту
        - А что, если требуется назначить сразу несколько фильтров роуту?
        - Их просто надо перечислить через символ пайп '|'.
        - В примере ниже роуту назначены 2 фильтра - 'auth' и 'old':

            Route::get('user', array('before' => 'auth|old', function()
            {
                return 'You are authenticated and over 200 years old!';
            }));

        - Либо их можно передать в массиве, как показано ниже:

            Route::get('user', array('before' => array('auth', 'old'), function()
            {
                return 'You are authenticated and over 200 years old!';
            }));


      > Назначение before-фильтра методу контроллера
        - Назначим определённый выше фильтр old при определении роута.
        - В этом примере это роут на метод 'showProfile' контроллера 'UserController'.
        - Это будет before-фильтр.

            Route::get('user', array('before' => 'old', 'uses' => 'UserController@showProfile'));

      > Использование параметров фильтров
        - Определим фильтр 'age' со всеми параметрами. Здесь $route -
          это ссылка на объект-роут, $request - ссылка на объект-запрос,
          $value - переданное значение.

            Route::filter('age', function($route, $request, $value)
            {
                //
            });

        - Назначим фильтр роуту и передадим ему значение 200:

            Route::get('user', array('before' => 'age:200', function()
            {
                return 'Hello World';
            }));

        - Особенность after-фильтра в том, что у него помимо вышеперечисленных
          параметров есть ещё параметр $response - обозначающий объект-ответ
          на запрос, который идёт 3-им по счёту.

      > Применить фильтр ко всем роутам, путь которых матчится с заданным паттерном
        - Можно применить фильтр ко всем роутам, путь которых матчится
          с заданным паттерном.
        - В примере ниже фильтр admin будет будет применён ко всем роутам,
          путь которых начинается с "admin/":

            Route::filter('admin', function()
            {
                //
            });

            Route::when('admin/*', 'admin');

        - Также можно установить ограничение по методу запроса. Например,
          будем пропускать только запросы методом GET:

            Route::when('admin/*', 'admin', array('post'));

      > Определение и использование фильтра из отдельного класса
        - Фильтр можно определить и в отдельном файле, в отдельном классе.
        - Вот как это делается:

            class FooFilter {

                public function filter()
                {
                    // Filter logic...
                }

            }

        - А вот как можно назначить этот фильтр роуту:

            Route::filter('foo', 'FooFilter');


  > 4.4.  Именованные роуты.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры

    --------------------------------------

    > Введение
      - Роутам можно задавать имена.
      - На именованные роуты можно делать редиректы по их имени.
      - Также по имени роута с помощью URL::route можно формировать URL.
      - Route::currentRouteName(): получить имя текущего запущенного роута

    > Примеры
      - Вот как можно задать имя роуту на анонимную функцию при его
        определении:

          Route::get('user/profile', array('as' => 'profile', function()
          {
              //
          }));

      - А вот как это сделать для роута на метод контроллера:

          Route::get('user/profile', array('as' => 'profile', 'uses' => 'UserController@showProfile'));

      - Вот как можно теперь сделать редирект:

          $redirect = Redirect::route('profile');

      - А вот так можно сделать URL:

          $url = URL::route('profile');

      - И вот так получить имя сработавшего роута из него самого:

          $name = Route::currentRouteName();


  > 4.5.  Группирование роутов.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры

    --------------------------------------

    > Введение
      - Несколько роутов можно объединять в группы.
      - Это позволяет применить фильтр ко всей группе сразу.
      - Также это позволяет задать namespace для всей группы сразу.

    > Примеры
      - Вот так можно объединить несколько роутов в группу, и одновременно
        всей группе назначить before-фильтр 'auth':

          Route::group(array('before' => 'auth'), function()
          {
              Route::get('/', function()
              {
                  // Has Auth Filter
              });

              Route::get('user/profile', function()
              {
                  // Has Auth Filter
              });
          });

      - А вот так можно для всех роутров в группе обозначить, что все
        пути к контроллерам будут квалифицироваться указанным пр.имён:

          Route::group(array('namespace' => 'Admin'), function()
          {
              //
          });


  > 4.6.  Роутинг поддоменов.

    --------------------------------------
    Подоглавление:

      - Введение
      - Пример

    --------------------------------------

    > Введение
      - Поддомен в пути роута также можно задавать с помощью плейсхолдера.
      - Это по сути тоже самое, что описано в 4.2.

    > Пример
      - Пример ниже показывает, как разруливать поддомены.
      - Для этого надо определить группу.
      - В неё надо передать массив атрибутов группы с параметром domain
        и строкой с доменом, где в кач-ве поддомена использован плейсхолдер.
      - Внутри группы надо разместить роуты, разруливающие поддомены.
      - В роут имя задействованного поддомена передаётся в виде аргумента.
      - Имя аргумента должно совпадать с именем плейсхолдера.
      - В примере ниже имя плейсходлера {account}, имя аргумента $account.

        Route::group(array('domain' => '{account}.myapp.com'), function()
        {

            Route::get('user/{id}', function($account, $id)
            {
                //
            });

        });


  > 4.7.  Префиксинг группы роутов.

    --------------------------------------
    Подоглавление:

      - Введение
      - Пример

    --------------------------------------

    > Введение
      - Группе роутов можно установить префикс.
      - ??? пока не понял, зачем это нужно ???

    > Пример:

        Route::group(array('prefix' => 'admin'), function()
        {

            Route::get('user', function()
            {
                //
            });

        });


  > 4.8.  Связывание роута с моделью.

    --------------------------------------
    Подоглавление:

      - Введение
      - Особенности
      - Пример

    --------------------------------------

    > Введение
      - Можно передать колбэк-функции роута экземпляр класса модели.
      - Можно использовать номер экземпляра как плейсхолдер в пути роута.
      - Например, вместо того, чтобы передавать роуту ID пользователя, можно
        передать объект-экземпляр класса User, соответствующий этому ID.
        Т.Е. ID в пути роута приведёт к передаче объекта (а не ID) в роут.

    > Особенности

      > Нет модели? Держи ошибку 404.
        - Если указанная модель не будет найдена, то будет ошибка 404.

    > Пример
      - Первым делом свяжем параметр user с моделью User:

          Route::model('user', 'User');

      - Определим роут с параметром {user}:

          Route::get('profile/{user}', function(User $user)
          {
              //
          });

      - Работать это будет так. В ответ на, например, запрос "profile/1"
        в колбэк-функцию роута будет передан экземпляр класса User,
        отвечающий ID == 1. Получить к нему доступ можно через атрибут $user.



> 5.  Входы, куки, информация о запросе

  --------------------------------------
  Подоглавление:

    - Работа со входными данными
    - Сохранение входных данных между запросами
    - Работа с загруженными входными файлами
    - Работа с куками
    - Получение информации о запросе

  --------------------------------------

  > Работа со входными данными

    > Введение
      - Получить входные данные можно с помощью нескольких простых методов.
      - Беспокоиться по поводу метода запроса нестоит. Каков бы не был метод
        запроса, данные нужно получать одними и теми же способами.
      - В случае поступления строки в формате JSON, работать с ней также
        можно используя ключи для получения значений, как и с другими форматами.

    > Примеры:
      - Извлечь входное значение с ключем 'name':

          $name = Input::get('name');

      - Извлечь входное значение с ключем 'name'. А если их нет, то
        выражение вернёт значение по умолчанию - в данном случае 'Sally':

          $name = Input::get('name', 'Sally');

      - Определить, передано ли на вход значение с ключем 'name':

          if (Input::has('name'))
          {
              //
          }

      - Извлечь всю входную строку из тела запроса:

          $input = Input::all();

      - Извлечь все входные данные, кроме указанных:

          $input = Input::except('credit_card');

      - Извлечь только указанные входные данные:

          $input = Input::only('username', 'password');

      - При получении данных от формы, можно использовать нотацию
        через точку для доступа к переданны массивам:

          $input = Input::get('products.0.name');


  > Сохранение входных данных между запросами

    > Введение:
      - Часто требуется где-нибудь сохранить поступившие данные между запросами.
      - В Laravel для этого реализован удобный функционал.

    > Добавление входных данных в сессию

      - Добавить всю входную информацию в сессию:

          Input::flash();

      - Добавить только указанные данные в сессию:

          Input::flashOnly('username', 'email');

      - Добавить в сессию все данные, кроме указанных:

          Input::flashExcept('password');

    > Извлечение старых входных данных из сессии

      - Извлечь старые входные данные из сессии:

          Input::old('username');


  > Работа с загруженными входными файлами

    > Введение:
      - На вход могут поступать и файлы, разумеется.
      - Для работы с ними у Laravel тоже есть функционал.
      - Метод Input::file возвращает объект-экземпляр класса
        "Symfony\Component\HttpFoundation\File\UploadedFile", который
        является наследником класса SplFileInfo, что и обеспечивает наличие
        набора методов для работы с файлом.

    > Функционал:
      - Извлечение переданного приложению файла:

          $file = Input::file('photo');

      - Определить, был ли загружен указанный файл:

          if (Input::hasFile('photo'))
          {
              //
          }

      - Перемещение загруженного файла по адресу $destinationPath,
        в который включено имя файла:

          Input::file('photo')->move($destinationPath);

      - Перемещение загруженного файла по адресу $destinationPath,
        но имя файла-результата указано отдельно в $fileName:

          Input::file('photo')->move($destinationPath, $fileName);

      - Получить абсолютный путь к загруженному файлу:

          $path = Input::file('photo')->getRealPath();

      - Получить исходное имя загруженного файла:

          $name = Input::file('photo')->getClientOriginalName();

      - Получить расширения загруженного файла:

          $extension = Input::file('photo')->getClientOriginalExtension();

      - Получить размер загруженного файла:

          $size = Input::file('photo')->getSize();

      - Получить MIME-тип загруженного файла:

          $mime = Input::file('photo')->getMimeType();


  > Работа с куками

    > Введение:
      - Каждая кука, созданная Laravel, зашифрована.
      - Также, каждая кука подписана аутентификационным кодом.
      - Если клиент изменит куку вручную, приложение сочтёт такие куки
        не валидными.

    > Функционал:
      - Проверить наличие куки с ключём 'name':

          $is = Cookie::has('name');

      - Извлечение значения куки с ключём 'name':

          $value = Cookie::get('name');

      - Добавить новую куку к объекту Response:

          $minutes = 120;
          $cookie = Cookie::make('name', 'value', $minutes);

          $response = Response::make('Hello World');
          $response->withCookie($cookie);

      - Добавить новую куку к следующему запросу:

          $minutes = 120;
          Cookie::queue('name', 'value', $minutes);

      - Создать куку, которая действует вечно, и добавить к след.запросу:

          Cookie::queue( Cookie::forever('name', 'value') );

      - Удалить куку по ключу:

          Cookie::queue( Cookie::forget('key') );


  > Получение информации о запросе

    > Введение:
      - Класс Request наследует класс "Symfony\Component\HttpFoundation\Request".
      - И поэтому содержит много методов для извлечения информации о запросе.

    > Примеры:
      - Получить URI запроса:

          $uri = Request::path();

      - Узнать метод запроса:

          $method = Request::method();

          if (Request::isMethod('post'))
          {
              //
          }

      - Проверить, бьётся ли путь запроса с RegExp:

          if (Request::is('admin/*'))
          {
              //
          }

      - Получить URL запроса:

          $url = Request::url();

      - Извлечь URI сегмент

          $segment = Request::segment(1);

      - Извлечь указанный заговок запроса:

          $value = Request::header('Content-Type');

      - Извлечь указанное значение из $_SERVER:

          $value = Request::server('PATH_INFO');

      - Выяснить, проходит ли это соединение через HTTPS:

          if (Request::secure())
          {
              //
          }

      - Выяснить, AJAX это запрос, или не AJAX:

          if (Request::ajax())
          {
              //
          }

      - Выяснить, является ли Content-Type запроса JSON-ом:

          if (Request::isJson())
          {
              //
          }

      - Выяснить, требует ли запрос в ответ JSON-строку:

          if (Request::wantsJson())
          {
              //
          }

      - Выяснить, в каком формате запрос требует ответ. Информация основана
        на на HTTP-заголовке Accept:

          if (Request::format() == 'json')
          {
              //
          }


6.  Выходы, views, редиректы

  --------------------------------------
  Подоглавление:

    - Основы формирования и отправки ответа на запрос
    - Формирование ответа в форматах: JSON, JSONP, file download response
    - Функции-макросы (автоматизация генерации Response-экземпляра)
    - Редиректы
    - Представления (views)
    - View Composers
    - View Creators

  --------------------------------------

  > Основы формирования и отправки ответа на запрос

    > Введение
      - Приложение на Laravel создано, чтобы получать запросы от пользователей.
      - На каждый запрос приложения обязано дать ответ.
      - Запрос в нём представлен объектом класса Request.
        - На входе этот класс формируется из HTTP-запроса, включающего тело.
        - На выходе мы получаем экземпляр - контейнер информации о запросе.
      - Ответ в Laravel представлен объектом класса Response.
        - На входе этот класс формируется из default-значений, заданных программистом,
          а также учитывается содержание объекта Request.
        - На выходе этот класс возвращает HTTP-ответ, включая тело.
        - Класс Response наследует от "Symfony\Component\HttpFoundation\Response",
          что обеспечивает набор методов для формирования HTTP-ответов.

    > Примеры
      - Из колбэк-функции роута вернуть строку. Будет автоматически сформирован
        response-объект, а из него HTTP-ответ с указанной телом-строкой и всеми
        остальными параметрами, вычисленными автоматом:

          Route::get('/', function()
          {
              return 'Hello World';
          });

      - В колбэк-функции роута вручную сформировать response-объект, и
        вернуть его:

          Route::get('/', function()
          {
            $contents = [значение];
            $statusCode = [значение];
            $value = [значение];

            // Создать новый экземпляр response-объекта
            $response = Response::make($contents, $statusCode);

            // Добавить в него HTTP-заголовок
            $response->header('Content-Type', $value);

            return $response;
          });

      - Если на выход надо послать view, то вместо Response::make надо
        использовать метод Response::view. Он также возвращает экземпляр
        класса Response:

          Route::get('/', function()
          {
            $value = [значение];

            // Создать новый экземпляр response-объекта в формате view
            $response = Response::view('hello');

            // Добавить в него HTTP-заголовок
            $response->header('Content-Type', $value);

            return $response;
          });

      - А вот так можно послать куки вместе с ответом:

          Route::get('/', function()
          {
            $content = [значение];
            $cookie = [значение];

            // Создать новый экземпляр response-объекта в формате view
            $response = Response::make($content);

            // Добавить в него куки
            $response->withCookie($cookie);

            return $response;
          });


  > Формирование ответа в форматах: JSON, JSONP, file download response

    > Создание ответа в формате JSON
      $response = Response::json(array('name' => 'Steve', 'state' => 'CA'));

    > Создание ответа в формате JSONP
      $response = Response::json(array('name' => 'Steve', 'state' => 'CA'))->setCallback(Input::get('callback'));

    > Создание ответа в формате 'file download response':
      - В Laravel скачкой файлов управляет synfony'вский модуль 'HttpFoundation'.
      - Он требует, чтобы имя файла было в кодировке ASCII.

        // Вариант 1
        $response = Response::download($pathToFile);

        // Вариант 2
        return Response::download($pathToFile, $name, $headers);


  > Функции-макросы (автоматизация генерации Response-экземпляра)

    > Введение
      - Позволяют создать макросы по формированию ответов.
      - Такой макрос можно можно использовать в роутах и контроллерах.
      - Цель: каждый раз не писать один и тот же код по созданию
        response-объекта, а автоматизировать этот процесс в функции.
      - Так что макрос - это функция, которая возвращает объект класса
        Response, а её имя становится стат.методом класса Response.

    > Примеры:
      - Создать макрос:

          Response::macro('caps', function($value)
          {
              return Response::make(strtoupper($value));
          });

      - Использовать макрос:

          $response = Response::caps('значение');


  > Редиректы

    > Введение
      - Из колбэк-функции роута можно произвести редирект на другую функцию.
      - Для этого надо вернуть объект класса RedirectResponse.
      - Целевая функция редиректа также обязана либо вернуть ответ, либо
        также осуществить редирект.
      - Есть 3 вида редиректа
          - На URI
          - На именованый роут
          - На метод контроллера

    > Примеры
      - Редирект на URI:
          return Redirect::to('user/login');

      - Перед редиректом добавить в объект сессионные данные:

          $r = Redirect::to('user/login');
          $r->with('message', 'Login Failed');
          return $r;

      - Редирект на именованый роут:
          return Redirect::route('login');

      - Редирект на именованый роут с параметрами:
          return Redirect::route('profile', array(1));

      - Редирект на именованый роут с именоваными параметрами:
          return Redirect::route('profile', array('user' => 1));

      - Редирект на метод контроллера:
          return Redirect::action('HomeController@index');

      - Редирект на метод контроллера с параметрами:
          return Redirect::action('UserController@profile', array(1));

      - Редирект на метод контроллера с именованными параметрами:
          return Redirect::action('UserController@profile', array('user' => 1));

  > Представления (views)

    > Введение:
      - Представления обычно содержат HTML + CSS + JS приложения.
      - Являются удобным способом отделить друг от друга: бизнес-логику,
        логику контроллера и логику представления информации.
      - Представления хранятся в папке "app/views".

    > Примеры передачи данных в представление:
      - Простое представление может выглядеть, например, так:

          <!-- View stored in app/views/greeting.php -->
          <html>
              <body>
                  <p>Hello, my name is <?php echo $name; ?></p>
                  <p>I am <?php echo $age; ?> years old.</p>
              </body>
          </html>

      - Это представление может быть возвращено в браузер из колбэк-функции
        роута вот так. Также обратите внимание, в этом примере мы передаём
        в представление значения переменных $name и $age, использованных выше:

          Route::get('/', function()
          {
              return View::make('greeting', array('name' => 'Taylor'));
          });

      - Любые данные можно расшарить (сделать доступными) для всех представлений
        приложения. Например, расшарим следующее: $name = 'Steve'

          View::share('name', 'Steve');

    > Примеры передачи одного представления в другое представление
      - Иногда может потребоваться передать одно представление в другое.
        Допустим, подпредставление хранится в "app/views/child/view.php".
        Тогда передать его в представление 'greeting' можно так:

          $view = View::make('greeting')->nest('child', 'child.view');
          $view = View::make('greeting')->nest('child', 'child.view', $data);

      - Переданное подпредставление будет доступно в представлении по
        указанному имени. В нашем примере, это 'child':

          <html>
              <body>
                  <h1>Hello!</h1>
                  <?php echo $child; ?>
              </body>
          </html>


  > View Composers

    > Введение
      - Событие composing возбуждается непосредственно перед рендерингом представления.
      - Рендеринг - получение DOM-структуры представления из его модели.
      - С помощью метода View::composer объекту-представлению можно назначить
        функцию-обработчик (анонимную или метод класса) события composing.
      - В Laravel такие обработчики называют "композер представления" (View Composer).
      - Их используют, если в представление каждый раз перед его рендерингом
        надо передавать фиксированный набор данных.

    > Архитектура использования
      1.  У нас есть 2 варианта, где хранить код функции-обработчика.
          > Вариант 1: в методе compose класса-композера
            - Можно создать для таких классов отдельную папку. Например: 'composer'.
            - В эту папку можно складывать файлы композер-классов.
            - В 1-м файле лучше всего хранить только 1 композер-класс.
            - В 1-м композер-классе должен быть только 1 метод: compose.
            - В теле метода compose находится код функции-обработчика.
            - Все классы-композеры надо добавить в IoC с помощью нового
              service-provider.
            - Как создать и добавить service-provider, читай в соответствующем
              разделе.
          > Вариант 2: в анонимной функции
            - При назначении обработчика события composing в кач-ве колбэк-функции
              указывается анонимная функция, в которой и находится код.
      2.  Назначение функции-обрабочтика
          - Для этого можно создать отдельный файл composers.php
          - Назначение производится с помощью метода View::composer
          - Получить доступ к классам из п.1 можно либо через IoC (рекомендуется),
            либо просто подключив их к этому файлу.
          - В этом файле можно провести все необходимые назначения.
      3.  Подключение файла composers.php к проекту
          - Файл composers.php должен быть выполнен при появлении запроса.
          - Хороший вариант: подключить его с помощью require в файл
            'app/start/global.php'.

    > Примеры
      - Вот шаблон для класса-композера (см. архитектура ч.1):

          // Лежит в отдельном файле ProfileComposer.php
          class ProfileComposer {

            public function compose($view) {

              // Добавить в представление переменную $count со
              // значением User::count()
                $view->with('count', User::count());

            }

          }

      - Вот как в файле composers.php можно назначить представлению 'profile'
        функцию-обработчик в виде метода composer класса-композера 'ProfileComposer'
        события 'composing' (см. архитектура ч.2):

          // Назначим представлению 'profile'
            View::composer('profile', 'ProfileComposer');

          // ... а вообще можно назначить сразу нескольким представлениям:
            View::composer(array('profile', 'anotherProfile'), 'ProfileComposer');

      - Вот как в файле composers.php можно назначить представлению 'profile'
        функцию-обработчик в виде анонимной функции события 'composing'
        (см. архитектура ч.2):

          // Назначим представлению 'profile'
            View::composer('profile', function($view)
            {

                // Добавить в представление переменную $count со
                // значением User::count()
                  $view->with('count', User::count());

            });

          // ... а вообще можно назначить сразу нескольким представлениям:
            View::composer(array('profile','dashboard'), function($view)
            {

                // Добавить в представление переменную $count со
                // значением User::count()
                  $view->with('count', User::count());

            });

      - Есть возможность за раз назначить нескольким представлениям указанные
        функции-обработчики. Например:

          View::composers(array(
              'AdminComposer' => array('admin.index', 'admin.profile'),
              'UserComposer' => 'user',
          ));

  > View Creators
    - Это почти тоже самое, что View Composers.
    - Отличие в том, что 'View Creator' срабатывает в начале создания нового
      экземпляра представления. А 'View Composer' срабатывает в начале создания
      DOM-представления из объекта-экземпляра представления. Последнее происходит
      при возвращении объекта-экземпляра представления командой return из
      функции-обработчика, которую запустил роут.
    - Вот переписка на стаке, которая также поясняет вышеописанные отличия:
        http://stackoverflow.com/questions/19265237/difference-between-view-composer-and-creator-in-laravel-4


> 7.  Контроллеры

  --------------------------------------
  Подоглавление:

    - Введение
    - Основы работы с контроллерами
    - Фильтры контроллеров
    - RESTful-контроллеры
    - Ресурсные контроллеры
    - Метод-отловитель (Catch-All) контроллера

  --------------------------------------

  > Введение
    - Выше уже было описано, что у роута может быть 2 варианта колбэк-функции.
    - Роут может быть на анонимную функцию или на метод контроллера.
    - Когда кода мало, то быстрее и проще сделать роут на анонимку прямо в routes.php.
    - Когда кода много, то лучше сделать роут на метод класса-контроллера.
    - Это позволит не засорять routes.php, сгребая всё в 1-ну кучу.
    - Обычно все файлы-контроллеры хранятся в папке "app/controllers".
      - Этот путь для них зарегистрирован по умолчанию в composer.json.
      - Однако, можно положить файл-контрорллер и в любую подпапку.
      - Например, положили мы его в папку "app/controllers/myFolder".
      - Теперь, чтобы всё заработало, надо выполнить команду композера dump-autoload.
    - Внимение! После создания нового класса-контроллера, надо выполнить
      команду композера dump-autoload, чтобы laravel увидел контроллер.

  > Основы работы с контроллерами

    > Введение
      - В 1-м php-файле должен быть только 1 класс-контроллер.
      - Класс-контроллер наследует от класса BaseController.
      - BaseController также хранится в папке "app/controllers".
      - В BaseController можно поместить некую общую для всех контроллеров логику.
      - BaseController наследует от класса Controller.

    > Примеры
      - Пример класса-контроллера:

          class UserController extends BaseController {

            // Показать представление с профилем указанного пользователя
              public function showProfile($id)
              {
                  $user = User::find($id);

                  return View::make('user.profile', array('user' => $user));
              }

          }

      - Назначим метод showProfile из контроллера UserController в качестве
        колбэк функции для роута:

          Route::get('user/{id}', 'UserController@showProfile');

      - Если для контроллера задействованы пр.имён, то вот как можно
        было бы, например, написать пример выше:

          Route::get('foo', 'Namespace\FooController@method');

      - Можно задать имя для контроллера в определении роута
        (пока не понятно зачем это надо):

          Route::get('foo', array('uses' => 'FooController@method',
                                                  'as' => 'name'));

      - Сгенерировать URL на controller action можно так:

          // вариант 1
          $url = URL::action('FooController@method');

          // вариант 2
          $url = action('FooController@method');

      - Получить имя запущенного controller action можно так:

          $action = Route::currentRouteAction();

  > Фильтры контроллеров

    > Введение
      - В разделе "4.  Routing" в пункте 4.3 описаны фильтры роутинга.
      - Там рассмотрено применение фильтров к роутам на анонимную функцию.
      - Для роутов на метод контроллера всё работает точно также.
      - Но есть преимущество - ещё можно определять и назначать фильтры
        внутри класса-контроллера.
      - В этом разделе ниже вы можете найти несколько практичных примеров.


    > Примеры
      - Назачить before-фильтр auth роуту на метод контроллера:

          Route::get('profile', array('before' => 'auth',
                      'uses' => 'UserController@showProfile'));

      - Вот как можно назначать фильтры в функции-конструкторе контроллера.
        Здесь они просто назначаются, а определены в другом месте:

          class UserController extends BaseController {

            // Функция-конструктор контроллера
              public function __construct()
              {
                  $this->beforeFilter('auth', array('except' => 'getLogin'));

                  $this->beforeFilter('csrf', array('on' => 'post'));

                  $this->afterFilter('log', array('only' =>
                                      array('fooAction', 'barAction')));
              }

          }

      - А вот как можно определить фильтр прямо в функции-конструкторе
        контроллера:

          class UserController extends BaseController {

            // Функция-конструктор контроллера
              public function __construct()
              {
                  $this->beforeFilter(function()
                  {
                      //
                  });
              }

          }

      - Фильтр также может быть определён, как отдельный метод контроллера.
        Тогда, чтобы назначить этот фильтр роуту из конструктора:

          class UserController extends BaseController {

            // Функция-конструктор контроллера
              public function __construct()
              {
                  $this->beforeFilter('@filterRequests');
              }

            // Определение фильтра в отдельном методе контроллера
              public function filterRequests($route, $request)
              {
                  //
              }

          }

  > RESTful-контроллеры

    > Введение
      - REST API - это такая архитектура, которая позволяет посылая запросы
        на один и тот же URI, но разными HTTP-методами и с разным набором
        параметров, получать разные ответы.
      - Laravel позволяет организовать такую архитектуру. Для этого понадобятся
        1 роут и 1 класс-контроллер.
      - Этот класс-контроллер и называют "RESTful controller".
      - Внимение! После создания нового класса-контроллера, надо выполнить
        команду композера dump-autoload, чтобы laravel увидел контроллер.

    > Практика

      # Вот как определяется роут, который будет работать с REST-контроллером:
        - 1-й аргумент: базовый URI для контроллера
        - 2-й аргумент: имя класса REST-контроллера

          Route::controller('users', 'UserController');

      # Вот как определяется класс REST-контроллера:
        - Внутри него для разруливания запросов определяются методы.
        - Имя метода определяется по шаблону: [HTTP-метод] + [имя метода].
        - [HTTP-метод] должен быть написан полностью маленькими буквами.
        - [имя метода] должно начинаться с большой буквы.
        - Если [имя метода] содержит несколько слов, то осуществить запрос
          по такому URI можно, указывая в запросе эти слова через '-'.
        - Все методы, у которых [имя метода] == 'Index', срабатывают при
          запросе к базовому URI контроллера. В примере выше это: 'users'.
        - В примерах ниже допустим, что:
          - URL нашего сайта "www.site.ru"
          - Роут определён как в примере выше

          class UserController extends BaseController {

            // Этот метод сработает вот в каком случае:
            // - Запрос должен осуществляться HTTP-методом GET
            // - Запрос должен быть по адресу: "www.site.ru/users"
              public function getIndex()
              {
                  //
              }

            // Этот метод сработает вот в каком случае:
            // - Запрос должен осуществляться HTTP-методом POST
            // - Запрос должен быть по адресу: "www.site.ru/users/profile"
              public function postProfile()
              {
                  //
              }

            // Этот метод сработает вот в каком случае:
            // - Запрос может осуществляться любым HTTP-методом
            // -Запрос должен быть по адресу: "www.site.ru/login"
              public function anyLogin()
              {
                  //
              }

            // Этот метод сработает вот в каком случае:
            // - Запрос должен осуществляться HTTP-методом GET
            // - Запрос должен быть по адресу: "www.site.ru/users/admin-profile"
              public function getAdminProfile()
              {
                  //
              }

          }

      # Метод для отлова не пойманных другими запросов
        - Может статься, что ни 1 метод REST-контроллера не поймает запрос.
        - Такие "непойманные" методы может поймать спец. метод.
        - Он должен называться "missingMethod":

            public function missingMethod($parameters = array())
            {
                //
            }


  > Ресурсные контроллеры

    > Введение
      - По сути это тоже самое, что REST-контроллер.
      - Но архитектура работы с ресурсными контроллерами несколько отичается.
      - Их предназначение - выстраивание REST-архитектуры вокруг ресурсов.
      - Например, управление работой с какими-нибудь фотографиями или другими ресурсами.

    > Фиксированный набор методов ресурсного контроллера

      > Введение
        - В отличие от REST-контроллера, у класса ресурсного контроллера
          изначально есть ограниченный набор методов.


      > Изначальный набор методов ресурсного контроллера:

      HTTP-Метод  Путь                        Имя метода    Имя роута
    ------------------------------------------------------------------------
      GET	        /resource	                  index	        resource.index
      GET	        /resource/create	          create	      resource.create
      POST	      /resource	                  store	        resource.store
      GET	        /resource/{resource}	      show	        resource.show
      GET	        /resource/{resource}/edit	  edit	        resource.edit
      PUT/PATCH	  /resource/{resource}	      update	      resource.update
      DELETE	    /resource/{resource}	      destroy	      resource.destroy


    > Работа с ресурсными контроллерами

      # Так можно с помощью 1-й artisan-команды в консоли быстро создать
        готовый шаблон ресурсного контроллера в папке 'app/controllers'.

          // Создать ресурсный контроллер
          // - С именем PhotoController
          // - С полным набором шаблонов-методов

            php artisan controller:make PhotoController

          // Создать ресурсный контроллер с опцией --only
          // - Эта опция позволяет указать в команде через запятую имена методов.
          // - Шаблоны в классе-ресурсном-контроллере будут созданы только для них
          // - А для не указанных методов шаблоны будут отсутствовать

            php artisan controller:make PhotoController --only=index,show

          // Создать ресурсный контроллер с опцией --except
          // - Эта опция позволяет указать в команде через запятую имена методов.
          // - Шаблоны в классе-ресурсном-контроллере НЕ будут созданы только для них
          // - А для не указанных методов шаблоны будут присутствовать

            php artisan controller:make PhotoController --except=index

      # Вот как можно зарегистрировать ресурсный контроллер для роута:

            Route::resource('photo', 'PhotoController');

      # Чтобы расширить ресурсный контроллер дополнительными методами,
        сверх изначального набора, нужно:
        - Создать этот метод в классе ресурсного контроллера.
        - До регистрации ресурсного контроллера создать роут на этот
          дополнительный метод.

            Route::get('photo/my', 'PhotoController@mymethod');
            Route::resource('photo', 'PhotoController');

      # По умолчанию роут, для которого зарегистрирован ресурсный контроллер,
        пропускает запрос для каждого из зарегистрированных в классе методов
        из стандартного набора.

          //Однако при определении роута с помощью параметра 'only' можно указать
          //список имён методов из стандартного набора, и только для них
          //роут будет осуществлять марштуризацию:
            Route::resource('photo', 'PhotoController',
                            array('only' => array('index', 'show')));

          //А с помощью параметра 'except' можно указать список имён методов
          //из стандартного набора, и роут будет осуществлять марштуризацию
          //для всех, кроме этих:
            Route::resource('photo', 'PhotoController',
                            array('except' => array('create', 'store', 'update', 'delete')));


  > Метод-отловитель (Catch-All) контроллера

    > Введение
      - Ну допустим мы создали роут на REST-контроллер.
      - Может оказаться, что в нём нет метода, отвечающего запросу.
      - В таком случае запрос пропадёт, ответа на него не будет. Нехорошо.
      - И тут нам поможет метод-отловитель, который как раз и ловит такие
        не пойманные другими методами REST-контроллера запросы.

    > Определение метода-отловителя в классе REST-контроллера

        public function missingMethod($parameters = array())
        {
            //
        }


> 8.  Ошибки и ведение лога

  --------------------------------------
  Подоглавление:

    - Введение
    - Про модуль Monolog
    - Детализация ошибок
    - Обработка исключений
    - HTTP-исключения
    - Обработка ошибок 404
    - Ведение лога

  --------------------------------------

  > Введение
    - В Laravel есть встроенная система работы с ошибками.
    - Функции-обработчики ошибок надо размещать в файле "app/global.php".
      Чтобы они назначались непосредственно перед началом работы приложения.
    - Или их можно размещать в других файлах, но добавлять в global.php с помощью require.
    - Также Laravel позволяет вести лог с помощью модуля Monolog.

  > Про модуль Monolog
    - Это продвинутая библиотека, которая позволяет вести логи.
    - Monolog встроен в Laravel в виде модуля.
    - Monolog может отсылать логи: в файл, в сокет, по почте, в базу данных,
      в веб-сервисы.
    - Реализует стандарт PSR-3.
    - Адрес на гитхабе:
        https://github.com/seldaek/monolog

  > Детализация ошибок
    - В Laravel у приложения можно вкл/выкл debug-режим.
    - Если он вкл, то в случае ошибки на экран будет выведена расширенная информация о ней.
    - Вкл/выкл debug-режим можно в файле "app/config/app.php", параметр "debug".
    - По умолчанию, debug-режим включён.
    - В продакшене рекомендуется debug-режим выключить. Иначе хакеры смогут
      получить много лишней информации о вашем приложении.

  > Обработка исключений

    > Введение
      - Для обработки ошибок надо назначать функции-обработчики событий-ошибок.
      - Исполняться этот код должен в начале работы приложения в файле "app/global.php".

    > Где размещать код с назначением обработчиков?
      - Вариант 1:  если код не велик, то можно прямо в файле "global.php"
      - Вариант 2:  если код велик, то можно вынести его в отдельный файл,
                      а в файл global.php добавить с помощью require.
      - Вариант 3:  если код велик, то вместо варианта 2 можно создать
                    service provider, и разместить код там. Он исполнится
                    при старте приложения и назначит нужные обработчики.

    > Порядок определения обработчиков
      - Допустим, у нас есть несколько обработчиков.
      - Тогда их надо определять об более общего к менее общему.
      - Например, обработчик Exception более общий, чем RuntimeException.

    > Практика
      - По умолчанию в файле "app/start/global.php" присутствует назначение
        обработчика, который обрабатывает все ошибки:

          App::error(function(Exception $exception)
          {
              // Послать error-запись в лог
                Log::error($exception);
          });

      - Назначить обработчик, который обрабатывает только исключения типа
        RuntimeException:

          App::error(function(RuntimeException $exception)
          {
              // Handle the exception...
          });

      - Если обработчик исключения возвращает что-либо с помощью return,
        то это будет отправлено в браузер, и больше никакие другие
        обработчики исключений не сработают:

          App::error(function(InvalidUserException $exception)
          {
              // Послать error-запись в лог
                Log::error($exception);

              // Эта строка отправится в браузер
                return 'Sorry! Something is wrong with this account!';
          });

      - Для перехвата ошибок PHP типа 'fatal error', можно использовать
        метод App::fatal:

          App::fatal(function($exception)
          {
              //
          });

  > HTTP-исключения
    - Некоторые исключения описывают код ошибки с сервера.
    - Например, это может быть ошибка (404) "page not found". Или ошибка
      (401) "unauthorized error". Или ошибка (500), сгеренировання разработчиком.
    - Примеры:

        // Возбудить исключение 404
          App::abort(404);

        // Возбудить исключение 403 с сообщением
          App::abort(403, 'Unauthorized action.');

  > Обработка ошибок 404
    - Можно зарегистрировать функцию-обработчик, которая обрабатывает
      исключение "404 Not Found":

        App::missing(function($exception)
        {
            return Response::view('errors.missing', array(), 404);
        });

  > Ведение лога

    > Введение
      - Laravel позволяет вести лог с помощью модуля Monolog.
      - Про модуль Monolog можно прочитать выше.
      - По умолчанию, Laravel создаёт 1 log-файл для приложения, который
        хранится по адресу "app/storage/laravel.log".

    > 7 видов сообщений для сохранения в лог
      - debug
      - info
      - notice
      - warning
      - error
      - critical
      - alert

    > Практика
      - Записывать информацию в лог можно так:

          Log::info('This is some useful information.');

          Log::warning('Something could be going wrong.');

          Log::error('Something is really going wrong.');

      - Получить доступ к используемому Laravel экземпляру Monolog можно так:

          $monolog = Log::getMonolog();

      - Можно зарегистрировать обработчикй событий, чтобы перехватывать
        в нём сообщения, передаваемые логу:

          Log::listen(function($level, $message, $context)
          {
              //
          });


9.  Artisan CLI

  --------------------------------------
  Подоглавление:

    - Введение
    - Основы работы с Artisan
    - Список стандартных опций и команд Artisan
    - Разработка собственных команд для Artisan

  --------------------------------------

  > Введение
    - Artisan CLI - интерфейс командной строки для работы с Laravel.
    - Доступен ряд стандартных команд, полезных при разработке приложений.
    - Основан на консольном компоненте из Synfony.

  > Основы работы с Artisan

    > Как начать использовать?
      1.  Открыть консоль.
      2.  Перейти в корневую папку Laravel-приложения.
      3.  Из этого места можно начинать пользоваться Artisan CLI.

    > Несколько основных опций и команд

      - Вывести на экран список всех доступных опций и команд:
          php artisan list

      - Посмотреть справку по указанной команде:
          php artisan help [имя команды]

      - Указать среду, которая будет использована во время исполнения команды:
          php artisan migrate --env=[имя среды]

      - Вывести текущую версию Laravel на экран:
          php artisan --version

  > Список стандартных опций и команд Artisan

    > Шаблон использования:

        php artisan [options] command [arguments]

    > Опции:

      # --help            -h    | Вывести справку:
                                  - Если команда не указана, то для себя.
                                  - Если команда указана, то для неё.
      # --quiet           -q    | Запретить вывод каких-либо сообщений
      # --verbose   -v -vv -vvv | Управление детализацией вывода:
                                  - Чем больше v, тем детальнее.
                                  - Значение '-vvv' можно использовать для дебага.
      # --version         -V    | Вывести версию Laravel
      # --ansi                  | Выводить текст в формате ANSI
      # --no-ansi               | Выводить текст в формате не-ANSI
      # --no-interaction  -n    | Не задавать никаких интерактивных вопросов.
      # --env                   | Указать среду, в которой будет выполняться команда

    > Команды:

      # changes                   | Вывести список изменений в Laravel с последней x.y версии
      # clear-compiled            | Удалить файл compiled class
      # down                      | Перевести приложение в режим "тех.обсллуживания"
      # up                        | Вывести приложение из режима "тех.обсллуживания"
      # dump-autoload             | Перегенерировать файлы автозагрузки фреймворка
      # env                       | Вывести имя текущей среды приложения
      # help                      | Тоже самое, что --help
      # list                      | Вывести на экран список всех доступных опций и команд
      # migrate                   | Запустить миграции базы данных
      # optimize                  | Оптимизировать фрейворк, чтобы улучшить производительность
      # routes                    | Вывести список зарегистрированных роутов
      # serve                     | Работать через встроенный в PHP сервер:
                                    - Автоматически запускает встроенный в PHP сервер.
                                    - Дальше приложение работает через него
      # tail                      | Отслеживать ошибки и выводить сообщения в консоль
                                    - Полезно при debug == false в app.php
      # tinker                    | "Поиграться" с приложением в командной строке
                                    - Подробнее о работе с tinker можно почитать здесь:
                                        http://blog.enge.me/post/tinkering-with-tinker-like-an-artisan
      # workbench                 | Создать новый package workbench
                                    - Подробнее см. здесь: http://laravel.com/docs/packages

      # asset:publish             | Опубликовать package's assets в публичную директорию

      # auth:clear-reminders      | Очиститься от истёкших reminder'ов
      # auth:reminders-controller | Создать пароль для reminder-контроллера
      # auth:reminders-table      | Создать миграцию для таблицы с password reminders

      # cache:clear               | Очистить кэш приложения

      # command:make              | Создать новую artisan-команду

      # config:publish            | Опубликовать конфигурацию package'а в приложении

      # controller:make           | Создать новый ресурсный контроллер

      # db:seed                   | Засеять базу данных записями

      # ide-helper:generate       | Сгенерировать новый файл IDE Helper File
      # ide-helper:models         | Сгенерировать автозавершение для моделей

      # key:generate              | Установить ключ приложения

      # migrate:install           | Создать новый репозиторий миграций
      # migrate:make              | Создать новый файл-миграцию
      # migrate:publish           | Опубликовать миграции package'а в приложение
      # migrate:refresh           | Сбросить и перезапустить все миграции
      # migrate:reset             | Откатить все миграции БД
      # migrate:rollback          | Откатить последнюю миграцию БД

      # queue:failed              | Список всех неудавшихся заданий
      # queue:failed-table        | Создать миграцию для таблицы в БД списка всех неудавшихся заданий
      # queue:flush               | Удалить все неудавшиеся задания
      # queue:forget              | Удалить неудавшееся задание
      # queue:listen              | Отслеживать указанное задание
      # queue:retry               | Попробовать перевыполнить неудавшееся задание
      # queue:subscribe           | Подписать URL на Iron.io push queue
      # queue:work                | Выполнить следующее задание по списку

      # session:table             | Создать миграцию для таблицы из БД, в которой лежат сессионные данные

      # view:publish              | Опубликовать представления package'а в приложение

  > Разработка собственных команд для Artisan

      [... описать по требованию ...]



|--------------------------------------------------------------------------
| База данных
|--------------------------------------------------------------------------
|
| В этом разделе описана работа с базами данных в Laravel
|


10. Основы работы с БД в Laravel

  --------------------------------------
  Подоглавление:

    - Настройка
    - Разные настройки соединения для операций чтение/запись.
    - Выполнение запросов
    - Работа с транзакциями
    - Доступ к другим соединениям и манипуляции с ними
    - Ведение лога запросов

  --------------------------------------

  > Настройка
    - Настроить подключения к БД в Laravel можно в файле "app/config/database.php".
    - Все соединения там хранятся в массиве в параметре "connections".
    - В этом же файле можно указать соединение "по умолчанию" в параметре "default".
    - А всего Laravel поддерживает 4 СУБД: MySQL, Postgres, SQLite, SQL Server.

  > Разные настройки соединения для операций чтение/запись.

    > Введение
      - Иногда может понадобиться установить разные настройки для операций чтения/записи.
        - Операции чтения: SELECT
        - Операции записи: INSERT, UPDATE, DELETE.
      - Laravel позволяет это организовать.
      - И это будет работать независимо от того, каким способом сделан запрос:
        простой запрос, query builder или Eloquent ORM.

    > Как реализуется
      - Реализуется всё с помощью ключей 'read' и 'write'
      - Эти ключи добавляются в массив настроек соединения.
      - В каждом из них могут быть все теже самые параметры, что в массиве настроек.
      - В случае операции чтения значения из массива 'read' заменят значения
        соответствующих параметров в массиве настроек соединения.
      - В случае операции записи значения из массива 'write' заменят значения
        соответствующих параметров в массиве настроек соединения.

    > Пример:

      1 Вот у нас в файле database.php в массиве 'connections' есть ключ 'mysql',
        который символизитует одно из соединений. В нём лежит вот такой массив с
        настройками этого соединения:

          'mysql' => array(
              'host'      => 'localhost:3308',
              'driver'    => 'mysql',
              'database'  => 'database',
              'username'  => 'root',
              'password'  => '',
              'charset'   => 'utf8',
              'collation' => 'utf8_unicode_ci',
              'prefix'    => '',
          )

      2 Допустим, мы хотим, чтобы для операций чтения/записи были разные
        значения 'host'. Тогда этот массив будет выглядеть так:

          'mysql' => array(
              'read' => array(
                  'host' => '192.168.1.1',
              ),
              'write' => array(
                  'host' => '196.168.1.2'
              ),
              'driver'    => 'mysql',
              'database'  => 'database',
              'username'  => 'root',
              'password'  => '',
              'charset'   => 'utf8',
              'collation' => 'utf8_unicode_ci',
              'prefix'    => '',
          )

  > Выполнение запросов

    > Введение
      - Как только соединение с БД настроено, можно делать к ней запросы.
      - Функционал для этого сконцентрирован и доступен в классе "DB".

    > Практика
      - Выполнить запрос SELECT, и получить массив результатов.
          Обратите внимание, здесь использован 1 плейсхолдер '?',
          значение которого заменяется в запросе на 1.
            $results = DB::select('select * from users where id = ?', array(1));

      - Выполнить запрос INSERT.
          Здесь уже использованы 2 плейсхолдера '?'. Значение первого в запросе
          заменяется на 1, а втого на 'Dayle'.
            DB::insert('insert into users (id, name) values (?, ?)', array(1, 'Dayle'));

      - Выполнить запрос UPDATE
          DB::update('update users set votes = 100 where name = ?', array('John'));

      - Выполнить запрос DELETE
          DB::delete('delete from users');

      - Просто выполнить указанный запрос:
          DB::statement('drop table users');

      - Назначить функци-обработчик, которая будет отлавливать все события,
        возбуждаемые при исполнении запросов к БД:

          DB::listen(function($sql, $bindings, $time)
          {
              //
          });

  > Работа с транзакциями

    > Введение
       - Функционал Laravel позволяет рабоать и с транзакциями.
       - Если внутри транзакции возникает любое исключение, происходит ролбэк автоматом.

    > Практика
      - Способ №1: использовать метод DB::transaction
          Выполнить несколько запросов одной транзакцией:

            DB::transaction(function()
            {
                DB::table('users')->update(array('votes' => 1));

                DB::table('posts')->delete();
            });

      - Способ №2: управление транзакцией вручную

          // Начать транзакцию
            DB::beginTransaction();

          // Сделать коммит
            DB::commit();

          // Сделать ролбэк
            DB::rollback();

  > Доступ к другим соединениям и манипуляции с ними

    > Практика:
      - В приложении может быть настроено > 1 соединения. Что, если мы
        хотим выполнить операцию не с default-соединением?
        Это можно сделать так:

          $users = DB::connection('foo')->select(...);

      - Получить ссылку на underlying PDO-объект-соединение можно так:

          $pdo = DB::connection()->getPdo();

      - Сделать реконнект соединения можно так:

          DB::reconnect('foo');

      - Сделать дисконнект соединения можно так:

          DB::disconnect('foo');

  > Ведение лога запросов

    > Введение
      - По умолчанию Larvel ведёт лог всех запросов к БД, которые были сделаны
        в этом экземпляре приложения, в оперативной памяти.
      - Минус такого подхода - если запросов очень много, то приложение может
        начать расходовать много оперативки.

    > Практика:

      - Отключить ведение лога запросов к БД в оперативке:
          DB::connection()->disableQueryLog();

      - Получить массив исполненных запросов:
          $queries = DB::getQueryLog();


11. Query Builder (строилка запросов)

  --------------------------------------
  Подоглавление:

    - Введение
    - Декомпозиция описания Query Builder

  --------------------------------------

  > Введение

    > В общем про "Query Builder"
      - В Laravel можно делать запросы к БД вручную их прописывая, как строку.
      - Как делать такие запросы, описано выше в главе 10.
      - А можно использовать специальный функционал "Query Builder" класса DB.
      - В этой главе как раз и описывается использование этого функционала.

    > Недостатки и преимущества функционала "Query Builder"

      > Относительно чего сравниваем "Query Builder"?
        - Относительно ввода запросов к БД вручную, как описано в главе 10.

      > Недостатки
        - Вручную можно составить запрос гибче.
        - Вручную при составлении запроса можно использовать особенности
          конкретной СУБД, а при использовании "Query Builder" нельзя.

      > Преимущества
        - Универсален. Работает со всеми 4-мя поддерживаемыми СУБД. При этом
          использовать надо один и тот же функционал без изменений. Как следствие,
          можно использовать любую БД из поддерживаемых, даже не зная диалектов.
        - Нет необходимости "чистить" строки-параметры, передаваемые функционалу
          "Query Builder", чтобы защититься от SQL Injection. Потому что этот
          функционал использует PDO.
        - Удобен. Благодаря "IDE Helper Generator" в PHPStorm для всех классов
          Laravel, в т.ч. DB, работает автозавершение.

  > Декомпозиция описания Query Builder (QB)

    11. Query Builder
      11.1. Selects
        - Описан функционал QB для выполнения SELECT-запроса к БД

      11.2. Joins
        - Описан функционал QB для работы с JOIN-утверждениями.

      11.3. Продвинутый where с анонимной функцией
        - Описан функционал QB для продвинутой работы с выражениями
          с атрибутом WHERE.

      11.4. Aggregates
        - Описан функционал QB для работы с агрегирующими функциями.
        - Такими как: count, max, min, avg, sum.

      11.5. Выражения в чистом виде; инкремент/декремент значений колонки
        - Описан функционал QB, позволяющий вставлять строки с кусками
          произвольного SQL в запрос, составленный с помощью QB.
        - Это позволяет писать более гибкие запросы, используя QB.
        - Также здесь описано инкрементирование/декрементирование
          всех значений в указанной колонке таблицы.

      11.6. Inserts
        - Описан функционал QB для работы с INSERT-утверждениями.

      11.7. Updates
        - Описан функционал QB для работы с UPDATE-утверждениями.

      11.8. Deletes
        - Описан функционал QB для работы с DELETE-утверждениями.

      11.9. Unions
        - Описан функционал QB, который позволяет "объединять" два
          запроса в один (не путать с UNION из SQL)

      11.10.  Pessimistic Locking
        - Описан функционал QB для организации pessimistic locking.
          - Optimistic Locking - запись в БД не блокируется, пока твой запрос
            проводит с ней операции. Но если она в течение этого времени
            изменилась, то и все проведённые операции отменяются (ролбэк).
          - Pessimistic Locking - запись в БД блокируется для других запросов,
            пока твой запрос проводит с ней операции.
          - Про optimistic/pessimistic locking можно прочитать здесь:
              http://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking

      11.11.  Кэширование результатов запросов
        - Описан функционал QB для кэширования результатов SQL-запросов.


  > 11.1. Selects

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для выполнения SELECT-запроса к БД

    > Практика

      # Извлечь все строки из таблицы
        - Извлечь их:

            $users = DB::table('users')->get();

        - Пробежаться по всем строкам, и вывести содержание поля 'name' каждой:
            foreach ($users as $user)
            {
                var_dump($user->name);
            }

      # Извлечь первую найденную строку из таблицы
        - В таблице 'users' найти все строки, в которых значение в столбце
          'name' равно 'John', и вернуть первую из них:

            $user = DB::table('users')->where('name', 'John')->first();

        - Вывести на экран значение из столбца 'name' из найденной строки:

            var_dump($user->name);

      # Извлечь значение из одной ячейки из одной найденной строки
        - В таблице 'users' найти все строки, в которых значение в столбце
          'name' равно 'John', и из первой из них извлечь и вернуть значение
          из столбца 'name':

            $name = DB::table('users')->where('name', 'John')->pluck('name');

      # Извлечь массив полей из указанной колонки таблицы:
        - Извлечь массив значений полей колонки 'title' таблицы 'roles':

            $roles = DB::table('roles')->lists('title');

      # Извлечь из таблицы все строки, но только из указанных столбцов:
        - Из таблицы 'users' из столбцов 'name' и 'email' извлечь
          все строки:

            $users = DB::table('users')->select('name', 'email')->get();

      # Извлечь из таблицы все уникальные строки (дублирующие не возвращать):
        - Из таблицы 'users' извлечь все уникальные строки:

            $users = DB::table('users')->distinct()->get();

      # Использование псевдонима для заголовка столбца:
        - Из таблицы 'users' извлечь все строки, но для столбца 'name'
          использовать в результате псевдоним 'user_name':

            $users = DB::table('users')->select('name as user_name')->get();

      # Дополнить уже существующий запрос select новым столбцом:
        - Создать SQL-запрос и сохранить его в переменную. Он должен из
          таблицы 'users' извлечь все строки для столбца 'name':

            $query = DB::table('users')->select('name');

        - Дополнить запрос $query - чтобы он извлекал данные ещё из из
          столбца 'age':

            $query = $query->addSelect('age');

        - Выполнить запрос $query и получить результат:

            $users = $query->get();

      # Использование оператора where:
        - Из таблицы 'users' извлечь все строки, у которых в столбце
          'votes' значение > 100:

            $users = DB::table('users')->where('votes', '>', 100)->get();

      # orWhere - одновременное использование нескольких where:
        - Из таблицы 'users' извлечь все строки, у которых или в столбце
          'votes' значение > 100, или в столбце 'name' значение 'John':

            $users = DB::table('users')
                                ->where('votes', '>', 100)
                                ->orWhere('name', 'John')
                                ->get();

      # whereBetween
        - Из таблицы 'users' извлечь все строки, у которых значение
          в столбце 'votes' находится между 1 и 100:

            $users = DB::table('users')
                                ->whereBetween('votes', array(1, 100))->get();

      # whereNotBetween
        - Из таблицы 'users' извлечь все строки, у которых значение
          в столбце 'votes' находится НЕ между 1 и 100:

            $users = DB::table('users')
                                ->whereNotBetween('votes', array(1, 100))->get();

      # WhereIn с массивом значений:
        - Из таблицы 'users' извлечь все строки, у которых значение в
          столбце 'id' равно хотя бы одному из переданных в массиве значений:

            $users = DB::table('users')
                                ->whereIn('id', array(1, 2, 3))->get();

      # WhereNotIn с массивом значений:
        - Из таблицы 'users' извлечь все строки, у которых значение в
          столбце 'id' НЕ равно НИ одному из переданных в массиве значений:

            $users = DB::table('users')
                                ->whereNotIn('id', array(1, 2, 3))->get();

      # whereNull
        - Из таблицы 'users' извлечь все строки, у которых значения в
          столбце 'updated_at' равну null (не установлены):

            $users = DB::table('users')
                                ->whereNull('updated_at')->get();

      # Использование Order By, Group By, Having:
        - Извлечь все строки из таблицы 'users'.
        - Отсортировать их по убыванию (orderBy).
        - Сгруппировать по столбцу count (groupBy).
        - Вернуть те строки, у которых значение в столбце 'count' > 100.

            $users = DB::table('users')
                                ->orderBy('name', 'desc')
                                ->groupBy('count')
                                ->having('count', '>', 100)
                                ->get();

      # Использование OFFSET и LIMIT
        - Примечания:
          - skip(n) - это offset, а take(n) - это limit
          - Отсчёт строк в таблицы нечинается не с 1, а с 0.
        - Извлечь все строки из таблицы 'users'. Из них вернуть вернуть
          5 строк, начиная с №10:

            $users = DB::table('users')->skip(10)->take(5)->get();


  > 11.2. Joins

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для работы с JOIN-утверждениями.

    > Практика

      # Inner join
        - Есть 3 таблицы: 'users', 'contacts' и 'orders.
        - В результирующей таблице должны быть только следующие столбцы:
          'users.id', 'contacts.phone' и 'orders.price'.
        - В результирующую таблицу должны попасть только те строки, которые
          удовлетворяют условиям.
        - Условие 1: users.id == contacts.user_id
        - Условие 2: users.id == orders.user_id
        - На выходе будет массив объектов, где каждый объект представляет
          одну результирующую строку.

          $result = DB::table('users')
                      ->join('contacts', 'users.id', '=', 'contacts.user_id')
                      ->join('orders', 'users.id', '=', 'orders.user_id')
                      ->select('users.id', 'contacts.phone', 'orders.price');

      # Left join
        - Есть 2 таблицы: 'users' и 'posts'.
        - Нужно для каждой строки из 'users' вывести все строки из 'posts',
          для которых 'users.id' == 'posts.user_id'. Если, например, у
          юзера с users.id = 2 в таблице 'posts' есть 3 поста, то для него
          будут выведены 3 строки: слева будут одинаковые строки из
          таблицы 'users', в которых users.id == 2, а справа разные строки
          из таблицы 'posts' с постами этого юзера.
        - На выходе будет массив объектов, где каждый объект представляет
          одну результирующую строку.

          DB::table('users')
                  ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
                  ->get();

      # Пример продвинутых inner join

        // Один
          DB::table('users')
                  ->join('contacts', function($join)
                  {
                      $join->on('users.id', '=', 'contacts.user_id')->orOn(...);
                  })
                  ->get();

        // Два
          DB::table('users')
                  ->join('contacts', function($join)
                  {
                      $join->on('users.id', '=', 'contacts.user_id')
                           ->where('contacts.user_id', '>', 5);
                  })
                  ->get();

  > 11.3. Продвинутый where с анонимной функцией

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для продвинутой работы с выражениями
        с атрибутом WHERE.

    > Практика

      > Пример №1

        - Вот это QB-выражение...

            DB::table('users')
                        ->where('name', '=', 'John')
                        ->orWhere(function($query)
                        {
                            $query->where('votes', '>', 100)
                                  ->where('title', '<>', 'Admin');
                        })
                        ->get();

        - ... на выходе даёт вот такой SQL:

            "select * from users where name = 'John' or
                                    (votes > 100 and title <> 'Admin')"

      > Пример №2

        - Вот это QB-выражение...

            DB::table('users')
                        ->whereExists(function($query)
                        {
                            $query->select(DB::raw('*'))
                                  ->from('orders')
                                  ->whereRaw('orders.user_id = users.id');
                        })
                        ->get();

        - ... на выходе даёт вот такой SQL

            select * from users
            where exists (
                select * from orders where orders.user_id = users.id
            )

  > 11.4. Aggregates

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для работы с агрегирующими функциями.
      - Такими как: count, max, min, avg, sum.

    > Практика

      # count() - подсчитать кол-во строк в таблице и вернуть значение:
        $users = DB::table('users')->count();

      # max(col) - найти MAX значение в колонке col, и вернуть его:
        $price = DB::table('orders')->max('price');

      # min(col) - найти MIN значение в колонке col, и вернуть его:
        $price = DB::table('orders')->min('price');

      # avg(col) - найти среднее среди значений колонки col, и вернуть его:
        $price = DB::table('orders')->avg('price');

      # sum(col) - найти сумму значений в колонке col, и вернуть её:
        $total = DB::table('users')->sum('votes');


  > 11.5. Выражения в чистом виде; инкремент/декремент значений колонки

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB, позволяющий вставлять строки с кусками
        произвольного SQL в запрос, составленный с помощью QB.
      - Это позволяет писать более гибкие запросы, используя QB.
      - Также здесь описано инкрементирование/декрементирование
        всех значений в указанной колонке таблицы.

    > Практика

      - В этом примере в функцию select() вставлен кусок SQL-кода
        с помощью DB::raw(), описывающий это выражение SELECT:

          $users = DB::table('users')
                       ->select(DB::raw('count(*) as user_count, status'))
                       ->where('status', '<>', 1)
                       ->groupBy('status')
                       ->get();

      - В таблице 'users' в столбце 'votes' с цифровым значением, во всех
        строках этого столбца инкрементировать значение на:

          // На 1
            DB::table('users')->increment('votes');

          // На 5
            DB::table('users')->increment('votes', 5);

      - В таблице 'users' в столбце 'votes' с цифровым значением, во всех
        строках этого столбца декрементировать значение на:

          // На 1
            DB::table('users')->decrement('votes');

          // На 5
            DB::table('users')->decrement('votes', 5);

  > 11.6. Inserts

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для работы с INSERT-утверждениями.

    > Практика

      # Вставить строку значений в таблицу:

          DB::table('users')->insert(
              array('email' => 'john@example.com', 'votes' => 0)
          );

      # Вставить несколько строк в таблицу:

          DB::table('users')->insert(array(
              array('email' => 'taylor@example.com', 'votes' => 0),
              array('email' => 'dayle@example.com', 'votes' => 0),
          ));

      # Вставить строку значений в таблицу с автоинкрементом, и получить
        id новой вставленной строки:

          $id = DB::table('users')->insertGetId(
              array('email' => 'john@example.com', 'votes' => 0)
          );

      #


  > 11.7. Updates

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для работы с UPDATE-утверждениями.

    > Практика
      - В таблице 'users' в строке с 'id' изменить значение поля 'votes'
        на 1:

          DB::table('users')
                      ->where('id', 1)
                      ->update(array('votes' => 1));



  > 11.8. Deletes

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для работы с DELETE-утверждениями.

    > Практика

      - Из таблицы 'users' удалить все строки, в которых в столбце
        'votes' значение < 100:

          DB::table('users')->where('votes', '<', 100)->delete();

      - Удалить все строки из таблицы:

          DB::table('users')->delete();

      - Удалить все строки из таблицы:

          DB::table('users')->truncate();


  > 11.9. Unions

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB, который позволяет "объединять" два
        запроса в один (не путать с UNION из SQL)

    > Практика
      - Создать запрос и сохранить его в $first:
          $first = DB::table('users')->whereNull('first_name');

      - Объединить запрос $first и ещё один запрос:
          $users = DB::table('users')->whereNull('last_name')->union($first)->get();


  > 11.10.  Pessimistic Locking

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для организации pessimistic locking.
        - Optimistic Locking - запись в БД не блокируется, пока твой запрос
          проводит с ней операции. Но если она в течение этого времени
          изменилась, то и все проведённые операции отменяются (ролбэк).
        - Pessimistic Locking - запись в БД блокируется для других запросов,
          пока твой запрос проводит с ней операции.
        - Про optimistic/pessimistic locking можно прочитать здесь:
            http://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking

    > Практика

      - Запустить операцию SELECT с "shared lock", то есть указанная
        таблица будет заблокирована на запись во время операции:

          DB::table('users')->where('votes', '>', 100)->sharedLock()->get();

      - Запустить операцию SELECT с "lock for update":

          DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();


  > 11.11.  Кэширование результатов запросов

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Описан функционал QB для кэширования результатов SQL-запросов.
      - Можно кэшировать результаты запросов, исопльзуя метод remember.
      - Пока результаты в кэше, если выполнить такой запрос, то обращения
        к БД происходить не будет, а результат будет браться из кэша.

    > Практика
      - Закэшировать результат этого запроса на 10 минут:

          $users = DB::table('users')->remember(10)->get();


12. Eloquent ORM

  --------------------------------------
  Подоглавление:

    - Что такое ORM
    - Введение в Eloquent ORM
    - Декомпозиция описания Eloquent ORM

  --------------------------------------

  > Что такое ORM

    > Проблема
      - Объектно-ориентированная программа использует в работе объекты.
      - Для сохранения состояния приложения эти объекты надо хранить в БД.
      - Структура БД для каждого объекта своя.
      - При сохранении приложения каждый раз приходится конвертировать объекты
        в формат, требуемый БД, и сохранять их.
      - При загрузке приложения каждый раз приходится извлекать данные из
        БД и формировать из них объекты.
      - Делать каждый раз всё это напряжно.

    > Решение
      - Использовать технологию ORM.
      - ORM позволяет автоматизировать вышеописанные задачи.
      - Это позволяет вообще абстрагироваться от способа хранения объектов в БД.
      - ORM - Object-Relational Mapping - Объектно-Реляционное Проекцирование.
      - ORM фактически создаёт двустороннюю проекцию между ООП-моделью и БД,
        отсюда и название: объектно-реляционное проецирование.
      - Двусторонняя проекция означает - изменения в ООП-модели приводит к
        автоматич. изменениям в БД в соотв. с системой связей. И наоборот.
      - При работе с ООП-моделью изменения в БД ORM вносит автоматом.
      - По сути своей ORM является реализацией шаблона проектирования
        приложений ActiveRecord.

    > Об ActiveRecord (AR)

      > Введение
        - Это шаблон проектирования приложений.
        - Был описан Мартином Фаулером в книге "Patterns of Enterprise Application Architecture".
        - Является самым популярным способом доступа к данным реляционных баз данных
          в объектно-ориентированном программировании.

      > Общие принципы работы
        - Пусть существует таблица в БД.
        - Для данной таблицы создаётся специальный AR-класс.
        - Таблица и AR-класс являются двусторонней проекцией.
        - Каждый объект-экземпляр AR-класса представляет одну строку таблицы.
        - При создании нового экземпляра в таблицу добавляется новая строка.
        - При чтении полей объекта считываются соотв.связям значения из строки БД.
        - При изменении/удалении экземпляра, изменяется/удаляется соотв.связям строка в БД.

  > Введение в Eloquent ORM
    - Eloquent ORM поставляется в комплекте с Laravel.
    - Eloquent в переводе на русский язык означает "Красноречивый".
    - Представляет собой простую реализацию шаблона пректирования ActiveRecord.
    - Как и описано выше, Eloquent ORM - это ресурс для организации двусторонней
      проекции между таблицей в БД и ООП-моделью в приложении.
    - Перед началом работы с Eloquent ORM следует убедиться, что соединение
      с БД настроено и работает, сделать этом можно в файле "app/config/database.php".

  > Декомпозиция описания Eloquent ORM

    12. Eloquent ORM
      12.1. Основы использования
        - Здесь описаны основы использования Eloquent ORM

      12.2. Установка ограничений на 'mass assignment' при создании экземпляра
        - При создании экземпляра модели конструктору передаётся массив параметров.
        - Из этих параметров конструктор собирает экземпляр и возвращает его.
        - Допустим, массив параметров формируется из полей формы пользователем.
        - Здесь скрыта серьёзная проблема безопасности приложения.
        - Хакер может вручную послать POST-запрос с массивом, который содержит
          даже те параметры, которых не было в форме. Например: isAdmin == true.
        - Чтобы обезопаситься, на сервере нужно иметь 2 списка - белый/чёрный -
          параметров, значения которых разрешено/запрещено принимать от пользователя.

      12.3. Операции: Insert/Update/Delete
        - Здесь описано, каким образом с помощью Eloquent ORM совершать
          операции вставки, изменения и удаления значений в БД и модели.

      12.4. Операция Soft Delete
        - Отличается от обычного delete тем, что строка не удаляется из БД.
        - Вместо этого ей в столбец 'deleted_at' добавляется timestamp.

      12.5. Timestamps
        - По умолчанию в классе-модели неявно $timestamps == true
        - Это значит, что Eloquent автоматически создаёт и обслуживает в таблице
          колонки 'created_at' и 'updated_at.
        - В колонке 'created_at' Eloquent помещает timestamp создания строки таблицы.
        - В колонке 'updated_at' Eloquent помещает timestamp последнего изменения строки таблицы.

      12.6. Query Scopes - заготовки запросов в стат.функциях
        - Суть технологии - возможность повторного использования запросов.
        - Некоторые 'Query Builder'-запросы нужно использовать в приложении много раз.
        - Для этого надо сохранить запрос в стат.функции в классе-модели.
        - У имени этой функции должен быть префикс 'scope'. Например: scopePopular()
        - Тогда можно будет обращаться к ней в запросе уже без префикса. Например:
             $users = User::popular()->women()->orderBy('created_at')->get();

      12.7. Relationships - работа со связанными таблицами
        - Между таблицами в БД могут предполагаться определённы связи.
        - В терминах SQL эти связи называют "внешние ключи", или "foreign keys".
        - В Eloquent есть 4 поддерживаемых типа связей: 1:1, 1:m, n:m, 1:n:m
        - Eloquent позволяет определять эти связи в классах-моделях.
        - Как следствие, через класс-модель можно делать запросы к её связям.

      12.8. Запросы с использованием связей
        - Допустим, модель Post связана с моделью s.
        - Нам надо извлечь все экземпляры Post, у которых > 10 комментариев.
        - А для этого нам надо задействовать данные из связи с s...

      12.9. Упраждающая загрузка (Eager Loading)
        - Позволяет радикально сократить кол-во запросов в некоторых случаях
          и улучшить производительность.

      12.10. Вставка в связанные модели
        - Часто в модели со связями понадобится вставлять новые экземпляры.
        - При этом всплывают различные мелкие трудности.
        - Но в Laravel предусмотрен спец.функционал, чтобы их избежать.

      12.11. Обновление timestamp модели-родителя
        - Допустим модель s связана с моделью Post belongTo связью.
        - Т.Е. s - это дочерняя с т.з. связей модель для Post.
        - Допустим, мы вставили новый экземпляр в s.
        - При этом, неплохо бы обновить столбец 'updated_at' владеющего этим
          комментом экземпляра Post.
        - И вот в этом пункте как раз описан функционал Eloquent для этого.

      12.12. Работа с bridge-таблицами
        - Для организации соединения m:n требуется 3-я bridge-таблица.
        - У Eloquent есть доп.функционал по работе с этой таблицей.

      12.13. Коллекции результатов запросов
        - Результатом запроса в Eloquent может быть 1 или много объектов-экземпляров.
        - Если 1, то возвращается ссылка на него.
        - Если много, то возвращается ссылка на коллекцию объектов.
        - Коллекция реализует интерфейс IteratorAggregate, и ведёт себя как массив.
        - Eloquent предоставляет ряд доп.методов для работы с этой коллекцией.
        - В этом пункте как раз и будет идти речь об этих методах.

      12.14. Ассессоры и мутаторы в Eloquent
        - Ассессор и мутатор определяются в классе модели.
        - Ассессор - метод, который автоматически применяется к результату,
          прежде чем он будет возвращён тебе.
        - Мутатор - метод, который автоматически применяется к результату
          непосредственно перед сохранением в БД.
        - В Eloquent ассессоры и мутаторы можно настроить так, чтобы эффект
          применялся только к значению в указанных столбцах экземпляра.

      12.15. Мутаторы дат
        - По умолчанию Eloquent приводит значения в колонках 'created_at',
          'updated_at' и 'deleted_at' к экземплярам класса Carbon.
        - Carbon: расширяет стандартный PHP-класс DateTime, предоставляя
          набор дополнительных методов для работы с датой и временем.
        - Ссылка на Carbon: https://github.com/briannesbitt/Carbon
        - Это поведение можно изменить.

      12.16. События модели
        - Модели в Eloquent могут генерировать ряд событий.
        - Этим событиям можно назначать функции-обработчики.
        - Это позволяет "вклинивать" доп.код на различных этапах процесса.

      12.17. Класс-наблюдатель за моделью
        - Это такое место, где для удобства можно собрать функции-обработчики
          событий модели, опианных в 12.16.

      12.18. Конвертация в массивы / JSON
        - Часто в разработке приходится использовать формат JSON.
        - Понадобится делать двустороннюю конвертацию коллекция <-> JSON.
        - Для этого в Eloquent предусмотрен специальный функционал.





  > 12.1. Основы использования

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Здесь описаны основы использования Eloquent ORM
      - Каждая модель в Laravel представлена отдельный .php файлом.
      - Файл-модель содержит 1 класс, наследующий от класса Eloquent.
      - В Laravel модели по умолчанию хранятся в папке 'app/models'.
      - Это можно изменить, поправив параметры автозагрузки composer.
      - !Все методы из Query Builder работают и с моделями Eloquent.

    > Практика

      # Определение модели
        - В примере ниже приведено базовое определение модели.
        - По умолчанию неявно используется default-подключение к БД.
        - По умолчанию в качестве имени таблицы неявно используется
          имя класса-модели во множественном числе в нижнем регистре.
            Например, если имя класса-модели 'User', то Eloquent ищет
            таблицу 'users'.

          class User extends Eloquent {}

      # $connection - явно указать имя соединения, которое будет использовано
        - Неявно Eloquent использует соединение, имя которого указано в
          параметре 'default' в файле 'app/config/database.php'.
        - Если требуется указать другое соединение, то внутри класса-модели
          надо явно определить св-во $connection, в котором указать имя соединения,
          одно из тех, которые присутствуют в массиве 'connections' в файле 'database.php'.

            class User extends Eloquent {

              protected $connection = 'anotherConnection';

            }

      # $table - явно указать имя таблицы
        - По умолчанию в качестве имени таблицы неявно используется
          имя класса-модели во множественном числе в нижнем регистре.
        - Чтобы явно указать имя таблицы, надо внутри класса-модели явно
          определить св-во $table, и поместить в него имя таблицы:

            class User extends Eloquent {

              protected $table = 'my_users';

            }

      # $primaryKey - явно указать имя столбца с первичным ключём
        - Неявно Eloquent всегда подразумевает, что в таблице есть столбец
          с именем 'id', и он обладает первичным ключём.
        - Если такое поведение не устраивает, можно явно указать имя столбца
          с первичным ключём. Для этого внутри класса-модели надо явно
          определить св-во $primaryKey, и поместить в него имя столбца:

            class User extends Eloquent {

              protected $primaryKey = 'user_id';

            }

      # $timestamps - нужны ли столбцы updated_at/created_at в таблице, или нет?
        - По умолчанию неявно $timestamps == true. Это значит, что Eloquent ожидает,
          что в таблице будут столбцы с именами 'updated_at' и 'created_at'.
        - Если такие столбцы в таблице не нужны, то внутри класса-модели
          надо явно определить св-во $timestamps со значением false:

            class User extends Eloquent {

              protected $timestamps = false;

            }

      # $incrementing - вкл/выкл автоинкремент для primary key
        - В Eloquent по умолчанию неявно столбец с именем 'id', или
          если $primaryKey присутствует, то с именем, указанным в его
          значении, обладает автоинкрементом.
        - Чтобы выключить автоинкремент у этого столбца, надо внутри
          класса-модели явно определить св-во $incrementing со значением false.

            class User extends Eloquent {

              protected $incrementing = false;

            }

      # $softDelete - вкл/выкл возможность использовать 'soft delete' в модели
        - Soft delete отличается от обычного delete тем, что строка не
          удаляется из таблицы БД.
        - Вместо этого ей в столбец 'deleted_at' добавляется timestamp.
        - По умолчанию soft delete у модели выключен.

        [устаревший вариант, работает в laravel 4.0, 4.1]
        - Чтобы его включить, надо внутри класса-модели явно определить св-во
          $softDelete со значением true:

            class User extends Eloquent {

              protected $softDelete = true;

            }

        [новый вариант, с laravel 4.2]

          use Illuminate\Database\Eloquent\SoftDeletingTrait;
          class User extends Eloquent {

            use SoftDeletingTrait;
            protected $dates = ['deleted_at'];

          }

      # [модель]::all() - получить все объекты-экземпляры модели
        - Как известно, класс-модель и таблица в БД являются двусторонней проекцией.
        - Каждый объект-экземпляр AR-класса представляет одну строку таблицы.
        - Получить все объекты-экземпляры модели можно так:

            $users = User::all();

      # [модель]::find(n) - получить объект-экземпляр по первичному ключу
        - Допустим, надо получить объект-экземпляр по первичному ключу.
        - И нам известно значение n первичного ключа в строке таблицы, данные
          из которой мы хотим извлечь в виде объекта-экземпляра.
        - Тогда это можно сделать так:

            $user = User::find(1);

      # [модель]::findOrFail(n) - аналог find, но в случае неудачи возбуждает исключение
        - Это тоже самое, что вышописанный метод find(n).
        - Но этот, если искомой строки в таблице не найдено, возбуждает исключение.
        - Это исключения типа 'ModelNotFoundException'.
        - Чтобы их отлавливать, надо для приложения зарегистрировать с помощью error()
          функци-обработчик, которая будет отлавливать именно такой тип исключений.

            // Примеры использования findOrFail(n)
              $model = User::findOrFail(1);
              $model = User::where('votes', '>', 100)->firstOrFail();

            // Регистрация функции-обработчика
              use Illuminate\Database\Eloquent\ModelNotFoundException;
              App::error(function(ModelNotFoundException $e)
              {
                  return Response::make('Not Found', 404);
              });

      # Пример использования Query Builder с Eloquent-моделью:

        - Найти строки, у которых в столбце 'votes' значение > 100,
          извлечь первые 10 из найденных, и вернуть их в виде массива
          экземпляров модели:

            $users = User::where('votes', '>', 100)->take(10)->get();

        - Пробежаться по всем извлечённым объектам:

            foreach ($users as $user)
            {
                var_dump($user->name);
            }

      # Пример использования агрегирующих ф-ий из Query Builder с Eloquent-моделью:

        - Получить количество строк в таблице, в которых в столбце 'value'
          значение > 100:

            $count = User::where('votes', '>', 100)->count();

        - Получить массив объектов-экземпляров модели, в которых в столбце
          'age' значение > 25, а в столбце 'votes' значение = 100:

            $users = User::whereRaw('age > ? and votes = 100', array(25))->get();

      # Извлечение результата по кускам - траншами
        - Бывает, что нужно извлечь много (тысячи) записей из таблицы.
        - И как следствие, обработать столько же объектов-экземпляров модели.
        - А ведь такая операция может сожрать всю оперативную память сервера.
        - Поэтому в Eloquent можно разбивать подобные операции на транши.
        - Можно указать кол-во извлекаемых в каждом транше записей.
        - Обработка транша производится в анонимной функции. Она вызывается
          сразу после того, как извлечение всех записей в транше завершено.
        - В примере ниже данные извлекаются траншами по 200 штук:

            User::chunk(200, function($users)
            {
                foreach ($users as $user)
                {
                    //
                }
            });

      # Явное указание соединения для проведения запроса
        - По умолчанию при проведении запроса используется соединение,
          указанное в определении класса-модели в папке 'app/models'
          в св-ве $connection.
        - Либо, если $connection опущено, используется соединение по умолчанию,
          указанное в параметре 'default' в файле 'app/config/database.php'.
        - А что, если нам хочется указать, какое соединение использовать,
          прямо во время проведения запроса? Это можно сделать так:

            $user = User::on('connection-name')->find(1);


  > 12.2. Установка ограничений на 'mass assignment' при создании экземпляра

    --------------------------------------
    Подоглавление:

      - Введение
      - Наглядный абстрактный пример, иллюстрирующий уязвимость 'mass assignment'
      - Защита от уязвимости, связанной с 'mass assignment', в Eloquent ORM
      - Практика

    --------------------------------------

    > Введение
      - При создании экземпляра модели конструктору передаётся массив параметров.
      - Из этих параметров конструктор собирает экземпляр и возвращает его.
      - Допустим, массив параметров формируется из полей формы пользователем.
      - Здесь скрыта серьёзная проблема безопасности приложения.
      - Хакер может вручную послать POST-запрос с массивом, который содержит
        даже те параметры, которых не было в форме. Например: isAdmin == true.
      - Чтобы обезопаситься, на сервере нужно иметь 2 списка - белый/чёрный -
        параметров, значения которых разрешено/запрещено принимать от пользователя.

    > Наглядный абстрактный пример, иллюстрирующий уязвимость 'mass assignment'
      - Ещё один пример можно увидеть в этой статье:
          http://websec.io/2013/02/04/Beware-the-Mass-Assignment.html
      - Допустим, у нас есть модель из 3-х параметров: 'login', 'password',
        'admin'.
      - И у нас есть документ, в котором новый пользователь может
        зарегистрироваться. Он может указать в форме значения только для
        'login' и 'password'. А поля для указания значения для 'admin' нет.
      - Класс модели выглядит так:

          class Model {

            // Св-ва модели и их значения по умолчанию
            private $login = null;
            private $password = null;
            private $admin = false;

            /**
             * Конструктор класса.
             * Создаёт новый объект-экземпляр и заселяет модель значениями,
             * переданными ему в массиве. Такой способ заселения называется
             * 'mass assignment'.
             *
            */
            public function __constructor($array) {

              foreach($array as $name => $value) {
                if( property_exists(get_class($this), $name)) {
                  $this->$name = $value;
                }
              }
            }
          }

      - Теперь допустим, что я хакер. И я хочу зарегистрировать учётную
        запись с правами администратора. Да, в форме нет поля для того,
        чтобы указать 'admin' = true. Но ведь я запросто могу отправить
        на сервер POST-запрос "как будто от формы". И в теле этого запроса
        передать массив, который будет содержать 'admin' = true. Если
        никакой проверки содержимого $array нет, как в приведённом выше
        классе Model, то это сработает.
      - Как защититься? Ответ прост: надо иметь на сервере для модели
        2 списка - белый/чёрный - которые явно содержат имена св-в модели,
        которые могут/не могут быть назначены через 'mass assignment'.

    > Защита от уязвимости, связанной с 'mass assignment', в Eloquent ORM
      - При создании нового экземпляра модели её конструктору передаётся
        массив атрибутов.
      - Св-ва модели заселяются значениями атрибутов из этого массива
        методом 'mass assignment'.
      - В Eloquent предусмотрены 2 списка - белый (fillable) и чёрный
        (guarded). В этих списках можно явно указать имена св-в модели,
        которые могут/не могут быть заселены методом 'mass assignment'.
      - В Eloquent по умолчанию все св-ва находятся в guarded-списке.
      - Поэтому разработчик должен явно указать в fillable-списк те
        свойства модели, которые он собирается заселять методом 'mass assignment'.

    > Практика

      # $fillable - белый список
        - Для определения белого списка, требуется в классе-модели определить
          св-во $fillable, и присвоить ему массив строк, каждая из которых
          обозначает имя св-ва модели, которое может быть инициировано
          методом 'mass assignment'.
        - Если $fillable и $guarded опущены, то т.к. в Eloquent все св-ва
          модели неявно находятся в guarded-списке, ни одно св-во модели не
          доступно для 'mass assignment'.
        - Если $fillable присутствует, а $guarded опущено, то для 'mass assignment'
          доступны только свойства, указанные в $fillable. А все остальные - не доступны.
        - Пример определения $fillable. В этой модели св-ва 'first_name', 'last_name', 'email'
          будут доступны для 'mass assignment', а все остальные - не доступны.

            class User extends Eloquent {

                protected $fillable = array('first_name', 'last_name', 'email');

            }

      # $guarded - чёрный список
        - В Eloquent все св-ва модели неявно находятся в guarded-списке.
        - Для явного определения чёрного списка, требуется в классе-модели
          определить св-во $guraded, и присвоить ему массив строк, каждая из которых
          обозначает имя св-ва модели, которое НЕ может быть инициировано
          методом 'mass assignment'.
        - Если $fillable и $guarded опущены, то т.к. в Eloquent все св-ва
          модели неявно находятся в guarded-списке, ни одно св-во модели не
          доступно для 'mass assignment'.
        - Если $guarded присутствует, а $fullable опущен, то для 'mass assignment'
          не доступны только свойства, указанные в $guarded. А все остальные
          доступны.
        - Пример определения $guarded. В этой модели св-ва 'id' и 'password'
          будут не доступны для 'mass assignment', а все остальные св-ва
          модели будут доступны:

            class User extends Eloquent {

                protected $guarded = array('id', 'password');

            }

      # Заблокировать все св-ва модели от 'mass assignment':
        - Особой нужны в этом выражении нет, поскольку они и так по умолчанию
          заблокированы.

            protected $guarded = array('*');


  > 12.3. Операции: Insert/Update/Delete

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Здесь описано, каким образом с помощью Eloquent ORM совершать
        операции вставки, изменения и удаления значений в БД и модели.
      - Операция UPDATE в laravel работает очень медленно (~0.x секунд).
      - Операция INSERT в laravel работает гораздо быстрее UPDATE.

    > Практика

      # save() - сохранение экземпляра модели в таблице БД

        - Сохраниние экземпляра в БД производится методом save():

            // Создать новый объект-экземпляр модели User
              $user = new User;

            // Инициализировать св-во 'name' в созданном объекте:
              $user->name = 'John';

            // Сохранить созданный экземпляр в таблице БД:
              $user->save();

      # push() - сохранение экземпляра модели и его связей в БД
        - Это практически тоже самое, что save(), но с одним отличием.
        - В отличие от save(), этот метод в том числе сохраняет и все
          связи экземпляра-модели в БД.

            $user->push();

      # create() - создание и сохранение нового экземпляра одной строкой
        - Вот здесь как раз используется 'mass assignment'.
        - Конструктору класса-модели передаётся массив значений.
        - И он используется для инициализации св-ва экземпляра методом 'mass assignment'.
        - Но как известно, по умолчанию все св-ва находятся в guarded-списке.
        - Поэтому, чтобы их можно было инициализировать методом 'mass assignment'
          в функции create, надо сначала добавить их в fillable-список, как
          описано выше.

            //  Создать новый экземпляр модели и добавить его в БД как
                строку таблицы.

                  $user = User::create(array('name' => 'John'));

            //  Найти в таблице БД все строки, в которых в столбце 'name'
                значение 'John'. Из них выбрать первую, превратить её в
                экземпляр модели и вернуть. А если ничего не найдено, то
                создать новый экземпляр модели и добавить его в БД как строку
                таблицы:

                  $user = User::firstOrCreate(array('name' => 'John'));

            //  Найти в таблице БД все строки, в которых в столбце 'name'
                значение 'John'. Из них выбрать первую, превратить её в
                экземпляр модели и вернуть. А если ничего не найдено, то
                создать новый экземпляр модели и вернуть его:

                  $user = User::firstOrNew(array('name' => 'John'));

      # id  - после выполнения save() или create() получить ID
        - По умолчанию в Eloquent имя столбца с первичным ключём: 'id'.
        - Или оно может быть явно указано в св-ве $primaryKey класса-модели.
        - По умолчанию этот столбец обладает автоинкрементом (99% случаев).
        - Или он может быть отключён в св-ве $incrementing класса модели
        - Если автоинкремент был включён, то было бы неплохо узнать значение
          id для последней добавленной (save/create) в БД строки.
        - Сделать это можно вот так:

            $insertedId = $user->id;

      # Изменение данных в БД через модель
        - Принцип простой: извлечь, изменить, запихнуть обратно.
        - Сначала находим в таблице БД нужную строку, извлекаем её
          в виде экземпляра модели.
        - Изменяем этот экземпляр как хотим.
        - Сохраняем его обратно в БД с помощью save().

            // Получить экземпляр модели, представляющий нужную строку таблицы БД
              $user = User::find(1);

            // Внести нужные изменения
              $user->email = 'john@foo.com';

            // Сохранить этот экземпляр обратно в БД
              $user->save();

      # Изменение сразу нескольких строк с помощью функции update из 'query builder'
        - Найти в таблице все строки, у которых в столбце 'votes' значение
          > 100. И изменить в них в столбце 'status' значение на 2:

            $affectedRows = User::where('votes', '>', 100)->update(array('status' => 2));

      # Обновить только timestamps модели:

          $user->touch();

      # delete()  - удалить экземпляр модели из таблицы БД

        //  Получить экземпляр, представляющий строку таблицы, которую
            требуется удалить
          $user = User::find(1);

        //  Используя полученную ссылку удалить эту строку:
          $user->delete();

      # destroy()   - удалить >= 1 экземпляра модели из БД по id
        - Если известен id той строки, которую требуется удалить из таблицы БД,
          то удобнее пользоваться destroy(), чем delete().
        - Кроме того с помощь destroy() можно удалить несколько строк за раз.

        // Удалить из таблицы строку с id == 1
          User::destroy(1);

        // Удалить из таблицы строку с id == 1, 2, 3 (вариант 1)
          User::destroy(array(1, 2, 3));

        // Удалить из таблицы строку с id == 1, 2, 3 (вариант 2)
          User::destroy(1, 2, 3);

      # Удаление сразу нескольких строк с помощью функции delete из 'query builder'
        - Найти в таблице все строки, у которых в столбце 'votes' значение
          > 100. И удалить их.

            $affectedRows = User::where('votes', '>', 100)->delete();

  > 12.4. Операция Soft Delete

    --------------------------------------
    Подоглавление:

      - Введение
      - Вкл/выкл функционал 'soft delete'
      - Практика

    --------------------------------------

    > Введение
      - Soft delete отличается от обычного delete тем, что строка не
        удаляется из таблицы БД.
      - Вместо этого ей в столбец 'deleted_at' добавляется timestamp.
      - Если у модели включён 'soft delete', то метод delete() не будет
        больше как раньше удалять соотв.строки из таблицы, а будет
        добавлять timestamp в столбец 'deleted_at'.
      - При запросе у модели экземпляров, 'soft deleted' экземпляры в
        результат попадать не будут.
      - А чтобы они всё-таки попадали в результат, нужно использовать
        метод withTrashed()

    > Вкл/выкл функционал 'soft delete'
      - По умолчанию функционал 'soft delete' неявно выпключен.
      - Чтобы его включить, надо внутри класса-модели явно определить св-во
        $softDelete со значением true, как описано в 12.1.

    > Практика

      # Включить функционал 'soft delete' в определении класса-модели:

          class User extends Eloquent {

              protected $softDelete = true;

          }

      # softDeletes() - добавить колонку с заголовком 'deleted_at' в таблицу:

          $table->softDeletes();

      # withTrashed() - включить в результат и 'soft deleted' записи
        - Если понадобилось включить в результат и 'soft deleted' записи,
          то тогда можно использовать этот метод.
        - Получить массив экземпляров, представляющих те строки в таблице БД,
          в которых в столбце 'account_id' значение == 1. Причём извлекать
          даже те, которые помечены как 'deleted' в столбце 'deleted_at':

            $users = User::withTrashed()->where('account_id', 1)->get();

      # onlyTrashed() - получить в результат ТОЛЬКО 'soft deleted' записи
        - Получить массив экземпляров, представляющих те строки в таблице БД,
          в которых в столбце 'account_id' значение == 1. Причём извлекать
          только те, которые помечены как 'deleted' в столбце 'deleted_at':

            $users = User::onlyTrashed()->where('account_id', 1)->get();

      # restore() - вернуть 'soft deleted' запись в нормальное состояние
        - То есть убрать у неё из столбца 'deleted_at' запись об удалении.

          // Пример 1
            $user->restore();

          // Пример 2
            User::withTrashed()->where('account_id', 1)->restore();

          // Пример 3 (использование restore() на связях):
            $user->posts()->restore();

      # forceDelete() - на самом деле удалить запись из таблицы
        - Допустим, у модели включён функционал 'soft delete'.
        - И тогда функция delete() на самом деле не удаляет запись из
          таблицы, а просто делает пометку в столбце 'deleted_at'.
        - Как же тогда в таких обстоятельствах удалить строку из таблицы
          "по настоящему"? Для этого как раз есть метод forceDelete()

            $user->forceDelete();

        - Этот метод работает также и со связями:

            $user->posts()->forceDelete();

      # trashed() - является ли экземпляр 'мягко удалённым', или нет?
        - Иногда нужно проверить, является ли экземпляр модели мягко-
          удалённым (soft deleted).
        - Конечно, можно было бы запросить значение из его столбца 'deleted_at',
          и проверить его. Но разработчики Laravel упростили этот провцесс.
        - Проверку можно осуществить с помощью метода trashed():

            // Если этот экземеляр является 'мягко удалённым', то:
              if($user->trashed())
              {
                  //
              }

            // Если этот экземеляр НЕ является 'мягко удалённым', то:
              if(!$user->trashed())
              {
                  //
              }

  > 12.5. Timestamps

    --------------------------------------
    Подоглавление:

      - Введение
      - Вкл/выкл функционал ведения колонок с timestamp'ами
      - Как изменить формат timestamp?

    --------------------------------------

    > Введение
      - По умолчанию в классе-модели неявно $timestamps == true
      - Это значит, что Eloquent автоматически создаёт и обслуживает в таблице
        колонки 'created_at' и 'updated_at.
      - В колонке 'created_at' Eloquent помещает timestamp создания строки таблицы.
      - В колонке 'updated_at' Eloquent помещает timestamp последнего изменения строки таблицы.
      - Если функционал включён, Eloquent добавляет значения в эти столбцы автоматом.
      - Если таких колонок в таблице нет, то надо их добавить вручную.

    > Вкл/выкл функционал ведения колонок с timestamp'ами
      - По умолчанию функционал ведения колонок с timestamp включён,
        т.е. в классе-модели $timestamps == true.
      - Чтобы отключить этот функционал, нужно сделать $timestamps == false.
      - Пример:

            class User extends Eloquent {

              protected $timestamps = false;

            }

    > Как изменить формат timestamp?
      - С помощью функции getDateFormat()
      - Пример:

          public function getDateFormat() {

            return 'Y-m-d H:i:s';

          }

  > 12.6. Query Scopes - заготовки запросов в стат.функциях

    --------------------------------------
    Подоглавление:

      - Введение
      - Наглядный пример использования

    --------------------------------------

    > Введение
      - Суть технологии - возможность повторного использования запросов.
      - Некоторые 'Query Builder'-запросы нужно использовать в приложении много раз.
      - Для этого надо сохранить запрос в стат.функции в классе-модели.
      - У имени этой функции должен быть префикс 'scope'. Например: scopePopular()
      - Тогда можно будет обращаться к ней в запросе уже без префикса. Например:
           $users = User::popular()->women()->orderBy('created_at')->get();

    > Налгядный пример использования

      # Определение Query Scope
        - Определение производится в классе-модели, в виде функции.
        - У имени этой функции должен быть префикс 'scope'.

          class User extends Eloquent {

            // Без параметров
              public function scopePopular($query)
              {
                return $query->where('votes', '>', 100);
              }

            // С параметрами
              public function scopeAge($query, $param1)
              {
                return $query->where($param1, '>', 100);
              }

          }

      # Использование определённого ранее Query Scope
        - Имя определённого выше query scope при использовании пишут
          без префикса и маленькими буквами.

          // Использование query scope без параметра
            $users = User::popular()->women()->orderBy('created_at')->get();

          // Использование query scope с параметром
             - В этом примере передаётся 1 параметр для $param1
            $users = User::age('Значение')->get();




  > 12.7. Relationships - работа со связанными таблицами

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция описания Relationships

    --------------------------------------

    > Введение
      - Между таблицами в БД могут предполагаться определённы связи.
      - В терминах SQL эти связи называют "внешние ключи", или "foreign keys".
      - В Eloquent есть 4 поддерживаемых типа связей: 1:1, 1:m, n:m, 1:n:m
      - Eloquent позволяет определять эти связи в классах-моделях.
      - Как следствие, через класс-модель можно делать запросы к её связям.

    > Декомпозиция описания Relationships

      12.7. Relationships
        12.7.1. Связь типа 1:1
          - 1 экземпляр модели X связан только с 1 экземпляром модели Y, и наоборот.
          - Под экземплярами, как описано выше, подразумеваются строки в таблицах.

        12.7.2. Связь типа 1:m
          - 1 экземпляр модели X связан с m экземплярами модели Y.
          - m экземпляров модели Y связаны с 1-им экземпляром модели X.

        12.7.3. Связь типа n:m
          - n экземпляров модели X связаны с m экземплярами модели Y.
          - Для организации связи типа m:n требуется 3-я промежуточная
            bridge-таблица.

        12.7.4. Связь типа 1:n через промежуточную модель
          - Позволяет организовать связь типа 1:n через промежуточную модель.

        12.7.5. Полиморфные связи
                [!!!Требует доработки!!!]
          - Позволяет связать одну модель с другими как одноранговую сеть.

        12.7.6. Полиморфные связи типа n:m
                [!!!Требует доработки!!!]
          -
          -

    > 12.7.1. Связь типа 1:1

      --------------------------------------
      Подоглавление:

        - Введение
        - Определение связи: прямое и обратное
        - Определимся с терминологией
        - Как Eloquent определяет имена связываемых колонок?
        - Практика

      --------------------------------------

      > Введение
        - 1 экземпляр модели X связан только с 1 экземпляром модели Y, и наоборот.
        - Под экземплярами, как описано выше, подразумеваются строки в таблицах.
        - Например: у одного пользователя может быть только 1 телефон.
        - Прямая связь 1:1 определяется функцией hasOne().
        - Обратная связь 1:1 определяется функцией belongsTo().

      > Определение связи: прямое и обратное
        - Допустим в классе-модели X определена "прямая" связь с Y.
        - Тогда через X можно сделать запрос и получить экземпляр Y.
        - Но вот через Y сделать запрос и получить экземпляр X пока нельзя.
        - А чтобы было можно, надо определить "обратную" связь в классе-модели Y.
        - Тогда через Y можно будет сделать запрос и получить экземпляр X.

      > Определимся с терминологией
        - X-модель: в которой определена "прямая" связь с Y-моделью.
        - Y-модель: с которой связана X-модель, в ней также может быть
                    определена "обратная" связь с X-моделью.

      > Как Eloquent определяет имена связываемых колонок?
        - Неявно Eloquent использует имя 'id' для X-модели.
        - Неявно Eloquent использует '[имя Y-модели]_id' для Y-модели.
        - Явно задать эти имена можно при определении как "прямой", так
          и "обратной" связей. См.примеры ниже.

      > Практика
        - Допустим, 1 экземпляр (строка в таблице) модели User может иметь
          только 1 связанный с ним экземпляр (строку в таблице) модели Phone.
        - В данном случае User - это X-модель, а Phone - это Y-модель.

        # "Прямое" определение связи 1:1 в X-модели

          //  Имена связанных колонок оставляем "по умолчанию". В данном случае
          //  колонка 'id' в User будет связана с колонкой 'user_id' в Phone:

              class User extends Eloquent {
                  public function phone()
                  {
                      return $this->hasOne('Phone');
                  }
              }

          //  Зададим вместо 'user_id' другое имя для связанной колонки Y-модели,
          //  а именно 'man_id'.

               class User extends Eloquent {
                  public function phone()
                  {
                      return $this->hasOne('Phone', 'man_id');
                  }
               }

          //  Зададим вместо 'id' и 'user_id' другие имена для связанных колонок.
          //  'man_id' вместо 'user_id', и 'local_key' вместо 'id'.

               class User extends Eloquent {
                  public function phone()
                  {
                      return $this->hasOne('Phone', 'man_id', 'local_key');
                  }
               }

        # "Обратное" определение связи 1:1 в Y-модели

          //  Имена связанных колонок оставляем "по умолчанию". В данном случае
          //  колонка 'id' в User будет связана с колонкой 'user_id' в Phone:

            class Phone extends Eloquent {
                public function user()
                {
                    return $this->belongsTo('User');
                }
            }

          //  Зададим вместо 'user_id' другое имя для связанной колонки Y-модели,
          //  а именно 'man_id'.

            class Phone extends Eloquent {
                public function user()
                {
                    return $this->belongsTo('User', 'man_id');
                }
            }

          //  Зададим вместо 'id' и 'user_id' другие имена для связанных колонок.
          //  'man_id' вместо 'user_id', и 'some_key' вместо 'id'.

            class Phone extends Eloquent {
                public function user()
                {
                    return $this->belongsTo('User', 'man_id', 'some_key');
                }
            }

        # Использование

          // Использование через X-модель
            - Сначала получить экземпляр модели User со значением 1 из
              столбца 'id' (или, если при определении связи в X-модели имя
              столбца "по умолчанию" было заменено, то из этого столбца).
            - Затем найти связанный с ним экземпляр модели Phone, и вернуть его.
            - Этой операцией мы находим телефон, который принадлежит указанному пользователю.

                $phone = User::find(1)->phone;

          // Использование через Y-модель
            - По сути, тоже самое.
            - Этой операцией мы находим пользователя, которому принадлежит телефон.

                $user = Phone::find(1)->user;

    > 12.7.2. Связь типа 1:m

      --------------------------------------
      Подоглавление:

        - Введение
        - "Обратная" связь актуальна также для и типа 1:m
        - Практика

      --------------------------------------

      > Введение
        - 1 экземпляр модели X связан с m экземплярами модели Y.
        - m экземпляров модели Y связаны с 1-им экземпляром модели X.
        - Например, у 1-го поста может быть много комментариев.
        - *Примечание: базовую инфу по связям см. в 12.7.1.
        - Прямая связь 1:m определяется функцией hasMany().
        - Обратная связь 1:m определяется функцией belongsTo().

      > "Обратная" связь актуальна также и для типа 1:m
        - Например, по комментарию мы можем определить, к какому он
          посту относится.
        - Она определяется той же функцией, что для 1:1.

      > Практика:
        - Допустим, 1 экземпляр (строка в таблице) модели Post может иметь
          m связанных с ним экземпляров (строк в таблице) модели .
        - В данном случае Post - это X-модель, а  - это Y-модель.

        # "Прямое" определение связи 1:m в X-модели
          - Имена связанных колонок оставляем "по умолчанию". В данном случае
            колонка 'id' в Post будет связана с колонкой 'post_id' в Phones:
          - А можно было их переопределить, как описано для 1:1 в 12.7.1.

            class Post extends Eloquent {
                public function s()
                {
                    return $this->hasMany('');
                }
            }

        # "Обратное" определение связи 1:m в Y-модели
          - Имена связанных колонок оставляем "по умолчанию". В данном случае
            колонка 'id' в Post будет связана с колонкой 'post_id' в Phones:
          - А можно было их переопределить, как описано для 1:1 в 12.7.1.

            class  extends Eloquent {
                public function post()
                {
                    return $this->belongsTo('Post');
                }
            }

        # Использование

          // Использование через X-модель
            - Найти все коменты для указанного поста, и получить массив
              из объектов-экземпляров модели 

                $s = Post::find(1)->s;

            - Найти все комменты для указанного поста, заголовок которых
              равен 'foo'. Выбрать из них первый и вернуть:

                $c = Post::find(1)->s()->where('title', '=', 'foo')->first();

          // Использование через Y-модель
            - Найти пост по комменту, получить экземпляр объекта-поста:

                $post = ::find(1)->post;


    > 12.7.3. Связь типа n:m

      --------------------------------------
      Подоглавление:

        - Введение
        - Про bridge-таблицу
        - Настройка имён
        - Практика

      --------------------------------------

      > Введение
        - n экземпляров модели X связаны с m экземплярами модели Y.
        - Обратной связи нет, только прямая.
        - Для организации связи типа m:n требуется 3-я промежуточная
          bridge-таблица.
        - Связь m:n определяется методом belongsToMany().

      > Про bridge-таблицу
        - Допустим, у есть 2 таблицы 'teachers' и 'students' со связью m:n.
        - У одного учителя может быть несколько учеников.
        - У одного ученика может быть несколько учителей.
        - Но где же нам хранить, у какого ученика какие учителя; у какого
          учителя какие ученики? Делать это в этих 2-х таблицах не удобно.
        - Как раз для этой цели мы и создаём 3-ю промежуточную bridge-таблицу.
        - Наглядный пример:

          # bridge-таблица
            - Изначально у нас 2 таблицы: 'teachers' и 'students'.
            - Между ними связь m:n.
            - Разбиваем эту связь на 1 связи типа 1:n методом bridge-таблицы.
            - Вот как в результате выглядит схема:

            | Teachers |                          | Students |
            |----------|                          |----------|
            | id       |------|              |----| id       |
            | name     |      |              |    | name     |
                              |              |
                              | |  Bridge  | |
                              | |----------| |
                              | | teach_id |-|
                              |-| stud_id  |

          # Пример реальной bridge-таблицы:
            - Из этого примера наглядно видно, как используеся bridge-таблица.
            - По ней можно однозначно определить, какой учитель связан с
              какими студентами, и наоборот, какой студент связан с какими учителями.

            teach_id      |      stud_id
            ----------------------------
                1               1
                1               2
                1               3
                2               1
                2               2
                2               3
                2               4
                        ...


      > Настройка имён

        > Как по умолчанию Eloquent определяет имена для bridge-таблицы
          - Eloquent ожидает, что имя bridge-таблицы будет состояить из
            имён связываемых моделей через символ '_'.
            Например: 'teacher_student'.
          - Eloquent ожидает, что в bridge-таблице будет 2 столбца. Имя
            каждого из них состоит из 1-й из частей названия таблицы
            + постфикс '_id'.
            Например, если bridge-таблица называется 'teacher_student',
            то имена столбцов: 'teacher_id', 'student_id'

        > Как по умолчанию Eloquent определяет имена для таблиц связываемых моделей
          - Неявно Eloquent использует имя 'id' для столбца X-модели.
          - Неявно Eloquent использует '[имя Y-модели]_id' для столбца Y-модели.

        > Что из этого можно настроить?
          - Всё.

        > Как производится настройка имён для bridge-таблицы?
          - Путём передачи 1-й строки с именем bridge-таблицы во 2-м аргументе
            методу belongsToMany().
          - Она должна соответствовать шаблону: '[имя 1]_[имя 2]'.
          - Тогда Eloquent автоматом сочтёт, что имена для столбцов:
            '[имя 1]_id' и '[имя 2]_id'.

        > Как производится настройка имён для столбцов связываемых моделей
          - Связываемый столбец в Y-модели задаётся путём передачи 3-го
            аргумента методу belongsToMany() со строкой-именем.
          - Связываемый столбец в X-модели задаётся путём передачи 4-го
            аргумента методу belongsToMany() со строкой-именем.

      > Практика

        # Определить прямую n:m связь (все имена оставляем по умолчанию)
          - Имена связанных столбцов в X-модели и Y-модели, а также имя
            bridge-таблицы оставляем "по умолчанию".

          // Прямая

            class Teacher extends Eloquent {

              public function students() {
                return $this->belongsToMany('Student');
              }

            }

          // Обратная

            class Student extends Eloquent {

              public function teachers() {
                return $this->belongsToMany('Teacher');
              }

            }

        # Определить прямую n:m связь (все имена оставляем по умолчанию)
          - Имена связанных столбцов в X-модели и Y-модели, а также имя
            bridge-таблицы переопределяем

          // Прямая

            class Teacher extends Eloquent {

              public function students() {
                return $this->belongsToMany('Student', 'teacher_student', 'teacher_id', 'student_id');
              }

            }

          // Обратная

            class Student extends Eloquent {

              public function teachers() {
                return $this->belongsToMany('Student', 'teacher_student', 'teacher_id', 'student_id');
              }

            }

        # Использование

          //  Найти всех учеников указанного учителя. Вернуть массив найденных
          //  экземпляров модели Student

            $students = Teacher::find(1)->students;

          //  Найти всех учителей указанного ученика. Вернуть массив найденных
          //  экземпляров модели Teacher

            $teachers = Student::find(1)->teachers;


    > 12.7.4. Связь типа 1:n через промежуточную модель

      --------------------------------------
      Подоглавление:

        - Введение
        - Структура таблиц
        - Практика

      --------------------------------------

      > Введение
        - Позволяет организовать связь типа 1:n через промежуточную модель.
        - Например, 1 экземпляр модели Country может быть связан со многими
          экземплярами модели Posts через модель Users.
        - Т.Е. смысл в том, что нам может понадобиться узнать, сколько постов
          было сделано пользователями указанной страны.
        - В подобных ситуациях и пригодится этот, 4-й тип связи.
        - Определяется методом hasManyThrough().

      > Структура таблиц
        - Какова должна быть структура таблиц для организации подобной связи?
        - Вот пример, какова она может быть:

            countries
                id - integer
                name - string

            users
                id - integer
                country_id - integer
                name - string

            posts
                id - integer
                user_id - integer
                title - string

        - И хотя таблица 'posts' не имеет столбца 'country_id', если в
          countries определить связь типа 1:n через промежуточную таблицу
          users, то через модель countries можно будет получить данные
          из posts.

      > Практика

        # Определить связь 1:n между Country и Post через User

          - Оставить все имена как по умолчанию.

              class Country extends Eloquent {

                  public function posts() {
                      return $this->hasManyThrough('Post', 'User');
                  }

              }

          - Самому определить имена для связанных столбцов:

              class Country extends Eloquent {

                  public function posts() {
                      return $this->hasManyThrough('Post', 'User', 'country_id', 'user_id');
                  }

              }

        # Использование
          - Определить, сколько всего постов, отправленных пользователями
            из указанной страны. Получить массив экземпляров модели Post:

              $posts = Countries::find(1)->posts;


    > 12.7.5. Полиморфные связи

      --------------------------------------
      Подоглавление:

        - Введение
        - Структура таблиц
        - Практика

      --------------------------------------

      > Введение
        - Позволяет связать одну модель с другими как одноранговую сеть.
        - То есть одна модель является целевой связью для нескольких других
          моделей одновременно.

      > Структура таблиц
        - Какова должна быть структура таблиц для организации подобной связи?
        - Вот пример, какова она может быть:

            staff
                id - integer
                name - string

            orders
                id - integer
                price - integer

            photos
                id - integer
                path - string
                imageable_id - integer
                imageable_type - string

      > Практика
        - Например, есть модель Photo. И она принадлежит одновременно моделям
          Staff и Order.

        # Определить связь

            class Photo extends Eloquent {

                public function imageable()
                {
                    return $this->morphTo();
                }

            }

            class Staff extends Eloquent {

                public function photos()
                {
                    return $this->morphMany('Photo', 'imageable');
                }

            }

            class Order extends Eloquent {

                public function photos()
                {
                    return $this->morphMany('Photo', 'imageable');
                }

            }

        # Использование полиморфной связи

            $staff = Staff::find(1);
            foreach ($staff->photos as $photo) {
                //
            }


        .... [пункт требует доработки] ....

            - Пока не понятно зачем это вообще надо и как работает.

  > 12.8. Запросы с использованием связей

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Допустим, модель Post связана с моделью s.
      - Нам надо извлечь все экземпляры Post, у которых > 10 комментариев.
      - А для этого нам надо задействовать данные из связи с s...

    > Практика

      # Получить массив экземпляров модели Post, у каждого из которых есть
        хотя бы один комментарий:

          $posts = Post::has('s')->get();

      # Получить массив экземпляров модели Post, у каждого из которых есть
        > 10 комментариев:

          $posts = Post::has('s', '>=', 3)->get();

      # Получить массив экземпляров модели Post, контент которых начинается
        со слова 'hello':

          $posts = Post::whereHas('s', function($q)
          {
              $q->where('content', 'like', 'hello%');

          })->get();

  > 12.9. Упреждающая загрузка (Eager Loading)

    --------------------------------------
    Подоглавление:

      - Введение
      - Описание проблемы
      - Описание решения проблемы
      - Ещё примеры

    --------------------------------------

    > Введение
      - Позволяет радикально сократить кол-во запросов в некоторых случаях
        и улучшить производительность.

    > Описание проблемы
      - Допустим есть 2 модели 'Book' и 'Author'.
      - 'Book' связана с 'Author' обратной связью:

          class Book extends Eloquent {
              public function author() {
                  return $this->belongsTo('Author');
              }
          }

      - Теперь представим, что надо вывести на экран имя автора
        каждой из книг. Это можно сделать так:

            foreach (Book::all() as $book) {      // 1 запрос
                echo $book->author->name;         // 25 запросов
            }

      - Допустим, книг у нас 25. Тогда код выше выполнит 1 запрос к БД для
        получения массива экземпляров модели Book в кол-ве 25 штук. А затем
        ещё 25 запросов, извлекая для каждой из книг через связь имя автора.
        Значит всего 26 запросов.
      - Проблема: чрезмерная нагрузка на сервер БД и трафик.

    > Описание решения проблемы
      - Можно сократить кол-во запросов с 26 до 2 в примере выше.
      - Суть решения: предзагрузить те связи, которые потребуется использовать
        при обхое извлечённых экземпляров:

          foreach (Book::with('author')->get() as $book) {    // 2 запроса
              echo $book->author->name;                       // 0 запросов
          }

      - Тут произошло всего 2 запроса к БД:

          select * from books
          select * from authors where id in (1, 2, 3, 4, 5, ...)

    > Ещё примеры

      # Упреждающе загрузить сразу несколько связей:

        foreach (Book::with('author', 'publisher')->get() as $book) {
            echo $book->author->name;
        }

      # Упреждающе загрузить вложенную связь

        foreach (Book::with('author.contacts')->get() as $book) {
            echo $book->author->name;
        }

      # Упреждающе загрузить связи, но не все, а соответствующие ограничениям
        - В этом примере, мы хотим упреждающе загрузить посты пользователя,
          но не все, а только в которых есть фраза 'first'.

        $users = User::with(array('posts' => function($query)
        {
            $query->where('title', 'like', '%first%');
        }))->get();

      # Упреждающая загрузка в существующий массив экземпляров
        - Полезно, если решение о упреждающей загрузке надо принимать "на месте".
        - Допустим, мы получили массив экземпляров модели Book:

            $books = Book::all();

        - Как теперь сделать для него упреждающую загрузку связей?
          Вот так:

            $books->load('author', 'publisher');

  > 12.10. Вставка в связанные модели.

    --------------------------------------
    Подоглавление:

      - Введение
      - Вставка в дочерюю модель через родительскую (1:1, 1:m)
      - Вставка в родительскую модель через дочернюю (1:1, 1:m)
      - Вставка при наличии связи m:n

    --------------------------------------

    > Введение
      - Часто в модели со связями понадобится вставлять новые экземпляры.
      - При этом всплывают различные мелкие трудности.
      - Но в Laravel предусмотрен спец.функционал, чтобы их избежать.

    > Вставка в дочерюю модель через родительскую (1:1, 1:m)
      - Допустим, есть 2 модели Post и .
      - В модели Post определена прямая 1:m связь.
      - И вот понадобилось вставить в  новый экземпляр.
      - Можно сделать это вручную, но тогда придётся вручную и
        указать значение для столбца 'post_id'.
      - Чтобы с этим не паритсья, можно вставить новый экземпляр модели
         через его модель-родителя (относительно направления связи)
        Post. Тогда 'post_id' будет заполнен автоматом:

          $ = new (array('message' => 'A new .'));
          $post = Post::find(1);
          $ = $post->s()->save($);

    > Вставка в родительскую модель через дочернюю (1:1, 1:m)
      - Допустим, есть 2 модели Account и User.
      - Здесь User - это дочерняя модель модели Account.
      - В модели User определена обратная belongTo связь:

          class User extends Eloquent {
              public function account() {
                  return $this->belongsTo('Account');
              }
          }

      - Допустим, нам понадобилось вставить в User новый экземпляр.
        При этом нам надо при вставке установить значение 'account_id'
        во вставляемом экземпляре модели User. Для этого можно использовать
        метод associate().

        // Создать новый экземпляр User
          $user = new User;

        // Получить ссылку на нужный экземпляр Account
          $account = Account::find(10);

        // Установить свежесознанному $user правильный 'account_id',
        //  ассоциировав его с $account
          $user->account()->associate($account);

        // Сохранить $user в модель User
          $user->save();

    > Вставка при наличии связи m:n
      - Допустим, есть 2 модели User и Role.
      - Между ними определена связь m:n.
      - Присутствует промежуточная bridge-таблица.
      - По сути код ниже добавляет/удаляет записи в ней.
      - Добавим новую роль пользователю:

          $user = User::find(1);
          $user->roles()->attach(1);

      - Отнимем у пользователя роль:

          $user = User::find(1);
          $user->roles()->detach(1);

      - Добавить пользователю сразу несколько ролей:

          $user->roles()->sync(array(1, 2, 3));


  > 12.11. Обновление timestamp модели-родителя

    --------------------------------------
    Подоглавление:

      - Введение
      - Решение
      - Практика

    --------------------------------------

    > Введение
      - Допустим модель s связана с моделью Post belongTo связью.
      - Т.Е. s - это дочерняя с т.з. связей модель для Post.
      - Допустим, мы вставили новый экземпляр в s.
      - При этом, неплохо бы обновить столбец 'updated_at' владеющего этим
        комментом экземпляра Post.
      - И вот в этом пункте как раз описан функционал Eloquent для этого.

    > Решение
      - Нужно добавить св-во $touches в определение класса-модели.
      - Это свойство должно содержать массив строк.
      - Каждая строка содержит имя модели, связанной с данной.

    > Практика

      # Определение $touches и belongTo-связи

          class  extends Eloquent {

              protected $touches = array('post');
              public function post() {
                  return $this->belongsTo('Post');
              }

          }

      # Обновим один из экземпляров 
        - И поскольку мы указали в $touches модель 'Post' как связь,
          то обновится и значение в столбце 'updated_at' в модели Post
          у связанного с этим комментом экземпляра:

            $ = ::find(1);                // извлечь экземпляр-коммент
            $->text = 'Edit to this !';   // отредактировать
            $->save();                           // сохранить в БД


  > 12.12. Работа с bridge-таблицами

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Для организации соединения m:n требуется 3-я bridge-таблица.
      - У Eloquent есть доп.функционал по работе с этой таблицей.

    > Практика

      # Доступ к bridge-таблице
        - Представим, что модель User связана с моделью Role связью n:m.
        - Получив доступ к связанным экземплярам, имеем доступ к bridge-таблице.
        - Доступ к ней имеем через св-во pivot экземпляра из связи.

          // Получим указанный экземпляр модели User
          $user = User::find(1);

          // Пробежимся по всем экземплярам модели Role, связанным с $user
          foreach ($user->roles as $role) {

              // Вот так имеем доступ к bridge-таблице
              echo $role->pivot->created_at;

          }

      # Дополнительные столбцы у bridge-таблицы
        - По умолчанию она должна иметь только 2 столбца - ключи соединяемых
          ей таблиц-моделей.
        - Но потенциально может иметь и дополнительные столбцы.
        - Указать их можно при создании связи с помощью withPivot().
        - В примере ниже добавляем 2 доп.столбца: 'foo', 'bar'

          ...
            return $this->belongsToMany('Role')->withPivot('foo', 'bar');
          ...

      # Сделать столбцы 'created_at' и 'updated_at' автомат.поддерживаемыми
        - Если вы хотите, чтобы эти столбцы автоматически обновлялись когда
          надо, нужно использовать метод withTimestamps().

            return $this->belongsToMany('Role')->withTimestamps();

      # Удалить все записи из bridge-таблицы для указанного экземпляра
        - Для этого использовать метод detach().
        - Записи удаляются только из bridge-таблицы.

          User::find(1)->roles()->detach();

      # Создание кастомной модели bridge-таблицы
        - Laravel позволяет определить кастомную модуль bridge-таблицы.
        - Сначала надо создать свой "базовый" класс вместо Eloquent.
        - При определении своих классов-моделей вместо "... extends Eloquent"
          писать "... extends [имя своего 'базового' класса]".
        - В своём 'базовом' классе-модели определить следующую функцию,
          которая вернёт экземпляр твоей кастомной модели-таблицы:

            public function newPivot(Model $parent, array $attributes, $table, $exists) {

                return new YourCustomPivot
                                ($parent, $attributes, $table, $exists);

            }


  > 12.13. Коллекции результатов запросов

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Результатом запроса в Eloquent может быть 1 или много объектов-экземпляров.
      - Если 1, то возвращается ссылка на него.
      - Если много, то возвращается ссылка на коллекцию объектов.
      - Коллекция реализует интерфейс IteratorAggregate, и ведёт себя как массив.
      - Eloquent предоставляет ряд доп.методов для работы с этой коллекцией.
      - В этом пункте как раз и будет идти речь об этих методах.

    > Практика

      # contains() - содержит ли коллекция указанный первичный ключ?

          $roles = User::find(1)->roles;

          if ($roles->contains(2))  {
              //
          }

      # Преобразование коллекции в формат JSON
        - Если привести коллекцию к строке, то мы получим её JSON-представление.

          $roles = (string) User::find(1)->roles;    // JSON

      # Пробежаться по всем элементам коллекции:
        - Для этого используется функция each.
        - Ей как аргумент передаётся callback-функция.
        - В ней то и производятся действия на каждой итерации.

          $roles = $user->roles->each(function($role) {
              //
          });

        - По сути, это тоже самое, применить callback к каждому объекту
          в коллекции.

      # Фильтрация коллекции
        - Коллекцию можно пропустить через фильтр.
        - Для этого используется функция filter.
        - Она принимает callback-функцию как аргумент.
        - Элемент попадает в результат, если эта функция его вернёт.
        - А если не вернёт, то не попадает.
        - Результат: отфильтрованная коллекция.
        - Исходная коллекция при этом не изменяется.

          $users_filtered = $users->filter(function($user) {

            // Отфильтруем всех, кроме админов
              if($user->isAdmin()) {
                  return $user;
              }

          });

      # Отсортировать коллекцию по значению
        - Для этого используется функция sortBy.

          // Можно так
            $roles = $roles->sortBy(function($role) {
                return $role->created_at;
            });

          // А можно и так
            $roles = $roles->sortBy('created_at');

      # Определение собственного объкта-коллекции
        - Это можно сделать в определении класса-модели.
        - Нужно перезаписать св-во 'newCollection'.

            class User extends Eloquent {
                public function newCollection(array $models = array()) {
                    return new CustomCollection($models);
                }
            }


  > 12.14. Ассессоры и мутаторы в Eloquent

    --------------------------------------
    Подоглавление:

      - Введение
      - Ассессоры
      - Мутаторы

    --------------------------------------

    > Введение
      - Ассессор и мутатор определяются в классе модели.
      - Ассессор - метод, который автоматически применяется к результату,
        прежде чем он будет возвращён тебе.
      - Мутатор - метод, который автоматически применяется к результату
        непосредственно перед сохранением в БД.
      - В Eloquent ассессоры и мутаторы можно настроить так, чтобы эффект
        применялся только к значению в указанных столбцах экземпляра.
      - Имена ассессоров и мутаторов должны быть в верблюжьей нотации,
        потому что Laravel реализует стандарт PSR-0.

    > Ассессоры
      - Допустим, мы хотим изменять каждый экземпляр этой модели
        непосредственно после её извлечением и перед передачей программисту.
      - Причём нам надо изменять значение только в указанном столбце по
        имени 'first_name'.
      - Тогда имя ассессора будет таким: 'getFirstNameAttribute'.

          class User extends Eloquent {

            // Этот ассессор изменяет значние в столбце 'first_name',
            // делая первую букву заглавной
              public function getFirstNameAttribute($value) {
                  return ucfirst($value);
              }

          }

    > Мутаторы
      - Допустим, мы хотим изменять каждый экземпляр этой модели
        непосредственно перед его сохранением в БД.
      - Причём нам надо изменять значение только в указанном столбце по
        имени 'first_name'.
      - Тогда имя мутатора будет таким: 'setFirstNameAttribute'.

          class User extends Eloquent {

            // Этот мутатор изменяет значение в столбце 'first_name',
            // переводя все символы в нижний регистр
              public function setFirstNameAttribute($value) {
                  $this->attributes['first_name'] = strtolower($value);
              }

          }


  > 12.15. Мутаторы дат

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - По умолчанию Eloquent приводит значения в колонках 'created_at',
        'updated_at' и 'deleted_at' к экземплярам класса Carbon.
      - Это как раз и делает мутатор дат, имя которого getDate.
      - Carbon: расширяет стандартный PHP-класс DateTime, предоставляя
        набор дополнительных методов для работы с датой и временем.
      - Ссылка на Carbon: https://github.com/briannesbitt/Carbon
      - Это поведение можно изменить.

    > Практика

      # Установить, на какие колонки будет действовать мутатор дат
        - Для этого надо перезаписать метод getDate в классе-модели.
        - getDate - это и есть мутатор дат.
        - К указанным столбцам мутатор применяться будет, к остальным - нет.

            public function getDates() {
                return array('created_at');
            }

      # Полностью выключить мутатор дат

            public function getDates() {
                return array();
            }


  > 12.16. События модели

    --------------------------------------
    Подоглавление:

      - Введение
      - Миссия
      - Список событий
      - Вернуть false: отменить действие по умолчанию
      - Метод boot
      - Практика

    --------------------------------------

    > Введение
      - Модели в Eloquent могут генерировать ряд событий.
      - Этим событиям можно назначать функции-обработчики.
      - Это позволяет "вклинивать" доп.код на различных этапах процесса.

    > Миссия
      - Позволяет автоматически вклинивать свой код перед/после операций
        создания, изменения, удаления, восстановления экземпляров модели.

    > Список событий
      - Здесь представлен список методов.
      - Каждый метод служит для назначения обработчика своему событию.
      - Функция-обработчик передаётся методу как callback-аргумент.

        # creating    // возбуждаетс непоср.перед созданием нового экземпляра
        # created     // возбуждаетс непоср.после создания нового экземпляра
            ---
        # updating    // возбуждается непоср.перед изменением экземпляра
        # updated     // возбуждается непоср.после изменения экземпляра
            ---
        # saving      // возбуждается непоср.перед сохранением экземпляра в БД
        # saved       // возбуждается непоср.после сохранения экземпляра в БД
            ---
        # deleting    // возбуждается непоср.перед удалением экземпляра
        # deleted     // возбуждается непоср.после удаления экземпляра
            ---
        # restoring   // возбуждается непоср.перед восстановлением 'soft deleted' экземпляра
        # restored    // возбуждается непоср.после восстановления 'soft deleted' экземпляра

    > Вернуть false: отменить действие по умолчанию
      - Если функция-обработчик событий creating, updating, saving или
        deleting вернут false, то действие по умолчанию для этого события
        будет отменено.

    > Метод boot
      - Определяется в классе-модели.
      - Позволяет прямо в нём назначить функции-обработчики для модели.
      - Очень удобно.

    > Практика

        # Отменить действие по умолчанию для события creating

            User::creating(function($user) {

                // Проверим на валидность создаваемый экземпляр польз.функцией isValid().
                // Если не валиден, не создавать.
                if (!$user->isValid()) return false;


            });

        # Назначить функции-обработчики для модели в методе boot

            class User extends Eloquent {

              public static function boot() {
                parent::boot();

                // Здесь назначать функции-обработчики

              }

            }


  >12.17. Класс-наблюдатель за моделью

    --------------------------------------
    Подоглавление:

      - Введение
      - Практика

    --------------------------------------

    > Введение
      - Это такое место, где для удобства можно собрать функции-обработчики
        событий модели, опианных в 12.16.

    > Практика

      # Определить класс-наблюдатель
        - Имена методов класса должны совпадать с именами событий модели.
        - Например: 'creating', 'created', 'updating' ... и т.д.

            class UserObserver {

                public function saving($model) {
                    //
                }

                public function saved($model) {
                    //
                }

            }

      # Регистрация экземпляра класса-наблюдателя для модели
        - Экземпляр класса-наблюдателя можно зарегистрировать для любой модели.
        - Без этого, разумеется, ничего работать не будет.
        - В этом примере зарегистрируем для модули User.

            User::observe(new UserObserver);


  > 12.18. Конвертация в массивы / JSON

    --------------------------------------
    Подоглавление:

      - Введение
      - Чёрный и белый списки столбцов
      - Практика

    --------------------------------------

    > Введение
      - Часто в разработке приходится использовать формат JSON.
      - Понадобится делать двустороннюю конвертацию коллекция <-> JSON.
      - Для этого в Eloquent предусмотрен специальный функционал.

    > Чёрный и белый списки столбцов

      > В общем
        - Речь идёт и о конвертации в массив, и в JSON-строку.
        - По умолчанию при конвертации в результат попадают данные из
          всех столбцов.
        - Это поведение можно изменив, явно определив "чёрный" или "белый"
          списки столбцов.

      > Чёрный список
        - Это массив имён столбцов модели, которые не попадают в результат
          конвертации.
        - Для его определения надо в определении класса-модели явно определить
          переменную $hidden, и в ней этот массив.

      > Белый список
        - Это массив имён столбцов модели, которые попадают в результат
          конвертации.
        - Для определения белого списка надо в определении класса-модели явно
          определить переменную $visible, и в ней этот массив.
        - В результат попадают только данные из указанных в нём столбцов,
          только те из них, которые явно не присутствуют в "чёрном списке".

    > Практика

      # Конвертация экземпляра модели в массив

          $user = User::with('roles')->first();
          $array = $user->toArray();

      # Конвертация коллекции экземпляров в массив

          $results = User::all();
          $array = $results->toArray();

      # Конвертация экземпляра модели в JSON-строку

        // Способ 1
          $user = User::with('roles')->first();
          $json = $user->toJson();

        // Способ 2
          $user = User::with('roles')->first();
          $json = (string) $user;

      # Конвертация коллекции экземпляров в JSON-строку

        // Способ 1
          $results = User::all();
          $json = $results->toJson();

        // Способ 2
          $results = User::all();
          $json = (string) $results;

      # Возвращение экземпляра модели прямо из роута
        - При этом происходит автоконвертация в JSON-строку

            Route::get('users', function()
            {
                return User::all();
            });

      # Определение чёрного списка в классе-модели:

            class User extends Eloquent {

              protected $hidden = array('password');

            }

      # Определение белого списка в классе-модели:

            class User extends Eloquent {

              protected $visible = array('first_name', 'last_name');

            }


13. Schema Builder (управление таблицами)

  --------------------------------------
  Подоглавление:

    - Введение
    - Создание/удаление таблиц
    - Добавление колонок
    - Изменение порядка колонок (только для MySQL)
    - Переименование колонок
    - Удаление колонок
    - Проверить по имени наличии таблицы или колонки
    - Добавление индексов
    - Удаление индексов
    - Добавление/удаление внешних ключей
    - Движки хранилищ

  --------------------------------------

  > Введение
    - У Laravel есть класс Schema.
    - Он позволяет работать с таблицами БД: добавлять, изменять, удалять.
    - Для этого он содержит соответствующий функционал.
    - Он позволяет работать со всеми 4-мя СУБД, которые поддерживает Laravel.
    - Причём для всех СУБД функционал унифицирован, один и тот же.

  > Создание/удаление таблиц

    # Создань новую таблицу
      - 1-й аргумент: имя таблицы
      - 2-й аргумент: анонимная функция, получающая как аргумент конфигурационный
                      объект $table, изменяя который можно настроить создаваемую таблицу.

        Schema::create('users', function($table) {
            $table->increments('id');
        });

    # Переименовать существующую в БД таблицу

        Schema::rename($from, $to);

    # Уточнить, какое соединение использовать для операции
      - Допустим, мы хотим использовать соединение 'foo'...

        Schema::connection('foo')->create('users', function($table) {
            $table->increments('id');
        });

    # Удалить таблицу из БД

        Schema::drop('users');

    # Удалить из БД таблицу, если она существует

        Schema::dropIfExists('users');

  > Добавление колонок

    > Чтобы изменить существующую в БД таблицу, можно использовать метод
      Schema::table. Во время изменения, в теле анонимной функции и
      производятся манипуляции с колонками:

        Schema::table('users', function($table) {
            $table->string('email');
        });

    > Доступные операции по работе с колонками:

      # $table->bigIncrements('id');     | создать столбец 'id' типа BIGINT с автоинкрементом
      # $table->bigInteger('votes');     | создать столбец 'votes' типа BIGINT
      # $table->binary('data');          | создать столбец 'data' типа BINARY
      # $table->boolean('confirmed');    | создать столбец 'confirmed' типа BOOL
      # $table->date('created_at');      | создать столбец 'created_at' типа DATE
      # $table->dateTime('created_at');  | создать столбец 'created_at' типа DATETIME
      # $table->decimal('amount', 5, 2); | создать столбец 'amount' типа DECIMAL
                                           - 5: MAX кол-во цифр во всём числе
                                           - 2: MAX кол-во цифр после запятой
      # $table->double('column', 15, 8); | создать столбец 'column' типа DOUBLE
                                           - 15: MAX кол-во цифр во всём числе
                                           - 8:  MAX кол-во цифр после запятой
      # $table->enum('choices', array('foo', 'bar'));| создать столбец 'choices' с вариантами 'foo', 'bar'
      # $table->float('amount');           | создать столбец 'amount' типа FLOAT
      # $table->increments('id');          | создать столбец 'id' типа INT с автоинкрементом
      # $table->integer('votes');          | создать столбец 'votes' типа INT
      # $table->longText('description');   | создать столбец 'description' типа LONGTEXT
      # $table->mediumText('description'); | создать столбец 'description' типа MEDIUMTEXT
      # $table->smallInteger('votes');     | создать столбец 'votes' типа SMALLINT
      # $table->tinyInteger('numbers');    | создать столбец 'numbers' типа TINYINT
      # $table->string('email');           | создать столбец 'email' типа VARCHAR
      # $table->string('name', 100);       | создать столбец 'email' типа VARCHAR длины 100
      # $table->text('description');       | создать столбец 'description' типа TEXT
      # $table->time('sunrise');           | создать столбец 'sunrise' типа TIME
      # $table->timestamp('added_on');     | создать столбец 'added_on' типа TIMESTAMP

      # $table->morphs('taggable');        | добавить надлежащий столбец для полиморфной таблицы
      # $table->softDeletes();             | добавить столбец 'deleted_at' типа TIMESTAMP
      # $table->timestamps();              | добавить столбцы 'created_at' и 'updated_at' типа TIMESTAMP
      # ->nullable()                       | объявить, что эта колонка допускает NULL-значения
      # ->default($value)                  | объявить значение по умолчанию для этой колонки
      # ->unsigned()                       | сделать тип INT этой колонки UNSIGNED

  > Изменение порядка колонок (только для MySQL)

    # Изменить порядок колонок в таблице
      - Пусть сначала идёт столбец 'name', а справа от него 'email'

      $table->string('name')->after('email');

  > Переименование колонок
    - Для переименования можно использовать метод renameColumn.
    - Перед переименованием убедись, что в твоём composer.json файле
      добавлена зависимость doctrine/dbal.
    - Переименование колонок типа ENUM не поддерживается.

    # Переименовать колонку

      Schema::table('users', function($table) {
          $table->renameColumn('from', 'to');
      });

  > Удаление колонок

    # Удалить колонку
      - Удалим из таблицы 'users' колонку 'votes'

      Schema::table('users', function($table) {
          $table->dropColumn('votes');
      });

    # Удалить сразу несколько колонок
      - Удалим из таблицы 'users' колонки 'votes', 'avatar', 'location'.

      Schema::table('users', function($table) {
          $table->dropColumn('votes', 'avatar', 'location');
      });

  > Проверить по имени наличии таблицы или колонки

    # Проверить наличие таблицы
      - Проверим, есть ли в наличии таблица 'users'

      if (Schema::hasTable('users')) {
          //
      }

    # Проверить наличие колонки
      - Проверим, есть ли в таблице 'users' в наличии колонка 'email'

      if (Schema::hasColumn('users', 'email')) {
          //
      }

  > Добавление индексов

    > Введение
      - Schema Builder поддерживает несколько типов индексов.
      - Индексы можно добавить при создании колонки в её определении.
      - Или же их можно добавить отдельно, после создания колонки.

    > Доступные операции для создания индексов:

      # $table->primary('id');                  | на колонке 'id' установить индекс типа PRIMARY KEY
      # $table->primary(array('first', 'last'));| на колонках 'first' и 'last' установить индекс типа PRIMARY KEY
      # $table->unique('email');                | на колонке 'email' создать индекс типа UNIQUE
      # $table->index('state');                 | на колонке 'state' создать индекс типа INDEX

    > Примеры:

      # Добавить индекс во время создания колонки
        - Добавим колонке 'email' при её создании индекс типа UNIQUE

        ...
        $table->string('email')->unique();
        ...

  > Удаление индексов

    > Введение
      - Чтобы удалить индекс, надо знать его имя.
      - Laravel присваивает индексам имена автоматически.
      - Принцип, по которому он это делает, выглядит так:
          [имя таблицы]+'_'+[имя колонки]+'_'+[тип индекса].
      - Например, для таблицы 'users', колонки 'id' и типа индекса 'primary',
        имя индекса будет таким: 'users_id_primary

    > Доступные операции для удаления индексов:

      # $table->dropPrimary('users_id_primary'); | удалить индекс по имени 'users_id_primary' типа PRIMARY из колонки 'id' табилцы 'users'
      # $table->dropUnique('users_email_unique');| удалить индекс по имени 'users_email_unique' типа UNIQUE из колонки 'email' таблицы 'users'
      # $table->dropIndex('geo_state_index');    | удалить индекс по имени 'geo_state_index' типа INDEX из колонки 'state' таблицы 'geo'

  > Добавление/удаление внешних ключей
    - Laravel позволяет также добавлять/удалять внешние ключи в таблицах.

    # Добавить внешник ключ в таблицу
      - Указать, что колонка 'user_id' в этой таблице связана с колонкой
        'id' в таблице 'users' внешним ключём.
      - Также указаны доп.настройки в виде onDelete и onUpdate.

      $table->foreign('user_id')->references('id')->on('users')
        ->onDelete('cascade')
        ->onUpdate('cascade');

    # Удалить внешний ключ
      - Удалим у таблицы внешний ключ по имени 'posts_user_id_foreign'

      $table->dropForeign('posts_user_id_foreign');

  > Движки хранилищ

    # Указать движок для таблицы

      Schema::create('users', function($table) {
          $table->engine = 'InnoDB';
          $table->string('email');
      });


14. Миграции и заселение

  --------------------------------------
  Подоглавление:

    - Введение
    - Как формируется имя миграции
    - Создание миграций
    - Выполнение миграций
    - Откат миграций
    - Заселение БД

  --------------------------------------

  > Введение
    - Миграции представляют собой некую систему контроля версий для БД.
    - Фактически миграция представляет собой .php файл.
    - Этот файл содержит класс, наследующий от класса Migration.
    - Этот класс содержит обычно 2 метода: 'up' и 'down'.
    - При выполнении метода 'up' миграция применяется к БД.
    - При выполнении метода 'down' миграция отменяется, всё возвращается как было.
    - Сами эти методы содержат операции "Schema Builder" с таблицами.
    - По умолчанию миграции хранятся в папке 'app/database/migrations'.
    - Однако при создании миграции в опции --path можно указать и другую папку.

  > Как формируется имя миграции
    - Имя файла-миграции формируется автоматически при создании миграции.
    - Оно содержит имя миграции, указанное при её создании, и timestamp.
    - Например, имя файла-миграции с именем 'create_users_table' может быть таким:
          "2014_02_07_130655_create_users_table.php"
    - Timestamp нужен, чтобы Laravel мог определить порядок миграций.

  > Создание миграций
    - Создавать миграции можно в консоли с помощью Artisan CLI.
    - Для создания миграции используется команда migrate:make.

    # Создать миграцию
      - Создадим миграцию с именем 'create_users_table'
      - При этом методы up и down будут абсолютно пусты.

      php artisan migrate:make create_users_table

    # Создать миграцию не в папке по умолчанию
      - По умолчанию файл-миграция создаётся в папке 'app/database/migrations'.
      - Создадим файл-миграцию в папке 'app/migrations'

      php artisan migrate:make foo --path=app/migrations

    # Создать миграцию, изменяющую таблицу с указанным именем
      - Для этого надо при создании миграции указать опцию '--table'.
      - В значении опции надо указать имя таблицы, которую будет изменять миграция.
      - Эта опция влияет по сути только на содержание методов up и down.
      - Они уже не будут пусты, как при создании миграции без флагов.
      - А будут содержать выражение для изменения таблицы Schema::table.

        php artisan migrate:make add_votes_to_user_table --table=users

    # Создать миграцию, создающую таблицу с указанным именем
      - Для этого надо при создании миграции указать опцию '--create'.
      - В значении опции надо указать имя таблицы, которую будет создавать миграция.
      - Эта опция влияет по сути только на содержание методов up и down.
      - Они уже не будут пусты, как при создании миграции без флагов.
      - А будут содержать выражение для изменения таблицы Schema::create.

        php artisan migrate:make create_users_table --create=users

  > Выполнение миграций

    # Выполнить все не выполненные миграции
      - При этом будут выполнены их методы up

      php artisan migrate

    # Выполнить все не выполненные миграции в папке

      php artisan migrate --path=app/foo/migrations

  > Откат миграций

    # Откатить назад последнюю выполненную миграцию
      - При этом будет выполнен её метод down

      php artisan migrate:rollback

    # Откатить назад все миграции

      php artisan migrate:reset

    # Откатить назад все миграции, и выполнить их по новой

      php artisan migrate:refresh
      php artisan migrate:refresh --seed

  > Заселение БД

    > Введение
      - У Laravel есть функционал для заселения таблиц БД тестовыми данными.
      - Заселение производится с помощью классов-заселяльщиков.
      - Все классы-заселяльщики хранятся в папке 'app/database/seeds'.
      - Классу-заселяльщику можно дать любое имя.
      - По умолчанию класс 'DatabaseSeeder' определён за вас.
      - Из него можно вызывать другие классы методом call по имени.
      - Таким образом можно контролировать порядок заселения.

    > Практика

      # Пример определения класса-заселяльщика
        - Это содержимое файла "DatabaseSeeder.php"

          <?php
          class DatabaseSeeder extends Seeder {

              public function run() {
                  $this->call('UserTableSeeder');

                  $this->command->info('User table seeded!');
              }

          }

          class UserTableSeeder extends Seeder {

              public function run() {
                  DB::table('users')->delete();

                  User::create(array('email' => 'foo@bar.com'));
              }

          }

      # Применить класс-заселяльщик и заселить БД
        - По умолчанию команда запускает метод run класса DatabaseSeeder
          из одноимённого файла из папки 'app/database/seeds'

        php artisan db:seed

      # Применить указанный класс-заселяльщик
        - Это можно сделать, использовав опцию '--class'.
        - Значением должно быть имя класса-заселяльщика, который надо использовать.

        php artisan db:seed --class=UserTableSeeder


15. Redis [!в разработке!]

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    -

  --------------------------------------

  > Ссылки

    - Официальный сайт:
        http://redis.io/topics/quickstart

    - Скачать последнюю версию для windows:
        https://github.com/rgl/redis/downloads

  > Введение
    - Redis - это NoSQL база данных для хранения данных типа ключ/значение.







|--------------------------------------------------------------------------
| Продвинутые знания
|--------------------------------------------------------------------------
|
| В этом разделе описаны продвинутые техники работы с Laravel
|


16. Аутентификация

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Терминология
    - Как работает аутентификация вообще и в Laravel в частности
    - Настройка
    - Атака "фиксация сессии"
    - Класс Hash: сохранение паролей
    - Класс Auth: аутентификация пользователей
    - Фильтр 'auth' на роутах
    - Фильтр 'CSRF' на роутах
    - Basic HTTP аутентификация
    - Напоминание и сброс пароля
    - Шифрование

  --------------------------------------

  > Ссылки

    - Статья на tutsplus с пошаговой инструкцией, как сделать аутентификацию
      на Laravel 4 и twitter bootstrap:
        http://code.tutsplus.com/tutorials/authentication-with-laravel-4--net-35593

    - Статья на laravelbook.com с пошаговой инструкцией, как сделать аутентификацию:
      на Laravel 4:
        http://laravelbook.com/laravel-user-authentication/

  > Введение
    - Laravel содержит функционал, облегчающий разработку аутентификации в приложении.
    - Можно использовать или не использовать его, по желанию разработчика.

  > Терминология

    # Аутентификация  | процесс проверки подлинности пользователя путём поиска
                        введённых им аутентификационных данных (логин, пароль) в
                        базе данных пользователей и сравнения.

    # Авторизация     | процесс проверки, имеет ли авторизованный пользователь
                        достаточно привелений, чтобы сделать то, что он собирается.

    # Залогиненый
      пользователь    | пользователь, прошедший аутентификацию, и успешно
                        вошедший в приложение.

  > Как работает аутентификация вообще и в Laravel в частности

    > Когда заходит новый пользователь без кук вообще
      - Вот заходит на сайт совершенно новый пользователь.
      - Ему предлагают ввести логин и пароль для аутентификации. Он вводит.
      - Сервер ищет такого пользователя в БД в таблице с пользователями.
        - Таблица с пользователями указана в конфиге 'app/auth.php'
      - Допустим, такой пользователь существует, что происходит дальше?
      - Создаётся аутентификационная сессия с уникальным сессионным ID.
        - Используется сессионный механизм, указанный в конфиге 'app/config/sessions.php'
        - Сессия создаётся по адресу 'app/storage/sessions'.
      - Пользователю отсылается сессионная кука - пара ключ/значение.
        - Ключ: сессионный ID
          - Ключ генерируется по шаблону: 'login_' + [сессионный ID].
          - Причём [сессионный ID] в захэшированном алгоритмом md5 виде.
        - Значение: ID пользователя из таблицы пользователей.
        - Это позволит пользователю быть авторизованным в течение времени,
          пока эта сессия и кука будут существовать: столько, сколько
          указано в конфиге session.php в параметре 'lifetime' (120 минут по умолчанию).
      - Также пользователю отсылается 'remember me' кука - пара ключ/значение.
        - Она отсылается, только если при авторизации было указано $remember == true.
        - Ключ: ID 'remember me' куки
          - Ключ генерируется по шаблону: 'remember_' + [ID 'remember me' куки].
          - Причём [ID 'remember me' куки] в захэшированном алгоритмом md5 виде.
        - Значение: ID пользователя из таблицы пользователей.
        - Эта кука будет действительна в течение 5 лет.
        - В течение этого времени пользователь будет авторизован в приложении,
          если не потеряет куку, или не залогаутится самостоятельно (после
          чего 'remember me' кука будет удалена).

          --------------                                --------------
          |            |   --> [новая сессия] -->       |            |
          |            |                                |            |
          |   новый    |                                |            |
          |  пользов.  |                                |   сервер   |
          |            |   <-- [сессионная кука] <--    |            |
          |            |                                |            |
          |            |   <-- [remember me кука] <--   |            |
          --------------                                --------------

    > Когда приходит пользователь с сессионной кукой
      - Вот заходит на сайт пользователь с сессионной кукой.
      - Кука у него не истёкшая (а иначе браузер бы её автоматом удалил).
      - Приложение проверяет наличие сессионной куки у пользователя.
      - Если она есть, не истекла, не подделана, то она успешно проходит проверку.
      - В этой куке лежит ID учётной записи пользователя.
      - По этому ID сервер находит строку пользователя в таблице пользователей.
        - Таблица с пользователями указана в конфиге 'app/auth.php'
      - Вошедший аутентифицируется на сайте, как этот самый пользователь.
      - После аутентификации автоматом изменяется ID сессии.
      - А старая сессионная кука со старым ID сессии заменяется на новую.
      - Это делается с целью защиты от атаки "фиксация сессии".

    > Когда приходит польозватель с 'remember me' кукой
      - Вот заходит на сайт пользователь с 'remember me' кукой.
      - Сессионной куки у него нет.
      - Приложение проверяет наличие 'remember me' куки.
      - Если она есть, не истекла, не подделана, то она успешно проходит проверку.
      - В этой куке лежит ID учётной записи пользователя.
      - По этому ID сервер находит строку пользователя в таблице пользователей.
        - Таблица с пользователями указана в конфиге 'app/auth.php'
      - Вошедший аутентифицируется на сайте, как этот самый пользователь.


  > Настройка
    - Конфигурационный файл для настройки этого функционала лежит в 'app/config/auth.php'.
    - Настройки хорошо задокументированы.

    > Краткое описание параметров в auth.php

      # 'driver'
        - Eloquent или Query Builder будет использовать аутентификационный функционал?
        - Возможны 2 варианта значения: "eloquent" (по умолч.), "database"

      # 'model'
        - Применяется, если использован 'driver' == 'Eloquent'
        - Указывает, какой класс-модель использовать для извлечения пользователей.
          Т.Е. иными словами, в какой таблице лежат данные о пользователях.
        - По умолчанию указана модель 'app/models/user.php'.

      # 'table'
        - Применяется, если использован 'driver' == 'Database'
        - Указывает имя таблицы, в которой лежат данные о пользователях,
          и которую требуется использовать для аутентификации.

      # 'reminder'
        - Содержит массив с настройками для напоминалки паролей.

        # 'email'
          - Путь к представлению (view), которое должно быть показано
            пользователю, как интерфейс напоминалки паролей.
          - Это путь относительно папки 'app/views'. В нём вместо '/'
            должны быть '.'

        # 'table'
          - Имя таблицы, которая соедржит 'reset tokens'.

        # 'expire'
          - Это время в минутах, по умолчанию 60 минут.
          - Обозначает, сколько времени напоминалка остаётся валидной
            после её запроса.

  > Атака "фиксация сессии"

    > Суть проблемы
      - Есть такая хакерская атака, называется "фиксация сессии".
      - Дело в том, что ID сессии можно передать в адресной строке.
      - Хакер формирует URL с заранее заготовленным ID сессии (фиксирует его).
      - Затем убеждает жертву перейти по этому URL и авторизоваться на сайте.
      - После этого хакер сам може перейти по этой же ссылке и получить контроль
        над учётной записью пользователя.

    > Решение
      - После каждой авторизации пользователя сервер должен перегенерировать
        его сессионный ID на новый.
      - Тогда злоумышленники не смогут войти, используя тот же сессионный ID.
      - Механизм аутентификации Laravel так и поступает.

  > Класс Hash: сохранение паролей
    - Это функционал Laravel для хэширования паролей bcrypt-функцией.
    - Доступен через класс Hash.

    # Захэшировать пароль функцией bcrypt

      $password = Hash::make('secret');

    # Сравнить строку и захэшированный пароль
      - Допустим, пользователь решил авторизоваться в приложении.
      - И он ввёл пароль.
      - А у нас в базе сохранён пароль в виде хэша.
      - Надо же теперь как то их сравнить, чтобы определить, правильный
        ли пароль ввёл пользователь?

      if (Hash::check('secret', $hashedPassword)) {
          // The passwords match...
      }

    # Проверить, требуется ли перехэшировать пароль
      - [Видимо бывают случаи, когда требуется...]

      if (Hash::needsRehash($hashed) {
          $hashed = Hash::make('secret');
      }

  > Класс Auth: аутентификация пользователей

    # Auth::attempt - аутентификация пользователя в приложении с выключенным
                      функционалом "запомнить меня"
      - 1 аргумент: массив данных для аутентификации.
        - В примере ниже в качестве логина использован 'email'.
        - Но это не обязательно, логином может быть всё, что угодно.
        - Любой столбец, который присутствует в таблице с пользователями.
        - Например, номер телефона, или просто набор символов.
      - 2 аргумент: использовать ли функционал "запомнить меня".
        - Вообще, его можно не передавать, по умолчанию он == false.
        - False значит, что пользователю не будет отправлена аутентификационная
          кука, и когда всё закроет и перезайдёт, то ему снова придётся авторизоваться.
      - Возбуждаемые события:
        - После вызова метода attempt, возбудится событие auth.attempt.
        - Если аутентификация успешна, возбудется событие auth.login.

        if (Auth::attempt(array('email' => $email, 'password' => $password), false)) {

          // Отправить пользователя на тот документ, при попытке перехода на
          // который он был "пойман" аутентификационным фильтром.
            return Redirect::intended('dashboard');

        }

    # Auth::attempt - аутентификация пользователя в приложении с включённым
                      функционалом "запомнить меня"
      - Если в функцию Auth::attempt передать true, то пользователю будет
        отправлена аутентификационная кука, содержащая зашифрованный
        идентификатор пользвоателя.
      - Когда пользователь всё закроет и откроет заново, приложение его
        узнает, проверив эту куку. Т.О. пользователь останется аутентифицированным
        неопределённо долгое время.

        if (Auth::attempt(array('email' => $email, 'password' => $password), true)) {
            // The user is being remembered...
        }

    # Auth::attempt - аутентификация пользователя в приложении с доп.условиями
      - В этом примере при аутентификации зададим доп.параметр.
      - Проверим, является ли учётная запись пользователя активной.
      - Для этого проверим значение столбца 'active' пользовательской таблицы.

        if (Auth::attempt(array('email' => $email, 'password' => $password, 'active' => 1))) {
            // The user is active, not suspended, and exists.
        }

    # Auth::check - проверить, аутентифицирован ли уже пользователь в приложении

        if (Auth::check()) {
            // The user is logged in...
        }

    # Auth::viaRemember - проверить, аутентифицирован ли уже пользователь
                          с использованием функционала "запомнить меня"

        if (Auth::viaRemember()) {
            //
        }

    # Доступ к данным аутентифицированного пользователя в табилце пользователей
      - Ну вот допустим пользователь аутентифицировался в приложении.
      - Как теперь получить доступ его данным?
      - Данным в его строке в таблице, указанной в конфиге 'auth.php'?
      - Для этого предусмотрен удобный функционал, доступный через класс Auth.
      - Например, получим email:

          $email = Auth::user()->email;

    # Auth::loginUsingId - залогинить пользователя, указав его ID
      - В таблице, указанной в конфиге 'auth.php', у каждого пользователя есть ID.
      - Можно программно аутентифицировать пользователя по этому ID.

          Auth::loginUsingId(1);

    # Auth::validate - валидация введённых пользователем данных без логина
      - Иногда надо просто проверить введенные пользователем логин и пароль.
      - Чтобы при этом не произошло авторизации (log in).

          if (Auth::validate($credentials)) {
              //
          }

    # Auth::loginUsingId - залогинить пользователя в учётку с указанным ID без аутентификации
      - Когда пользователь логинится через attempt, он должен ввести логин и пароль.
      - В конфиге 'auth.php' указана таблица с пользователями в БД.
      - Внутри функция матчит введённые логин и пароль с записями в таблице.
      - И если они найдены, и все условия выполнены, логинит пользователя.
      - А вот с функцией loginUsingId история совсем другая.
      - Используя её, можно запустить кого угодно в любую учётную запись.
      - Никакой проверки чего-бы то нибыло не происходит.
      - Пользователя просто логинят с учётной записью, указанной в ID.

        Auth::loginUsingId(1);

    # Авторизовать пользователя без сессий и кук по ID
      - Это будет авторизация на 1 запрос.
      - В качестве атрибута принимает массив параметров для авторизации.

        if (Auth::once($credentials)) {
            //
        }

    # Авторизовать пользователя без сессий и кук по экземпляру пользователя

        $user = User::find(1);
        Auth::login($user);

    # Залогаутить пользователя из приложения

        Auth::logout();

  > Фильтр 'auth' на роутах
    - Из коробки в Laravel в файле 'app/filters.php' определён фильтр 'auth'.
    - Его можно поставить на любой роут, как before-фильтр.
    - Он бутет пропускать в роут только авторизованных пользователей.
    - Все guest-пользователи будут переадресованы на страницу для авторизации.

    # Установим на роут 'profile' before-фильтр 'auth'

        Route::get('profile', array('before' => 'auth', function() {
            // Only authenticated users may enter...
        }));

  > Фильтр 'CSRF' на роутах

    > Про фильтр
      - Из коробки в Laravel в файле 'app/filters.php' определён фильтр 'csrf'.
      - Его можно поставить на любой роут, как before-фильтр.
      - Он будет защищать сайт от csrf-атак.

    > Что такое CSRF-атака
      - Cross-Site Request Forgery - межсайтовая подделка запроса.
      - Допустим, у пользователя есть сессионная кука с нашего сайта.
      - Пользователь заходит на сайт хакера.
      - А там выполняется JS-скрипт, который выполняет AJAX-запрос.
      - Запрос от имени пользователя к нашему сайту, с использованием его кук.
      - Так хакер может запросто украсть аккаунт у пользователя, или другие данные.

    > Как защититься от CSRF-атак?
      - Можно поставить before-фильтр 'csrf' на роуты.
      - А сами запросы подписывать неким кодом, который называют csrf-token.
      - Фильтр будет пропускать в роут только запросы с правильным кодом.

    > Практика

      # Вставить CSRF-токен в форму

        <input type="hidden" name="_token" value="<?php echo csrf_token(); ?>">

      # Установить на роут 'register' before-фильтр 'auth':

        Route::post('register', array('before' => 'csrf', function() {
            return 'You gave a valid CSRF token!';
        }));

  > Basic HTTP аутентификация

    > Что такое и как работает HTTP Basic Auth
      - В переводе на русский: базовая HTTP-аутентификация.
      - Вот от клиента приходит запрос на сервер.
      - Сервер в ответ посылает HTTP-заголовок "WWW-Authenticate...".
      - Браузер всё понимает, и показывает модальное окно для ввода логина и пароля.
      - Пользователь их вводит и нажимает OK.
      - На сервере введённые данные доступны в переменных: 'PHP_AUTH_USER', 'PHP_AUTH_PW'.

    > Как это работает в Laravel

      > Введение
        - HTTP Basic Auth является быстрым способом авторизовать пользователя.
        - При этом дажен не нужно создавать login-страницу.
        - Нужно лишь поставить фильтр 'auth.basic' на нужный роут.
        - Фильтр 'auth.basic' реализует Basic HTTP Auth для роута.
        - Он идёт вместе с Laravel 'из коробки', и находится в 'app/filters.php'.
        - По умолчанию для матчинга логина он ищет столбец 'email' в таблице пользователей.
        - Чтобы это изменить, придётся создать свой фильтр с блэкджэком и шлюхами (см.ниже)

      > Практика

        # Установить на роут 'profile' фильтр 'auth.basic'

          Route::get('profile', array('before' => 'auth.basic', function()
          {
              // Only authenticated users may enter...
          }));

        # Определить свой custom фильтр для Basic HTTP Auth
          - Стандартный 'auth.basic' для матчинга логина ищет d столбце 'email'
            в таблице пользователей.
          - А этот будет искать в столбце 'username'.
          - Для этого надо передать строку 'username' функции basic как
            аргумент в определении фильтра.
          - Определяется он в файле 'app/filters.php'.

            Route::filter('basic_custom', function()
            {
              return Auth::basic('username');
            });

        # Определить свой фильтр для Basic HTTP Auth без сессий и кук

          Route::filter('basic.once', function()
          {
              return Auth::onceBasic();
          });

  > Напоминание и сброс пароля

    > Введение
      - Пользователь может забыть пароль от своей учётной записи.
      - Поэтому должен быть способ сбросить старый пароль, и установить новый.
      - Laravel предоставляет специальный функционал и для этого.
      - Он позволяет отсылать напоминалки пароля и делать сбрасывание пароля.
      - Чтобы всё работало, сначала убедись, что твоя модель User реализует интерфейс
        'Illuminate\Auth\Reminders\RemindableInterface'

    > Практика

      # Вот как выглядит определение класса User, реализующего RemindableInterface:

        class User extends Eloquent implements RemindableInterface {

            public function getReminderEmail()
            {
                return $this->email;
            }

        }

      # Создание таблицы для хранения токенов для сброса паролей
        - Чтобы механизм заработал, такая таблица должна быть создана в БД.
        - Создать её можно 2-мя простыми командами в Artisan (см.ниже).
        - При этом в БД будет создана таблица с именем 'password_reminders'.
        - А в ней будет 3 столбца: 'email', 'token' и 'created_at'.

            php artisan auth:reminders-table
            php artisan migrate

      # Генерация reminder-контроллера
        - Теперь нам надо сгенерировать reminder-controller.
        - Сделать это можно 1-й простой командой Artisan (ниже).
        - В результате будет сгенерирован REST-контроллер.
        - В нём 4 метода: 'getRemind', 'postRemind', 'getReset', 'postReset'.

         php artisan auth:reminders-controller

      # 'getRemind' - показ представления для напоминания пароля
        - 'getRemind' отвечает за показ формы напоминания паролей.
        - По умолчанию он возвращает представление с именем 'password.remind'.
        - В любом случае, показываемое представление должно быть создано.
        - Представление должно содержать форму с полем name='email'.
        - Она должна слать POST-запрос методу 'postRemind' контроллера.
        - Пример содержания представления:

          <form action="{{ action('RemindersController@postRemind') }}" method="POST">
              <input type="email" name="email">
              <input type="submit" value="Send Reminder">
          </form>

      # 'postRemind' - отсылка письма-напоминалки пароля пользователю
        - 'postRemind' отвечает за отсылку письма-напоминалки пароля пользователю.
        - Метод ожидает, что на входе в POST-запросе будет поле 'email'.
        - В этом поле он ожидает найти email-адрес пользователя из таблицы пользователей.
        - По этому адресу, если он найден в БД, он и отправить письмо-напоминалку пароля.
        - Внутри 'postRemind' сообщение отправляется методом Password::remind.
        - Вторым аргументом он принимает callback-функцию.
        - Внутри неё можно редактировать сообщение, которое будет отправлено пользователю:

            public function postRemind() {

              Password::remind(Input::only('email'), function($message)
              {
                  $message->subject('Password Reminder');
              });

            }

        - В случае успешной отправки, в сессию будет записано 'status'-сообщение.
        - В случае неудачи, в сессию будет записано 'error'-сообщение.

      # 'getReset' - показ представления для сброса пароля
        - Вот 'postRemind' отправил пользователю письмо-напоминалку пароля.
        - Это письмо содержит ссылку на метод 'getReset' контроллера.
        - Ему на вход вместе с запросом будет отправлен токен для сброса паролей.
          - По умолчанию 'срок годности' этого токена всего 1 час.
          - Изменить это можно в опции 'reminder.expire' в файле 'app/config/auth.php'
        - По умолчанию 'getReset' возвращает представление с именем 'password.reset'.
        - В любом случае, показываемое представление должно быть создано.
        - Токен должен быть помещён в значение атрибута value скрытого
          эл-та input с атрибутом name='token'.
        - Также форма должна содержать поля: 'email', 'password' и 'password_confirmation'.
        - Она должна слать POST-запрос методу 'postReset' контроллера.
        - Пример содержания представления:

          <form action="{{ action('RemindersController@postReset') }}" method="POST">
              <input type="hidden" name="token" value="{{ $token }}">
              <input type="email" name="email">
              <input type="password" name="password">
              <input type="password" name="password_confirmation">
              <input type="submit" value="Reset Password">
          </form>

      # 'postReset' - сохранение нового пароля в БД
        - По умолчанию этот метод делает следующее.
        - Получает из аргументов ссылку на экземпляр модели User.
        - Он меняет значение свойства $user->password на хэш нового пароля.
        - Новый пароль хэшируется методом Hash::make.
        - После чего экземпляр модели User функцией save() сохраняется в БД.
        - В урезанном варианте это выглядит так (см. ниже).
        - Полную default-версию можно посмотреть в созданном artisan-командой
          reminder-контроллере.

          public function postReset() {

            $response = Password::reset($credentials, function($user, $password) {

              $user->password = Hash::make($password);
              $user->save();

            });
          }

        - Если пароль был успешно переустановлен, пользователь будет перенаправлен
          в корень нашего приложения.
        - Если пароль переустановить не удалось, пользователь будет перенаправлен
          обратно на 'getRemind', а сообщение об ошибке 'error' будет записано в
          сессию.

  > Шифрование

    > Введение
      - Laravel содержит средства для мощного AES-256 шифрования из дополнения
        mcrypt PHP.
      - Чтобы всё работало нормально, в настройках надо задать ключ.
      - Ключ представляет из себя строку из 32-х случайных символов.
      - Задать ключ можно в параметре 'key' в конфиге 'app/config/app.php'.

    > Практика

      # Зашифровать строку алгоритмом AES-256

          $encrypted = Crypt::encrypt('secret');

      # Расшифровать зашифрованную строку

          $decrypted = Crypt::decrypt($encrypted);


17. Кэш

  --------------------------------------
  Подоглавление:

    - Настройка
    - Что такое memcached?
    - Практика: API Laravel для работы с кэшем
    - Операции increment/decrement
    - Использование меток (tags) в кэше

  --------------------------------------

  > Настройка

    > Введение
      - Laravel обеспечивает унифицированный API для нескольких систем кэширования.
      - Доступные варианты: "file", "database", "apc", "memcached", "redis", "array"
      - Конфиг для настройки кэша находится в файле 'app/config/cache.php'.
      - По умолчанию параметру 'driver' установлено значение 'file'.
      - При этом сериализованные объекты сохраняются в файлах в папке 'app/storage/cache'
      - Для крупных приложений рекомендуется не использовать 'file'-кэширование.
      - А вместо этого использовать системы кэширования в оперативке memcached/APC.

    > Параметры в конфиге

      # 'driver'
        - Какая система кэширования будет использоваться по умолчанию.
        - Какая бы ни была выбрана, API для работы используется один и тот же.
        - Доступные варианты: "file", "database", "apc", "memcached", "redis", "array"
        - Значение, которое стаит "из коробки": 'file'.

      # 'path'
        - Используется, если выбран 'driver' == 'file'.
        - Путь к папке, в которой будут храниться файлы с кэшем.
        - По умолчанию: 'app/storage/cache'

      # 'connection'
        - Используется, если выбран 'driver' == 'database'.
        - Имя соединения, указывающее на БД, которая будет использоваться.
        - Если установлен null, то будет использовано default-соединение.

      # 'table'
        - Используется, если выбран 'driver' == 'database'.
        - Имя таблицы, которая будет использоваться для хранения кэша.
        - По умолчанию устновлено значение 'cache'.
        - Вот шаблон для создания таблицы в БД для хранения кэша:

            Schema::create('cache', function($table)
            {
                $table->string('key')->unique();
                $table->text('value');
                $table->integer('expiration');
            });

      # 'memcached'
        - Используется, если выбран 'driver' == 'memcached'.
        - Массив массивов настроек для серверов memcached.
        - Каждый из элементов-массивов представляет настройки для 1-го из них.
        - Каждый массив с настройками должен содержать 3 настройки.
        - Это: "host", "port", и "weight".

      # 'prefix'
        - Используется при хранении кэша в оперативке (memcached, APC).
        - Хранить кэш в оперативке могут и другие приложения одновременно.
        - По этой причине могут возникать коллизии ключей сохраняемых значений.
        - Чтобы этого избежать, требуется придать уникальность ключам приложения.
        - Для этого им всем можно добавить некий уникальный префикс.
        - В этом параметре как раз этот префикс и можно указать.
        - "Из коробки" установлен префикс 'laravel'.

  > Что такое memcached?
    - Система кэширования, которая хранит данные в оперативной памяти.
    - Хранит данные в парах ключ/значение.
    - Её использование ускоряет работу, снижает нагрузку на БД и жёсткие диски.
    - Memcached устанавливается как отдельный сервис.
    - К нему можно получить доступ по сети.
    - Memcached не привязан к отдельным процессам PHP.
    - Благодаря этому кэш расшарен между процессами, что очень удобно.
    - Memcached может кэшировать любые типы данных, в т.ч. объекты.
    - Потому любые типы при помещении в кэш сериализуются в строку.

  > Практика: API Laravel для работы с кэшем

    # Сохранение в кэше на $minutes минут
      - Сохраним значение 'value' с ключём 'key' в кэше.
      - Укажем, что данные будут хранитсья в кэше $minutes минут.
      - *Примечание:  фактически к 'key' будет добавлен автоматом префикс,
                      указанный в конфиге cache.php.

        Cache::put('key', 'value', $minutes);

    # Сохранение в кэше до указанной даты и времени
      - Сохраним значение 'value' с ключём 'key' в кэше.
      - Укажем конкретную дату и время, до которого этот кэш будет храниться.
      - Для этого используем класс Carbon (надстройка над DateTime).
      - API класса: https://github.com/briannesbitt/Carbon

      // Получить датавременное значение: сейчас + 10 минут.
        $expiresAt = Carbon::now()->addMinutes(10);

      // Поместить данные в кэш
        Cache::put('key', 'value', $expiresAt);

    # Сохранить значение в кэше навсегда

        Cache::forever('key', 'value');

    # Поместить данные в кэш, если такого ключа не существует
      - Для этого используется метод Cache::add.
      - Если данные с таким ключём уже существуют, то метод вернёт false.
      - А если нет, и значение размещено, то метод вернёт true.

        Cache::add('key', 'value', $minutes);

    # Проверить, существует ли значение с ключём 'key' в кэше
      - Неявно к 'key' добавляется префикс из настроек.

        if (Cache::has('key'))
        {
            //
        }

    # Извлечь значение из кэша
      - Извлечь значение с ключём 'key' из кэша.
      - Неявно к 'key' добавляется префикс из настроек.

        $value = Cache::get('key');

    # Извлечь значение из кэша или вернуть указанное значение
      - Бывает, что извлечь значение из кэша не удаётся.
      - Например, оказалось, что значения с таким ключём в кэше нет.
      - Можно подстраховаться и подготовить другое значение.
      - В случае неудачи, оно и будет возвращено.

      // Извлечь из кэша или вернуть default-значение
        $value = Cache::get('key', 'default');

      // И более гибкий вариант с анонимной функцией
        $value = Cache::get('key', function() { return 'default'; });

    # Извлечь, а если неудача, то сохранить указанное
      - Метод сначала пытается извлечь из кэша значение с указанным ключём.
      - Если неудача, то он сохраняет указанное значение с этим же ключём.
      - В примере ниже попробуем извлечь из кэша значение 'users'.
      - А если не получится, то сохранить в кэш с ключём 'users' то,
        что вернёт анонимная фукнция.

      // В случае сохранения в кэш, оно произойдёт на $minutes минут
        $value = Cache::remember('users', $minutes, function()
        {
            return DB::table('users')->get();
        });

      // В случае сохранения в кэш, оно произойдёт навечно
        $value = Cache::rememberForever('users', function()
        {
            return DB::table('users')->get();
        });

    # Удалить из кэша
      - Удалим значение с ключём 'key' из кэша.

      Cache::forget('key');

  > Операции increment/decrement
    - Операции инкремента и декремента поддерживают все драйверы.
    - Кроме file и database.

    # Инкрементировать значение в кэше
      - Инкрементируем значение в кэше с ключём 'key'

      // На 1
        Cache::increment('key');

      // На величину amount
        Cache::increment('key', $amount);

    # Декрементировать значение в кэше
      - Декрементируем значение в кэше с ключём 'key'

      // На 1
        Cache::decrement('key');

      // На величину amount
        Cache::decrement('key', $amount);

  > Использование меток (tags) в кэше

    > Суть
      - Каждую пару ключ/значение можно пометить определённой меткой (tag).
      - Потом можно будет, например, извлечь разом весь кэш с заданной меткой.

    > Поддержка
      - Использование меток поддерживается всеми драйверами кэша.
      - Кроме file и database.

    > Практика
      - Метод tags можно использовать совместно с методами put, remember,
        forever и rememberForever.

      # Сохранить помеченный кэш №1
        - Сохраним в кэш значение $john с ключём 'john' на $minutes минут.
        - Одновременно помитим этот кэш метками 'people' и 'authors'.

          Cache::tags('people', 'authors')->put('John', $john, $minutes);

      # Сохранить помеченный кэш №2
        - Сохраним в кэш значение $anne с ключём 'anne' на $minutes минут.
        - Одновременно помитим этот кэш метками 'people' и 'artists'.

          Cache::tags(array('people', 'artists'))->put('Anne', $anne, $minutes);

      # Получить весь кэш с указанными метками и извлечь из него по ключу

        // Получить весь кэш с метками 'people', 'artists', и извлечь из
        // него значение по ключу 'anne':
          $anne = Cache::tags('people', 'artists')->get('Anne');

        // Получить весь кэш с метками 'people', 'authors', и извлечь из
        // него значение по ключу 'john':
          $john = Cache::tags(array('people', 'authors'))->get('John');

      # Удалить весь кэш с указаными метками
        - Удалить весь кэша с меткой 'authors'
        - При этом 'john' будет удалён, а 'anny' нет.

          Cache::tags('authors')->flush();


18. События

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Где размещать код, назначающий обработчики?
    - Практика

  --------------------------------------

  > Ссылки

      - Отличная статья про события в Laravel 4
          http://culttt.com/2014/03/10/using-events-laravel-4/

  > Введение
    - В Laravel есть класс Event для работы с событиями.
    - Он позволяет назначать функции-перехватчики событий приложения.

  > Где размещать код, назначающий обработчики?

    > Общее
      - Вопрос в том, где размещать код, назначающий событиям функции-обработчики?
      - В принципе, его можно разместить где угодно.
      - Разумнее всего в том коде, который выполняется в начале приложения.
      - Есть несколько основных вариантов, приведённых ниже.

    > Вариант №1: 'app/start/global.php'
      - Этот файл выполняется каждый раз при запросе к приложению.
      - Как раз пере выполнением 'app/routes.php'. Независимо от среды.
      - Так что здесь вполне можно разместить код, назначающий обработчики.

    > Вариант №2: в отдельном файле
      - Можно создать, например, файл 'app/events.php'.
      - В этот файл размещать код, назначающий обработчики.
      - А сам файл подключить с помощью include/require к 'app/start/global.php'.
      - Это позволит не загромождать global.php.

    > Вариант №3: в отдельном 'service provider'
      - Создать отдельный файл вроде 'EventsServiceProvider.php'.
      - Он должен быть в формате 'service provider'.
      - Поместить его можно где угодно.
      - Не забыть добавить путь к нему в массив 'providers' конфига 'app/config/app.php'.

  > Практика

    # Назначить функцию-обработчик
      - Назначим в приложении функцию-обработчик события 'user.login'

        Event::listen('user.login', function($user)
        {
            $user->last_login = new DateTime;

            $user->save();
        });

    # Возбудить указанное событие
      - Возбудим событие 'user.login'
      - Передадим обработчику массив параметров.

        $event = Event::fire('user.login', array($user));

    # Назначить функцию-обработчик с указанием приоритета
      - При назначении каждой функции-обработчика можно указать приоритет.
      - Для одного события может быть назначено много функций-обработчиков.
      - Все они будут выполнены в ответ на возбуждение этого собыитя.
      - Но в каком порядке? Вот это как раз и определяется приоритетом.
      - Чем выше приоритет, тем 'первее' будет выполнен обработчик.

      // С приоритетом 10
        Event::listen('user.login', 'LoginHandler', 10);

      // С приоритетом 5
        Event::listen('user.login', 'OtherHandler', 5);

    # Отменить дальнеёшее распространение события
      - Иногда может потребоваться отменить дальнейшее распространение события.
      - Например, для события назначены 3 функции-обработчика.
      - Допустим, нам надо, чтобы выполнился только 1-й, о 2 прочих - нет.
      - Тогда надо в 1-й функции-обработчике вернуть false.

          Event::listen('user.login', function($event)
          {
              // Handle the event...

              return false;
          });

    # Использование плейсхолдеров при назначении обработчика
      - В имени события можно использовать звёздочку: '*'.
      - Она обозначает любое сочетание любых символов в любом кол-ве.

      // Этот обработчик будет назначен всем событиям, начинающимся с 'foo.'
        Event::listen('foo.*', function($param)
        {
            // Handle the event...
        });

      // А вот как внутри обработчика можно определить, какое конкретно
      // событие из тек, для которых он назначен, привело к текущему
      // исполнению кода обработчика
        Event::listen('foo.*', function($param)
        {
            if (Event::firing() == 'foo.bar')
            {
                //
            }
        });

    # Использование класса из IoC в качестве обработчика
      - Часто в качестве функции-обработчика указывают анонимную функцию.
      - Можно указать и просто имя любой функции, или метода.
      - А можно указать имя класса, который присутствует в IoC контейнере.
      - Вот как может выглядеть определение такого класса:

          class LoginHandler {

              public function handle($data)
              {
                  //
              }

          }

      - Вот как выглядит назначение этого класса обработчиком

          Event::listen('user.login', 'LoginHandler');

      - При этом по умолчанию в качестве обработчика будет вызван метод
        'handle' этого класса.
      - Но можно и при назначении вручную указать метод, который будет вызван.
        Укажем, например, имя 'onLogin':

          Event::listen('user.login', 'LoginHandler@onLogin');

    # Отсроченное возбуждение цепочки событий
      - Механизм прост: создаём очередь из событий и нажимаем на "спуск".
      - После чего все события по очереди возбуждаются.
      - Поставить событие в очередь, передав ему массив аргументов, можно так:

          Event::queue('foo', array($user));

      - Зарегистрировать "спусковой ключёк" можно так:

          Event::flusher('foo', function($user)
          {
              //
          });

      - "Нажать на спуск" можно так:

          Event::flush('foo');

    # Класс-назначатель событий
      - Можно назначение ряда событий оформить как класс.
      - Для этого во-первых надо создать новый класс.
      - В нём все методы, кроме subscribe - это функции-обработчики.
      - Ещё в нём есть метод subscribe.
      - В этом методе надо назначить требуемым событиями эти самые обработчики.
      - Вот как может выглядеть определение такого класса (пример):

            class UserEventHandler {

                /**
                 * Handle user login events.
                 */
                public function onUserLogin($event)
                {
                    //
                }

                /**
                 * Handle user logout events.
                 */
                public function onUserLogout($event)
                {
                    //
                }

                /**
                 * Register the listeners for the subscriber.
                 *
                 * @param  Illuminate\Events\Dispatcher  $events
                 * @return array
                 */
                public function subscribe($events)
                {
                    $events->listen('user.login', 'UserEventHandler@onUserLogin');

                    $events->listen('user.logout', 'UserEventHandler@onUserLogout');
                }

            }

      - Чтобы события из subscribe назначились, надо зарегистрировать
        класс-назначатель. Сделать это можно так:

          $subscriber = new UserEventHandler;
          Event::subscribe($subscriber);


19. IoC контейнеры

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Концепции 'Inversion Of Control' и 'Dependency Injection'
    - Где размещать код для настройки IoC-контейнера?
    - Практика: основы работы с IoC-контейнером Laravel
    - Практика: использование IoC-контейнера в контроллерах
    - Практика: использование при назначении обраб-ков фильтров/композеров/событий
    - События IoC-контейнера


  --------------------------------------

  > Ссылки

    - Inversion of control (wiki en):
        http://en.wikipedia.org/wiki/Inversion_of_control

    - Пара статей о том, что такое IoC:
        http://www.apofig.com/2010/08/dependency-injection-inversion-of.html#cat
        http://vladimirsblog.com/laravel-inversion-of-control/

    - Dependency Injection (wiki en):
        http://en.wikipedia.org/wiki/Dependency_injection

    - Пара статей о том, что такое DI:
        http://www.apofig.com/2011/07/dependency-injection-inversion-of.html
        http://vladimirsblog.com/laravel-dependency-injection-for-beginners/

    - Хороший пример работы с IoC в Laravel:
        http://vladimirsblog.com/laravel-dependency-injection-in-practic/

  > Введение
    - Здесь речь пойдёт о встроенной в Laravel реализации шаблона IoC.
    - Будут рассмотрены концепции 'Inversion Of Control' и 'Dependency Injection'.
    - Будер рассмотрен функционал Laravel для работы со встроенной реализацией IoC.

  > Концепции 'Inversion Of Control' и 'Dependency Injection'
    - Допустим, у нас имеется некий пользовательский код (ПК).
    - Допустим, ПК использует в своей работе какой-то класс (Класс).
    - ПК пользуется свойствами и методами этогоа Класса и его экземпляров.
    - Можно сказать, что ПК связан с Классом, зависит от него.
      - При изменении Класса придётся изменять и ПК. Это односторонняя связь.
      - При изменении ПК придётся менять и Класс. Это уже двусторонняя связь.
    - Наличие такой связи между ПК и классом является плохой практикой.
      - Невозможно провести отдельный юнит-тест каждого задействованного класса.
      - Трудно заменить одну реализацию класса на другой, придётся менять код ПК.
    - Использование концепции IoC позволит избавиться от этой связи
    - Согласно ей, ПК должен зависеть не от класса, а от интерфейса.
    - Во время выполнения ПК при обращении к интерфейсу подставляется его реализация.
    - Это происходит автоматичеки, а подстановку производит IoC-контейнер.
    - Сам процесс подстановки назывют 'Dependency Injection'.
    - Интерфейс заставляет все реализации реализовывать один фиксированный API.
    - А ПК использует этот API внутри себя для работы с этой зависимостью.
    - Поэтому одну реализацию можно спокойно изменять на другую.
    - А ПК при этом менять не придётся, ведь он использует всё тот же API.

                         --------------------------------
                         |Интерфейс, от которого зависит|
------------------       |пользовательский код          |
|Пользовательский|       |------------------------------|
|код.            | ----> |По совместительству - слот, в |
------------------       |который IoC-контейнер         | <-----|
                         |подставит одну из реализаций  |       |
                         |интерфейса во время выполнения|       |
                         |пользовательского кода        |       |
                         --------------------------------       |
                                                                |
                                                                |
                                                     -----------|
     IoC-контейнер подставит                         |
     в слот одну из этих                             |
     реализаций класса-зависимости.                  |
     Кукую именно? Зависит от того,                  |
     как разработчик настроил          --------------|------------------------
     IoC-контейнер                     |                  |                  |
                                       |                  |                  |
                                       |                  |                  |
                            ------------------   ------------------   ------------------
                            |Класс-реализация|   |Класс-реализация|   |Класс-реализация|
                            |интерфейса. v1  |   |интерфейса. v2  |   |интерфейса. v3  |
                            ------------------   ------------------   ------------------

  > Где размещать код для настройки IoC-контейнера?

    > Общее
      - Вопрос в том, где размещать код, настраивающий IoC-контейнер?
      - В принципе, его можно разместить где угодно.
      - Разумнее всего в том коде, который выполняется в начале приложения.
      - Есть несколько основных вариантов, приведённых ниже.

    > Вариант №1: 'app/start/global.php'
      - Этот файл выполняется каждый раз при запросе к приложению.
      - Как раз пере выполнением 'app/routes.php'. Независимо от среды.
      - Так что здесь вполне можно разместить код, назначающий обработчики.

    > Вариант №2: в отдельном файле
      - Можно создать, например, файл 'app/ioc.php'.
      - В этот файл размещать код, назначающий обработчики.
      - А сам файл подключить с помощью include/require к 'app/start/global.php'.
      - Это позволит не загромождать global.php.

    > Вариант №3: в отдельном 'service provider'
      - Создать отдельный файл вроде 'IocServiceProvider.php'.
      - Он должен быть в формате 'service provider' (см. IoC контейнеры).
      - Поместить его можно где угодно.
      - Не забыть добавить путь к нему в массив 'providers' конфига 'app/config/app.php'.
      - В файле в методе boot и надо размещать код, назначающий обработчики.

  > Практика: основы работы с IoC-контейнером Laravel

    # Добавить тип в IoC-контейнер (анон.функция)
      - Добавить тип 'foo' в IoC-контейнер.
      - При запросе будет возвращено то, что возвращает аноним.функция.
      - А она возвращает экземпляр класса FooBar.

          App::bind('foo', function($app)
          {
              return new FooBar;
          });

    # Обратиться к типу из IoC-контейнера
      - В примере выше мы добавили тип 'foo' в IoC-контейнер.
      - Теперь в польз.коде мы можем его использовать по этому имени.
      - Тогда будет выполнена анон.функция, определённая при добавлении типа.
      - Обратимся к 'foo' и получим экземпляр 'FooBar':

          $value = App::make('foo');

    # Добавим тип в IoC-контейнер (готовый объект)
      - Добавить тип 'foo' в IoC-контейнер.
      - При запросе будет возвращена ссылка на объект, указанная в определении.

          $foo = new Foo;
          App::instance('foo', $foo);

    # Добавить 'расшаренный' тип в IoC-контейнер
      - При каждом запросе будет возвращаться ссылка на один и тот же объект.
      - В отличие от 'не расшаренного' типа, где каждый раз возвр.ссылка на нов.объект.
      - Добавить с помощью анонимной функции:

          App::singleton('foo', function()
          {
              return new FooBar;
          });

      - Добавить с помощью готового объекта:

          $foo = new Foo;
          App::singleton('foo', $foo);

    # Добавить интерфейс в IoC-контейнер (готовый класс)
      - Добавитьи интерфейс 'UserInterface' в IoC-контейнер.
      - При запросе будет возвращена ссылка на класс 'User'.

          App::bind('UserInterface', 'User');

    # Автоматическое извлечение из IoC-контейнера в конструкторе класса
      - Добавленный в IoC-конструктор тип или интерфейс можно передать
        в качестве аргумента конструктору любого класса.
      - В этом случае произойдёт автомат.извлечение из IoC-контейнера.
      - В этом примере класс User будет доступен в конструкторе через
        переменную $users:

          class UserController extends BaseController {

              public function __construct(UserInterface $users) {
                  $this->users = $users;
              }

          }

      - А в этом примере объект типа FooBar будет доступен в конструкторе
        через переменную $foo:

          class UserController extends BaseController {

              public function __construct(Foo $foo) {
                  $this->FooBar = $foo;
              }

          }

  > Практика: использование IoC-контейнера в контроллерах
    - IoC-контейнер очень удобно использовать в контроллерах.
    - А именно, его можно использовать в конструкторе контроллера.
    - Это позволит добавить в этот класс-контроллер все его зависимости.
    - Допустим, мы добавили тип в IoC-контейнер:

        App::bind('orders', function($app)
        {
            return new MegaOrderStorage;
        });

    - И у нас есть контроллер, который засисит от этого типа.
    - Тогда подключить эту зависимость к контроллеру можно так:

        class SomeController extends BaseController {

            public function __construct(Orders $orders) {
                $this->orders = $orders;
            }

            public function getIndex() {
                $all = $this->orders->all();

                return View::make('orders', compact('all'));
            }

        }

  > Практика: использование при назначении обраб-ков фильтров/композеров/событий
    - IoC-контейнер может использоваться и при назначении различных обработчиков.
    - Обработчиков событий, фильтров, композеров.
    - Обычно ими служат анонимные функции или ссылки на готовые методы или функции.
    - Но можно использовать и IoC-контейнер.
    - При запросе типа может создаваться экземпляр указанного в IoC класса.
    - И выполняться его конструктор, т.е. тоже самое, что какая-нибудь функция.
    - Плюс в конструктор можно подключить различные зависимости как описано выше.
    - И также использовать подготовленные св-ва и методы класса.
    - Но такой подход стоит использовать в "тяжелых" случаях.
    - Вот примеры использования IoC-контейнера при назначении обработчиков:

        Route::filter('foo', 'FooFilter');
        View::composer('foo', 'FooComposer');
        Event::listen('foo', 'FooHandler');

  > События IoC-контейнера
    - IoC-контейнер возбуждает событие при каждом извлечении из него.
    - Вот как можно назначить функцию-обработчик для всех извлечений:

        App::resolvingAny(function($object)
        {
            //
        });

    - А вот как для извлечения по конкретному имени:

        App::resolving('foo', function($foo)
        {
            //
        });


20. Service providers

  --------------------------------------
  Подоглавление:

    - Введение
    - Как это работает?
    - Процесс создания нового service provider

  --------------------------------------

  > Введение
    - Service Providers (SP) - один из механизмов Laravel.
    - Он позволяет выполнить настройку приложения перед его запуском.
    - Например, назначть обработчики событий, настроить IoC-контейнер и т.д.

  > Как это работает?
    - Ну допустим наше приложение состоит из нескольких компонентов.
    - Для каждого компонента нужно провести настройку перед стартом приложения.
    - Удобно ведь настроечный код для каждого из них поместить в отдельный файл?
    - Тогда получится, что все настройки для каждого из компонентов в 1-м месте.
    - Концепция SP в Laravel позволяет всё именно так и организовать.
    - Каждый такой 'настроечный' файл должен быть выполнен в определённом формате.
    - Он должен содержать класс, наследующий от класса ServiceProvider.
    - В классе надо определить метод 'public function register()'
    - Внутри этого метода и разместить весь настроечный код.
    - Доступ к объекту-приложению из этого можно получить так:

        $this->app

    - Вот пример содержимого настроечного файла:

        use Illuminate\Support\ServiceProvider;

        class FooServiceProvider extends ServiceProvider {

            public function register() {
                $this->app->bind('foo', function()
                {
                    return new Foo;
                });
            }

        }

    - Когда настроечный файл будет готов, его надо подключить к приложению.
    - Сделать это можно 2-мя способами: в конфиге и методом App::register.
    - В конфиге: добавить путь к настроечному файлу в массив 'providers'
      в файле-конфиге приложения 'app/config/app.php'.
    - Методом App::register: с помощью этого метода можно зарегистрировать
      настроечный файл в приложении прямо во время его выполнения.

        App::register('FooServiceProvider');

  > Процесс создания нового service provider
    - Он подробно описан в разделе '21. Фасады' в подглаве
      'Пошаговая инструкция: как подключить фасад'.


21. Фасады

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Пошаговая инструкция: как подключить фасад

  --------------------------------------

  > Ссылки

    - Здесь описан процесс создания фасадов (stackoverflow):
        http://stackoverflow.com/questions/16957790/how-do-i-create-a-facade-class-with-laravel

  > Введение
    - Обсуждаемый здесь механизм Laravel называется 'Фасады'.
    - Он обеспечивает синтаксический сахар при работе с IoC-контейнером.
    - К примеру, лежит в IoC-контейнере тип 'foo', получить его можно так:

        $foo = $app->make('foo');           // получить объект
        $bar = $app->make('foo')->get(1);   // вызвать метод get

    - А подключив 'фасад' сделать это можно так:

        $foo = Foo;
        $bar = Foo::get(1);

  > Пошаговая инструкция: как подключить фасад

    1.  Создаём модель
      - Создать отдельный .php файл в папке 'app/models'.
      - Например, пусть это будет файл 'myClass.php'.
      - Пример того, как он может выглядеть:

        <php
        namespace MyNameSpace;
        use Eloquent;

        class MyClass extends Eloquent {

          public function method() {
            //...
          }

        }

    2.  Создаём папку 'serviceproviders'
      - В этой папке будем хранить .php файлы 'service providers' приложения.
      - Если такая папка уже создана и настроена, то можно пропустить этот шаг.

      2.1.  Созадть папку
        - Создать папку 'app/serviceproviders'.

      2.2.  Добавить путь к ней в composer
        - Внести изменения в файл composer.json в корне приложения.
        - Добавить в параметр classmap в autoload следующее:

          ...
            "autoload": {
                "classmap": [
                    ...
                    "app/serviceproviders"
                ]
            },
          ...

      2.3.  Обновить файлы autoload композера
        - Теперь надо обновить все autoload-файлы композера.
        - Для этого из корня проекта выполнить в консоли команду:

          composer dump-autoload

    3.  Создаём новый service provider
      - Создадим файл 'serviceproviders/MyServiceProvider.php'.
      - Его внутренности должны соответствовать шаблону для service providers.
      - В методе register добавляем в IoC-контейнеро новую запись.
      - Она связывает псевдоним 'MyClassAlias' с классом MyNamespace\MyClass.
      - Пример того, как может выглядеть содержимое этого файла:

        <?php
        namespace MyNameSpace;
        use Illuminate\Support\ServiceProvider;

        class MyServiceProvider extends ServiceProvider {

          public function register() {

            $this->app->bind('MyClassAlias', function() {
              return new MyNamespace\MyClass;
            });

          }
        }

    4.  Добавить созданный service provider в массив providers
      - Свежесозданный service provider теперь надо зарегистрировать.
      - Сделать это можно в главном конфиге приложения 'app/config/app.php'.
      - В нём в массив providers добавляем данные по новому service provider:

        'MyNameSpace\MyServiceProvider'

    5.  Создаём папку 'facades'
      - В этой папке будем хранить .php файлы-фасады приложения.
      - Если такая папка уже создана и настроена, то можно пропустить этот шаг.

      5.1.  Созадть папку
        - Создать папку 'app/facades'.

      5.2.  Добавить путь к ней в composer
        - Внести изменения в файл composer.json в корне приложения.
        - Добавить в параметр classmap в autoload следующее:

          ...
            "autoload": {
                "classmap": [
                    ...
                    "app/facades"
                ]
            },
          ...

      5.3.  Обновить файлы autoload композера
        - Теперь надо обновить все autoload-файлы композера.
        - Для этого из корня проекта выполнить в консоли команду:

          composer dump-autoload

    6.  Создаём новый фасад
      - Создадим файл 'facades/MyFacade.php'.
      - В нём должно быть определение класса-модели из п.2, наследующее
        от класса Facades.
      - Внутри должен быть только один метод getFacadeAccessor().
      - Этот метод должен возвращать строку с IoC-псевдонимом класса-модели из п.2.
      - Вот как может выглядеть внутренность файла-фасада:

        <?php
        namespace MyNameSpace;
        use Illuminate\Support\Facades\Facade;

        class MyClass extends Facade {

          protected static function getFacadeAccessor() {
            return 'MyClassAlias';
          }

        }

    7.  Настраиваем псевдоним для фасада (если надо)
      - Это актуально, когда фасад определён в своём пр.имён.
      - Настройку можно произвести в главном конфиге приложения 'app/config/app.php'.
      - В массив aliases добавляем новую строку:

          'MyClassAlias' => 'MyNameSpace\MyFacade.php'


22. Вспомогательные функции общего назначения

  --------------------------------------
  Подоглавление:

    - Введение
    - Массивы
    - Пути
    - Строки
    - URL
    - Разные

  --------------------------------------

  > Введение
    - Вместе с Laravel поставляется набор вспомогательных функций.
    - Это функции, дополняющие стандартный набор PHP по ряду направлений.
    - Направления: массивы, пути, строки, URL и прочие.
    - В этом пункте будут перечислены и описаны все эти функции.


  > Массивы
  ==============

    > Что такое dot-нотация?
      - Это нотация для ключей массивов.
      - Её используют некоторые из нижепредставленных функций.
      - Она используется при работе с многомерными массивами.
      - Допустим, есть у нас вот такой массив:

          $arr = array('foo' => array('bar' => 'ivan'));

      - С использованием dot-нотации ключ 'bar' можно обозначить так:

          foo.bar

      - Благодаря такому приёму любой многомерный массив можно представить
        в виде одномерного с dot-нотацией.


    *****************************************
                    Список
    *****************************************

    [Добавление эл-та]
      # array_add     | вставить ключ/знач., если такого ключа ещё нет
      # array_set     | вставить ключ/знач, используется dot-нотация

    [Удаление эл-та]
      # array_except  | удалить эл-т с указанным ключём
      # array_forget  | удалить эл-т с указанным ключём в dot-нотации

    [Извлечение эл-та]
      # array_get     | извлечь значение по ключу в dot-нотации
      # array_pull    | извлечь значение по ключу, и удалить его из массива
      # array_only    | извлечь массив указанных пар ключ/значение
                      | - Принимает массив ключей, пары с этими ключами и извлекает.
      # array_pluck   | извлечь массив значений по ключу
                        - Принимает 1 строку с ключём
                        - Служит для работы с массивом массивов.
                        - Извлекает из вложенных массивов (1 уровня) все значения с указанным ключём
      # array_fetch   | извлечь массив значений по ключу в dot-нотации
                        - Тоже самое, что array_pluck
                        - Но только ключ должен быть в dot-нотации
      # array_flatten | извлечь массив значений
                        - Извлекает все значения со всех уровней многоур.массива
      # array_divide  | извлечь ключи и значения массива
                        - Возвращает 2 массива: один с ключами, другой со значениями
                        - Для приёма этих массивов использовать конструкцию list($a,$b)
      # head          | извлечь первый элемент массива
      # last          | извлечь последний элемент массива
      # array_dot     | сделать из многоур.массива одноуровневый, используя dot-нотацию, и вернуть результат

    [Работа через анонимную функцию]
      # array_first   | извлечь 1-й эл-т, который прошёл true-тест
                        - пропускает все эл-ты по очереди через анон.функцию
                        - анон.функция должна возвращать bool-условие
      # array_last    |извлечь последний эл-т, который прошёл true-тест
                        - пропускает все эл-ты по очереди через анон.функцию
                        - анон.функция должна возвращать bool-условие
      # array_sort    | сортировка массива с помощью анонимной функции
      # array_where   | фильтрация массива с помощью анонимной функции



    *****************************************
                    Примеры
    *****************************************

    [Добавление эл-та]
      # array_add     | вставить ключ/знач., если такого ключа ещё нет

        $array = array('foo' => 'bar');
        $array = array_add($array, 'key', 'value');

      # array_set     | вставить ключ/знач, используется dot-нотация

        $array = array('names' => array('programmer' => 'Joe'));
        array_set($array, 'names.editor', 'Taylor');

    [Удаление эл-та]
      # array_except  | удалить эл-т с указанным ключём

        $array = array_except($array, array('keys', 'to', 'remove'));

      # array_forget  | удалить эл-т с указанным ключём в dot-нотации

        $array = array('names' => array('joe' => array('programmer')));
        $array = array_forget($array, 'names.joe');

    [Извлечение эл-та]
      # array_get     | извлечь значение по ключу в dot-нотации
        - Аналогичная функция есть и для объектов: object_get.

          $array = array('names' => array('joe' => array('programmer')));
          $value = array_get($array, 'names.joe');

      # array_pull    | извлечь значение по ключу, и удалить его из массива

          $array = array('name' => 'Taylor', 'age' => 27);
          $name = array_pull($array, 'name');

      # array_only    | извлечь массив указанных пар ключ/значение
        - Принимает массив ключей, пары с этими ключами и извлекает.

          $array = array('name' => 'Joe', 'age' => 27, 'votes' => 1);
          $array = array_only($array, array('name', 'votes'));        // ['name' => 'Joe', 'votes' => 1]

      # array_pluck   | извлечь массив значений по ключу
        - Принимает 1 строку с ключём
        - Служит для работы с массивом массивов.
        - Извлекает из вложенных массивов (1 уровня) все значения с указанным ключём

          $array = array(array('name' => 'Taylor'), array('name' => 'Dayle'));
          $array = array_pluck($array, 'name');               // array('Taylor', 'Dayle');

      # array_fetch   | извлечь массив значений по ключу в dot-нотации
        - Тоже самое, что array_pluck
        - Но только ключ должен быть в dot-нотации

          $array = array(
              array('developer' => array('name' => 'Taylor')),
              array('developer' => array('name' => 'Dayle')),
          );
          $array = array_fetch($array, 'developer.name');     // array('Taylor', 'Dayle');

      # array_flatten | извлечь массив значений
        - Извлекает все значения со всех уровней многоур.массива

          $array = array('name' => 'Joe', 'languages' => array('PHP', 'Ruby'));
          $array = array_flatten($array);                     // array('Joe', 'PHP', 'Ruby');

      # array_divide  | извлечь ключи и значения массива
        - Возвращает 2 массива: один с ключами, другой со значениями
        - Для приёма этих массивов использовать конструкцию list($a,$b)

          $array = array('foo' => 'bar');
          list($keys, $values) = array_divide($array);

      # head          | извлечь первый элемент массива

          $first = head($this->returnsArray('foo'));

      # last          | извлечь последний элемент массива

          $last = last($this->returnsArray('foo'));

      # array_dot     | сделать из многоур.массива одноуровневый, используя dot-нотацию, и вернуть результат

          $array = array('foo' => array('bar' => 'baz'));
          $array = array_dot($array);                         // array('foo.bar' => 'baz');

    [Работа через анонимную функцию]
      # array_first   | извлечь 1-й эл-т, который прошёл true-тест
        - пропускает все эл-ты по очереди через анон.функцию
        - анон.функция должна возвращать bool-условие

          $array = array(100, 200, 300);
          $value = array_first($array, function($key, $value)
          {
              return $value >= 150;
          });                                 // 200

      # array_last    |извлечь последний эл-т, который прошёл true-тест
        - пропускает все эл-ты по очереди через анон.функцию
        - анон.функция должна возвращать bool-условие

          $array = array(350, 400, 500, 300, 200, 100);
          $value = array_last($array, function($key, $value)
          {
              return $value > 350;
          });                                 // 500

      # array_sort    | сортировка массива с помощью анонимной функции

          $array = array(
              array('name' => 'Jill'),
              array('name' => 'Barry'),
          );

          $array = array_values(array_sort($array, function($value)
          {
              return $value['name'];
          }));

      # array_where   | фильтрация массива с помощью анонимной функции

          $array = array(100, '200', 300, '400', 500);

          $array = array_where($array, function($key, $value)
          {
              return is_string($value);
          });                                   // Array ( [1] => 200 [3] => 400 )


  > Пути
  ==============


    *****************************************
                    Список
    *****************************************

      # app_path     | получить абсолютный путь к папке 'app'
      # base_path    | получить абсолютный путь к корневой папке приложения
      # public_path  | получить абсолютный путь к папке 'public'
      # storage_path | получить абсолютный путь к папке 'app/storage'


    *****************************************
                    Примеры
    *****************************************

      # app_path     | получить абсолютный путь к папке 'app'

          $path = app_path();

      # base_path    | получить абсолютный путь к корневой папке приложения

          $path = base_path();

      # public_path  | получить абсолютный путь к папке 'public'

          $path = public_path();

      # storage_path | получить абсолютный путь к папке 'app/storage'

          $path = storage_path();

  > Строки
  ==============

    *****************************************
                    Список
    *****************************************

      # camel_case     | конвертирует строку в верблюжью нотацию (fooBar)
      # snake_case     | конвертирует строку в змеиную нотацию (foo_bar)
      # class_basename | извлекает имя класса, отбрасывая пр.имён
      # e              | запускает для строки htmlentities, с поддержкой UTF-8
      # ends_with      | проверяет, заканчивается ли строка указанной подстрокой
      # starts_with    | проверяет, начинается ли строка указанной подстрокой
      # str_contains   | проверить, содержит ли строка указанную подстроку
      # str_limit      | ограничивает кол-во букв в строке, обрезает лишнее, заканчивает указанной подстрокой
      # str_finish     | добавить в конец строки подстроку, удалить её повторы
      # str_is         | матчится ли строка паттерном, в котором можно использовать *
      # str_plural     | конвертировать строку во множеств.число (только eng)
      # str_singular   | конвертировать строку в единств.число (только eng)
      # str_random     | сгенерировать случайную строку указанной длины
      # studly_case    | конвертирует строку в studly-нотацию (FooBar)
      # trans          | перевести переданную языковую строку
      # trans_choice   | перевести переданную языковую строку с интонацией


    *****************************************
                    Примеры
    *****************************************

      # camel_case     | конвертирует строку в верблюжью нотацию (fooBar)

          $camel = camel_case('foo_bar');           // 'fooBar'

      # snake_case     | конвертирует строку в змеиную нотацию (foo_bar)

          $snake = snake_case('fooBar');            // 'foo_bar'

      # class_basename | извлекает имя класса, отбрасывая пр.имён

          $class = class_basename('Foo\Bar\Baz');   // 'Baz'

      # e              | запускает для строки htmlentities, с поддержкой UTF-8

          $entities = e('<html>foo</html>');

      # ends_with      | проверяет, заканчивается ли строка указанной подстрокой

          $value = ends_with('This is my name', 'name');      // true/false

      # starts_with    | проверяет, начинается ли строка указанной подстрокой

          $value = starts_with('This is my name', 'This');    // true/false

      # str_contains   | проверить, содержит ли строка указанную подстроку

          $value = str_contains('This is my name', 'my');     // true/false

      # str_limit      | ограничивает кол-во букв в строке, обрезает лишнее, заканчивает указанной подстрокой

          $string = str_limit('абвгдеёжзий', $limit = 5, $end = '...');  // 'абвгд...'

      # str_finish     | добавить в конец строки подстроку, удалить её повторы

          $string = str_finish('this/string', '/');   // this/string/

      # str_is         | матчится ли строка паттерном, в котором можно использовать *

          $value = str_is('foo*', 'foobar');

      # str_plural     | конвертировать строку во множеств.число (только eng)

          $plural = str_plural('car');    // 'cars'

      # str_singular   | конвертировать строку в единств.число (только eng)

          $singular = str_singular('cars');   // 'car'

      # str_random     | сгенерировать случайную строку указанной длины

          $string = str_random(10);   // 'QTcFLFKxmW'

      # studly_case    | конвертирует строку в studly-нотацию (FooBar)

          $value = studly_case('foo_bar');    // 'FooBar'

      # trans          | перевести переданную языковую строку

          $value = trans('validation.required'):

      # trans_choice   | перевести переданную языковую строку с имменениями

          $value = trans_choice('foo.bar', $count);


  > URL
  ==============

    *****************************************
                    Список
    *****************************************

      # action         | сгенерировать URL на метод контроллера
      # route          | сгенерировать URL на именованный роут
      # asset          | сгенерировать URL на указанный ресурс
      # link_to        | сгенерировать HTML-ссылку на указанный URL
      # link_to_asset  | сгенерировать HTML-ссылку на указанный ресурс
      # link_to_route  | сгенерировать HTML-ссылку на именованный роут
      # link_to_action | сгенерировать HTML-ссылку на метод контроллера
      # secure_asset   | сгенерировать HTML-ссылку на указанный ресурс используя HTTPS
      # secure_url     | сгенерировать абсолютный URL на указанный путь используя HTTPS
      # url            | сгенерировать абсолютный URL на указанный путь


    *****************************************
                    Примеры
    *****************************************

      # action         | сгенерировать URL на метод контроллера

          $url = action('HomeController@getIndex', $params);

      # route          | сгенерировать URL на именованный роут

          $url = route('routeName', $params);

      # asset          | сгенерировать URL на указанный ресурс

          $url = asset('img/photo.jpg');

      # link_to        | сгенерировать HTML-ссылку на указанный URL

          echo link_to('foo/bar', $title, $attributes = array(), $secure = null);

      # link_to_asset  | сгенерировать HTML-ссылку на указанный ресурс

          echo link_to_asset('foo/bar.zip', $title, $attributes = array(), $secure = null);

      # link_to_route  | сгенерировать HTML-ссылку на именованный роут

          echo link_to_route('route.name', $title, $parameters = array(), $attributes = array());

      # link_to_action | сгенерировать HTML-ссылку на метод контроллера

          echo link_to_action('HomeController@getIndex', $title, $parameters = array(), $attributes = array());

      # secure_asset   | сгенерировать HTML-ссылку на указанный ресурс используя HTTPS

          echo secure_asset('foo/bar.zip', $title, $attributes = array());

      # secure_url     | сгенерировать абсолютный URL на указанный путь используя HTTPS

          echo secure_url('foo/bar', $parameters = array());

      # url            | сгенерировать абсолютный URL на указанный путь

          echo url('foo/bar', $parameters = array(), $secure = null);


  > Разные
  ==============

    *****************************************
                    Список
    *****************************************

      # csrf_token | получить значение текущего CSRF токена
      # dd         | вывести dump переменной и завершить скрипт
      # value      | вернуть значение, возвращаемое аргументом-анонимной функцией
      # with       | вернуть объект указанного класса


    *****************************************
                    Примеры
    *****************************************

      # csrf_token | получить значение текущего CSRF токена

          $token = csrf_token();

      # dd         | вывести dump переменной и завершить скрипт

          dd($value);

      # value      | вернуть значение, возвращаемое аргументом-анонимной функцией

          $value = value(function() { return 'bar'; });

      # with       | вернуть объект указанного класса

          $value = with(new Foo)->doWork();


23. Почта

  --------------------------------------
  Подоглавление:

    - Введение
    - Настройка
    - Практика: основное
    - Встраивание данных и картинок в письмо
    - Очередь: отложенная отправка email
    - Функционал для тестирования отправки

  --------------------------------------

  > Введение
    - Laravel предоставляет функционал для работы с электронной почтой.
    - Он представляет собой API к известной библиотеке SwiftMailer.

  > Настройка
    - Настройку можно произвести в конфиге 'app/config/mail.php'.
    - Доступные для настройки параметры:

      # driver      | Какая технология будет использоваться для работы с почтой:
                      "smtp" (по умолчанию), "mail", "sendmail"

      # host        | Хост SMTP сервера, который будет использован приложением
                      для работы с почтой.

      # port        | SMPT порт, который будет использовать приложение для
                      доставки почты пользователям.

      # from        | Глобальный "From" адрес в виде массива с 2-мя параметрами:
                      'address' и 'name'.
                      - По умолчанию значения у них null, значет отключены.
                      - Если указать значения, то они будут использованы при отправки
                        каждого письма приложением.

      # encryption  | Протокол шифрования для отправки почты, по умолчанию "TLS"

      # username    | Имя пользователя для подключения к SMTP-серверу

      # password    | Пароль для подключения к SMTP-серверу

      # sendmail    | Если driver == 'sendmail', то надо указать путь к папке
                      с sendmain на этом сервере.

      # pretend     | - Если true, то письма на самом деле не будут отправлятсья
                        получателю, а будут записываться в логи приложения.
                        Это режим, который удобно использовать для разработки.
                      - Если false (по умолчанию), то будут.

  > Практика: основное

    # Отправить письмо
      - Mail::send($view, $data, $callback) int
        - $view - представление, которое будет телом письма.
        - $data - данные, которые будут переданы представлению.
        - $callback - анон.функция для настройки отправляемого письма
      - Переменная $message всегда передается в $view классом Mail.
      - Полный список настроек для $callback доступен по адресу:
          http://laravel.com/api/4.1/

        Mail::send('emails.welcome', $data, function($message)
        {

          // Email-адрес и имя отправителя
            $message->from('bar@example.com', 'Ivan Petrov');

          // Email-адрес и имя получателя
            $message->to('foo@example.com', 'John Smith');

          // Тема письма
            $message->subject('Welcome!');

          // Обратный адрес
            $message->returnPath('baz@example.com');

          // Приложить файл к письму
            $message->attach($pathToFile, array('as' => $display, 'mime' => $mime));

        });

    # Дополнительное текстовое тело письма
      - В примере выше в кач-ве тела письма выступает HTML-документ.
      - На всякий случай рекомеднуется посылать ещё и текстовое тело.
      - Некоторые клиенты не могут просмотреть HTML-письма.
      - К счастью, можно одновременно отправить обе версии.
      - Для этого надо указать 2 представления: HTML и текстовое.

          Mail::send(array('html.view', 'text.view'), $data, $callback);

  > Встраивание данных и картинок в письмо
    - Допустим, мы хотим сделать в письме кнопку-картинку.
    - Первый вариант, указать URL, с которого у клиента подгрузится эта картинка.
    - Второй вариант, встроить картинку в само письмо.
    - Второй лучше первого, т.к. клиент точно увидит эту картинку.
    - В обычных условиях это довольно муторная задача.
    - Но Laravel предоставляет функционал, позволяющий удобно это делать.

    # Встроить картинку в HTML-представление-тело письма
      - Переменная $message всегда передается в $view классом Mail.

        <body>
            Here is an image:

            <img src="<?php echo $message->embed($pathToFile); ?>">
        </body>

    # Встроить данные в HTML-представление-тело письма
      - Переменная $message всегда передается в $view классом Mail.

        <body>
            Here is an image from raw data:

            <img src="<?php echo $message->embedData($data, $name); ?>">
        </body>

  > Очередь: отложенная отправка email
    - Отправка email может замедлить ответ приложения клиенту.
    - Плюс может понадобиться запланировать отправку на какое-то время.
    - Поэтому Laravel позволяет делать отложенную отправку email.
    - А именно, ставить эту задачу в очередь используя компонент Queue.
    - Queue представляет собой API к сервисам-планировщикам задач.
    - В классе Mail находится API для использования Queue при работе с почтой.

    # Поставить задачу отправки письма в очередь
      - Задача будет выполнена сразу, как только сможет.
      - Для этого надо использовать метод Mail::queue.
      - Он принимает те же аргументы, что Mail::send.

        Mail::queue('emails.welcome', $data, function($message)
        {
            $message->to('foo@example.com', 'John Smith')->subject('Welcome!');
        });

    # Поставить отложенную задачу отправки письма в очередь
      - Задача будет выполнена через $sec секунд
      - Для этого надо использовать метод Mail::later.

        Mail::later($sec, 'emails.welcome', $data, function($message)
        {
            $message->to('foo@example.com', 'John Smith')->subject('Welcome!');
        });

    # Поставить задачу в определённую очередь
      - Очереди бывают разные, и у них есть имена.
      - Поэтому поставить задачу можно в определённую именованную очередь.
      - Для этого есть методы Mail::queueOn и Mail::laterOn.
      - Это полные аналоги соответствующих вышеприведённых методов.
      - Только в них можно указать ещё имя очереди для постановки.

      // Пример Mail::queueOn

        Mail::later(5, 'emails.welcome', $data, function ($message) {
          $message->to('foo@example.com', 'Джон Смит')->subject('Привет!');
        });

      // Пример Mail::laterOn

        Mail::queueOn('queue-name', 'emails.welcome', $data, function ($message) {
          $message->to('foo@example.com', 'Джон Смит')->subject('Привет!');
        });

  > Функционал для тестирования отправки
    - Допустим мы настроили отправку почты.
    - И теперь нам всё это надо протестировать.
    - Но мы не хотим отправлять реальные письма.
    - А хотим, чтобы отправленные письма записывались в лог.
    - И в логе можно было бы проверить правильность работы.
    - Для этого есть специальная опция pretend.
    - Её можно установить 'на постоянку' в true/false в конфиге 'app/config/mail.php'.
    - Или же для текущей сессии в коде, используя метод Mail::pretend().

      Mail::pretend();


24. Пагинация

  --------------------------------------
  Подоглавление:

    - Введение
    - Настройка
    - Практика
    - Конвертация в JSON

  --------------------------------------

  > Введение
    - Термин 'пагинация' означает разбиение информации на страницы.
    - В Laravel предусмотрен специальный функционал для пагинации.

  > Настройка
    - Настроить пагинацию можно в конфиге 'app/config/view.php'.
    - Единственная настройка - параметр pagination.
    - Он указывает, какое представление должно быть использовано для
      создание пагинационных ссылок.

      # pagination::slider
        - Покажет пагинационные ссылки с номерами страниц.

      # pagination::simple
        - Покажет пагинационные ссылки в виде стролочек 'вперёд' и 'назад'.

  > Практика
    - Для осуществления пагинации используется метод paginate.
    - Он обозначает MAX кол-во элементов для отображения на 1-й странице.

    # Пагинация результатов из БД
      - Пагинация в query builder команде.

      $users = DB::table('users')->paginate(15);

    # Пагинация eloquent-модели
      - 2 примера:

      $allUsers = User::paginate(15);
      $someUsers = User::where('votes', '>', 100)->paginate(15);

    # Отображение пагинированных результатов
      - Выше были получены и пагинированы результаты.
      - Теперь их можно вывести на экран в представлении.

        // Вывести данные
          <div class="container">
              <?php foreach ($users as $user): ?>
                  <?php echo $user->name; ?>
              <?php endforeach; ?>
          </div>

        // Вывести пагинационные ссылки (представление по умолчанию)
          <?php echo $users->links(); ?>

    # Альтернативное представление для пагинационных ссылок
      - Вообще представление для пагинац.ссылок задаётся в конфиге.
      - Именно оно и выводится методом links() без аргументов.
      - Но можно использовать и другое, альтернативное представление.
      - Для этого его имя надо передать как аргумент в метод.

          <?php echo $users->links('view.name'); ?>

    # Дополнительные пагинационные данные
      - Получить доп.пагинационную инфу можно этими методами:

          getCurrentPage() | номер текущей страницы
          getLastPage()    | номер последней доступной страницы
          getPerPage()     | кол-во моделей, возвращаемых на каждой странице
          getTotal()       | общее кол-во страниц
          getFrom()        | номер первого элемента пагинатора
          getTo()          | номер последнего элемента пагинатора
          count()          | кол-во элементов на текущей странице

    # Создать пагинатор вручную

        $paginator = Paginator::make($items, $totalItems, $perPage);

    # Изменение URI пагинатора
      - Этот пример будет создавать URL вроде таких:
          'http://example.com/custom/url?page=2'

        $users = User::paginate();
        $users->setBaseUrl('custom/url');

    # Добавить query string в URL пагинатора
      - Этот пример будет создавать URL вроде таких:
          'http://example.com/something?page=2&sort=votes'

        <?php echo $users->appends(array('sort' => 'votes'))->links(); ?>

    # Добавить 'hash fragment' в URL пагинатора
      - Этот пример будет создавать URL вроде таких:
          'http://example.com/something?page=2#foo'

        <?php echo $users->fragment('foo')->links(); ?>

  > Конвертация в JSON
    - Класс Paginator реализует интерфейс 'Illuminate\Support\Contracts\JsonableInterface'.
    - Поэтому он содержит метод toJson, который и можно использовать.
    - Ещё для конвертации в JSON можно вернуть объект класса Paginator из представления.
    - Итоговый JSON будет содержать данные и мета-информацию. Данные будут
      доступны в эл-те с ключём 'data', а различная мета информация в
      эл-тах с ключами: 'total', 'current_page', 'last_page', 'from', 'to'.


> 25. Queues: планировщик задач

  --------------------------------------
  Подоглавление:

    - Базовая информация
    - Настройка
    - Практика: основы
    - Практика: анонимные функции в качестве задач
    - Практика: Artisan-демон для прослушки планировщика задач
    - Практика: работа с iron
    - Практика: контроль за 'неудавшимися' задачами

  --------------------------------------

  > Базовая информация

    > Введение
      - Есть ли возможность отложенного выполнения произвольной функции?
      - Можно ли запланировать и реализовать это для множества функций?
      - Да, это может реализовать функционал, для обозначения которого
        можно использовать общиий термин "планировщик задач".

    > Примеры, для чего это может понадобиться?
      - Ускорить отклик для клиента, отложив выполнение ресурсоёмкой задачи.
      - Для организации планирования задач для сотрудников в системе управления.

    > API для работы с планировщиками задач в Laravel
      - У Laravel нет собственного планировщика задач.
      - Вместо этого у него есть API к 4-зм сторонним планировщикам задач.
      - Какой бы из них вы не выбрали, использовать надо один и тот же API.
      - То есть, этот механизм сделан в соответствии с принципами IoC.

    > Драйвер 'sync'
      - В конфиге 'queue.php' по умолчанию установлен драйвер 'sync'.
      - На самом деле это не является драйвером какого-либо ПЗ.
      - 'sync' означает, что Laravel будет запускать задачи синхронно.
      - То есть, как только приходит задача, Laravel её запускает.
      - 'sync' является чисто отладочным режимом, поскольку на практике
        особой пользы от него нет.

    > 2 доступных варианта извлечения задач из планировщика задач (ПЗ)
      - Добавление задач в ПЗ для обоих вариантов происходит одинаково.
      - Как это делается, подробно описано ниже в 'Практика: основы'.
      - А вот степень автоматизации извлечения задач из ПЗ может быть разная.

      > Вариант 1: опрос ПЗ Artisan-демоном
        - Применяется для драйверов: 'beanstalkd', 'sqs'.
        - Для опроса ПЗ запускается спициальный Artisan-демон (см.ниже).
        - Когда приходит время, от извлекает и запускает соотв.задачу.

      > Вариант 2: ПЗ автоматом присылает задачи
        - Применяется для драйвера: 'iron'.
        - Является более продвинутым вариантом, по ставнению с 1-ым.
        - Когда приходит время, ПЗ отправляет на указанные адреса HTTP-запрос.
        - В запросе содержится сериализованная функция для выполнения.
        - Для получения этого запроса в Laravel настраивается специальный роут.
        - Запрос принимается, функция выполняется.
        - Iron.io бесплатно даёт отправлять 10млн сообщений с 1-го аккаунта.


  > Настройка
    - Функционал Laravel по работе с планировщиками задач можно настроить
      в конфиге 'app/config/queue.php'.
    - Описание опций для настройки:

      # 'default'
        - Драйвер по умолчанию для сервиса ПЗ.
        - Доступные варианты:

          # Synchronous
            - Установлен по умолчаннию.
            - Значение: 'sync'.
            - Это драйвер для локального использования.

          # Beanstalkd
            - Оф.сайт: http://kr.github.io/beanstalkd/
            - Значение: 'beanstalkd'.
            - Зависимость: 'pda/pheanstalk'.

          # IronMQ
            - Оф.сайт: http://www.iron.io/
            - Значение: 'iron'.
            - Зависимость: 'iron-io/iron_mq'.

          # Amazon SQS
            - Оф.сайт: http://aws.amazon.com/sqs/
            - Значение: 'sqs'.
            - Зависимость: 'aws/aws-sdk-php'.

          # Redis
            - ?

      # 'connections'
        - Массив массивов настроек соединения с различными ПЗ.

      # 'failed'
        - Настройках сохранения информации о неудавшихся задачах.
        - Можно указать имя базы данных и таблицы.


  > Практика: основы
    - Термином 'задача' обозначают метод класса.
    - Отложенный запуск задачи означает отложенное выполнение этого метода.

    # Добавить задачу в планировщик задач
      - Добавить в очередь по умолчанию, опустив её имя.
      - Использовать имя метода-задачи по умолчанию - 'fire' - опустив его имя.
      - Указать имя класса, в котором лежит задача: 'SendEmail'.
      - Передать в задачу массив аргументов.

        Queue::push('SendEmail', array('message' => $message));

    # Добавить задачу в планировщик задач
      - Указать имя очереди: 'email'.
      - Указать имя метода-задачи: 'send'
      - Указать имя класса, в котором лежит задача: 'SendEmail'.
      - Передать в задачу массив аргументов.

        Queue::push('SendEmail@send', array('message' => $message), 'emails');

    # Добавить одним махом несколько задач в планировщик задач
      - Указать имя очереди: 'someQueue'
      - Указать имена классов, а имя метода оставить по умолчанию ('fire').
      - Передать во все задачи один и тот же массив аргументов $payload.

        Queue::bulk(array('SendEmail', 'NotifyUser'), $payload);

    # Определить класс и задачу с именем по умолчанию
      - Имя задачи по умолчанию: 'fire'.
      - Оно используется неявно, если не указать имя при добавлении задачи.

        class SendEmail {

            public function fire($job, $data)
            {
                //
            }

        }

    # Определить класс и задачу с именем НЕ по умолчанию
      - В одном из примеров выше мы явно указали имя задачи: 'send'.
      - Значит, в классе вместо 'fire' надо задачу с таким именем и определять.

        class SendEmail {

            public function send($job, $data)
            {
                //
            }

        }

    # Добавить задачу с отложенным выполнением в планировщик задач
      - Всё работает точно также, как для метода Queue::push.
      - Но 1-ым аргументом передаётся дата-временное Carbon-значение.
      - Задача будет выполнена в укзанные в нём дату и время, а не сразу.
      - Про Carbon см. ссылку в разделе 'ссылки' этого файла.

        $date = Carbon::now()->addMinutes(15);
        Queue::later($date, 'SendEmail@send', array('message' => $message));

    # Удаление задачи из планировщика задач
      - После выполнения задачу нужно удалить из планировщика.
      - Сделать это можно специальным методом delete().
      - Обычно его размещают в конце метода-задачи.

          public function fire($job, $data)
          {
              // Process the job...

              $job->delete();
          }

    # Повторное добавление задачи в планировщик задач
      - После выполнения задачи может понадобиться выполнить её снова.
      - Это можно организовать с помощью специального метода release().
      - Как аргумент ему можно передать кол-во секунд, через которое он
        должен выполниться.

          public function fire($job, $data)
          {
              // Process the job...

              $job->release(5);
          }

    # Получить число запусков задачи
      - Так можно узнать, сколько раз уже была запущена задача.
      - Это можно сделать с помощью специального метода attempts().

          if ($job->attempts() > 3)
          {
              //
          }

    # Получить ID задачи

        $id = $job->getJobId();


  > Практика: анонимные функции в качестве задач
    - Можно использовано анон.функции в качестве задач.
    - Это очень удобно для небольших простых задач.
    - Добавим задачу в виде анон.функции в планировщик задач:

        Queue::push(function($job) use ($id)
        {
            Account::delete($id);

            $job->delete();
        });

    - При работе с iron.io надо быть осторожным и проверять, действительно
      ли данны пришли с iron.io, а не от хакера. Для этого надо использовать
      секретный токен, а запрос от iron должен выглядеть примерно так:

        https://yourapp.com/queue/receive?token=SecretToken


  > Практика: Artisan-демон для прослушки планировщика задач
    - Для работы нужно открыть консоль в корневой папке приложения.
    - Вот годная статья для реализации через ПЗ beanstalkd и Artisan-демон:
        http://fideloper.com/ubuntu-beanstalkd-and-laravel4

    # Запуск демона для default-соединения
      - Default-соединение указано в конфиге 'queue.php' в параметре 'default'.
      - Для запуска демона для default-соединения с ПЗ выполнить команду:

          php artisan queue:listen

    # Запуск демона для указанного соединения
      - В массиве 'connections' конфига 'queue.php' указан набор соединений.
      - Это соединения с различными настройками с различными ПЗ.
      - Каждое из этих соединений имеет своё уникальное имя.
      - Демон можно запустить для каждого из них по имени.
      - Например, запустим демон для соединения 'myConnection':

          php artisan queue:listen myConnection

    # Запуск демона для нескольких соединений за раз
      - Можно запустить демон для нескольких соединений за одну команду.
      - Для этого надо использовать опцию --queue:

          php artisan queue:listen --queue=high,low

    # Указать таймаут
      - Некоторые методы-задачи могут выполняться очень долго.
      - Они даже могут войти в бесконечный цикл или зависнуть.
      - Поэтому демону можно настроить таймаут в сек. на выполнение задачи.
      - Для этого используют отпцию --timeout:

          php artisan queue:listen --timeout=60

    # Интервал опросов
      - Демон периодически опрашивает ПЗ.
      - И если находит задачу(и), время которой подошло, выполняет её/их.
      - Демону можно указать период в сек., с которых проводить такие опросы.
      - Для этого надо использовать опцию --sleep:

          php artisan queue:listen --sleep=5

    # Выполнить 1-ю готовую задачу
      - Вообще, можно и не запускать демон.
      - А можно единовременно опросить планировщика задач.
      - Если там есть задачи, время которых подошло, то выполнить
        первую задачу в очереди:

          php artisan queue:work


  > Практика: работа с iron

    > Введение:
      - Выше описаны 2 доступных варианта извлечения задач из ПЗ.
      - Реализация 1-го варианта с помощью Artisan-демона описана выше.
      - Реализация 2-го автоматизированного варианта описана здесь.
      - Iron.io единственный ПЗ, который реализует 2-й вариант на текущий момент.
      - Вот наглядное учебное видео для реализации этого на практике:
          http://vimeo.com/64703617

    > Настройка
      - Сначала зарегистрировать аккаунт на iron.io.
      - Затем в конфиге 'queue.php' в connections настроить соединение.

    > Практика

      # Зарегистрировать новый URL-получатель
        - Iron будет посылать HTTP-запрос с поспевшими задачами по списку.
        - Этот список может включать любое кол-во URL, заданных хозяином аккаунта.
        - Задать эти URL можно и зайдя в свой аккаунт на сайте iron.io.
        - А можно и прямо Artisan-командой queue:subscribe.
        - При этом соединение с ПЗ должно быть настроено.

          php artisan queue:subscribe queue_name http://foo.com/queue/receive

        - Здесь 'queue_name' - это имя соединения.
        - А URL - это новый URL-получатель, который требуется зарегистрировать.

      # Создать роут для приёма HTTP-запросов от ПЗ
        - Вот мы добавили в Iron несколько задач.
        - У каждой из этих задач есть время, когда она должна начать выполняться.
        - Когда это время наступает, говорят, что задача 'поспела'.
        - Поспевшую задача Iron отправляет по списку URL-получателей.
        - А на стороне приложения этот запрос надо принять.
        - Для этого надо настроить роут, принимающий такой запрос.
        - Функция, на которую перенаправляет роут, должна делать только
          одно - возвращать результат работы метода Queue::marshal().
        - Вот пример такого роута:

            Route::post('queue/receive', function()
            {
                return Queue::marshal();
            });

        - Метод marshal позаботится о запуске метода-задачи.

  > Практика: контроль за 'неудавшимися' задачами

    > Введение
      - Информация здесь актуальна только при работе с Artisan-демоном.
      - По какой-то причине иногда не удаётся выполнить задачу.
      - А ведь это может быть какая-то очень важная задача.
      - Поэтому нужно как-то отслеживать появление таких неудач.
      - Чтобы используя эти данные исправлять положение.
      - Для этого в Laravel имеется специальный механизм.

    > Настройка БД
      - Можно указать БД и таблицу для приёма неудавшихся задач.
      - Сделать это можно в параметре 'failed' конфига 'app/config/queue.php'.

    > Механизм
      - При запуске демона можно задать MAX количество попыток.
      - Задача будет пытаться выполниться указанное кол-во попыток.
      - Если ни разу не получится, то будет сохранена в базу данных.

    > Практика:

      # Создать миграцию
        - Этой командой можно создать миграцию для таблицы, которая
          может принимать данные о неудавшихся задачах.

            php artisan queue:failed-table

      # Запустить демона, указав MAX кол-во попыток
        - Для этого надо использовать опцию --tries.

            php artisan queue:listen connection-name --tries=3

      # Зарегистрировать обработчик для события failing
        - Когда задача не удаётся, возбуждается событие failing.
        - Для него можно зарегистрировать функцию-обработчик:

            Queue::failing(function($job, $data)
            {
                //
            });

      # Посмотреть все неудавшиеся задачи
        - В том числе будут выведены ID задач

          php artisan queue:failed

      # Попробовать ещё раз выполнить неудавшуюся задачу
        - Для этого надо указать её ID.

          php artisan queue:retry 5

      # Удалить неудавшуюся задачу
        - Имеется в виду, из таблицы, где они хранятся.
        - Для этого надо указать её ID.

          php artisan queue:forget 5

      # Удалить все неудавшиеся задачи
        - Имеется в виду, из таблицы, где они хранятся.

          php artisan queue:flush


26. Сессии

  --------------------------------------
  Подоглавление:

    - Введение
    - Настройка
    - Практика: основное
    - Практика: флэш-данные

  --------------------------------------

  > Введение
    - Сессия позволяет сохранить какие-то данные между запросами пользователя.
    - Сессии используются, например, в механизме аутентификации пользователей.
    - Laravel предоставляет единый API для всех доступных реализаций сессионных механизмов.
    - Какой бы из них вы не выбрали, использовать надо один и тот же API.
    - То есть, этот механизм сделан в соответствии с принципами IoC.

  > Настройка
    > Настроить сессии в Laravel можно в конфиге 'app/config/session.php'.
    > Подробнее о сессионных настройках:

      # driver
        - Указать какой механизм сессий будет задействован.
        - Какой бы из них вы не выбрали, использовать надо один и тот же API.
        - Доступные варианты:

          # 'file' [по умолчанию]
            - Сессионные данные будут храниться в файле.
            - Такой вариант подойдёт для большинства приложений.

          # 'cookie'
            - Сессионные данные будут храниться в куках.

          # 'database'
            - Сессионные данные будут храниться в базе данных.

          # 'aps'
            - Сессионные данные будут храниться в оперативной памяти.
            - APC - Alternative PHP Cache - дополнение к PHP.
            - Инструкция: http://php.net/apc/

          # 'memcached'
            - Сессионные данные будут храниться в оперативной памяти.
            - Более продвинутая система, чем APC.
            - Официальный сайт: http://memcached.org/

          # 'redis'
            - Сессионные данные будут хранитсья в redis.
            - Redis - это NoSQL база данных
            - Официальный сайт: http://redis.io/topics/quickstart
            - Скачать последнюю версию для windows можно здесь: https://github.com/rgl/redis/downloads

          # 'array'
            - Сессионные данные будут хранитсья в простом PHP-массиве.
            - Массив живёт до конца обработки запроса.
            - Данные между запросами не сохраняются.
            - !Этот драйвер используют ТОЛЬКО для unit-тестов!
            - Потому что по факту он не реализует механизм сессии.

      # lifetime        | Время в минутах, в течение которого хранятся
                          сессионные данные, и после которого они становятся expired

      # expire_on_close | Можно сделать так, чтобы сессионные данные становились
                          expired сразу после закрытия браузера, тогда надо указать true.
                          По умолчанию укзано false.

      # files           | Если driver == 'file', то надо указать папку, где будут
                          хранится сессионные файлы.

      # connection      | Если driver == "database', или driver == "redis", то
                          надо указать имя соединения из коллекции соединений
                          в файле database.php, которое будет использоваться.

      # table           | Если driver == "database', то надо указать таблицу в БД,
                          в которой будут хранитсья данные сессий.

      # lottery         | Некоторым технологиям по работе с сессиями надо вручную
                          периодически очищать своих хранилища от старых сессий.
                          Здесь указана вероятность запуска этого процесса на каждом
                          запросе (по умолчанию, случайная от 2% до 100%).

      # cookie          | Здесь указано имя сессионной куки, которая будет
                          содержать UID сессии. Используется для любой сессионной
                          технологии.

      # path            | Адрес (начиная от корня приложения), начиная с которого
                          будет проверяться доступность сессионной куки. По умолчанию
                          стоит корень приложения '/'

      # domain          | ?

      # secure          | Если true, сессионные куки отправляются обратно на сервер
                          только в случае, если используется защищённое HTTPS-соединение.
                          По умолчанию false.

    > Подготовка таблицы в БД
      - Допустим, мы используем 'database' в качестве значения параметра 'driver'.
      - Тогда нам надо создать таблицу, отвечающую всем требованиям.
      - Легко сделать это можно с помощью команд Schema Builder или Artisan.

      # Создать требуюмую таблицу с помощью Schema Builder

          Schema::create('sessions', function($table)
          {
              $table->string('id')->unique();
              $table->text('payload');
              $table->integer('last_activity');
          });

      # Создать требуюмую таблицу с помощью Artisan
        - Открыть консоль, перейти в корень приложения.
        - Выполнить следующие команды:

            php artisan session:table
            composer dump-autoload
            php artisan migrate


  > Практика: основное

    # Сохранить элемент в сессию
      - С ключём 'key' и значением 'value'

        Session::put('key', 'value');

    # Добавить элемент в сохранённый в сессии массив
      - Вот допустим в сессию уже сохранён массив 'user'
      - И мы хотим добавить в него новый элемент.
      - С ключём 'teams' и значением 'developers'.

        Session::push('user.teams', 'developers');

    # Извлечь значение из сессии
      - Извлечь значение с ключём 'key' из сессии.
      - А если не получится, вернуть строку 'default'.

        $value = Session::get('key', 'default');

    # Извлечь значение из сессии
      - Извлечь значение с ключём 'key' из сессии.
      - А если не получится, выполнить анон.функ. и вернуть то,
        что она вернёт.

        $value = Session::get('key', function() { return 'default'; });

    # Извлечь все данные из сессии

        $data = Session::all();

    # Проверить наличие
      - Проверить, есть ли в сессии элемент с ключём 'users'.

        if (Session::has('users')) {
            //
        }

    # Удалить элемент из сессии
      - Удалить элемент с ключём 'key' из сессии.

        Session::forget('key');

    # Удалить все элементы из сессии

        Session::flush();

    # Перегенерировать ID сессии

        Session::regenerate();


  > Практика: флэш-данные

    # Зафлэшить данные в сессию до следующего запроса
      - Иногда требуется сохранить эл-т в сессию до следующего запроса.
      - Чтобы после след.запроса этот элемент самоудалился из сессии.
      - Такой способ сохранени по английски называют 'flash data'.
      - Зафлэшим в сессию элемент с ключём 'key' и значением 'value'.

        Session::flash('key', 'value');

    # Перефлэшить все текущие флэш-данные
      - Допустим, мы зафлэшили некоторые данные в сессию на запросе №1.
      - Наступил запрос №2, и эти данные нам в сессии доступны.
      - Но на запросе №3 этих даных уже небудет.
      - А что, если нам надо, чтобы флэш-данные из запроса №2 перекочевали
        в запрос №3?
      - В этом поможет метод reflash().

        Session::reflash();

    # Перефлешить только указанные флэш-данные
      - Перефлэшить только элементы с ключами 'username' и 'email'.

        Session::keep(array('username', 'email'));


27. Шаблоны

  --------------------------------------
  Подоглавление:

    - Введение
    - Наглядно: что такое шаблон
    - Практика: использование шаблона в контроллере
    - Blade: основы
    - Blade: управляющие структуры и прочее

  --------------------------------------

  > Введение
    - Часто надо на сайте требуется сделать много почти одинаковых страниц.
    - И во всех этих страницах используется одна, на 100% совпадающая разметка.
    - Различаются эти страницы контентом, либо какой-нибудь доп.разметкой внутри.
    - Так зачем в каждой странице каждый раз снова и снова писать одно и тоже?
    - Получается неэффективно, плюс загромождает код документов.
    - Поэтому придумали решение - использовать шаблоны разметки.
    - Ту часть, которая на 100% совпадает, выносят в отдельный файл-шаблон.
    - И используют этот шаблон уже во всех остальных требуемых документах.
    - Технология, реализующая это, называется шаблонизатором.
    - В Laravel есть собственный встроенный шаблонизатор: 'Blade'.

  > Наглядно: что такое шаблон
    - Допустим, есть у нас 3 вот таких документа:

       doc1.html          doc2.html         doc3.html
      ----------------------------------------------------------
      <html>            <html>            <html>
        <div>             <div>             <div>

          <p>Иван</p>       <i>Пётр</i>       <b>Дмитрий</b>

        </div>            </div>            </div>
      </html>           </html>           </html>

    - Они почти одинаковые. Различаются лишь содержанием эл-та DIV.
    - Поэтому есть смысл их одинаковую часть вынести в отдельный файл-шаблон.
    - Шаблон будет лежать в файле 'layouts/master.blade.html':

        master.blade.html
      ---------------------
        <html>
          <div>

            @yield('content')

          </div>
        </html>

    - Вот как теперь будут выглядеть наши 3 файла:

       doc1.html                    doc2.html                   doc3.html
      -------------------------------------------------------------------------------------
      @extends('layouts.master')  @extends('layouts.master')  @extends('layouts.master')
      @section('content')         @section('content')         @section('content')

        <p>Иван</p>                 <i>Пётр</i>                 <b>Дмитрий</b>

      @stop                       @stop                       @stop

    - Профит на лицо. Благодаря шаблону, теперь не надо писать одно и тоже
      во всех 3-х файлах. Вместо это одинаковая разметка вынесена в шаблон.
      Особенно заметна выгода становится, когда эта 'общая' разметка имеет
      большой объём.

  > Практика: использование шаблона в контроллере
    - Допустим, у нас есть шаблон. Такой же, как в примере выше.
    - И мы хотим применить этот шаблон в нашем контроллере 'UserController'.
    - Тогда первым делом нам надо определить св-во $layout:

        protected $layout = 'layouts.master';

    - Как следствие, указанный шаблон будет автоматом загружен в него.
    - Допустим, ещё у нас есть представление 'views/user/profile.html'.
    - И ещё у нас в контроллере есть метод 'showProfile'.
    - И среди роутов у нас есть роут на этот метод.
    - В 'showProfile' мы и хотим использовать наш шаблон. Сделать это можно так:

        public function showProfile() {

            $this->layout->content = View::make('user.profile');

        }

    - Т.Е. мы просто записываем в св-во content шаблона представление 'profile'.
    - Как следствие, представление в шаблоне заменяет строку '@yield('content')'.
    - Вот как целиком выглядит контроллер, описывающий приведённый пример:

        class UserController extends BaseController {

          // Шаблон
            protected $layout = 'layouts.master';

          // Метод, на который указывает роут (действие)
            public function showProfile()  {

                $this->layout->content = View::make('user.profile');

            }
        }

  > Blade: основы
    - Blade - это встроенный в Laravel шаблонизатор.
    - Он основан на концепции наследования шаблонов и секциях.
    - Все файлы-шаблоны blade должны иметь расширение .blade.php

    # Определить blade-шаблон
      - Расположен в файле 'app/views/layouts/master.blade.php'.

        <html>
            <body>
                @section('sidebar')
                    This is the master sidebar.
                @show

                <div class="container">
                    @yield('content')
                </div>
            </body>
        </html>

    # Использовать blade-шаблон
      - Допустим, мы создаём файл-представление.
      - Он будет расположен по адресу: 'app/views/someView.php'.

        // Укажем, что это представление наследует от шаблона master
        // - Это обязательно должна быть 1-ая строка в документе
        //   Иначе работать не будет!
          @extends('layouts.master')

        // Обозначим секцию 'sidebar'
        // - Она по сути полностью заменит одноимённую секцию из шаблона
          @section('sidebar')

            // Поместить сюда контект из 'sidebar' шаблона
              @parent

            // Добавить новый контент
              <p>Это контент, добавленный к контенту из 'sidebar' шаблона.</p>
          @stop

        // Обозначим секцию 'content'
        // - Она заменит строку "@yield('content')" в шаблоне
          @section('content')
              <p>This is my body content.</p>
          @stop

      - Обратите внимение, что представления, которые наследуют от blade-шаблона,
        просто перезаписывают секции из шаблона, как показано ниже.
      - А контент из секции шаблона может быть включён директивой @parent
      - Иногда, если вы не уверены, что такая секция была определена в
        шаблоне, можно в директиве @yield в представлении передать вторым
        аргументом значение по умолчанию:

          @yield('section', 'Default Content');

  > Blade: управляющие структуры и прочее

    # Вывод данных
      - Допустим, в представление мы передали переменную $name.
      - Вот так её в представлении можно вывести, используя фигурные скобки.
      - Конечно, можно использовать и обычный вариант.

        // Обычный вариант
          Hello, <?php echo $name; ?>.
          The current UNIX timestamp is  <?php echo time() ?>.

        // Blade-вариант с обрезанием всех тегов.
          Hello, {{{ $name }}}.
          The current UNIX timestamp is {{{ time() }}}.

        // Blade-вариант без обрезания тегов.
          Hello, {{ $name }}.
          The current UNIX timestamp is {{ time() }}.

      - Так что вот эти вещи идентичны:

          {{ $x }}            <?php echo $x ?>

      - А вот эти почти идентичны.
      - С разницей в том, что {{{ }}} обрезает все HTML-теги.
      - При выводе польз.ввода рекомендуется использовать именно этот вариант.

          {{{ $x }}}            <?php echo $x ?>

      - Допустим требуется вывести строку, которая не будет обрабатываться
        шаблонизатором blade. Это может понадобиться, если требуется обрамить
        её в фигурные скобки. Такую строку можно вывести так:

          @{{   {Иван Петров}   }}

      - На экран будет выведено:

          {Иван Петров}

    # Вывод после проверки на наличие
      - Допустим, мы не уверены, что $name была передана и доступна.
      - Мы хотим сначала проверить наличие $name. А уже потом выводить.
      - Сделать это можно так:

        // Обычный вариант
          <?php
            if( isset($name) ) echo $name;
            else echo 'Default';
          ?>

        // Длинный blade-вариант
          {{{ isset($name) ? $name : 'Default' }}}

        // Короткий blade-вариант
          {{{ $name or 'Default' }}}

    # Стейтмент IF
      - Работает также, как if в PHP.

      @if (count($records) === 1)
          I have one record!
      @elseif (count($records) > 1)
          I have multiple records!
      @else
          I don't have any records!
      @endif

      @unless (Auth::check())
          You are not signed in.
      @endunless

    # Циклы

      @for ($i = 0; $i < 10; $i++)
          The current value is {{ $i }}
      @endfor

      @foreach ($users as $user)
          <p>This is user {{ $user->id }}</p>
      @endforeach

      @while (true)
          <p>I'm looping forever.</p>
      @endwhile

    # Вставка под-представлений
      - Допустим, вы хотим в какое-то место представления вставить ещё одно.
      - Также, как это делается в PHP директивами include и require.
      - Сделать это можно вот так:

          @include('view.name')

      - А вот так можно передать ему какие-то данные:

          @include('view.name', array('some'=>'data'))

    # Комментарий

      {{-- This  will not be in the rendered HTML --}}


28. Валидация

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Валидация: основы
    - Валидация: работа над ошибками
    - Валидация: получение сообщений об ошибках в представлении
    - Валидация: стандартные правила
    - Валидация: условное добавление правил
    - Кастомизация стандартных сообщений о НЕ прохождении валидации
    - Кастомизация правил валидации

  --------------------------------------

  > Ссылки

    - Хорошая статья с реальным примером валидации:
        http://laravelbook.com/laravel-input-validation/

  > Введение
    - Часто нужно проводить валидацию введённых пользователем данных.
    - Для этого требуется использовать различные правила валидации.
    - А в случае не прохождения валидации сохранять в сессии данные об этом.
    - Чтобы вернуть пользователя к форме и указать ему что за ошибка.
    - Laravel имеет для всего этого механизм валидации, представленный классом Validation.

  > Валидация: основы
    - Допустим, нам надо провести валидацию 3х полей: 'name', 'password', 'email'.
    - И для каждого поля у нас разный набор правил валидации.
    - Тогда первым делом нам надо создать новый объект класса Validator.
    - Внутри него надо определить поля для валидации и их значения.
    - А также правила валидации для каждого из этих полей.
    - Вот как он определяется:

        $validator = Validator::make(
            array(
                'name' => 'Dayle',
                'password' => 'lamepassword',
                'email' => 'email@example.com'
            ),
            array(
                'name' => 'required',
                'password' => 'required|min:8',
                'email' => 'required|email|unique:users'
            )
        );

    - 1й аргумент - массив полей для валидации и их значений.
    - 2й аргумент - массив наборов правил валидации для каждого из полей.
    - Разные правила в наборе отделяются друг от друга символом пайп '|'.
    - Что дальше? Как теперь определить, прошли ли данные валидацию?
    - С помощью метода passes():

        if ($validator->passes()) {
            // Все данные прошли валидацию
        }

    - А как определить, если какие-то данные не прошли валидацию?
    - С помощью метода fails():

        if ($validator->fails()) {
            // Данные не прошли валидацию
        }

    - Если данные не прошли валидацию, как извлечь сообщение об ошибке?
    - Для этого надо получить экземпляр объекта MessageBox.
    - Для этого применим метод messages к объекту Validator:

        $messages = $validator->messages();

    - Можно также получить доступ к массиву правил валидации, которые
      не удалось пройти:

        $failed = $validator->failed();

  > Валидация: работа над ошибками
    - В примере выше мы воспользовались методом messages().
    - Этот метод мы применили к объекту класса Validator.
    - Как результат, метод messages возвращает объекта класса MessageBox.
    - И этот объект имеет ряд доп.методов для работы с ошибками валидации.
    - Получить первое сообщение об ошибке для указанного поля:

        $first =  $messages->first('email');

    - Получить это же сообщение, но в указанном формате:

        $first =  $messages->first('email', '<p>:message</p>');

    - Получить все сообщения об ошибке для указанного поля:

        foreach ($messages->get('email') as $message){
            //
        }

    - Получить все сообщения об ошибках для всех полей:

        foreach ($messages->all() as $message) {
            //
        }

    - Получить тоже самое, но в указанном формате:

        foreach ($messages->all('<li>:message</li>') as $message) {
            //
        }

    - Проверить, доступны ли сообщения об ошибках для для указанного поля:

        if ($messages->has('email')) {
            //
        }

  > Валидация: получение сообщений об ошибках в представлении
    - Вот, допустим, мы провели валидацию каких-то данных.
    - Как теперь получить сообщения об ошибках валидации в представлении?
    - Представим, что у нас есть роут на представление с формой:

        Route::get('register', function()
        {
            return View::make('user.register');
        });

    - И есть роут для обработки post-данных после их отправки пользователем:

        Route::post('register', function()
        {
            $rules = array(...);

            $validator = Validator::make(Input::all(), $rules);

            if ($validator->fails())
            {
                return Redirect::to('register')->withErrors($validator);
            }
        });

    - Как видно, в последнем мы проверили наличие ошибок валидации методом fails().
    - И если они есть, то переадресуем пользователя на роут register.
    - При этом используем метода withErrors().
    - Он флэшит сообщения об ошибках в сессию.
    - После переадресации нам надо получить к ним доступ в представлении 'user.register'.
    - Сделать это можно через переменную $errors.
    - Эта переменная ВСЕГДА определена во всех представлениях приложения.
    - Потому что Laravel всегда автоматом проверяет, нет ли в сессии данных об ошибках.
    - Вот пример, посре редиректа в представлении получить сообщение об
      ошибке:

        <?php echo $errors->first('email'); ?>

    - Т.Е. $errors по сути представляет экземпляр класса MessageBox.
    - И можно использовать с ним в се соответствующие методы (см.выше).

  > Валидация: стандартные правила

    # accepted
      - Значение в поле должно быть равно: 'yes', 'on' или 1.
      - Все эти значения семантически означают 'да', 'включено'.
      - Полезно для валидации чекбоксов типа "Вы согласны с правилами?".

    # active_url
      - Значение в поле должно быть валидным URL.
      - Проверка "за кулисами" производится PHP-функцией checkdnsrr.

    # after:date
      - Значение в поле должно быть датой, более поздней, чем date.
      - Строки приводятся к датам функцией strtotime.

    # alpha
      - Поле должно содержать только латинские символы.

    # alpha_dash
      - Поле должно содержать только латинские символы, цифры и _ -

    # alpha_num
      - Поле должно содержать только латинские символы и цифры.

    # before:date
      - Значение в поле должно быть датой, более ранней, чем date.
      - Строки приводятся к датам функцией strtotime.

    # between:min,max
      - Значнение в поле должно быть числов в диапазоне от min до max.
      - Строки, числа и файлы трактуются аналогично правилу size (см.ниже).

    # confirmed
      - Значение поля 'name' должно быть равно значению в поле 'name_confirmation'.
      - Например, есть в форме поле с атрибутом name, равным 'name':

          <input type="password" name="password">

      - И ещё поле с атрибутом 'name' равным 'name_confirmation':

          <input type="password" name="password_confirmation">

      - Так вот это правило валидации проверяет, равны ли значения value
        этих двух полей?

    # date
      - Значение в поле должно быть правильной датой.
      - Её правильность 'за кулисами' проверяется PHP-функцией strtotime.

    # date_format:format
      - Значение поля должно быть датой в определённом формате.
      - В таком, какой понимает PHP-функция date_parse_from_format.

    # different:field
      - Значение поля должно отлечаться от значения field.

    # digits:value
      - Значение поля должно быть числом и иметь длину value.

    # different:field
      - Значения поля должно быть числом между MIN и MAX.

    # email
      - Значение поля должно быть корректным адресом email.

    # exists:table,column
      - Значение поля должно существовать в указанной таблице БД.
      - Если column не указано, то будет использовано имя поля.
      - Пример использования:

          'state' => 'exists:states,someColumn'

      - Можно передать ещё пару аргументов, которые будут к запросу where.
        Например, где account_id == 1:

          'state' => 'exists:states,someColumn,account_id,1'

    # image
      - Загруженный файл должен быть картинкой в формате: 'jpeg', 'png', 'bmp', 'gif'.

    # in:foo,bar,…
      - Значение поля должно быть одним из перечисленных foo,bar,...

    # integer
      - Значение поля должно быть целым числом типа int

    # ip
      - Значение поля должно быть корректным IP-адресом.

    # max:value
      - Значение поля должно быть меньше, чем value.
      - Строки, числа и файлы трактуются аналогично правилу size (см.ниже).

    # mimes:foo,bar,...
      - MIME-тип загруженного файла должен быть одним из перечисленных foo,bar,...

    # min:value
      - Значение поля должно быть больше, чем value.
      - Строки, числа и файлы трактуются аналогично правилу size (см.ниже).

    # not_in:foo,bar,...
      - Значение поля НЕ должно быть одним из перечисленных foo,bar,...

    # numeric
      - Значение поля должно быть числом.

    # regex:pattern
      - Значение поля должно матчиться с заданным регулярным выражением.

    # required
      - Значение поля должно присутствовать - иметь непустое значение.

    # required_if:field,value
      - Значение поля должно присутствовать только при выполнении условия.
      - Условие в том, что другое поле с name='field' имеет value='value'.

    # required_with:foo,bar,...
      - Значение поля должно присутствовать только при выполнении условия.
      - Условие в том, что хотя бы в одном из полей с name='foo',name='bar',...,
        значение уже присутствует.

    # required_with_all:foo,bar,...
      - Значение поля должно присутствовать только при выполнении условия.
      - Условие в том, что во всех полях с name='foo',name='bar',...,
        значение уже присутствует.

    # required_without:foo,bar,...
      - Значение поля должно присутствовать только при выполнении условия.
      - Условие в том, что хотя бы в одном из полей с name='foo',name='bar',...,
        значение должно отсутствовать.

    # required_without_all:foo,bar,...
      - Значение поля должно присутствовать только при выполнении условия.
      - Условие в том, что во всех полях с name='foo',name='bar',...,
        значение должно отсутствовать.

    # same:field
      - Значение в поле должно совпадать со значением field

    # size:value
      - Значение в поле должно иметь размер, равный value.
      - Для строк, размер - количество симсволов.
      - Для чисел, размер соответствует целому числу.
      - Для файлов, размер - кол-во килобайт.

    # unique:table,column,except,idColumn
      - Значение поля должно быть уникальным в заданной таблице table БД.
      - Если column не указано, то будет использовано имя поля.
      - Пример использования:

          'email' => 'unique:users,email_address'

      - Можно указать 3-й аргумент, чтобы проигнорировать строку с таким ID:

          'email' => 'unique:users,email_address,10'

      - В примере ниже только строки со значением 1 в столбце 'account_id'
        будут проверены на уникальность:

          'email' => 'unique:users,email_address,NULL,id,account_id,1'

    # URL
      - Значение в поле должно быть правильным URL.
      - Для проверки 'за кулисами' используется PHP-функция filter_var.

  > Валидация: условное добавление правил

    # Проводить валидацию только переданных для этого полей
      - Как уже описано выше, Validator::make принимает на вход 2 массива.
      - 1й аргумент - массив полей для валидации и их значений.
      - 2й аргумент - массив наборов правил валидации для каждого из полей.
      - Но что, если в 1-м отсутствует поле 'x', а во втором оно валидируется?
      - Ниже пример такой ситуации. В 1м массиве для валидации передаётся поле
        'email', а поля 'age' нет. А во 2м массиве присутствует правило для
        валидации поля 'age.

          $data = array('email' => 'ivan@gmail.com');
          $cond = array('age' => 'required|alpha_num');
          $v = Validator::make($data, $cond);

      - Т.Е. по сути проводится валидация отсутствующего значения.
      - Ни к чему хорошему это не приведёт.
      - Поэтому, если разработчик допускает, что во 1м массиве могут отсутствовать
        некоторые поля, которые присутствоуют во 2м массиве, то следует для этих полей
        добавить в их правила валидации правило 'sometimes'.
      - 'sometimes' означает, что валидация поля будет проводитсья только в том
        случае, если это поле присутствует п 1м массиве.
      - Теперь мы можем исправить пример, приведённый выше:

          $data = array('email' => 'ivan@gmail.com');
          $cond = array('age' => 'sometimes|required|alpha_num');
          $v = Validator::make($data, $cond);

    # Сложная условная валидация
      - Иногда требуется проводить валидацию только если выполнены некие условия.
      - Например, если значение поля 'x' > 100, провести require-валидацию поля 'y'.
      - Или если значения полей 'x' и 'y' < 50, то провести валидацию поля 'z'.
      - Каким же образом реализовать такую валидацию? Сейчас это будет описано!
      - Допустим, сотрудник добавляет отчёт (цифра) о выполненном задании.

          $v = Validator::make($data, array(
            'report' => 'required|numeric'
          ));

      - Мы ожидаем увидеть, что она будет >= 50 и <= 100.
      - А если нет, то он должен заполнить еще одно обязательное текстовое поле.
      - В этом поле он должен объяснить, почему цифра не соответствует ожиданиям.
      - MAX длина этого поля должна быть 500 символов.
      - Реализоать это можно с помощью функции sometimes():

          $v->sometimes('reason', 'required|max:500', function($input) {

              if($input->report < 50 || $input->report > 50)
                return true;
              else
                return false;

          });

      - 1-й аргумент - 'reason' - имя поля, валидацию которого потребуется
        дополнительно провести в случае выполнения поставленных условий.
      - 2-й аргумент - 'required|max:500' - правила для валидации этого поля.
      - 3-й аргумент - анонимная функция - условия, которые должны быть выполнены
        для того, чтобы была проведена валидация. Если она вернёт true, то валидация
        таки будет проведена. А если вернёт false, то таки нет.
      - $input - автоматически передающийся в анон.функцию аргумент. Является
        экземпляром класса 'Illuminate\Support\Fluent'.
      - Условную валидацию даже можно применить к нескольким полям за раз:

          $v->sometimes(array('reason', 'cost'), 'required', function($input) {

              if($input->report < 50 || $input->report > 50)
                return true;
              else
                return false;

          });

  > Кастомизация стандартных сообщений о НЕ прохождении валидации

    > Введение
      - Вот, допустим, какие-то поля не прошли валидацию.
      - Автоматически генерируются стандартные сообщения об этом.
      - Как их получить, описано выше в пункте 'Валидация: работа над ошибками'.
      - Проблема в том, что все эти сообщения на английском языке.
      - А значит их нельзя использовать в своих русскоязычных приложениях.
      - Можно ли как-то заменить стандартные сообщения на свои, исправленные?
      - Да, и именно об этом пойдёт речь в этом пункте.

    # Передача кастомных сообщений валидатору
      - Во превых отметим, что в сообщениях-ошибках используются плейсхолдеры.
      - В примере ниже, например, ':attribute' будет заменено на имя поля.
      - Создадим массив кастомных сообщений-ошибок для различных правил валидации:

          $messages = array(
              'same'    => 'Значение :attribute и :other должны совпадать.',
              'size'    => 'Значение :attribute должно полностью совпадать с :size.',
              'between' => 'Значение :attribute должно быть между :min - :max.',
              'in'      => 'Значение :attribute должно быть одним из следующих: :values',
          );

      - И оказывается, методу Validator::make можно передать 3-й аргумент.
      - И это как раз и есть массив с кастомными сообщениями-ошибками.
      - Вот так, например:

          $validator = Validator::make($input, $rules, $messages);

      - А если требуется определить кастомные сообщения-ошибки не просто
        для конкретных правил валидации, а и для конкретных указанных полей?
        Например, для поля с именем 'email' и правила валидации 'require':

          $messages = array(
              'email.required' => 'Укажите свой адрес электронной почты!',
          );

  > Кастомизация правил валидации

    > Введение
      - Laravel 'из коробки' предоставляет много стандартных правил валидации.
      - Все они перечислены выше в пункте 'Валидация: стандартные правила'.
      - Но несмотря на их количество, они на 100% не покрывают потребности.
      - Особенно потребности разработчика из РФ.
      - Например, среди них нет правил, работающих с русским языком.

    # Регистрация кастомного правила валидации
      - Для этого у класса Validator имеется метод extend.
      - Этот метод принимает 2 аргумента.
      - 1-й аргумент: имя нового правила валидации.
      - 2-й аргумент: анон.функция, которая должна возвращать true/false.
        - True - в случае успешной валидации, false - в случае неудачной.
        - Анон.функция автоматом получает 3 аргумента.
          - $attribute - имя поля, которое валидируется.
          - $value - значение поля, которое валидируется.
          - $parameters - список параметров валидации, переданных в правиле.
      - Определим кастомное правило валидации 'foo', которое проверяет
        значение поля на равенство строке 'foo':

          Validator::extend('foo', function($attribute, $value, $parameters)
          {
              return $value == 'foo';
          });

      - Вместо анонимной функции можно также указать метод класса:

          Validator::extend('foo', 'FooValidator@validate');

      - Кроме того надо учесть, что стандартного сообщение об ошибке
        валидации не существует.
      - Поэтому следует не забыть добавить своё, кастомное.

    # Регистрация кастомного правила валидации через расширение класса Validator
      - В принципе, это тоже самое, что описано выше.
      - Просто выше мы использовали для этого метод extend.
      - А в этом примере мы просто расширим класс Validator.
      - У нас будет какой-то CustomValidator, наследующий от Validator.
      - И в CustomValidator мы добавим методы, представляющие собой
        кастомные правила валидации.
      - Имена этих методов должны начинатсья с 'validate', и оканчиваться
        именем правила валидации с большой буквы.
      - Например, имя метода для правила валидации с именем 'foo' будет
        выглядеть так: 'validateFoo'.
      - Вот пример, как может выглядеть такой класс:

          <?php
          class CustomValidator extends Illuminate\Validation\Validator {

              public function validateFoo($attribute, $value, $parameters)
              {
                  return $value == 'foo';
              }

          }

      - После этого надо зарегистрировать в классе Validator это расширение.
      - Это позволит и дальше использовать Validator.
      - Для этого надо использовать метод resolver():

          Validator::resolver(function($translator, $data, $rules, $messages)
          {
              return new CustomValidator($translator, $data, $rules, $messages);
          });




