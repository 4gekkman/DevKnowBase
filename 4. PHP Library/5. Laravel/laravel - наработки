////==========================================================////
////																													////
////                  Laravel - мои наработки					        ////
////																													////
////==========================================================////
//// 			        		       ////
//// 			  Оглавление			 ////
//// 			        		       ////
////=========================////


  А. Для Laravel 4.0 - 4.2
  ------------------------

    А1. Технология вкладывания вьюх в документ
    А2. Шаблонизация через blade
    А3. Динамический роутинг
    А4. Управление конфигами приложения
    А5. Выполнение кода ДО и НА старте приложения
    А6. Режим обслуживания приложения
    А7. Фильтры для запросов
    А8. Ошибки и логи
    А9. Как пользоваться Service providers
    А10. Как сделать аутентификацию и авторизацию
    А11. Хэширование данных с помощью bcrypt
    А12. Использования key-value хранилища Redis
    A13. Работа с email
    А14. Капча
    А15. Guzzle - для работы с HTTP
    А16. Геолокация
    А17. Как пользоваться CSRF-токеном в Laravel
    А18. Каталог в интернет-магазине
    А19. Транслитерация RUS->ENG с помощью пакета URLify
    А20. Манипуляции с изображениями с помощью пакета Intervention Image
    А21. Кэширующий сервер изображений в интернет-магазине
    А22. Получить массив имён столбцов в таблице
    А23. Создание библиотек функций, доступных в любом месте Laravel
    А24. Использование библиотек функций для расшаривания кода между контроллерами
    А25. Как передавать данные с сервера в layout-представление
    А26. Как сохранять/извлекать строки с HTML в/из БД

  Б. Для Laravel 5.0 - 5.1
  ------------------------

    Б1. NGINX: как организовать мгновенную загрузку N картинок в документе
    Б2. Доступ к классам в L5 с учётом перехода на PSR-4
    Б3. Организация модульного приложения на основе Laravel 5.1
    Б4. Как изменить базу данных по умолчанию для текущего запроса
    Б5. Генерация миграции L5 из готовой БД
    Б6. Генерация заселятелей L5 из готовой БД
    Б7. Как расшарить куки для всех поддоменов домена
    Б8. Как бороться с ошибкой nginx: "504 Gateway Time-out"
    Б9. Установка N серверов MySQL на одну ОС Ubuntu в Homestead
    Б10. Решение проблемы: Cookie::get() возвращает null

  В. Laravel ~5.2. Новая архитектура приложений
  ---------------------------------------------

    В1. Новая архитектура приложений
    В2. Установка laravel и homestead
    В3. Оформление нового пакета composer
    В4. Как открыть >= 2 моделей workbench одновременно
    В5. Как посмотреть очередь задач с драйвером redis
    В6. Оформление локального и удалённого (на GitHub) репозиториев для пакета
    В7. Работа с Carbon
    B8. Использование веток пакетов composer
    B9. Концепция frontend-части моего фреймворка
    В10. Настройка отправки почты из Laravel через gmail-аккаунт
    В11. Работа с HybridAuth


////==========================================================////


А1. Технология вкладывания вьюх в документ

  --------------------------------------
  Подоглавление:

    - Введение
    - Отличие документа от вьюхи
    - Решение проблемы
    - Суть вьюх
    - Пустой HEAD
    - Практика

  --------------------------------------

  > Введение
    - В документе часто собираются интерфейсы многих модулей.
    - Один интерфейс может принадлежать лишь одному модулю.
    - Документ, т.о., будет принадлежать одному из модулей.
    - Все остальные интерфейсы являются вьюхами.
    - Возникает вопрос, каким же образом запихнуть все эти вьюхи в документ?

  > Отличие документа от вьюхи
    - Каждый интерфейс представляет из себя отдельный файл.
    - Все интерфейсы делятся на "документы" и "вьюхи".
    - Документ связан с роутом, и должен быть "законченной" страницей.
    - Вьюха не связана с роутом, и представляет лишь "элемент" страницы.

  > Решение проблемы
    - Laravel позволяет "вкладывать" вьюхи в документ.
    - Можно даже вкладывать вьюхи в другие вьюхи, и далее в глубину.
    - При вкладывании можно передать принимающей вьюхе данные.

  > Суть вьюх
    - Каждая вьюха - один из законченных интерфейсов того или иного модуля.
    - Часто их надо показывать при опред. условиях в опред. документах.
    - Рассмотрим для ясности пример про интернет-магазин:


      - Рассмотрим документ - главную страницу интернет-магазина.
      - Пусть он принадлежит модулю m1.
      - В нём есть 9 разных мест, куда надо вставить по 1 вьюхе.
      - Каждая вьюха принадлежит какому-то другому модулю.
      - Каждая вьюхя является законченным интерфейсом своего модуля (одим из).


                        --------------------------------
                        |Документ d1_document.blade.php|
                        --------------------------------

                  Приветствуем Вас в нашем интернет-магазине!

           Выберите город:        Наш каталог:       Что с моим заказом:
         -------------------   -------------------   -------------------
         |Место под v1_view|   |Место под v2_view|   |Место под v3_view|
         -------------------   -------------------   -------------------

             Я смотрел:            Мои желания:          Мои скидки:
         -------------------   -------------------   -------------------
         |Место под v4_view|   |Место под v5_view|   |Место под v6_view|
         -------------------   -------------------   -------------------

          Акции и конкурсы:        Инфо-меню:             Вход в ЛК:
         -------------------   -------------------   -------------------
         |Место под v7_view|   |Место под v8_view|   |Место под v9_view|
         -------------------   -------------------   -------------------

      - Было бы удобно просто вставить каждую вьюху на своё место в документ.
      - Каждая бы встроилась в код документа, и выполняла свою функцию.
      - Вот для этого вьюхи и существуют.

  > Пустой HEAD
    - У вьюхи должен быть пустой <head></head>.
    - Иначе при вставке в принимающий интерфейс вставится и содержимое head.
    - Если head будет пуст, то вставится лишь содержимое body.
    - Без самого элемента body, естественно.
    - Но теги - doctype, html, head, body - удалять не следует.
    - Ведь нам может понадобиться посмотреть на работу вьюхи, не вставляя её никуда.
    - А для этого требуется, чтобы соответствующие теги присутствовали.
    - К сожалению, без <meta charset='UTF-8'></meta> могут быть каракули при отдельном просмотре.
    - Но в конце концов можно явно указать браузеру, что используется UTF-8.

  > Практика
    - Допустим, есть у нас 2 вьюхи. У обоих в head пусто.

      'views/views/v1_view.php'    'views/views/v2_view.php'
      ------------------------     ------------------------

           <!doctype html>              <!doctype html>
           <html lang="ru">             <html lang="ru">
           <head></head>                <head></head>
           <body>                       <body>

             <p>Вьюха №1!</p>             <p>Вьюха №2!</p>

           </body>                      </body>
           </html>                      </html>

    - И есть один документ.

      - У него уже в head не пусто.
      - В документе есть 2 подготовленных под вьюхи места.
      - Первое - div с id=='place1'.
      - Второе - div с id=='place2'.
      - Содержимое 1-й вьюхи доступно через переменную $view1.
      - Содержимое 1-й вьюхи доступно через переменную $view2.

                'views/docs/v1_document.blade.php'
                ----------------------------------

                  <!doctype html>
                  <html lang="ru">
                  <head>
                    <meta charset="UTF-8">
                    <title>Document</title>
                  </head>
                  <body>

                    <div id='place1'>
                      <?php echo $view1; ?>
                    </div>

                    <div id='place2'>
                      <?php echo $view2; ?>
                    </div>

                  </body>
                  </html>

    - Создадим теперь роут на этот документ.
    - И при создании представления "вложим" в док-т те 2 вьюхи:

        Route::get('/nest', function(){

          $view = View::make('docs/v1_document')->
                    nest('view1', 'views/v1_view.php')->
                    nest('view2', 'views/v2_view.php');

          return $view;
        });

    - Теперь документ v1_document доступен по URI == '/nest'.
    - Если открыть документ, то мы увидим, что код из вьюх встроился куда задали.
    - Передать данные во вкладываемое представление можно так:

        Route::get('/nest', function(){

          $data = array('ivan' => 10, 'lena' => 20);

          $view = View::make('docs/v1_document')->
                    nest('view1', 'views/v1_view.php', $data);

          return $view;
        });

    - Передать данные в создаваемое представление можно так:

        Route::get('/nest', function(){

          $data = array('ivan' => 10, 'lena' => 20);

          $view = View::make('docs/v1_document', $data)->
                    nest('view1', 'views/v1_view.php');

          return $view;
        });


А2. Шаблонизация через blade

  --------------------------------------
  Подоглавление:

    - Введение
    - Шаблоны документов
    - Разница между section/show и yield

  --------------------------------------

  > Введение
    - Бывает, что у группы док-в одинаковых эл-тов на X%.
    - Представим, что есть N документов, у которых X% одинаковых эл-тов.
    - Мы можем каждый из них разработать полностью отдельно.
    - Такое решение имеет следующие минусы:

        - Выполнено на X% больше бесполезной работы.
        - Если надо что-то изменить в одинак.части, то менятьвсе N док-ов.

    - Рассмотрим это на примере.

      - Допустим, есть N вот таких вот документов.
      - У них всё одинаковое, кроме содержимого p с id=='w'.

      Документ 1                   Документ 2                       Документ N
      --------------------------   --------------------------  ...  --------------------------

        <http>                       <http>                           <http>
          <head>                       <head>                           <head>
          </head>                      </head>                          </head>
          <body>                       <body>                           <body>

            <p>Одинаковая часть</p>      <p>Одинаковая часть</p>          <p>Одинаковая часть</p>

            <p id='w'>Разная часть:      <p id='w'>Разная часть:          <p id='w'>Разная часть:
             Документ №1</p>              Документ №2</p>                  Документ №[N]</p>

          </body>                      </body>                          </body>
        </http>                      </http>                          </http>

      - Допустим, решили не использовать шаблонизацию, и каждый док-т делать отдельно.
      - Тогда придётся лишние N-1 раз писать их "одинаковую" часть:

                                <http>
                                  <head>
                                  </head>
                                  <body>

                                    <p>Одинаковая часть</p>

                                  </body>
                                </http>

      - А если понадоб-ся измен. везде один.часть, придётся изменять N файлов.

  > Шаблоны документов
    - Избежать описанных выше минусов можно, применяя шаблонизацию.
    - Laravel позволяет организовать шаблонизацию с помощью blade.
    - Создадим шаблон 'layouts/l1_layout.blade.php'.
    - Какой использовать вариант - без разницы, суть одна.


        Вариант №1.                     Вариант №2.
        Использ-е: section / show.      Использ-е: yield

        layouts/l1_layout.blade.php     layouts/l1_layout.blade.php
        ---------------------------     ---------------------------

          <http>                          <http>
            <head>                          <head>
            </head>                         </head>
            <body>                          <body>

              <p>Одинаковая часть</p>         <p>Одинаковая часть</p>

              <p id='w'>                      <p id='w'>

                @section('content')
                                                @yield('content')
                @show

              </p>                            </p>

            </body>                         </body>
          </http>                         </http>

    - Теперь нам надо создать наши N документов на основе этого шаблона.
    - Вот как они теперь будут выглядеть:

    Документ 1                               Документ 2                              Документ N
    --------------------------               --------------------------      ...     --------------------------
    @extends('lk_grumart._layouts.main')     @extends('lk_grumart._layouts.main')    @extends('lk_grumart._layouts.main')

      @section('content')                       @section('content')                     @section('content')
        <p id='w'>                                <p id='w'>                              <p id='w'>
          Разная часть:                             Разная часть:                           Разная часть:
          Документ №1                              Документ №2                              Документ №[N]
        </p>                                      </p>                                    </p>
      @stop                                     @stop                                   @stop

    - Как видно, количество лишнего кода (а значит и работы) серьёзно сократилось.
    - Внести изменение в пост. часть можно теперь легко в шаблоне, 1 раз для N файлов.
    - Важный момент здесь - @extends должно быть в самом-самом начале файла.
    - Даже если туда затесается какой-нибудь BOM или пробел, работать не будет.
    - *Примеч.: роут должен вести не на шаблон, а как раз на 1 из этих N файлов.

  > Разница между section/show и yield
    - Только в том, что внутри section/show в шаблоне можно задать доп. контент.
    - В то время, как с помощью yield доп. контента не задашь.
    - Например:

          Доп. контент с section/show               Без доп. контента с yield
         -----------------------------              --------------------------

             <http>                                    <http>
               <head>                                    <head>
               </head>                                   </head>
               <body>                                    <body>

                 @section('diff')                          @yield('diff');
                   <span>Доп. контент</span>
                   [сюда вставятся данные из             </body>
                    section/stop документа-            </http>
                    наследника шаблона]
                 @show

               </body>
             </http>

    - Вот и вся разница.


А3. Динамический роутинг

  --------------------------------------
  Подоглавление:

    - Введение
    - 5 плюсов динамического роутинга
    - Принцип работы
    - Динамический роутинг на REST-контроллерах

  --------------------------------------

  > Введение
    - Управлять URI роута можно динамически - программно - у себя в ЛК.

  > 5 плюсов динамического роутинга

    + Можно на 1 странице в ЛК увидеть все док-ты проекта со всеми URI.
    + Можно 2-мя кликами в ЛК изменить URI документа.
    + Информация по URI в ЛК всегда актуальная, т.к. это единый источник.
    + Единая входная точка для всех запросов.
    + Все док-ты и контроллеры можно называть по их ID, и располагать не иерархично, в ряд.

  > Принцип работы
    - Пусть у нас в БД есть такая таблица:

        id | inner_uri | outer_uri

    - В самом верху routes.php у нас такой вот роут.
    - Ни один запрос не пройдёт мимо этого роута, он как сторожевой пёс:

        Route::any('/{outer_uri}', function($outer_uri) {

          // Извлекаем из БД экз.модели по первич.ключу $outer_uri
            $page = Page::where('outer_uri', '=', $outer_uri)->first();

          // Получаем полный URL на роут с внут. URI == $page->inner_uri
            $url = URL::to($page->inner_uri);

          // Создаём новый объект-запрос класса Request
          // - URL запроса равен найденному выше $url
          // - Метод запроса тот же, что у пришедшего от клиента Псу Any.
          // - Также передаём новому запросу веьс старый Input
            $request = Request::create($url, Request::method(), Input::all());

          // Отправляем запрос
            $response = Route::dispatch($request)->getOriginalContent();

        }

    - Ниже идут внутренние роуты.
    - Прямо запрос до них никогда не дойдёт, т.к. не пройдёт через "пса".

              -----------------------------
              |HTTP-запрос от пользователя|-
              ----------------------------- \
                          |                  \
      http://site.ru/user |                   \
                          |                    \
              -----------------------------     |
              |Роут - сторожевой Пёс - Any|   \ | /
              -----------------------------    \|/  Ни один запрос от клиента не
                             |                 / \  проскочет мимо Пса Any напрямую.
                             |                /   \
      Пёс Any сверяется с БД |
                             |
                ------------------------------
                |   outer_uri  |  inner_uri  |
                |--------------|-------------|
                | /user        | /i1         |<-- Гав! Гав! Соответствие!
                | /user/lk     | /i2         |
                | /user/ivan   | /i3         |
                | /user/lena   | /i4         |
                |     ...      |     ...     |
                ------------------------------
                              |
                              | Пёс Any переадресовывает запроc роуту с
                              | inner_uri == '/i1'
                              |
                              |
         -------  -------  ---------------------  -------  -------
    ...  | ... |  | ... |  | Роут с URI == /i1 |  | ... |  | ... |  ...
         -------  -------  ---------------------  -------  -------

    - По внешнему URI клиенты могут через Пса Any запрашивать документы.
    - Именно внешний URI мы будем менять через ЛК, если надо сменить URL док-та.
    - Внутренним будем считать URI всех роутов, находящихся ниже Пса Any.
    - Потому что прямо получить доступ к ним по этим URI нельзя - Пёс Any не пропустит.
    - Итак, роут с внут. URI == '/i1' получает запрос.
    - Например, это может быть обычный роут на callback:

        Route::get('/i1', function(){

          return 'Привет, Мир!';

        });

    - Или роут на метод обычного контроллера:

        Route::get('/i1', 'MyController@myMethod');

    - Или роут на REST-контроллер:

        Route::controller('/i1', 'MyRestController');


  > Динамический роутинг на REST-контроллерах
    - Допустим, решили делать всё на REST-контроллерах и динамическом роуте.
    - Тогда рекомендуемая структура папок:


      - controllers           - models                  - views
        - i1_controller.php     - m1_[имя модели].php     - layouts
        - i2_controller.php     - m1_[имя модели].php       - l1_layout.blade.php
        - i3_controller.php     - m1_[имя модели].php       - l2_layout.blade.php
        - i4_controller.php     - m2_[имя модели].php       - l3_layout.blade.php
        - i5_controller.php     - m2_[имя модели].php       ...
        - i6_controller.php     - m3_[имя модели].php     - docs
        ...                     ...                         - i1_document.blade.php
                                                            - i2_document.blade.php
                                                            - i3_document.blade.php
                                                            ...
                                                          - views
                                                            - v1_view.blade.php
                                                            - v2_view.blade.php
                                                            - v3_view.blade.php
                                                            ...
                                                          - errors
                                                            - e1_error.blade.php
                                                            - e2_error.blade.php
                                                            - e3_error.blade.php
                                                            ...


      - public
        - resources

          - library.js            - layouts       - docs           - views          - errors
          - global_lkgrumart.css    - l1_layout     - i1_document    - v1_view        - e1_error
                                      - [имя].css     - [имя].css      - [имя].css      - [имя].css
                                      - [имя].js      - [имя].js       - [имя].js       - [имя].js
                                      - [имя].js      - [имя].js       - [имя].js       - [имя].js
                                      ...             ...              ...              ...
                                      - [имя].png     - [имя].png      - [имя].png      - [имя].png
                                      - [имя].png     - [имя].png      - [имя].png    - [имя].png
                                      ...             ...              ...              ...

                                    - l2_layout     - i2_document    - v2_view      - e2_error
                                    - l3_layout     - i3_document    - v3_view      - e3_error
                                    ...             ...              ...            ...

    - Будем придерживаться принципа: 1 контроллер - 1 документ.
    - Вьюхи будем передавать в представления документов там, где это требуется.
    - В самой верхней части файла routes.php следует роут "Пёс Any":

        Route::any( '/{p1?}/{p2?}/{p3?}/{p4?}/{p5?}/{p6?}/{p7?}/{p8?}/{p9?}/{p10?}', function($p1='',$p2='',$p3='',$p4='',$p5='',$p6='',$p7 ='',$p8 ='',$p9 ='',$p10 = '')
        {

          // 1. Получить URI запроса без query string
          $outer_uri = Request::path();

          // 2. Извлечь из БД экз.модели по первич.ключу $outer_uri
          $page = Page::where('outer_uri', '=', $outer_uri)->first();

          // 3. Если ничего не найдено, вернуть Abort 404
          if(!isset($page)) App:abort('404');

          // 4. В противном случае:
          else {

            // 4.1. Создаём новый объект-запрос класса Request
            // - URI == $page->inner_url
            // - Метод запроса тот же, что у пришедшего от клиента Псу Any.
            // - Также передаём новому запросу веьс старый Input
            // - При желании можно также передать куки и файлы
            $request = Request::create($uri, Request::method(), Input::all());

            // 4.2. Отправляем запрос и возвращаем ответ
            return Route::dispatch($request)->getOriginalContent();

          }

        }

    - В файл filters.php, метод App::before(...) добавить обработчик ошибки 404.
    - Если Пёс Any не найдёт в БД соответствие запросу, он вызовет ошибку 404.
    - И этот обработчик её как раз и обработает.

        App::missing(function($exception)
        {
            return 'К сожалению, такого документа нет =)';
        });

    - В принципе, можно ещё добавить обработчик и других ошибок.
    - Если обработчик при возн. ошибки ничего не вернёт, laravel сам её обработает.

        App::error(function(Exception $exception, $code){

          // Будем обрабатывать только эти ошибки
          if ( ! in_array($code,array(401,403,500))){
             return;
          }

          // Допустим, у нас по URI == 'ierror_document' лежит документ для обработки ошибок
          $view = "ierror_document";

          // Допустим, этот массив данных мы хотим передать в документ
          $data = array('ivan' => 10);

          // Ловим ошибки и передаём во $view с данными $data
          switch ($code) {

             case 401:
             return Response::view($view, $data, $code);

             case 403:
             return Response::view($view, $data, $code);

             case 500:
             return Response::view($view, $data, $code);

          }
        }

    - Ну а ниже для каждого документа делаем роут на свой REST-контроллер.
    - По принципу 1 документ - 1 контроллер.
    - Обратите внимание, id контоллера == id документа.
    - Внут. URI контроллеров находятся не в иерарх.порядке, а в ряд.

        Route::controller('/i1', 'i1_controller');
        Route::controller('/i2', 'i2_controller');
        Route::controller('/i3', 'i3_controller');
        Route::controller('/i4', 'i4_controller');
        Route::controller('/i5', 'i5_controller');
        Route::controller('/i6', 'i6_controller');
        Route::controller('/i7', 'i7_controller');
        ...

    - Ну а вот как выглядит типичный REST-контроллер:

        class i1_controller extends BaseController {

          public function getIndex() {

            // GET-API1
            ...


            // GET-API2
            ...

            // ...
            ...

          }


          public function getIndex() {

            // POST-API1
            ...


            // POST-API2
            ...

            // ...
            ...

          }

          public function missingMethod($parameters = array()) {

            // Обработка запросов, не обработанных др.методами контроллера

          }
        }


А4. Управление конфигами приложения

  --------------------------------------
  Подоглавление:

    - Введение
    - Конфиг по умолчанию
    - Кастомные конфиги
    - Каждый конфиг имеет имя
    - Как указать приложению, при каких условиях какой конфиг использовать?
    - Как узнать, из какого конфига было создано приложение?
    - php artisan env - узнать имя текущей среды

  --------------------------------------

  > Введение
    - При каждом запросе создаётся новый экземпляр приложения Laravel.
    - Экземпляр конструируется на основе конфиг.объекта с настройками.
    - Существует конфиг "по умолчанию", но можно создавать и кастомные.
    - В разных условиях может понадобиться использовать разные конфиги.
    - Laravel позволяет гибко настроить, когда какой конфиг использовать.

  > Конфиг по умолчанию

    > Где хранится
      - В папке 'app/config'.

    > Какое имя имеет
      - Конфиг по умолчанию имеет имя "production".

    > Что из себя представляет
      - Конфиг.объект Laravel формирует из набора конфиг.файлов.
      - Каждый конфиг.файл содержит "тематические" настройки для приложения.
      - Вот стандартный набор конфиг.файлов:

        - app/config
          - app.php         | общие настроки
          - auth.php        | настройки аутентификации
          - cache.php       | настройки кэширования
          - compile.php     | тут можно встроить свои классы в приложение
          - database.php    | настрока взаим-ия с базами данных
          - mail.php        | почтовые настройки
          - queue.php       | настойка взаим-ия с сервисами очередей сообщений
          - remote.php      | настройка SSH (управление удал.сервером через Laravel)
          - services.php    | здесь можно хранить пароли и логины от разных сервисов
          - session.php     | настройка сессий
          - view.php        | настройка представлений
          - workbench.php   | настройка работы artisan workbench

  > Кастомные конфиги

    > Где хранятся?
      - В папках 'app/config/[имя кастомного конфига]'

    > Какие имена имеют?
      - Имя кастомного конфига совпадает с именем папки, в которой он.

    > Что из себя представляют?
      - Кастомный конфиг создаётся приложением таким образом:

        1) Создаёт конфиг.объект из конфига по умолчанию.
        2) Смотрит, какие конф.файлы есть в папке кастомного конфига.
          - КК может содержать от 0 конф. файлов.
          - В каждом конф.файле может быть указано от 0 настроке.
          - Т.О., КК вовсе не обязан содержать все файлы со всеми настройками.
          - Например, КК может содержать:

              app/config/myCustomConfig     app.php
                app.php                    -----------------

                                           <?php
                                             return array(
                                               'debug' => false
                                             );
                                           ?>

        3) Перезаписывает в созданном конф.объекте переданные в КК настрйки.

  > Каждый конфиг имеет имя

    > Имя конфига по умолчанию
      - Имеет имя 'production'

    > Имена кастомных конфигов
      - Их имена совпадают с именами папок, в которых они находятся.

    > Зачем конфигам имена?
      - Можно указывать приложению по имени, какой конфиг использовать.

  > Как указать приложению, при каких условиях какой конфиг использовать?
    - Указывать надо до того, как приложение запустилось.
    - Самое лучшее место для этого - файл 'bootstrap/start.php'.
    - Вот как можно указать имя конфига, который должно испольозвать приложение:

        $env = $app->detectEnvironment(function() {

            return '[здесь указать имя конфига]';

        });

    - Переменная $env получит строку с указанным в callback именем конфига.
    - Также есть возможность связать имя конфига с именем компьютера.
    - Ну типа, если имя компьютера 'A1', то используем конфиг 'C1'.
    - А если имя компьютера 'A2', то используем конфиг 'C2'.

        $env = $app->detectEnvironment(array(

          'C1' => array('A1'),
          'C2' => array('A2'),

        ));

  > Как узнать, из какого конфига было создано приложение?
    - Сделать это можно где угодно в приложении:

        $environment = App::environment();

  > php artisan env - узнать имя текущей среды
    - Это команда artisan, отображающая имя текущей среды.
    - Очень удобно.

        php artisan env




А5. Выполнение кода ДО и НА старте приложения

  --------------------------------------
  Подоглавление:

    - Введение
    - Код ДО старта приложения
    - Код НА старте приложения
    - Выполнение в зависимости от имени конфига

  --------------------------------------

  > Введение
    - Laravel позволяет исполнить произвольный код ДО и НА старте приложения.
    - Рассмотрим, как это делается на практике.

  > Код ДО старта приложения
    - Выполняется в файле: 'Laravel/bootstrap/start.php'.
    - Можно сюда добавить и свой код.
    - В основном эта возможность нужна нам, как пользователям,
      чтобы указать приложению имя конфига для использования.

  > Код НА старте приложения

    > Общая информация
      - К моменту выполнения этого кода приложение УЖЕ создано.
      - Сюда можно добавить код, который надо выполнять при каждом старте приложения.
      - К примеру, если приложение находится в режиме обслуживания (App::down),
        здесь самое место для того, чтобы вернуть запросу соотв. вьюху,
        где будет написано что-то вроде "извените, сайт на обслуживании".

    > Где находится
      - Находится в папке 'Laravel/app/public/start'.

  > Выполнение в зависимости от имени конфига

    > start/global.php
      - В этом файле код выполняется независимот от стартового конфига.

    > start/[имя стартового конфига].php
      - Здесь код выполняется в том случае, если имя стартового конфига
        равно имени этого файла.


А6. Режим обслуживания приложения

  --------------------------------------
  Подоглавление:

    - Введение
    - Включить режим обслуживания
    - Выключить режим обслуживания
    - Настройка роута для режима обслуживания

  --------------------------------------

  > Введение
    - Иногда нужно вырубить приложения, чтобы что-то в нём "допилить".
    - В Laravel есть удобный механизм для вкл/выкл "режима обслуживания".
    - При вкл. режиме обслуживания запрос просто направляется соотв. роуту.

  > Включить режим обслуживания
    - Можно такой командой artisan:

        php artisan down

  > Выключить режим обслуживания
    - Можно такой командой artisan:

        php artisan up

  > Настройка роута для режима обслуживания
    - Запрос надо перехватывать ещё ДО создания экземпляра приложения.
    - Тут у нас один вариант - в файле 'Laravel/bootstrap/start.php'.
    - Добавляем в него вот такой роут:

        App::down(function()
        {
            return Response::view('[имя представления]', array(), 503);
        });

    - Он перехватывает все запросы к приложению в режиме обслуживания.
    - Для режима обслуживания можно создать отдельное представление.
    - Которое и будет сообщать посетителю, что, мол, приложение сейчас
      в режиме обслуживания, извините.


А7. Фильтры для запросов

  --------------------------------------
  Подоглавление:

    - Введение
    - Что из себя представляет фильтр
    - Глобальные фильтры

  --------------------------------------

  > Введение
    - Запрос можно пропускать через фильтры.
    - О них и пойдёт речь.

  > Что из себя представляет фильтр
    - Это callback, в который попадает запрос.
    - Можно с этим запросом сделать что угодно, и отправить дальше.
    - Можно выполнить любой доп.код.

  > Глобальные фильтры

    > Что такое:
      - Глобальные фильтры - которые работают на уровне всего приложения.

                                ------------    ------------    ------------
        --------    --------    |Глобальный|    |          |    |Глобальный|    --------
        |Клиент| -> |Запрос| -> |before    | -> |приложение| -> |after     | -> |Клиент|
        --------    --------    |фильтр    |    |          |    |фильтр    |    --------
                                ------------    ------------    ------------

    > Какие бывают

      1) After    | ловит запрос НА старте приложения
      2) Before   | ловит запрос в самом конце выполнения приложения

    > Как назначить

      > Где назначить?

        1) В файле "app/filters.php"
          - Там по умолчанию даже есть заготовки для before и after фильтров.

        2) В одном из файлов папки "app/start".
          - Например, в global.php.

        3) В файле "bootstrap/start.php"

        4) Создать свой service provider, и в нём назначить.

      > Как назначить глобальный before фильтр

          App::before(function($request)
          {
              //
          });

      > Как назначить глобальный after фильтр

          App::after(function($request, $response)
          {
              //
          });

  > Фильтры роутеров
    - Принцип работы такой же, как у и глобальных фильтров.
    - Создать новый фильтр можно в следующих местах:

      - В routes.php
      - В filters.php

    - Создать новый фильтр можно следующим образом:

      - Фильтр с callback-функцией

          Route::filter('myFilter1', function()
          {
              //
          });

      - Фильтр с методом filter класса yyy

          Route::filter('myFilter2', 'yyy');

      - Фильтр с методом xxx класса yyy

          Route::filter('myFilter3', 'yyy@xxx');

    - Как назначить фильтр роуту/группе можно так:

        // Назначение фильтров группе
        Route::group(array('before' => 'myFilter1', 'after' => 'myFilter2'), function()
        {

          // Назначение фильтров роуту на callback
          Route::get('/', array(  'before' => 'myFilter1',
                                  'after' => 'myFilter2',
                                  function() {

          }));

          // Назначение фильтров роуту на метод контроллера
          Route::get('/user', array(  'before' => 'myFilter1',
                                      'after' => 'myFilter2',
                                      'uses' => 'UserController@showProfile'));

        });

    - Назначить фильтр напрямую роуту на REST-контроллер нельзя.
    - Вместо этого предлагается поместить REST-контроллер в группу, а ей уже назначить.
    - Например:

        Route::group(array('before' => 'myFilter1'), function()
        {
            Route::controller('/users', 'I1_controller');
            Route::controller('/events', 'I2_controller');
        });

    - А назначить, скажем, 2 before-фильтра можно так:

        Route::group(array('before' => array('myFilter1', 'myFilter2')), function()
        {
            Route::controller('/users', 'I1_controller');
            Route::controller('/events', 'I2_controller');
        });

    - Ещё про фильтры можно почитать в "Справочник классов/1. Route".


А8. Ошибки и логи

  --------------------------------------
  Подоглавление:

    - Введение
    - Ведение лога
    - Обработка ошибок

  --------------------------------------

  > Введение
    - Обсудим здесь, как в Laravel работать с ошибками, вести лог.

  > Ведение лога
    - В Laravel 'из коробки' встроен Monolog.
    - По умолчанию он пишет лог в 1 файл:

        "app/storage/logs/laravel.log"

    - А что, если мы хотим, чтобы каждый день лог писался в новый файл?
    - Тогда в "bootstrap/start.php" надо добавить следующее:

        $logFile = 'laravel.log';
        Log::useDailyFiles(storage_path().'/logs/'.$logFile);

    - Laravel автоматом добавляет в лог всякие warnings и errors.
    - Но можно добавлять их и самому, в т.ч. в отладочных целях.
    - Делать это можно так:

        Log::error('Моё сообщение');
        Log::warning('Моё сообщение');
        Log::info('Моё сообщение');

    - Есть ещё зоопарк способов добавить запись в лог. О них здесь:


  > Обработка ошибок

    > Общая информация
      - Для обработки ошибок можно назначить функции-обработчики.
      - Делать это надо либо до запуска приложения, либо на его старте.

    > Если обработчик не вернёт значение, то ошибку обработает Laravel.
      - ... стандартным образом.

    > Варианты, где можно назначить эти обработчики:

        1. "bootstrap/start.php" - до запуска приложения.
        2. "app/start/global.php" - на старте приложения для любой среды
        3. "app/start/[имя].php" - на старте приложения для среды [имя]
        4. "app/filters.php" в App::before фильтре.
        5. В любом service provider'e, можно сделать отдельный, для ошибок.

    > Есть 3 варианта обработчиков:

      1) App::error
        - Ловит и обрабатывет ВСЕ ошибки.
        - Для примера, напишем обработчик, который отловит 401, 403, 404, 500:

            App::error(function(Exception $exception, $code){

              // Будем обрабатывать только эти ошибки

                if (!in_array($code, array(401, 403, 404, 500))){
                   return;
                }


              // Добавим в лог запись об ошибке

                Log::error('Произолша ошибка, код: '.$code);


              // Допустим, у нас по URI == '/error' доступен документ для обработки ошибок

                $view = "/error";


              // Допустим, этот массив данных мы хотим передать в документ

                $data = array('ivan' => 10);


              // Ловим ошибки и передаём во $view с массивом $data
              switch ($code) {

                 case 401:
                 return Response::view($view, $data, $code);

                 case 403:
                 return Response::view($view, $data, $code);

                 case 404:
                 return Response::view($view, $data, $code);

                 case 500:
                 return Response::view($view, $data, $code);

              }
            }

      2) App::missing
        - Тоже самое, что и App:error.
        - Но ловит только одну лишь ошибку 404
        - Пример:

            App::missing(function($exception) {

              // Добавим в лог запись об ошибке

                Log::error('Произолша ошибка, код: '.$code);


              // Допустим, у нас по URI == '/error' доступен документ для обработки ошибок

                $view = "/error";


              // Допустим, этот массив данных мы хотим передать в документ

                $data = array('ivan' => 10);


              // Вернуть документ $view, к котором можно сообщить об ошибке
                return Response::view($view, $data, 404);

            });

      3) App::error
        - Для обработки фатальных ошибок.
        - Работает аналогично, как и вышеописанные два.

    > Сгенерировать ошибку можно и вручную:

        App::abort('404');




А9. Как пользоваться Service providers

  --------------------------------------
  Подоглавление:

    - Введение
    - История и изначальное предназначение "поставщиков сервисов".
    - Могут исполнять любой код
    - Создание своего поставщика
    - Возможность подключения поставщика во время выполнени приложения

  --------------------------------------

  > Введение
    - Фраза "service providers" переводится, как "поставщик сервисов".
    - Функционал позволяет запускать желаемые php-файлы на старте приложения.

  > История и изначальное предназначение "поставщиков сервисов".

    #
      - В Laravel можно устанавливать различные дополнения.
      - Для них выделена отдельная папка: "Laravel/vendor".

    #
      - При установке доп-ия надо как-то интегрир-ть его функц-ал в приложение.
      - Обычно, надо добавлять функционал доп-ия в IoC-контейнер приложения.
      - Действия по интеграции надо выполнять НА старте приложения.
      - Это, конечно, можно делать в файле start/global.php.
      - Но тогда этот файл разрастётся, и это будет плохо и не удобно.

    #
      - Поэтому решили для интергации каждого приложения делать отдельные файлы.
      - И сделали механизм, который запускает такие файлы НА старте приложения.
      - Каждый такой файл договорились называть "Service Provider".

  > Могут исполнять любой код
    - Поставщики можно использовать не только для интеграции сервисов.
    - Ведь они исполнят любой код, какой им не передашь.
    - Например, в поставщике можно:

      - Осуществлять регистрации в IoC-контейнер.
      - Осуществлять аутентификацию.
      - Проводить какие-либо действия с базой данных.
      ...

  > Создание своего поставщика
    - Создадим своего поставщика, в котором добавим переменную в IoC.
    - Для начала создадим новую папку, в которой будут храниться поставщики.
    - Это может быть какая угодно папка, где угодно в приложении.

        Laravel/app/sproviders

    - Теперь добавим в composer.json проекта путь к этой папке:

        ...
        "autoload": {
          "classmap": [

            ...
            "app/sproviders"

          ]

        },
        ...

    - Теперь создадим наш поставщик: "Laravel/app/sproviders/test.php"
    - Будем использовать для него пространство имён MyProviders.
    - Внутри добавим в IoC переменную youpicaey со значением 123.

        test.php
       --------------------------------
        <?php namespace MyProviders;


        use Illuminate\Support\ServiceProvider;

        class test extends ServiceProvider {

          public function register() {

            $this->app->bind('youpicaey', function() {
              return 123;
            });

          }
        }

    - Теперь зарегистрируем наш поставщик в приложении.
    - Это можно сделать в конфиге "app/config/app.php".
    - В настройке 'providers' надо добавить путь к test.php с учётом пр.имён:

        'providers' => array(

          ...
          'MyProviders\test',

        ),

    - И наконец, надо обновить связи композера.
    - Для этого в корне Laravel надо выполнить следующую команду:

        composer dump-autoload

    - Теперь проверим работоспособность нашего поставщика:

        Route::get('/test', function(){

          echo App::make('youpicaey');

        });

  > Возможность подключения поставщика во время выполнени приложения
    - Поставщика можно подключить к приложению прямо во время его выполнения.
    - Вот так:

        App::register('FooServiceProvider');


А10. Как сделать аутентификацию и авторизацию

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Декомпозиция

  --------------------------------------

  > Ссылки

      - Статья "Классификация механизмов аутентификации пользователей и их обзор" (habr):
          http://habrahabr.ru/post/177551/

      - Статья "OAuth 2.0 простым и понятным языком" (habr):
          http://habrahabr.ru/company/mailru/blog/115163/

      - Статья про аутентификацию в wiki:
          https://ru.wikipedia.org/wiki/Аутентификация

      - Статья про авторизацию в wiki:
          https://ru.wikipedia.org/wiki/Авторизация

      - Статья о безопасности способов восстановления пароля, на habr:
          http://habrahabr.ru/post/167013/


  > Введение
    - Аутентификация: выяснение, кто зашёл на сайт, и знает ли его сайт.
    - Авторизация: выдача прав доступа аутентифицированному пользователю.
    - Чаще всего аутентификация и авторизация проходят одновременно.
    - В этой граве рассмотрим общие принципы аутентификации и авторизации.
    - А также, каким образом их можно реализоваь на практике в Laravel.

  > Декомпозиция

    А10.Как сделать аутентификацию и авторизацию
      A10.1.  Общие принципы аутентификации
        - Термин "аутентификация" от английского "authentic" - истинный.
        - Суть в том, что одна сторона удостоверяет подлинность другой.
        - В главе описаны генезис, принципы работы и даны примеры.

      А10.2.  Общие принципы авторизации
        - Термин "авторизация" от англ. "authorisation" - разрешение.
        - Авторизацию можно проводить лишь после аутентификации.
        - Если мы знаем, кто перед нами, то мы знаем, что ему можно доверить.
        - Т.Е. для каждого аутентиф.субъекта должны быть назначены свои права.
        - Суть авторизации в назначении прав аутентифицированным пользователям.

      А10.3.  Организация системы аутентификации интернет-магазина
        - Единственно-верной системы аутентификации (САУ) не существует.
        - Как делать систему аутентификации, зависит от конкретного проекта.
        - В этой главе обсуждается, как делать САУ для интернет-магазина.


  > A10.1.  Общие принципы аутентификации

    --------------------------------------
    Подоглавление:

      - Введение
      - Типовые элементы системы аутентификации
      - Какие бывают факторы аутентификации
      - N-факторная аутентификация
      - Что такое аутентификация вообще
      - Примеры
      - Основной и резервные механизмы аутентификации

    --------------------------------------

    > Введение
      - Термин "аутентификация" от английского "authentic" - истинный.
      - Суть в том, что одна сторона удостоверяет подлинность другой.
      - В главе описаны генезис, принципы работы и даны примеры.

    > Что такое аутентификация вообще

      > Генезис термина
        - Термин "аутентификация" происходит от английского "authentication".
        - Перевод "authentic" - истинный, настоящий, подлинный, неподдельный.
        - Перевод "authentication" - опознание, удостоверение подлинности.

      > Типовые элементы системы аутентификации

          1. Аутентификатор (хозяин)
            - Тот, кто аутентифицирует аутентифицируемого.
            - Хозяин системы аутентификации.

          2. Аутентифицируемый
            - Тот, кого аутентифицирует аутентификатор.
            - Субъект, который будет проходить процедуру аутентификации.

          3. Аутентификационные данные
            - Некий набор данных.
            - В нём субъекты сопоставляются с их факторами (характеристиками).

          4. Фактор (характеристика)
            - Отличительная черта субъекта.
            - Предполагается, что этим обладает лишь данный конкретный субъект.

          5. Механизм аутентификации
            - Принцип работы системы аутентификации.

          6. Механизм управления доступом (авторизация)
            - Какие права доступа имеет каждый аутентифицированный субъект?
            - Вообще, такой механизм наделения правами называют авторизацией.

      > Какие бывают факторы аутентификации

          # Фактор знания: "то, что ты знаешь"
            - Пароль, секретное слово, секретный ответ на вопрос и т.д.

          # Фактор владения: "то, чем ты владеешь"
            - SMS-аутентификация через принадлежащий номер телефона.
            - USB-токен, банковская карта, и т.д.

          # Фактор принадлежности: "то, чем ты являешься"
            - Лицо, отпечатки пальцев, сетчатка глаза.

      > N-факторная аутентификация
        - Когда для аутентификации субъекта используется N факторов.
        - Например, 2-факторная: одновременно через пароль и SMS.

      > Что такое аутентификация вообще

        > Короткое определение
          - Процедура проверки подлиности субъекта хозяином.

        > Как это происходит

          1. Субъект посылает хозяину свой(и) фактор(ы).
          2. Хозяин ищет в аутентификационных данных учётную запись,
             соответствующую предъявленному(ым) субъектом фактору(ам).
          3. Хозяин заканчивает поиски и получает результат. Тут 2 варианта:
            - Если нашёл: значит аутентификация прошла успешно.
            - Если не нашёл: значит аутентификация не удалась.
          4. Аутентификатор сообщает аутентифицируемому результат.

                                       Аутентификационные данные
            ----------------    2     |------------------|
            |Аутентификатор| -------> | Login   Password |
            ----------------          |                  |
              /|\ |     /|\    3      | Иван     1234    |
               |  |      ------------ | Пётр     4534    |
              1|  |4                  | Николай  45654   |
               |  |                   | ...              |
               |  |                   |                  |
               | \|/                  |------------------|
             -------------------
             |Аутентифицируемый|
             -------------------

      > Примеры

        # 1: охранник на проходной, и посетитель

            1. Хозяин: охранник.
            2. Субъект: посететиель.
            3. Аутентификационные данные:
              - Журнал охранника, сопоставляющие ФИО и паспортные данные.
              - Например:

            Номер   Имя    Паспорт   Права
            ----------------------------------------------------------------
            1       Пётр   1234      Может пройти в фирмы "Ромашка" и "Клубничка"
            2       Вася   5678      Может пройти на завод
            3       Маша   0643      Может приходить чинить электрику
               ...

            ----------------------------------------------------------------

            4. Фактор
              - Паспортные данные.
            5. Механизм аутентификации
              - Субъект предъявляет паспортные данные хозяину.
              - Хозяин ищет соответствующую учётную запись в журнале.
            6. Механизм управления доступом (авторизация)
              - Для каждого субъекта в журнале указаны его права.
              - После аутентификации охранник наделит ими субъект.


        # 2: Иван и прохожий

            1. Хозяин: Иван.
            2. Субъект: идущий навстречу прохожий.
            3. Аутентификационные данные:
              - Иван помнит всех своих знакомых в лицо.
            4. Факторы
              - Лицо
              - Телосложение
            5. Механизм аутентификации
              - Хозяин осматривает субъекта, его лицо и телосложение.
              - Хозяин либо узнаёт его, либо не узнаёт.
            6. Механизм управления доступом (авторизация)
              - Разным знакомым Иван готов позволить разные вещи.
              - После аутентификации Иван наделит субъекта соотв. правами.

        # 3: домофон

            1. Хозяин: домофон и хозяин квартиры.
            2. Субъект: звонящий по домофону человек.
            3. Аутентификационные данные:
              - Хозяин квартиры помнит голоса всех своих знакомых.
            4. Факторы
              - Голос
            5. Механизм аутентификации
              - Хозяин слушает голос говорящего в домофон субъекта.
              - Хозяин либо узнаёт его, либо не узнаёт.
            6. Механизм управления доступом (авторизация).
              - Если хозяин узнал голос, то впускает субъекта.
              - Если хозяин не узнал голос, то не впускает субъекта.

        # 4: замок

            1. Хозяин: замок
            2. Субъект: человек, который хочет открыть замок
            3. Аутентификационные данные:
              - Замок помнит, как выглядит сетчатка глаз ряда субъектов.
            4. Факторы
              - Сетчатка глаза
            5. Механизм аутентификации
              - Хозяин считывает сетчатку глаза субъекта.
              - Затем он сверяет считанные данные со своей базой данных.
            6. Механизм управления доступом (авторизация)
              - Если хозяин узнал сетчатку, то отпирает замок.
              - Если хозяин не узнал сетчатку, то не отпирает замок.

        # 5: интернет-приложение

            1. Хозяин: интернет-приложение
            2. Субъект: посетитель
            3. Аутентификационные данные:
              - Таблица users. Например:

                id    login   password   privs
              ----------------------------------------
                1     Petro   1234       {...}
                2     Vasya   5678       {...}
                3     Masha   0643       {...}
                          ...
              ----------------------------------------

            4. Факторы
              - Пароль
            5. Механизм аутентификации (здесь описан схематично):
              - Заходит пользователь на сайт.
              - Сайт смотрит у него аутентификационную куку.
              - Если кука есть, то извлекает из неё id пользователя.
                - По id находит учётку в users и авторизует пользователя.
              - Если куки нет, то ждёт ввода пароля.
              - Пользоатель вводит логин и пароль.
              - Сайт ищет учётку с такими паролем и логином в users.
              - Если находит, то аутентифицирует пользователя.
              - Если не находит, то не аутентифицирует.
            6. Механизм управления доступом (авторизация):
              - В users есть столбец privs.
              - В нём указаны права доступа для каждого пользователя.

    > Основной и резервные механизмы аутентификации

      > Введение
        - В системе аутентификации может быть более 1 механизма аутентификации.
        - Бывает, что субъект не может аутентифицироваться основным механизмом.
        - Поэтому, для надёжности, должны быть 1 или более резервных механизмв.

      > Основной и резервные механизмы
        - У каждого из механизмов есть приоритет.
        - Механизм с самым высоким приоритетом применяется первым.
        - Основной механизм - у которого самый высокий приоритет.
        - Резервные механизмы - все, кроме основного.

      > Примеры

        # 1: охранник на проходной, и посетитель
          - Продолжим рассматривать данный пример.
          - Что, если у охранника в журнале нет записей о субъекте?
          - А субъект при этом уверен, что запись быть должна?
          - Тогда в силу вступает резервный метод аутентификации:

            1. Хозяин: фирма "Ромашка" и охранник
            2. Субъект: посетитель
            3. Аутентификационные данные:
              - Информация у фирмы "Ромашка".
              - В фирме знают, кто их сегодня должен посетить.
            4. Фактор: ФИО
            5. Механизм аутентификации
              - Охранник звонит в "Ромашку" и говорит ФИО субъекта.
              - Из "Ромашки" отвечают, пропускать его или не пропускать.
            6. Механизм управления доступом (авторизация):
              - Если пропускать, то охранник вносит субъекта в журнал и пропускает.
              - Если непропускать, то не пропускает.

        # 5: интернет-приложение
          - Что, если пользователь забыл пароль?
          - Тогда у него должны быть резервные методы, чтобы авторизоваться.
          - Такие как:
            - Восстановление пароля.
            - Секретный ответ на вопрос
            - Секретное слово


  > А10.2.  Общие принципы авторизации

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры

    --------------------------------------

    > Введение
      - Термин "авторизация" от англ. "authorisation" - разрешение.
      - Авторизацию можно проводить лишь после аутентификации.
      - Если мы знаем, кто перед нами, то мы знаем, что ему можно доверить.
      - Т.Е. для каждого аутентиф.субъекта должны быть назначены свои права.
      - Суть авторизации в назначении прав аутентифицированным пользователям.

    > Примеры
      - Рассмотрим подробнее авторизацию в примерах из А10.1.

      # 1: охранник на проходной, и посетитель
        - У охранника есть журнал (аутентификационные данные).
        - В нём для каждого субъекта указаны права.
        - Охранник наделяет субъект соотв. правами, если он пройдёт аутентификацию.

      # 2: Иван и прохожий
        - Иван разным своим знакомым позволяет разные вещи.
        - Например, с незнакомцем Иван говорить не будет, а со знакомым будет.
        - Иван, аутентифицировав незнакомца, наделит его соотв. правами.

      # 3: домофон
        - Хозяин квартиры впускает в дом только тех, кого он ждёт.
        - Незнакомцев он пускать не собирается.
        - Если хозяин узнает звонящего по голосу, то наделит его правом пройти.
        - А если не узнает, то не наделит.

      # 4: замок
        - Замок может быть открыт только подходящим ключём.
        - Если ключ подходит, субъект получит право открыть дверь.
        - Если ключ не подходит, то замок не откроется.

      # 5: интернет-приложение
        - В нём есть таблица users, с информацией о польозвателях.
        - Для каждого пользователя указаны права в приложении.
        - Авторизованные пользователи получают соотв. права.

  > А10.3.  Организация системы аутентификации интернет-магазина

    --------------------------------------
    Подоглавление:

      - Введение
      - Обсуждения

    --------------------------------------

    > Введение
      - Единственно-верной системы аутентификации (САУ) не существует.
      - Как делать систему аутентификации, зависит от конкретного проекта.
      - В этой главе обсуждается, как делать САУ для интернет-магазина.

    > Обсуждения

      # Тема: Регистрация должна быть ненавязчивой доп.функцией ИМ
        - Пользователь приходит в ИМ чтобы покупать, а не чтобы регистрироваться.
        - Он должен иметь возможность комфортно пользоваться ИМ без регистрации.
        - И лишь если вдруг он специально захочет, то зарегистрироваться.

      # Тема: Ненавязчивый и незаметный для него сбор информации пользователе
        - Должен постоянно проводитьсья системой.
        - И этими данными следует дополнять учётку пользователя в users.
        - С их помощью можно будет облегчать ему пользование магазином.
        - Например, подставлять при оформлении заказа ранее использованные данные.

      # Тема: Риск потери собранных данны о пользователе
        - Аутентификация анонимусов производится с помощью вечной куки.
        - Кука хранится в конкретном браузере пользователя.
        - Она может потерятсья, он может зайти из др.браузера или с др.компа.
        - Чтобы MIN-ть риск утери данных, надо MAX-ть кол-во зарегистрированных.
        - Поскольку зарегистрированные пользователи не подвержены этому риску.
        - Т.Е. надо хитрым образом стараться зарегистрировать каждого 1-го.

      # Тема: Реализация аутентификации для не зарегистрированных пользователей
        - Она реализуется с помощью "бесконечной" (действует 5 лет) куки.

      # Тема: Неужели проводить аутентификацию по куке при каждом запросе?
        - Т.Е. при каждом HTTP-запросе пользователя лезть в БД?
        - В таком случае нагрузка на базу данных будет очень велика.
        - Поэтому так поступать не следует.
        - Надо проводить аутентификацию 1 раз в N минут.
        - А в течение этих вот N минут считать этого пользователя аутентифицированным.
        - А информацию о том, что польз.аутентиф-ан хранить в сессии.

      # Тема: Где хранить сессии?
        - Предположим, что мы будем хранить сессии в БД.
        - В этом случае при каждом HTTP-запросе пользователя будет обращение к БД.
        - Это будет очень медленно, и очень сильно будет её тормозить.
        - Поэтому сессии следуте хранить в быстром key-value хранилище.
        - Laravel поддерживает 3 варианта: APC, memcached и redis.
        - Я склоняюсь к redis.
        - В нём можно хранить массивы, доступны операции push, pop и т.д.
        - Он хранит данные как в оперативке, так и на диске (если нет памяти).
        - Плюс говорят, он самый быстрый.
        - Сайт: http://redis.io/

      # Тема: Для посетителей и работников - разные механизмы аутентификации
        - Вообще то авторизация для сотрудников и посетителей должна отличаться.
        - Для посетителей упор идёт на удобство и не навязчивость.
        - Для работников упор идёт на MAX защищённость данных.
        - Но для начала можно сделать для них одну и ту же авторизацию.
        - Такую, которая рассчитана на посетителей.
        - А потом уже усилить авторизацию для сотрудников, увеличив безопасность.

      # Тема: Какие механизмы аутентификации надо задействовать для посетителей?

        1. Аутентификация по вечной и сессионной кукам
          - Это основной механизм аутентификации посетилелей.
          - Сначала он ищет у посетителя сессионную куку.
            - Если находит, то:
              - Ищет сессию с таким ID в Redis.
              - Если находит, то аутентифицирует пользователя.
              - Заменяет пользователю сессионную куку и её ID в Redis.
                - Для профилактики от атаки с фиксацией сессии.
              - Аутентификация завершена.
          - Если не находит, то ищет вечную куку:
            - Если находит, то:
              - Ищет ID вечной куки в БД в таблице пользователей.
              - Если находит, то аутентифицирует пользователя.
              - Создаёт новую сессию в Redis и посылает пользователю сес.куку.
              - Перезаписывает пользователю куку с теми же ключём и значением.
                - Чтобы обновить её срок годности.
                - "Вечная" кука на самом деле годна в течение 5 лет.
              - Аутентификация завершена
            - Если не находит, то:
              - Создаёт в БД в табл.пользователя нового пользователя.
              - Посылает пользователю вечн.куку, и добавляет её ID в таблицу.
              - Создаёт новую сессию в Redis и посылает пользователю сес.куку.
              - Аутентификация завершена.

        2. Аутентификация через ввод логина/пароля.
          - Это дополнительный механизм аутентификации пользователей.
          - Он нужен только для зарегистрированных пользователей.
            - Бывает, что такой пользователь потерял свою вечную куку.
            - Или зашёл с другого браузера/компьютера.
            - Но при этом он хочет аутентиф-ся по той своей учётной записи.
          - Тогда он может ввести логин и пароль:
            - Система в табл.польз. находит польз. с такими логином и паролем.
            - Заменяет польз. вечную куку, на куку с ID найденного пользователя.
            - Создаёт новую сессию в Redis и посылает пользователю сес.куку.
            - Аутентификация завершена.

        3. Механизм сброса пароля
          - Это дополнительный механизм аутентификации пользователей.
          - Он нужен для зарег.польз-ей, которые забыли пароль.
          - Есть несколько вариантов этого механизма:
            1) Контрольный вопрос-ответ.
            2) Уникальная ссылка на email.
            3) Отправка нового (действующего) пароля на email
            4) Отправка нового (действующего) пароля в СМС

          - Способ №2 оптимален по простоте реализации и безопасности.
          - Его и рассмотрим:
            - Если пользователь забыл пароль, и не может аутентифицировться.
            - Он вводит в спец. поле указанный при регистрации email.
            - Производится поиск пользователя с таким email в БД.
            - Если такой пользователь не найден:
              - Пользователю при этом показывают текст:
                - Что он должен получить письмо со ссылкой на указанном email.
                - И перейти по ссылке. А ссылка действует в течение 5 минут.
                - Этот текст не отличается от того, что был бы показан, если
                  бы пользователь был найден.
                - Это не позволит злоумышленникам путём перебора узнать, какие
                  email's есть в БД.
            - Если такой пользователь найден:
              - Пользователю при этом показывают текст:
                - Что он должен получить письмо со ссылкой на указанном email.
                - И перейти по ссылке. А ссылка действует в течение 5 минут.
                - Этот текст не отличается от того, что был бы показан, если
                  бы пользователь был найден.
                - Это не позволит злоумышленникам путём перебора узнать, какие
                  email's есть в БД.
              - "За кулисами" производятся следующие действия:
                - Случайным образом генерируется строка из 20 символов.
                - Строка и текущая datetime сохраняются в таблицу пользователя.
                - Пользователю на email посылается письмо:
                  - В письме детально описывается, что происходит.
                  - Указано, что не надо нажимать на ссылку, если это не он меняет пароль.
                  - И дана ссылка на публичный API, созданный для сброса паролей.
                  - В query string этой ссылки записаны те случайные 20 символов.
              - Когда пользователь нажимает на эту ссылку, происходит следующее:
                - У него в браузере открывается документ по ссылке.
                - Сервер извлекает из ссылке query string.
                - В табл.поль-ей в БД он ищет такого пользователя:
                  - У которого в соотв.стоблце хэш строки с помощью bcrypt ..
                  - .. равен этой query string.
                - Если такой пользователь не найден, то:
                  - Показать сообщение о том, что ссылка истекла.
                - Если такой пользователь найден, то:
                  - Проверить указанное в таблице пользователей время.
                    - Если прошло более максимальных N минут, то:
                      - Пользователю выдаётся сообщение о том, что время истекло.
                      - И что он может заказать новую ссылку таким же образом.
                    - Если прошло менее максимальных N минут, то:
                      - Пользователю предлагагается ввести новый пароль 2 раза.
                      - После ввода он может нажать на кнопку OK.
                      - Старый пароль пользователя заменяется новым паролем.

      # Как защититься от подделки куки
        - Laravel обладает встроенным механизмом защиты кук от подделок.
        - Созданные им куки шифруются, и подписываюся аутентифик-ым кодом.
        - Если злоумышленник изменит куку, Laravel об этом узнает.
        - Подделаные куки Laravel считает недействительными.

      # Тема: Ресурсы для рассмотренных выше 3-х механизмов аутентификации

        1. Аутентификация по вечной и сессионной кукам

          1) Работающий механизм сессий через Redis.
          2) Таблица пользователей в базе данных.

        2. Аутентификация по вечной и сессионной кукам
           (дополнительно к 1)

          1) Интерфейс для ввода и отправки логина и пароля.
          2) API для приёма запроса и аутентификации

        3. Механизм сброса пароля
           (дополнительно к 1 и 2)

          1) Интерфейс для ввода email для восстановления пароля.
          2) API для приёма запроса при переходе по ссылке в письме.


А11. Хэширование данных с помощью bcrypt

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Про хэширование в общем
    - Про расшифровку хэшей радужными таблицами
    - Класс Hash в Laravel

  --------------------------------------

  > Ссылки

    - Статья "Безопасное хранение паролей" на хабре про bcrypt:
        http://habrahabr.ru/post/159043/

    - Статья "Как надо хэшировать пароли, а как не надо" на хабре про bcrypt:
        http://habrahabr.ru/post/210760/

    - Статья про радужные таблицы и взлом хэшей:
        http://habrahabr.ru/post/130965/

    - Статья "криптостойкость 1000-кратного хэшированного пароля"
        http://habrahabr.ru/post/100301/

    - Статья "Хэширование" на wiki:
        https://ru.wikipedia.org/wiki/Хеширование

  > Введение
    - Часто может требоваться захэшировать какие-либо данные.
    - Хэш-функции md5 и sha-1 признаны не надёжными, лучше от них отказатсья.
    - Вместо них рекомендуется использовать хэш-фукнцию bcrypt.
    - О ней, и как её использовать в Laravel, и идёт речь в этой главе.

  > Про хэширование в общем

    > Общее
      - Хэширование - процесс одностороннего преобразование входных данных
        в выходную строку заданной длины.
      - Хэш-функция: выполняющая процесс хэширования.
      - Хэш - строка, результат работы хэш-функции.
      - Хэш-функция всегда выдаёт один и тот же хэш для одних и тех же данных.
      - Хэш не даёт даже намёка о том, что из себя представляли исходные данные.
      - Предполагается, что обратно получить из хэша исходные данные нельзя.

    > Криптографические хэши
      - Существуют криптографические и нет хэш-функции.
      - К криптографическим относятся: md5, sha-1, bcrypt и т.д.
      - К не крпитографическим: функции для создания контрольных сумм и т.д.
      - Криптографические хэши отличаются следующим:

        # Необратимость
            Для заданного хэша m должно быть вычислительно
            неосуществимо найти блок данных X, для которого H(X) == m.

        # Стойкость к коллизиям 1-го рода
            Для заданных данных М должно быть вычислительно
            неосуществимо подобрать другие данные N != M, для для которых
            H(N) == H(m)

        # Стойкость к коллизиям 2-го рода
            Должно быть вычислительно неосуществимо подобрать пару
            данных M и N, имеющих одинаковый хэш.

    > Зачем нужно
      - Например, надо нам сохранит пароль "ivan1234" в базе данных.
      - А пароль этот принадлежит пользователю Ивану.
      - Можно хранить пароль в открытом виде, прямо так: "ivan1234".
      - Но тогда его могут украсть: админ, взломать базу и т.д.
      - И злоумышленник по этому паролю сможет авторизваться, как Иван.
      - Чтобы этого не произошло, лучше не хранить пароль в открытом виде.
      - А хранить хэш пароля.
      - Если злоумышленник получит хэш, он не сможет узнать пароль.
      - Конечно, он может попытаться взломать хэш, чтобы узнать пароль.
      - Но взломать bcrypt сегодня мегасложно.
      - Вот Иван хочет авторизоваться, и вводит свой пароль.
      - Мы хэшируем этот пароль и сравниваем результат с хэшем в базе.
      - Если совпадает, то авторизуем Ивана.


  > Про расшифровку хэшей радужными таблицами
    - Злоумышленник заранее составляет таблицу "пароль" - "хэш".
    - Затем, допустим, он украл хэш пароля какого-нибудь пользователя.
    - И может за пару секунд найти его в этой радужной таблице.
    - Радужная таблица может быть гигантской - терабайты информации.
    - В сети открыто валяются радужные таблицы по популярным хэщ-функциям.

  > Класс Hash в Laravel

    > Как работает
      - Для хэширования использует php-функцию password_hash.
      - password_hash($value, PASSWORD_BCRYPT, array('cost' => $cost)).
      - Подробнее о ней в официальной справке php:
          http://nl1.php.net/manual/en/function.password-hash.php

    > Функционал

        # Захэшировать пароль функцией bcrypt

          $password = Hash::make('secret');

        # Сравнить строку и захэшированный пароль
          - Допустим, пользователь решил авторизоваться в приложении.
          - И он ввёл пароль.
          - А у нас в базе сохранён пароль в виде хэша.
          - Надо же теперь как то их сравнить, чтобы определить, правильный
            ли пароль ввёл пользователь?

          if (Hash::check('secret', $hashedPassword)) {
              // The passwords match...
          }

        # Проверить, требуется ли перехэшировать пароль
          - [Видимо бывают случаи, когда требуется...]

          if (Hash::needsRehash($hashed) {
              $hashed = Hash::make('secret');
          }


А12. Использования key-value хранилища Redis

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Настройка Redis в Laravel
    - Использования Redis в Laravel
    - Примечание по поводу пароля Redis
    - Внимание! Почему Redis может не работать в Laravel
    - В Windows удобно сделать автозапуск Redis при запуске Windows

  --------------------------------------

  > Ссылки

    - Официальный сайт Redis
        http://redis.io/

  > Введение
    - Реляционная база данных является довольно медленной вещью.
    - Для ускорения работы приложения, ему требуется более быстое хранилище.
    - Таким хранилищем может стать NoSQL БД, или key-value хранилище.
    - Есть много реализаций таких хранилищь, но здесь речь пойдёт о Redis.
    - Работа с Redis подробно описана в файле "9. Redis".
    - В Laravel есть встроенная поддержка Redis для:

      1) Использования в качестве базы данных
      2) Кэширования
      3) Хранения сессий

  > Настройка Redis в Laravel

    1. Убедиться, что сервер Redis запущен
      - В противном случае ничего, естественно, работать не будет.

    2. Посмотреть в redis.conf значения параметров Redis
      - Конфиг редис по умолчанию называется redis.conf.
      - Он может храниться где угодно, а не обязательно в папке с Laravel.
        - В Linux/Ubuntu он скорее всего лежит в /etc/redis/redis.conf.
        - В Windows в папке, рядом с файлом redis-server.exe.
      - Надо посмотреть значения следующих параметров:

        # bind          | ip хоста, на котором работает сервер Redis.
        # port          | порт, на котором работает сервер Redis
        # requirepass   | пароль, необходимый для работы с сервером Redis (если установлен)

    3. Настроить подключение к Redis в Laravel
      - Делать это надо в файле "config\database.php", в параметре 'redis'.
      - Выглядит этот параметр так (пример):

          'redis' => array(

            'cluster' => false,

            'default' => array(
              'host'     => '127.0.0.1',
              'port'     => 6379,
              'database' => 0,
              'password' => ''
            ),

          ),

    4. Установить Redis в качестве механизма сессий в Laravel
      - Делать это надо в файле "config\sessions.php", в параметре 'driver'.
      - Должно быть так:

          'driver' => 'redis',

    5. Установить Redis в качестве механизма кэширования в Laravel
      - Делать это надо в файле "config\cache.php", в параметре 'driver'.
      - Должно быть так:

          'driver' => 'redis',

  > Использования Redis в Laravel

    1. В механизме сессий
      - Стандартный унифицированный функционал Laravel для сессий.

    2. В механизме кэширования
      - Стандартный унифицированный функционал Laravel для кэширования.

    3. В качестве базы данных

      - Установить соединение с 'default' сервером Redis:

          $redis = Redis::connection();

      - Установить соединение с 'otherServer' сервером Redis:

          $redis = Redis::connection('otherServer');

      - Когда установлено соединение, можно выполнять Redis-команды.
      - Да, те самые, которые описаны здесь: http://redis.io/commands
      - К ним надо обращаться, просто как к методам экземпляра $redis.
      - Это в документации Laravel называется "магические методы".
      - Примеры:

          $redis->set('name', 'Taylor');
          $name = $redis->get('name');
          $values = $redis->lrange('names', 5, 10);

      - Можно и не применять "магические методы".
      - А вместо них использовать метод command.
      - Пример:

          $values = $redis->command('lrange', array(5, 10));

      - Но и это ещё не всё.
      - Не обязательно создавать экземпляр Redis для работы с default-соединением.
      - Можно работать напрямую с классом Redis.
      - И использовать магические методы, как стат.методы этого класса:

          Redis::set('name', 'Taylor');
          $name = Redis::get('name');
          $values = Redis::lrange('names', 5, 10);

  > Примечание по поводу пароля Redis
    - Redis очень быстр.
    - Злоумышленник может перебирать по 150k паролей в секунду.
    - Поэтому пароль должен быть не менее 30 символов разл.регистра.
    - Лучше использовать не только цифры и буквы, но и всякие спец.символы.

  > Внимание! Почему Redis может не работать в Laravel
    - При попытке использовать класс Redis Laravel может выдавать ошибку:

        Call to undefined method Redis ...

    - В этом случае надо открыть конфиг PHP.
    - И в нём найти и отключить extension для Redis.
    - Если это дополнение включено, то Redis в Laravel работать не будет.
    - В конфиге PHP искать надо строку:

        extension=php_redis.dll

    - Найдя, надо её закомментировать вот так:

        ;extension=php_redis.dll

    - И перезагрузить сервер.

  > В Windows удобно сделать автозапуск Redis при запуске Windows

    > Предисловие
      - Я пользуюсь Windows, как основной операционной системой.
      - Здесь же я и веду разработку всех программных продуктов.
      - Допустим, у нас Laravel настроен на использование Redis.
      - Если сервер Redis не запущен, то и Laravel-приложения не работают.
      - А после перезагрузки Windows сервер Redis сам собой не запустится.

    > Как сделать автозапуск сервера Redis при запуске Windows

      1. Создать powershell скрипт (пути заменить на актуальные)

        Redis_start.ps1
        ------------------
          # Запускает сервер Redis с указанным конфигом
          $redis = "C:\WebDev\0. Projects\grumart.ru\Redis\redis-server.exe"
          $config = "C:\WebDev\0. Projects\grumart.ru\Redis\redis.conf"
          &$redis $config

      2. Создать новую задачу в "планировщике задач" Windows

        2.1. Панель управления -> Расписание выполнения задач
        2.2. Щёлкнуть по "библиотека планировщика задач".
        2.3. Щёлкнуть правой кнопкой правее, и выбрать "создать новую задачу".
        2.4. Настроить всё. Особое внимание уделить вкладке "действие"

          - Нажать кнопку "создать"
          - В поле "программа или сценари" вписать следующее (пути заменить на актуальные):

              C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe

          - В поле "добавить аргументы" написать следующее (пути заменить на актуальные):

              -NoProfile -File "C:\WebDev\0. Projects\grumart.ru\Redis\Скрипт для запуска Redis при старте windows\Redis_start.ps1" -ExecutionPolicy RemoteSigned "C:\WebDev\0. Projects\grumart.ru\Redis\Скрипт для запуска Redis при старте windows\Redis_start.ps1"


A13. Работа с email

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Как работает электронная почта
    - Конфиг "config/mail.php"
    - В итоге, что же использовать?

    - Настройка "SMTP" через SMTP-сервер mailgun

  --------------------------------------

  > Ссылки

    /////-------------------------/////
    /////       Основы email      /////
    /////-------------------------/////

      - Что такое SMTP (статья на wiki):
          https://ru.wikipedia.org/wiki/SMTP

      - PHP-фукнция mail(), официальный справочник:
          http://php.net/manual/ru/book.mail.php

      - Статья "Как работает электронная почта"
          http://www.pcwork.ru/kak_rabotaet_elektronnaya_pochta_deystvuyuschaya_sistema_server_smtp.htm


    /////-------------------------/////
    /////     Email в Laravel     /////
    /////-------------------------/////

      - Статья "Sending Email with Laravel 4" на culttt.com (en):
          http://culttt.com/2014/04/14/sending-email-laravel-4/

      - Оф. сайт SwiftMailer:
          http://swiftmailer.org/

      - Оф. справочник laravel 4 (en):
          http://laravel.com/docs/4.2/mail

      - Оф. справочник классов laravel 4 (см. класс illuminate\mail):
          http://laravel.com/api/4.2/


    /////-------------------------/////
    ///// Бесплатные SMTP-сервера /////
    /////-------------------------/////

      > mail.ru     | MAX 1 сообщение в минуту
      > yandex.ru   | MAX 150 сообщений в день
      > meta.ua     | MAX 200 сообщений в день
      > ukr.net     | MAX 250 сообщений в день
      > rambler.ru  | MAX 200 сообщений в час
      > gmail.com   | MAX 500 сообщений в день
      > mailgun.org | MAX 10000 сообщений в месяц


    /////-------------------------/////
    /////     Сервисы HTTP-API    /////
    /////-------------------------/////

      > https://mailgun.com
        - 10000 сообщений/месяц бесплатно.
        - Свыше 10k надо платить $0.00050 за каждый отправленный email.
        - Итого, платные 1000 сообщений будет стоить $0.5.

      > https://www.mandrill.com/
        - 12000 сообщений/месяц бесплатно.
        - Свыше 12k по $0.2 за каждую 1000 сообщений.

      > http://sendgrid.com/
        - 200 сообщений/день бесплатно (6000/месяц).
        - За $10 можно купить 40000 сообщений
        - Итого, платные 1000 сообщений будет стоить $0.25.

      > http://www.epochta.ru/
        - 6000 сообщений/месяц бесплатно.
        - Свыше 6k сообщений $10 за каждые 10000 сообщений.
        - Итого, платные 1000 сообщений будут стоить $1.


  > Введение
    - Любое современное интернет-приложение должно уметь слать сообщения по email.
    - В данной главе рассмотрим, как это делается в Laravel.
    - Laravel реализует простой API к популярной email-библиотеке SwiftMailer.
    - SwiftMailer обеспечивает удобную работу с email в объекто-ориентированном стиле.
    - Этот самый API реализован в Laravel классом Illuminate\Mail.


  > Как работает электронная почта

    > Схема отправки письма через SMTP-сервер:

            -------      -------
         -> | MTA | ---> | MTA | ->
         |  -------      -------  |
         |                        |
         |                        |
         |                        |
        -------              -------
        | MUA |              | MUA |
        -------              -------

      # Ситуация
        - Надо отправить письмо по адресу ivanpetrov@mail.ru
        - Письмо будет отправлять приложение PHP-функцией mail().
        - Имеется настроенный MTA Sendmail.

      # Как всё происходит

        1. Применяем функцию mail() и отправляем письмо нашему MTA Sendmail через порт 25.
        2. Он запращивает у DNS-сервера адрес mail.ru, и пересылает письмо местному MTA через порт 25.
        3. MTA на mail.ru передаёт письмо местному POP3-серверу, который кладёт его в ящик клиента.


    > Про SMTP, MUA и MTA

      # SMTP
        - Simple Mail Transfer Protocol - простой протокол передачи почты.
        - Предназначен для передачи электронной почты в сетях TCP/IP.
        - Впервые описан в RFC 821 в 1982 году.
        - Предназначен для передачи исходящей почты с использованием порта TCP 25.
        - Работает обычно через порт 25.

      # MUA - Mail User Agent - клиент электронной почты
        - Программа-клиент, которая передаёт письмо для передачи на SMTP-сервер.

      # MTA - Mail Transfer Agent - агент пересылки сообщений
        - Это и есть сервер электронной почты, или SMTP-сервер.
        - Список самых известных MTA доступен в этой статье wiki:
            https://ru.wikipedia.org/wiki/Почтовый_сервер


  > Конфиг "config/mail.php"
    - Настройки класса Mail лежат в файле "config/mail.php".
    - Там есть следующие настройки:

      # 'driver'
        - Позволяет выбрать драйвер.
        - Доступны следующие варианты:

          > smtp
            - Используем сторонний SMTP-сервер для отправки писем.
            - В интернете полно сторонних общедоступных SMTP-серверов.
            - По умолчанию установлен SMTP-сервер: "smtp.mailgun.org"

          > mail
            - Будем отправлять письма встроенной в PHP функцией mail().
            - Она требует, чтобы был установлен SMTP-сервер sendmail.
            - Подробнее про эту функцию см. в официальном справочнике:
                http://php.net/manual/ru/book.mail.php

          > sendmail
            - Используем SMTP-сервер Sendmail.

          > mailgun
            - Используем через API сервис mailgun.com для отправки писем.
            - Т.Е. письма мы отправляем через HTTP, используя API сервиса.

          > mandrill
            - Используем через API сервис mandrill.com для отправки писем.
            - Т.Е. письма мы отправляем через HTTP, используя API сервиса.

          > log
            - Отправляем все письма в лог.
            - Этот режим можно использовать для отладки приложения.


      # 'host'
        - Используется, если в 'driver' выбран "SMTP".
        - Здесь можно задать host стороннего SMTP-сервера.
        - По умолчанию установлен 'smtp.mailgun.org'.

      # 'port'
        - Порт для работы с SMTP-сервером.
        - По умолчанию стоит порт 587 (для работы с 'smtp.mailgun.org')

      # 'from'
        - Можно указать глобальные исходящий адрес и имя отправителя.
        - Эти значения будут использоваться при отправке всех писем.

      # 'encryption'
        - Протокол шифрования.
        - По умолчанию указан 'tls'.
        - Авторы уверяют, что это надёжно и безопасно.

      # 'username'
        - Используется, если в 'driver' выбран "SMTP".
        - Часть для использования SMTP-сервера требуется аутентификация.
        - Здесь можно указать name для аутентификации.

      # 'password'
        - Используется, если в 'driver' выбран "SMTP".
        - Часть для использования SMTP-сервера требуется аутентификация.
        - Здесь можно указать password для аутентификации.

      # 'sendmail'
        - Используется, если в 'driver' выбран "sendmail".
        - Содержить путь к папке, в которой находится Sendmail.
        - По умолчанию указан путь '/usr/sbin/sendmail -bs'.

      # 'pretend'
        - Pretend переводится, как "претворяться".
        - По умолчанию значение этой опции false.
        - Если true, то почта не отправляется и попадает в лог.
        - Удобно использовать для отладки.


  > В итоге, что же использовать?

    > Предисловие
      - В Laravel доступно много инструментов для работы с почтой.
      - Какой же из них в какой ситуации лучше использовать?
      - Рассмотрим плюсы и минусы разных вариантов.
      - Будем оценивать по 3-м параметрам:

          Простота / Ограничения / Фин.затраты

      - Оценку будем проводить по 5-бальной шкале.

    > Варианты:

      #1: свой SMTP-сервер (1 / 5 / 5)

        > Обсуждение
          - Установить и настроить свой SMTP-сервер на своём серваке.
          - Потребуется время, чтобы в этом разобраться, поэтому это сложно.
          - Но зато никаких ограничений, и никаких фин. затрат.

        > Выводы
          - Такой вариант подойдёт для реальных проектов, он вполне надёжен.

      #2: бесплатный сторонний SMTP-сервер (5 / 1 / 5)

        > Обсуждение
          - Использовать бесплатный сторонний SMTP-сервер проще простого.
          - Но все они имеют неприятные ограничения на кол-во отправляемых писем.
          - Поэтому данный вариант не надёжен:
            - Если лимит будет исчерпан, отправка перестанет работать.

        > Лимиты популярных бесплатных SMTP-серверов:

          - mail.ru     | MAX 1 сообщение в минуту
          - yandex.ru   | MAX 150 сообщений в день
          - meta.ua     | MAX 200 сообщений в день
          - ukr.net     | MAX 250 сообщений в день
          - rambler.ru  | MAX 200 сообщений в час
          - gmail.com   | MAX 500 сообщений в день
          - mailgun.org | MAX 10000 сообщений в месяц

        > Выводы
          - Практически не подходит для реальных проектов, т.к. не надёжен.
          - Можно использовать, если кол-во сообщений гарантировано ниже лимитов.
          - Плюс можно попользоваться для тестирования.

      #3: платный сторонний SMTP-сервер (5 / 3 / 1)

        > Обсуждение
          - Как отдельное решение практически отсутствует на рынке.
          - В наше время идёт в составе комплексного SMTP-сервиса.

        > Выводы
          - См. SMTP-сервисы

      #4: сторонний SMTP-сервис (5 / 3 / 1)

        > Обсуждение
          - Обычно объединяет в себе 2 API: по протоколам SMTP и HTTP.
          - Обычно позволяет отправлять N 1-ых сообщений/мес. бесплатно.
          - Свыше бесплатного лимита обычно берёт деньги за каждое сообщение.
          - Обычно предоставляет ряд доп.функционала для работы с почтой.

        > Рассмотрим несколько SMTP-сервисов

          # https://mailgun.com
            - 10000 сообщений/месяц бесплатно.
            - Свыше 10k надо платить $0.00050 за каждый отправленный email.
            - Итого, платные 1000 сообщений будет стоить $0.5.

          # https://www.mandrill.com/
            - 12000 сообщений/месяц бесплатно.
            - Свыше 12k по $0.2 за каждую 1000 сообщений.

          # http://sendgrid.com/
            - 200 сообщений/день бесплатно (6000/месяц).
            - За $10 можно купить 40000 сообщений
            - Итого, платные 1000 сообщений будет стоить $0.25.

          # http://www.epochta.ru/
            - 6000 сообщений/месяц бесплатно.
            - Свыше 6k сообщений $10 за каждые 10000 сообщений.
            - Итого, платные 1000 сообщений будут стоить $1.

        > Выводы
          - При использовании будет являться источником доп. постоянных расходов.
          - Но зато обеспечивает качественное SMTP-решение.
          - Можно использовать в реальном проекте, если не жалко денег,
            и неохота париться с организацией своей почтовой архитектуры.

      #5: лог

        > Обсуждения
          - Вместо реальной отправки сообщений можно посылать их в лог Laravel.

        > Выводы
          - Удобно использовать для отладки.


  > Настройка "SMTP" через SMTP-сервер mailgun

    > Предисловие
      - Это будет инструкция по настройке Laravel для работы через
        сторонний SMTP-сервер.
      - То есть в параметре "driver" мы выбираем "SMTP".
      - В качестве стороннего SMTP-сервера будем использовать smtp.mailgun.com
      - Как использовать SMTP-сервер smtp.mailgun.com описано у них в справке:
          http://documentation.mailgun.com/user_manual.html#smtp-relay

    > Инструкция

      1. Создать учётную запись на mailgun.com
        - Она понадобится нам для авторизации на их smtp-сервере.
        - Если учётная запись там уже есть, можно пропустить этот этап.
        - Заходим на mailgun.com и создаём новую учётную запись.

      2. Посмотреть SMTP-логин, SMTP-пароль, номера портов
        - Зайти в панель управления mailgun, раздел "Domains".
        - Зайти в доступный домен, щёлкнув по нему.
        - Посмотреть значения следующих параметров:

          # SMTP Hostname
            - Скорее всего это: smtp.mailgun.org

          # Default SMTP Login
            - Логин для подключения к SMTP-серверу

          # Default Password
            - Пароль для подключения к SMTP-серверу

        - Посмотреть номера портов.
        - Обычно SMTP-сервер слушает порты 25, 587 и 465.

      3. Записать SMTP-логин и SMTP-пароль в файл настроек laravel mail.php
        - SMTP-логин записать в параметр 'username'.
        - SMTP-пароль записать в параметр 'password'.

      4. Всё, теперь должно работать.



А14. Капча

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Виды капч
    - Установка капчи от Mew
    - Настройка капчи от Mew
    - Использование капчи от Mew
    - Принцип работы капчи от Mew

  --------------------------------------

  > Ссылки

    - Статья "Капча" на wiki:
        https://ru.wikipedia.org/wiki/Капча

    - Статья про виды капч на ruseller.com:
        http://ruseller.com/lessons.php?rub=29&id=1057

    - Официальный репозиторий на GitHub капчи от студии Mew:
        https://github.com/mewebstudio/captcha


  > Введение
    - Часто в приложении требуется отсеять ботов.
    - Например, при регистрации. Иначе в базу набьётся куча ботов.
    - Для этого нужен способ отличить человека от бота.
    - Таким способом является использование капчи (captcha).
    - В этой главе рассмотрим, как использовать капчу с Laravel.
    - Будем рассматривать бесплатную капчу с распознаванием текста от Mew.

  > Виды капч

    # Распознавание текста
      - Пользователь должен распознать текст на картинке и ввести его.

    # Логические вопросы
      - Пользователь должен ответить на некий логический вопрос.
      - Подразумевается, что на него может ответить только человек.
      - Например: "Как называется самая большая страна в мире?". Ответ: Россия

    # Распознавание изображений
      - Пользователь должен распознать, что изображено на картинке.
      - Например: есть 10 картинок, 5 котов и 5 собак.
      - Пользователь должен щёлкнуть по всем котам.

    # Взаимодействие с пользователем
      - Польозватель должен осуществить какое-то логическое действие.
      - Например: сдвинуть слайдер в указанное положение.

  > Установка капчи от Mew

      1. Вносим изменения в composer.json:

          {
              "require": {
                  ...
                  "mews/captcha": "dev-master"
              },
              ...
          }

      2. Обновляем и устанавливаем зависимости composer:

        - Переходим в консоли в папку с laravel.
        - Обновляем зависимости:

            php ..\composer.phar update

        - Устанавливаем новые зависимости:

            php ..\composer.phar install

      3. Добавить service provider капчи в конфиг "app/config/app.php":

        'providers' => array(
            // ...
            'Mews\Captcha\CaptchaServiceProvider',
        )

      4. Добавить псевдоним капчи в конфиг "app/config/app.php":

     'aliases' => array(
          // ...
          'Captcha' => 'Mews\Captcha\Facades\Captcha',
      )

  > Настройка капчи от Mew

    > Где настроить?
      - В конфиге: "\Laravel\vendor\mews\captcha\src\config\config.php"

    > Какие есть настройки?

      # id          | имя правила валидации
      # fontsizes   | какие размеры шрифтов использовать в капче
      # length      | кол-во символов в капче
      # width       | ширина картинки с капчей
      # height      | высота картинки с капчей
      # space       | расстояние в px между символами в капче
      # colors      | цвета, которые следует использовать в капче
      # sensitive   | является ли капча чувствительной к регистру (нет по умолчанию)
      # quality     | качество картинки (от 0 до 100), 80 по умолчанию

    > Настройки по умолчанию:

      'id' => 'captcha',
      'fontsizes' => array(14, 15, 16, 17, 18),
      'length' => 5,
      'width' => 120,
      'height' => 30,
      'space' => 20,
      'colors' => array('128,23,23', '128,23,22', '33,67,87', '67,70,83', '31,56,163', '48,109,22', '165,42,166', '18,95,98', '213,99,8'),
      'sensitive' => false, // case sensitive (params: true, false)
      'quality' => 80 // image quality


  > Использование капчи от Mew

    // 1. Получить введённый пользоватем код капчи
    // - Если его нет, то вернуть success == 0
    $userCaptchaRequest = Input::get('captcha');
    if(!$userCaptchaRequest) return Response::make(json_encode(array("success" => 0), JSON_UNESCAPED_UNICODE));

    // 2. Задать правило валидации и создать экземпляр валидатора
    $rules = array('captcha' => array('required', 'captcha'));
    $validator = Validator::make(array('captcha'=>$userCaptchaRequest), $rules);

    // 3. Провести валидацию
    if($validator->fails()) {

      return Response::make(json_encode(array("success" => 0), JSON_UNESCAPED_UNICODE));

    } else {

      return Response::make(json_encode(array("success" => 1), JSON_UNESCAPED_UNICODE));

    }

  > Принцип работы капчи от Mew

    1. Метод Captcha::img() делает (схематично) следующее:
      - Генерирует картинку с капчей и возвращает её.
      - Сохраняет в переменную сессии captchaHash хэш-код капчи.

    2. Что происходит при валидации капчи
      - Из сессии извлекается содержимое "captchaHash".
      - И сравнивается с помощью Hash::check() с введённым пользователем кодом.

    3. Сколько по времени хранится код?
      - До конца существования сессии.
      - Обычно сессия существует 120 минут.
      - Значит код хранится MAX 120 минут.


А15. Guzzle - для работы с HTTP

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    -

  --------------------------------------

  > Ссылки

    - Официальный сайт Guzzle
        http://guzzle.readthedocs.org/en/latest/


  > Введение


А16. Геолокация

  --------------------------------------
  Подоглавление:

    16.1. Ссылки
    16.2. Цель и способы геолокации
    16.3. Применение в интернет-магазине
    16.4. Административно-территориальное деление в РФ
    16.5. Временные зоны РФ в соотв. с ФЗ "О времени" от 26.10.2014
    16.6. Подготовка базы часовых зон субъектов РФ
    16.7. Об устройстве базы ФИАС
    16.8. Подготовка базы ФИАС к использованию
    16.9. Подготовка API Яндекс.Карт к использованию
    16.10. Поиск неточного совпадения
    16.11. Подготовка базы ipgeobase к использованию
    16.12. Алгоритмы геолокации
    16.13. Как организовать быстрый AJAX-поиск по базе ФИАС

  --------------------------------------

--////---------------------////
  ////                     ////
  ////     16.1. Ссылки    ////
  ////                     ////
  ////---------------------////


    > База ФИАС на оф.сайте

      // Скачать с оф.сайта в формате dbf
          http://fias.nalog.ru/Public/DownloadPage.aspx

      // Скачать документацию базы ФИАС c оф.сайта:
          http://fias.nalog.ru/Public/Docs/Сведения о составе информации ФИАС.doc

    > База фиас в формате sql на сайте basicdata.ru:

      // Смотреть базу ФИАС онлайн:
          http://basicdata.ru/online/fias/

      // Скачать базу ФИАС:
          http://basicdata.ru/download/fias/

    > База ipgeobase.ru:
          http://ipgeobase.ru/cgi-bin/Archive.cgi

    > API геолокационных сервисов Yandex и Google

      // API Яндекс.Карт

        // Главная
            https://api.yandex.ru/maps/

        // Объект ymaps.geolocation
            http://api.yandex.ru/maps/doc/jsapi/2.0/ref/reference/geolocation.xml
            http://api.yandex.ru/maps/jsbox/2.0/geolocation_ip
            http://ucozmagazines.ru/blog/opredelenie_goroda_po_ip_api_jandeks_kart/2013-09-04-42

      // API Google Maps
          https://developers.google.com/maps/?hl=ru

    > Часовые зоны в РФ

      // ФЗ N 107 "Об исчислении времени" в редакции 26.10.2014
          http://www.consultant.ru/document/cons_doc_LAW_165942/

      // Часовые пояса PHP:
          http://php.net/manual/ru/timezones.php

    > Прочее

      // Все базы geonames.org:
          http://download.geonames.org/export/dump/
          http://download.geonames.org/export/dump/RU.zip
          http://download.geonames.org/export/dump/UA.zip
          http://download.geonames.org/export/dump/featureCodes_ru.txt
          http://download.geonames.org/export/dump/timeZones.txt

      // Данные для составления базы крупных нас.пунктов РФ:
          https://ru.wikipedia.org/wiki/Федеральные_округа_Российской_Федерации
          https://ru.wikipedia.org/wiki/Город_федерального_значения
          https://ru.wikipedia.org/wiki/Коды_субъектов_Российской_Федерации
          https://ru.wikipedia.org/wiki/Административно-территориальное_деление_России

      // Коды муниципальных образований ОКТМО:
          https://ru.wikipedia.org/wiki/Общероссийский_классификатор_территорий_муниципальных_образований
          http://nalog.ru/rn78/service/oktmo/

      // Определение координат по адресу:
          http://u-karty.ru/opredelenie-koordinat-na-karte-yandex

      // Опредление ОКТМО муниципальных образований:
          http://nalog.ru/rn78/service/oktmo/



--////----------------------------------------////
  ////                                        ////
  ////     16.2. Цель и способы геолокации    ////
  ////                                        ////
  ////----------------------------------------////

  > Цель геолокации - получить следующие данные о местонахождении посетителя:

    - Координаты
    - Город
    - Федеральный округ
    - Субъект федерации
    - Район
    - Населённый пункт
    - Часовой пояс

  > Способ геолокации №1: по IP
    - В API Яндекс.Карт получаем страну, регион и город посетителя.
    - По ним находим соотв. объект/нас.пункт в ФИАС.
    - По таблице "m3_fias_regions_timezones" определяем временную зону.

  > Способ геолокации #2: по выбранному из ФИАС нас.пункту
    - Пользователь вручную выбирает нас.пункт из базы ФИАС.
    - По таблице "m3_fias_regions_timezones" определяем временную зону.

  > Способ геолокации #3: её отсутствие
    - Надо дать возможность человеку просто указать "доставка по РФ".
    - Это покроет все те случаи, когда у человека не получается выбрать свой нас.пункт.
    - Либо из-за недостатков базы, либо из-за ошибок алгоритма.


--////---------------------------------------------////
  ////                                             ////
  ////     16.3. Применение в интернет-магазине    ////
  ////                                             ////
  ////---------------------------------------------////

    1. Применение информации о часовом поясе посетителя

      1.1. Время работы магазина
        - Его надо указывать с учётом часового пояса посетителя.
        - В противном случае, оно будет вводить посетителей в заблуждение.

      1.2. Время доставки
        - В случае, если пользователь сможет указывать временной диапазон доставки.
        - Нужно принимать эти данные с учётом часового пояса посетителя.
        - В противном случае возможны досадные накладки.

      1.3. Прочие значения, связанные со временем
        - Например, в ЛК сотрудника, время, до которого надо выполнить работу.

    2. Применение информации о местоположении посетителя

      2.1. Способы доставки
        - Разные способы доставки действуют в разных локациях.
        - Зная локацию посетителя, предлагать ему лишь доступные способы доставки.
        - В том числе, это касается и точек самовывоза.

      2.2. Стоимость доставки
        - Доставка в разные локации стоит разных денег.
        - Зная локацию посетителя и вес посылки, можно показать ему стоимость доставки.

      2.3. Срок доставки
        - Доставка в разные локации разными способами занимает разное время.
        - Зная способ доставки, нач. и кон. точки, можно показать ему срок доставки.

      2.4. Геолокация предложений
        - Организация засисимости предлагаемых условий от локации посетителя.
        - Например, разные спец.предложения в разных субъектах РФ.


--////-----------------------------------------------------------////
  ////                                                           ////
  ////     16.4. Административно-территориальное деление в РФ    ////
  ////                                                           ////
  ////-----------------------------------------------------------////

                    ------
                    | РФ |
                    ------
                       |
            ----------------------
            | Федеральные округа |
            ----------------------
                       |
               ---------              ----------------------------------
               |                      | - Города федерального значения |
        ---------------               | - Республики                   |
        | Субъекты РФ | ------------> | - Области                      |
        ---------------               | - Края                         |
                |                     | - Автономные области           |
                |                     | - Автономные округа            |
                |                     ----------------------------------
                |
                |
    -----------------------------     ----------------------
    | Муниципальные образования | --> | - Районы           |
    -----------------------------     | - Городские округа |
                 |                    ----------------------
                 |
    -------------------------------------------------------
    | Административные центры районов (населённые пункты) |
    -------------------------------------------------------


--////----------------------------------------------------------------------////
  ////                                                                      ////
  ////    16.5. Временные зоны РФ в соотв. с ФЗ "О времени" от 26.10.2014   ////
  ////                                                                      ////
  ////----------------------------------------------------------------------////

    > Введение
      - 26 октября 2014 года вышла новая редкация закона "О времени".
      - Эта глава написана с использованием данных из неё.
      - Ссылка:
          http://www.consultant.ru/document/cons_doc_LAW_165942/

    > Осуществляется ли сезонный перевод времени?
      - Нет.
      - Все живут по зимнему времени круглый год.

    > Как формируются границы часовых зон
      - В соответствии с границами субъектов РФ или районов внутри субъектов.
      - Для всех субъектов крому 2-х часовые зоны формируются по границам субъекта.
      - Исключение только для этих 2-х субъектов:

        1) Республика Саха (содержит 3 часовые зоны).
        2) Сахалинская область (содержит 2 часовые зоны).

    > База часовых зон в субъектах РФ
      - Можно создать таблицу в базе данных, имеющую следующие колонки:

        # regionName  | имя субъекта РФ в базе ФИАС
        # regionNum   | номер субъекта РФ, в соответствии с базой ФИАС
        # districtName| имя района
        # timezoneNum | номер часовой зоны
        # offset      | смещение часовой зоны в часах относительно UTC

      - Когда мы узнаём адрес посетителя, мы узнаём и номер региона, и имя района.
      - Зная номер региона и имя района, можно легко узнать номер и смещение времени в нём.
      - Если район не указан, значит в этом субъекте всего 1 часовая зона.
      - А если укзан, значит > 1.

    > В каком регионе действует какая часовая зона?
      - Об этом подробно указано в обсуждаемом законе.


--////------------------------------------------------------////
  ////                                                      ////
  ////    16.6. Подготовка базы часовых зон субъектов РФ    ////
  ////                                                      ////
  ////------------------------------------------------------////

    1. Создать новый файл

      > Название и кодировка
        - Назвать его "fias_regions_timezones.txt".
        - Установить ему кодировку UTF-8 без BOM.

      > Формат
        - Столбцы отделены друг от друга 1 символом табуляции.
        - Первая строка обозначает названия столбцов, остальные - данные.

      > Структура

          # regionNum     | номер субъекта РФ
          # regionName    | имя субъекта РФ
          # timezoneNum   | номер временной зоны РФ в соотв. с законом
          # offset        | смещение временной зоны относ. UTF
          # districtName  | имя района / городского округа
          # districtUid   | id района в базе ФИАС

      > Вот несколько строк из готового файла

          11	Республика Коми		2	3
          12	Республика Марий Эл		2	3
          13	Республика Мордовия		2	3
          14	Республика Саха (Якутия)	Алданский	8	9
          14	Республика Саха (Якутия)	Амгинский	8	9

      > Где брать данные для составления файла

        > Номер региона и имя субъекта РФ
          - Брать в файле-документе к ФИАС.
          - Там, в приложении 3, эти данные доступны в таблице.
          - Ссылка:
              http://fias.nalog.ru/Public/Docs/Сведения о составе информации ФИАС.doc

        > Номер часового пояса и UTF-смещение для субъектов РФ и районов/г.округов
          - Брать в ФЗ N 107-ФЗ (ред. от 21.07.2014) "Об исчислении времени".
          - Ссылка:
              http://www.consultant.ru/document/cons_doc_LAW_165942/

        > Информация об ID района в базе ФИАС
          - Брать в базе ФИАС.
          - Можно использовать такой запрос:

              SELECT aoid,formalname,areacode FROM d_fias_addrobj WHERE aolevel = '3' && regioncode = '14' && formalname = '[..имя района..]';

          - Примечения:

            *1
              - В фиас (12.10.2014) отсутствует напрочь Нерюнгринский р-он в респ.Саха.
              - ФИАС до сих пор считает Нерюнгри городским округом.
              - Вместо района указать uid города Нерюнгри.

    2. Подготовить пустую таблицу "m3_fias_regions_timezones"
      - В ней должны быть следующие столбцы, в таком же порядке:

          # id            | int         | id с автоинкрементом
          # regionNum     | varchar(45) | номер субъекта РФ
          # regionName    | varchar(100)| имя субъекта РФ
          # timezoneNum   | varchar(45) | номер временной зоны РФ в соотв. с законом
          # offset        | varchar(45) | смещение временной зоны относ. UTF
          # districtName  | varchar(100)| имя района / городского округа
          # districtUid   | varchar(100)| id района в базе ФИАС

    3. Загрузить данные из файла "fias_regions_timezones.txt" в таблицу "m3_fias_regions_timezones"
      - Воспользоваться SQL-командой LOAD DATA.
      - Вот готовая команда:

          LOAD DATA INFILE '[..путь к файлу..]/fias_regions_timezones.txt'
            INTO TABLE m3_fias_regions_timezones
            COLUMNS
              TERMINATED BY '\t'
            LINES
              TERMINATED BY '\n'
            IGNORE 1 ROWS
            (regionNum,regionName,districtName,timezoneNum,offset);


--////--------------------------------------////
  ////                                      ////
  ////     16.7. Об устройстве базы ФИАС    ////
  ////                                      ////
  ////--------------------------------------////

  --//----------------------------------------//
    // 1. Где читать об устройстве базы ФИАС? //
    //----------------------------------------//

      http://fias.nalog.ru/Public/Docs/Сведения о составе информации ФИАС.doc


  --//-------------------//
    // 2. Что такое ФИАС //
    //-------------------//

      - ФИАС - "Федеральная Информационная Адресная Система".
      - ФИАС является систематизированным сводом актуальных адресных сведений, истории их изменения.

  --//--------------------//
    // 3. Что такое КЛАДЭ //
    //--------------------//

      - КЛАДЭ - "КЛассификатор АДресообразующих Элементов".
      - Это перечень адресообразующих элементов, где каждый имеет классификационный код.
      - В нём принята иерархическая система классификации.
      - Клас.коды адресообразующих эл-в отражают текущее админ.-террит. деление адресного пространства.

  --//-------------------------------------------//
    // 4. Кодирование адресообразующих элементов //
    //-------------------------------------------//

      > Структура кода адресного элемента:

            СС А РРР ГГГ ВВВ ППП УУУУ ЭЭЭ ЦЦЦ

      > Значения элементов кода:

          - СС    | код субъекта РФ
          - А     | код округа в составе субъекта РФ
          - РРР   | код района
          - ГГГ   | код города (сельского поселения)
          - ВВВ   | код внутригородского района
          - ППП   | код населённого пункта
          - УУУУ  | код улицы
          - ЭЭЭ   | код дополнительного адресообразующего элемента
          - ЦЦЦ   | код подчиненного адресного объекта доп.адресообразующего элемента

      > Для объектов верх.уровня эл-ты кода более низкого уровня имеют 0-ые значения.
        - Например, есть у нас объект "г.Москва".
        - Для него эл-ты кода: ВВВ - ЦЦЦ будут нулевые.

      > В случае подчинённости адр.объекта старшему объекту через несколько уровней,
        иерархии, промежуточные эл-ты кода
        - Например, есть у нас объект "г.Москва".
        - Это город федерального значения, т.е. является субъектом РФ.
        - Значит улицы в этом городе привязаны напрямую к субъекту РФ.
        - Для них эл-ты кода: А - ППП будут нулевые.

  --//-------------------------------------------------------//
    // 5. Уникальные ID для адресообразующих элементов КЛАДЭ //
    //-------------------------------------------------------//

      5.1. Два вида используемых UID

        1) UID записи
        2) UID объекта в КЛАДЭ

      5.2. Про UID записи
        - Запись представляет собой все актуальные на тот момент данные об объекте.
        - В КЛАДЭ сохраняются и устаревшие записи так, что можно отслеживать историю изменений объекта.
        - Допустим, есть 3 записи про 1-ин и тот же объект.
        - 2 из них устаревшие, а 1 актуальная на данный момент.
        - Каждая знает UID предыдущей, и UID следующей (по времени) записи для данного объекта.

      5.3. Про ID объекта в КЛАДЭ
        - Каждый объект в КЛАДЭ имеет уникальный в его пределах ID.
        - Этот ID никогда не меняется, и всегда ведёт к одному и тому же объекту.
        - За исключением операции дробления, когда объект по факту перестаёт существовать как целое.
        - Его ввели, потому что клас.коды сами по себе не могут служить в качестве ID.
        - Т.К. при изменении админ.-террит. деления, эти коды тоже меняются.
        - А это самое деление часто изменяется с течением времени.


  --//------------------------------------------------//
    // 6. Состав эл-в КЛАДЭ - столбцы таблицы ADDROBJ //
    //------------------------------------------------//

        # aoid        | Global UID объекта, описан выше в пункте 5.3.

        # formalname  | Формализованное наименование
          - Содержит формализованное наименование адресного объекта.
          - То есть то, которое фигурирует на картах, к которому все привыкли.

        # regioncode  | [часть клас.код: "СС"] Код субъекта РФ (см.п.8 ниже).
        # autocode    | [часть клас.код: "А"] Код округа в составе субъекта РФ
        # areacode    | [часть клас.код: "РРР"] Код района
        # citycode    | [часть клас.код: "ГГГ"] Код города
        # ctarcode    | [часть клас.код: "ВВВ"] Код внутригородского района
        # placecode   | [часть клас.код: "ППП"] Код населенного пункта
        # streetcode  | [часть клас.код: "УУУУ"] Код улицы
        # extrcode    | [часть клас.код: "ЭЭЭ"] Код дополнительного адресообразующего элемента
        # sextcode    | [часть клас.код: "ЦЦЦ"] Код подчиненного дополнительного адресообразующего элемента

        # offname     | Официальное наименование
          - Как официально называется объект.
          - Пример форм.имени: "аул Бульбекский".
          - Пример оф.имени: "сельское поселение Бульбекское".

        # postalcode  | Почтовый индекс
          - Почтовый индекс почт.отделения, обслуживающего данный объект.

        # ifnsfl      | Код ИФНС ФЛ
        # terrifnsfl  | Код территориального участка ИФНС ФЛ
        # ifnsul      | Код ИФНС ЮЛ
        # terrifnsul  | Код территориального участка ИФНС ЮЛ
        # okato       | ОКАТО
        # oktmo       | ОКТМО

        # updatedate  | Дата и время внесения записи в БД

        # shortname   | Краткое наименование типа объекта
          - Краткое наименование типа адресного объекта.
          - Берётся из таблицы "SOCRBASE".
          - Примеры (краткое наименование / полное наименование):

              край / Край
              респ / Республика
              рп   / Рабочий поселок
              пгт  / Поселок городского типа

        # aolevel     | Уровень адресного объекта
          - Цифра, обозначающая уровень адресного объекта в иерархии.
          - Доступны следующие уровни:

              1  - уровень региона
              2  - уровень автономного округа
              3  - уровень района
              4  - уровень города
              5  - уровень внутригородской территории
              6  - уровень населенного пункта
              7  - уровень улицы
              90 - уровень дополнительных территорий
              91 - уровень подчиненных дополнительным территориям объектов

        # parentguid  | Global UID родит.объекта в иерархии для связи с ним.

        # aoguid      | UID записи, описанный в п.5.2.
        # previd      | UID предыдущей по времени записи об объекте
        # nextid      | UID следующей по времени записи об объекте

        # code        | Код адресного объекта одной строкой с признаком актуальности из КЛАДР 4.0
        # plaincode   | Код адресного объекта из КЛАДР 4.0 одной строкой без признака актуальности (последних двух цифр)

        # actstatus   | Статус актуальности адресного объекта
          - Определяет, является ли эта запись по адресному объекту актуальной.
          - Актуальной называют самую последнюю по времени запись об объекте.
          - Возможные значения: 0 - не актуальный, 1 - актуальный.
          - Возможные значения этого столбца хранятся в таблице ACTSTAT.

        # centstatus  | Признак центра
          - Определяет, является ли объект центром админ.-террт. образования.
          - Возможные значения:

            0   – объект не является центром административно-территориального образования;
            1   – объект является центром района;
            2   – объект является центром (столицей) региона;
            3   – объект является одновременно и центром района и центром региона.

          - Возможные значения этого столбца хранятся в таблице CENTERST.

        # operstatus  | Статус действия
          - Определяет причину поясления записи в БД.
          - Возможные значения:

            0  - Не определено
            1 – Инициация
            10 – Добавление
            20 – Изменение
            21 – Групповое изменение
            30 – Удаление
            31 – Удаление вследствие удаления вышестоящего объекта
            40 – Присоединение адресного объекта (слияние)
            41 – Переподчинение вследствие слияния вышестоящего объекта
            42 – Прекращение существования вследствие присоединения к другому адресному объекту
            43 – Создание нового адресного объекта в результате слияния адресных объектов
            50 – Переподчинение
            51 – Переподчинение вследствие переподчинения вышестоящего объекта
            60 – Прекращение существования вследствие дробления
            61 – Создание нового адресного объекта в результате дробления

          - Возможные значения этого столбца хранятся в таблице OPERSTAT.

        # currstatus  | [таблица CURENTST] Статус актуальности КЛАДР 4 (последние две цифры в коде)

        # startdate   | Дата начала действия записи
        # enddate     | Дата окончания действия записи

        # normdoc     | Внешний ключ на нормативный документ
          - ID нормативного документа, в соотв. с которым сделана запись.
          - Данные по ним можно найти в таблице NORMDOC.


  --//------------------------------------------------------//
    // 7. Таблицы ФИАС, использующиеся совместно с ADDROBJ  //
    //------------------------------------------------------//
      - Коды субъектов РФ, используемые в ФИАС:

        01 - Республика Адыгея (Адыгея)
        02 - Республика Башкортостан
        03 - Республика Бурятия
        04 - Республика Алтай
        05 - Республика Дагестан
        06 - Республика Ингушетия
        07 - Кабардино-Балкарская Республика
        08 - Республика Калмыкия
        09 - Карачаево-Черкесская Республика
        10 - Республика Карелия
        11 - Республика Коми
        12 - Республика Марий Эл
        13 - Республика Мордовия
        14 - Республика Саха (Якутия)
        15 - Республика Северная Осетия - Алания
        16 - Республика Татарстан (Татарстан)
        17 - Республика Тыва
        18 - Удмуртская Республика
        19 - Республика Хакасия
        20 - Чеченская Республика
        21 - Чувашская Республика - Чувашия
        22 - Алтайский край
        23 - Краснодарский край
        24 - Красноярский край
        25 - Приморский край
        26 - Ставропольский край
        27 - Хабаровский край
        28 - Амурская область
        29 - Архангельская область
        30 - Астраханская область
        31 - Белгородская область
        32 - Брянская область
        33 - Владимирская область
        34 - Волгоградская область
        35 - Вологодская область
        36 - Воронежская область
        37 - Ивановская область
        38 - Иркутская область
        39 - Калининградская область
        40 - Калужская область
        41 - Камчатский край
        42 - Кемеровская область
        43 - Кировская область
        44 - Костромская область
        45 - Курганская область
        46 - Курская область
        47 - Ленинградская область
        48 - Липецкая область
        49 - Магаданская область
        50 - Московская область
        51 - Мурманская область
        52 - Нижегородская область
        53 - Новгородская область
        54 - Новосибирская область
        55 - Омская область
        56 - Оренбургская область
        57 - Орловская область
        58 - Пензенская область
        59 - Пермский край
        60 - Псковская область
        61 - Ростовская область
        62 - Рязанская область
        63 - Самарская область
        64 - Саратовская область
        65 - Сахалинская область
        66 - Свердловская область
        67 - Смоленская область
        68 - Тамбовская область
        69 - Тверская область
        70 - Томская область
        71 - Тульская область
        72 - Тюменская область
        73 - Ульяновская область
        74 - Челябинская область
        75 - Забайкальский край
        76 - Ярославская область
        77 - Г.Москва
        78 - Г.Санкт-Петербург
        79 - Еврейская автономная область
        83 - Ненецкий автономный округ
        86 - Ханты-Мансийский автономный округ - Югра
        87 - Чукотский автономный округ
        89 - Ямало-Ненецкий автономный округ
        99 - Иные территории, включая город и космодром Байконур


  --//------------------------------------------------------//
    // 8. Таблицы ФИАС, использующиеся совместно с ADDROBJ  //
    //------------------------------------------------------//

      # SOCRBASE
        - Нужно использовать для расшифровки значения shortname.
        - Допустим, в shortname указано 'пгт'.
        - Смотрим ищем по этой строке в столбце scname таблицы SOCRBASE.
        - Найдя, смотрим значение в столбце "socrname":
            "посёлок городского типа".
        - Столбцы таблицы SOCRBASE:

            # level       | Уровень адресного объекта
            # scname      | Краткое наименование типа объекта
            # socrname    | Полное наименование типа объекта
            # kod_t_st    | Ключевое поле

      # ACTSTAT
        - Можно использовать для расшифровки статуса актуальности записи в "actstatus".
        - Актуальной называют самую последнюю по времени запись объекта.
        - Но в этой таблице всего 2 значения:

            0 - не актуальный
            1 - актуальный

        - Так что в принципе, можно на неё забить.
        - Столбцы таблицы ACTSTAT:

            # actstatid   | Идентификатор статуса
            # name        | Наименование

      # CENTERST
        - Можно использовать для расшифровки кода признака центра в "centstatus".
        - В этой таблице всего 4 значения:

            0   – объект не является центром административно-территориального образования;
            1   – объект является центром района;
            2   – объект является центром (столицей) региона;
            3   – объект является одновременно и центром района и центром региона.

        - Так что в принципе, можно на неё забить.
        - Столбцы таблицы CENTERST:

            # centerstid  | Идентификатор статуса
            # name        | Наименование

      # OPERSTAT
        - Можно использовать для расшифровки кода в "operstatus".
        - Этот код обозначает причину появления данной записи.
        - Всего таких кодов 15, см. выше в п.6.
        - Не особо нужная нам для разработки интернет-магазина таблица.
        - Столбцы таблицы OPERSTAT:

            # operstatid  | Идентификатор статуса
            # name        | Наименование

      # CURENTST
        - Можно использовать для расшифровки кода в "currstatus".
        - Обозначает статус актуальности КЛАДР 4.
        - Вообще нам не нужно для разработки интернет-магазина таблица.
        - Столбцы таблицы CURENTST:

            # curentstid  | Идентификатор статуса
            # name        | Наименование

      # NORMDOC
        - Содержит нормативные документы, каждый из которых имеет ID.
        - Столбец "normdoc" записи содержит ID нормативного документа...
        - ...в соответствии с которым эта запись была сделана.
        - Вообще нам не нужно для разработки интернет-магазина таблица.
        - Столбцы таблицы NORMDOC:

            # normdocid   | Идентификатор нормативного документа
            # docname     | Наименование документа
            # docdate     | Дата документа
            # docnum      | Номер документа
            # doctype     | Тип документа
            # docimgid    | Идентификатор образа


  --//---------------------------------------------------------------------//
    // 9. Инфа о домах, владениях и т.д. из баз HOUSE, HOUSEINT и LANDMARK //
    //---------------------------------------------------------------------//

      - В интернет магазине можно позволить пользователям выбрать номер дома/владение и т.д.
      - Преимущество: можно узнать его индекс, и авто-подставить где понадобится.
      - Недостаток: а что, если в ФИАС нет номера дома, где живёт чел?
      - Короче говоря, на начальном этапе можно обойтись без этого функционала.
      - Потом будет не трудно его допилить если понадобится. По требованию.


  --//----------------------------------//
    // 10. Список ВСЕХ таблиц в БД ФИАС //
    //----------------------------------//

      # ACTSTAT       | перечень статусов актуальности записи адр.элемента по ФИАС

        - actstatid   | Идентификатор статуса
        - name        | Наименование

      # ADDROBJ       | коды, наименования и типы адресообразующих элементов

        - aoid        | Уникальный идентификатор записи
        - formalname  | Формализованное наименование
        - regioncode  | Код региона
        - autocode    | Код автономии
        - areacode    | Код района
        - citycode    | Код города
        - ctarcode    | Код внутригородского района
        - placecode   | Код населенного пункта
        - streetcode  | Код улицы
        - extrcode    | Код дополнительного адресообразующего элемента
        - sextcode    | Код подчиненного дополнительного адресообразующего элемента
        - offname     | Официальное наименование
        - postalcode  | Почтовый индекс
        - ifnsfl      | Код ИФНС ФЛ
        - terrifnsfl  | Код территориального участка ИФНС ФЛ
        - ifnsul      | Код ИФНС ЮЛ
        - terrifnsul  | Код территориального участка ИФНС ЮЛ
        - okato       | ОКАТО
        - oktmo       | ОКТМО
        - updatedate  | Дата внесения записи
        - shortname   | Краткое наименование типа объекта
        - aolevel     | Уровень адресного объекта
        - parentguid  | Идентификатор объекта родительского объекта
        - aoguid      | Глобальный уникальный идентификатор адресного объекта
        - previd      | Идентификатор записи связывания с предыдушей исторической записью
        - nextid      | Идентификатор записи  связывания с последующей исторической записью
        - code        | Код адресного объекта одной строкой с признаком актуальности из КЛАДР 4.0
        - plaincode   | Код адресного объекта из КЛАДР 4.0 одной строкой без признака актуальности (последних двух цифр)
        - actstatus   | [таблица ACTSTAT] Статус актуальности адресного объекта ФИАС. Актуальный адрес на текущую дату. Обычно последняя запись об адресном объекте.
        - centstatus  | [таблица CENTERST] Статус центра
        - operstatus  | [таблица OPERSTAT] Статус действия над записью – причина появления записи
        - currstatus  | [таблица CURENTST] Статус актуальности КЛАДР 4 (последние две цифры в коде)
        - startdate   | Начало действия записи
        - enddate     | Окончание действия записи
        - normdoc     | Внешний ключ на нормативный документ

      # CENTERST      | перечень возможных статусов (центров) адр.объ-ов админ.единиц

        - centerstid  | Идентификатор статуса
        - name        | Наименование

      # CURENTST      | перечень статусов актуальности записи адр.эл-та по классификатору КЛАДР 4.0

        - curentstid  | Идентификатор статуса
        - name        | Наименование

      # ESTSTAT       | перечень возможных видов владений

        - eststatid   | Признак владения
        - name        | Наименование

      # HOUSE         | номера домов, земельных участвов и т.д.

        - postalcode  | Почтовый индекс
        - ifnsfl      | Код ИФНС ФЛ
        - terrifnsfl  | Код территориального участка ИФНС ФЛ
        - ifnsul      | Код ИФНС ЮЛ
        - terrifnsul  | Код территориального участка ИФНС ЮЛ
        - okato       | ОКАТО
        - oktmo       | ОКTMO
        - updatedate  | Дата время внесения записи
        - housenum    | Номер дома
        - eststatus   | Признак владения
        - buildnum    | Номер корпуса
        - strucnum    | Номер строения
        - strstatus   | Признак строения
        - houseid     | Уникальный идентификатор записи дома
        - houseguid   | Глобальный уникальный идентификатор дома
        - aoguid      | Guid записи родительского объекта
        - startdate   | Начало действия записи
        - enddate     | Окончание действия записи
        - statstatus  | [таблица HSTSTAT] Состояние дома
        - normdoc     | Внешний ключ на нормативный документ
        - counter     | Счетчик записей домов для КЛАДР 4

      # HOUSEINT      | записи с интервалами домов улиц нас.пунктов

        - postalcode  | Почтовый индекс
        - ifnsfl      | Код ИФНС ФЛ
        - terrifnsfl  | Код территориального участка ИФНС ФЛ
        - ifnsul      | Код ИФНС ЮЛ
        - terrifnsul  | Код территориального участка ИФНС ЮЛ
        - okato       | ОКАТО
        - oktmo       | ОКТМО
        - updatedate  | Дата  внесения записи
        - intstart    | Значение начала интервала
        - intend      | Значение окончания интервала
        - houseintid  | Идентификатор записи интервала домов
        - intguid     | Глобальный уникальный идентификатор интервала домов
        - aoguid      | Идентификатор объекта родительского объекта
        - startdate   | Начало действия записи
        - enddate     | Окончание действия записи
        - intstatus   | Статус интервала
        - normdoc     | Внешний ключ на нормативный документ
        - counter     | Счетчик записей домов для КЛАДР 4

      # HSTSTAT       | перечень возможных состояний объектов недвижимости

        - housestid   | Идентификатор статуса
        - name        | Наименование

      # INTVSTAT      | перечень возможных значений интервалов домов (обычный, четный, нечетный)

        - intvstatid  | Идентификатор статуса (обычный, четный, нечетный)
        - name        | Наименование

      # LANDMARK      | описания мест расположения объектов, которые невозможно однозначно идентифицировать с использованием вышеописанных адресообразующих элементов

        - location    | Месторасположение ориентира
        - postalcode  | Почтовый индекс
        - ifnsfl      | Код ИФНС ФЛ
        - terrifnsfl  | Код территориального участка ИФНС ФЛ
        - ifnsul      | Код ИФНС ЮЛ
        - terrifnsul  | Код территориального участка ИФНС ЮЛ
        - okato       | ОКАТО
        - oktmo       | ОКТМО
        - updatedate  | Дата внесения записи
        - landid      | Уникальный идентификатор записи ориентира
        - landguid    | Глобальный уникальный идентификатор ориентира
        - aoguid      | Уникальный идентификатор родительского объекта
        - startdate   | Начало действия записи
        - enddate     | Окончание действия записи
        - normdoc     | Внешний ключ на нормативный документ

      # NORMDOC       |

        - normdocid   | Идентификатор нормативного документа
        - docname     | Наименование документа
        - docdate     | Дата документа
        - docnum      | Номер документа
        - doctype     | Тип документа
        - docimgid    | Идентификатор образа

      # OPERSTAT      | перечень кодов операций над адресными объектами

        - operstatid  | Идентификатор статуса
        - name        | Наименование

      # SOCRBASE      | перечень полных, сокращённых типов адресных эл-в и уровней их классификациии

        - level       | Уровень адресного объекта
        - scname      | Краткое наименование типа объекта
        - socrname    | Полное наименование типа объекта
        - kod_t_st    | Ключевое поле

      # STRSTAT       | перечень видов строений

        - strstatid   | Признак строения
        - name        | Наименование
        - shortname   | Краткое наименование


  --//--------------------------------------------------------//
    // 11. Кол-во записей в ФИАС от 13.10.2014 разных уровней //
    //--------------------------------------------------------//
      - В т.ч. здесь, естественно, присутствуют и историеческие записи по объектам.

          1  - ур. региона                        | 99      |
          2  - ур. автономного округа             | 0       |
          3  - ур. района                         | 2 406   |- 247 284
          4  - ур. города                         | 6 455   |
          5  - ур. внутригородской территории     | 56      |
          6  - ур. населенного пункта             | 238 268 |
          7  - ур. улицы                          | 1 096 116 |
          90 - ур. дополнительных территорий      | 30 518    | - 1 131 243
          91 - ур. подчиненных доп. тер. объектов | 4 609     |
        -----------------------------------------------
                                           Итого: | 1 378 527

      - Разделять базу нет никакого смысла, это ничего не ускорит.
      - Достаточно просто правильно применять не уникальные индексы.


--////---------------------------------------------------////
  ////                                                   ////
  ////     16.8. Подготовка базы ФИАС к использованию    ////
  ////                                                   ////
  ////---------------------------------------------------////

  --//--------------------------------------------------------//
    // Вариант №1:                                            //
    //--------------------------------------------------------//
    // Используем базу ФИАС с сайта basicdata.ru в sql-формате

    1. Скачать нужные таблицы ФИАС в формате SQL
      - Отсюда:
          http://basicdata.ru/download/fias/
      - Скачивать следующие таблицы:
          ADDROBJ, SOCRBASE, ACTSTAT, CENTERST
      - ADDROBJ нужно скачать 3 файла:
        1) table
        2) index
        3) data
      - Для остальных тоже самое, но без index.

    2. Установить ADDROBJ в базу MySQL

      2.1. Выполнить скрипт table.sql в нужной БД.
        - В workbench: file -> open SQL script.
        - В mysql shell:

            mysql -uroot;
            use grumart_v2;
            source [filename];

        - Тем самым мы создаём пустую таблицу 'd_fias_addrobj'.

      2.2. Выполнить скрипт index.sql в нужной БД.
        - Тем самым мы добавляем в таблицу 'd_fias_addrobj' индексы.

      2.3. Выполнить скрипт data.sql
        - Его можно выполнить только через shell, т.к. он очень велик.
        - Перед выполнением сменить кодировку shell на utf-8 командой:

            chcp 65001

        - Иначе будут кракозябры, т.к. по умолчанию кодировка 866 (не utf-8).

      2.4. Переименовываем таблицу в "m3_fias_addobj".
        - Эта таблица находится в составе модуля "М3. Геолокация".

      2.5. Делаем не уникальные индексы (KEY)
        - Они понадобятся для осуществления быстрого поиска по этим колонкам.
        - Делаем не уникальные индексы на следующие колонки:

          # aoid
          # formalname
          # regioncode
          # areacode
          # aolevel
          # parentguid
          # aoguid
          # centstatus

    3. Установить SOCRBASE в базу MySQL
      - Тоже самое, что для 2.
      - Установить индексы на все колонки:

          # level
          # scname
          # socrname
          # kod_t_st

      - Имя таблицы: "m3_fias_socrbase"

    4. Установить ACTSTAT, CENTERST
      - Тоже самое, что для 2. Но без индексов.
      - Имена таблиц:

          "m3_fias_actstat"
          "m3_fias_centerst"

  --//--------------------------------------------------------//
    // Вариант №2:                                            //
    //--------------------------------------------------------//
    // Используем базу ФИАС с оф.сайта в формате dbf

    1. Скачать базу ФИАС в формате dbf с оф.сайта
      - Ссылка для скачивания:
          http://fias.nalog.ru/Public/DownloadPage.aspx
      - Это будет архив "fias_dbf.rar".
      - Он весит 1.8гб (18.10.2014), так что придётся подождать.
      - Распаковать из архива следующие файлы:
          ADDROBJ.dbf, SOCRBASE.dbf.

    2. Преобразовать вышеуказанные файлы в формат .csv
      - Столбцы должны быть отделены друг от друга символом табуляции.
      - Преобразование можно реализовать любой удобной программой.
      - Для Windows рекомендую программу "DBF Commander Professional" от v3.3.
      - В результате следует получить 2 файла:
          ADDROBJ.csv, SOCRBASE.csv.
      - *Примечание: можно вместо этого импортировть файлы прямо из .dbf
        в таблицу mysql с помощью программы navicat (доступен для Win и Linux).

    3. Подготовить пустую таблицу "m3_fias_addrobj"
      - Для этого выполнить данный SQL-скрипт:

          CREATE TABLE `m3_fias_addrobj` (
            `aoid` char(36) NOT NULL COMMENT 'Уникальный идентификатор записи',
            `formalname` varchar(120) NOT NULL COMMENT 'Формализованное наименование',
            `regioncode` varchar(2) NOT NULL COMMENT 'Код региона',
            `autocode` char(1) NOT NULL COMMENT 'Код автономии',
            `areacode` varchar(3) NOT NULL COMMENT 'Код района',
            `citycode` varchar(3) NOT NULL COMMENT 'Код города',
            `ctarcode` varchar(3) NOT NULL COMMENT 'Код внутригородского района',
            `placecode` varchar(3) NOT NULL COMMENT 'Код населенного пункта',
            `streetcode` varchar(4) NOT NULL COMMENT 'Код улицы',
            `extrcode` varchar(4) NOT NULL COMMENT 'Код дополнительного адресообразующего элемента',
            `sextcode` varchar(3) NOT NULL COMMENT 'Код подчиненного дополнительного адресообразующего элемента',
            `offname` varchar(120) NOT NULL COMMENT 'Официальное наименование',
            `postalcode` char(6) NOT NULL COMMENT 'Почтовый индекс',
            `ifnsfl` varchar(4) NOT NULL COMMENT 'Код ИФНС ФЛ',
            `terrifnsfl` varchar(4) NOT NULL COMMENT 'Код территориального участка ИФНС ФЛ',
            `ifnsul` varchar(4) NOT NULL COMMENT 'Код ИФНС ЮЛ',
            `terrifnsul` varchar(4) NOT NULL COMMENT 'Код территориального участка ИФНС ЮЛ',
            `okato` varchar(11) NOT NULL COMMENT 'ОКАТО',
            `oktmo` varchar(8) NOT NULL COMMENT 'ОКТМО',
            `updatedate` date NOT NULL COMMENT 'Дата  внесения записи',
            `shortname` varchar(10) NOT NULL COMMENT 'Краткое наименование типа объекта',
            `aolevel` int(10) unsigned NOT NULL COMMENT 'Уровень адресного объекта ',
            `parentguid` char(36) NOT NULL COMMENT 'Идентификатор объекта родительского объекта',
            `aoguid` varchar(36) NOT NULL COMMENT 'Глобальный уникальный идентификатор адресного объекта',
            `previd` varchar(36) NOT NULL COMMENT 'Идентификатор записи связывания с предыдушей исторической записью',
            `nextid` varchar(36) NOT NULL COMMENT 'Идентификатор записи  связывания с последующей исторической записью',
            `code` varchar(17) NOT NULL COMMENT 'Код адресного объекта одной строкой с признаком актуальности из КЛАДР 4.0',
            `plaincode` varchar(15) NOT NULL COMMENT 'Код адресного объекта из КЛАДР 4.0 одной строкой без признака актуальности (последних двух цифр)',
            `actstatus` tinyint(3) unsigned NOT NULL COMMENT 'Статус актуальности адресного объекта ФИАС. Актуальный адрес на текущую дату. Обычно последняя запись об адресном объекте.',
            `centstatus` int(10) unsigned NOT NULL COMMENT 'Статус центра',
            `operstatus` int(10) unsigned NOT NULL COMMENT 'Статус действия над записью – причина появления записи',
            `currstatus` int(10) unsigned NOT NULL COMMENT 'Статус актуальности КЛАДР 4 (последние две цифры в коде)',
            `startdate` date NOT NULL COMMENT 'Начало действия записи',
            `enddate` date NOT NULL COMMENT 'Окончание действия записи',
            `normdoc` varchar(36) NOT NULL COMMENT 'Внешний ключ на нормативный документ',
            `livestatus` varchar(45) NOT NULL COMMENT '',
            PRIMARY KEY (`aoid`)
          ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Классификатор адресообразующих элементов'

      - Назначить таблице нужные не уникальные индексы, выполнив следующий SQL-скрипт.
      - *Примечание: лучше сначала залить данные, а потом добавить индексы,
                     если поступить наоборот, данные будут заливаться в разы медленнее.

          ALTER TABLE `m3_fias_addrobj`
            ADD KEY `aoid` (`aoid`),
            ADD FULLTEXT INDEX `formalname` (`formalname` ASC),
            ADD KEY `regioncode` (`regioncode`),
            ADD KEY `areacode` (`areacode`),
            ADD KEY `aolevel` (`aolevel`),
            ADD KEY `aoguid` (`aoguid`),
            ADD KEY `parentguid` (`parentguid`),
            ADD KEY `centstatus` (`centstatus`),
            ADD KEY `actstatus` (`actstatus`);

    4. Подготовить пустую таблицу "m3_fias_socrbase"
      - Для этого выполнить данный SQL-скрипт:

          CREATE TABLE `m3_fias_socrbase` (
            `level` int(10) unsigned NOT NULL COMMENT 'Уровень адресного объекта',
            `scname` varchar(10) NOT NULL COMMENT 'Краткое наименование типа объекта',
            `socrname` varchar(50) NOT NULL COMMENT 'Полное наименование типа объекта',
            `kod_t_st` int(10) unsigned NOT NULL COMMENT 'Ключевое поле',
            PRIMARY KEY (`kod_t_st`)
          ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Типы адресных объектов'

      - Назначить таблице нужные не уникальные индексы, выполнив следующий SQL-скрипт:

          ALTER TABLE `m3_fias_socrbase`
            ADD KEY `scname` (`scname`);

    5. Загрузить данные в "m3_fias_addrobj" и "m3_fias_socrbase"
      - В Windows это удобнее всего сделать с помощью программы Navicat.
      - Там есть возможность импортировать данные из файлов .dbf

    6. Копируем таблицу m3_fias_addrobj
      - На 24.10.2014 в таблице ~2 400 000 записей.
      - Полнотекстовый поиск по ней медленный, среднее время 5-15 секунд.
      - Из них 2млн записей - это улицы.
      - Улицы нам для геолокации не нужны, их можно удалить.
      - Но они понадобятся нам позже, так что оригинал таблицы надо сохранить.
      - Создадим копию таблицы:

          CREATE TABLE m3_fias_addrobj_copy SELECT * FROM m3_fias_addrobj;

      - Теперь переименуем m3_fias_addrobj в m3_fias_addrobj_original.
      - А m3_fias_addrobj_copy переименуем в m3_fias_addrobj.
      - И вот теперь можно повесить описанные выше индексы на m3_fias_addrobj

    7. Удаление не актуальных записей
      - В ФИАС большую часть места занимают не актуальные записи.
      - Они нам не нужны, и их можно удалить для ускорения поиска.
      - Это записи с actstatus == '0'.
      - Удалить не актуальные записи можно так:

        DELETE FROM m3_fias_addrobj WHERE actstatus = '0';



--////---------------------------------------------------------////
  ////                                                         ////
  ////     16.9. Подготовка API Яндекс.Карт к использованию    ////
  ////                                                         ////
  ////---------------------------------------------------------////

  --//------------------------------------------//
    // 1. Введение в JavaScript API Яндекс.Карт //
    //------------------------------------------//

    -----------------
    Подголавление

      1.0. Ссылки
      1.1. Введение
      1.2. Что такое JavaScript API Яндекс.Карт
      1.3. Как подключить к документу JS API Яндекс.Карт
      1.4. Объект geolocation
      1.5. Использование объекта geolocation

    -----------------

    1.0. Ссылки

      - Руководство разработчика Яндекс.Карт
          https://api.yandex.ru/maps/doc/jsapi/2.0/dg/concepts/about.xml

      - Справочник JavaScript API Яндекс.Карт
          https://api.yandex.ru/maps/doc/jsapi/2.0/ref/concepts/About.xml

    1.1. Введение
      - Здесь мы рассмотрим JS API Яндекс.Карт.
      - Но не весь, а его основы, и в ракурсе геолокации.
      - Т.Е. нас будет интересовать лишь функционал geolocation.

    1.2. Что такое JavaScript API Яндекс.Карт
      - Это набор JavaScript-компонентов, предназначенных для создания интерактивных карт
      - Компоненты размещены на серверах Яндекса и доступны для использования сразу после их загрузки на страницу.
      - Использовать его, как понятно из названия, можно в JS-коде.

    1.3. Как подключить к документу JS API Яндекс.Карт
      - Для этого нужно в конец кода документа загрузить его:

          <script src="http://api-maps.yandex.ru/2.0-stable/?load=package.full&lang=ru-RU" type="text/javascript"></script>

    1.4. Объект geolocation
      - Он содержит геолокационные данные, определённые по IP клиента.
      - Вот ссылка на него в справочнике:
          https://api.yandex.ru/maps/doc/jsapi/2.0/ref/reference/geolocation.xml
      - Вот, какие св-ва он содержит:

          # longitude - долгота;
          # latitude - широта;
          # zoom - масштаб (если доступен);
          # city - название города;
          # region - название региона;
          # country - название страны.

      - Название города, региона и страны выводится на языке, указанном в параметре lang при подключении API.

    1.5. Использование объекта geolocation
      - Рассмотрим, как пользоваться этим на практике.
      - Практический пример IP-геолокации можно посмотреть в оф.документации:
          http://api.yandex.ru/maps/jsbox/2.0/geolocation_ip
      - Итак, пример:

        // Ждём, пока всё загрузится, и выполняем функцию myfunc
          ymaps.ready(myfunc);

        // Определяем функцию myfunc
        function myfunc() {

          // Получим объект geolocation
          var geo = ymaps.geolocation;

          // Получим координаты
          var coords = {
            latitude: geo.latitude,
            longitude: geo.longitude
          };

          // Получим страну, субъект, город
          var country = geo.country;
          var region = geo.region;
          var city = geo.city;

        }


--////----------------------------------------------------------////
  ////                                                          ////
  ////     16.10. Поиск неточного совпадения                    ////
  ////                                                          ////
  ////----------------------------------------------------------////

    > Предисловие
      - Допустим, проходит у нас автоматическая геолокация.
      - Объект ymaps.geolocation возвращает имя страны, региона, города.
      - Теперь нам надо найти такой объект в базе ФИАС.
      - Проблема в том, что в именах от Яндекс и в ФИАС могут быть небольшие различия.
      - Поэтому, если метод точного сравнения результатов не дал, надо применить неточный поиск.

    > Для чего нужен неточный поиск
      - Чтобы получать в цифрах, насколько "схожи" 2 строки.
      - Оно будет означать, насколько точно совпадают сравниваемые строки.
      - Допустим нам надо сравнить со строкой X 10 других строк.
      - И определить, какая из этих строк наиболее "схожа" со строкой X.
      - Неточный поиск как раз и помогает решать такие задачи.

    > Нам понадобится сравнивать лишь русские строки
      - В них могут быть буквы из русского алфавита.
      - И в них могут быть пробелы.
      - Это всё.

    > Терминология

        # Строка-объект (СО) - та, в которой ищут.
        # Строка-кандидат (СК) - та, которую ищут в строке-объекте.

    > Алгоритм неточного поиска

      1. Удаляем из обоих строк лишние символы
        - Всё, кроме русских букв и пробелов, заменяем на пробелы.
        - Заменяем 2 и более идущих подряд пробелов на 1.
        - Удаляем все пробелы в начале и конце строки.

      2. Делаем в обеих строках все буквы маленькими.

      3. Пробуем точное сравнение
        - М.Б. после этих операций строки стали точно равны.
        - Если да, то возвращаем ... и завершаем работу.
        - Если нет, то переходим к следующему шагу.

      4. Подсчитываем кол-во слов (через пробел) в обоих строках
        - И сохраняем эти данные в массивы (explode).

      5. Ищем полные вхождения слов из СК в СО
        - Делаем цикл по массиву со словами из СК.
        - На каждой итерации делаем цикл по массиву со словами из СО.
        - Осуществляем точное сравнение.
        - За каждое успешное точное сравнение начисляем СК 1 балл.

      6. Ищем неполные, побуквенные вхождения слов из СК в СО
        - Делаем цикл по массиву со словами из СК.
        - На каждой итерации делаем цикл по массиву со словами из СО.
        - Сравниваем строки, начиная от 0-го символа, подряд.
        - И так до первого несовпадающего символа.
        - За каждый совпавший символ начисляем СК 1/L баллов.
          - Где L - длина ставниваемого слова из СО.

      7. Суммируем все быллы строки-кандидата
        - И получаем её вес.

      8. Выясняем, какая из строк-кандидатов наиболее релевантна
        - Сравниваем их веса.

    > Пример нечёткого поиска

      # Исходные данные

        - Допустим, у нас есть такая строка-объект

            "Саха (Якутия) вовсе неплоха"

        - И 4 вот такие строки-кандидата:

            1) "Саха Якут"
            2) "Саха Якути"
            3) "Саха Якутия"
            4) "Саха Якутия НеплОха"

      # Выполняем шаги 1-3, и получаем обработанные строки:

        - Строка-объект:

            "саха якутия вовсе неплоха"

        - И 4 вот такие строки-кандидата:

            1) "саха якут"
            2) "саха якути"
            3) "саха якутия"
            4) "саха якутия неплоха"

      # Выполняем шаги 4-7, и получаем кол-во баллов для каждой строки-кандидата:

        1) "саха якут" - 1.66 балла.

          # саха
            +1 балл   | Полное совпадение со словом "саха" в СО

          # якут
            +4/6 = 0.66  | Входит в 4 первых из 6 букв в слове "якутия" в СО

        2) "саха якути" - 1.83 балла

          # саха
            +1 балл   | Полное совпадение со словом "саха" в СО

          # якути
            +5/6 = 0.83  | Входит в 5 первых из 6 букв в слове "якутия" в СО

        3) "саха якутия" - 2 балла

          # саха
            +1 балл   | Полное совпадение со словом "саха" в СО

          # якутия
            +1        | Полное совпадение со словом "якутия" в СО

        4) "саха якутия неплоха" - 3 балла

          # саха
            +1 балл   | Полное совпадение со словом "саха" в СО

          # якутия
            +1        | Полное совпадение со словом "якутия" в СО

          # неплоха
            +1        | Полное совпадение со словом "неплоха" в СО

      # В итоге строки-кандидаты занимают следующие позиции по релевантности:

        1) "саха якутия неплоха"
        2) "саха якутия"
        3) "саха якути"
        4) "саха якут"






--////----------------------------------------------------------////
  ////                                                          ////
  ////     16.11. Подготовка базы ipgeobase к использованию     ////
  ////                                                          ////
  ////----------------------------------------------------------////

    1. Скачать базу ipgeobase
      - Скачать последнюю версию базы можно здесь:
          http://ipgeobase.ru/cgi-bin/Archive.cgi
      - Это будет архив "geo_files.zip".
      - Из архива извлечь 2 файла: "cidr_optim.txt" и "cities.txt".
      - Файл cities.txt преобразовать в UTF-8 без BOM.

    2. Подготовить пустую таблицу "m3_ipgeobase_ips"
      - В ней должны быть следующие столбцы, в таком же порядке:

          # id            | int         | id с автоинкрементом
          # ip_num_min    | varchar(45) | начальный ip блока, преобразованный в число
          # ip_num_max    | varchar(45) | конечный ip блока, преобразованный в число
          # ip_block      | varchar(100)| блок ip-адресов в формате: "начальный_ip - конечный_ip"
          # country_code  | varchar(45) | 2-значный код страны
          # city_code     | varchar(45) | код населённого пункта для поиска его в "m3_ipgeobase_cities"

      - Установить уникальные индексы на "ip_num_min" и "ip_num_max".
      - Для этого можно выполнить следующий SQL-код:

          CREATE TABLE `grumart_v2`.`m3_ipgeobase_ips` (
            `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
            `ip_num_min` INT UNSIGNED NOT NULL,
            `ip_num_max` INT UNSIGNED NOT NULL,
            `ip_block` VARCHAR(45) NOT NULL,
            `country_code` VARCHAR(45) NOT NULL,
            `city_code` VARCHAR(45) NOT NULL,
            PRIMARY KEY (`id`),
            UNIQUE INDEX `id_UNIQUE` (`id` ASC));

    3. Подготовить пустую таблицу "m3_ipgeobase_cities"
      - В ней должны быть следующие столбцы, в таком же порядке:

          # id            | int         | id с автоинкрементом
          # city_code     | varchar(45) | код города
          # city_name     | varchar(45) | имя населённого пункта
          # region        | varchar(45) | имя субъекта РФ
          # fedDistrict   | varchar(45) | имя федерального округа
          # latitude      | varchar(45) | широта
          # longitude     | varchar(45) | широта

      - Установить уникальный индекс на "city_code".
      - Для этого можно выполнить следующий SQL-код:

            CREATE TABLE `grumart_v2`.`m3_ipgeobase_cities` (
              `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
              `city_code` VARCHAR(45) NOT NULL,
              `city_name` VARCHAR(45) NOT NULL,
              `region` VARCHAR(45) NOT NULL,
              `fedDistrict` VARCHAR(45) NOT NULL,
              `latitude` VARCHAR(45) NOT NULL,
              `longitude` VARCHAR(45) NOT NULL,
              PRIMARY KEY (`id`),
              UNIQUE INDEX `city_code` (`city_code` ASC));

    4. Загрузить данные в созданные таблицы
      - Загрузить данные в "m3_ipgeobase_ips" из "cidr_optim.txt":

          LOAD DATA INFILE '[..путь к файлу..]/cidr_optim.txt'
            INTO TABLE m3_ipgeobase_ips
            COLUMNS
              TERMINATED BY '\t'
            LINES
              TERMINATED BY '\n'
            (ip_num_min,ip_num_max,ip_block,country_code,city_code);

      - Загрузить данные в "m3_ipgeobase_cities" из "cities.txt":

          LOAD DATA INFILE '[..путь к файлу..]/cities.txt'
            INTO TABLE m3_ipgeobase_cities
            COLUMNS
              TERMINATED BY '\t'
            LINES
              TERMINATED BY '\n'
            (city_code,city_name,region,fedDistrict,latitude,longitude);



--////-------------------------------------////
  ////                                     ////
  ////     16.12. Алгоритмы геолокации     ////
  ////                                     ////
  ////-------------------------------------////

    1. Алгоритм геолокации по IP

      1.0. Проводим геолокацию, только если нет куки geolocation.

      1.1. Получаем данные о местонахождении пользователя:

        1.1.1. Либо из API Яндекс.Карт
          - Используем объект ymaps.geolocation.
          - Получаем следующие данные:

            # latitude  | широта
            # longitude | долгота
            # city      | название города
            # region    | название региона
            # country   | название страны

          - Если country не "Россия", завершаем геолокацию.
          - Считаем, что выбран город по умолчанию - Москва.

        1.1.2. Либо из базы ipgeobase
          - Извлекаем его IP-адрес.
          - Преобразуем его в число. Адрес a.b.c.d преобразуется так:
              256³*a+256²*b+256*c+d
          - Ищем в "m3_ipgeobase_ips" строку, которой соответствует это число
            (оно должно быть > ip_num_min и < ip_num_max).
          - Если не находим, завершаем геолокацию дефолтной локацией.
          - Если находим, то извлекаем код города city_code.
          - В "m3_ipgeobase_cities" находим строку с соотв. кодом города.
          - Завершаем геолокацию дефолтной локацией, если:
            - region != ("Крым"|"Севастополь") и
            - fedDistrict содержит слово "Украина".
          - Сохраняем в переменные city_name, region, latitude, longitude.
          - В итоге получаем следующие данные:

            # latitude  | широта
            # longitude | долгота
            # city      | название города
            # region    | название региона
            # country   | название страны

      1.2. Определяем номер региона.
        - Ищем в таблице "m3_fias_regions_timezones".
        - Используем region из п.1.1.
        - Используем для обоих значений алгоритм неточного поиска.
        - Есле регион НЕ Саха или Сахалин:
          - То сразу извлекаем информацию о часовой зоне.
          - В итоге получаем следующие данные:

            # regionNum
            # timezoneNum
            # offset

        - Есле регион Саха или Сахалин:
          - То извлекаем пока лишь номер региона.
          - Т.Е. в Сахе 3 часовых зоны, а на сахалине 2.
          - И чтобы узнать часовую зону, сначала нужно узнать район.
          - В итоге получаем следующие данные:

            # regionNum

      1.3. Находим город / нас.пункт в ФИАС

        1.3.1. Используем regionNum и city.

        1.3.2. Пробуем искать по city путём точного сравнения.
          - Ищем только среди городов / нас.п. (aolevel = 4 || 6).
          - Если получилось, переходим к 1.3.4.
          - Если не получилось, переходим к 1.3.3.

        1.3.3. Пробуем искать по city, используя алгоритм неточного поиска.
          - Ищем только среди городов / нас.п. из региона regionNum.
          - Если получилось, переходим к 1.3.4.
          - Если не получилось:
            - считаем, что выбран город по умолчанию - Москва;
            - завершаем геолокацию.

        1.3.4. Если найдено более 1 результата
          - Проверяем актуальность записей. Выбираем только актуальные.
          - Если всё равно > 1 результата, выбираем первый попавшийся.

        1.3.5. Извлекаем инфу о типе объекта
          - Извлекаем shortname (сокращённое имя типа объекта).
          - Ищем в таблице "m3_fias_socrbase" полное имя типа объекта.
          - Для этого сравниваем shortname со столбцом scname.

        1.3.6. Записываем следующую информацию:

            # aoid          | uid объекта в ФИАС
            # formalname    | имя города / нас.пункта
            # areacode      | код района в ФИАС
            # citycode      | код города в ФИАС
            # placecode     | код нас.п. в ФИАС
            # centstatus    | статус центра в ФИАС
            # socrname      | полное имя типа объекта (аул, посёлок, село, город ...)

      1.4. Находим регион в ФИАС
        - Используя regionNum находим объект-регион в ФИАС.
        - Извлекаем shortname (сокращённое имя типа объекта).
        - Ищем в таблице "m3_fias_socrbase" полное имя типа объекта.
        - Для этого сравниваем shortname со столбцом scname.
        - Итого, записываем следующие данные

            # aoid        | uid объекта ФИАС (региона)
            # formalname  | имя региона
            # socrname    | полное имя типа объекта (республика, край, область ...)

      1.5. Находим район в ФИАС
        - Используя regionNum и areacode.
        - Извлекаем shortname (сокращённое имя типа объекта).
        - Ищем в таблице "m3_fias_socrbase" полное имя типа объекта.
        - Для этого сравниваем shortname со столбцом scname.
        - Итого, записываем следующие данные

            # aoid        | uid объекта ФИАС (района)
            # formalname  | имя района
            # socrname    | полное имя типа объекта (район ...)

      1.6. Если часовая зона не найдена ранее, определяем её
        - Ищем в таблице "m3_fias_regions_timezones".
        - Используем aoid района.
        - В результате получаем:

            # timezoneNum
            # offset

      1.7. Сохраняем в таблицу пользователей следующие данные:

          # countryName     | имя страны, по умолчанию "Россия".

          # cityId          | uid объекта-города в ФИАС (aoid)
          # cityName        | имя города / нас.пункта (formalname в ФИАС)
          # cityType        | полное имя типа объекта (деревня, город, и т.д.)

          # districtId      | uid объекта-района в ФИАС (aoid)
          # districtName    | имя района (formalname в ФИАС)
          # districtType    | полное имя типа объекта (район и т.д.)

          # regionId        | uid объекта-региона в ФИАС (aoid)
          # regionName      | имя региона (formalname в ФИАС)
          # regionNum       | номер региона
          # regionType      | полное имя типа объекта (край, область, республика и т.д.)

          # centerStatus    | какой признак центра

          # UTC_offset      | UTC-смещение

      1.8. Устанавливаем пользователю вечную куку
        - О том, что он прошёл геолокацию, и больше не надо.
        - Имя куки: geolocation.
        - Значение: адрес нас. пункта человекопонятным языком.
          Например: "Россия, Московская область, город Красногорск".


    2. Алгоритм геолокации при выборе локации пользователем вручную

      2.1. Геолокация проводится по требованию пользователя.
        - Он сам нажимает на специальную кнопку, и запускает процесс.

      2.2. Пользователь выбирает город / н.пункт в базе ФИАС

        2.2.1. Выбор через интерфейс ajax-поиска по городам/н.пунктам в ФИАС
          - Пользователь начинает вводить название города/н.пункта, где он проживает.
          - После каждого нажатия на сервер отправляется ajax-запрос с введённой строкой.
          - Производится поиск в таблице m3_fias_addrobj по индексированному столбцу formalname, по всей таблице.
          - В выпадающем списке пользователь может выбрать из 7 первых результатов.
          - После клика по результату, выбор считается осуществлённым.

        2.2.2. Выбор через 2-ступенчатый интерфейс
          - Пользователь из списка выбирает имя субъекта РФ.
          - Появляется список городов и нас.пунктов этого субъекта.
          - В нём состоят только те, у которых centstatus != 0.
          - То есть это столица субъекта, и админ.центры районов.
          - Причём столица субъекта выделяется жирным, а её areacode всегда == '000'.
          - После клика по гор./н.пункту, выбор считается осуществлённым.

        2.2.3. В итоге мы имеем следующую информацию:

            # aoid          | uid объекта в ФИАС
            # formalname    | имя города / нас.пункта
            # regioncode    | код субъекта РФ
            # areacode      | код района в ФИАС
            # citycode      | код города в ФИАС
            # placecode     | код нас.п. в ФИАС
            # centstatus    | статус центра в ФИАС
            # shortname     | короткое имя типа объекта

        2.2.4. Извлекаем полное имя типа объекта
          - Используя shortname берём из "m3_fias_socrbase" полное имя типа.
          - Для этого сравниваем shortname со столбцом scname.
          - Получаем:

            # socrname      | полное имя типа объекта (аул, посёлок, село, город ...)

      2.3. Находим регион в ФИАС
        - Используя regioncode находим объект-регион в ФИАС.
        - Извлекаме shortname (сокращённое имя типа объекта).
        - Ищем в таблице "m3_fias_socrbase" полное имя типа объекта.
        - Для этого сравниваем shortname со столбцом scname.
        - Итого, записываем следующие данные

            # aoid        | uid объекта ФИАС (региона)
            # formalname  | имя региона
            # socrname    | полное имя типа объекта (республика, край, область ...)

      2.4. Находим район в ФИАС
        - Используя regioncode и areacode.
        - Извлекаме shortname (сокращённое имя типа объекта).
        - Ищем в таблице "m3_fias_socrbase" полное имя типа объекта.
        - Для этого сравниваем shortname со столбцом scname.
        - Итого, записываем следующие данные

            # aoid        | uid объекта ФИАС (района)
            # formalname  | имя района
            # socrname    | полное имя типа объекта (район ...)

      1.6. Находим часовую зону и смещение

        1.6.1. Если regioncode != (14 | 65)
          - Если мы имеем дело не с Сахой или Сахалином.
          - По номеру региона ищем в m2_fias_regions_timezones.
          - Находим номер часовой зоны и UTC-смещение:

            # timezoneNum
            # offset

        1.6.2. Если regioncode == (14 | 65)
          - Если мы имеем дело с Сахой или Сахалином.
          - Ищем по номеру региона и aoid района.
          - Находим номер часовой зоны и UTC-смещение района:

            # timezoneNum
            # offset

      1.7. Сохраняем в таблицу пользователей следующие данные:

          # countryName     | имя страны, по умолчанию "Россия".

          # cityId          | uid объекта-города в ФИАС (aoid)
          # cityName        | имя города / нас.пункта (formalname в ФИАС)
          # cityType        | полное имя типа объекта (деревня, город, и т.д.)

          # districtId      | uid объекта-района в ФИАС (aoid)
          # districtName    | имя района (formalname в ФИАС)
          # districtType    | полное имя типа объекта (район и т.д.)

          # regionId        | uid объекта-региона в ФИАС (aoid)
          # regionName      | имя региона (formalname в ФИАС)
          # regionNum       | номер региона
          # regionType      | полное имя типа объекта (край, область, республика и т.д.)

          # centerStatus    | какой признак центра

          # UTC_offset      | UTC-смещение

      1.8. Устанавливаем пользователю вечную куку
        - О том, что он прошёл геолокацию, и больше не надо.
        - Имя куки: geolocation. Значение:
        - Значение: адрес нас. пункта человекопонятным языком.
          Например: "Россия, Московская область, город Красногорск".


--////-----------------------------------------------------------////
  ////                                                           ////
  ////  16.13. Как организовать быстрый AJAX-поиск по базе ФИАС  ////
  ////                                                           ////
  ////-----------------------------------------------------------////

  --//--------------------//
    // 1. Описание задачи //
    //--------------------//

      - Допустим, мы хотим сделать "ручную" геолокацию.
      - Чтобы пользователь мог внучную выбрать свой нас.пункт из ФИАС.
      - Он начанает вводить имя своего нас.пункта в текстовое поле.
      - Допустим, он живёт в Москве, и начинает вводить:

          ----------------
          | Моск         |
          ----------------

      - И ему вылазит до 5 подходящих вариантов городов.
      - Он может щёлкнуть по 1-му из них, и т.о. выбрать его.
      - А если там нет подходящего, то может продолжить писать.

  --//----------------------//
    // 2. Описание проблемы //
    //----------------------//

      - В базе ФИАС более 2 миллионов строк.
      - А запрос должен быть быстрым, 1-2-3 секунды.
      - Иначе пользователю будет некомфортно ждать результатов.
      - Вопрос в том, как сделать его быстрым?

  --//------------//
    // 3. Решение //
    //------------//

      - Надо использовать полнотекстовый индекс на столбце formalname таблицы m3_fias_addrobj.
      - Плюс нюанс для объектов с aolevel = '6'.
      - Среди них есть не нужные нам объекты, вроде дорог, местечек и т.д.
      - Поэтому нужно ещё проводить отсеивание по shortname. Вот это оставляем:

          городок     | городок
          х           | хутор
          у           | улус
          ст-ца       | станица
          сл          | слобода
          рп          | рабочий посёлок
          починок     | починок
          пгт         | посёлок городского типа
          п/ст        | посёлок и(при) станция(и)
          п           | посёлок
          нп          | населённый пункт
          кп          | курортный посёлок
          заимка      | заимка
          дп          | дачный посёлок
          д           | деревня
          г           | город
          аул         | аул
          аал         | аал

      - Поиск должен срабатывать, когда введено минимум 4 символа.
      - Итак, вот как выглядит итоговой SQL-запрос, который выдаёт 5 результатов:

          SELECT * FROM m3_fias_addrobj
            WHERE
              MATCH(formalname) AGAINST('Москва*' IN BOOLEAN MODE)  &&
              (aolevel = '1' || aolevel = '4' || aolevel = '6')     &&
              actstatus = '1'                                       &&
              (
                shortname = 'городок' ||
                shortname = 'х'       ||
                shortname = 'у'       ||
                shortname = 'ст-ца'   ||
                shortname = 'сл'      ||
                shortname = 'рп'      ||
                shortname = 'починок' ||
                shortname = 'пгт'     ||
                shortname = 'п/ст'    ||
                shortname = 'п'       ||
                shortname = 'нп'      ||
                shortname = 'кп'      ||
                shortname = 'заимка'  ||
                shortname = 'дп'      ||
                shortname = 'д'       ||
                shortname = 'г'       ||
                shortname = 'аул'     ||
                shortname = 'аал'
              )
            HAVING formalname LIKE 'Москва%'
            LIMIT 5;

      - *Внимание: строку поиска надо писать в 2-х местах запроса,
                   1) В MATCH ... AGAINST
                   2) В HAVING ... LIKE


А17. Как пользоваться CSRF-токеном в Laravel

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Применяется для защиты своих API
    - Принцип работы защиты роутов на основе CSRF-токена
    - CSRF-атака: как работает, зачем защищаться
    - Как применить фильтр к REST-контроллеру
    - Код CSRF-фильтра

  --------------------------------------

  > Ссылки

      - Межсайтовая подделка запроса, wiki:
          https://ru.wikipedia.org/wiki/Межсайтовая_подделка_запроса

      - Как работать с CSRF-фильтром в laravel, stackoverflow:
          http://stackoverflow.com/questions/20444236/laravel-4-csrf-form-submit-through-ajax-call

  > Введение
    - CSRF расшифровывается, как Cross Site Request Forgery.
    - CSRF расшифровывается, как МСП, Межсайтовая Подделка Запроса.
    - CSRF-токен является частью механизма защиты.
    - Он позволяет защитить API от ajax-запросов не "из этого" документа.
    - Это пресекает попытки осуществить CSRF-атаки.
    - Это пресекает попытки использовать в своих нуждах наши публичные API.

  > Применяется для защиты своих API
    - Защита на основе CSRF-токена применяется для защиты API сайта.
    - То есть, это и есть область применения данной защиты.

  > Принцип работы защиты роутов на основе CSRF-токена

    1) Laravel при создании каждой сессии кладёт в неё новый токен
      - Получить его так: Session::token()

    2) На страницу, с которой будем делать ajax-запрос, передаём значение токена
      - Передаём на страницу в виде переменной значение Session::token()
      - Допустим, она доступна на странице через переменную $token.

    3) Записываем переданное на страницу значение в JS-модель
      - В переменную _token.
      - Делается это в конце представления страницы, через тег script.

    4) Когда делаем ajax-запрос, передаём с ним и значение $token
      - Значние $token передаём в HTTP-заголовке 'X-CSRF-Token'.
      - Либо передаём в параметре '_token'.

    5) Перед роутами, которые хотим защитить, мы стамим CSRF-фильтр
      - В нём извлекаем пришедшее в заголовке или параметра значение $token.
      - И сравниваем его с токеном из сессии.
      - Если они равны, то пропускаем запрос в роут. А если нет, то нет.


  > CSRF-атака: как работает, зачем защищаться

    # Как работает
      1) Заходит на наш сайт X посетитель, и авторизуется.
      2) Теперь у него в браузере для сайта X есть авторизационная кука.
      3) Затем он заходит на сайт Y, который принадлежит злоумышленнику.
      4) Злоумышленник с Y посылает ajax-запрос к API сайта X.
      5) Допустим, он посылает запрос к API смены пароля пользователя.
      6) В итоге, аккаунт пользователя взломан.

    # Зачем защищаться
      - Чтобы всякие злоумышленники юзали API моего сайта от лица пользователей.

  > Несанкционированная эксплуатация моих API: как работает, зачем защищаться

    # Как работает
      1) Допустим, я делал на сайте X API для геолокации.
      2) Ему отправляешь начало имени города, оно возвращает инфу в json.
      3) А у злоумышленника есть сайт Y, и ему тоже нужно такое API.
      4) И он берёт и начинает пользоваться моим API, делая ajax-запросы к нему.
      5) В итоге мой сервер, за который я плачу, перегружен левыми запросами.

    # Зачем защищаться
      - Чтобы мои API можно было использовать лишь через интерфейсы на моем сайте.
      - Ну кроме тех API, которые я хочу сделать общедоступными.

  > Как применить фильтр к REST-контроллеру

    # 1 способ
      - В глобальной группе, которая включает в себя и Пса Any.
      - Это первая строка с кодом в файле routes.php.
      - Вот её начало:

          Route::group(array('before' => array('authentication', ...

    # 2 способ
      - Часто надо применить CSRF-фильтр к конкретному контроллеру.
      - В этом случае это можно сделать в его конструкторе, вот так:

          public function __construct() {

             // Применяем CSRF befor-фильтр в конструкторе контроллера
             $this->filter('before', 'csrf');

          }

  > Код CSRF-фильтра

      Route::filter('csrf', function()
      {

        // Работает только с POST-запросами
        // - Потому что у меня все API работают только через POST-запросы
        if(Request::isMethod('post')) {

          // Если это ajax-запрос:
          // - Получим токен или из http-заголовка X-CSRF-Token
          // - Или получием его из параметра "_token" во входяхих данных
          $token = Request::ajax() ? Request::header('X-CSRF-Token') : Input::get('_token');

          // Если значение токена в сессии не совпадает с полученным, то:
          // - Возможно, это CSRF-атака.
          // - Блокируем этот запрос.
          if (Session::token() != $token)
          {
            throw new Illuminate\Session\TokenMismatchException;
          }

        }

      });


А18. Каталог в интернет-магазине

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение

    - Теоретические основы: декомпозиция
    - Структуры данных
    - План разработки


  --------------------------------------

  > Ссылки

    - Александр Бондарь рассказывает в т.ч. про требования к каталогу
        http://www.youtube.com/watch?v=KxuHa4ahkpk

  > Введение
    - В этой главе обсуждаем, как сделать каталог в интернет-магазине.
    - И, как результат этого обсуждения, получаем готовый точный рецепт.

  > Теоретические основы: декомпозиция

    А18.  Каталог в интернет-магазине
      А18.1.  Дерево каталогов
        - Как устроено дерево каталогов.
        - Где у дерева корень. Уровни каталогов в дереве.
        - Что такое [К]-каталог и [О]-каталог.
        - Находясь в каталоге X, из каких каталогов отображать товары?

      А18.2.  Контейнеры и товары
        - Все товары хранятся в таблице товаров.
        - Характеристики каждой тов.категории хранятся в соотв. таблице характеристик.
        - Каждый товар лежит в контейнере. Нет товаров не в контейнерах.
        - Описывается необходимость применения контейнеров в современном каталоге и-магазина.
        - Описывается, как учитывать популярность и рейтинг, применяя контейнеры.

      А18.3.  Настройка таблиц характеристик для [К]-каталогов
        - Каждый [К]-каталог обладает своей таблицей характеристик
        - Столбцы таблицы характеристик [К]-каталога можно настраивать через веб-интерфейс.
        - Для столбца можно указывать: Имя, описание, тип, обязательность, инфу о фильтре.
        - Должны быть доступны для настройки столбцы из таблицы товаров - ч.м.б. повесить на них фильтры.

      А18.4.  Настройка фильтров для [К]-каталогов
        - Для [К]-каталогов можно устанавливать фильтры.
        - Бывают разные типы фильтров, типов может быть сколько угодно.
        - Есть 2 режима определения очерёдности показа фильтров: автоматический и ручной.
        - Популярность фильтра определяется кол-во его использований.

      А18.5.  Система сохранения целостности данных
        - У каждого товара должны быть на 100% заполнены обяз. поля. Всегда.
        - Только если в [К]-каталоге 0 товаров можно изменять обяз.столбцы табл.характеристик
        - При добавл./измен. товара должны быть указаны все обяз.свойства
        - Товары могут добавляться лишь внутрь [К]-каталогов

      А18.6.  Система политик: наценки, скидки, спецпредложения
        - Политику можно настроить так, чтобы она действовала на конкретные товары.
        - Политика применяется к данным перед отправкой
        - Политика влияет на ценообразование, скидки, участие в спецпредложениях.

  > А18.1.  Дерево каталогов

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция

    --------------------------------------

    > Введение
      - Как устроено дерево каталогов.
      - Где у дерева корень. Уровни каталогов в дереве.
      - Что такое [К]-каталог и [О]-каталог.
      - Находясь в каталоге X, из каких каталогов отображать товары?

    > Декомпозиция

      А18.1.  Дерево каталогов
        А18.1.1.  Что такое дерево каталогов
          - Примерно тоже самое, что папки в Windows.
          - Папка "Каталог" - 0-й уровнень. Является условностью.
          - Все реальные каталоги имеют уровень от 1 и выше.
          - На 1-й уровень есть смысл класть лишь [К]-каталоги.
          - Вот схематичная иллюстрация:

                Каталог                 | 0 ур.
                  Телефоны              | 1 ур. [К]-кат.
                    Смартфоны           | 2 ур.
                      Ударопрочные      | 3 ур.
                    Кнопочные           | 2 ур.
                  Текстиль              | 1 ур. [К]-кат.
                    Постельное бельё    | 2 ур.
                    Шторы               | 2 ур.
                  Ботинки               | 1 ур. [К]-кат.
                    Мужские             | 2 ур.
                    Женские             | 2 ур.

        А18.1.2.  [К]-каталоги и [О]-каталоги
          - [К]-каталоги имеют свою таблицу характеристик товара, а [О]-каталоги нет.

        А18.1.3.  Принцип отображения товаров
          - Допустим, мы находимся в каталоге X. Какие товары показывать?
          - Все товары в каталоге X, кроме находящихся в [К]-каталогах.

    > А18.1.1.  Что такое дерево каталогов
      - Это примерно как папки в Windows.
      - Только не для файлов, а для контейнеров с товарами.
      - Они могут быть вложены друг в друга, и образуют дерево.
      - Корнем этого дерева является каталог "Каталог". Это 0-й уровень.
      - Этот каталог - условность. На самом деле его не существует.
      - Вот пример дерева каталогов:

            Каталог
              Средства связи
                Телефоны
                Смартфоны
                  Ударопрочные
              Бытовая техника
                Утюги
                Холодильники

    > А18.1.2.  [К]-каталоги и [О]-каталоги

     # [К]-каталоги
      - Корневые [К]-каталоги имеют свою таблицу характеристик товара.
      - При создании [К]-каталога, автоматом создаётся и таблица характ.товара.
      - На 1-м уровне каталога есть смысл размещать только [К]-каталоги.
      - Т.К. если разместить [О]-каталоги, они будут недоступныд для просмотра.

     # [О]-каталоги
      - Обычные [О]-каталоги не имеют свою таблицу характеристик товара.
      - Они пользуются таковой, принадлежащей ближайшему предку - [К]-каталогу.
      - Как следствие, тоже самое относится и к фильтрам [О]-каталогов.

    > А18.1.3.  Принцип отображения товаров

      > Каталог-пример для иллюстрации

                    [К] - корневой      [О] - обычный

        [К] Средства связи
          [О] Смартфоны
            [О] Обычные
            [О] Ударопрочные
          [О] Телефоны
          [К] Трансгалактические передатчики
            [О] Криптогенные трансмиттеры
              [О] Атомно-силовые станции
              [О] Плазмо-фотонные пронизыватели
            [О] Зенонские наручные устройства

      > Разберёмся на примерах
        - Вопрос в том, какие товары показывать в каком из каталогов?
        - Рассмотрим случаи, когда пользователь находится в том или ином каталоге.
        - И покажем, товары из каких каталогов отображать.

        # Пользователь находится в каталоге "Средства связи"

          - Показываем товары из этих каталогов:

            [К] Средства связи      |
              [О] Смартфоны         |
                [О] Обычные         | - и показываем фильтры каталога "Средства связи"
                [О] Ударопрочные    |
              [О] Телефоны          |

          - Показываем ссылки на следующие каталоги:

            [О] Смартфоны
            [О] Телефоны

        # Пользователь находится в каталоге "Смартфоны"

          - Показываем товары из этих каталогов:

            [О] Смартфоны           |
              [О] Обычные           | - и показываем фильтры каталога "Средства связи"
              [О] Ударопрочные      |

          - Показываем ссылки на следующие каталоги:

            [О] Обычные
            [О] Ударопрочные

        # Пользователь находится в каталоге "Телефоны"

          - Показываем товары из этих каталогов:

            [О] Телефоны            | - и показываем фильтры каталога "Средства связи"

          - Показываем ссылки на следующие каталоги:

            пусто

        # Пользователь находится в каталоге "Трансгалактические передатчики"

          - Показываем товары из этих каталогов:

            [К] Трансгалактические передатчики      |
              [О] Криптогенные трансмиттеры         |
                [О] Атомно-силовые станции          | - и показываем фильтры каталога "Трансгалактические передатчики"
                [О] Плазмо-фотонные пронизыватели   |
              [О] Зенонские наручные устройства     |

          - Показываем ссылки на следующие каталоги:

            [О] Криптогенные трансмиттеры
            [О] Зенонские наручные устройства

        # Пользователь находится в каталоге "Криптогенные трансмиттеры"

          - Показываем товары из этих каталогов:

            [О] Криптогенные трансмиттеры           |
              [О] Атомно-силовые станции            | - и показываем фильтры каталога "Трансгалактические передатчики"
              [О] Плазмо-фотонные пронизыватели     |

          - Показываем ссылки на следующие каталоги:

            [О] Атомно-силовые станции
            [О] Плазмо-фотонные пронизыватели


  > А18.2.  Контейнеры и товары

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция

    --------------------------------------

    > Введение
      - Все товары хранятся в таблице товаров.
      - Характеристики каждой тов.категории хранятся в соотв. таблице характеристик.
      - Каждый товар лежит в контейнере. Нет товаров не в контейнерах.
      - Описывается необходимость применения контейнеров в современном каталоге и-магазина.
      - Описывается, как учитывать популярность и рейтинг, применяя контейнеры.

    > Декомпозиция

      А18.2.  Контейнеры и товары
        А18.2.1.  Таблица товаров
          - Все товары интернет-магазина хранятся в таблице товаров.

        А18.2.2.  Таблицы характеристик товаров у [К]-каталогов
          - Характеристики каждой тов.категории хранятся в соотв. таблице характеристик.
          - Таблица характеристих жёстко связана с соотв. [К]-каталогом.

        А18.2.3.  Контейнеры
          - Каждый товар лежит в контейнере. Нет товаров не в контейнерах.
          - Это позволяет показывать разные компл. товара, как 1, но вести раздельный учет.

        А18.2.4.  Обоснование необходимости контейнеров
          - Конт-р позв-ет показывать все товары в нём, как один (напр., обувь разн.размеров)
          - Конт-р позв-ет показывать кажд. товар в нём по отдельности (напр., iphone разных цветов)
          - Конт-р позв-ет для всех товаров в нём иметь единую стр.товара.
          - И на этой странице контейнер позволяет выбирать среди товаров в нём.

        А18.2.5.  Популярность и отзывы+рейтинг товаров
          - Популярность товара, это кол-во его просмотров пользователями.
          - Пользователи могут оставлять отзывы о товаре с оценкой от 1 до 5 баллов.
          - Рейтинг товара, это средняя его оценка пользователями.
          - Описывается, как учитывать популярность и рейтинг, применяя контейнеры.

        А18.2.6.  Система учёта остатков
          - Есть система для начинающих, а есть для развитых ИМ.
          - Система для начинающих работает с тов.позициями, но не товарами поштучно.
          - Системад для развитых работает с товарами поштучно.

        А18.2.7.  Простая статистика
          - Необходимо вести статистику о прожадах в отдельнйо таблице.
          - По этой статистике можно строить графики и вычислять ROI и т.д.
          - Так можно узнавать, какие товары когда выгднее всего продавать. И тренды.

        А18.2.8.  Автоматическая система округления цен
          - Её можно как включить, так и выключить.
          - Здесь описано, как она работает.

        А18.2.9.  Популярность и отзывы + оценки + рейтинги
          - Популярность тов.позиции, это кол-во кликов по ней за всё время.
          - Пользователи могут оставлять отзывы о товаре.

    > А18.2.1.  Таблица товаров
      - Все товары интернет-магазина хранятся в таблице товаров.
      - Но в ней хранятся лишь общие (есть у всех) для всех товаров свойства.
      - Например: id, имя, описание, ... .
      - Характеристики товаров в ней хранить нельзя.
      - Их слишком много, а таблица вмещает максимум до 4096 столбцов, это мало.

    > А18.2.2.  Таблицы характеристик товаров у [К]-каталогов
      - Поэтому каждую отдельную товарную категорию помещают в [К]-каталог.
      - При создании [К]-каталога автоматически создаётся пустая таблица характеристик.
      - Мы добавляем туда нужные столбцы-характеристики, настраиваем её.
      - И после завершения настройки наполняем её контейнерами с товарами.

    > А18.2.3.  Контейнеры
      - Каждый товар лежит в контейнере. Нет товаров не в контейнерах.
      - Контейнер знает все о товарах, которые в нём лежат.
      - Контейнер позволяет решить вопрос с комплектациями одного и того же товара.
      - Например, можно показывать одну модель ботинок разных размеров, как 1 товар.
      - Но при этом вести учёт разных размеров этих ботинок, как разных товаров.

    > А18.2.4.  Обоснование необходимости контейнеров
      - Бывает, что >= 2 товаров одинаковы. Отличие лишь в мелких деталях.
      - В одном случае, хотелось бы показывать их в каталоге, как разные товары:

                            iPhone 6      iPhone 6
                              белый        чёрный

      - В другом случае, хотелось бы показывать их в каталоге, как 1 товар.
      - Допустим, у нас есть 10 размеров кроссовок Nike Air. Показываем, как 1:

                                  Кроссовки
                                   Nike Air

      - Во всех случаях для них должна быть 1, общая страница товара.
      - Щёлкнули, скажем, по "iPhone 6 белый", попали на общую страницу.
      - А на ней можно уже выбрать конкретную модель.

         ○   [картинка]   iPhone 6 белый 16гб    [краткое описание]   [цена]
         •   [картинка]   iPhone 6 белый 32гб    [краткое описание]   [цена]
         ○   [картинка]   iPhone 6 черный 16гб   [краткое описание]   [цена]
         ○   [картинка]   iPhone 6 черный 32гб   [краткое описание]   [цена]

      - Чтобы этого добиться, надо разложить все товары по контейнерам.
      - Для этих контейнеров у нас есть таблица m4_containers.
      - При создании товара автоматически создаётся и контейнер для него.
      - Контейнер получает тот же id, что у товара, и является "родным" для него.

          m4_goods                     m4_containers
          --------------------------   --------------------------
            ID    Имя                    ID    Имя
            555   iPhone6 16гб белый     555   iPhone6

      - Товар после создания можно переложить в контейнер другого товара.
      - Но "родной" контейнер для него всё равно остаётся.
      - Контейнер в любой момент обладает актуальной информацией о содержащихся в нём товарах.

    > А18.2.5.  Популярность и отзывы+рейтинг товаров
      - Популярность товара, это кол-во его просмотров пользователями.
      - Пользователи могут оставлять отзывы о товаре с оценкой от 1 до 5 баллов.
      - Рейтинг товара, это средняя его оценка пользователями.
      - Вопрос в том, как учитывать популярность и рейтинг, применяя контейнеры?
      - Рассмотрим для прояснения этих вопросов несколько случаев:

        Случай 1
        -----------------------------
        | - Мы продаём ботинки
        | - У нас есть 10 разных размеров ботинок
        | - Мы хотим показывать их, как 1 товар в каталоге
        | - Мы хотим, чтобы у них у всех был общий счётчик популярности
        | - Мы хотим, чтобы у них были общие отзывы и рейтинг
        |

          Как в мы в этом случае должны начислять баллы?
          - При клике по товару начисляем 1 балл контейнеру.
          - При отзыве связываем его с контейнером, и добавляем баллы контейнеру.

        Случай 2
        -----------------------------
        | - Мы продаём iphone'ы
        | - У нас есть 10 разных по цвету и памяти моделей
        | - Мы хотим показывать их, как разные товары в каталоге
        | - Мы хотим, чтобы у каждого из них был свой счётчик популярности
        | - Мы хотим, чтобы у них были общие отзывы и рейтинг
        |

          Как в мы в этом случае должны начислять баллы?
          - При клике по товару начисляем 1 балл этому товару.
          - При отзыве связываем его с контейнером, и добавляем баллы контейнеру.

        Случай 3
        -----------------------------
        | - Мы продаём iphone'ы
        | - У нас есть 10 разных по цвету и памяти моделей
        | - Мы хотим показывать их, как разные товары в каталоге
        | - Мы хотим, чтобы у каждого из них был свой счётчик популярности
        | - Мы хотим, чтобы у каждого из них были свои отзывы и рейтинги
        |

          Как в мы в этом случае должны начислять баллы?
          - При клике по товару начисляем 1 балл этому товару.
          - При отзыве связываем его с товаром, и добавляем баллы товару.

    > А18.2.6.  Система учёта остатков

      > Упрощённый вариант для начала
        - Этот вариант используется на начальном этапе развития ИМ.
        - Остатки учитываются для каждой товарной позиции.
        - Для этого в таблице товарных позиций есть 4 свойства:

          count             | кол-во товара в наличие у нас на складе
          supplierwarehouse | доступен ли товар на складе поставщика (0 | 1)
          costpricewar      | себестоимость со своего склада
          costpricesup      | себестоимость со склада поставщика

        - Работает это всё следующим образом. Рассмотрим варианты:

          # count == 0, supplierwarehouse == 0
            - Значит товара нет ни у нас наскладе, не у поставщика.
            - Показываем клиенту, что этот товар "под заказ".
            - Ни в коем случае не говорим, что его нет в наличии.
            - Клиент щёлкает по кнопке "заказать".
            - Говорим "введите email, мы сообщим, когда он появится".
            - В итоге мы собираем стат о спросе на товар, и получаем потенц.клиента.

          # count == 0, supplierwarehouse == 1
            - Значит у нас на складе товара нет, а у поставщика есть.
            - Для расчёта цены используем себестоимость поставщика costpricesup.

          # count > 0, supplierwarehouse == 0
            - Значит у нас на складе товар есть, а у поставщика нет.
            - Для расчёта цены используем себестоимость товара на нашем складе costpricewar.

          # count > 0, supplierwarehouse == 1
            - Значит товар есть и у нас на складе, и у поставщика.
            - Приоритетом для продажи всегда обладает товар у нас на складе.
            - Для расчёта цены используем себестоимость товара на нашем складе costpricewar.

        - Т.О. если товар закончился у нас, он автоматом продаётся от поставщика.

      > Про более сложный вариант, для развитого ИМ
        - Используется в ИМ, торгующих преимущественно со своего склада.
        - Вот привозят нам на склад этот товар фурами.
        - Мы весь его проверяем, и каждому отдельному товару присваиваем ID.
        - Именно товару, а не товарной позиции.
        - И с этим ID связана и себестоимость, по которой его купили, и личная история, и пр.

    А18.2.7.  Простая статистика

     > Необходимо вести статистику
      - В интернет магазине необходимо вести строгий учёт и подсчёт всего.
      - Какую статистику по товарам надо собирать:

        - Какой товар, с какой себестоимостью, по какой цене, когда был продан.
        - Операционная прибыль от продаж по любой позиции за указанный период времени.
        - Количество продаж по любой позиции за указанный период времени.
        - Средняя себестоимость от продаж по позиции за указанный период времени.
        - Средние инклюзивные расходы на продажу 1 товара по позиции за указ.пер.времени.
        - ROI позиции за указанный период времени.

      - Такая статистика позволит увидеть и динамику всех этих значений.
      - Эти данные можно будет визуализироват с помощью графиков и пр.инструментов.
      - Эти данные покажут, что начинает продаваться лучше, что хуже.
      - И какую прибыль мы получаем с продажи тех или иных позиций.
      - Мы узнаем, что лучше продавать.

     > Таблица "Продажи"
      - Должна быть отдельная таблица "Продажи", где учитываются все продажи.
      - Должна учитываться вся необходимая для расчётов фин. информация.
      - Надо в ней также указывать кто заказал, когда, какие способы оплаты/доставки и т.д.
      - Плюс полная история этой продажи.

     > Есть ли смысл делать какие-то учётв в таблице товарных позиций?
      - Нет смысла.
      - Надо записывать статистику продаж в таблицу "Продажи".
      - А потом уже работать с ней для расчёта ROI, прибыли, построения графиков и т.д.

    А18.2.8.  Автоматическая система округления цен
      - Некрасивые цены вроде 34234 неприятно цепляются за глаза посетителей.
      - Их надо округлять до красивых. За это отвечает св-во pretty таблицы товарных позиций.
      - pretty == 1 значит включить эту систему, pretty == 0 значит выключить.
      - Система работает по следующим правилам:

        # Если цена < 10000
          - Производится округления до десятков в ближайшую сторону.
          - Примеры:
            2452 -> 2450
            5635 -> 5640

        # Если цена X >= 10000, и при этом X - 100 имеет ту же разрядность
          - Производится округления до десятков в ближайшую сторону.
          - Примеры:
            24524 -> 24520
            56355 -> 56360

        # Если цена X >= 10000, и при этом X - 100 имеет разрядность меньше на 1
          - Производится округление до сотен в меньшую сторону.
          - При этом на конце должен стоять 0.
          - Примеры:
            10055 -> 9990
            20055 -> 19990

    А18.2.9.  Популярность и отзывы + оценки + рейтинги

      # Популярность
        - Популярность тов.позиции, это кол-во кликов по ней за всё время.
        - Баллы популярности надо начислять товарам, а не контейнеру.
        - Рассмотрим 2 варианта:

          1) При показе в виде 1 товара, начислять всем товарам по 1 баллу.
            - Ведь по сути покупатель проявил интерес ко всем им.
            - Популярность этого 1 товара должна складываться из попул-ти всех товаров в контейнере.

          2) А при показе по отдельности, начислять 1 балл тому товару, по которому кликнули.
            - В этом случае используется популярность каждого отдельного товара.

        - Популярность подсчитывается в таблице товарных позиций, в столбце views.

      # Отзывы + оценки + рейтинги
        - Пользователи могут оставлять отзывы о товаре.
        - Все отзывы, разумеется, должны хранитсья в отдельной таблице.
        - Но одновременно рейтинг товара подсчитываетсяи в товарной таблице.
        - Чисто для того, чтобы было удобно сортировать/фильтровать по рейтингу.
        - Рассмотрим 2 варианта:

          1) При показе в виде 1 товара
            - В документе товара в любой момент выбран 1 из товаров в контейнере.
            - Когда пользователь нажимает "оставить отзыв", этому то товару его и приписывать.
            - Средний балл объединённого товара складывается из ср.баллов всех товаров в контейнере.

          2) При показе в виде отдельных товаров
            - В документе товара в любой момент выбран 1 из товаров в контейнере.
            - Когда пользователь нажимает "оставить отзыв", этому то товару его и приписывать.
            - Каждому отдельно показываемому товару в каталоге показывать свой средний балл.

        - В таблице тов.позиций для этих целей есть 3 столбца:

            votes       | кол-во оценивших этот товар
            sumscore    | суммарная оценка товара
            rating      | рейтинг (средняя оценка)


  > А18.3.  Настройка таблиц характеристик для [К]-каталогов

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция

    --------------------------------------

    > Введение
      - Каждый [К]-каталог обладает своей таблицей характеристик
      - Столбцы таблицы характеристик [К]-каталога можно настраивать через веб-интерфейс.
      - Для столбца можно указывать: Имя, описание, тип, обязательность, инфу о фильтре.
      - Должны быть доступны для настройки столбцы из таблицы товаров - ч.м.б. повесить на них фильтры.

    > Декомпозиция

      А18.3.  Настройка таблиц характеристик для [К]-каталогов
        А18.3.1.  Каждый [К]-каталог обладает своей таблицей характеристик
          - Сабж.

        А18.3.2.  Манипулирование столбцами через веб-интерфейс
          - Столбцы таблицы характеристик [К]-каталога можно настраивать через веб-интерфейс.

        А18.3.3.  Какие св-ва столбцов можно настраивать?
          - Имя, описание, тип, обязательность.
          - Также всё, что касается фильтров.

        А18.3.4.  Присутствие в настройках столбцов из таблицы товаров
          - В веб-интерфейсе, среди столбцов для настройки, должны быть таковые из табл.товаров.
          - Чтобы на них можно было повесить фильтры

    > А18.3.1.  Каждый [К]-каталог обладает своей таблицей характеристик
      - При создании [К]-каталога автоматически создаётся пустая таблица характеристик.
      - Мы добавляем туда нужные столбцы-характеристики, настраиваем её.
      - И после завершения настройки наполняем её контейнерами с товарами.

    > А18.3.2.  Манипулирование столбцами через веб-интерфейс
      - Если в [К]-каталоге ещё нет товаров, можно настраивать все столбцы табл.хар.
      - А если уже есть товары, то можно настраивать только не обяз. столбцы табл.хар.
      - Манипулирование столбцами должно быть можно осуществлять через ЛК.

    > А18.3.3.  Какие св-ва столбцов можно настраивать?
      - Имя, описание, тип, обязательность.
      - Также всё, что касается фильтров.

    > А18.3.4.  Присутствие в настройках столбцов из таблицы товаров
      - В веб-интерфейсе, среди столбцов для настройки, должны быть таковые из табл.товаров.
      - Настраивать их должно быть нельля во всех частях, кроме фильтров.
      - Фильтры на них должно быть можно поставить.


  > А18.4.  Настройка фильтров для [К]-каталогов

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция

    --------------------------------------

    > Введение
      - Для [К]-каталогов можно устанавливать фильтры.
      - Бывают разные типы фильтров, типов может быть сколько угодно.
      - Есть 2 режима определения очерёдности показа фильтров: автоматический и ручной.
      - Популярность фильтра определяется кол-во его использований.

    > Декомпозиция

      А18.4.  Настройка фильтров для [К]-каталогов
        А18.4.1.  Фильтры для столбцов таблицы товаров и таблицы характеристик
          - Для [К]-каталогов можно устанавливать фильтры.
          - Фильтр можно установить на почти на все столбцы в таблицах товаров и характеристик.

        А18.4.2.  Разные типы фильтров
          - Бывают разные типы фильтров, типов может быть сколько угодно.
          - Типы фильтров хранятся в отдельной таблице, каждый имеет свой код.

        А18.4.3.  Очерёдность фильтров
          - Есть 2 режима определения очерёдности: автоматический и ручной.
          - В автоматическом режиме выше находятся более популярные фильтры.
          - В ручном можно вручную задать "вес" фильтра. Чем больше вес, тем выше.

        А18.4.4.  Популярность фильтров, зависимость от неё очерёдности
          - Для каждого фильтра сохраняется количество его испольозваний.
          - Чем больше это количество, тем больше и популярность.
          - Если позиция фильтра определяется автоматически, эта популярность и задействуется.


    > А18.4.1.  Фильтры для столбцов таблицы товаров и таблицы характеристик
      - Для [К]-каталогов можно устанавливать фильтры.
      - Фильтр можно установить на почти на все столбцы в таблицах товаров и характеристик.
      - Установка фильтров происходит в том же меню, где настройка столбцов каталога.
      - Эти фильтры будут работать во всех [О]-каталогах внутри данного [К]-каталога.

    > А18.4.2.  Разные типы фильтров
      - Бывают разные типы фильтров.
      - Например, какой фильтр применять, может зависеть от типа столбца.
      - А может быть несколько версий фильтра для определённого типа столбцов.
      - Короче, много их. Каждый тип иммет свой код. Все типы хранятся в отдельной таблице.

    > А18.4.3.  Очерёдность фильтров
      - Есть 2 режима: автоматический и ручной.
      - В автоматическом режиме выше находятся более популярные фильтры.
      - В ручном можно вручную задать "вес" фильтра. Чем больше вес, тем выше.

    > А18.4.4.  Популярность фильтров, зависимость от неё очерёдности
      - Для каждого фильтра сохраняется количество его испольозваний.
      - Чем больше это количество, тем больше и популярность.
      - Если позиция фильтра определяется автоматически, эта популярность и задействуется.



  > А18.5.  Система сохранения целостности данных

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция

    --------------------------------------

    > Введение
      - У каждого товара должны быть на 100% заполнены обяз. поля. Всегда.
      - Только если в [К]-каталоге 0 товаров можно изменять обяз.столбцы табл.характеристик
      - При добавл./измен. товара должны быть указаны все обяз.свойства
      - Товары могут добавляться лишь внутрь [К]-каталогов

    > Декомпозиция

      А18.5.  Система сохранения целостности данных
        А18.5.1.  Основной принцип системы сохранения целостности данных
          - У каждого товара должны быть на 100% заполнены обяз. поля. Всегда.

        А18.5.2.  Только если в [К]-каталоге 0 товаров можно изменять обяз.столбцы табл.характеристик
          - Иначе это может привести к нарушению целостности данных.

        А18.5.3.  При добавл./измен. товара должны быть указаны все обяз.свойства
          - Если добавляем новый товар, то надо указать все обязательные значения.
          - Если изменяем товар, то все обязательные значения должны быть указаны.

        А18.5.4.  Товары могут добавляться лишь внутрь [К]-каталогов
          - В том числе и в [О]-каталоги, которые находятся в [К]-каталогах.

    > А18.5.1.  Основной принцип системы сохранения целостности данных
      - У каждого товара должны быть на 100% заполнены обяз. поля. Всегда.
      - Допустим, имя товара будет обязательным для заполнения столбцом.
      - Значит, у ВСЕХ товаров имя должно быть указано.
      - Иначе возможны катаклизмы, как это, товар и без имени показывать посетителю?
      - Короче, нужно прикладывать к этому все усилия.

    > А18.5.2.  Только если в [К]-каталоге 0 товаров можно изменять обяз.столбцы табл.характеристик
      - Иначе это может привести к нарушению целостности данных.
      - Представим, что в каталоге уже есть 10 товаров.
      - А мы взяли и добавили новую обязательную характеристику в табл.характеристик.
      - Это приводит к тому, что у этих 10 товаров в новом столбце пусто.
      - А ведь он обязателен! Вот и нарушение целостности.

    > А18.5.3.  При добавл./измен. товара должны быть указаны все обяз.свойства
      - Это соответствует основному принципу целостности данных.
      - Если добавляем новый товар, то надо указать все обязательные значения.
      - Если изменяем товар, то все обязательные значения должны быть указаны.

    > А18.5.4.  Товары могут добавляться лишь внутрь [К]-каталогов
      - В том числе и в [О]-каталоги, которые находятся в [К]-каталогах.
      - Но не могут добавляться в [О]-каталоги вне всяких [К]-каталогов.
      - Вообще, [О]-каталоги вне [К]-каталогов должны быть запрещены.


  > А18.6.  Система политик: наценки, скидки, спецпредложения

    --------------------------------------
    Подоглавление:

      - Введение
      - Декомпозиция

    --------------------------------------

    > Введение
      - Политику можно настроить так, чтобы она действовала на конкретные товары.
      - Политика применяется к данным перед отправкой
      - Политика влияет на ценообразование, скидки, участие в спецпредложениях.

    > Декомпозиция
      А18.6.  Система политик: наценки, скидки, спецпредложения
        А18.6.1.  Таргетирование политики
          - Политику можно настроить так, чтобы она действовала на конкретные товары.

        А18.6.2.  Политика применяется к данным перед отправкой
          - Сначала данные о товарах извлекаются из хранилища.
          - Потом смотрят, какие политики на какой товар действуеют.
          - К каждому товару применяются соответствующие политики.

        А18.6.3.  Что можно настраивать в политике
          - Ценообразование, скидки, спецпредложения.

    > А18.6.1.  Таргетирование политики
      - Политику можно настроить так, чтобы она действовала на конкретные товары.
      - Таргетирование возможно по каталогу, в котором лежат товары.
      - Таргетирование возможно по конкретным, прямо указанным товарам.
      - Таргетирование возможно по имени и описанию (с помощью RegExp).
      - Таргетирование возможно по бренду (с помощью RegExp).
      - И так далее, на что фантазии хватит.

    > А18.6.2.  Политика применяется к данным перед отправкой
      - Сначала данные о товарах извлекаются из хранилища.
      - Потом смотрят, какие политики на какой товар действуеют.
      - К каждому товару применяются соответствующие политики.
      - Таким образом мы как бы получаем "мутировавшие" данные.
      - Вот эти то данные мы и возвращаем клиенту.
      - Такая механика позволяет включать/отключать политику очень легко.

    > А18.6.3.  Что можно настраивать в политике
      - Ценообразование, скидки, спецпредложения.


  > Структуры данных

  --//-----------------------------------------//
    // 0. Список используемых каталогом таблиц //
    //-----------------------------------------//

      1. m4_catalogues                | каталоги
      2. m4_containers                | контейнеры
      3. m4_goods                     | товары
      4. m4_goods_charact_[id кат.]   | характеристики

      5. m4_columns                   | все колонки таблиц характеристик корневых каталогов
      6. m4_filters                   | фильтры
      7. m4_filters_types             | типы фильтров
      8. m4_policy                    | политики
      9. m4_policy_types              | типы политик

      10. m4_sorts                    | сортировки
      11. m4_resources                | ресурсы
      12. m4_resources_types          | типы ресурсов


    --//------------------//
      // 1. m4_catalogues //
      //------------------//

        # id            | INT UNSIGNED  | уникальный id каталога (== catid)
        # parentid      | INT UNSIGNED  | id каталога-родителя
        # cattype       | TINYINT UNS.  | тип каталога, 0 - обычный, 1 - корневой
        # name          | VARCHAR(1000) | имя каталога
        # desc          | VARCHAR(1000) | описание каталога, до 1000 символов
        # count         | INT UNSIGNED  | актуальное кол-во контейнеров в каталоге
        # catimg        | VARCHAR(200)  | id ресурса иконки с картинкой, представляющей категорию
        # chartabgroups | VARCHAR(1000) | список имён доступных групп характерстик через запятую (каждая х. в табл.хар. может быть или не быть в группе)

      Карантин -----------------
        # availstatus   | TINYINT UNS.  | доступность: 0 - наследует, 1 - см.кол-во, 2 - нет, 3 - скоро будет, 4 - под заказ, 5 - есть, 6 - есть в вашем городе
        # displaystatus | TINYINT UNS.  | отображение: 0 - наследует, 1 - не показывать посетителям, 2 - показывать
        # markup        | SMALLINT      | наценка в % (число 0 и выше), действует на содержимое каталога рекурсивно, -1 значит - наследует значение.
        # specoffers    | VARCHAR(1000) | какие спец.предложения на него действуют (id через запятую)

      SQL ----------------------

        CREATE TABLE `grumart_v2`.`m4_catalogues` (
          `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
          `parentid` INT UNSIGNED NOT NULL,
          `cattype` TINYINT UNSIGNED NOT NULL,
          `name` VARCHAR(1000) NOT NULL,
          `desc` VARCHAR(1000) NOT NULL,
          `count` INT UNSIGNED NOT NULL,
          `catimg` VARCHAR(200) NOT NULL,
          PRIMARY KEY (`id`));


    --//------------------//
      // 2. m4_containers //
      //------------------//

      // 2.1. Столбцы в таблице

        # id            | INT UNSIGNED  | id контейнера
        # name          | VARCHAR(1000) | имя контейнера (как имя товара, но не содержит характеристик)
        # desc          | VARCHAR(1000) | описание контейнера (для внут.пользования)
        # choosename    | VARCHAR(1000) | на странице товара пользователь будет видеть "Выберите [choosename]" (комплектацию, размер и т.д.)
        # catid         | INT UNSIGNED  | id категории, в которой находится контейнер
        # is_diff_show  | TINYINT UNS.  | показывать в каталоге содержащиеся товары отдельно (0), или как 1 товар (1)

      // 2.2. Инфа из таблицы политик также приходит с сервера

        # policy        | массив объектов-политик, действующих на товары контейнера; у каждой политики есть набор параметров

      // 2.3. Эти сервисные столбцы также приходят с сервера

        # isExpanded      | раскрыт ли контейнер так, чтобы было видно товары
        # isSetsExpanded  | раскрыты ли параметры контейнера
        # selected        | выделен ли контейнер

      // 2.3. Набл.массив из ID товаров в контейнере, вычисляется в клиенте

        # goods         | наблюдаемый массив ID товаров в контейнере, выстроенных в порядке в соотв. с их св-ми pos

      // 2.4. Эти данные вычисляются и добавляются в клиенте

        # count_vis     | сколько видимых товарных позиций содержит
        # count         | сколько товарных позиций содержит
        # min_price     | цена самого дешёвого товара в контейнере
        # max_price     | цена самого дешёвого товара в контейнере
        # av_markup     | средняя по всем товарам в контейнере наценка
        # last_added_at | дата добавления самого свежего товара в контейнере

      // Карантин -----------------

        # jsoncontent   | VARCHAR(60000)| json-строка со всеми данными о товарах, которые содержит
        # sumviews      | BIGINT UNS.   | суммарное кол-во просмотров лежащих в контейнере товаров
        # sumvotes      | BIGINT UNS.   | суммарное кол-во оставленных отзывов по лежащим в контейнере товаров
        # sumsumscore   | BIGINT UNS.   | суммарное кол-во полученных по отзывам баллов по лежащим в контейнере товаров
        # sumrating     | TINYINT UNS.  | средний рейтинг по всем лежащим в контейнере товарам


    --//-------------//
      // 3. m4_goods //
      //-------------//

      // 3.1. Столбцы в таблице

        # id            | INT UNSIGNED  | уникальный (в системе) id товарной позиции
        # pos           | TINYINT UNS.  | позиция товарной позиции в контейнере (от 0 и выше)
        # name          | VARCHAR(1000) | имя товарной позиции
        # desc          | VARCHAR(5000) | описание товарной позиции в формате html, до 5000 символов
        # components    | VARCHAR(1000) | Комплектация (напр.: "PS4,Контроллер,Гарнитура,Кабель HTMI,Кабель питания")
        # warranty      | VARCHAR(1000) | Гарантия (число - кол-во недель)
        # containerid   | INT UNSIGNED  | id контейнера, в котором находится сейчас
        # disptatus     | TINYINT UNS.  | отображение: 0 - не показывать посетителям, 1 - показывать

        # views         | BIGINT UNS.   | Количество просмотров товара посетителями
        # votes         | BIGINT UNS.   | Кол-во поставивших оценку (оценку можно ставить от 1 до 5)
        # sumscore      | BIGINT UNS.   | Общее кол-во полученных баллов

        # costprice     | INT UNSIGNED  | себестоимость товара (значен.используется, если в кач-ве источника указана заглушка "есть")
        # pretty        | TINYINT UNS.  | включить ли систему округления сумм

        # imgs          | VARCHAR(1000) | ID ресурсов-картинок товара, через запятую
        # videos        | VARCHAR(1000) | ID ресурсов-видео товара, через запятую

        # created_at    | DATETIME      | Дата и время добавления в каталог
        # updated_at    | DATETIME      | Дата и время последнего обновления
        # deleted_at    | DATETIME      | Дата и время "мягкого" удаления

      // 3.2. Эти сервисные столбцы также приходят с сервера

        # isSetsExpanded| TINYINT UNS.  | раскрыта ли панель опций: 0 - нет, 1 - да
        # isAvailable   | TINYINT UNS.  | в наличии товар или нет? (применяется, когда не действует ни 1 политика)

      // 3.3. Инфа из таблицы политик также приходит с сервера

        # policy        | массив объектов-политик, действующих на данную товарную позицию

      // 3.4. Вычисляемые в клиенте данные о цене, наценках и скидках

        # costprice_from_policy   | себестоимость в используемом источнике
        # final_markup_percent    | итоговая наценка в % (с учётом всех скидок - они уже вычтены)
        # final_discount_percent  | итоговая скидка в %
        # final_discount_rubs     | итоговая скидка в рублях
        # final_markup_rubs       | итоговая наценка в рублях
        # price                   | итоговая цена для покупателя в рублях

      // 3.5. Вычисляемые в клиенте данные о наличии

        # available   | товара в наличии ('Е' - есть, 'Н' - нет, или цифра от 0 и выше)
        # reserved    | товара в резерве ('' - возможность резерва отсутствует, или цифра от 0 и выше)

      // 3.6. Вычисляемые в клиенте данные о ресурсах и рейтинге

        # count_imgs    | кол-во картинок у товара
        # count_videos  | кол-во видео у товара
        # rating        | рейтинг товара (о 1 до 5)

      // 3.7. Прочие вычисляемые в клиенте данные

        # actualsource  | ссылка на политику типа 1, действующую на товар, имеющую наибольший приоритет (актуальную)
        # imgsobsarr    | наблюдаемый массив объектов-фото товаров {url: '', pos: ''}


      Карантин -----------------
        # sales         | BIGINT UNS.   | Количество завершённых продаж товара
        # netsale       | BIGINT UNS.   | На какую сумму в рублях продано за всё время
        # refunds       | INT UNSIGNED  | Количество завершённых возвратов товара по гарантии

          specoffers    | VARCHAR(1000) | какие спец.предложения на него действуют (id через запятую)
          availstatus   | TINYINT UNS.  | доступность: -1 - наследует, 0 - см.кол-во, 1 - нет, 2 - скоро будет, 3 - под заказ, 4 - есть, 5 - есть в вашем городе
          markup        | SMALLINT      | наценка в % (число 0 и выше), -1 значит - наследует значение.
          prettyprice   | INT UNSIGNED  | округлённая в сотв. с prettyrate цена
          actprice      | INT UNSIGNED  | действующая цена в рублях
          manprice      | INT UNSIGNED  | можно вручную поставить цену, которая не зависит ни от чего; если не пусто, действует она

          count             | кол-во товара в наличие у нас на складе
          supplierwarehouse | доступен ли товар на складе поставщика (0 | 1)
          costpricewar      | себестоимость со своего склада
          costpricesup      | себестоимость со склада поставщика


    --//-------------------------------//
      // 4. m4_goods_charact_[id кат.] //
      //-------------------------------//

        # prod_id       | INT UNSIGNED  | id продукта
        # ...           |
        # ...           | - столбцы из m4_columns
        # ...           |


    --//---------------//
      // 5. m4_columns //
      //---------------//

        # id            | INT UNSIGNED  | уникальный в системе id колонки
        # id_chartab    | INT UNSIGNED  | id таблицы характеристик, которой принадлежит
        # name          | VARCHAR(1000) | имя (для заголовков фильтров, характеристик и т.д)
        # desc          | VARCHAR(1000) | описание для внутренного пользования
        # filter_id     | INT UNSIGNED  | id фильтра, который применяется к этому столбцу
        # filter_onoff  | TINYINT UNS.  | включить (1) / выключить (0) применение фильтра
        # filter_pos    | TINYINT UNS.  | 0 - автоматическая, 1 - наивысший приоритет. 2 - пониже. 3 - ещё ниже. и т.д.
        # char_subhead  | VARCHAR(1000) | имя подраздела характеристики
        # char_pos      | VARCHAR(1000) | позиция характеристики в подразделе (от 0 и выше, 0 - наивысшая)

      Карантин -----------------
        # filter_type   | TINYINT UNS.  | код типа применяемого фильтра


    --//---------------//
      // 6. m4_filters //
      //---------------//

        # id         | INT UNSIGNED   | id фильтра
        # name       | VARCHAR(1000)  | имя фильтра
        # desc       | VARCHAR(1000)  | описание фильтра
        # catid      | INT UNSIGNED   | к какому каталогу приписан
        # display    | TINYINT UNS.   | отображать или нет (0 | 1)
        # pos        | TINYINT UNS.   | позиция фильтра (>=0), чем меньше, тем выше фильтр
        # type       | TINYINT UNS.   | какой тип фильтра использовать
        # column     | VARCHAR(1000)  | по какому столбцу фильтровать (имя)
        # usenumber  | VARCHAR(1000)  | кол-во раз, которое был использован за всё время


    --//---------------------//
      // 7. m4_filters_types //
      //---------------------//

        # code  | TINYINT UNS.  | код типа фильтра
        # desc  | VARCHAR(100)  | описание



    --//--------------//
      // 8. m4_policy //
      //--------------//

        # id          | INT UNSIGNED    | id политики
        # type        | TINYINT UNS.    | тип политики (см. m4_policy_types)
        # desc        | VARCHAR(1000)   | подробное описание группы-спецпредложения (для внут.пользования)
        # platename   | VARCHAR(1000)   | имя на плашке
        # platecolor  | VARCHAR(1000)   | цвет плашки
        # platetip    | VARCHAR(1000)   | подсказка, появляющаяся при наведении на бляшку спецпредложения
        # expire      | DATETIME        | дата и время окончания действия (если пусто или время ещё не пришло, то действует)
        # param0      | VARCHAR(1000)   | Параметр политики №0
        # param1      | VARCHAR(1000)   | Параметр политики №1
        # param3      | VARCHAR(1000)   | Параметр политики №2
        # param3      | VARCHAR(1000)   | Параметр политики №3
        # param4      | VARCHAR(1000)   | Параметр политики №4
        # param5      | VARCHAR(1000)   | Параметр политики №5
        # param6      | VARCHAR(1000)   | Параметр политики №6
        # param7      | VARCHAR(1000)   | Параметр политики №7
        # param8      | VARCHAR(1000)   | Параметр политики №8
        # param9      | VARCHAR(1000)   | Параметр политики №9


    --//--------------------//
      // 9. m4_policy_types //
      //--------------------//

        # code    | TINYINT UNS.  | код типа политики
        # desc    | VARCHAR(100)  | описание


    --//--------------//
      // 10. m4_sorts //
      //--------------//

        # code    | TINYINT UNS.  | код типа сортировки
        # desc    | VARCHAR(100)  | описание

    --//------------------//
      // 11. m4_resources //
      //------------------//

        # id    | INT UNSIGNED  | id ресурса
        # type  | TINYINT UNS.  | тип ресурса (см. m4_resources_types)
        # url   | VARCHAR(1000) | url ресурса

      SQL ----------------------

        CREATE TABLE `grumart_v2`.`m4_resources` (
          `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
          `type` TINYINT UNSIGNED NOT NULL,
          `url` VARCHAR(1000) NOT NULL,
          PRIMARY KEY (`id`));

    --//------------------------//
      // 12. m4_resources_types //
      //------------------------//

        # id    | TINYINT UNS.  | id и по совместительству код типа ресурса
        # color | VARCHAR(10)   | каким цветом обозначать данный тип
        # desc  | VARCHAR(100)  | описание

      SQL ----------------------

        CREATE TABLE `grumart_v2`.`m4_resources_types` (
          `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
          `color` VARCHAR(45) NOT NULL,
          `desc` VARCHAR(100) NOT NULL,
          PRIMARY KEY (`id`));


  > План разработки

    --------------------------------------
    Подоглавление:

      - Введение

      - Этап 1. Каталоги


    --------------------------------------

    > Введение
      - Здесь будем обсуждать прикладной план по разработке.
      - Имеется в виду уже непосредственно программирование.
      - Что в первую очередь делать, что во вторую.

    > Этап 1. Каталоги

      1) Подготовить модуль М4 к разработке.
      2) Создать в БД таблицу m4_catalogues.
      3) Создать интерфейс для работы с каталогами
        - Каталоги должны быть оформлены в древовидной форме.
        - [К]-каталоги должны быть визуально выделены.
        - Должна быть возможность добавлять, изменять, удалять каталоги.
        - Должен быть доступ к своствам каждого каталога для их изменения.
        - Должна быть возможность перемещать каталоги в другие каталоги.
        - На 1-м уровне нужно позволить создавать лишь [К]-каталоги.

    > Этап 2. Контейнеры и товары

      1)

    > Этап 3. Таблицы характеристик и фильтры

      1)



















































































  > В двух словах

    # Каталоги
      - Есть дерево каталогов. В нём [К]-каталоги (корневые), и [О]-каталоги (обычные).
      - [О]-каталоги могут находиться лишь внутри [К]-каталогов.
      - [К]-каталоги и все [О]-каталоги имеют общую таблицу характеристик товаров.
      - Добавлять, редактировать, удалять столбцы в ней можно через спец. интерфейс.
      - Всё дерево каталогов отображается в виде дерева.

    #










Каталог
Контейнер
Товар
Политика (цены, скидки, спецпредложения)
Фильтры



- Все товары хранятся в контейнерах. Нет товаров не в контейнерах.
- При создании товара автоматически создаётся его "родной" контейнер, и товар кладётся в него.
- Любой контейнер в любой момент знает всю, на 100% актуальную инфу о товарах внутри.
- Все контейнеры хранятся в каталогах. Нет контейнеров не в каталоге.
- Бывают [К]-каталоги (корневые), и [О]-каталоги (обычные).
- Для [К]-каталогов можно настраивать фильтры: по какому столбцу, типы, позиции.
- К товарам и каталогам могут применяться различного рода политики.
- Политики ценообразования, скидок, спецпредложений.
- Политика действует лишь на те товары/каталоги, которые подходят по условиям.
- Любую политику можно в любой момент отключить, и она перестанет действовать.
- Политика применяется к товару перед передачей данных пользователю.




- Система сохранения целостности данных













  > Декомпозиция

    А18.  Каталог в интернет-магазине
      А18.1.  Архитектура каталога: общий взгляд.
        - Общий взгляд на то, как должен работать каталог. Без деталей.

      А18.2.  Структуры задействованных в каталоге таблиц
        - Список таблиц, необходимых для каталога, и их структуры.

      А18.3.  Каталоги: какие товары отображать в каталоге "X"
        - Дерево каталогов состоит из многих каталогов, вложенных друг в друга.
        - При этом следует различать корневые каталоги, и обычные.
        - Корневые имеют свою собственную таблицу характеристик.
        - Обычные же используют таблицу характеристик ближайшего родителя-корневого.

      А18.4.  Каталоги: создание, редактирование, перемещение, удаление
        -

      А18.5.  Товары и контейнеры: создание, редактирование, перемещение, удаление
        -

      А18.6.  Товары и контейнеры: популярность, рейтинг
        -

      А18.7.  Каталоги: отображение товаров по 30 штук
        -


      А18.8.  Каталоги: применение фильтров
        -

      А18.9.  Ценообразование
        -

      А18.10. Видимость товара, контейнера и каталога
        -



скидки, спецпредложения


  --////----------------------------------------------////
    ////                                              ////
    ////  А18.1.  Архитектура каталога: общий взгляд. ////
    ////                                              ////
    ////----------------------------------------------////

 |    - У нас есть дерево каталогов, похоже на файловую систему ОС.
 |    - Всю информацию о нём мы храним в таблице m4_catalogues.
д|    - В нём может быть бесконечное кол-во уровней вложенности.
е|    - Например:
р|
е|        Каталог                 | 0 ур.
в|          Телефоны              | 1 ур.
о|            Смартфоны           | 2 ур.
 |              Ударопрочные      | 3 ур.
к|            Кнопочные           | 2 ур.
а|          Текстиль              | 1 ур.
т|            Постельное бельё    | 2 ур.
а|            Шторы               | 2 ур.
л|          Ботинки               | 1 ур.
.|            Мужские             | 2 ур.
 |            Женские             | 2 ур.

т|    - Все товары мы храним таблице товаров m4_goods.
о|    - Она содержит все общие для всех товаров в мире свойства.
в|
а|      m4_goods
р|      ------------------------------
ы|        Имя   Описание   Цена   ...

х|    - Но у каждой категории товаров есть ряд индивидуальных характеристик.
а|    - Хранить их m4_goods не получится, т.к. MAX кол-во столбцов == 4096.
р|    - Поэтому при создании каждого каталога создаётся и таблица характеристик.
а|    - Она получает имя m4_goods_charact_[id каталога].
к|    - Их столбцы можно настраивать: имя, тип, описание, обязательность.
т|
е|      m4_goods_charact_[id каталога]
р|      ------------------------------
.|        ID_товара   ...   ...   ...

 |    - Бывает, что >= 2 товаров одинаковы. Отличие лишь в мелких деталях.
 |    - В одном случае, хотелось бы показывать их в каталоге, как разные товары:
 |
 |                          iPhone 6      iPhone 6
 |                            белый        чёрный
 |
 |    - В другом случае, хотелось бы показывать их в каталоге, как 1 товар.
к|    - Допустим, у нас есть 10 размеров кроссовок Nike Air. Показываем, как 1:
о|
н|                                Кроссовки
т|                                 Nike Air
е|
й|    - Во всех случаях для них должна быть 1, общая страница товара.
н|    - Щёлкнули, скажем, по "iPhone 6 белый", попали на общую страницу.
е|    - А на ней можно уже выбрать конкретную модель.
р|
ы|       ○   [картинка]   iPhone 6 белый 16гб    [краткое описание]   [цена]
 |       •   [картинка]   iPhone 6 белый 32гб    [краткое описание]   [цена]
д|       ○   [картинка]   iPhone 6 черный 16гб   [краткое описание]   [цена]
л|       ○   [картинка]   iPhone 6 черный 32гб   [краткое описание]   [цена]
я|
 |    - Чтобы этого добиться, надо разложить все товары по контейнерам.
т|    - Для этих контейнеров у нас есть таблица m4_containers.
о|    - При создании товара автоматически создаётся и контейнер для него.
в|    - Контейнер получает тот же id, что у товара, и является "родным" для него.
а|
р|        m4_goods                     m4_containers
о|        --------------------------   --------------------------
в|          ID    Имя                    ID    Имя
 |
 |          555   iPhone6 16гб белый     555   iPhone6
 |    - Товар при создании можно сразу положитьи в контейнер другого товара.
 |    - Но "родной" контейнер для него всё равно создаётся, но остаётся пустым.
 |    - Контейнер в любой момент обладает актуальной информацией о содержимом:
 |
 |        m4_containers
 |        --------------------------
 |          ID     Имя      Содержит     MIN_цена     MAX_цена    ...
 |          555    iPhone6  4            31999        38999

 |    - Товарами и каталогами активно используются картинки и видео.
 |    - Скажем, у товара "iPhone 6 белый 16гб" может быть 8 картинок.
р|    - Информация об этом в m4_goods хранится в виде строки.
е|    - В строке, через запятую, перечислены ID этих картинок в m4_resources.
с|    - Аналогичная ситуация и с видео.
у|
р|        m4_goods                      m4_resources
с|        --------------------------    -------------------------
ы|          ...   images    videos        ID    URL
 |                "1,2"     "3,4"         1     http://grumart.ru/res/iphone6_1.png
 |                                        2     http://grumart.ru/res/iphone6_2.png
 |                                        3     http://youtube.com/watch?v=QbnT7jnNNoE
 |                                        4     http://youtube.com/watch?v=dMUlW2BZcl0

ф|   - Какие фильтры, у каталога с каким ID, мы храним в таблице m4_filters.
и|   - Есть несколько типовых фильтров, каждый из них имеет свой код.
л|
ь|       m4_filters
т|       -----------------------------------------------------------
.|         ID_фильтра    ID_каталога    Код_фильтра    Имя_столбца

 |    - Иногда требуется сделать спецпредложение по товарам.
 |    - Его можно сделать по 1 товару, или по каталогу рекурсивно.
с|    - Все всецпредложения у нас хранятся в таблице m4_specoffers.
п|
е|        m4_specoffers
ц|        -------------------------------------------------------------
п|          ID    Name                        Type      Expire      ...
р|          1     -20%                        1
е|          2     New                         0         2014-10-30
д|          3     Суперцена                   0
л|          4     Бесплатная доставка по РФ   2         2014-11-15
о|
ж|        m4_containers                m4_goods
е|        ---------------------------  ---------------------------
н|          ...   specoffers             ...   specoffers
и|                1,2                          2,3,4
я|
 |                        m4_catalogues
 |                        ---------------------------
 |                          ...   specoffers
 |                                1,3,4


  --////-------------------------------------------------------////
    ////                                                       ////
    ////  А18.2.  Структуры задействованных в каталоге таблиц  ////
    ////                                                       ////
    ////-------------------------------------------------------////

    --//-----------------------------------------//
      // 0. Список используемых каталогом таблиц //
      //-----------------------------------------//

        1. m4_catalogues               | каталоги
        4. m4_containers               | контейнеры
        2. m4_goods                    | товары
        3. m4_goods_charact_[id кат.]  | характеристики
        5. m4_resources                | ресурсы
        6. m4_resources_types          | типы ресурсов
        7. m4_filters                  | фильтры
        8. m4_filters_types            | типы фильтров
        9. m4_specoffers               | спецпредложения
        10. m4_sorts                   | сортировки
        11. m4_availstatuses           | статусы доступности для товаров/контейнеров/каталогов
        12. m4_columns                 | все колонки таблиц характеристик корневых каталогов

    --//------------------//
      // 1. m4_catalogues //
      //------------------//

        # id            | INT UNSIGNED  | уникальный id каталога (== catid)
        # parentid      | INT UNSIGNED  | id каталога-родителя
        # cattype       | TINYINT UNS.  | тип каталога, 0 - обычный, 1 - корневой
        # name          | VARCHAR(1000) | имя каталога
        # desc          | VARCHAR(1000) | описание каталога, до 1000 символов
        # markup        | SMALLINT      | наценка в % (число 0 и выше), действует на содержимое каталога рекурсивно, -1 значит - наследует значение.
        # availstatus   | TINYINT UNS.  | доступность: -1 - наследует, 0 - см.кол-во, 1 - нет, 2 - скоро будет, 3 - под заказ, 4 - есть, 5 - есть в вашем городе
        # displaystatus | TINYINT UNS.  | отображение: -1 - наследует, 0 - не показывать посетителям, 1 - показывать
        # specoffers    | VARCHAR(1000) | какие спец.предложения на него действуют (id через запятую)
        # catimg        | VARCHAR(100)  | id ресурса иконки с картинкой, представляющей категорию
        #

    --//-------------//
      // 2. m4_goods //
      //-------------//

        # id            | INT UNSIGNED  | уникальный (в системе) id товара
        # pos           | TINYINT UNS.  | позиция товара в контейнере (от 0 и выше)
        # name          | VARCHAR(1000) | имя товара
        # desc          | VARCHAR(5000) | описание товара в формате html, до 5000 символов
        # containerid   | INT UNSIGNED  | id контейнера, в котором находится сейчас
        # homecontid    | INT UNSIGNED  | id "родного" контейнера
        # availstatus   | TINYINT UNS.  | доступность: -1 - наследует, 0 - см.кол-во, 1 - нет, 2 - скоро будет, 3 - под заказ, 4 - есть, 5 - есть в вашем городе
        # displaystatus | TINYINT UNS.  | отображение: -1 - наследует, 0 - не показывать посетителям, 1 - показывать
        # specoffers    | VARCHAR(1000) | какие спец.предложения на него действуют (id через запятую)
        # components    | VARCHAR(1000) | Комплектация (текст, голый набор характеристик)
        # warranty      | VARCHAR(1000) | Гарантия (текст)

        # costprice     | INT UNSIGNED  | себестоимость товара (цена у производителя/поставщика)
        # markup        | SMALLINT      | наценка в % (число 0 и выше), -1 значит - наследует значение.
        # prettyprice   | INT UNSIGNED  | округлённая в сотв. с prettyrate цена
        # prettyrate    | TINYINT UNS.  | округлять цену до вида "99" на конце, 0 - нет, 1 - десятки, 2 - сотни, 3 - тысячи, 4 - десятки тысяч и т.д.
        # actprice      | INT UNSIGNED  | действующая цена в рублях
        # manprice      | INT UNSIGNED  | можно вручную поставить цену, которая не зависит ни от чего; если не пусто, действует она

        # imgs          | VARCHAR(1000) | ID ресурсов-картинок товара, через запятую
        # videos        | VARCHAR(1000) | URL-ы видео товара через ,

        # sales         | BIGINT UNS.   | Количество завершённых продаж товара
        # netsale       | BIGINT UNS.   | На какую сумму в рублях продано за всё время
        # refunds       | INT UNSIGNED  | Количество завершённых возвратов товара по гарантии

        # views         | BIGINT UNS.   | Количество просмотров товара посетителями
        # votes         | BIGINT UNS.   | Кол-во поставивших оценку (оценку можно ставить от 1 до 5)
        # sumscore      | BIGINT UNS.   | Общее кол-во полученных баллов
        # rating        | TINYINT UNS.  | Рейтинг (sumrating/votes, от 1 до 5)

        # added_at      | DATETIME      | Дата и время добавления в каталог
        # updated_at    | DATETIME      | Дата и время последнего обновления
        # deleted_at    | DATETIME      | Дата и время "мягкого" удаления

    --//-------------------------------//
      // 3. m4_goods_charact_[id кат.] //
      //-------------------------------//

        # prod_id       | INT UNSIGNED  | id продукта
        # ...           |
        # ...           | - столбцы из m4_columns
        # ...           |

    --//------------------//
      // 4. m4_containers //
      //------------------//

        # prod_id       | INT UNSIGNED  | id контейнера, равный id "родного" товара
        # name          | VARCHAR(1000) | имя контейнера (как имя товара, но не содержит характеристик)
        # desc          | VARCHAR(1000) | описание контейнера
        # catid         | INT UNSIGNED  | id категории, в которой находится контейнер
        # is_diff_show  | TINYINT UNS.  | показывать в каталоге содержащиеся товары отдельно (1), или как 1 товар (0)

        # jsoncontent   | VARCHAR(5000) | json-строка со всеми данными о товарах, которые содержит
        # count         | SMALLINT UNS. | сколько товаров содержит
        # count_visible | SMALLINT UNS. | сколько видимых товаров содержит
        # min_price     | INT UNSIGNED  | цена самого дешёвого товара в контейнере
        # max_price     | INT UNSIGNED  | цена самого дешёвого товара в контейнере
        # last_added_at | DATETIME      | самая свежая added_at среди товаров в контейнере
        # sumviews      | BIGINT UNS.   | суммарное кол-во просмотров лежащих в контейнере товаров
        # sumvotes      | BIGINT UNS.   | суммарное кол-во оставленных отзывов по лежащим в контейнере товаров
        # sumsumscore   | BIGINT UNS.   | суммарное кол-во полученных по отзывам баллов по лежащим в контейнере товаров
        # sumrating     | TINYINT UNS.  | средний рейтинг по всем лежащим в контейнере товарам

    --//-----------------//
      // 5. m4_resources //
      //-----------------//

        # id    | INT UNSIGNED  | id ресурса
        # type  | TINYINT UNS.  | тип ресурса (см. m4_resources_types)
        # url   | VARCHAR(1000) | url ресурса

    --//-----------------------//
      // 6. m4_resources_types //
      //-----------------------//

        # code  | TINYINT UNS.  | код типа ресурса
        # desc  | VARCHAR(100)  | описание

    --//---------------//
      // 7. m4_filters //
      //---------------//

        # id         | INT UNSIGNED   | id фильтра
        # name       | VARCHAR(1000)  | имя фильтра
        # desc       | VARCHAR(1000)  | описание фильтра
        # catid      | INT UNSIGNED   | к какому каталогу приписан
        # display    | TINYINT UNS.   | отображать или нет (0 | 1)
        # pos        | TINYINT UNS.   | позиция фильтра (>=0), чем меньше, тем выше фильтр
        # type       | TINYINT UNS.   | какой тип фильтра использовать
        # column     | VARCHAR(1000)  | по какому столбцу фильтровать (имя)
        # usenumber  | VARCHAR(1000)  | кол-во раз, которое был использован за всё время

    --//---------------------//
      // 8. m4_filters_types //
      //---------------------//

        # code  | TINYINT UNS.  | код типа фильтра
        # desc  | VARCHAR(100)  | описание

    --//------------------//
      // 9. m4_specoffers //
      //------------------//

        # id          | INT UNSIGNED  | id группы-спецпредложения (== specoffers)
        # name        | VARCHAR(1000) | имя группы-спецпредложения (для внут.пользования)
        # desc        | VARCHAR(1000) | подробное описание группы-спецпредложения (для внут.пользования)
        # platetext   | VARCHAR(1000) | текст на бляшке, который будет отображаться клиентам (до 20 символов)
        # platetip    | VARCHAR(1000) | подсказка, появляющаяся при наведении на бляшку спецпредложения
        # type        | TINYINT UNS.  | тип спецпредложения: 0-просто бляшка, 1-скидка, 2-бесплатная доставка, 3-бонус(баллы), 4-кастомное
        # expire      | DATETIME      | дата и время окончания действия (если пусто или время ещё не пришло, то действует)
        # color       | VARCHAR(10)   | цвет бляшки с именем спец.предложения на товаре/каталоге
        # param1      | VARCHAR(1000) | Параметр 1 спецпредложения
        # param3      | VARCHAR(1000) | Параметр 2 спецпредложения
        # param3      | VARCHAR(1000) | Параметр 3 спецпредложения
        # param4      | VARCHAR(1000) | Параметр 4 спецпредложения
        # param5      | VARCHAR(1000) | Параметр 5 спецпредложения

    --//--------------//
      // 10. m4_sorts //
      //--------------//

        # code    | TINYINT UNS.  | код типа сортировки
        # desc    | VARCHAR(100)  | описание

    --//----------------------//
      // 11. m4_availstatuses //
      //----------------------//

        # code    | TINYINT UNS.  | код статуса доступности
        # desc    | VARCHAR(100)  | описание

    --//----------------//
      // 12. m4_columns //
      //----------------//

        # id            | INT UNSIGNED  | уникальный в системе id колонки
        # id_chartab    | INT UNSIGNED  | id таблицы характеристик, которой принадлежит
        # name          | VARCHAR(1000) | имя (для заголовков фильтров, характеристик и т.д)
        # desc          | VARCHAR(1000) | описание для внутренного пользования
        # filter_id     | INT UNSIGNED  | id фильтра, который применяется к этому столбцу
        # filter_onoff  | TINYINT UNS.  | включить (1) / выключить (0) применение фильтра
        # filter_type   | TINYINT UNS.  | код типа применяемого фильтра
        # filter_pos    | TINYINT UNS.  | 0 - автоматическая, 1 - наивысший приоритет. 2 - пониже. 3 - ещё ниже. и т.д.
        # char_subhead  | VARCHAR(1000) | имя подраздела характеристики
        # char_pos      | VARCHAR(1000) | позиция характеристики в подразделе (от 0 и выше, 0 - наивысшая)




  --////------------------------------------------------------------////
    ////                                                            ////
    ////  А18.3.  Каталоги: какие товары отображать в каталоге "X"  ////
    ////                                                            ////
    ////------------------------------------------------------------////

    > Введение
      - Дерево каталогов состоит из многих каталогов, вложенных друг в друга.
      - При этом следует различать корневые каталоги, и обычные.
      - Корневые имеют свою собственную таблицу характеристик.
      - Обычные же используют таблицу характеристик ближайшего родителя-корневого.

    > Основные правила

      # Какие товары показывать в каталоге X?
        - Все товары текущего каталога, и все [О]-каталоги-потомки X.
        - При этом товары из [К]-каталогов-потомков игнорируются.

      # Ссылки на какие каталоги показывать в каталоге X?
        - На все дочерние [О]- и [К]-каталоги.

    > Каталог-пример для иллюстрации

                  [К] - корневой      [О] - обычный

      [К] Средства связи
        [О] Смартфоны
          [О] Обычные
          [О] Ударопрочные
        [О] Телефоны
        [К] Трансгалактические передатчики
          [О] Криптогенные трансмиттеры
            [О] Атомно-силовые станции
            [О] Плазмо-фотонные пронизыватели
          [О] Зенонские наручные устройства

    > Разберёмся на примерах
      - Вопрос в том, какие товары показывать в каком из каталогов?
      - Рассмотрим случаи, когда пользователь находится в том или ином каталоге.
      - И покажем, товары из каких каталогов отображать.

      # Пользователь находится в каталоге "Средства связи"

        - Показываем товары из этих каталогов:

          [К] Средства связи      |
            [О] Смартфоны         |
              [О] Обычные         | - и показываем фильтры каталога "Средства связи"
              [О] Ударопрочные    |
            [О] Телефоны          |

        - Показываем ссылки на следующие каталоги:

          [О] Смартфоны
          [О] Телефоны

      # Пользователь находится в каталоге "Смартфоны"

        - Показываем товары из этих каталогов:

          [О] Смартфоны           |
            [О] Обычные           | - и показываем фильтры каталога "Средства связи"
            [О] Ударопрочные      |

        - Показываем ссылки на следующие каталоги:

          [О] Обычные
          [О] Ударопрочные

      # Пользователь находится в каталоге "Телефоны"

        - Показываем товары из этих каталогов:

          [О] Телефоны            | - и показываем фильтры каталога "Средства связи"

        - Показываем ссылки на следующие каталоги:

          пусто

      # Пользователь находится в каталоге "Трансгалактические передатчики"

        - Показываем товары из этих каталогов:

          [К] Трансгалактические передатчики      |
            [О] Криптогенные трансмиттеры         |
              [О] Атомно-силовые станции          | - и показываем фильтры каталога "Трансгалактические передатчики"
              [О] Плазмо-фотонные пронизыватели   |
            [О] Зенонские наручные устройства     |

        - Показываем ссылки на следующие каталоги:

          [О] Криптогенные трансмиттеры
          [О] Зенонские наручные устройства

      # Пользователь находится в каталоге "Криптогенные трансмиттеры"

        - Показываем товары из этих каталогов:

          [О] Криптогенные трансмиттеры           |
            [О] Атомно-силовые станции            | - и показываем фильтры каталога "Трансгалактические передатчики"
            [О] Плазмо-фотонные пронизыватели     |

        - Показываем ссылки на следующие каталоги:

          [О] Атомно-силовые станции
          [О] Плазмо-фотонные пронизыватели



  --////---------------------------------------------------------------------////
    ////                                                                     ////
    ////  А18.4.  Каталоги: создание, редактирование, перемещение, удаление  ////
    ////                                                                     ////
    ////---------------------------------------------------------------------////

    --//----------//
      // Создание //
      //----------//

      > При создании каталога есть ряд обязательных для заполнения полей
        - Они обозначены * в разделе со структурами таблиц.
        - Нажимаешь кнопку "создать", и тебе предлагают эти поля заполнить.
        - Заполнил, нажимаешь "ОК", и каталог создаётся.

      > [К]-каталог

        - При создании [К]-каталога автоматически создаётся таблица характеристик.
        - Она в названии получает такой же ID, как ID нового каталога.
        - Допустим, мы создали каталог с ID == 5.
        - Таблица получит название: m4_goods_charact_5

        - Изначально в ней есть всего 1 столбец, это "prod_id".
        - Он как бы идёт по умолчанию, удалить и редактировать его нельзя.
        - И в таблице m4_columns он не фигурирует.

      > [О]-каталог

        - При создании [О]-каталога таблица характеристик также создаётся.
        - Но на практике не применяется, и редактировать её нельзя.
        - Начнёт применяться, только если [О]-каталог сделать [К]-каталогом.


    --//----------------//
      // Редактирование //
      //----------------//

      > id
        - Изменять запрещено, он один навсегда.

      > name, desc, markup, catimg
        - Можно изменять без ограничений.
        - name не более 32 символов.

      > cattype

        - [О]-каталог можно сделать [К]-каталогом.
        - Для этого надо изменить значение cattype на 1.
        - Причём такое изменение возможно, только если в каталоге 0 товаров.
        - Иначе не получится, ведь у этих товаров уже есть другие характеристики.
        - Которые лежат в таблице характеристик ближайшего [К]-каталога-предка.

        - Или наоборот, [К]-каталог можно сделать [О]-каталогом.
        - Для этого надо изменить значение cattype на 0.
        - Это также можно сделать, только если в каталоге 0 товаров.

      > parentid
        - См. перемещение

      > availstatus, displaystatus
        - При изменении автоматически изменяется и у всех каталогов рекурсивно.


    --//-------------//
      // Перемещение //
      //-------------//

      > [К]-каталог

        - [К]-каталог можно свободно перемещать в любой другой существующий каталог.
        - То есть, по факту, менять ему parentid.

      > [О]-каталог

        - [О]-каталог можно переместить в др.каталог, только если в каталоге 0 товаров.
        - Соображения те же, что для изменения типа каталога.


    --//----------//
      // Удаление //
      //----------//

        - При удалении каталога рекурсивно удаляетсяи всё его содержимое.
        - Это касается как [К]-каталогов, так и [О]-каталогов.

          -> Подкаталоги из таблицы m4_catalogues.
          -> Таблицы этих подкаталогов.
          -> Столбцы этих таблиц из таблицы m4_columns.
          -> Фильтры этих подкаталогов из таблицы m4_filters.
          -> Товары из таблицы m4_goods.
          -> Родные контейнеры этих товаров из таблицы m4_containers
          -> Соответствующие ресурсы из таблицы m4_resources


  --////--------------------------------------------------------------------------------////
    ////                                                                                ////
    ////  А18.5.  Товары и контейнеры: создание, редактирование, перемещение, удаление  ////
    ////                                                                                ////
    ////--------------------------------------------------------------------------------////

    --//-------------------------------//
      // Создание: товара и контейнера //
      //-------------------------------//

      > При создании товара его родноей контейнер создаётся автоматом
        - Таким образом каждый товар имеет свой родной контейнер.

      > При создании товара есть ряд обязательных для заполнения полей
        - Они обозначены * в разделе со структурами таблиц.
        - Нажимаешь кнопку "создать", и тебе предлагают эти поля заполнить.
        - Заполнил, нажимаешь "ОК", и товар с контейнером создаются.


    --//------------------------------------//
      // Редактирование товара и контейнера //
      //------------------------------------//

      > Контейнер знает всё про все товары, которые в нём лежат.
        - Все данные о товарах контейнера можно хранить в 1 поле контейнера, в виде json-строки.
        - В этой json-строке ключи - ID товаров в контейнере, а значения - объекты со всеми их свойствами.

      > Контейнер всегда обладает на 100% актуальной информацией
        - Допустим, в контейнере лежат 4 товара. И мы редактируем 1 из них.
        - Автоматически обновляются и данные в контейнере.
        - Причем только в той части, которая касается редактируемого товара.

      > Рассмотрим, что меняется при редактировании свойств товара в контейнере

        # id
          - Изменить нельзя.

        # name, desc, components, warranty
          - Ничего

        # containerid
          - Перерасчитывается всех зависимых от товаров свойств (в таблице нижних, через строку).

        # homecontid
          - Изменить нельзя

        # availstatus
          - Ничего не меняется

        # displaystatys
          - Перерасчитать count_visible

        # specoffers
          - Изменения в jsoncontent

        #



    --//-------------//
      // Перемещение //
      //-------------//

        - Возможно как в [О]-, так и [К]-каталог.
        - Используемая таблица характеристик каталога, в который перемещают,
          должна иметь в наличии столбцы с теми же именами, и тех же типов,
          что используемая таблица характеристика каталога, из которого перемещают.
        - В противном случае товар перемещён не будет.


    --//----------//
      // Удаление //
      //----------//









  --////------------------------------------------------------////
    ////                                                      ////
    ////  А18.6.  Товары и контейнеры: популярность, рейтинг  ////
    ////                                                      ////
    ////------------------------------------------------------////

      > Рассмотрим несколько разных случаев

            Случай 1
            -----------------------------
            | - Мы продаём ботинки
            | - У нас есть 10 разных размеров ботинок
            | - Мы хотим показывать их, как 1 товар в каталоге
            | - Мы хотим, чтобы у них у всех был общий счётчик популярности
            | - Мы хотим, чтобы у них были общие отзывы и рейтинг
            |

              Как в мы в этом случае должны начислять баллы?
              - При клике по товару начисляем 1 балл контейнеру.
              - При отзыве связываем его с контейнером, и добавляем баллы контейнеру.


            Случай 2
            -----------------------------
            | - Мы продаём iphone'ы
            | - У нас есть 10 разных по цвету и памяти моделей
            | - Мы хотим показывать их, как разные товары в каталоге
            | - Мы хотим, чтобы у каждого из них был свой счётчик популярности
            | - Мы хотим, чтобы у них были общие отзывы и рейтинг
            |

              Как в мы в этом случае должны начислять баллы?
              - При клике по товару начисляем 1 балл этому товару.
              - При отзыве связываем его с контейнером, и добавляем баллы контейнеру.


            Случай 3
            -----------------------------
            | - Мы продаём iphone'ы
            | - У нас есть 10 разных по цвету и памяти моделей
            | - Мы хотим показывать их, как разные товары в каталоге
            | - Мы хотим, чтобы у каждого из них был свой счётчик популярности
            | - Мы хотим, чтобы у каждого из них были свои отзывы и рейтинги
            |

              Как в мы в этом случае должны начислять баллы?
              - При клике по товару начисляем 1 балл этому товару.
              - При отзыве связываем его с товаром, и добавляем баллы товару.

      >

Выводы:

  1. Баллы популярности надо начислять товарам, а не контейнеру

    1.1. При показе в виде 1 товара, начислять всем товарам по 1 баллу.
      - Ведь по сути покупатель проявил интерес ко всем им.
      - Популярность этого 1 товара должна складываться из попул-ти всех товаров в контейнере.

    1.2. А при показе по отдельности, начислять 1 балл тому товару, по которому кликнули.
      - В этом случае используется популярность каждого отдельного товара.

  2. Отзывы и проставленные оценки надо связывать с товарами, а не контейнером

    2.1. При показе в виде 1 товара
      - В документе товара в любой момент выбран 1 из товаров в контейнере.
      - Когда пользователь нажимает "оставить отзыв", этому то товару его и приписывать.
      - Средний балл объединённого товара складывается из ср.баллов всех товаров в контейнере.

    2.2. При показе в виде отдельных товаров
      - В документе товара в любой момент выбран 1 из товаров в контейнере.
      - Когда пользователь нажимает "оставить отзыв", этому то товару его и приписывать.
      - Каждому отдельно показываемому товару в каталоге показывать свой средний балл.








  --////----------------------------------------------------////
    ////                                                    ////
    ////  А18.7.  Каталоги: отображение товаров по 30 штук  ////
    ////                                                    ////
    ////----------------------------------------------------////

    > Запрос без фильтров, с сортировкой
      - Вот зашёл пользователь в каталог, ему надо показать 30 товаров.
      - У него включена, скажем, сортировка по популярности.
      - Мы извлекаем все контейнеры, у которых есть хоть 1 видимый товар.
      - Сортируем данные по популярности, используя столбцы контейнеров.
      - Подсчитываем, сколько контейнеров надо вернуть, чтобы отобразилось 30 товаров.
      - И возвращаем нужное кол-во контейнеров.

    > Запрос с фильтрами, и с сортировкой
      - Вот находится пользователь в каталоги, и решает применить фильтр.
      - Мы ищем по всем товарам в соответствие с выбранными фильтрами.
      - И находим список ID всех контейнеров, в которых найдены соотв. товары.
      - Затем извлекаем все эти контейнеры, и история повторяется (см.выше).

    > Как сделать всё это дело максимально экономичным по ресурсам и быстрым
      - Надо хранить проекцию всех данных по каталогу в Redis.
      - В виде json-строки с именем, равным ID соответствующего корневого каталога.
      - Такая строка будет иметь вменяемый вес:

        - Пусть у нас "ключ: значение" для 1 столбца будет занимать 20 символов.
        - 1 символ, это 1 байт, так что 20 байт.
        - Пусть у нас в среднем по каталогу у 1 товара 20 свойств.
        - Пусть у нас в каталоге 10000 товаров.
        - Тогда: 20*20*10000/1000/1000 = 4 мегабайта.
        - Пусть у нас 100 каталогов в магазине.
        - В итоге, они займут в оперативной памяти 400 мегабайт. Вполне терпимо.

      - Итак, когда пользователь запрашивает данные, мы извлекаем их из Redis на сервер.
      - Там распаковываем json-строку в массив, пщем и достаём оттуда то, что надо.
      - И сформированный ответ посылаем клиенту.
      - Все эти операции не задействуют БД и жёсткий диск, поэтому быстры и экономичны.

    > Организация хранения проекции всех данных каталога в Redis
      - Логичнее всего запускать по расписанию PHP-скрипт раз в N часов.
      - Например, это можно делать 1 раз в сутки, в 4:00 МСК.
      - Он собирает из БД данные по всем контейнерам.
      - И запихивает их в Redis, попутно удаляя старые.
      - Вуаля.


  --////-----------------------------------------////
    ////                                         ////
    ////  А18.8.  Каталоги: применение фильтров  ////
    ////                                         ////
    ////-----------------------------------------////

      - Для [К]-каталога можно настраивать его таблицу характеристик.
      - Там же можно настроить и применение фильтров к тому или иному столбцу.

        Применять ли фильтр?    Какого типа?    Позиция?


      - Позиция фильтра может настраиваться автоматически, по популярности.
      - А может указываться вручную.

      - Возможные типы фильтров доступны в таблице m4_filters_types.
      - Список и описание каждого типа фильтров:

      - Популярность фильтра считается, как кол-во его использований.
      - Популярность считается не для типа, а для конкретного фильтра.
      - Поэтому, при создании каждой колонки в таблице характеристик,
        для неё автоматически создаётся в m4_filters фильтр с UID.
      - И вот в него и записывается кол-во использования.

      - Связь между колонкой и фильтром



      - Где фильтр берет данные


  --////---------------------------////
    ////                           ////
    ////  А18.9.  Ценообразование  ////
    ////                           ////
    ////---------------------------////

    > Ценовая политика
      - Должна быть отдельная таблица с ценовыми политиками.
      - Туда можно добавлять ЦП, которые будут действовать на указанную группу товаров.
      - Можно удалять ЦП, она перестаёт действовать на указанную группу.
      - Цена товара на который не действует никакая ЦП, равна себестоимости.
      - Группа, на которую будет действовать ЦП, гибко настраивается:

        - По существующему каталогу
        - По любому из столбцов товара, в т.ч. с характеристиками.
        - Больше, меньше, равно.
        - Регулярное выражение.

      - Ценовая политика и определяет наценку в %.
      - А также включены или выключены "красивые цены".


    - Вот допустим создали политику для группы товаров.
    - Теперь нам надо часть этой группы извлечь и показать пользователю.
    - Допустим, у товаров цена не обозначена.
    - Как можно узнать, на какой товар действует какая политика?
    - Надо проверять, соотв. ли товар условиям политики.
    - И так для каждой политики.

    - Товар не должен знать о своей конечной цене.
    - Она должна вычисляться непосредственно перед показом пользователю товаров.
    - В соответствии с ценовыми политиками.
    - Тогда не понадобится самим товарам что-то непосредственно дописывать.


    > Скидки начисляются таким же образом
      - Допустим, хотим мы сделать скидки на определённую группу товаров.
      - Создаём новую скидочную политику для этой группы, и все дела.







  --////---------------------------------------------------////
    ////                                                   ////
    ////  А18.10. Видимость товара, контейнера и каталога  ////
    ////                                                   ////
    ////---------------------------------------------------////

    > Основные принципы
      - Контейнер видим, если хоть 1 товар внутри него видим.
      - У товаров и каталогов за видимость отвечает свойство displaystatus.
      - Под "видимостью" имеется в виду видимость для посетителей.
      - Его значения:

        -1: наследует от вышестоящего каталога
         0: невидим
         1: видим

      - Если значение == -1, а выше нет каталога, то считается, как 0.

    > Иллюстрации

      > Случай 1: все каталоги и товары внутри каталога "Средства связи" видимы

        [К] Средства связи      | displaystatus == 1   | видим
          [О] Смартфоны         | displaystatus == -1  | видим
            iphone 6            | displaystatus == -1  | видим
            samsung G5          | displaystatus == -1  | видим

          [О] Телефоны          | displaystatus == -1  | видим
            nokia 3310          | displaystatus == -1  | видим
            siemens A50         | displaystatus == -1  | видим

      > Случай 2: все кат. и тов., кроме кат. "Телефоны", внутри кат. "Средства связи", видимы

        [К] Средства связи      | displaystatus == 1   | видим
          [О] Смартфоны         | displaystatus == -1  | видим
            iphone 6            | displaystatus == -1  | видим
            samsung G5          | displaystatus == -1  | видим

          [О] Телефоны          | displaystatus == 0   | невидим
            nokia 3310          | displaystatus == -1  | невидим
            siemens A50         | displaystatus == -1  | невидим

      > Случай 3: сложный

        [К] Средства связи      | displaystatus == 1   | видим
          [О] Смартфоны         | displaystatus == -1  | видим
            iphone 6            | displaystatus == 0   | невидим
            samsung G5          | displaystatus == -1  | видим

          [О] Телефоны          | displaystatus == 0   | невидим
            nokia 3310          | displaystatus == 1   | невидим
            siemens A50         | displaystatus == -1  | невидим

    > Механика определения, видим или нет товар
      - Допустим, пользователь находится в каталоге "Средства связи"

      1) Определям, из каких каталогов надо отображать товары
        - Находим список ID этих каталогов.
        - Каталоги с displaystatus == 1, находящиеся внутри каталогов
          с displaystatus == 0, естественно, не отображаем также.

      2) Ищем товары внутри найденного списка каталогов
        - Причём берём только те товары, у которых displaystatus == 1

      3) Находим список ID контейнеров без повторений из найденных товаров
        - Разумеется, с учётом всех задействованных фильтров.

      4) Получаем коллекцию контейнеров с этими ID.


















----------------------

      А18.1.  Архитектура БД каталога. Общий взгляд.
        - Архитектура должна позволять масштабироваться до бесконечности.
        - Даже, если будут тысячи категорий и млн-ы товаров, всё должно работать.
        - Выбрана архитектура с центральной таблицей, в которой есть все товары.
        - Но она содержит лишь общие для всех товаров магазина столбцы.
        - И есть возможность для каждой категории делать свою отдельну таблицу.
        - Что за столбцы в ней будут, выбирать индивидуально.
        - Таблицы категорий будут хранить индивид.особенности товаров каждой категории.

      А18.2.  API каталога
        - Взаимодействие с каталогом происходит только через публичный API.
        - Этот API должен быть защищён CSRF-фильтром.

      А18.3.  Дерево каталогов
        - Устроено также, как в любой ОС. файл - товар, папка - каталог.
        - Корень - корневой каталог дерева. Это 0-й уровень дерева.
        - От корня идут ветки. Это каталоги на 1-м уровне дереве.
        - Для каждой ветки можно настраивать свою собственную таблицу.
        - Эта таблица будет использоваться всей веткой.
        - Для настройки таблиц для веток должен присутствовать API и интерфейс.
        - Для хранения структуры каталогов должна быть предусмотрена отдельная таблица.

      А18.4.  Товары в каталоге. Группировка.
        - Товар можно положить в любой каталог >= 1 уровня.
        - Товар можно перемещать только внутри ветки, т.к. в других другие таблицы.
        - Есть возможность группировать товары по комплектациям.

      А18.5.  Фильтрация
        - Для каждого каталога >= 1 уровня должно быть можно настроить фильтры.
        - Для этого должен быть предусмотрен отдельный API.
        - Д.Б. можно выбирать столбцы для фильтрации, и 1 из стандартных типов фильтров.
        - Должно быть можно назначать очерёдность фильтров, сверху вниз.
        - Информация о фильтрах должна храниться в отдельной таблице.

      А18.6.  Ценообразование
        - У каждого товара должна быть указана цена-себестоимость.
        - Должно быть можно указать наценку в процентах.
        - Её Д.Б. можно указать для товара, каталогов.
        - Наценки не складываются. Чем ниже по дереву, тем > приоритет наценки.
        - Наценки в % хранятся в 2 местах: таблица товаров, таблица каталогов.

      А18.7.  Спецпредложения
        - Д.Б. возможность помечать товары и каталоги спецпредложениями.
        - Д.Б. таблица, содержащая эти самые спецпредложения. Возможность указать % скидки.
        - В табл.товаров и каталогов д.б. можно указать спецпредложения через ,
        - API каталога должно уметь фильтровать по спец.предложениям.

       А18.8.  Наличие, резерв
        - Для каждого товара Д.Б. указан остаток на складе.
        - Этот остаток должен автоматически меняться при убытии/прибытии товара.
        - Д.Б. возможность не учитывать наличие товара.
        - Д.Б. возможность менять статус товара на: есть, под заказ, нет, не показывать.
        - Должна быть возможность резервировать товары.
        - Резерв должен автоматом сниматься при убытии товара или по истечение X часов.

       А18.9.  Человеко-понятные URI
        - Для нужд SEO, uri каталогов и товаров должны быть человекопонятными.
        - Они должны формироваться по принципу:
            "[Имя транслитом]-[uid]"

       А18.10.  Импорт каталогов поставщиков
        - Иногда, чтобы не забивать вручную, хочется импортировать каталог поставщика.
        - Для этого заранее готовится отдельная папка со статусом "скрыто".
        - И готовится скрипт для осуществления импорта.
        - Импортированные данные потом проверяются вручную, исправляются.
        - Прошедшие проверку товары рассортировываются по нужным каталогам ветки.

       А18.11.  YML импорт и экспорт каталога
        - Нужен функционал, позволяющий экспортировать каталог в файл YML.
        - Это понадобится для работы с Яндекс.Маркетом.
        - И функционал для импорта - у многих поставщиков прайсы в этом формате.

-----------------------












































// сопутствующие товары (св-во контейнера //




      - Даже, если будут тысячи категорий и млн-ы товаров, всё должно работать.
      - Выбрана архитектура с центральной таблицей, в которой есть все товары.
      - Но она содержит лишь общие для всех товаров магазина столбцы.
      - А вот характеристики товаров должны быть вынесены в отдельные таблицы.
      - Для каждого каталога >= 1 уровня можно задать свою таблицу с характеристиками.

    > Таблицы в БД для работы каталога

      > Список

        # m4_goods
          - Центральная таблица товаров

        # m4_goods_charact_[id каталога]
          - Группа таблиц с характеристиками товаров в отдельных каталогах.

        # m4_catalogues
          - Таблица с каталогами.

        # m4_goods_unions
          - Таблица товарных объединений.

        # m4_specoffers
          - Таблица групп-спецпредложений.

        # m4_filters
          - Таблица фильтров

      > m4_goods - центральная таблица товаров

                                    ------------
                                    | m4_goods |
                                    ------------
      -------------------                 |       ----------------------
      | Каталог id == 1 | ------------->  | ----> | m4_goods_charact_1 |
      -------------------                 |       ----------------------
          -------------------             |       ----------------------
          | Каталог id == 2 | ----------> | ----> | m4_goods_charact_2 |
          -------------------             |       ----------------------
              -------------------         |       ----------------------
              | Каталог id == 3 | ------> | ----> | m4_goods_charact_3 |
              -------------------         |       ----------------------
          -------------------             |       ----------------------
          | Каталог id == 4 | ----------> | ----> | m4_goods_charact_4 |
          -------------------             |       ----------------------
                                          |
                                      ... | ...
                                          |
                                          |


          # id              | уникальный (в системе) id товара
          # name            | имя товара
          # desc            | описание товара в формате html, до 5000 символов
          # catid           | id категории, в которой лежит товар
          # kgroupid        | в какой группе по комплектации состоит (если состоит)
          # specoffers      | какие спец.предложения на него действуют (id через запятую)
   x      # availstatus     | Доступность: -1 - наследует, 0 - см.кол-во, 1 - нет, 2 - скоро будет, 3 - под заказ, 4 - есть, 5 - есть в вашем городе
   x      # displaystatus   | Отображение: -1 - наследует, 0 - не показывать посетителям, 1 - показывать

   x      # costprice       | себестоимость товара (цена у производителя/поставщика)
   x      # markup          | наценка в % (-1, 0-100%), -1 - значение наследуется от каталога
   x      # price           | цена в рублях (возможность поставить вручную, тогда показывается оно)

          # imgs            | URL-ы картинок товара через ,
          # videos          | URL-ы видео товара через ,

   x      # sales           | Количество завершённых продаж товара
   x      # netsale         | На какую сумму в рублях продано за всё время
   x      # refunds         | Количество завершённых возвратов товара по гарантии

          # views           | Количество просмотров товара посетителями
          # votes           | Кол-во поставивших оценку (от 1 до 5)
          # sumrating       | Общее кол-во полученных баллов
          # rating          | Рейтинг (sumrating/votes)

          # warranty        | Гарантия (текст)
          # components      | Комплектация (текст)

          # added_at        | Дата и время добавления в каталог
          # updated_at      | Дата и время последнего обновления
          # deleted_at      | Дата и время "мягкого" удаления

      > m4_goods_charact_[id каталога] - таблицы характеристик

          # product_id      | id товара из центральной таблицы
          # ...             | Далее индивидуально для каждой ветки


      > m4_catalogues - таблица с каталогами

          # id              | уникальный id каталога (== catid)
          # parentid        | id каталога-родителя
          # name            | имя каталога
          # desc            | описание каталога, до 1000 символов
          # markup          | наценка в % (число 0 до 100), действует на содержимое каталога
          # availstatus     | Доступность: -1 - наследует, 0 - см.кол-во, 1 - нет, 2 - скоро будет, 3 - под заказ, 4 - есть, 5 - есть в вашем городе
          # displaystatus   | Отображение: -1 - наследует, 0 - не показывать посетителям, 1 - показывать
          # specoffers      | какие спец.предложения на него действуют (id через запятую)
          # charactable     | имя используемой таблицы с характеристиками
          # characformat    | json-строка с форматом вывода характеристик на странице товара
          # catimg          | иконка с картинкой, представляющей категорию
          #

      > m4_goods_unions - таблица товарных объединений

          # id              | id группы (== kgroupid)
          # name            | имя группы
          # desc            | описание группы
          # groupparams     | json-строка (параметры-столбцы, тип интерфейса для выбора, см. amazon)
          # members         | id товаров-членов союза, через запятую
          # groupincat      | группировать ли членов при показе в каталоге, или показывать как отдельыне товары (1 | 0)

      > m4_specoffers_groups - таблица групп-спецпредложений

          # id              | id группы-спецпредложения (== sogroupid)
          # name            | имя группы-спецпредложения (для внут.пользования)
          # desc            | подробное описание группы-спецпредложения (для внут.пользования)
          # platetext       | текст на бляшке, который будет отображаться клиентам (до 20 символов)
          # platetip        | подсказка, появляющаяся при наведении на бляшку спецпредложения
          # type            | тип спецпредложения: 0-просто бляшка, 1-скидка, 2-бесплатная доставка, 3-бонус(баллы), 4-кастомное
          # expire          | дата и время окончания действия (если пусто или время ещё не пришло, то действует)
          # color           | цвет бляшки с именем спец.предложения на товаре/каталоге
          # param1          | Параметр 1 спецпредложения
          # param3          | Параметр 2 спецпредложения
          # param3          | Параметр 3 спецпредложения
          # param4          | Параметр 4 спецпредложения
          # param5          | Параметр 5 спецпредложения

      > m4_filters - таблица фильтров

          # id              | id фильтра
          # name            | имя фильтра
          # desc            | описание фильтра
          # catid           | к какому каталогу приписан
          # display         | отображать или нет (0 | 1)
          # pos             | позиция фильтра (>=0), чем меньше, тем выше фильтр
          # type            | какой тип фильтра использовать
          # column          | по какому столбцу фильтровать (имя)
          # usenumber       | кол-во раз, которое был использован за всё время

  > А18.2.  API каталога

    --------------------------------------
    Подоглавление:

      - Введение
      - Выделим 2 вида API катлога
      - Адреса API, безопасность
      - Функционал
      -

    --------------------------------------

    > Введение
      - Взаимодействие с каталогом происходит только через публичный API.
      - Этот API должен быть защищён CSRF-фильтром.

    > Выделим 2 вида API катлога

      # GET-API
        - В ответ на GET-запросы API возвращает представление.
        - В uri и query string можно передавать параметры запроса.
        - Допустим, делаем мы GET-запрос к API каталога с uri: /catalog/phones
        - В ответ API вернёт представление каталога, с данными из каталога phones.
        - Это API рассчитано на не ajax-запросы, а на запросы из браузера.

      # POST-API
        - В ответ на POST-запросы API возвращает json-строку с данными, или ничего.
        - В теле запроса можно передавать параметры запроса.
        - Это API рассчитано на ajax-запросы.
        - Допустим, делаем мы GET-запрос к API каталога /catalog/.
        - И передаём параметр: operation == 1.
        - API выполняет соотв. операцию, и возвращает соотв. строку с ответом.

    > Адреса API, безопасность

      # GET-API в "grumart.ru/catalog"
        - Должно находиться на общедоступном роуте "grumart.ru/catalog".
        - Является общедоступным. Кто угодно может его полностью использовать.

      # GET-API в "lk.grumart.ru/catalog"
        - Предназначено для сотрудников, занимающихся составлением каталога.
        - Очень похоже на GET-API в "grumart.ru/catalog", но есть отличия.
        - Доступно для использования только тем, кому дан явный доступ к роуту.
        - Доступны лишь те фунции и тем людям, доступ к которым явно им дан.

      # POST-API
        - Должно находиться на роуте "lk.grumart.ru/catalog".
        - Доступно для использования только тем, кому дан явный доступ к роуту.
        - Доступны лишь те фунции и тем людям, доступ к которым явно им дан.

    > Функционал

      # GET-API в "grumart.ru/catalog"

        /catalog/[имя каталога]
          - Рекурсивно показывает товары из каталога, чьё имя указано.
          - Для каждого товара показывает бляшки спец.предложений, действующие на него.
          - Отображает все фильтры и сортировки.
          - Показывает рекурсивно список всех содержащихся в нём каталогов и кол-во товаров в них.

        /catalog/[имя каталога]/?sort=[цифра от 0 до 5]
          - Указывает, каким образом сортировать товары в каталоге.
          - Доступные варианты:

            0. По цене (сначала недорогие) - по умолчанию
            1. По цене (сначала дорогие)
            2. По названию (alphabetical сортировка)
            3. По новизне (чем позже дата добавления dateadded, тем выше)
            4. По рейтингу (столбеу rating)
            5. По популярности (общему кол-ву просмотров views).

        /catalog/[имя каталога]/?viewtype=[цифра от 0 до 2]
          - Указывает формат отображения товаров в каталоге.
          - Доступные варианты:

            0. Платка
            1. Список с картинками - по умолчанию
            2. Список без картинок

        /catalog/[имя каталога]/?filters=[urlencoded json-строка]
          - Помещаем имена и значения всех фильтров каталога в json-строку.
          - Кодируем её в формат urlencoded, и вуаля.
          - Её длина ограничена в IE 2048 символами, на фильтры хватит.

      # GET-API в "lk.grumart.ru/catalog"

        /catalog/[имя каталога]
          - Рекурсивно показывает товары из каталога, чьё имя указано.
          - Для каждого товара показывает бляшки спец.предложений, действующие на него.
          - Отображает все фильтры и сортировки.
          - Показывает дерево каталогов и нашу текущую позицию в нём.
          - В дереве показывает кол-во товаров/каталогов для каждого каталога.
          - В дереве показывает бляшки спецпредложений каталогов.

        /catalog/[имя каталога]/?sort=[цифра от 0 до 5]
          - Указывает, каким образом сортировать товары в каталоге.
          - Доступные варианты:

            0. По цене (сначала недорогие) - по умолчанию
            1. По цене (сначала дорогие)
            2. По названию (alphabetical сортировка)
            3. По новизне (чем позже дата добавления dateadded, тем выше)
            4. По рейтингу (столбеу rating)
            5. По популярности (общему кол-ву просмотров views).

        /catalog/[имя каталога]/?viewtype=[цифра от 0 до 2]
          - Указывает формат отображения товаров в каталоге.
          - Доступные варианты:

            0. Платка
            1. Список с картинками - по умолчанию
            2. Список без картинок

        /catalog/[имя каталога]/?filters=[urlencoded json-строка]
          - Помещаем имена и значения всех фильтров каталога в json-строку.
          - Кодируем её в формат urlencoded, и вуаля.
          - Её длина ограничена в IE 2048 символами, на фильтры хватит.

      # POST-API

        1. Operation "cat1"
          - Создать новый каталог.

        2. Operation "cat2"
          - Изменить св-ва существующего каталога.

        3. Operation "cat3"
          - Удалить каталог.

        4. Operation "prod1"
          - Создать новый товар.

        5. Operation 5
          - Изменить св-ва существующего товара.

        6. Operation 6
          - Удалить товар.

        7. Operation 7





1   1
2    2
3    2
4   3
5    4
6    4
 7  5
 7  6
 7   7
8    7


- Проблема в отображении объединённых в союз товаров.
- Допустим, извлекаю я 30 товаров.
- Из них 10 объединены в союз, и указано, что показывать их, как 1.
- В итоге из этих 30 я показываю лишь 21.
- Но показать то мне надо 30 в представлении.
- Основной вопрос, как при таких условиях извлечь из БД "ровно 30" товаров за 1 запрос.

- Возникает вопрос, как узнать, сколько эл-в извлечь, чтобы получилось 30?
- Если просто извлечь 30, а они окажутся членами 1 союза, то это не 30, а 1.
- Извлечь больше, чем надо, не получится, потому что в союзе может быть сколько угодно эл-в.

- Вместо товара контейнер с товарами сделать нельзя?
- Потому что должен быть доступен поиск по всем характеристикам всех товаров.
- А если сделать контейнер, то будет недоступен.
- Поэтому каждая отдельная комплектация товара идёт, как отдельный товар.

- А что, если поиск то как раз производить непосредственно по товарам.
- После этого получить из найденных список id всех контейнеров.
- А затем спокойненько извлекать первые 30 контейнеров прямо по PRIMARY-ключу?
- Такое извлечение вообще не занимает почти никаких ресурсов сервера.

- Таким образом, товар не может быть не в контейнере.
- При создании товара должно быть можно выбрать ему контейнер.
- По умолчанию, новый товар будет помещатсься в зеркальный новый же контейнер, с таким же id.
- Но любой товар можно будет переместить в контейнер к другому товару.
- При этом старый контейнер остаётся, но у него на счётчике товаров 0.
- Контейнеры со счётчиками товаров 0 можно игнорировать при извлечении.

- Для контейнеров придётся создать ещё одну таблицу: m4_containers
- А таблицу m4_goods_unions списать в утиль.
- Каждый товар при создании получает свой контейнер с идентичным ID.


- Но как с контейнерами будет работать пагинация?
- Ну ищем мы по товарам, извлекли первые 30 найденных товаров.
- Из них 10 состоят в 1 группе, остальные в своих группах.
- Итого мы получаем 21 группу, а нам надо 30, как быть?
- Единственный выход, это поиск не по товарам, а по контейнерам. Да?
- Но как искать в контейнерах св-ва содержащихся в них товаров?

- Может быть есть такой запрос, чтобы можно было искать по товарам,
  и при этом за 1 запрос извлечь товаров на 30 контейнеров?






1) Как извлечь 30 товаров с 1-го запроса к БД
(Причём товары из 1-й группы считаются за 1 товар)
- Создаём ещё одну таблицу: контейнеры.
- При создании товара автоматом создаётся контейнер с таким же id, и товар "помещается" в него.
- Каждый контейнер имеет столбцы с актуал. данными, необходимыми для сортировки:
  - MAX цена
  - MIN цена
  - Название
  - Самая свежая дата добавления
  - Рейтинг
  - Популярность
- При извлечении в каталог берём данные из таблицы контейнеров, а не товаров.
- Так, мы легко можем извлекать по 30 контейнеров с помощью LIMIT, не загружая базу.

2) Как снять нагрузку
- В каждой категории мы показываем только товары непосредственно в ней (не рекурсивно).
- А содержащиеся категории отображаем просто, как папки в топе
- Таким образом получается, что товаров то надо отображать совсем мало
- И нагрузка мала.

3) Фильтрация
- При наличии фильтров поиск идет по товарам, а не контейнерам.
- Извлекается список id контейнеров всех товаров в категории, соотв-их фильтрам.
- Далее по unique индексу извлекаются контейнеры из таблицы контейнеров.
- И они уже сортируются в соотв. с выбранной сортировкой.









В общем, проработал тему с sql основательно. Ответ: нет, он так не может. Поэтому пошёл другим путём и придумал хорошее по скорости решение...

1) Как извлечь 30 товаров с 1-го запроса к БД
(Причём товары из 1-й группы считаются за 1 товар)
- Создаём ещё одну таблицу: контейнеры.
- При создании товара автоматом создаётся контейнер с таким же id, и товар "помещается" в него.
-








      [ По работе с каталогами ]

        # Создание нового каталога
          - Принимает строку с данными, из которых создаёт новый каталог.

        # Редактирование св-в каталога
          - Принимает строку с данными, и вносит изменения в каталог.

        # Удаление каталога
          - Принимает строку с id каталога, и удаляет его.
          - Но лишь в том случае, если в нём нет товаров. Иначе error.

        # Получение св-в каталога с указанным id
          - Принимает строку с id каталога, возвращает объект с его св-ми

        # Получение св-в всех каталогов
          - Возвращает все имеющиеся объекты-каталоги

        # Сколько каталогов содержит (рекурсивно)
          - Возвращает число каталогов, которые содержит.

        # Сколько товаров содержит (рекурсивно)
          - Возвращает число товаров, которые содержит.



      [ По работе с товарами ]

        # Создание нового товара
        # Редактирование св-в товара
        # Удаление товара

        #









//// Группировка одинаковых товаров с разными комплектациями ////

  Общее
  - Пусть у нас есть 4 товара "Кроссовки XXX".
  - Они отличаются лишь комплектацией, а именно - размером.
  - Все они хранятся в БД, как отдельные товары.
  - Но мы не хотим показывать их пользователю, как отдельные товары.
  - А хотим показать, как 1 товар.
  - И чтобы уже на странице товара пользователь мог выбрать комплектацию.

  Группа, как точка доступа к товарам-членам группы
  - Итак, мы хотим объединить 4 товара "Кроссовки XXX" в группу.
  - Для этого мы создаём ещё одну запись в таблице товаров - группу.
  - У неё будут заполнены лишь следующие столбцы:

    # uid       | Уникальный ID записи в таблице товаров
    # name      | Имя группы (в том же столбце, где обычно имя товара)
    # desc      | Опис.группы (в том же столбце, где обычно опис. товара)
    # isGroup   | Является ли группой (0 | 1).
    # groupuid  | Уникальный ID группы (номер = MAX предыдущ.номер + 1)
    # template  | Шаблон с wildcards для отображения комплектаций на стр.товара

  - И мы помещаем все наши товары "Кроссовки XXX" в эту группу.
  - Для этого мы просто им в столбце groupuid указываем uid группы.
  - Плюс в столбце numingr им указываем номер в группе (от 0 и выше).
  - Причем товар в один и тот же момент может быть лишь в 1 группе.

  Извлечение из каталога (через API - простое, поиск, ajax-подсказки и пр.)
  - Ищем в каталоге в соотв. с API по любому признаку.
  - При поиске игнорируем записи-группы с isGroup == 1.
  - Из результатов поиска извлекаем имена всех групп в нём без повторов.
  - Для этих групп извлекаем все имеющиеся элементы.
  - И добавляем их тоже к результатам поиска.
  - И возвращаем всё это добро клиенту.
  - А он уж разберётся, как его отображать.

  Пагинация
  - Как будет работать пагинация при таком извлечении из каталога?
  - Клиенту посылаем ВСЕ результаты поиска.
  - А пагинация реализуется уже на стороне клиента.

  Переход на страницу товара, который не в группе, кликнув по нему в каталоге
  - При клике по товару происходит GET-запрос к API-каталога.
  - Допустим, наш товар называется: "Одеяло Шерстяное".
  - А uid нашего товара - "s177" (s - single - значит не в группе)
  - Тогда uri запроса будет такой:
      /catalog/odeyalo-sherstianoe-s177
  - Контроллер принимает запрос и извлекает из последней его части id товара.
  - Затем он извлекает из таблиц товаров данные по этому товару.
  - И возвращает представление страницы товара + эти данные.

  Переход на страницу товара, который в группе, кликнув по нему в каталоге
  - При клике по товару происходит GET-запрос к API-каталога.
  - Допустим, наш товар называется: "Одеяло Шерстяное".
  - И его столбец groupuid не пуст, а значит он состоит в группе.
  - Значит, для запроса мы используем не id товара, а id группы.
  - А uid группы нашего товара - "g56" (g - group - значит в группе).
  - Тогда uri запроса будет такой:
      /catalog/odeyalo-sherstianoe-g56
  - Контроллер принимает запрос и извлекает из последней его части id группы.
  - Затем он извлекает из таблиц товаров данные по товарам группы.
  - И возвращает представление страницы товара + эти данные.
  - А клиент уже сам разбирается, как ему удобнее их отобразить.

  Группировка и редактирование товаров
  - Допустим, мы открыли редактор товаров, и видим их список.
  - В нём мы не видим товаров, состоящих в группе.
  - А вместо этого видим группы.
  - При клике по группе она разворачивается, и там мы видим её товары.



//// Советы от Александра Бондаря по каталогу ////

  # Учёт наличия товаров на складе
    - Для каждого товара должно быть укзано его кол-во на складе.
    - При поступлении/убытии товара со склада это число автоматом меняется.
    - Должна быть возможность указывать локацию товара на складе (код локации).
    - Должна быть возможность не учитывать кол-во товаров на складе
      - Т.Е. вкл/выкл учёт наличия товара для каждой товарной позиции.
      - Это нужно при работе со склада поставщика, где кол-во не известно.

  # Поддержка группировки одинаковы товарных позиций, но разной комплектации
    - Это св-во товара, которое может меняться внутри товарной единицы.
    - Но товары с отличиями в котором не разумно выносить в разные тов.позиции.
    - Например:
      - Пара обуви модели "X".
      - На складе есть пары 10 размеров - от 35 до 45 - модели "X".
      - Будет странно, если в каталоге клиенту показывать их, как разные товары.
      - Гораздо логичнее показывать, как 1 товар. А внутри давать выбрать размер.
    - Как реализовать в базе:
      - Сделать в основной таблице следующие доп.столбцы:

        # "groupuid": уникальный id группы, число
          - Это уникальный id группы в системе.
          - Генерируется автоматом, как самый > номер группы + 1.
          - У всех членов группы в столбце "groupuid" он одинаковый.

        # "numingroup": номер, который занимает позиция в группе
          - Номер товарной позиции в группе.
          - Нумерация начинается с 0. Затем 1, 2, 3 и т.д.
          - Группу везде, где надо, будет представлять эл-м с MIN позицией в группе.
          - Именно он будет выбран "по умолчанию" на странице товара.

        # "template": текстовый шаблон, задействующий столбцы таблицы категории
          - Текстовое описание-шаблон для элемента группы.
          - Будет использоваться на странице товаров.
          - В интерфейсе, позволяющем пользователю выбрать комплектацию.
          - Может задействовать имена столбцов, как wildcards.
          - Должен быть ограничен 100 символами.

        # "groupname": имя группы
          - Будет использоваться на странице товаров.
          - В интерфейсе, позволяющем пользователю выбрать комплектацию.
          - Примеры:
            - Если речь идёт об обуви, это будет: "Размеры".
            - Если речь идёт о памяти смартфона, это будет: "Оперативная память".

      - Заполнять все эти доп.столбцы нужно для всех элементов группы.
      - Делать это будут помогать спец.интерфейсы.
    - Цена:
      - Если эл-т не состоит в группе, будет указываться просто цена.
      - Если эл-т состоит в группе, то будет цена "от ...".
      - Причём будет браться самая маленькая цена из всех эл-в группы.
    - Извлечение:
      - При извлечении будет показываться только 1 из эл-в группы.
      - Это элемент, у которого MIN позиция в группе.
      - А цена будет использована от эл-та с минимальной ценой.
    - Интерфейс выбора комплектации на странице товара:
      - Располагается рядом с кнопкой "купить" и ценой.
      - Будет называться именем из "groupname".
      - По умолчанию будет выбран эл-т с MIN позицие в группе.
      - Будет показывать лишь выбранный эл-т и кнопку изменить.
      - При нажатии на кнопку всплывает окно с другими вариантами.
      - При клике по варианту в этом окне, он выбирается.
    - Страница товара
      - При выборе другой комплектации меняются и зависящие от неё вещи.
      - Например, цена тут уже указана точная, за выбранную комплектацию.
    - Редактирование
      - Допустим, перед нами список товаров в выбранной папке.
      - Парой кликов вы можем добавить товар в группу.
      - Визуально группа должна быть обозначена, как контейнер.
      - А все эл-ты группы должны находиться внутри контейнера.
      - Либо в новую, либо в уже существующую, указав её номер.
      - При добавлении в новую требуется указать значения всех групповых столбцов.
      - При доб-ии в сущест-ую, они рассчитываются автоматически и добавляются.
      - Должно быть можно перетаскивать мышью эл-ты в группу/из группы.

  # Поддержка акционных группировок
    - Должна быть возможность создавать и редактировать список акционных групп.
    - Храниться они должны в отдельной таблице.
      - id, имя, описание, скидка в рублях, скидка в %, url шильдика
    - Например: "Спецпредложение", "Акция", "Скидки", "Горячее предложение" и т.д.
    - Должен быть функционал, позволяющий добавлять/удалять и группы:
      - Один конкретный товар.
      - Всю товарную категорию.
      - Товары с указанными свойствами.
      - Товары в определённом ценовом диапазоне.
    - Соотв. у каждого товара долежн быть столбец "sale"
    - Один товар может одновременно участвовать лишь в 1 акции.

  # Человеко-понятные URI для каталогов и товаров
    - Это способствует продвижению.
    - Примеры человеко-понятных URI категорий:
        /catalog/phones
        /catalog/textile
    - Примеры человеко-понятных URI товаров:
        /catalog/iphone6-white-777
      - Здесь 777 - это ID товара.
      - Он нужен затем, чтобы создать URI был гарантированно уникальным.
    - Т.О. нужно добавить в таблицу товаров ещё 1 столбец: 'humreaduri'.
    - На страницу товара должно быть можно заходить как по нему, так и по id товара.


//// Масштабируемость (бесконечная) ////




//// Терминология ////





//// Храниние данныех о товарах в БД ////
- Какие варианты есть?

  # Вариант 1: хранить все товары в 1 таблице
    - Плюс: всё хранится в 1 месте.
    - Минус: кол-во столбцов в таблицу MySQL ограничено, даже несколько
             товарных категорий могут занять сотни столбцов, очень быстро
             настанет час, когда место закончится.
    - Минус очень весомы, этот вариант не годится

  # Вариант 2: отдельная таблица для каждой категонии, но с общем центром

          --------------------------------------
          | Центр - общие свойства, все товары |
          --------------------------------------
             |
             |
             |    -----------------------------------------
             |--> | Частные св-ва товаров из категории №1 |
             |    -----------------------------------------
             |
             |    -----------------------------------------
             |--> | Частные св-ва товаров из категории №2 |
             |    -----------------------------------------
             |
             | ...
             |




//// Поставщики ////





//// Устройство каталога ////





//// Устройство фильтов ////





//// Поиск по каталогу ////





//// API каталога ////
- Вообще сам по себе каталог - это просто API.
- К нему можно делать запросы, и он возвращает данные.
- Используя эти данные и можно отображать инфу пользователю.
- Используется для фильтрации, сортировки, поиска по каталогу.
- Управление производится через URI и query string.

  # Для выбора папки каталога
    -   /catalog/[красивое имя папки]
    - Примеры:
        /catalog/phones
        /catalog/textile
        /catalog/games

  # Для фильтрации каталога по введённой польозвателем строке (поиска)
    - Осуществляется с помощью FULLTEXT индексов.
    - Через query string.
    - Например:
        /catalog/phones?search=иван

  # Для фильтрации
    - Осуществляется Через query string.
    - /catalog/phones?[id фильтра]=[значение]
    - ID фильтра передаётся в JS-модель фильтра с сервера,
      где он был заранее создан и хранится в БД
    - ID всех фильтров в системе уникальны.



//// Ценообразование ////




//// Наличие ////




//// Специальные предложения, акции и т.п. ////




//// Способы добавления товаров в каталог ////










- Терминология
  - Дерево
  - Поддерево
  - Ветка
  - Листья

  - Дерево каталога
  - Корень
  - Поддеревья
  - Листья
-

- Дерево каталога
- Поддеревья каталога
- Всё работает на ajax, так быстрее
- Пагинация товаров
- Каждый товар может одновременно лежать лишь в одной папке (как в винде)
- У каждого товара должен быть выключатель: опубликован/не опубликован.
- Каждая папка в каталоге должна иметь свой уникальный ID
  - А также своё "красивое имя", которое будет отображаться в URL
  - В контроллере мы будем брать его из URL-а + параметры из query string.
  - И благодаря этому определять, что показывать пользователю.

- Устройство каталога:
  - У каталога есть дерево: "Каталог".
  - По сути, это как папка в Windows, в которой могут лежать другие папки.
  - И корень дерева - папка "Каталог" - это 0-й уровень дерева.
  - В папке "Каталог" непосредственно товаров быть не может.

  - На 1-м уровне - т.е. в папке "Каталог" могут лежать другие папки.
  - По ним в меню нельзя щёлкнуть и зайти, а лишь раскрывается список с их содержимым.
  - Это сделано для того, чтобы удобно было пользовать на тачпадах.
  - В папках 1-го уровня непосредственно товаров быть не может.

  - В папках 1-го уровня лежат папки 2-го уровня.
  - Начиная с папок 2-го уровня, в них уже могут хранитсья товары.
  - Также в папках 2-го уровня могут лежать папки 3-го уровня.
  - В папках 3-го уровня папки 4-го, и т.д., любой уровень вложенности.

  - Допустим, пользователь находится каталоге в папке 2-го уровня "X".
  - Он видит все товары, которые находятся непосредсвенно в "X".
  - А также он видит все товары, которые находятся в подпапках "X" рекурсивно.

  - Начиная со 2-го уровня у всех папок могут быть индивидуально настроенные фильтры.


- Устройство фильтров
  - Должно быть несколько стандартных типов фильтров.
  - В настройках папки достаточно указать столбец и выбрать тип фильтра.
  - Также должно быть можно выбирать очерёдность фильтров.
  - Чтобы фильтры так можно было настраивать, они должны знать:
    - Имя таблицы
    - Имена колонок
    - Типы колоноа
    - Описания колонок
  - Тогда можно будет выбрать конкретную колонку в конкретной таблице для фильтрации.


- Как будут храниться данные о товарах в БД







- Вариант устройства каталога №1
  - Товары могут лежать только в листьях.
  - Лист это последняя папка ветки.
  - Когда заходишь в ветку, вместо фильтров видны лишь папки в этой ветке.
  - Пример на sotmarket.ru

- Вариант устройства каталога №2
  - Тоже, что и вариант 1.
  - Но в ветках тоже доступны некоторые фильтры.



- Для каждой папки должно быть можно настраивать свои фильтры
- Для каждой папки должно быть можно настраивать ценообразование.
- Для кажодго товара в отдельности должно быть можно настраивать ценообразование.










- Выгрузка и загрузка данных в форматах YML.





- Рейтинги товаров





- Фильтры





-










А19. Транслитерация RUS->ENG с помощью пакета URLify

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Установка
    - Использование

  --------------------------------------

  > Ссылки

    - Официальный репозиторий URLify на github:
        https://github.com/marcmascarell/urlify

  > Введение
    - Бывают ситуации, когда требуется транслитерировать RUS->ENG.
    - Чаще всего, для последующего использования полученного значения в URL.
    - Пакет URLify для Laravel представляет собой порт URLify.js из Django.
    - Он решает проблему.

  > Установка

    1. Добавить в composer.json, в "require" строку:

        "mascame/urlify": "dev-master"

    2. Добавить в app/config/app.php в 'providers' строку:

        'Mascame\Urlify\UrlifyServiceProvider'

    3. Выполнить в консоли в папке laravel команду:

        php ..\composer.phar update

    4. Выполнить в консоли в папке laravel команду:

        php ..\composer.phar dump-autoload

  > Использование

    # Транслитерация для использования в URL:
        $r = Mascame\Urlify::filter ('Красивое фото.gif');  //


А20. Манипуляции с изображениями с помощью пакета Intervention Image

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Системные требования
    - Введение
    - IICache - дополнение к II для кэширования
    - Установка II и IICache
    - Настройка
    - IMagic: поддерживаемые форматы изображений и цвета
    - Использование

  --------------------------------------

  > Ссылки

    - Официальный сайт пакета Intervention Image для Laravel
        http://image.intervention.io/

    - Видео про то, как кэшировать изменённые картинки пакетом Intervention Image
        http://www.youtube.com/watch?v=r95dduj6scI

    - Оф.сайт ImageMagic:
        http://imagemagick.org/

    - Описание установки IMagick (в OpenServer она уже есть):
        http://habrahabr.ru/sandbox/58371/

  > Системные требования
    - PHP >= 5.3
    - Fileinfo Extension
    - Одна из следующих библиотек:
      1) GD Library (>=2.0)
      2) Imagick PHP extension (>=6.5.7)

  > Введение
    - II - PHP-библиотека для работы с изображениями.
    - Она позволяет создавать, редактировать и объединять изображения.
    - Поддерживает 2 наиболее распространённые библиотеки для обработки изображений:
        1) GD Library
        2) Imagick
    - Библиотека следует FIG-стандарту PSR-2.
    - Легко интегрируется с Laravel, устанавливается как пакет для него.

  > IICache - дополнение к II для кэширования

    > Что это такое
      - Это дополнение к II, добавляющее возможность кэширования картинок.
      - Оно использует пакет Illuminate/Cache, который является частью Laravel.
      - Так что используется та система кэширования, которая настроена в Laravel.
      - В моём случае, это будет Redis.

    > Принципы работы
      - Когда ICache установлен, становится доступен статический метод cache.
      - Все запросы к II, осуществлённые внутри cache, кэшируются на указанное время t.
      - При появлении этих запросов в будущем они будут браться из кэша.

    > Пример использования

        // Выполнить запрос с II, и закэшировать его
        $img = Image::cache(function($image) {
            $image->make('public/foo.jpg')->resize(300, 200)->greyscale();
        });

  > Установка II и IICache

    Установка II
    ------------

      1. Добавить в composer.json, в require, строку:

          "intervention/image": "~2.0"

      2. Ввести в папке laravel команду:

          php ..\composer.phar update

      3. Зайти в config/app.php и добавить туда следующее:

          - В конец $providers добавить следующую строку:

              'Intervention\Image\ImageServiceProvider'

          - В конец $aliases добавить следующую строку:

              'Image' => 'Intervention\Image\Facades\Image'

    Установка IICache
    -----------------

      1. Добавить в composer.json, в require, строку:

          "intervention/imagecache": "2.*"

      2. Ввести в папке laravel команду:

          php ..\composer.phar update


  > Настройка

    Подготовка конфига
    ------------------

      # Создание конфига для II

        - Создадим в app/config в Laravel конфиг для II.
        - Для этого в папке laravel надо выполнить следующую команду:

            php artisan config:publish intervention/image

        - Теперь конфиг доступен по адресу:

            "app/config/packages/intervention/image/config.php"

      # Создание конфига для IICache

        - Создадим в app/config в Laravel конфиг для IICache.
        - Для этого в папке laravel надо выполнить следующую команду:

            php artisan config:publish intervention/imagecache

        - Теперь конфиг доступен по адресу:

            "app/config/packages/intervention/imagecache/config.php"

    Настройка драйвера для работы с изображениями (конфиг II)
    ---------------------------------------------------------

      - В нём есть всего 1 опция 'driver' для выбора драйвера для обработки изображений.
      - Можно выбрать из 2 вариантов:

          1) 'gd'         | GD Library (по умолчанию)
          2) 'imagick'    | Imagick

      - Рекомендуется использовать imagick, а не GD.
      - У неё больше возможностей, она быстрее, результаты качественнее.
      - Imagick по умолчанию есть в OpenServer.
      - В ссылках также есть ссылка на инструкцию по установке Imagick.

    Настройка конфига IICache
    -------------------------
    - В II, установленном в Laravel, есть встроенный механизм URL-доступа к изображениям.
    - Этот механизм использовать вовсе не обязательно, лучше сделать свой аналогичный.
    - Но такая возможность есть.
    - И данный конфиг служит исключительно для настройки данного механизма.
    - Рассмотрим доступные для настройки параметры:

      # route
        - По умолчанию значение: route => null
        - То есть основанные на URL манипуляции изображениями отключены.
        - Но здесь можно указать имя роута.
        - Оно будет использоваться как раз для основанных на URL манипуляций с изображеняими.
        - В этой формуле данное значение будет использоваться вместо {route-name}

            http://yourhost.com/{route-name}/{template-name}/{file-name}

      # paths
        - Массив строк, каждая из которых представляет из себя путь.
        - В этих каталогах данный механизм будет искать запрашиваемые {file-name}.

      # templates
        - Массив элементов в формате: [имя формата] => [анонимная функция].
        - Имя формата используется при запросе через URL вместо {template-name}.
        - В анонимной функции можно совершать манипуляции с изображением.
        - И возвращать уже изменённое изображение.
        - Также имеется встроенный шаблон 'original' для доступа к оригинальному изображению.

      # lifetime
        - При первом доступе по конкретному URL результат записывается в кэш.
        - При повторном доступе по этому же URL, результат берётся сразу из кэша.
        - Но только если кэш ещё не истёк.
        - В этом параметре можно задать срок годности кэша в минутах.
        - По умолчанию стоит 43200 минут == 720 часов == 30 дней == 1 месяц.

    Настройка лимита памяти в php.ini
    --------------------------------------------------

      - Работа с изображениями затрачивает много памяти.
      - Resize картинки из 3000x2000 в 300x200 может занять до 32мб памяти!
      - Следует убедиться, что в php.ini лимиты имеют достаточные размеры.
      - Для этого в php.ini см. директиву "memory_limit".
      - Можно поставить её, допустим:

          memory_limit = 1G

    Настройка max-размера файла в php.ini
    --------------------------------------------------

      - Может потребоваться закачивать и работать с большими по весу файлами.
      - Следует убедиться, что в php.ini лимиты на размер файла достаточны.
      - Для этого в php.ini см. директиву "upload_max_filesize".
      - Можно поставить её, допустим:

          upload_max_filesize = 1G

  > IMagic: поддерживаемые форматы изображений и цвета

    Поддерживаемые форматы изображений
    ----------------------------------

      JPEG	      PNG	        GIF	        TIF
      Read/Write	Read/Write	Read/Write	Read/Write

      BMP	        ICO	        PSD
      Read/Write	Read/Write	Read/Write


    Поддерживаемые форматы цвета
    ----------------------------

      > Формат integer

        # Информация
          - По умолчанию метод pickColor возвращает значение RGB в виде int-числа.
          - RGB переводится в int-число по следующей формуле:

              RED + GREEN*256 + BLUE*256*256

          - Допустим, есть у нас цвет в формате RGB: 255,200,100
          - Получим его int-представление:

              int = 255 + 200*256 + 100*256*256 = 6 605 055

        # Пример: извлечь цвет из картинки и залить им изображение $img
          $color = Image::make('public/foo.jpg')->pickColor(10, 10);
          $img->fill($color);

      > Формат array

        # Информация
          - Цвет можно передать в виде масива с 4-мя элементами.
          - Вид массива такой: array([RED], [GREEN], [BLUE], [ALPHA])
          - Причём последний, 4-й элемент [ALPHA], является не обязательным.
          - [ALPHA] задаётся, как число от 0 до 1.

        # Пример: использование цвета в формате array без/с альфа-значением

          $img->fill(array(255, 0, 0));
          $img->fill(array(255, 0, 0, 0.5));

      > Формат hex

        # Информация
          - RGB-цвет можно представить в 16-ричном формате.
          - К нему мы все привыкли в HTML и CSS.

        # Пример: использование цветов в 16-ричном формате

          $img->fill('#ccc');
          $img->fill('#cccccc');
          $img->fill('cccccc');

      > Строковые форматы rgb и rgba

        # Пример: использование цветов в строковых rgb- и rgba-форматах

          $img->fill('rgb(255, 0, 0)');
          $img->fill('rgba(255, 0, 0, 1)');
          $img->fill('rgba(0, 0, 0, 0.5)');

  > Использование

    --------------------------------------
    Подоглавление:

      - Основы использования
      - Возвращение изображение, как Response в Laravel
      - Загрузка изображений на сервер в Laravel с помощью II
      - Создание собственных фильтров (скриптов обработки изображений)
      - Кэширование

      - Intervention Image API

    --------------------------------------

    > Основы использования

      # Чтение изображения
        - II и метод make позволяют легко считывать изображения в 1 строчку.
        - Причем make может читать изображения из разных источников. Вот список:

          ● Файловая система
            - Можно указать путь к изображению в файловой системе.
            - Например: 'resources/images/ivan.png'

          ● URL
            - Можно указать URL изображения, откуда оно и будет считано.
            - В php.ini директива "allow_url_fopen" должна быть On

          ● Бинарные данные
            - Можно передать бинарные данные изображения.

          ● URL-encoded
            - Можно передать изображение в формате URL-encoded.

          ● Base64
            - Можно передать изображение в формате Base64-encoded.

          ● GD-ресурс
            - Ресурс PHP типа GD (при использовании GD-драйвера)

          ● Экземпляр IMagick
            - При использовании IMagic-драйвера

          ● Экземпляр Intervention\Image\Image
            - Сабж.

          ● Экземпляр SplFileInfo
            - Для управления загрузками Laravel через Symfony\Component\HttpFoundation\File\UploadedFile

        - Пример:

            $img = Image::make('foo/bar/baz.jpg');

      # Создание изображения
        - Создать новое пустое изображение можно методом canvas().
        - Можно указать width, height. И опционально - color.
        - Например, создадим изображение 800x600 цвета '#ccc':

            $img = Image::canvas(800, 600, '#ccc');

      # Редактирование изображения
        - Допустим, мы получили $img с помощью make() или canvas().
        - Теперь мы можем, используя методы II, всячески его мучать.
        - Обычно каждый метод возвращает изменённый экземпляр Intervention\Image\Image.
        - Поэтому можно использовать эти методы цепочкой.
        - Например, считаем картинку 'foo.jpg', изменим размера на 320x240, и вставим водяной знак поверх:

            $img = Image::make('foo.jpg')->resize(320, 240)->insert('watermark.png');

    > Возвращение изображение, как Response в Laravel
      - Рассмотрим, как из Laravel вернуть Response с изображением.
      - Допустим, поступил запрос от клиента.
      - Создадим изображение:

          $img = Image::canvas(800, 600, '#ff0000');

      - И вернём его клиенту. Сделать это можно 2-мя способами:

        Способ 1
        --------

          return $img->response();

        Способ 2
        --------

          $response = Response::make($img->encode('png'));
          $response->header('Content-Type', 'image/png');
          return $response;

    > Загрузка изображений на сервер в Laravel с помощью II
      - Для этого можно просто передать загруженный файл методу make.
      - Допустим, поступил к нам от клиента файл 'photo':

          $file = Input::file('photo');

      - Считаем его и создадим экземпляр II:

          $img = Image::make($file);

      - Изменим размер файла на 300x200, и сохраним как 'foo.jpg':

          $img->resize(300, 200)->save('foo.jpg');


    > Создание собственных фильтров (скриптов обработки изображений)
      - Термином "фильтр" здесь называют скрипт из II-операций.
      - У II есть интерфейс, который все фильтры должны реализовывать:
          Intervention\Image\Filters\FilterInterface
      - Созданные фильтры можно применять методом filter().
      - Создадим для примера фильтр:

        DemoFilter.php
        --------------------

          <?php

          namespace Intervention\Image\Filters;

          class DemoFilter implements FilterInterface
          {
              /**
               * Default size of filter effects
               */
              const DEFAULT_SIZE = 10;

              /**
               * Size of filter effects
               *
               * @var integer
               */
              private $size;

              /**
               * Creates new instance of filter
               *
               * @param integer $size
               */
              public function __construct($size = null)
              {
                  $this->size = is_numeric($size) ? intval($size) : self::DEFAULT_SIZE;
              }

              /**
               * Applies filter effects to given image
               *
               * @param  Intervention\Image\Image $image
               * @return Intervention\Image\Image
               */
              public function applyFilter(\Intervention\Image\Image $image)
              {
                  $image->pixelate($this->size);
                  $image->greyscale();

                  return $image;
              }
          }

      - Теперь пример. Создадим изображение и применим к нему это фильтр:

          $img = Image::make('foo.jpg');
          $img->filter(new DemoFilter(45));

    > Кэширование

      # Информация
        - Чтобы кэширование стало доступным, требуется установить дополнение к II.
        - Это пакет "Intervention Image Cache". Установка описана выше в разделе "Установка".
        - IICache использует в работе пакет "Illuminate/Cache", который является частью Laravel.
        - Соответственно, для кэширования используется настроенная в Laravel система.
        - Например, если в настройках указан Redis. Значит в нём и будет сохранятсья кэш.

      # Зачем кэшировать
        - Работа с изображениями занимает много ресурсов системы.
        - Она кушает память и процессорное время будь здоров.
        - Особенно это становится чувствительно, когда картинок в проекте много.
        - Например, для интернет-магазинов, в которых десятки тысяч товаров.
        - А для каждого товара несколько десятков картинок разных размеров.
        - Кэширование позволяет сохранять часто используемые вариации картинок в памяти.
        - Это кардинально уменшает расход ресурсов на работу с картинками для подобных проектов.

      # Принципы
        - Как только IICache установлен, становится доступен метод cache.
        - Через него и следует проводить все манипуляции с изображением.
        - Допустим, у нас есть изображение 'public/foo.jpg'.
        - И мы хотим получить его же, но в размере 300x200.
        - Получаем объект II в 1-й раз, через cache. Кэшируем на 10 минут.

            $img = Image::cache(function($image) {
               $image->make('public/foo.jpg')->resize(300, 200);
            }, 10, true);

        - Через в течение 10 минут оно снова нам понадобилось.
        - Делаем точно такой-же запрос.
        - Но в этот раз оно будет извлечено уже из кэша:

            $img = Image::cache(function($image) {
               $image->make('public/foo.jpg')->resize(300, 200);
            }, 10, true);

    > Intervention Image API

    --------------------------------------
    Подоглавление:

      Создание и считывание изображений
      ---------------------------------

        # canvas        | создать новое изобр.-экз. II с width, height и color
        # make          | создать новое изобр.-экз. из указанного источника

      Изменение размеров изображений
      ------------------------------

        # resize        | изменить размер изобр. на [width]/[height]; можно сохр.соотн.сторон и не допустить увелич.веса
        # widen         | изменить размер изобр. пропорционально указанному width; можно не допустить увелич.веса
        # heighten      | изменить размер изобр. пропорционально указанному height; можно не допустить увелич.веса
        # fit           | crop (в соотв. с заданной пропорцией) + resize (с сохр.соотн.сторон)
        # resizeCanvas  | изменить размер границ изображения на указанный; можно указать якор.точку, откуда изменять
        # crop          | вырезать прямоугольник [width]/[height] из изображения, с позиции [x]/[y]
        # trim          | обрезает пустые участки по краям изображения

      Работа с цветом изображений
      ---------------------------

        # gamma         | коррекция гаммы изображения
        # brightness    | коррекция яркости изображения
        # contrast      | коррекция контраста изображения
        # colorize      | коррекция содержания RED, GREEN, BLUE цветов в изображении
        # greyscale     | сделать изображение черно-белым
        # invert        | инвертировать все цвета изображения
        # mask          | применить указанный source, как альфа-маску, к указанному изображению
        # flip          | зеркально отразить изображение (горизонтально/вертикально)
        # limitColors   | ограничить max число цветов в изображении (оно конвертируется)
        # pickColor     | считывает цвет из точки X изображения и возвращает в указанном формате

      Применение эффектов и фильтров
      ------------------------------

        # filter        | применить пользовательский фильтр к изображению
        # pixelate      | применить эффект пикселизации к изображению, с указанным размером пикселя
        # rotate        | повернуть изображение против часовй стрелки на угол angle; можно указать цвет для пустых мест, появившихся после поворота
        # orientate     | читает из exif-данных инфу об ориентации изображения, и корректирует её, чтобы отобразить его корректно
        # blur          | применить фильтр размытия по гауссу к изображению
        # sharpen       | увеличить резкость изображения
        # opacity       | установить непрозрачность изображения от 0% (прозрачное) до 100% (непрозрачное)

      Рисование
      ---------

        # text          | написать текст на изображении в указанном месте (текст и его параметры можно задавать)
        # pixel         | нарисовать 1 пиксель указанного цвета в указанном месте
        # line          | нарисовать линию из т.X в т.Y (цвет и ширину можно задать)
        # rectangle     | нарисовать прямоугольник по точкам ABCD (параметры границ и фона можно задать в колбэк-функции)
        # circle        | нарисовать круг с центром в точке X и радиусом R (параметры границ и фона можно задать в колбэк-функции)
        # ellipse       | нарисовать эллипс с центром в т.X и радиусами R1 и R2 (параметры границ и фона можно задать в колбэк-функции)
        # polygon       | рисует полигон по указанным точкам (параметры границ и фона можно задать в колбэк-функции)

      Вставка одного изображения в другое, водяной знак
      -------------------------------------------------

        # fill          | залить изображение указанным цветом, или другим изображением как плиткой (repeat)
        # insert        | поместить поверх изобр. другое (из указ.источн.), в указанном месте; м.б. использовано для создания водяных знаков (прозрачность поддерживаается)

      Извлечение информации
      ---------------------

        # width         | получить ширину изображения
        # height        | получить высоту изображения
        # mime          | получить MIME-тип изображения (если он установлен)
        # exif          | прочитать метаданные exif из изображения
        # filesize      | получить размер изображения в байтах, если оно получено из файла в файловой системе

      Возвращение изображения
      -----------------------

        # save          | сохранить изображение в файловую систему
        # encode        | закодировать изображение в указанный формат (jpeg по умолчанию), в указанном качестве (90 по умолчанию)
        # response      | encode + создать объект Illuminate\Http\Response и вложить в него закодированное изображение

      Прочее
      ------

        # backup        | сохранить в памяти текущ.сост.изобр. под именем [name] (откатить можно функцией reset)
        # reset         | вернуть файл к состоянию [name], сохранённому с помощью backup

        # cache         | [закэшировать]/[прочитать из кэша] указанное изображение

        # destroy       | высвободить память, связанную с изображением, до завершения php-скрипта
        # getCore       | получить изображение в формате используемого драйвера (GD или Imagick)
        # interlace     | вкл/выкл чересстрочную развертку изображения

    --------------------------------------


    Создание и считывание изображений
    ---------------------------------

      //----------------------------
      // # canvas
      //----------------------------
      // - создать новое изобр.-экз. II с width, height и color
      // - public Intervention\Image\ImageManager canvas(integer $width, integer $height, [mixed $bgcolor])
      //
      //    - $width    | ширина изображения в px
      //    - $height   | высота изображения в px
      //    - $bgcolor  | цвет фона изображения в любом поддерживаемом формате
      //

        - Создадим изображение 600x300 с фоном цвета '#eee'
            $img = Image::canvas(600, 300, '#eee');

        - Вернём это изображение клиенту:
            return $img->response();


      //----------------------------
      // # make
      //----------------------------
      // - создать новое изобр.-экз. из указанного источника

        - Из файла:
            $img = Image::make( URL::asset('armani_46.jpg') );

        - Из URL:
            $img = Image::make('http://bm.img.com.ua/nxs/img/prikol/images/large/7/1/159117_287309.jpg');

        - Вернуть клиенту:
            return $img->response();


    Изменение размеров изображений
    ------------------------------

      //----------------------------
      // # resize
      //----------------------------
      // - изменить размер изобр. на [width]/[height]; можно сохр.соотн.сторон и не допустить увелич.веса
      // - public Intervention\Image\Image resize ( integer $width, integer $height, [Closure $callback] )
      //
      //   - $width     | новая ширина
      //   - $height    | новая высота
      //   - $callback  | анонимная функция, в которой наложить ограничения:
      //                  - aspectRatio() | сохранить соотношение сторон
      //                  - upsize()      | не дать увеличить размер файла по сравнению с первоначальным
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Изменим его размер на 300x200:
            $img->resize(300, 200);           // будет растянуто/сжато

        - Изменим только его ширину на 300:
            $img->resize(300, null);          // будет растянуто/сжато

        - Изменим только его высоту на 200:
            $img->resize(null, 200);          // будет растянуто/сжато

        - Изменим только его ширину на 300 и сохраним соотношение сторон:
            $img->resize(300, null, function($constraint){
              $constraint->aspectRatio();                     // НЕ будет растянуто/сжато
            });

        - Изменим только его высоту на 200 и сохраним соотношение сторон:
            $img->resize(null, 200, function($constraint){
              $constraint->aspectRatio();                     // НЕ будет растянуто/сжато
            });

        - Изменим только его высоту на 400 и предотвратим увеличение размера, и сохраним соотн.сторон:
            $img->resize(null, 400, function($constraint){
              $constraint->aspectRatio();                    // НЕ будет растянуто/сжато
              $constraint->upsize();                         // размер НЕ станет больше
            });

      //----------------------------
      // # widen
      //----------------------------
      // - изменить размер изобр. пропорционально указанному width; можно не допустить увелич.веса
      // - public Intervention\Image\Image widen ( integer $width, [Closure $callback] )
      //
      //   - $width     | новая ширина
      //   - $callback  | анонимная функция с ограничениями (доступно лишь 1: upsize())
      //
      // - По сути это resize, в котором можно менять только width, и соотн.сторон всегда сохраняется
      // - Аналог heighten, только для ширины.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Установим ширину изображения равной 500px (высота автоматом изменится пропорционально):
            $img->widen(500);   // изначальные пропорции сохранены

        - Сделаем тоже самое, но установим ограничение - результат не должен по весу быть больше исходника:
            $img->widen(500, , function($constraint){
              $constraint->upsize();
            });

      //----------------------------
      // # heighten
      //----------------------------
      // - изменить размер изобр. пропорционально указанному height; можно не допустить увелич.веса
      // - public Intervention\Image\Image heighten ( integer $height, [Closure $callback] )
      //
      //   - $height    | новая высота
      //   - $callback  | анонимная функция с ограничениями (доступно лишь 1: upsize())
      //
      // - По сути это resize, в котором можно менять только height, и соотн.сторон всегда сохраняется
      // - Аналог widen, только для высоты.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Установим высоту изображения равной 500px (высота автоматом изменится пропорционально):
            $img->heighten(500);   // изначальные пропорции сохранены

        - Сделаем тоже самое, но установим ограничение - результат не должен по весу быть больше исходника:
            $img->heighten(500, , function($constraint){
              $constraint->upsize();
            });


      //----------------------------
      // # fit
      //----------------------------
      // - crop (в соотв. с заданной пропорцией) + resize (с сохр.соотн.сторон)
      // - public Intervention\Image\Image fit( int $width, [ [int $height], [Closure $callback, [ string $position ]] ])
      //
      //   - $width     | ширина
      //   - $height    | высота
      //   - $callback  | анон.функция, позволяющая задать доп. параметры:
      //                  - upsize()    | предотвратить рост веса результата по сравнению с исходником
      //                  - position()  | позиция вырезаемого прямоугольника (доступные значения см. ниже)
      //
      // - Принцип работы:
      //   1) Вычисляет соотношение сторон R, как $width / $height
      //   2) Вычисляет размеры прямоугольника с R, наилучшим образом влезующего в изображение
      //      - Его размеры НЕ $width и $height!
      //      - Его размеры равны размерам изображения!
      //      - Но его соотношение сторон равно R.
      //   3) Вырезает этот прямоугольник из изображения в соотв. с position
      //      - По умолчанию центр прямоугольника в центре изображения.
      //      - Но в position можно задать иное положение прямоугольника.
      //      - Доступные значения: top-left, top, top-right, left, center (по умолч.), right, bottom-left, bottom, bottom-right
      //   4) Изменяет размеры вырезанного прямоугольника до $width и $height
      //      - Разумеется, соотношение сторон остаётся равным R.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Вырежем прямоуг.MAX разм. с соотн.сторон 100x50, и изменим его размер на 100x50:
            $img->fit(100, 50);


      //----------------------------
      // # resizeCanvas
      //----------------------------
      // - изменить размер границ изображения на указанный; можно указать якор.точку, откуда изменять
      // - public Intervention\Image\Image resizeCanvas (int $width, int $height, [string $anchor, [boolean $relative, [mixed $bgcolor]]])
      //
      //   $width     | новая ширина холста в px
      //   $height    | новая высота холста в px
      //   $anchor    | определяет, с каких сторон будет обрезано/наращено изображение (варианты см.ниже)
      //   $relative  | включить ли "относительный режим", когда $width и $height будут добавлены к текущим размерам холста: true / false (по умолчанию)
      //   $bgcolor   | цвет фона наращенных пустых областей (если новые размеры больше старых)
      //
      // - Операция аналогична операции "изменить размер холста" в Photoshop.
      // - Если новые размеры меньше, изображение просто обрезается там, где задано настройками.
      // - А если больше, то туда добавляется пустое пространство с цветом фона $bgcolor
      // - Возможные значения $anchor: top-left, top, top-right, left, center (по умолч.), right, bottom-left, bottom, bottom-right
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Уменьшим размер холста до 100x100, изображение будет обрезано со всех сторон, к центру:
            $img->resizeCanvas(100, 100);
            $img->resizeCanvas(100, 100, 'center');

        - Нарастим холст с каждой стороны на 50px, пустые области закрасим серым:
            $img->resizeCanvas(100, 100, 'center', true, '#eee');

        - Обрежем холст с каждой стороны на 50px:
            $img->resizeCanvas(-100, -100, 'center', true);

        - Нарастим холст слева/справа на 50px, а снизу на 100px, пустые области закрасим серым:
            $img->resizeCanvas(100, 100, 'top', true, '#eee');

        - Обрежем холст слева/справа на 50px, а снизу на 100px:
            $img->resizeCanvas(-100, -100, 'top', true);


      //----------------------------
      // # crop
      //----------------------------
      // - вырезать прямоугольник [width]/[height] из изображения, с позиции [x]/[y]
      // - public Intervention\Image\Image crop(int $width, int $height, [int $x, int $y])
      //
      //   - $width   | ширина прямоугольника, который надо вырезать
      //   - $height  | высота прямоугольника, который надо вырезать
      //   - $x       | координата X лев.верх. угла вырезаемого прямоугольника
      //   - $y       | координата Y лев.верх. угла вырезаемого прямоугольника
      //
      // - По умолчанию, центр вырезаемого прямоугольника находится в центре изображения.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Вырежем квардрат 100x100 по центру $img:
            $img->crop(100, 100);

        - Вырежем квардрат 100x100 с ЛВ углом в ЛВ угле изображения (0,0):
            $img->crop(100, 100, 0, 0);


      //----------------------------
      // # trim
      //----------------------------
      // - обрезает пустые участки по краям изображения
      // - public Intervention\Image\Image trim( [string $base, [array $away, [int $tolerance, [int $feather]]]] )
      //
      //   $base        | место для взятия образца цвета, который надо срезать по краям
      //                  - доступные значения: top-left (по умолч.), bottom-right, transparent
      //   $away        | с какой стороны надо срезать (по умолч. срезается со всех)
      //   $away          - доступные значения: top, left, bottom, right
      //   $tolerance   | чувствительность от 0 (по умолч.) до 100, чем больше, тем больше похожих цветов удаляет
      //   $feather     | оставить нетронутым область такой толщины в px вокруг изображения
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Нарастим границу цвета '#eee' 50px вокруг $img (для дальнейшего обрезания):
            $img->resizeCanvas(100, 100, 'center', true, '#eee');

        - Обрежем границу вокруг $img со всех сторон, цвет возьмём из ЛВ угла:
            $img->trim();

        - Обрежем границу вокруг $img со всех сторон, цвет возьмём из Пн угла:
            $img->trim('bottom-right');

        - Обрежем прозрачную границу вокруг $img со всех сторон, цвет возьмём из Пн угла:
            $img->resizeCanvas(100, 100, 'center', true, 'RGBA(0,0,0,0)');
            $img->trim('transparent');

        - Обрежем границу вокруг $img только слева, цвет возьмём из ЛВ угла:
            $img->trim('top-left', 'left');

        - Обрежем границу вокруг $img со всех сторон с 50% толерантностью и 10px нетронутой границы, цвет возьмём из ЛВ угла:
            $img->trim('top-left', null, 50, 10);


    Работа с цветом изображений
    --------------------

      //----------------------------
      // # gamma
      //----------------------------
      // - коррекция гаммы изображения
      // - public Intervention\Image\Image gamma( float $correction )
      //
      //   $correction    | во сколько раз изменить гамму (0 - полная чернота, 1 - текущее состояние, 2 - в 2 раза выше и т.д.)
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Изменим гамму до полной черноты:
            $img->gamma(0);

        - Увеличим гамму в 4 раза:
            $img->gamma(4);


      //----------------------------
      // # brightness [!почему-то не сработала]
      //----------------------------
      // - коррекция яркости изображения
      // - public Intervention\Image\Image brightness( integer $level )
      //
      //   $level   | уровень яркости (MIN: -100, NORM: 0, MAX: +100)
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Изменим яркость до -50:
            $img->brightness(-50);

        - Изменим яркость до +50:
            $img->brightness(50);


      //----------------------------
      // # contrast
      //----------------------------
      // - коррекция контраста изображения
      // - public Intervention\Image\Image contrast(integer $level)
      //
      //   $level   | уровень контраста (MIN: -100, NORM: 0, MAX: +100)
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Изменим контраст до -50:
            $img->contrast(-50);

        - Изменим контраст до +50:
            $img->contrast(50);


      //----------------------------
      // # colorize
      //----------------------------
      // - коррекция содержания RED, GREEN, BLUE цветов в изображении
      // - public Intervention\Image\Image colorize(integer $red, integer $green, integer $blue)
      //
      //   $red     | уровень красного (MIN: -100, NORM: 0, MAX: +100)
      //   $green   | уровень зелёного (MIN: -100, NORM: 0, MAX: +100)
      //   $blue    | уровень синего (MIN: -100, NORM: 0, MAX: +100)
      //
      // - Уровни цветов, как видно, нормализованы.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Уберём красный, оставим зелёный без изменений, и прибавим синего:
            $img->colorize(-100, 0, 100);


      //----------------------------
      // # greyscale [!почему-то не сработала]
      //----------------------------
      // - сделать изображение черно-белым
      // - public Intervention\Image\Image greyscale()
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Сделаем изображение черно-белым:
            $img->greyscale();


      //----------------------------
      // # invert
      //----------------------------
      // - инвертировать все цвета изображения
      // - public Intervention\Image\Image invert()
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Инвертируем все цвета изображения:
            $img->invert();


      //----------------------------
      // # mask
      //----------------------------
      // - применить указанный source, как альфа-маску, к указанному изображению
      // - public Intervention\Image\Image mask( mixed $source, [bool $mask_with_alpha] )
      //
      //   $source            | источник изображения-маски (принимается любой разрешённый формат)
      //   $mask_with_alpha   | содержит ли маска альфа-канал (true/false)
      //
      // - Альфа-маска позволяет сделать эффект сведения изображения на нет.
      // - Допустим, как-будто изображение по краям сходит на нет.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Создадим изображение из URL, которое будем испольозвать, как маску:
            $mask = Image::make('http://img0.liveinternet.ru/images/attach/c/2//66/154/66154940_0_4f676_7de0df89_L.png');

        - Применим $mask к $img, как альфа-маску:
            $img->mask($mask);

        - Применим $mask с альфа-каналом к $img:
            $img->mask($mask, true);


      //----------------------------
      // # flip
      //----------------------------
      // - зеркально отразить изображение (горизонтально/вертикально)
      // - public Intervention\Image\Image flip( [mixed $mode] )
      //
      //   $mode  | 'h' - горизонтально (по умолч.), 'v' - вертикально
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Отразим его горизонтально:
            $img->flip();

        - Отразим его вертикально:
            $img->flip('v');


      //----------------------------
      // # limitColors
      //----------------------------
      // - ограничить max число цветов в изображении (оно конвертируется)
      // - public Intervention\Image\Image limitColors( integer $count, [mixed $matte] )
      //
      //   $count   | null - truecolor, или число - MAX кол-во цветов в палитре
      //   $matte   | цвет, который будет применяться к прозрачным пикселам (по умолчанию отключено)
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Оставим изображению лишь 3 цвета:
            $img->limitColors(3);

        - Оставим изображению лишь 3 цвета, а к прозрачным пикселам применим серый цвет:
            $img->limitColors(3, '#eee');


      //----------------------------
      // # pickColor
      //----------------------------
      // - считывает цвет из точки X изображения и возвращает в указанном формате
      // - public Intervention\Image\Image pickColor( int $x, int $y, [string $format] )
      //
      //   $x       | x-коорд. точки, откуда брать цвет
      //   $y       | x-коорд. точки, откуда брать цвет
      //   $format  | в каком формате функция вернёт результат
      //              - array: array(255, 255, 255, 1)    (по умолч.)
      //              - rgb: rgb(255, 255, 255)
      //              - rgba: rgba(255, 255, 255, 0.5)
      //              - hex: #cccccc
      //              - int: 16776956
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Возьмём цвет в формате hex из ЛВ угла (0,0) изображения:
            $color = $img->pickColor(0, 0, 'hex');

        - Возьмём цвет в формате array из точки (100,100) изображения:
            $color = $img->pickColor(100, 100);


    Применение эффектов и фильтров
    ------------------------------

      //----------------------------
      // # filter
      //----------------------------
      // - применить пользовательский фильтр к изображению
      // - public Intervention\Image\Image filter( Intervention\Image\Filters\FilterInterface $filter )
      //
      //   $filter  | фильтр, который надо применить к изображению
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Применим к нему DemoFilter:
            $img->filter(new DemoFilter(45));


      //----------------------------
      // # pixelate
      //----------------------------
      // - применить эффект пикселизации к изображению, с указанным размером пикселя
      // - public Intervention\Image\Image pixelate( integer $size )
      //
      //   $size  | размер пиксела
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Применим к нему pixelate с размером пиксела 3:
            $img->pixelate(3);


      //----------------------------
      // # rotate
      //----------------------------
      // - повернуть изображение против часовй стрелки на угол angle; можно указать цвет для пустых мест, появившихся после поворота
      // - public Intervention\Image\Image rotate( float $angle, [string $bgcolor] )
      //
      //   $angle     | угол, на который надо повернуть изображение
      //   $bgcolor   | цвет, которым закрасить пустые места, которые могут появиться при повороте
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Повернём изображение на 45° против ЧС
            $img->rotate(45);

        - Повернём изображение на 45° по ЧС
            $img->rotate(-45);

        - Повернём изображение на 45° по ЧС, пустые места закрасим серым:
            $img->rotate(-45, '#eee');


      //----------------------------
      // # orientate
      //----------------------------
      // - читает из exif-данных инфу об ориентации изображения, и корректирует её, чтобы отобразить его корректно
      // - public Intervention\Image\Image orientate()
      // - допустим, фото было сделано на смартфон в горизонтальной ориентации
      // - инфа об этом как раз и есть в exif
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Ориентируем его правильно, согласно данным из exif:
            $img->orientate();


      //----------------------------
      // # blur
      //----------------------------
      // - применить фильтр размытия по гауссу к изображению
      // - public Intervention\Image\Image blur( [integer $amount] )
      //
      //   $amount  | значение от 0 (не размыто) до 100 (max размытие)
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Слегка размоем его:
            $img->blur(2);

        - Сильно размоем его:
            $img->blur(60);


      //----------------------------
      // # sharpen
      //----------------------------
      // - увеличить резкость изображения
      // - public Intervention\Image\Image sharpen( [integer $amount] )
      //
      //   $amount  | значение от 0 (не размыто) до 100 (max размытие)
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

        - Слегка наведём резкость на него:
            $img->sharpen(10);

        - Наведём на него резкость по-серьёзному:
            $img->sharpen(60);


      //----------------------------
      // # opacity
      //----------------------------
      // - установить непрозрачность изображения от 0% (прозрачное) до 100% (непрозрачное)
      // - public Intervention\Image\Image opacity( integer $transparency )
      //
      //   $transparency  | значение от 100 (непрозрачный) до 0 (прозрачный)
      //
      // *Примечание:
      //    - Чтобы эффект был заметен, надо кодировать в формате PNG.
      //

        - Создадим изображение из URL:
            $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');


        - Сделаем его полупрозрачным:
            $img->opacity(50);

        - Сделаем его непрозрачным:
            $img->opacity(0);

        - Сделаем его почти полностью прозрачным:
            $img->opacity(90);


        - Возвращаем клиенту в формате PNG!
            $img->response('png');


    Рисование
    ---------

      //----------------------------
      // # text
      //----------------------------
      // - написать текст на изображении в указанном месте (текст и его параметры можно задавать)
      // - public Intervention\Image\Image text( string $text, [integer $x, [integer $y, [Closure $callback]]] )
      //
      //   - $text      | текст, который надо написать
      //   - $x         | координата x центра текста (== 0 по умолчанию)
      //   - $y         | координата y центра текста (== 0 по умолчанию)
      //   - $callback  | анонимная функция, позволяющая задать параметры текста
      //

        - Создадим изображение:
            $img = Image::canvas(600, 300, '#eee');

        - Напишем на нём "Сарай", и зададим параметры текста:

            $img->text('foo', 200, 100, function($font) {
                $font->file('resources/other/PT sans ttf/PTC55F.ttf');   | путь к ttf-шрифру или цифра от 1 до 5 (встроенные в GD шрифты, 1 по умолчанию)
                $font->size(70);                                         | размер шрифта в px
                $font->color('#000');                                    | цвет шрифта
                $font->align('center');                                  | гориз.выравнивание (center / right / left)
                $font->valign('top');                                    | вертик.выравнивание (tom / middle/ bottom)
                $font->angle(10);                                        | угол поворота против ч.с.
            });

        - Вернём клиенту:
            return $img->response();


      //----------------------------
      // # pixel
      //----------------------------
      // - нарисовать 1 пиксель указанного цвета в указанном месте
      // - public Intervention\Image\Image pixel( mixed $color, integer $x, integer $y )
      //
      //   $color   | цвет пиксела в любом принимаемом формате
      //   $x       | x-координата точки, где надо нарисовать пиксел
      //   $y       | y-координата точки, где надо нарисовать пиксел
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - В его центре поставим белый пиксел:
            $img->pixel('#fff', 300, 150);


      //----------------------------
      // # line
      //----------------------------
      // - нарисовать линию из т.X в т.Y (цвет и ширину можно задать)
      // - public Intervention\Image\Image line( int $x1, int $y1, int $x2, int $y2, [Closure $callback] )
      //
      //   $x1        | x-координата точки №1, откуда нужно вести линию
      //   $y1        | y-координата точки №1, откуда нужно вести линию
      //   $x2        | x-координата точки №2, куда нужно вести линию
      //   $y2        | y-координата точки №2, куда нужно вести линию
      //   $callback  | анон.функ., где можно определить цвет и ширину линии
      //                - color(string $color)
      //                - width(integer $width)
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Проведём белую линию шириной 10px от ЛВ до ПН угла
            $img->line(0,0, 600,300, function($draw){
              $draw->color('#fff');
              $draw->width(10);
            });


      //----------------------------
      // # rectangle
      //----------------------------
      // - нарисовать прямоугольник по точкам ABCD (параметры границ и фона можно задать в колбэк-функции)
      // - public Intervention\Image\Image rectangle( int $x1, int $y1, int $x2, int $y2, [Closure $callback])
      //
      //   $x1        | x-координата ЛВ угла прямоугольника
      //   $y1        | y-координата ЛВ угла прямоугольника
      //   $x2        | x-координата ПН угла прямоугольника
      //   $y2        | y-координата ПН угла прямоугольника
      //   $callback  | анон.функ., где можно определить цвет и ширину линии
      //                - background(string $color)
      //                - border( integer $width, string $color )
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Нарисуем по центру белый квадрат с зелёной рамкой толщиной 10px:
            $img->rectangle(250,100, 350,200, function($draw){
              $draw->background('#fff');
              $draw->border(10, '#5f5');
            });


      //----------------------------
      // # circle
      //----------------------------
      // - нарисовать круг с центром в точке X и радиусом R (параметры границ и фона можно задать в колбэк-функции)
      // - public Intervention\Image\Image circle( integer $radius, integer $x, integer $y, [Closure $callback] )
      //
      //   $radius    | радиус круга
      //   $x         | x-координата центра круга
      //   $y         | y-координата центра круга
      //   $callback  | анон.функ., где можно определить цвет и ширину линии
      //                - background(string $color)
      //                - border( integer $width, string $color )
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Нарисуем в центре белый круг с радиусом 100px, и зелёной рамкой толщиной 10px:
            $img->circle(100, 300,150, function($draw){
              $draw->background('#fff');
              $draw->border(10, '#5f5');
            });

      //----------------------------
      // # ellipse
      //----------------------------
      // - нарисовать эллипс с центром в т.X и радиусами R1 и R2 (параметры границ и фона можно задать в колбэк-функции)
      // - public Intervention\Image\Image ellipse(int $width, int $height, int $x, int $y, [Closure $callback])
      //
      //   $width     | ширина эллипса (10 по умолчанию)
      //   $height    | высота эллипса (10 по умолчанию)
      //   $x         | x-координата центра эллипса
      //   $y         | y-координата центра эллипса
      //   $callback  | анон.функ., где можно определить цвет и ширину линии
      //                - background(string $color)
      //                - border( integer $width, string $color )
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Нарисуем в центре белый эллипс 200x100, и зелёной рамкой толщиной 10px:
            $img->ellipse(200,100, 300,150, function($draw){
              $draw->background('#fff');
              $draw->border(10, '#5f5');
            });


      //----------------------------
      // # polygon
      //----------------------------
      // - рисует полигон по указанным точкам (параметры границ и фона можно задать в колбэк-функции)
      // - public Intervention\Image\Image polygon(array $points, [Closure $callback])
      //
      //   $points    | 1d-массив точек полигона
      //   $callback  | анон.функ., где можно определить цвет и ширину линии
      //                - background(string $color)
      //                - border( integer $width, string $color )
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Подготовим массив координат точек для 6-конечного полигона:
            $points = array(
              200,100,
              300,50,
              400,100,
              400,200,
              300,250,
              200,200
            );

        - Нарисуем 6-конечный полигон с зелёной рамкой толщиной 10px:
            $img->polygon($points, function($draw){
              $draw->background('#fff');
              $draw->border(10, '#5f5');
            });


    Вставка одного изображения в другое, водяной знак
    -------------------------------------------------

      //----------------------------
      // # fill
      //----------------------------
      // - залить изображение указанным цветом, или другим изображением как плиткой (repeat)
      // - public Intervention\Image\ImageManager fill(mixed $filling, [integer $x, integer $y])
      //
      //   $filling   | цвет (в любом из допустимых форматов) или источник изображения (любой из допустимых)
      //   $x         | x-координата стартовой точки для заливки
      //   $y         | y-координата стартовой точки для заливки
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Зальём его полностью зелёным цветом:
            $img->fill('#5f5');

        - Зальём его полностью повторяющимся изображением из URL:
            $img->fill('http://www.diabetesmine.com/wp-content/uploads/2009/03/facebook-small-icon.png');


      //----------------------------
      // # insert
      //----------------------------
      // - поместить поверх изобр. другое (из указ.источн.), в указанном месте; м.б. использовано для создания водяных знаков (прозрачность поддерживаается)
      // - public Intervention\Image\Image insert(mixed $source, [string $position, [integer $x, integer $y]])
      //
      //   $source    | источник изображения
      //   $position  | где разместить: top-left (default), top, top-right, left, center, right, bottom-left, bottom, bottom-right
      //   $x         | сдвиг по оси x относительно $position
      //   $y         | сдвиг по оси y относительно $position
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 600, '#000');

        - Подготовим полупрозрачный водяной знак:
            $mark = Image::make('http://res.cloudinary.com/demo/image/upload/sample_watermark.png');

        - Поместим $mark справа-снизу в $img:
            $img->insert($mark, 'bottom-right');


    Извлечение информации
    ---------------------

      //----------------------------
      // # width
      //----------------------------
      // - получить ширину изображения
      // - public Intervention\Image\Image width()
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Получим ширину изображения:
            $w = $img->width();       // 600


      //----------------------------
      // # height
      //----------------------------
      // - получить высоту изображения
      // - public Intervention\Image\Image height ()
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Получим высоту изображения:
            $w = $img->height();       // 300


      //----------------------------
      // # mime
      //----------------------------
      // - получить MIME-тип изображения (если он установлен)
      // - public Intervention\Image\Image mime()
      //

        - Получим изображение из URL:
            $img = Image::make('http://res.cloudinary.com/demo/image/upload/sample_watermark.png');

        - Получим его mime-тип:
            $mime = $img->mime();   // image/png


      //----------------------------
      // # exif
      //----------------------------
      // - прочитать метаданные exif из изображения
      // - public Intervention\Image\Image exif([string $key])
      //
      //   $key   | извлечь значение только св-ва с указанным ключём
      //

        - Получим изображение из URL:
            $img = Image::make('http://res.cloudinary.com/demo/image/upload/sample_watermark.png');

        - Извлечём данные exif изображения в массив:
            $exif = $img->exif();

        - Извлечём данные о модели камеры, которым снято изображение, в переменную:
            $name = $img->exif('Model');


      //----------------------------
      // # filesize [!почему-то не сработала]
      //----------------------------
      // - получить размер изображения в байтах, если оно получено из файла в файловой системе
      // - public Intervention\Image\Image filesize()
      //

        - Получим изображение из файла:
            $img = Image::make( URL::asset('armani_46.jpg') );

        - Узнаем размер этого изображения:
            $size = $img->filesize();


    Возвращение изображения
    -----------------------

      //----------------------------
      // # save
      //----------------------------
      // - сохранить изображение в файловую систему
      // - public Intervention\Image\Image save( [string $path, [int $quality]] )
      //
      //   $path      | куда сохранить
      //                - если $img создано из существующего файла, а $path не указан, то он будет перезаписан
      //   $quality   | в каком качестве сохранить, (от 0 до 100), 90 по умолчанию
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Закодируем его в PNG-формат с качеством 100
            $img->encode('png', 100);

        - Сохраним его, как 'blackhole.png' в файловую систему (папку public в Laravel), в качестве 90:
            $img->save('blackhole.png');

        - Сохраним его, как 'blackhole.png' в файловую систему (папку public в Laravel), в качестве 100:
            $img->save('blackhole.png', 100);


      //----------------------------
      // # encode
      //----------------------------
      // - закодировать изображение в указанный формат (jpeg по умолчанию), в указанном качестве (90 по умолчанию)
      // - public Intervention\Image\Image encode([mixed $format, [int $quality]])
      //
      //   $format    | jpg / png / gif / tif / bmp
      //                - По умолчанию изображение будет закодировано в типе текущего изображения
      //                - Если тип изображения ещё не определён, то в jpg
      //   $quality   | качество (от 0 до 100), 90 по умолчанию
      //
      // - encode() нужно применять, скажем, перед save()
      //

        - Пример см.выше


      //----------------------------
      // # response
      //----------------------------
      // - encode + создать объект Illuminate\Http\Response и вложить в него закодированное изображение
      // - public Intervention\Image\Image response( [string $format, [integer $quality]] )
      //
      //   $format    | jpg / png / gif / tif / bmp
      //                - По умолчанию изображение будет закодировано в типе текущего изображения
      //                - Если тип изображения ещё не определён, то в jpg
      //   $quality   | качество (от 0 до 100), 90 по умолчанию
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Вернём его клиенту:

          ● В качестве 90 в виде jpg-файла
              return $img->response();

          ● В качестве 50 в виде png-файла
              return $img->response('png', 50);


    Прочее
    ------

      //----------------------------
      // # backup
      //----------------------------
      // - сохранить в памяти текущ.сост.изобр. под именем [name] (откатить можно функцией reset)
      // - public Intervention\Image\Image backup( [string $name] )
      //
      //   $name  | имя бэкапа состояния изображения в памяти
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Сохраним его состояние в памяти, как 'backup1':
            $img->backup('backup1');

        - Сделаем его полупрозрачным:
            $img->opacity(50);

        - Вернём его к состоянию 'backup1':
            $img->reset('backup1');


      //----------------------------
      // # reset
      //----------------------------
      // - вернуть файл к состоянию [name], сохранённому с помощью backup
      // - public Intervention\Image\Image reset( [string $name] )
      //
      //   $name  | имя бэкапа состояния, к которому надо вернуть изображение
      //

        - см. пример выше


      //----------------------------
      // # cache
      //----------------------------
      // - [закэшировать]/[прочитать из кэша] указанное изображение
      // - public Intervention\Image\ImageManager cache( Closure $callback, [int $lifetime, [bool $returnObj]] )
      //
      //   $callback    | анон.функ. с операциями над изображением, определяющими закэшированное изображение
      //   $lifetime    | время жизни кэша в минутах (5 по умолчанию)
      //   $returnObj   | что вернуть: экземпляр II (по умолч.) или поток изображения (стрку)
      //

        - Как только IICache установлен, становится доступен метод cache.
        - Через него и следует проводить все манипуляции с изображением.
        - Допустим, у нас есть изображение 'public/foo.jpg'.
        - И мы хотим получить его же, но в размере 300x200.
        - Получаем объект II в 1-й раз, через cache. Кэшируем на 10 минут.

            $img = Image::cache(function($image) {
               $image->make('public/foo.jpg')->resize(300, 200);
            }, 10, true);

        - Через в течение 10 минут оно снова нам понадобилось.
        - Делаем точно такой-же запрос.
        - Но в этот раз оно будет извлечено уже из кэша:

            $img = Image::cache(function($image) {
               $image->make('public/foo.jpg')->resize(300, 200);
            }, 10, true);


      //----------------------------
      // # destroy
      //----------------------------
      // - высвободить память, связанную с изображением, до завершения php-скрипта
      // - public Intervention\Image\Image destroy()
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Закодируем его в PNG-формат с качеством 100
            $img->encode('png', 100);

        - Сохраним его, как 'blackhole.png' в файловую систему (папку public в Laravel), в качестве 90:
            $img->save('blackhole.png');

        - Высвободим связанную с $img память:
            $img->destroy();


      //----------------------------
      // # getCore
      //----------------------------
      // - получить изображение в формате используемого драйвера (GD или Imagick)
      // - public Intervention\Image\Image getCore()
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Получим его в формате Imagick
            $imagick = $img->getCore();


      //----------------------------
      // # interlace
      //----------------------------
      // - вкл/выкл чересстрочную развертку изображения
      // - public Intervention\Image\Image interlace( [boolean $interlace] )
      //
      //   $interlace   | true (по умолч.) / false
      //

        - Создадим чёрное изображение:
            $img = Image::canvas(600, 300, '#000');

        - Включить чересстрочную развертку:
            $img->interlace();

        - Выключить чересстрочную развертку:
            $img->interlace(false);


А21. Кэширующий сервер изображений в интернет-магазине

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - В двух словах обо всём

    - Фронт работ: содержание меню 'М5. Ресурсы'
    - Фронт работ: серверная часть на поддомене img.grumart.ru

  --------------------------------------

  > Ссылки

    - Кэширование в MySQL:
        http://www.mysql.ru/docs/man/Query_Cache_Configuration.html

    - Официальный сайт пакета Intervention Image для Laravel
        http://image.intervention.io/

  > Введение
    - Интернет-магазину потребуется работать с большим кол-вом картинок.
    - Причём каждая картинка понадобится в нескольких разных размерах.
    - И на некоторые из них потребуется проставлять т.н. "водяной знак".
    - Чтобы сервер не лёг, а у пос-лей всё грузилось быстро, понадобится кэширование.
    - Эта глава о том, как сделать такой сервер на Laravel.

  > В двух словах обо всём

    1) Отдельный модуль для работы с изображениями и другими ресурсами
      - Его следует сделать. Это будет модуль "M5. Ресурсы".
      - Он будет использовать 3 таблицы:

          M5_resources
          M5_settings
          M5_filters

    2) GET API

      # Будет выглядеть так:
          http://[хост]/( [width]x[height] | 'original' )/[filter id]/[img id]/[img name].[img resolution]

      # Пример:
          http://img.grumart.ru/200x200/0/55/ivan.png

    3) Настройки
      - В разделе "M5. Ресурсы" должно быть подменю "Настройки".
      - Оно будет связано с таблице M5_settings.
      - В нём должен быть реализован интерфейс для настройки сервера ресурсов.
      - Должна быть реализована настройка следующих вещей:

        • Хост сервера изображений. Например, 'http://img.grumart.ru'.
        • Папка, в которой искать изображения (относ.public)
        • Время хранения кэша изображений в памяти.
        • Значение директивы 'memory_limit' из php.ini
        • Значение директивы 'upload_max_filesize' из php.ini
        • Изображение для водяного знака.
        • Изображение, которое показывается в случае, если ресурс не найден.
        •
        • query_cache_limit
        • query_cache_size
        • query_cache_type
        •

    4) Настройки читаются из M5_settings при каждом запросе картинки?
      - Да. Но не будет ли это работать медленно?
      - Нет, не будет. Потому что у MySQL есть кэширование запросов.
      - Срок годности кэша не ограничен.
      - Кэш перезаписывается при изменении данных в соотв. таблице.
      - Кэш удаляется при перезапуске сервера MySQL.
      - Нужно настроить кэширование так, чтобы запросы к M5_settings и M5_filters кэшировались.

    5) В каком виде хранятся изображения в каталоге?
      - Имя каждого изображения == ID его ресурса. Без расширения.
      - Например:

        Папка с изображениями
        -----------------------

          1
          2
          3
          ...
          55
          56
          57
          ...

    6) Как браузер и поисковики вычисляют имя отдаваемого изображения?
      - По последней секции после /
      - Допустим, отдаём мы изображение по URL: 'http://grumart.ru/img/ivan.png'
      - Браузер и поисковики определят, что его имя 'ivan.png'.

    7) О важности имени изображения для SEO
      - Имя отдаваемого изображения должно отражать его содержание.
      - Если изображён iPhone6 16gb white, то имя должно быть такое:
          'iphone6_16gb_white.jpg'

    8) Каким веб-сервером лучше отдавать изображения?
      - ngnix

    9) Как определять фильтры для изображений, и для чего они нужны?
      - Допустим, хотим мы ставить на изображения водяной знак.
      - Но не на все, а только на изображения товаров.
      - Тогда для всех изображений мы применяем фильтр 0 (отсутствует).
      - А когда отдаём картинки товаров, применяем фильтр, скажем, 1.
      - Классы фильтров можно определять в отдельной папке 'app/img_filters'.
      - А указывать соответствие ID и класса можно в отдельной таблице M5_filters.
      - Для её настройки можно сделать свой небольшой интерфейс.

    10) Сжатие
      - Можно сжимать все картинки при сохранении для сохранения места на жестком диске.
      - Добавить данный функционал следует по требованию (по необходимости).

    11) Сохранение нового ресурса
      - В M5_resources создаётся новая запись о ресурсе-изображении.
      - Она получает уникальный ID.
      - Файл-изображение сохраняется в каталог ресурсов, указанный в настройках, с именем [id].
      - Настоящее имя файла-изображения сохраняется в колонке name в M5_resources.

    12) Как сервер ресурсов осуществляет доступ к ресурсу
      - Для получения изображения-ресурса нужно знать лишь его id.
      - Поступает запрос: http://img.grumart.ru/200x200/1/55/ivan.png
      - Сервер извлекает ID ресурса: 55.
      - Сервер из M5_settings извлекает путь к папке с ресурсами (относ.public).
      - Сервер из этой папки по ID извлекает нужный ресурс R.
      - Сервер применяет к нему операцию fit(), и получает изображение 200x200.
      - Сервер применяет к нему фильтр 1 (допустим, проставляет водяной знак).
      - Сервер извлекает MIME-тип ресурса.
      - Из MIME-типа он извлекает расширение изображения.
        - Оно должно быть одно из: jpg / png / gif / tif / bmp / ICO.
        - Причем, в нижнем регистре.
        - Если нет, то по умолчанию применяется расширение jpg
      - Сервер кодирует изображение в найденном формате, в качестве 90, командой encode().
      - Сервер возвращает ресурс клиенту функцией response()

      *Примечание:
        - Обратите внимание, что к таблице M5_resources сервер не обращался.
        - Эта таблица нужна лишь для ручного просмотра и редактирования ресурсов.
        - .. через специальный интерфейс. Не более.

  > Фронт работ: содержание меню 'М5. Ресурсы'

    # Структура меню

      | - 'М5. Ресурсы'
      |
      |   - Настройки
      |   - Все ресурсы
      |   - Фильтры
      |


  > Фронт работ: серверная часть на поддомене img.grumart.ru

    1) Написать серверную часть
      - Она должна принимать запросы в духе вышеописанного GET API.
      - Извлекать из URI переданную в данных запросах информацию.
      - Обрабатывать их, и возвращать соотвутствующий ресурс.
      - Или, если ресурс не найден, или формат не верный, возвращает соответствующее изображение-заменитель.

    2) Повесить данную серверную часть на роут 'img.grumart.ru'
      - Добавить этот поддомен в Dog Any.
      - Позаботиться о том, чтобы URI-параметры передавались в REST-контроллеры.

    3) Добавить поддомен img.grumart.ru в настройках интернет-сервера.
      - Иначе веб-сервер не будет обрабатывать запрос к нему.


А22. Получить массив имён столбцов в таблице

    $list = Schema::getColumnListing('table_name');


А23. Создание библиотек функций, доступных в любом месте Laravel

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Пошаговая инструкция

  --------------------------------------

  > Ссылки

      - Ответ на stackoverflow, в которо описана тема:
          http://stackoverflow.com/questions/25695408/laravel-4-2-include-a-php-file-library-into-controller

  > Введение
    - Хотелось бы иметь общую библиотеку функций.
    - Которая доступна откуда угодно в Laravel. В том числе, из любого контроллера.
    - В этой главе будет описано, как это реализовать.

  > Пошаговая инструкция

    1) Создать в /app каталог, в котором будем держать библиотеки
      - Например: /app/libraries

    2) В composer.json проекта включить этот каталог
      - В autoload -> classmap, вот так:

        ...
        "autoload": {
          "classmap": [
            ...
            "app/libraries",
            ...

    3) Выполнить dump-autoload, чтобы композер схавал новую связь
      - Перейти в каталог с laravel.
      - Выполнить:

          php ../composer.phar dump-autoload

    4) Создать в /app/libraries файл, в котором будет лежать класс-библиотека

      /app/libraries/MyGlobalLibrary.php
      -------------------------------------

        // зададим пространство имён, в котором будет лежать наш класс
        namespace libraries;

        // Собственно, сам класс-библиотека
        class myClass {

          // 1. Первая фукнция класса
          public function some_func1() {

              // ...

          }

          // 2. Вторая фукнция класса
          public function some_func2() {

              // ...

          }

        }

    5) Теперь получить доступ к библиотеке можно из любого места в Laravel
      - Для этого достаточно создать экземпляр этого класса.
      - Вот так:

          $lib = new \libraries\MyGlobalLibrary();

    6) Можно задать псевдоним библиотеке, чтобы было удобнее
      - Для этого заходим в /app/config/app.php
      - И там, в массиве 'aliases', задаем псевдоним:

          'aliases' => array(
              ...
              'MyGlobalLibrary'   => 'libraries\MyGlobalLibrary',
              ...
          )

      - Здесь не помешает опять запустить dump-autoload.
      - Теперь можно получить экземпляр библиотеки покороче:

          $lib = new MyGlobalLibrary();


А24. Использование библиотек функций для расшаривания кода между контроллерами

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Архитектура решения
    - Основные принципы

  --------------------------------------

  > Ссылки

      - В этой статье см. подзаголовок "How to reuse code across controllers":
          http://tech.knolskape.com/10-quick-tips-to-get-better-at-laravel/

  > Введение
    - Часто 1 и тот же функцинал требуется использовать в разных контроллерах.
    - Например: сохранить загруженное изображение на сервер изображений.
    - Каким образом это можно реализовать? Есть 2 пути:

      1) Запрос метода 1-го контроллера из метода 2-го контроллера
        - Этот путь профессионалы не рекомендуют.
        - Это создаст сеть трудно-отслеживаемых связей между контроллерами.
        - В то время, как задача контроллера - принять запрос, обработать и отдать.

      2) Хранить такой код в общедоступных библиотех
        - К таким библиотекам должно быть можно обратиться из любого контроллера.
        - Именно этот способ и рекомендуется использовать.

  > Архитектура решения

      ----------------
      | Контроллер 1 |<------
      ----------------      |
                            |
      ----------------      |
      | Контроллер 2 |<-----|        ----------------------------
      ----------------      |------- | Общедоступные библиотеки |
                            |        ----------------------------
             ...            |
                            |
      ----------------      |
      | Контроллер N |<------
      ----------------

  > Основные принципы

    # Весь код, требующийся в >= 2 контроллерах, помещать в общедоступную библиотеку
      - Тогда этот код можно будет многокрано использовать в разных контроллерах.
      - Но не следует засорять общедоступные библиотеки не "многократно используемым" кодом.

    # Лучше набор тематических библиотек, вместо 1 гигантской
      - Представим, что весь многократно используемы код мы размещаем в гигантской по размеру библиотеке.
      - И нам нужна одна маааленькая функция из этой библиотеки в контроллере А.
      - И чтобы её получить, нам надо создать экземпляр класса этой библиотеки.
      - А если она гигантская, это то будет занимать время и оперативную память.
      - Поэтому, лучше создавать набор тематических библиотек, чем одну гигантскую.
      - А к этому набору приложить оглавление.


А25. Как передавать данные с сервера в layout-представление

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Суть проблемы
    - Решение: view composers

  --------------------------------------

  > Ссылки

      - В этом обсуждении на stackoverflow содержится суть вопроса:
          http://stackoverflow.com/questions/19428212/cant-pass-data-from-controller-to-blade-template-laravel

  > Суть проблемы

    # Blade
      - В Laravel есть технология шаблонизации под названием Blade.
      - Она подробно описана в пункте: "А2. Шаблонизация через blade".

    # Документ-шаблон (layout) и использующие его документы
      - В шаблонизации участвуют 2 сорта документов, указанных выше.
      - Один и тот же layout могут использовать много документов-детей.

    # Как происходит запрос документа
      - Пользователь вводит URL документв в стркоу браузера.
      - Запрос поступает на сервер, происходит динамический роутинг.
      - Запрос попадает в соответствующий контроллер.
      - Контроллер возвращает представление ДОЧЕРНЕГО ДОКУМЕНТА.

    # Передача данных документа-шаблону
      - Как было указано, 1 layout могут использовать много документов-детей.
      - А в 99% случаев в layout тоже надо передавать какие-то данные с сервера.
      - Представим, что у нас есть 20 документов по 20-ти разным URL.
      - Все эти документы используют один и тот же layout.
      - Неужели, в каждом случае, для передачи данных в layout, нужно добавлять 1 и тот же код во все 20 контроллеров?

    # Иллюстрация проблемы
      - Ключевым моментом на схеме является передача данных.
      - Как видно, данные от n-го контроллера передаются n-му документу.
      - Но ведь кое-какие данные надо в каждому n-ом случае передавать и шаблону.
      - Причём, в каждом n-ом случае, это одни и те же данные.
      - Неужели надо эти, одни и те же данные, передавать шаблону в каждом n-ом контроллере?
      - Конечно нет. Решение приведено ниже.

                                ------------
                                Пользователь
                                ------------
                                     || url
                                   ------
                                   Сервер
                                   ------
                                     ||
               ------------------------------------------------
               |              |              |                |
         ------------   ------------   ------------      ------------
         Контроллер 1   Контроллер 2   Контроллер 3  ..  Контроллер n
         ------------   ------------   ------------      ------------
              | данные       | данные       | данные         | данные
         ----------     ----------     ----------        ----------
         Документ 1     Документ 2     Документ 3        Документ n
         ----------     ----------     ----------        ----------
              .              .              .                 .
           ....................................................
           .
           .
        ------
        Шаблон
        ------

  > Пошаговая инструкция

    *Примечание:
      - Технология view composers подробно описана в
          "6.  Выходы, views, редиректы" -> "View Composers"

    1. Создать файл app/composers.php
      - Пример того, как он должен выглядеть:

          app/composers.php
          -------------------------
          <?php

            // 1. Композер для шаблона "layouts.l1_layout_forlk"
            View::composer('layouts.l1_layout_forlk', function($view) {

              $data = M1_routes::all();
              $view->with('xxxyyy', json_encode($data, JSON_UNESCAPED_UNICODE));

            });

            // 2. Композер для всех представлений
            View::composer('*', function($view) {

              $view->with('xxx', 123);

            });

          ?>

    2. Добавить composers.php в app/start/global.php
      - В результате чего он будет исполняться при каждом старте приложения.
      - В конец файла добавить строчку:

          require app_path().'/composers.php';


А26. Как сохранять/извлекать строки с HTML в/из БД

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Связь HTML и Unicode
    - Сохранение HTML в БД в кодировке UTF-8
    - Извлечение HTML из БД из кодировки UTF-8

  --------------------------------------

  > Ссылки

      - Справка по PHP-функции strip_tags (удалить все теги, кроме указанных):
          http://php.net/manual/en/function.strip-tags.php

      - Как удалить конкретные указанные теги (чего strip_tags не умеет):
          http://blog.tatedavies.com/2012/11/23/php-strip-certain-tags-with-strip_tags/

      - Справка по PHP-функции htmlspecialchars (преобразует спец.символы в HTML-сущности):
          http://php.net/manual/ru/function.htmlspecialchars.php

      - Справка по PHP-функции htmlspecialchars_decode (преобразует HTML-сущности в спец.символы):
          http://php.net/manual/ru/function.htmlspecialchars-decode.php

      - Статья про связь HTML с Unicode на wiki:
          http://en.wikipedia.org/wiki/Unicode_and_HTML

      - Статья про то, что такое графемы, на wiki:
          http://en.wikipedia.org/wiki/Grapheme

      - Статья про Unicode в wiki:
          http://en.wikipedia.org/wiki/Unicode

  > Введение
    - Часто требуется сохранить строку с HTML-кодом в базу данных.
    - Либо наоборот, извлечь строку с HTML-кодом из базы данных.
    - Хранение HTML-кода в БД представляет угрозу для безопасности.
    - В этой главе описано, как безопасно хранить HTML-код в БД.

  > Связь HTML и Unicode

    > Что такое графема
      - Минимальная единица в письменной системе языка.
      - В нашем случае, под "языком" выступает HTML.

    > HTML-документ на фундаментальном уровне состоит из графем
      - Эти графемы не зависят от способов хранения или передачи.
      - То есть, их (графем) смысл не зависит от этих факторов.

    > HTML-документ, фактически, является набором Unicode-символов
      - Он должен состоять из символов, имеющихся в HTML charset (наборе символов HTML).
      - Каждому символу в этом наборе присвоен уникальный положительный целый числовой код.
      - HTML charset определяется в стандарте HTML DTD.
      - Также в нём определён синтаксис (последовательности символов) для формирования валидного HTML-кода.
      - HTML charset состоит преимущественно из символов, определённых в Unicode.

    > В каком виде HTML сохраняетс в ФС / передаётся по сети
      - Как мы уже выяснили, html-документ это набор unicode-символов.
      - А набор символов можно сохранить в ФС с использованием какой-либо кодировки.
      - Поэтому, при сохранении, каждый символ html-документа кодируется в соотв. с используемой кодировкой.

    > Что происходит, если используемая кодировка не поддерживает символ в HTML-документе
      - Например, кодировка UTF-8 полностью поддерживает все Unicode-символы.
      - Поэтому весь HTML-код можно сохранить в ФС с кодировкой UTF-8 в неизменном виде.
      - Например, можно без проблем сохранить вот такую стоку:

          <html><b>Иван Петров</b></html>

      - Но есть кодировки, которые поддерживают не все Unicode-символы.
      - Например, кодировка Windows-1251 не поддерживает символ ☺.
      - Что произойдёт, если мы попытаемся сохранить такую строку:

          <html><b>Иван Петров ☺</b></html>

      - Т.К. символа ☺ нет в этой кодировке, он будет заменён на свой числовой код из HTML-charset.
      - В нашем случае, сохранённая строка будет выглядеть так:

          <html><b>Иван Петров &#x263A;</b></html>

    > Числовые коды символов в HTML charset

      > О числовых кодах
        - HTML-документ состоит из символов, имеющихся в HTML charset.
        - Каждому символу в этом наборе присвоен уникальный положительный целый числовой код.
        - Относительно недавно появилась поддержка этого кода в 16-ричном формате.
        - Используя этот код, можно отобразить любой символ из

      > Шаблон
        - Шаблон для отображения символов в документе таков: &#[код];
        - Допустим, требуется отобразить символ с кодом "263А".
        - Тогда в документ нужно поместить следующую конструкцию: &#263A;

      > Способ отобразить любой Unicode-символ в HTML-документе HTML charset в html-документе.
        - Сабж.

      > Способ сохранить HTML-код в ФС в кодировке, не поддерживающей символы в нём
        - Сабж.

    > Именованные символы в HTML charset (html-сущности)
      - В HTML есть 252 именованных числовых кода в HTML charset.
      - В этот набор входят некоторые часто используемые, или странные символы.
      - К ним можно обращаться не только по коду, но и по имени.
      - Шаблон: &[имя];
      - Скажем, вот конструкция для вывода пробела: &nbsp;

  > Сохранение HTML в БД в кодировке UTF-8

    > Суть
      - Сохранять следует без преобразования символов в их коды.
      - Поскольку в этом нет необходимости, UTF-8 поддерживает все Unicode-символы.
      - То есть, если надо сохранить следующую строку в БД:

          <html><b>Иван Петров</b></html>

      - То именно так она и должна выглядеть в таблице БД.

    > При передаче на сервер некоторые символы могут кодироваться
      - Обычно я передаю данные на сервер в формате json.
      - Кодирование я провожу с помощью knockoutjs-функции toJSON.
      - А она, судя по всему, кодирует некоторые символы в их HTML-коды.
      - Короче говоря, передаче такой строки:

          <html><b>Иван Петров</b></html>

      - На сервере я получаю:

          $str = &lt;html&gt;&lt;b&gt;Иван Петров&lt;/b&gt;&lt;/html&gt;

      - Чтобы с этим справиться, в php есть функция htmlspecialchars_decode.
      - После применения этой функции к $str мы получаем:

          htmlspecialchars_decode($str) == "<html><b>Иван Петров</b></html>";

      - И уже вот эту строку можно спокойно сохранить в БД.

  > Извлечение HTML из БД из кодировки UTF-8
    - Просто извлекаешь и передаёшь. Никаких трудностей тут не возникает.





А20. Проект Ч

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    -

  --------------------------------------

  > Ссылки
    -

  > Введение
    -




  Компании
    - Это компании, с которыми мы так или иначе работам.
    - Это могут быть наши поставшики, подрядчики и т.д.
    - Все они должны храниться в таблице компаний (ТК).
    - ТК должна содержать:
      - Общая информация о компании
      - Юр.адрес
      - Факт.адрес
      - Реквизиты
      - Контакты
      - ...
    - В ТК в том числе должна быть и наша собственная компания на 1-м месте.

  Источники товаров

    Концепция источников
      - Когда покупатель заказывает товар, этот товар ему откуда-то надо привезти.
      - Это либо один из своих складов, либо склад одного из поставщиков.
      - Введём сущность "источник", которая обозначает, откуда мы берём данный товар.
      - Для каждого товара в продаже должен быть известен его источник.
      - Возможно указать следующие значения для товара в качестве источника:

        # На заказ
          - Это заглушка. Значит, товара нет.
          - "Нет" указывать не эффективно, лучше пусь поль-ль проявит интересь.
          - Так хоть мы будем узнавать, какой на этот товар есть спрос.

        # Есть
          - Это заглушка. Значит, товар есть, но неизвестно откуда.
          - Значение себестоимости берётся из таблицы товаров.
          - Остатки не учитываются, считается, что товар всегда есть.
          - В качестве адреса склада используется г.Москва.
          - Применяется для тестов, и как упрощённый вариант для работы.

        # [Конкнетный склад конкретной компании]
          - Сабж.
          - Значение себестоимости берётся из таблицы источника.
          - Остатки синхронизируются с таблицей источника.
          - Адресом служит адрес данного склада.
          - Именно этот вариант должен применяться в 99% случаев.

    Таблица источников (ТИ)
      - Содержит список всех источников (по факту - складов), которые мы когда-либо использовали.
      - ТИ должна содержать:
        - id компании, которой принадлежит
        - Текстовое описание
        - Контакты
        - Адрес
        - Время работы
        - Статус (используется, не используется)
      - Для каждой записи в ТИ создаётся таблица синхронизации с источником.
      - Данные для таблиц источников берутся у каждой компании и перерабатываются индивидуально.

    Таблица синхронизации с источником (ТСИ)
      - В конце имени имеет "_[id компании]_[id источника]".
      - Может содержать только те же товары, что содержит M4_goods.
      - Товары в ТСИ - это проекции товаров из M4_goods, они связаны через ID.
      - ТСИ автоматически наполняется товарами из M4_goods.
      - Товары могут лишь добавляться в ТСИ, и никогда не могут удаляться (только админом).
      - Периодически должно происходить добавление новых товаров из M4_goods в ТСИ.
      - ТСИ содержит инфу по остаткам и себестоимости товаров.

    Управление источниками товаров происходит через политику
      - Политика источников (ПИ)
      - Есть отдельный вид политики для управления источниками.
      - По умолчанию на все товары действует ПИ "На заказ".
      - Таким образом мы избегаем ситуации, когда товара нет, а написано, что есть.


Б1. NGINX: как организовать мгновенную загрузку N картинок в документе

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Изменение размеров картинок "на лету"
    - Ускорение работы с ImageMagic с помощью кэширования в приложении (Image::cache)
    - Кардинальное ускорение сервера изображений спомощью кэширования ответов на веб-сервере NGINX
    - Рекомендации по аппаратной части для сервера изображений
    - Автопомещение всех изображений приложения в кэш: робот и cron

  --------------------------------------

  > Ссылки

    # Соответствующая статья на habr
      http://habrahabr.ru/company/mkechinov/blog/105716/


  > Введение
    - Часто бывает, что в 1 документе надо мгновенно загрузить N картинок.
    - Особенно это актуально для интернет-магазинов.
    - Например, в каталоге интернет-магазина может понадобиться загрузить сразу 30 картинок.
    - Ведь клиент не будет ждать, если всё будет происходить медленно.


  > Изменение размеров картинок "на лету" с помощью ImageMagic
    - Есть такой функционал, который называется ImageMagic.
    - Его можно интегрировать с Laravel, установив соответствующий пакет.
    - Допустим, у нас есть 1 большое изображение товара, размером 1000x1000 px.
    - А в разных местах на сайте нам требуется разные размеры этого изображения.
    - Скажем: 50x50, 100x100, 150x150, 1000x1000.
    - Заранее сохранять в ФС все эти изображения было бы не выгодно:
      1) Потому что, если тянуть всё с HDD, будет большая нагрузка на него.
      2) Это будет очень медленно.
      3) Будет занимать много места на HDD.
    - Более оптимальный путь, изменять размер картинки "на лету", и возвращать результат.
    - Минусы такого подхода:
      1) Операции с картинками требуют много ресурсов компьютера.
      2) Они происходят достаточно медленно.


  > Ускорение работы с ImageMagic с помощью кэширования в приложении (Image::cache)
    - ImageMagic имеет встроенный функционал кэширования результатов.
    - Он находится в отедльном пакете, и его можно задействовать так: Image::cache(...)
    - Он кэширует результаты работы ImageMagic.
    - И при их запросе в след.раз проверяет, есть ли они в кэше.
    - Если есть, то отдаёт их из кэша, а не выполняет операцию снова.
    - Плюсы:
      1) Это заметно ускоряет выгрузку изображений на сайте. Однако, её всё ещё нельзя назвать мгновенной.
        - Дело в том, что запрос всё ещё должен пройти через весь вреймворк Laravel, всё приложение.
        - А это занимает существенное время, и существенные ресурсы.
        - Ведь происходит подгрузка всех ресурсов фреймворка, выполнение большого числа кода.
        - И когда приходит одновременно N запросов картинок, это загружает сервер по полной.
        - Что ещё больше замедляет исполнение каждого из этих N запросов.
    - Минусы:
      1) Кэш занимает место в оперативной памяти.

      ВЫВОДЫ: 

        1. Лучше отключить этот функционал, чтобы не жрал оперативную памят.
        2. Вместо его использования, лучше кэшировать запросы с изображениями в nginx.
        3. Чтобы 1-му пользователю не ждать загрузку, использовать робота и cron
          - Проблема в том, чтобы изображение попало в кэш, его кто-то должен 1 раз запросить.
          - При 1 запросе работает ImageMagic, и достаточно медленно.
          - Если это будет делать клиент, он, возможно, не будет ждать и уйдёт. Потеря.
          - Поэтому, лучше, чтобы это делал наш робот, по расписанию, ночью.
          - Т.Е. кэш по плану должен истекать где-нибудь в 4 утра МСК.
          - И сразу же, в этот момент, робот должен обходить все изображения приложения.


  > Кардинальное ускорение сервера изображений спомощью кэширования ответов на веб-сервере NGINX
    - Исходя из предыдущего абзаца, мы приходим к следующему выводу.
    - Для кардинального ускорения необходимо исключить прохождение запроса через приложение.
    - То есть, надо кэшировать изображения на самом веб-сервере NGINX.
    - И когда поступает запрос на изображение, сразу же возвращать его из кэша NGINX'а.
    - Не давая ему пройти дальше, в "медленное" приложение.
    - В итоге, скорость получения изображения будет сравнима с извлечением из оперативной памяти на локальном компьютере.
    - И даже 100, 1000 и т.д. изображений будут отображаться в документе мгновенно при его загрузке.
    - Но, есть и ограничение:
    
      1) Это скорость интернета и ширина его канала у клиента
        - Ведь все эти изображения клиент всё равно должен подгрузить.
        - Однако, в настоящее время большинство имеет высокоскоростной интернет.
        - К слову, в кэше в основном будут храниться маленькие картинки ~10kb.
        - Значит:

            100 картинок        ~ 1 mb 
            1 000 картинок      ~ 10 mb
            10 000 картинок     ~ 100 mb
            100 000 картинок    ~ 1 gb.

        - Ширина обычного интернет-канала составляет 10 мегабит/сек.
        - 1 мегабит составляет 125 kb, итого, 10 мегабит/сек = 1.25 mb/сек
        - Вывод: ~125 картинок размером 10 kb будут подгружаться мгновенно.


  > Рекомендации по аппаратной части для сервера изображений

   # Пропускная способность интернета 1 гигабит/сек
     - Это позволит отдавать ~125000 / 300 = 416 пользователям по 30 картинок каждую секунду.

   # Количество оперативной памяти
     - Зависит от следующих параметров:

       Кол-во товарных позицией                         # goods
       Среднее кол-во картинок для каждой тов.позиции   # avg_imgs_num
       Средний вес закэшированных картинок              # imgs_avg_weight
       Требуемое кол-во размеров каждой из картинок     # imgs_sizes_num

     - Рассмотрим несколько вариантов.
     - Результатом будет вердикт, скольк оперативной памяти нужно для каждого из рассмотренных вариантов.


        goods       avg_imgs_num    imgs_avg_weight, kb    imgs_sizes_num    памяти нужно, gb
        -------------------------------------------------------------------------------------
        1 000       3               10                     10                0.3
        10 000      3               10                     10                3
        100 000     3               10                     10                30
        1 000 000   3               10                     10                300


  > Автопомещение всех изображений приложения в кэш: робот и cron
    
    Суть
    ----
      - Проблема в том, чтобы изображение попало в кэш, его кто-то должен 1 раз запросить.
      - При 1 запросе работает ImageMagic, и достаточно медленно.
      - Если это будет делать клиент, он, возможно, не будет ждать и уйдёт. Потеря.
      - Поэтому, лучше, чтобы это делал наш робот, по расписанию, ночью.
      - Т.Е. кэш по плану должен истекать где-нибудь в 4 утра МСК.
      - И сразу же, в этот момент, робот должен обходить все изображения приложения.

    Как запускать робота
    --------------------
      - Надо использовать Cron и Laravel Scheduler.
      - Cron создаёт тики каждую минуту в Laravel Scheduler.
      - Мы создаём задание и помещаем его в Scheduler.
      - Задание знает дату и время, когда истекает кэш изображений.
      - И с каждым тиком проверяет, не наступил ли час "Х".
      - Если наступил, то он пробегает все изображения сервера изображений.
      - Причём, каждое изображение во всех используемых сервером размерах.
      - В результате, все ответы на запросы кэшируются NGINX'ом.
      - И когда клиент теперь будет работать с приложением, изображения будут отдаваться мгновенно.


Б2. Доступ к классам в L5 с учётом перехода на PSR-4

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Про PSR-4

      - Про PSR-4: общее
      - Про PSR-4: 4 основных понятия
      - Про PSR-4: примеры работы

    - Фасады: проблема и решения

      - В чём проблема с доступом к фасадам в L5?
      - Способы получить доступ к фасадам в L5 не из глоб.пр.имён

          1. Абсолютный путь к псевдониму
          2. Абсолютный путь к фасаду
          3. Импортирование псевдонима с помощью use
          4. Импортирование фасада с помощью use

  --------------------------------------

  > Ссылки

    # Стандарт PSR-4
        http://www.php-fig.org/psr/psr-4/ru/

    # Битва стандартов: PSR-0 против PSR-4
        http://zenwalker.me/blog/php-psr-0-vs-psr-4.html

    # Хм, psr? (статья на ruseller.com)
        http://ruseller.com/lessons.php?rub=37&id=1803


  > Введение
    - Laravel 4 реализовывал стандарт PSR-0.
    - А Laravel 5 реализует стандарт PSR-4.
    - В связи с этим несколько изменился способ доступа к классам.
    - В этой главе раскрывается данная тема.


  > Про PSR-4
    
    Про PSR-4: общее
    ----------------
      - В 2009 году на конференции http://tek.phparch.com/ собрались заинтересованные лица.
      - Они решили выработать некие стандарты кодирования на PHP, и объединились в рабочую группу.
      - Эта группа теперь называется Framework Interoperability Group (FIG).
      - Один из стандартов - PSR-4:

          "Данный PSR описывает спецификацию для автозагрузки классов 
           на основе путей файлов. Она полностью взаимозаменяема и может 
           пользоваться в дополнение к любой другой спецификации 
           автозагрузчика, включая PSR-0. Данный PSR также описывает, 
           где размещать файлы, которые будут загружаться в соответствии 
           со спецификацией." - цитата с оф.сайта FIG

    Про PSR-4: 4 основных понятия
    -----------------------------
      1. Абсолютное имя класса
        - По этому имени можно получить доступ к классу.
        - Из любого места в коде.
        - Это как абсолютный путь к файлу в файловой системе.

      2. Префикс пространства имён
        - Пространство имён, в котором находится класс.
        - Можно написать: use [пространство имён]
        - И тогда доступ к классу в нём можно получить просто по имени.

      3. Базовый каталог
        - Это корневой каталог для всех пространств имён.

      4. Путь к файлу
        - Итоговый путь к классу с учётом баз.кат. и префикса пр.имён.

    Про PSR-4: примеры работы
    -------------------------

      Пример 1
      --------
        1. \Acme\Log\Writer\File_Writer
        2.  Acme\Log\Writer
        3. ./acme-log-writer/lib/
        4. ./acme-log-writer/lib/File_Writer.php

      Пример 2
      --------
        1. \Aura\Web\Response\Status
        2.  Aura\Web
        3. /path/to/aura-web/src/
        4. /path/to/aura-web/src/Response/Status.php

      Пример 3
      --------
        1. \Symfony\Core\Request
        2.  Symfony\Core
        3. ./vendor/Symfony/Core/
        4. ./vendor/Symfony/Core/Request.php

      Пример 4
      --------
        1. \Illuminate\Support\Facades\Request
        2. \
        3. C:\WebDev\projects\zaste.ru\vendor\laravel\framework\src
        4. C:\WebDev\projects\zaste.ru\vendor\laravel\framework\src\Illuminate\Support\Facades\Request.php

  > Фасады: проблема и решения

    В чём проблема с доступом к фасадам в L5?
    -----------------------------------------
      - В файле config/app.php есть массив aliases.
      - В этом массиве перечислены псевдонимы для фасадов.
      - То есть, доступ к фасаду можно получить по имени-псевдониму.
      - Но эти имена-псевдонимы находятся в глобальном пр.имён.
      - Следовательно, из кода, который находится не в глобальном
        пространстве имён, получить доступ к фасаду через псевдоним,
        просто написав его имя в "относительном" стиле, не получится.
      - Пример:

        - Рассмотрим псевдоним View.
        - Вот он определён в app.php:

            config/app.php
            --------------
              'aliases' => [
                ...
                'View'      => 'Illuminate\Support\Facades\View',
                ...
              ]

        - Допустим, мы находимся в коде в глоб.пр.имён.
        - Тогда доступ к View можно получить так:

            View::make(...);                   

        - Теперь допустим, мы находимся в коде НЕ в глоб.пр.имён.
        - Но ведь View то у нас лежит в глоб пр.имён.
        - Поэтому, как в примере выше, доступ к View мы не получим.

    Способы получить доступ к фасадам в L5 не из глоб.пр.имён
    ---------------------------------------------------------

      1. Абсолютный путь к псевдониму
      -------------------------------
        - В массиве aliases в config/app.php определены псевдонимы для фасадов.
        - Все они определены и доступны в глобальном пр.имён.
        - Доступ к ним откуда угодно можно получить, указав абсолютный путь.
        - Например:

            \View::make(...);

      2. Абсолютный путь к фасаду
      ---------------------------
        - Можно вообще не использовать псевдонимы фасадов.
        - И обращаться к фасадам напрямую, используя абсолютный путь.
        - Например:

            Illuminate\Support\Facades\View::make(...);

      3. Импортирование псевдонима с помощью use
      ------------------------------------------
        - Можно импортировать псевдоним фасада из глоб.пр.имён в текущее.
        - Тогда не придётся использ.абс.путь для доступа к фасаду.      
        - Пример:

            // Импортируем псевдоним из глоб.пр.имён
            use View;

            // Имеем доступ к нему по относительному пути
            View::make(...);

      4. Импортирование фасада с помощью use
      --------------------------------------
        - Можно импортировать не псевдоним, а сам фасад.
        - Но тогда придётся обращаться к нему по имени фасада, а не псевдонима.
        - Например, у фасада Model имя псевдонима Eloquent. Это надо иметь в виду.
        - Пример:

             // Импортируем класс-фасад, используя абс.путь
            use Illuminate\Support\Facades\View;

            // Имеем доступ к нему по относительному пути
            View::make(...);         


Б3. Организация модульного приложения на основе Laravel 5.1

  --------------------------------------
  Подоглавление:

    Вводная информация
    ------------------

      # Ссылки
      # Введение
      # Общий взгляд на всю картину


    Прикладная информация
    ---------------------

      # Преобразование оригинального Laravel 5.1 в модульное приложение [TODO: доработать]
      # Установка нового экземпляра модульного Laravel 5.1 [TODO: доработать]
      # Поддержка общего пакета с ресурсами для всех модулей 

      # Подготовка нового административного домена
      # Подготовка нового клиентского домена

      # Подготовка нового модуля к разработке
      # Оформление готового модуля, как пакета composer
      # Подключение и отключение модуля
      # Обновление установленного модуля
      # Изменение структуры БД модуля

      # Добавление/Удаление административного документа
      # Добавление/Удаление клиентского документа
      # Добавление/Удаление шаблона

      # Добавление/Удаление модели модуля
      # Добавление/Удаление контракта модуля

      # Добавление/Удаление команды админ.документа
      # Добавление/Удаление artisan-команды админ.документа
      # Добавление/Удаление события админ.документа
      # Добавление/Удаление обработчика события админ.документа


    Наработки и примечания
    ----------------------

      # Как изменить базу данных по умолчанию для текущего запроса
      # Как сделать реверс-инжениринг БД модуля в миграцию Laravel 5.1
      # Обсуждение модулей для обслуживания модульного приложения
   

  --------------------------------------

  > Ссылки

    # Поддерживаемые на данный момент типы пакетов Composer
        https://github.com/composer/installers#current-supported-types

    # Установка пакета Composer в любой каталог проекта
        https://getcomposer.org/doc/faqs/how-do-i-install-a-package-to-a-custom-path-for-my-framework.md

    # GitHub
        https://github.com/

    # Packagist
        https://packagist.org/

    # Готовые решения организации модульных приложений для Laravel 5, 4:
      http://sky.pingpong-labs.com/docs/2.0/modules
        https://github.com/creolab/laravel-modules

    # Использование частных репозиториев для модулей
        https://getcomposer.org/doc/05-repositories.md#using-private-repositories


  > Введение
    - Рассматриваем организацию модульного приложения на основе Laravel 5.1.

    
  > Общий взгляд на всю картину



                                                           ////===========================////
                                                           ////                           ////
                                                           ////   Модульное приложение    ////
                                                           ////   на основе Laravel 5.1   ////
                                                           ////                           ////
                                                           ////===========================////
                                                             //                           //
                                                             //         Оглавление        //
                                                             //                           //
//======================================================================================================================================================//

  - Domain Driven Design                                                      - Клиентская часть
  - Административная и клиентская части                                       - Межмодульное взаимодействие
  - Административная часть                                                    - Роутинг
  - Модифицированный Laravel 5.1, как базовое приложение и отдельный пакет    - Публичные ресурсы модулей
  - Модуль "Управление модульным приложением"                                 - Механизм автоматической публикации всех публичных ресурсов
  - Модуль "Центральная система журналирования"                               - Не публичные, частные репозитории для модулей
  - Определение модуля                                                        - Отдельная база данных для каждого модуля, схема БД модуля
  - Определение модульного приложения                                         - Шаблоны представлений - такие же потребители, как документы клиентской части
                                                                              - Концепция: один контроллер - один документ
                                                                              - Административные документы
                                                                              - Клиентские документы

//======================================================================================================================================================//
                                                             //                           //
                                                             //         Содержание        //
                                                             //                           //
                                                             //===========================//
                                                                           |
                                                                           |
                                                                           |
====================                                                       |    ================
Domain Driven Design ------------------------------------------------------|--- Клиентская часть
====================                                                       |    ================
  - Используется Domain Driven Design (DDD).                               |      - Клиентские домены не обладают модульной структурой.
                                                                           |      - Клиентские домены содержат документы клиентской части приложения.
===================================                                        |      - Эти документы являются потребителями модулей из админ.части.
Административная и клиентская части ---------------------------------------|      - Они жестко зависят от соотв.модулей и других ресурсов.
===================================                                        |      - И если соотв.модуль и ресурс удалить, перестают правильно работать.
  - Домены могут быть административные / клиентские                        |
                                                                           |    ===========================
======================                                                     |--- Межмодульное взаимодействие
Административная часть ----------------------------------------------------|    ===========================
======================                                                     |      - Только через события.
                                                                           |      - Один модуль возбуждает событие.
  # Не связанные модули                                                    |      - Заинтересованные модули могут ловить это событие.
    - Административные домены состоят из модулей.                          |      - Реализуется сценарий "беспрепятственной" работы.
    - Модули независимы друг от друга, не связаны друг с другом.           |      - То есть, если никто событие не поймал, ничего не должно ломаться.
    - При удалении одного модуля, на остальные это никак не влияет.        |
                                                                           |    =======
  # Модули, как пакеты                                                     |--- Роутинг
    - Модули устанавливаются в приложение, как пакеты композера.           |    =======
    - В качестве удалённого репозитория для модулей используется github.   |      - Реализуется отдельным соответствующим модулем.
    - Предпочтительно хранить модули в приватном, а не публичном           |      - Который содержит .php файл, который инклюдится в routes.php приложения.
      репозитории.                                                         |
                                                                           |    =========================
  # Управление версиями модулей                                            |--- Публичные ресурсы модулей
    - Управление версиями модулей производится с помощью git.              |    =========================
                                                                           |      - Находятся в каталоге Public в каталоге модуля.
  # Возможность установки пакета в любой каталог                           |      - Публикуются в Public проекта командой vendor:publish
    - Пакет с модулем устанавливается в каталог нужного админ.домена.      |
                                                                           |    ==========================================================
  # Зависимости модулей                                                    |--- Механизм автоматической публикации всех публичных ресурсов
    - Модули могут иметь зависимости, которые прописываются                |    ==========================================================
      в composer.json модуля.                                              |      - Все публичные ресурсы публикуются при каждом HTTP-запросе.
    - Все модули имеют min 1 зависимость, в виде пакета с                  |      - Удобен в период активной разработки.
      общими ресурсами.                                                    |      - Имеет конфигурацию в config/autopublish.php
    - Зависимости модуля устанавливаются на уровне проекта                 |      - Вкл / Выкл из .env, с помощью свойства RES_AUTOPUBLISH (0 / 1)
      при установке самого модуля.                                         |      - Не должен использоваться в продакшн, иначе сервер сразу ляжет.
                                                                           |
  # Шаблон для административной части                                      |    =============================================
    - Все представления модулей связаны с шаблоном Backoffice.             |--- Не публичные, частные репозитории для модулей
                                                                           |    =============================================
======================================================================     |      - Модули не должны быть в публичном доступе, как частная собственность.
Модифицированный Laravel 5.1, как базовое приложение и отдельный пакет ----|      - Для них следует использовать частные репозитории (скажем, на github).
======================================================================     |
  - Laravel 5.1 для нужд модульного приложения д.б. немного модифицирован. |    =========================================================
  - Такую модифицированную версию нужно иметь в отдельном репозитории.     |--- Отдельная база данных для каждого модуля, схема БД модуля
  - Чтобы потом, при создании нового приложения, использовать.             |    =========================================================
  - Также, неплохо сразу прописать зависимости от нескольких модулей.      |      - Для каждого модуля удобно использовать отдельную БД.
  - Это некий набор модулей, которые должны быть в каждом приложении.      |      - Каждая такая БД может иметь имя, как id модуля.
                                                                           |      - В каталоге каждого модуля д.б. актуальная схема его БД.
=========================================                                  |      - Такую схему удобно строить с помощью MySQL Workbench.
Модуль "Управление модульным приложением" ---------------------------------|      - Когда модуль имеет отдельную БД, удобно проводить
=========================================                                  |        синхронизацию БД со схемой.
  - Парсит структуру модульного приложения в свою БД.                      |
  - Может делать это по расписанию, или по нажанию на кнопку.              |    ============================================================================
  - Отслеживает ошибки и потенциальные проблемы по каждому обновлению.     |--- Шаблоны представлений - такие же потребители, как документы клиентской части
  - Позволяет удобно просматривать структуру приложения,                   |    ============================================================================
    и даже кое-что редактировать (скажем, описания).                       |      - Шаблоны точно также могут зависеть от модулей.
  - Содержит статистику по всему модульному приложению.                    |      - И при удалении этих модулей, шаблоны ломаются.
                                                                           |      - А вообще шаблон состоит из:
===========================================                                |
Модуль "Центральная система журналирования" -------------------------------|          - Шаблон
===========================================                                |          - Композер
  - Предназначен для ведения лога по всему приложению.                     |          - Публичные ресурсы
  - Каждое сообщение имеет timestamp и теги.                               |
  - Имеет интерфейс с сортировкой и фильтрацией.                           |      - И публичные ресурсы шаблона также публикуются в Public проекта.
  - Функционал этого модуля используют все модули, и всё приложение.       |      - С помощью автоматической системы публикации публичных ресурсов.
  - Принимает сообщения через обработчик определённого события.            |
  - Которое находится в общем пакете с ресурсами для всех модулей.         |    ==========================================
  - Отправляются сообщения через хелпер, который в том же пакете.          |--- Концепция: один контроллер - один документ
  - Если модуль отсутствует, то хелпер просто ничего не отправляет.        |    ==========================================
  - В итоге, ничего нигде не ломается в случае отсутствия этого модуля.    |      - Все документы приложения следуют данной концепции.
  - Это нагляно демонстрирует взаимодействие модулей через события.        |      - Для обработки всех запросов документа используются т.н. Implicit Controller.
                                                                           |
==================                                                         |    ==========================
Определение модуля --------------------------------------------------------|--- Административные документы
==================                                                         |    ==========================
                                                                           |      - Один модуль может иметь много административных документов.
  Модуль - это:                                                            |      - Административными называют документы из модулей.
    - отдельное приложение со своей базой данных;                          |      - В отличие от клиентских документов, содержат такой функционал, как:
    - находящееся в отдельном репозитории;                                 |
    - версионностью которого управляет git по схеме Престона-Вернера;      |        # Команды
    - заточенное для использ-ия в модульном приложении опред.конфигурации; |        # Консольные команды
    - никак не зависящее от других модулей;                                |        # События
    - но могущее иметь зависимости от других пакетов (но не модулей);      |        # Обработчики событий
    - могущее взаимодействовать с другими модулями через события;          |
    - могущее быть установл. в мод. приложение как composer-зависимость.   |      - Контроллеры этих документов не могут прямо работать с другими модулями.
                                                                           |      - А могут взаимодействовать с ними лишь через события.
=================================                                          |      - И в случае отсутствия реакции на событие, они не должны ломаться.
Определение модульного приложения -----------------------------------------|      - Зато, они могут прямо работать с функционалом пакетов - не модулей.
=================================                                          |      - Но тогда, эти пакеты должны быть указаны, как зависимости, в composer.json модуля.
                                                                           |
  Модульное приложение - это:                                              |    ====================
    - root-приложение, служащее базой для интеграции в неё модулей;        |--- Клиентские документы
    - административная часть которого полностью состоит из модулей;        |    ====================
    - модули к которому подключаются, как зависимости с помощью composer;  |      - Должны находиться, как дети в каталогах клиентских доменов.
    - использующее функционал модулей для строительства клиентской части;  |      - Их контроллеры могут прямо работать с функционалом модулей.
    - обеспечивает базовую инфраструктуру для функц. и взаимод. модулей;   |      - Да и вообще, с любым функционалом, доступным в модульном приложении.
    - служащее как бы материнской платой для модулей.                      |      - В случае отключения подобного модуля, клиентский документ ломается.
                                                                           |      - Потому что он является лишь интерфейсом по отношению к модулям.
                                                                           |      - А интерфейс не может работать без того, что "должно быть под капотом".

  > Преобразование оригинального Laravel 5.1 в модульное приложение [TODO: доработать]

    ---------------------------------
    Подоглавление:

      - Введение
      - Пошаговая инструкция

    ---------------------------------

    > Введение
      - Оригинальный Laravel 5.1 изначально не является модульным приложением.
      - Чтобы сделать его таковым, требуется его несколько преобразовать.
      - В этом разделе приведён пошаговый процесс такоо преобразования.

    > Пошаговая инструкция

      1. Создать новый каталог app в корне приложения
        - Переименовать каталог app в _old_app.
        - И создать новый пустой каталог app в корне приложения.

      2. Подготовить образцы в app/DomainsSamples
        - Это образцы для административной и клиентской частей приложения.

      3. Подготовить образцы для шаблонов
        - Создать каталог app/Layouts/_sample
        - И в нём разместить образец шаблона.

      4. Изменить путь к Public
        - Создать каталог app/Public
        - Перенести в него всё из старого каталога Public.
        - Создать каталог app/Miscellaneous
        - В нем создать новый класс MyExtendedApplication.php
        - Этот класс должен наследовать от Illuminate\Foundation\Application.
        - В нём заменить метод publicPath:

            <?php namespace App;

              use Illuminate\Foundation\Application;
              class MyExtendedApplication extends Application
              {

                // Заменить путь к каталогу Public
                public function publicPath()
                {
                    return $this->basePath('app/Public');
                }

              }

        - В /bootstap/app.php:

          # Заменить это:

            $app = new Illuminate\Foundation\Application(
                realpath(__DIR__.'/../')
            );

          # На вот это:

            $app = new App\MyExtendedApplication(
                realpath(__DIR__.'/../')
            );

      5. Изменить путь к Storage
        - Переместить каталог storage из корня в app/Storage
        - В bootstrap/app.php добавить следующее (но не в конец):

            $app->useStoragePath(base_path('app/Storage'));

      6. Изменить путь к HTTP- и консольному ядрам

        # Http-ядро
          - Скопировать http-ядро:
              Из:   /_old_app/Http/Kernel.php
              В:    /app/HttpKernel.php
          - Заменить внутри namespace:
              С:    App\Http
              На:   App
          - Заменить внутри класса псевдоним:
              С:    use Illuminate\Foundation\Http\Kernel as HttpKernel;
              На:   use Illuminate\Foundation\Http\Kernel as HttpKernelSource;
          - Заменить внутри имя класса:
              С:    Kernel
              На:   HttpKernel
          - Заменить в /bootstrap/app.php путь к http-ядру:
              С:    App\Http\Kernel::class
              На:   ddd\HttpKernel::class

        # Консольное ядро
          - Скопировать консольное ядро:
              Из:   /_old_app/Console/Kernel.php
              В:    /app/ConsoleKernel.php
          - Заменить внутри namespace:
              С:    App\Console
              На:   App
          - Заменить внутри класса псевдоним:
              С:    use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
              На:   use Illuminate\Foundation\Console\Kernel as ConsoleKernelSource;
          - Заменить внутри имя класса:
              С:    Kernel
              На:   ConsoleKernel
          - Заменить в /bootstrap/app.php путь к http-ядру:
              С:    App\Console\Kernel::class
              На:   App\ConsoleKernel::class

      7. Создать каталог для общих сервис-провайдеров
        - Создать каталог app/Providers
        - Скопировать туда общие сервис провайдеры из _old_app/Providers.

      8. Изменить путь к routes.php
        - Скопировать routes.php
            Из:   /_old_app/Http/routes.php
            В:    /app/routes.php
        - В app/Providers/RouteServiceProvider.php изменить путь к routes.php:
            С:    app_path('Http/routes.php')
            На:   base_path('app/routes.php')

      9. Создать каталог для middleware
        - Создать каталог app/Middleware
        - Скопировать:
            Из:   _old_app/Http/Middleware
            В:    app/Middleware
        - Исправить во всех middleware пространства имён.
        - В app/HttpKernel.php исправить пути к этим middleware

      10. Создать каталог Exceptions
        - Скопировать каталог Exceptions
            Из:   _old_app/Exceptions
            В:    app/Exceptions

      11. Скопировать классы Controller, Event и Job
        - В Miscellaneous.

      12. Удалить старые public, storage, _old_app.


  > Установка нового экземпляра модульного Laravel 5.1 [TODO: доработать]

    ---------------------------------
    Подоглавление:

      - Введение
      - Пошаговая инструкция

    ---------------------------------

    > Введение
      - Здесь подробно описано, как установить модульное приложение.

    > Пошаговая инструкция


  > Поддержка общего пакета с ресурсами для всех модулей

    ---------------------------------
    Подоглавление:

      - Ссылки
      - Введение

    ---------------------------------

    > Ссылки

      # Удалённый публичный репозиторий пакета на github:
          https://github.com/4gekkman/CommonProjectsLib


    > Введение
      - Этот пакет предназначается для модульных приложений на основе Laravel.
      - Он содержит общие для всех модулей библиотеки ресурсов.
      - Подробную инструкцию см. в readme.md в репозитории пакета (ссылка выше).


  > Подготовка нового административного домена

    ---------------------------------
    Подоглавление:

      - Введение
      - Процесс подготовки административного домена

    ---------------------------------

    > Введение
      - Здесь описана подготовка нового административного домена к работе.

    > Процесс подготовки административного домена

      1. Скопировать каталог domain в app/domains
        - Каталог domain находится по адресу:
            app/DomainSamples/admin/domain

      2. Переименовать domain в настоящее имя домена
        - Но заменить точки . на подчеркивания _
        - Поскольку точки не могут присутствовать в именах классов.
        - Например, если имя домена: lk.zaste.ru
        - То надо переименовать domain в: lk_zaste_ru

      3. Удалить из каталога с доменом каталог module
        - Если, конечно, вы не собираетесь заодно и подготовить новый модуль.

      4. Настроить файл domain_info.json
        - Указать следующие значения:

          "protocol"    | Протокол, доступные значения: "http" / "https"
          "domain"      | Имя домена, например, "lk.zaste.ru"
          "type"        | Тип домена, доступные значения: "admin" / "client"
          "description" | Описание домена

      5. В модуле №1 выполнить обновление структуры
        - Убедиться, что обновление прошло успешно.
        - Убедиться, что появился соответствующий роут в M3.
        - Либо, если этого модуля нет, настроить роутинг вручную.


      6. Добавить этот домен в файл hosts

      7. Добавить этот домен в /etc/nginx/sites-avaible

        7.1. Если это не поддомен
          - Создаём новый конфиг в указанном каталоге.

        7.2. Если это поддомен
          - Можно добавить в server_name инфу о нём.
          - Допустим, есть у нас домен zaste.ru.
          - И хотим мы добавить поддомен lk.zaste.ru.
          - Тогда заходим в конфиг zaste.ru:

              server_name zaste-l5.ru *.zaste-l5.ru;

      8. Перезагрузить nginx

          sudo service nginx restart


  > Подготовка нового клиентского домена

    ---------------------------------
    Подоглавление:

      - Введение
      - Процесс подготовки клиентского домена

    ---------------------------------

    > Введение
      - Здесь описана подготовка нового клиентского домена к работе.

    > Процесс подготовки клиентского домена

      1. Скопировать каталог domain в app/domains
        - Каталог domain находится по адресу:
            app/DomainSamples/client/domain

      2. Переименовать domain в настоящее имя домена
        - Но заменить точки . на подчеркивания _
        - Поскольку точки не могут присутствовать в именах классов.
        - Например, если имя домена: zaste.ru
        - То надо переименовать domain в: zaste_ru

      3. Удалить из каталога с доменом каталог Documents/document
        - Если, конечно, вы не собираетесь заодно и подготовить новый документ.
        - Причём, каталог Documents удалять не надо.

      4. Настроить файл domain_info.json
        - Указать следующие значения:

          "protocol"    | Протокол, доступные значения: "http" / "https"
          "domain"      | Имя домена, например, "lk.zaste.ru"
          "type"        | Тип домена, доступные значения: "admin" / "client"
          "description" | Описание домена


  > Подготовка нового модуля к разработке

    ---------------------------------
    Подоглавление:

      - Введение
      - Процесс подготовки нового модуля к разработке

    ---------------------------------

    > Введение
      - Описан процесс подготовки нового модуля к разработке.

    > Процесс подготовки нового модуля к разработке

      1. Шаблон модуля копируется в нужный каталог-домен
        - Из app/DomainsSamples/admin/domain копируется каталог module.

      2. Наименование модуля
        - Модулю следует присвоить ID такое, которого ещё нет.
        - Например, уже существуют модули m1, m2, m3.
        - Значит, новый модуль будет называться m4.
        - Значит, следует переименовать скопированный каталог module в m4

      3. Заполнить composer.json нового модуля
        - А именно, поля:

          name
          description
          authors -> homepage
          require (если есть не стандартные зависимости)
          autoload

      4. В structure.json нового модуля ничего не делать
        - А заполнять его по мере добавления ресурсов.

      5. В composer.json проекта:
        - Открыть composer.json всего проекта (не модуля).
        - И добавить туда пространство имён модуля.
        - Имя пространства имён: id модуля.
        - Корневой каталог пр.имён: каталог модуля.
        - Пример:

            "autoload": {
                "psr-4": {
                    ...
                    "M1\\": "app/Domains/lk_zaste_ru/M1/"
                    ...
                }
            }

        - А также добавить установочный путь для модуля.
        - Без этого в представлениях модуля не будут правильно
          искаться пути к ресурсам c.css, j.js, f.js. m.js !!!
        - Пример:

            "extra": {
                "installer-paths": {
                    ...
                    "app/Domains/zaste_l5_ru/M1": ["4gekkman/M1"],
                    ...
                }
            },        

      6. Заполнить ServiceProvider.php в корневом каталоге модуля
        - В самом файле есть пометки TODO того, что там надо сделать.
        - В PHPStorm они выделены кислотно-зелёным цветом.
        - Посмотреть все пометки в документе можно так: ALT + 6

      7. Подготовить первый документ модуля
        - Переименовать каталог document (не путать с Documents) в имя документа.
        - Тот самый, который расположен по адресу:

          /[Каталог модуля]
              /Documents
                  /document

        - В structure.json модуля заполнить соотв. поля для этого документа.
        - А именно: имя документа, "description", "uri", "layout".
        - Когда понадобится создать ещё один документ, можно будет скопировать этот.

      8. Подготовить шаблоны всех ресурсов нового модуля
        - В каждом из файлов, о которых речь ниже, есть пометки
          TODO того, что там надо сделать.
        - В PHPStorm они выделены кислотно-зелёным цветом.
        - Посмотреть все пометки в документе можно так: ALT + 6
        - Речь идёт о следующих шаблонах:

          /[Каталог модуля]
              /Contracts
                  _CT1_MD1_sample.php
              /Models
                  _MD1_sample.php
              /Documents
                  /document
                      /Commands
                          CRUD samples
                              _C1_create.php
                              _C1_delete.php
                              _C1_save.php
                              _C1_update.php
                          _C1_sample.php
                      /Console
                          _T1_sample.php
                      /Events
                          _E1_sample.php
                      /EventHandlers
                          _H1_sample.php
                      /Public
                          c.css
                          m.js
                          f.js
                          j.js

      9. Подготовить Controller.php и View.php первого документа
        - В самих файлах есть пометки TODO того, что там надо сделать.
        - В PHPStorm они выделены кислотно-зелёным цветом.
        - Посмотреть все пометки в документе можно так: ALT + 6

      10. Добавить ServiceProvider модуля в /config/app.php
        - Сабж.


  > Оформление готового модуля, как пакета composer

    ---------------------------------
    Подоглавление:

      - Введение
      - Весь процесс разработки общим планом
      - Процесс оформления модуля, как пакета, и подключения к приложению

    ---------------------------------

    > Введение
      - Допустим, разработка модуля завершена, и он готов к релизу.
      - Теперь его надо оформить, как composer-пакет.
      - Чтобы его можно было устанавливать в проект через composer.
      - Здесь описан процесс, как это сделать.


    > Процесс оформления модуля, как пакета composer

      1. Подготовить SQL-скрипт для заселения БД модуля стартовыми данными
        - Для этого оставить в БД только МИНИМУМ необходимых данных.
        - Обычно, то данные в таблице настроек, какие-то статические данные, и т.п.
        - Затем в workbench сделать экспорт данных БД модуля (без стркуктуры).
        - Для этого в меню надо выбрать: server -> Data Export
        - Там выбрать в списке чекбоксов нужнаю базу данных.
        - Справа снизу, переключить select на dump data only.
        - Снизу выбрать радио-буттоном export to Self-Contained File.
        - И экспортировать данные в каталог "Database/1.0.0 - " модуля.

      2. Подготовить файл c workbench-моделью базы данных модуля
        - И положить его в каталог "Database/1.0.0 - " модуля.

      3. Подготовить документацию модуля в readme.md
        - В каталоге модуля есть файл readme.md
        - Необходимо в нём сделать подробное описание модуля.
        - Зачем он, установка, удаление, использование, и прочее.
        - Потом, по мере обновления, делать там релизные заметки.
        - Файл должен соответствовать формату mark down (для github).
        - Последний описан в методичке по последней версии Laravel, в главе:
            "Г13.  Разработка composer-пакетов для Laravel"

      4. Создать локальный git-репозиторий, и скопировать туда модуль
        - Например, можно иметь такую структуру у себя в файловой системе:

          /packages
              /m1
              /m2
              /m3
              ..

        - Где /m1, /m2, /m3, .. - отдельные локальные репозитории.
        - Сначала создать отдельный каталог, например, "m1".
        - Скопировать в него разработанный модуль.
        - Перейти в него в окне терминала, и выполнить: git init

      5. Создать удалённый репозиторий на github
        - Зайти на github.com, аутентифицироваться.
        - Создать новый приватный или публичный репозиторий.
        - Публичный использовть только для тех модулей, которые д.б. публичными.
        - Имя удалённого репозитория должно совпадать с ID модуля.

      6. Связать локальный репозиторий с удалённым
        - Для этого перейти в каталог локального репозитория.
        - И выполнить команду:

          git remote add [имя удал.репо.] [адрес удал.репо]

        - Например:

          git remote add M1 git@github.com:4gekkman/M1.git

        - Внимание! Регистр 'm1' или 'M1' имеет значение!

      7. Добавить в GitAutoPushScript.ps1 запись для авто-push
        - Этот скрипт каждый 3 часа автоматически делат push.
        - Следует добавить туда новый локальный репозиторий.

      8. Удалить каталог с модулем из проекта
        - Поскольку модуль уже скопирован в локальный репозиторий.
        - Так как далее мы установим модуль, как composer-зависимость.

      9. Удалить пр.имён модуля из composer.json проекта
        - Открыть composer.json проекта.
        - Удалить из "psr-4" пространство имён модуля.
        - Нужды в нём больше нет.

      10. Удалить ServiceProvider модуля из config/app.php
        - Можно и не удалять, если собираетесь установить этот модуль.
        - Ведь в этом случае, придётся обратно его добавить.

      11. Выполнить GitAutoPushScript.ps1 для загрузки модуля в репозиторий
        - Для этого открыть окно терминала с PowerShell.
        - И просто ввести полный путь к GitAutoPushScript.ps1.
        - В результате чего он выполнится. Например:

            C:\WebDev\GitAutoPushScript.ps1

      12. Создать новый релиз пакета версии 1.0.0
        - Для этого перейти в репозиторий пакета на github.
        - Кликнуть там по releases.
        - Нажать кнопку create new release.
        - В качестве tag version вписать 1.0.0.
        - Вписать название релиза, содержащее имя и версию пакета.
        - Нажать кнопку publish release.


  > Подключение и отключение модуля

      ---------------------------------
      Подоглавление:

        - Введение
        - Подключение модуля
        - Отключение модуля

      ---------------------------------

      > Введение
        - Здесь описаны ОБЩИЕ процессы подключения/отключения модуля в модульном приложении.
        - Конкретные же инструкции см. в документах самих модулей.

      > Подключение модуля

        1. Убедиться, что такого модуля нет в проекте
          - Что каталог модуля (который был при разработке), удалён.
          - И что модуль уже не подключен к проекту.

        2. Добавить модуль, как зависимость, в composer.json проекта
          - Открыть файл composer.json проекта.
          - Добавить туда модуль, как зависимость.
          - Причем указать, чтобы он скачивался не с packagist.
          - А прямо из репозитория на github (обычно, приватного).
          - Например:

            {
                "require": {
                    "4gekkman/m1": "1.0.*"
                },
                "repositories": [
                    {
                        "type": "vcs",
                        "url":  "git@github.com:4gekkman/m1.git"
                    }
                ]
                "extra": {
                    "installer-paths": {
                        "app/Domains/lk_zaste_ru/M1": ["4gekkman/M1"],
                    }
                },                
            }

          - Также следует указать, куда устанавливать модуль.
          - А устанавливать его надо в нужный каталог-домен (административный).
          - Например:

            "extra": {
                "installer-paths": {
                    "app/Domains/lk_zaste_ru/M1": ["4gekkman/m1"]
                }
            }

        3. Выполнить установку модуля
          - Перейти в окне терминала в корень приложения.
          - Выполнить:

              composer update
              composer dump-autoload

        4. Выполнить подготовку БД модуля
          - Из workbench-модели модуля, и SQL-файла с данными.
          - Надо брать соотв. данные для устанавливаемой версии модуля.

        5. Подключить сервис-провайдер модуля config/app.php
          - Сервис-провайдер модуля находится в каталоге модуля.


    > Отключение модуля

      1. Убрать модуль, как зависимость, из composer.json проекта
        - Убрать его из "require".

      2. Убрать подключение сервис-провайдеров модуля и его документов из config/app.php
        - Сабж.

      3. Удалить базу данных модуля
        - Сабж.

      4. Выполнить удаление модуля
        - Перейти в окне терминала в корень приложения.
        - Выполнить:

            composer update
            composer dump-autoload

        - Каталог с миграциями модуля располагается по адресу:

            [каталог модуля]/Database/Migrations


  > Обновление установленного модуля

    ---------------------------------
    Подоглавление:

      - Введение
      - Обновление на уровне "патч" и "минорное"
      - Обновление на уровне "мажорное"

    ---------------------------------

    > Введение
      - Здесь описан процесс обновления установленного модуля.

    > Обновление на уровне "патч" и "минорное"

      # Информация
        - Такое обновление имеет обратную совместимость.
        - После обновления всё должно продолжить без проблем работать.
        - В composer.json версия в зависимости модуля прописана в таком духе:

            "4gekkman/m1": "~1.0"

        - Значит, можно просто применить composer update.
        - И модуль обновится до последней версией.
        - Пример обновление на уровне "патч":

            От "1.0.0" до "1.0.1"

        - Пример обновление на уровне "минорное":

            От "1.0.15" до "1.1.0"

        - Также надо не забыть выполнить соотв.миграции для обновления БД модуля.

      # Инструкция

        1. Просмотреть замечания к новому релизу
          - Там должна быть подробная инструкция по обновлению.
          - Здесь же приведена стандартная инструкция.

        2. Выполнить команду: composer update
          - Перейти в окне терминала в каталог проекта.
          - Выполнить эту команду.

        3. Обновить структуру БД
          - Посмотреть в каталоге Database модуля.
          - Есть ли там файлы обновлённые файлы для новой версии.
          - Если есть, то использовать workbench-модель.
          - В workbench синхронизировать БД модуля с ней.


    > Обновление на уровне "мажорное"

      # Информация
        - Мажорное обновление не гарантирует обратной совместимости.
        - Оно должно сопровождаться пояснительным документом по этому поводу.
        - Возможно, придётся изменять код в потребителях модуля.
        - Чтобы сделать мажорное обновление, надо изменить версию в composer.json.
        - Например, была такая запись:

            "4gekkman/m1": "~1.0"

        - А мы хотим обновиться до версии 2.0.0. Делаем такую:

            "4gekkman/m1": "~2.0"

        - И применяем команду: composer update

      # Инструкция

        1. Просмотреть замечания к новому релизу
          - Там должна быть подробная инструкция по обновлению.
          - Здесь же приведена стандартная инструкция.

        2. Удалить старый модуль
          - Полностью.

        3. Установить новый модудь
          - Как устанавливать модули описано в другом разделе.


  > Изменение структуры БД модуля

    ---------------------------------
    Подоглавление:

      - Введение

      - Во время разработки до первого релиза
      - Во время первого релиза
      - Во время разработки между релизами
      - Во время 2-го и последующего релизов

    ---------------------------------

    > Введение
      - Обсуждается тематика обновления БД модуля.
      - Каждый модуль имеет свою собственную базу данных.
      - В каталоге модуля есть каталог Database.
      - В нём могут быть каталоги, с именами (примеры):

          1.0.0
          1.0.5
          1.0.10

      - В каждом из таких каталогов должны лежать 2 файла:

          1. Workbench-модель базы данных модуля.
          2. SQL-файл с минимальными тестовыми данными для этой модели.

    > Во время разработки до первого релиза
      - Изменения вносятся в workbench-схему.
      - После чего производится синхронизации БД со схемой.


    > Во время первого релиза

      1. Workbench-схема помещается в каталог Database модуля
        - Сабж.

      2. SQL-файл с MIN-данными модуля помещается в тот же каталог
        - Сначала, надо удалить из БД модуля все лишние данные.
        - Необходимыми, как правило, являются подобного рода данные:

          - Данные из таблицы настроек.
          - Различного рода статичные-справочные данные.
          - ... и другие.

        - Затем надо экспортировать оставшиеся данные БД в файл.
        - И этот файл поместить в каталог Database модуля.


    > Во время разработки между релизами
      - Не в каждом релизе будут изменения в БД модуля.
      - Но допустим, настал тот момент, когда надо внести изменения.
      - Тогда в каталоге Database создаётся новый каталог.
      - Его имя должно совпадать с версией будущего релиза.
      - Например, если версия будущего 1.0.5, то имя каталога:

          1.0.5

      - В него помещается Workbench-схема базы данных модуля.
      - Для создания тестовых данных, создаётся временная БД.
      - В неё вручную (или копипастой) добавляются минимальные тестовые данные.
      - Экспортируются в файл, и кладутся в каталог 1.0.5


  > Добавление/Удаление административного документа

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Введение
      - Допустим, мы хотим добавить новый админ.документ в какой-то модуль.
      - Или же, мы хотим удалить его.
      - Рассмотрим, как это делается.

    > Инструкция по добавлению

      1. Скопировать документ в каталог [модуль]/Documents

        # Если есть подготовленный документ-сосед
          - Находящийся в Documents соответствующего модуля.
          - То лучше взять и скопировать его.
          - Т.К. этот документ уже подготовлен для работы с этим модулем.
          - И можно сэкономить время на соответствующей подготовке.

        # Если нет подготовленного документа-соседа
          - То скопировать из app/DomainsSamples/admin/domain/module/Documents/document
          - В этом случае, придётся ещё и подготовить документ к работе с модулем.
          - Как это делается, описано в "Подготовка нового модуля к разработке".

      2. Переименовать каталог с документом
        - Дать ему имя документа, латинскими буквами, с большой буквы.

      3. Добавить запись о документе в [модуль]/structure.json
        - И заполнить все необходимые соответствующие поля.
        - По мере разработки документа, не забывать дополнять эту инфу.

      4. Добавить регистрацию ресурсов документа в сервис-провайдер модуля
        - Открыть сервис-провайдер, и сделать по аналоги с другими документами.

    > Инструкция по удалению

      1. Удалить документ из каталога [модуль]/Documents

      2. Удалить запись о документе из [модуль]/structure.json

      3. Удалить регистрацию ресурсов документа из сервис-провайдера модуля


  > Добавление/Удаление клиентского документа

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Введение
      - Допустим, мы хотим добавить новый клиент.документ в какой-то клиент.домен.
      - Или же, мы хотим удалить его.
      - Рассмотрим, как это делается.

    > Инструкция по добавлению

      1. Скопировать документ в каталог [клиент.домен]/Documents

        # Если есть подготовленный документ-сосед
          - Находящийся в Documents соответствующего клиент.домена.
          - То лучше взять и скопировать его.
          - Т.К. этот документ уже подготовлен для работы с этим модулем.
          - И можно сэкономить время на соответствующей подготовке.

        # Если нет подготовленного документа-соседа
          - То скопировать из app/DomainsSamples/client/domain/Documents/document
          - В этом случае, придётся ещё и подготовить документ к работе.

      2. Переименовать каталог с документом
        - Дать ему имя документа, латинскими буквами, с большой буквы.

      3. Добавить запись о документе в [клиент.домен]/structure.json
        - И заполнить все необходимые соответствующие поля.
        - По мере изменения соотв.информации, изменять её и здесь.

    > Инструкция по удалению

      1. Удалить документ из каталога [клиент.домен]/Documents

      2. Удалить запись о документе из [клиент.домен]/structure.json


  > Добавление/Удаление шаблона

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Введение
      - Допустим, мы хотим добавить новый шаблон.
      - Или же, мы хотим удалить его.
      - Рассмотрим, как это делается.

    > Инструкция по добавлению

      1. Скопировать шаблон в каталог app/Layouts
        - Из app/Layouts/_Sample

      2. Переименовать каталог шаблона, и layout.blade.php
        - Каталог переименовать в имя шаблона, лат.буквами, с большой буквы.
        - layout.blade.php переименовать в [имя шаблона с мал.буквы].blade.php

      3. Подготовить файлы шаблона к работе
        - В файлах есть пометки TODO: они показывают, что надо делать.

      4. Добавить сервис-провайдер шаблона в providers в config/app.php
        - Сабж.

    > Инструкция по удалению

      1. Убедитсья, что этот шаблон не используют никакие документы

      2. Удалить каталог с шаблоном из app/Layouts

      3. Удалить сервис-провайдер шаблона из providers в config/app.php


  > Добавление/Удаление модели модуля

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Инструкция по добавлению

      1. Скопировать шаблон модели в [модуль]/Models
        - Шаблон находится по адресу [модуль]/Models/_MD1_sample.php

      2. Переименовать скопированную модель
        - Дать ей уникальный в этом каталоге, следующий по счёту ID.
        - Скажем, если предыдущий был MD5, то новой дать MD6.
        - Аналогичный ID должен быть у таблицы модели в БД.
        - Вообще, ID и имя модели должны совпадать с ID и именем таблицы в БД.

      3. Добавить информацию о модели в structure.json модуля
        - И обновлять по мере необходимости.

      4. Подготовить файл-модель к работе
        - Там есть пометки TODO: они показывают, что надо делать.

    > Инструкция по удалению

      1. Удалить модель из [модуль]/Models

      2. Удалить информацию о модели из structure.json модуля


  > Добавление/Удаление контракта модуля

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Инструкция по добавлению

      1. Скопировать шаблон контракта в [модуль]/Contracts
        - Шаблон находится по адресу [модуль]/Contracts/_CT1_sample.php

      2. Переименовать скопированный контракт
        - Дать ему уникальный в этом каталоге, следующий по счёту ID.
        - Скажем, если предыдущий был CT5, то новой дать CT6.
        - Ну и дать ему имя, отражающее, для чего этот контракт.

      3. Добавить информацию о контракте в structure.json модуля
        - И обновлять по мере необходимости.

      4. Подготовить файл-контракт к работе
        - Там есть пометки TODO: они показывают, что надо делать.

    > Инструкция по удалению

      1. Удалить контракт из [модуль]/Contracts

      2. Удалить информацию о контракте из structure.json модуля


  > Добавление/Удаление команды админ.документа

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Инструкция по добавлению

      1. Скопировать шаблон контракта в [модуль]/[документ]/Commands
        - Шаблон находится по адресу [модуль]/[документ]/Commands/_C1_sample.php

      2. Переименовать скопированную команду
        - Дать ей уникальный в этом каталоге, следующий по счёту ID.
        - Скажем, если предыдущий был C5, то новой дать C6.
        - Ну и дать ей имя, отражающее, для чего она.

      3. Добавить информацию о команде в structure.json модуля
        - И обновлять по мере необходимости.

      4. Подготовить файл-команду к работе
        - Там есть пометки TODO: они показывают, что надо делать.

    > Инструкция по удалению

      1. Удалить команду из [модуль]/[документ]/Commands/

      2. Удалить информацию о команде из structure.json модуля


  > Добавление/Удаление artisan-команды админ.документа

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Инструкция по добавлению

      1. Скопировать шаблон artisan-команды в [модуль]/[документ]/Console
        - Шаблон находится по адресу [модуль]/[документ]/Console/_T1_sample.php

      2. Переименовать скопированную artisan-команду
        - Дать ей уникальный в этом каталоге, следующий по счёту ID.
        - Скажем, если предыдущий был T5, то новой дать T6.
        - Ну и дать ей имя, отражающее, для чего она.

      3. Добавить информацию об artisan-команде в structure.json модуля
        - И обновлять по мере необходимости.

      4. Подготовить файл-artisan-команду к работе
        - Там есть пометки TODO: они показывают, что надо делать.

      5. Зарегистрировать artisan-команду в сервис-провайдере модуля
        - В методе register.

    > Инструкция по удалению

      1. Удалить artisan-команду из [модуль]/[документ]/Console/

      2. Удалить информацию о команде из structure.json модуля

      3. Удалить регистрацию artisan-команды из сервис-провайдера модуля
        - Из метода register.


  > Добавление/Удаление события админ.документа

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Инструкция по добавлению

      1. Скопировать шаблон события в [модуль]/[документ]/Events
        - Шаблон находится по адресу [модуль]/[документ]/Events/_E1_sample.php

      2. Переименовать скопированное событие
        - Дать ему уникальный в этом каталоге, следующий по счёту ID.
        - Скажем, если предыдущий был E5, то новой дать E6.
        - Ну и дать ему имя, отражающее, для чего оно.

      3. Добавить информацию о событии в structure.json модуля
        - И обновлять по мере необходимости.

      4. Подготовить файл-событие к работе
        - Там есть пометки TODO: они показывают, что надо делать.

    > Инструкция по удалению

      1. Удалить событие из [модуль]/[документ]/Events/

      2. Удалить информацию о событии из structure.json модуля


  > Добавление/Удаление обработчика события админ.документа

    ---------------------------------
    Подоглавление:

      - Введение
      - Инструкция по добавлению
      - Инструкция по удалению

    ---------------------------------

    > Инструкция по добавлению

      1. Скопировать шаблон обработчика события в [модуль]/[документ]/EventHandlers
        - Шаблон находится по адресу [модуль]/[документ]/EventHandlers/_H1_sample.php

      2. Переименовать скопированный обработчик события
        - Дать ему уникальный в этом каталоге, следующий по счёту ID.
        - Скажем, если предыдущий был H5, то новой дать H6.
        - Ну и дать ему имя, отражающее, для чего он.

      3. Добавить информацию об обработчике события в structure.json модуля
        - И обновлять по мере необходимости.

      4. Подготовить файл-обработчик-события к работе
        - Там есть пометки TODO: они показывают, что надо делать.

    > Инструкция по удалению

      1. Удалить обработчик события из [модуль]/[документ]/EventHandlers/

      2. Удалить информацию об обработчике события из structure.json модуля



  > Как изменить базу данных по умолчанию для текущего запроса

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение в проблему
    - Решение

  --------------------------------------

  > Ссылки

    # Ссылка на решение
        http://forumsarchive.laravel.io/viewtopic.php?pid=70866#p70866


  > Введение в проблему
    - Существует конфиг config/database.php.
    - В нём сконфигурированы соединения с серверами баз данных.
    - В каждой конфигурации указана база данных (schema) по умолчанию.
    - Но иногда, в коде требуется обратиться к другой базе данных (schema).
    - Не к другому серверу баз данных, а именно к другой БД на том же сервере.
    - И это является проблемой.
    - Допустим, в Laravel присутствует так называемый Schema Builder.
    - И он может работать только с базой данных, указанной по умолчанию.
    - А между прочим, именно через него работают, скажем, миграции.


  > Решение

    // 1. Установить другое значение "database" в config/database.php
    //    - Причём, это работает только для текущей сессии.
    //    - То есть, у других запросов будет значение по умолчанию.
    Config::set('database.connections.mysql.database', $database);

    // 2. Выполнить переподключение к соответствующему соединению
    $connection = DB::reconnect('mysql');

    // 3. Установить соединение по умолчанию
    DB::setDefaultConnection('mysql');

    // 4. Работать с новым соединением, с указаной БД

      // ... код ...


  > Как сделать реверс-инжениринг БД модуля в миграцию Laravel 5.1

    ---------------------------------
    Подоглавление:

      - Ссылки
      - Введение
      - Процесс реверс-инжениринга с применением Xethron/migrations-generator

    ---------------------------------

    > Ссылки

      # Пакеты для Laravel, для осуществления реверс-инжениринга:
          https://github.com/Xethron/migrations-generator


    > Введение
      - При релизе модуля, с ним должна поставляться и миграция.
      - А при первом релизе, миграцию надо сделать из готовой БД.
      - Иными словами, надо провести реверс-инжениринг БД в миграцию L5.1.
      - Здесь будет рассмотрен этот процесс.


    > Процесс реверс-инжениринга с применением Xethron/migrations-generator

      1.



  > Обсуждение модулей для обслуживания модульного приложения

    Модуль "Управление модульным приложением"
    -----------------------------------------

      # Общее описание
        - Имеет набор таблиц для хранения структуры модульного приложения.
        - Может по команде синхронизировать содержимое таблиц с реальной структурой.
        - Имеет наглядный интерфейс для просмотра структуры в браузере.

      # Что должен иметь и уметь

        1) Должен иметь структуру таблиц для хранения ресурсов мод.приложения
          - Для каждого ресурса должна быть своя таблица.
          - Например: Домены, Модули, Документы, Модели, Контракты,
                      Команды, События, Обработчики, Консольные команды

        2) Должен уметь синхронизировать данные по команде
          - Пробегать всю структуру модульного приложения.
          - И синхронизировать инфу в таблицах с реальностью.

        3) Оповещать о созданных/удалённых ресурсах
          - Скажем, при синхронизации выяснилось, что структура изменилась.
          - Добавились какие-то новые ресурсы, а какие-то старые были удалены.
          - В каждом таком случае следует возбуждать соответствующее событие.
          - Оно несёт в себе инфу: добавлен/удалён, тип ресурса, его данные.
          - Заинтересованные модули могут отслеживать эти события, и использовать.
          - Скажем, модуль "Управление правами доступа", может использовать.
          - Примеры: 

            1] При добавл.нов.команды, модуль добавляет новое соотв.право на исполнение.
            2] При добавлении нового документа создаётся новый роут.

        4) При синхронизации должен использовать инфо.файлы
          - А именно: domain_info.json, module_info.json, clients_info.json
          - Структура этих файлов заранее известна.
          - Скрипт должен извлекать из них инфу, и записывать в соотв.таблицу.

        5) Должен иметь удобный интрфейс для просмотра структуры
          - В этом интерфейсе, вся структура д.б., как на ладони.
          - Благодаря инфе из инфо-файлов, это должно быть очень наглядно.
          - С удобными именами и описаниями.

        6) Иметь систему предупреждений по зависимостям потребителей
          - Документы-потребители зависят от набора модулей.
          - В случае отсутствия этих модулей, потребитель не работает.
          - Данные об этих зависимостях лежат в clients_info.json клиентского домена.
          - Наш модуль должен уметь обнаруживать такие проблемы и сообщать.


    Модуль "Лог приложения"
    -----------------------

      # Общее описание
        - Это модуль для журналирования всего приложения.
        - Умеет работать с тегами, имеет свой фасад и функционал.
        - Имеет веб-интерфейс.

      # Что должен иметь и уметь

        1) Две таблицы: Сообщения и Теги
          - В Сообщения хранить сообщения.
          - А в Теги хранить теги, с которыми связаны сообщения.
          - Связь между этими таблицами: n:m

        2) Использование тегов для пометки сообщений
          - Каждое сообщение может быть помечено 1 или более тегами.
          - Потом, по этим тегам, можно фильтровать сообщения в интерфейсе.

        3) Иметь веб-интерфейс
          - Удобный веб-интерфейс с пагинацией в стиле "показать ещё N".
          - С возможностью фильтровать сообщения по тегам.
          - С возможностью сортировать сообщения по дате создания.

        4) Автоматический контроль размера лога
          - Таблица с логом не должна разрастаться больше положенного.
          - Должна быть возможность задать ограничения:

            1) Максимальный срок хранения сообщения в таблице.
            2) Максимальное кол-во сообщений в таблице.

          - В случае превышения лимитов, автоматически предпринимать меры.

        5) Свой фасад и функция-помощник для удобного использования
          - Лог потребуется использовать много и часто.
          - Поэтому фасад и функция-помощник просто необходимы.
          - С ними пользоваться будет удобно.
          - Функция-помощник может выглядеть так:

              log($msg, $tags)

          - Причём, второй аргумент не обязателен, а первый да.

        6) В веб-интерфейсе использовать websocket
          - Надо, чтобы в веб-интерфейс сообщения приходили в режиме онлайн.
          - Даже при применённых фильтрах и сортировке.
          - Вот интерфейс открыт и рраз, новое сообщение само собой появляется.


Б4. Как изменить базу данных по умолчанию для текущего запроса

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение в проблему
    - Решение

  --------------------------------------

  > Ссылки

    # Ссылка на решение
        http://forumsarchive.laravel.io/viewtopic.php?pid=70866#p70866


  > Введение в проблему
    - Существует конфиг config/database.php.
    - В нём сконфигурированы соединения с серверами баз данных.
    - В каждой конфигурации указана база данных (schema) по умолчанию.
    - Но иногда, в коде требуется обратиться к другой базе данных (schema).
    - Не к другому серверу баз данных, а именно к другой БД на том же сервере.
    - И это является проблемой.
    - Допустим, в Laravel присутствует так называемый Schema Builder.
    - И он может работать только с базой данных, указанной по умолчанию.
    - А между прочим, именно через него работают, скажем, миграции.


  > Решение

    // 1. Установить другое значение "database" в config/database.php
    //    - Причём, это работает только для текущей сессии.
    //    - То есть, у других запросов будет значение по умолчанию.
    Config::set('database.connections.mysql.database', $database);
    
    // 2. Выполнить переподключение к соответствующему соединению
    $connection = DB::reconnect('mysql');
    
    // 3. Установить соединение по умолчанию
    DB::setDefaultConnection('mysql');

    // 4. Работать с новым соединением, с указаной БД

      // ... код ...


Б5. Генерация миграции L5 из готовой БД

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка
    # Функционал команды migrate:generate

      php artisan help migrate:generate   | справка о команде
      php artisan migrate:generate        | создать миграцию всей default-БД default-соединения
        --tables="table1,table2,..."        - включить в миграцию лишь указанные таблицы
        --ignore="table1,table2,..."        - миграция по всем таблицам, кроме указанных
        --connection="name"                 - указать соединение (mysql по умолчанию)
        --path="путь"                       - куда поместить созданную миграцию
        --defaultIndexNames                 - использовать имена индексов по умолчанию (а не те, что назначены им в БД)
        --defaultFKNames                    - использовать имена внешних ключей по умолчанию (а не те, что назначены им в БД)

    # Использование

      - Пример создания миграции БД модуля

  --------------------------------------

  > Ссылки

    # Ссылка на репозиторий Xethron/migrations-generator
        https://github.com/Xethron/migrations-generator

    # Мини-туториал по использованию Xethron/migrations-generator:
        http://codingtip.blogspot.ru/2014/04/laravel-4-generate-migration-existed-dabase-laravel-4.html


  > Введение
    - В Laravel есть такой функционал, как миграции.
    - Он подробно описано в последней версии справочника по Laravel.
    - Класс-миграцию можно создать вручную. 
    - Но что, если надо сделать миграцию из уже готовой базы данных?
    - В этом случае, нам понадобится доп.пакет, т.к. из коробки такого фукнционала нет.
    - В L4 таким пакетом был: barryvdh/laravel-migration-generator
    - А в L5 основанный на нём: Xethron/migrations-generator
    - Рассмотрим же работу с последним в этой главе.


  > Установка

    1. Добавить в composer.json проекта требуемые зависимости и репозитории

        "require-dev": {
            "xethron/migrations-generator": "dev-l5",
            "way/generators": "dev-feature/laravel-five-stable"
        }    
        "repositories": [
            {
                "type": "git",
                "url": "git@github.com:jamisonvalenta/Laravel-4-Generators.git"
            }
        ]

    2. Добавить в массив providers в config/app.php провайдеры пакета
      - Открыть файл config/app.php.
      - Добавить в массив providers 2 следующие записи:

        Way\Generators\GeneratorsServiceProvider::class,
        Xethron\MigrationsGenerator\MigrationsGeneratorServiceProvider::class,      

    3. Выполнить установку пакета, и обновить автозагрузку
      - Перейти в окне терминала в каталог проекта.
      - Выполнить следующие команды:

          composer update
          composer dump-autoload

      - Он может запросить токен для доступа к соотв.репозиторию.
      - В запросе будет указан URL, по которому можно взять токен.
      - Надо по нему перейти и нажать кнопку "copy token".
      - А затем вставить токен в окне терминала, и нажать enter.

  > Функционал команды migrate:generate

      php artisan help migrate:generate   | справка о команде
      php artisan migrate:generate        | создать миграцию всей default-БД default-соединения
        --tables="table1,table2,..."        - включить в миграцию лишь указанные таблицы
        --ignore="table1,table2,..."        - миграция по всем таблицам, кроме указанных
        --connection="name"                 - указать соединение (mysql по умолчанию)
        --path="путь"                       - куда поместить созданную миграцию
        --defaultIndexNames                 - использовать имена индексов по умолчанию (а не те, что назначены им в БД)
        --defaultFKNames                    - использовать имена внешних ключей по умолчанию (а не те, что назначены им в БД)


  > Использование

    Пример создания миграции БД модуля
    ----------------------------------

      # Исходные условия
        - Имеется модуль "М1 - управление модулями".
        - У него на сервере БД есть своя БД "M1".
        - Эта БД разрабатывается с помощью mysql workbench.
        - Требуется сделать миграцию всей этой БД.
        - Миграция должна учитывать в т.ч. FK, индексы.
        - Миграцию мы хотим положить в каталог:
            app/Domains/lk_zaste_ru/M1/Database/Migrations


      # Пошаговое решение задачи

        1) Перейти в окне терминала в корневой каталог приложения
          - При использовании homestead, в окне его терминала.

        2) Подготовить специальное соединение для создания миграции
          - Дело в том, что БД "M1" не является default-БД в default-соединении.
          - А команде migrate:generate нельзя указать другую БД.
          - Можно лишь указать другое соединение.
          - Поэтому, рекомендуется создать спец.соединение для работы с этой командой.
          - И перед её использованием менять в нём имя БД, миграцию которого надо создать.
          - Для создания нового соединения откройте файл config/database.php
          - В нём добавьте в массив connections новое соединение:

            'mysql4migrations' => [
                'driver'    => 'mysql',
                'host'      => env('DB_HOST', '127.0.0.1'),
                'database'  => 'm1',
                'username'  => env('DB_USERNAME', 'forge'),
                'password'  => env('DB_PASSWORD', ''),
                'charset'   => 'utf8',
                'collation' => 'utf8_unicode_ci',
                'prefix'    => '',
                'strict'    => false,
            ],    

          - Важный нюанс! Регистр букв в имени БД имеет значение!      

        3) Создать миграцию
          - *Примечание: каталог v1_0_0 должен существовать, иначе будет ошибка.
          - Для этого выполнить команду:

            


          - Он спросит, добавлять ли миграцию в таблицу Migrations, ответить yes.
          - И он попросит указтаь номер пакета, указать рекомендуемый.
          - В окне терминала он будет отображать данные по мере создания миграции.
          - Готовые миграции можно найти в каталоге migrations.


Б6. Генерация заселятелей L5 из готовой БД

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка
    # Функционал команды iseed

      php artisan help iseed              | справка о команде
      php artisan iseed table1,table2,... | создать классы-заселятели для указанных таблиц
        --database="name"                   - указать соединение (mysql по умолчанию)
        --force                             - если файлы с такими именами уже есть, перезаписать
        --max="10"                          - максимальное число строк для заселения

    # Использование

      - Пример создания заселятелей для таблиц БД модуля

  --------------------------------------

  > Ссылки

    # Ссылка на репозиторий orangehill/iseed
        https://github.com/orangehill/iseed


  > Введение
    - В Laravel есть такой функционал, как классыз-заселятели.
    - Он подробно описано в последней версии справочника по Laravel.
    - Класс-заселятель можно создать вручную. 
    - Но что, если надо сделать заселятель из уже готовой базы данных?
    - В этом случае, нам понадобится доп.пакет, т.к. из коробки такого фукнционала нет.
    - В L5 есть такой пакет: orangehill/iseed
    - Рассмотрим же работу с ним в этой главе.


  > Установка

    1. Добавить в composer.json проекта требуемые зависимости и репозитории

        "require": {
            "orangehill/iseed": "dev-master"
        }

    2. Добавить в массив providers в config/app.php провайдер пакета
      - Открыть файл config/app.php.
      - Добавить в массив providers следующую запись:

        Orangehill\Iseed\IseedServiceProvider::class,

    3. Выполнить установку пакета, и обновить автозагрузку
      - Перейти в окне терминала в каталог проекта.
      - Выполнить следующие команды:

          composer update
          composer dump-autoload

      - Он может запросить токен для доступа к соотв.репозиторию.
      - В запросе будет указан URL, по которому можно взять токен.
      - Надо по нему перейти и нажать кнопку "copy token".
      - А затем вставить токен в окне терминала, и нажать enter.

  > Функционал команды iseed

      php artisan help iseed              | справка о команде
      php artisan iseed table1,table2,... | создать классы-заселятели для указанных таблиц
        --database="name"                   - указать соединение (mysql по умолчанию)
        --force                             - если файлы с такими именами уже есть, перезаписать
        --max="10"                          - максимальное число строк для заселения  


  > Использование

    Пример создания заселятелей для таблиц БД модуля
    ------------------------------------------------

      # Исходные условия
        - Имеется модуль "М1 - управление модулями".
        - У него на сервере БД есть своя БД "M1".
        - Эта БД разрабатывается с помощью mysql workbench.
        - Уже создана миграция всей этой БД.
        - Но как на счёт неких "демо-данных"?
        - Загрузить демо-данные в БД помогут заселятели.


      # Пошаговое решение задачи

        1) Перейти в окне терминала в корневой каталог приложения
          - При использовании homestead, в окне его терминала.

        2) Подготовить специальное соединение для создания заселятелей
          - Дело в том, что БД "M1" не является default-БД в default-соединении.
          - А команде iseed нельзя указать другую БД.
          - Можно лишь указать другое соединение.
          - Поэтому, рекомендуется создать спец.соединение для работы с этой командой.
          - И перед её использованием менять в нём имя БД, миграцию которого надо создать.
          - Для создания нового соединения откройте файл config/database.php
          - В нём добавьте в массив connections новое соединение:

            'mysql4migrations' => [
                'driver'    => 'mysql',
                'host'      => env('DB_HOST', '127.0.0.1'),
                'database'  => 'm1',
                'username'  => env('DB_USERNAME', 'forge'),
                'password'  => env('DB_PASSWORD', ''),
                'charset'   => 'utf8',
                'collation' => 'utf8_unicode_ci',
                'prefix'    => '',
                'strict'    => false,
            ],    

          - Важный нюанс! Регистр букв в имени БД имеет значение!      
          - P.S. можно использовать то же соединение, что для работы с созданием миграций.

        3) Переключить соединение по умолчанию на mysql4migrations
          - Когда я тестировал команду, опция --database не срабатывала.
          - Единственным способом указать верное соединение, было изменить default-соединение.
          - Для этого надо открыть конфиг config/database.php
          - И в нём изменить значение св-ва 'default' на:

            'default' => env('DB_CONNECTION', 'mysql4migrations'),

        4) Создать заселятели
          - Представм, что у нас в БД модуля лишь 2 таблицы: table1 и table2
          - Создадим для них классы-заселятели.
          - Для этого выполнить команду:

            php artisan iseed table1,table2 --database="mysql4migrations" --force

          - К сожалению, нельзя указать, куда он должен сохранять готовые заселятели.
          - Это захардкожено, он сохранит их в app/database/seeds.
          - Причём, перезапишет все одноимённые заселятели.

        5) Изменить соединение по умолчанию обратно, как было
          - Допустим, было так:

            'default' => env('DB_CONNECTION', 'mysql'),

        6) Вырезать созданные заселятели в нужное место
          - По умолчанию, они будут созданы в: app/database/seeds.
          - А в нашем примере, надо их перенести в: 
              app/Domains/lk_zaste_ru/M1/Database/Seeds/v1_0_0

        7) Добавить в начале каждого из файлов-заселятелей верное пр.имён
          - В нашем случае, это:

              namespace M1\Database\Seeds\v1_0_0;


Б7. Как расшарить куки для всех поддоменов домена

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Особенности Cookie::queue
    # Пошаговое решение
    # Примечание по удалению такой куки

  --------------------------------------

  > Ссылки

    # Статья на английском
        https://gistlog.co/JacobBennett/15558410de2a394373ac

    # Ссылка на метод make в API laravel 5.1:
        http://laravel.com/api/5.1/Illuminate/Contracts/Cookie/QueueingFactory.html#method_make


  > Введение
    - Есть 3 домена: zaste.ru, lk.zaste.ru, img.zaste.ru.
    - Надо, чтобы проставляемая кука была общая для всех трёх.
    - В этой главе описано, как это делать в Laravel.


  > Особенности Cookie::queue
    - В ссылках выше есть ссылка на этот метод (make).
    - Он имеет следующие аргументы:

      string  $name       // имя куки
      string  $value      // значение куки
      int     $minutes    // время жизни куки в минутах
      string  $path       // путь, где действует (по умолчанию '/')
      string  $domain     // домен, где действует (по умолчанию тот, где кука проставляется)
      bool    $secure     // помещать куку в ответ, только при передаче по безопасному tls-каналу
      bool    $httpOnly   // кука недоступна из JS


  > Пошаговое решение
    - Итак, у нас есть 3 указанных во введении домена.
    - Чтобы кука была доступна во всех 3-ёх, надо указать правильный $domain.
    - А именно, полное доменное имя с доменами 1 и 2 уровней.
    - Перед которым должна стоять точка.
    - В нашем случае это: '.zaste.ru'
    - Пример создания такой куки:

        Cookie::queue(
          'my_cookie',
          'value of the cookie',
          15,
          '/',
          '.zaste.ru',
        );


  > Примечание по удалению такой куки
    - Удалить созданную методом выше куку просто по ключу не получится.
    - То есть, если написать, например: 

        Cookie::queue( Cookie::forget('m7_auth_cookie') );

    - То кука не удалится.
    - Чтобы она удалилась, надо также указывать тот же $domain, что при создании.
    - А именно:

        Cookie::queue( Cookie::forget('m7_auth_cookie', '/', '.zaste.ru') );

    - Для получения значения этого домена по данным модуля M7,
      можно использовать функцию-хелпер lib_domain4cookie().


Б8. Как бороться с ошибкой nginx: "504 Gateway Time-out"

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Решение

  --------------------------------------

  > Ссылки

    # Статья с решением
        ruhighload.com/post/Ошибка+504+Gateway+Time-out+в+Nginx

  > Введение
    - Иногда какая-то работа на сервере выполняется довольно долго.
    - Тогда nginx 1.8.0 выдаёт ошибку "504 Gateway Time-out".
    - Если за 30 секунд данная работа выполниться не успевает.
    - Это бывает неудобно, поэтому, возможно это исправить.

  > Решение
    
    1. Установим таймаут nginx 300 секунд (вместо стандартных 30):
      - Открываем файл /etc/nginx/available-sites/[нужный конфиг]
      - Там в указанный блок location вписываем директиву:

        location ~ \.php$ {
          ...
          fastcgi_read_timeout 300;
          ...
        } 

    2. Установим таймаут php-fpm 300 секунд (вместо стандартных 30):   
      - Открываем конфиг php-fpm: /etc/php5/php-fpm/php.ini
      - Находим там директиву max_execution_time.
      - Устанавливаем значение 300.


Б9. Установка N серверов MySQL на одну ОС Ubuntu в Homestead

  --------------------------------------
  Оглавление:

    # Ссылки
    # Введение
    # Два варианта
    # Уникальность некоторых св-в каждого экземпляра MySQL

    # Работа с mysqld_multi
    # Образец конфига my.conf
    # Пошаговая инструкция по преобразования 1-экземплярной mysql в мульти-экземплярную
    # Возможные ошибки, и решения

  --------------------------------------

  > Ссылки

    # Установка N-штук mysql-серверов из бинарников на Linux
        http://dev.mysql.com/doc/refman/5.7/en/multiple-servers.html
        https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html
        https://dev.mysql.com/doc/refman/5.7/en/postinstallation.html

    # Использование mysqld_multi для управления N экземплярами mysql
        http://dev.mysql.com/doc/refman/5.7/en/mysqld-multi.html
        http://mldav.blogspot.ru/2011/11/mysql.html
        https://www.percona.com/blog/2014/08/26/mysqld_multi-how-to-run-multiple-instances-of-mysql/


  > Введение
    - При разработке на Laravel я использую модульную систему.
    - Каждый модуль имеет отдельную БД, имеющую определённое имя.
    - Примеры имён этих БД: 'M1', 'M2', 'M3', и так далее.
    - Переименовывать модули и их БД нельзя.
    - А 1 экземпляр MySQL не может содержать 2 БД с одинаковым именем.
    - Поэтому, на каждый новый проект нужен отдельный экземпляр MySQL.


  > Два варианта

    # Вариант решения проблемы №1
      - Просто установить ещё один mysql-сервер.

    # Вариант решения проблемы №2
      - Использовать спец.софт в рамках 1-го mysql-сервера.


  > Уникальность некоторых св-в каждого экземпляра MySQL

    0. Пояснение
      - Какой бы из способов установки N серверов не был выбран.
      - Каждый экземпляр имеет набор св-в, которые д.б. уникальны.
      - Уникальны среди всех установленных в системе экземпляров.
      - Это позволяет избежать потенциального конфликта между экземплярами.
      - Эти свойства настраиваются в конфиге / конфигах.

    1. При работе через mysqld_multi

      datadir
      port
      socket
      pid-file

      general_log_file
      log-bin
      slow_query_log_file
      log-error

    2. При работе с несколькими разными mysql-серверами

      2.1. У них разные basedir и запускаются через mysqld_save

        port
        socket        

      2.2. В противном случае

        datadir
        port
        socket
        pid-file

        general_log_file
        log-bin
        slow_query_log_file
        log-error      

    3. Пояснения к значениям свойств

      # datadir
        - Каждый экземпляр mysql должен иметь свою datadir.
        - В datadir хранятся базы данных, которыми управляет экземпляр.

      # basedir
        - Если в системе установлено несколько mysql.
        - И каждый из mysql установлен в своём каталоге.
        - В basedir каждого из них надо указать этот каталог.
        - Это автоматически приведёт к тому, что каждый из mysql
          будет использовать свою datadir, лог-файл и pid, потому
          что последние рассчитываются относительно basedir.
        - Поэтому, если basedir для каждого mysql указан свой,
          то единственные опции, которые надо сделать у каждого
          mysql уникальными, это: socket и port.
        - Допустим, мы установили несколько mysql из tar-бинарников.
        - Тогда, каждый из mysql можно запустить, перейдя в его
          basedir, и использовав там команду bin/mysqld_safe.
        - Команда mysqld_safe передаст демону mysqld правильный
          basedir, поэтому, нужно лишь будет в конфиге каждого
          mysql указать правильные socket и port.

      # port
        - TCP/IP порт для подключения к mysql.

      # socket
        - Путь к сокету сервера mysql в Linux.

      # pid-file
        - Путь к файлу, где mysql хранит process id.

      # general_log_file      | это всё
      # log-bin               | свойства
      # slow_query_log_file   | для настройки
      # log-error             | логов

      # tmpdir
        - Путь к каталогу для временных файлов mysql.
        - Можно увеличить производительность, указав разные
          tmpdir для разных mysql, на разных жёстких дисках.


  > Работа с mysqld_multi

    --------------------------------------
    Подоглавление:

      # О чем этот подраздел
      # Общая теория о mysqld_multi (MM)

        - Синопсис
        - Option Group Number (GNR)
        - Про уникальность опций для каждого [mysqlN] 
        - Синтаксис команды mysqld_multi
        - Как mysqld_multi считывает конфиг
        - Про группы опций: [mysqld], [mysqldN], [mysqld_multi]
        - Список опций [options] для команды mysqld_multi
        - Пример конфига для mysqld_multi

      # Важные замечания по использованию mysqld_multi

        - У каждого экземпляра mysqlN д.б. свой каталог с данными
        - К каталогам данных у unix-пользователя mysql д.б. рекурсивные права 755
        - Для всех mysqlN д.б. одинаковый MySql-аккаунт для их остановки (программой mysqladmin)
        - TCP/IP порт и unix-socket д.б. своию для каждого mysqlN
        - У каждого экземпляра mysqld д.б. свой файл для PID

    --------------------------------------

    > О чем этот подраздел
      - Как использовать N экземпляров mysql в одной ОС.
      - Используя для управления ими софт mysqld_multi.
      - Это родной софт от mysql.
      - Здесь будет подробная, пошаговая инструкция.
      - Как, имя установленный mysql, добавить ещё N экземпляров.
      - Как всё настроить, и использовать в итоге с homestead.

    > Общая теория о mysqld_multi (MM)

      # Синопсис
        - Mysqld_multi служит для управления несколькими процессами mysqld.
        - Каждый такой процесс использует свой unix-socket файл.
        - А для работы с каждым из них используется свой порт.
        - Mysqld_multi может запускать/останавливать, сообщать их статус.

      # Option Group Number (GNR)
        - MM ищет в my.cnf сервера группы с именем [mysqlN].
        - Где N может быть любым положительным числом.
        - Номер N называют номером группы опций, сокращённо GNR.
        - GNR, по сути, служит ID для экземпляров mysql под управлением MM.
        - В my.cnf с помощью GNR для каждого экземпляра указываются свои опции.
        - Также, GNR используется для управляющих экземплярами команд в терминале.
        - Список доступных опций в [mysqlN] такой же, как в [mysql]

      # Про уникальность опций для каждого [mysqlN]
        - Для каждого [mysqlN] есть набор опций, значения которых д.б. уникальны.
        - Вот эти опции:

          -> Основные
                datadir
                port
                socket
                pid-file

          -> Опции лога     
                general_log_file
                log-bin
                slow_query_log_file
                log-error       

      # Синтаксис команды mysqld_multi
        - Вот синтаксис команды mysqld_multi:

            shell> mysqld_multi [options] {start|stop|reload|report} [GNR[,GNR] ...]

        - start|stop|reload|report указывают, какую операцию надо выполнить.
        - GNR указывает номер процесса mysqlN, которому предназначена операция.
        - Если GNR не указать, операция будет применена ко всем mysqlN.
        - В качестве GNR можно указать диапазон, вроде: 5-17.
        - Или же, можно перечислить GNR: 5,6,8,17.
        - Примеры:

          shell> mysqld_multi --example     | показать пример конфига для mysqld_multi
          shell> mysqld_multi report        | доложить о статусе всех экземпляров mysqlN
          shell> mysqld_multi start         | запустить все экземпляры mysqlN
          shell> mysqld_multi stop          | остановить все экземпляры mysqlN
          shell> mysqld_multi stop 8,10-13  | остановить экземпляры mysqlN с номерами 8,10,11,12,13 

      # Как mysqld_multi считывает конфиг

        1) С опцией "--no-defaults"
          - Никакие конфиги не считываются.

        2) С опцией "--defaults-file=file_name"
          - В качестве конфига читывается указанный файл.

        3) Без специализированных опций по этому поводу
          - Ищет конфиг по стандартным адресам.
          - И доп.конфиг, указанный в опции "--defaults-extra-file=file_name".
          - Если эта опция указана N раз, берётся лишь последнее значение.

      # Про группы опций: [mysqld], [mysqldN], [mysqld_multi]

        1) [mysqld]
          - Это группа общих опций для всех экземпляров mysql.

        2) [mysqldN]
          - Это группы опций с уникальными для каждого N-го экземпляра значениями.
          - Список опций, которые д.б. в этой группе:

            -> Основные
                  datadir
                  port
                  socket
                  pid-file

            -> Опции лога     
                  general_log_file
                  log-bin
                  slow_query_log_file
                  log-error          

        3) [mysqld_multi]
          - Это группа опций для команды mysqld_multi.

      # Список опций [options] для команды mysqld_multi

        --help                  | вывести справку и завершить
        --example               | показать пример конфига
        --log=file_name         | путь к файлу для ведения лога
        --mysqladmin=prog_name  | путь к бинарнику mysqladmin, который используется для остановки серверов
        --mysqld=prog_name      | путь к бинарнику mysqld
        --no-log                | выводить лог в stdout, а не писать в файл-лог
        --password=password     | пароль для работы с mysqladmin (обязательное значение)
        --silent                | тихий режим; отключает warnings
        --tcp-ip                | подключаться к серверам mysql через tcp/ip порт, а не unix socket
          - Эта опция влияет на операции stop и report.

        --user=user_name        | имя пользователя для работы с mysqladmin
        --verbose               | выводить более подробную инфу
        --version               | вывести версию и завершить

      # Пример конфига для mysqld_multi

        # This file should probably be in your home dir (~/.my.cnf)
        # or /etc/my.cnf
        # Version 2.1 by Jani Tolonen

        [mysqld_multi]
        mysqld     = /usr/local/bin/mysqld_safe
        mysqladmin = /usr/local/bin/mysqladmin
        user       = multi_admin
        password   = multipass

        [mysqld2]
        socket     = /tmp/mysql.sock2
        port       = 3307
        pid-file   = /usr/local/mysql/var2/hostname.pid2
        datadir    = /usr/local/mysql/var2
        language   = /usr/local/share/mysql/english
        user       = john

        [mysqld3]
        socket     = /tmp/mysql.sock3
        port       = 3308
        pid-file   = /usr/local/mysql/var3/hostname.pid3
        datadir    = /usr/local/mysql/var3
        language   = /usr/local/share/mysql/swedish
        user       = monty    

    > Важные замечания по использованию mysqld_multi

      # У каждого экземпляра mysqlN д.б. свой каталог с данными
        - Нельзя для >= 2 экземпляро mysql использовать 1 каталог с данными.
        - Это создаёт потенциально конфликтную ситуацию.
        - И может закончиться непредсказуемым образом.
        - Путь к каталогу данных указывается в конфиге для каждого
          экземпляра mysqlN в опции datadir.

      # К каталогам данных у unix-пользователя mysql д.б. рекурсивные права 755
        - Для работы с процессами mysqldN обычно используется отдельный unix-аккаунт.
        - Это аккаунт с именем mysql и группой mysql.
        - Необходимо выдать mysql:mysql рекурсивные права 755 на каталоги данных
          всех экземпляров mysqldN.

      # Для всех mysqlN д.б. одинаковый MySql-аккаунт для их остановки (программой mysqladmin)
        - Вот у нас есть N экземпляров mysql.
        - В каждом из них д.б. mysql-аккаунт с одним и тем же именем и паролем.
        - Этот аккаунт будет использоваться программой mysqladmin для остановки серверов.
        - Важно, чтобы этот аккаунт имел право SHUTDOWN.
        - Необходимо создать такой аккаунт, выполнив для каждого mysqld-сервера:

          shell> mysql -u root -S /tmp/mysql.sock -p
          Enter password:
          mysql> CREATE USER 'multi_admin'@'localhost' IDENTIFIED BY 'multipass';
          mysql> GRANT SHUTDOWN ON *.* TO 'multi_admin'@'localhost';      

        - В коде выше необходимо для каждого сервера подставить соотв.данные.

      # TCP/IP порт и unix-socket д.б. своию для каждого mysqlN
        - В конфиге, для каждого экземпляра надо указать свои сабжи.
        - Для каждого N-го экземпляра в его группе опций [mysqlN].

      # У каждого экземпляра mysqld д.б. свой файл для PID
        - Особенно, если для старта используется mysqld_safe.
        - В конфиге, для каждого экземпляра надо указать свой сабж.
        - Это надо сделать для каждого N-го экземпляра в его группе опций [mysqlN].
        - Используя опцию pid-file.


  > Образец конфига my.conf

    ##----------------------------##
    ## 1. Блок опций mysqld_multi ##
    ##----------------------------##
    [mysqld_multi]

      ## 1.1. Путь к файлу mysqld_safe ##
      ##-------------------------------##
      mysqld = /usr/bin/mysqld_safe

      ## 1.2. Путь к файлу mysqladmin ##
      ##------------------------------##
      mysqladmin =/usr/bin/mysqladmin

      ## 1.3. Имя mysql-аккаунта для работы с mysqladmin ##
      ##-------------------------------------------------##
      user = multi_admin

      ## 1.4. Пароль от mysql-аккаунта для работы с mysqladmin ##
      ##-------------------------------------------------------##
      pass = multipass


    ##-------------------------------------##
    ## 2. Блок общих для всех mysqld опций ##
    ##-------------------------------------##
    [mysqld]

      ##---------------------##
      ## 2.1. Основные опции ##
      ##---------------------##
      basedir         = /usr
      tmpdir          = /tmp
      lc-messages-dir = /usr/share/mysql
      skip-external-locking

      ##------------------------------------##
      ## 2.2. Ограничение доступа к серверу ##
      ##------------------------------------##
      ## Вместо skip-networking по умолчанию к серверу можно
      ## подключиться лишь с localhost, что тоже довольно безопасно
      bind-address = 0.0.0.0

      ##-------------------------------##
      ## 2.3. Тонкая настройка сервера ##
      ##-------------------------------##
      key_buffer              = 16M
      max_allowed_packet      = 16M
      thread_stack            = 192K
      thread_cache_size       = 8
        # This replaces the startup script and checks MyISAM tables if needed
        # the first time they are touched
      myisam-recover          = BACKUP
      # max_connections       = 100
      # table_cache           = 64
      # thread_concurrency    = 10

      ##-------------------------------------##
      ## 2.4. Настройка кэширования запросов ##
      ##-------------------------------------##
      query_cache_limit       = 1M
      query_cache_size        = 16M

      ##--------------------------------------------##
      ## 2.5. Настройка журналирования и репликации ##
      ##--------------------------------------------##

        # Here you can see queries with especially long duration
      # log_slow_queries       = /var/log/mysql/mysql-slow.log
      # long_query_time        = 2
      # log-queries-not-using-indexes

        # The following can be used as easy to replay backup logs or for replication.
        # note: if you are setting up a replication slave, see README.Debian about
        #       other settings you may need to change.
      # server-id             = 1
      # log_bin               = /var/log/mysql/mysql-bin.log
      expire_logs_days        = 10
      max_binlog_size         = 100M
      # binlog_do_db          = include_database_name
      # binlog_ignore_db      = include_database_name

      ##-----------------------##
      ## 2.6. Настройка InnoDB ##
      ##-----------------------##

      # InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.
      # Read the manual for more InnoDB related options. There are many!

      ##-----------------------------##
      ## 2.7. Настройка безопасности ##
      ##-----------------------------##

      # Read the manual, too, if you want chroot!
      # chroot = /var/lib/mysql/ \

      # For generating SSL certificates I recommend the OpenSSL GUI "tinyca".
      #
      # ssl-ca=/etc/mysql/cacert.pem
      # ssl-cert=/etc/mysql/server-cert.pem
      # ssl-key=/etc/mysql/server-key.pem

      ##-----------------------##
      ## 2.8. Прочие настройки ##
      ##-----------------------##
      [mysqldump]
      quick
      quote-names
      max_allowed_packet      = 16M

      [mysql]
      #no-auto-rehash # faster start of mysql but no tab completition

      [isamchk]
      key_buffer              = 16M


    ##----------------------------------------------##
    ## 3. Блок опций для экземпляра mysql c GNR = 1 ##
    ##----------------------------------------------##
    [mysqld1]

      ## 3.1. Путь к каталогу данных экземпляра ##
      ##----------------------------------------##
      datadir = /var/lib/mysql_multi/3306

      ## 3.2. Порт для подключения к экземпляру ##
      ##----------------------------------------##
      port = 3306

      ## 3.3. Путь к сокету экземпляра ##
      ##-------------------------------##
      socket = /var/run/mysqld/mysqld3306.sock

      ## 3.4. Путь к файлу для хранения Process ID экземпляра ##
      ##------------------------------------------------------##
      pid-file = /var/run/mysqld/mysqld3306.pid

      ## 3.5. Имя unix-пользователя для работы с экземпляром ##
      ##-----------------------------------------------------##
      user = mysql

      ## 3.6. Путь к файлу, где экземпляр должен вести лог ошибок ##
      ##----------------------------------------------------------##
      log_error = /var/log/mysql/error.log

      # innodb_data_home_dir = /var/lib/mysql_multi/3306


    ##----------------------------------------------##
    ## 4. Блок опций для экземпляра mysql c GNR = 2 ##
    ##----------------------------------------------##
    [mysqld2]

      ## 4.1. Путь к каталогу данных экземпляра ##
      ##----------------------------------------##
      datadir = /var/lib/mysql_multi/3307

      ## 4.2. Порт для подключения к экземпляру ##
      ##----------------------------------------##
      port = 3307

      ## 4.3. Путь к сокету экземпляра ##
      ##-------------------------------##
      socket = /var/run/mysqld/mysqld3307.sock

      ## 4.4. Путь к файлу для хранения Process ID экземпляра ##
      ##------------------------------------------------------##
      pid-file = /var/run/mysqld/mysqld3307.pid

      ## 4.5. Имя unix-пользователя для работы с экземпляром ##
      ##-----------------------------------------------------##
      user = mysql

      ## 4.6. Путь к файлу, где экземпляр должен вести лог ошибок ##
      ##----------------------------------------------------------##
      log_error = /var/log/mysql/error.log




    #
    # * IMPORTANT: Additional settings that can override those from this file!
    #   The files must end with '.cnf', otherwise they'll be ignored.
    #
    !includedir /etc/mysql/conf.d/


  > Пошаговая инструкция по преобразования 1-экземплярной mysql в мульти-экземплярную
    - На любом этапе, если что-то не работает, см.лог:
        sudo nano /var/log/mysql/error.log

    1. Остановить все запущенные экземпляры mysql
      - Для этого выполнить команды:

        sudo /etc/init.d/mysql stop     | если multi-сервера ещё не настроены
        mysqld_multi stop               | если multi-сервера уже настроены

    2. Создать каталог /var/lib/mysql_multi/
      - Если такового ещё не существует.
      - Для этого выполнить следующий код:

        sudo mkdir /var/lib/mysql_multi                  | создать

    3. Переместить каталог /var/lib/mysql в /var/lib/mysql_multi/3306
      - В случае, если multi-сервера ещё не были ранее настроены.
      - Для этого выполнить следующий код:

        sudo mv /var/lib/mysql /var/lib/mysql_multi/3306

    4. Создать каталог /var/lib/mysql_multi/3307, путём копирования из 3306    
      - Либо, заменить 3307 на номер порта нового, создаваемого экземпляра mysql.
      - Для этого выполнить следующий код:

        sudo cp -a /var/lib/mysql_multi/3306 /var/lib/mysql_multi/3307

    5. Выдать mysql_multi права 777, и назначить владельцем mysql:mysql, рекурсивно
      - Для этого выполнить следующий код: 

        sudo chmod 777 /var/lib/mysql_multi -R           | назначить права 777 рекурсивно
        sudo chown mysql:mysql /var/lib/mysql_multi -R   | сделать mysql:mysql владельцем рекурсивно    

    6. Модифицировать /etc/mysql/my.cnf
      - Использовать для этого приведённый выше шаблон.
      - Открыть конфиг можно так:

        sudo nano /etc/mysql/my.cnf

    7. Выдать /var/log/mysql права 777, и назначить владельцем mysql:mysql, рекурсивно
      - Для этого выполнить следующий код:

        sudo chmod 777 /var/log/mysql -R
        sudo chown mysql:mysql /var/log/mysql -R

    8. Прописать в apparmor новые права
      - Для этого открыть конфиг apparmor:

          sudo nano /etc/apparmor.d/usr.sbin.mysqld

      - И добавить туда (подставив везде вместо 3306 нужный порт):

          ##------------##
          ## mysql 3306 ##
          ##------------##

          /var/lib/mysql_multi rw,
          /usr/lib/mysql_multi/3306/plugin/ r,
          /usr/lib/mysql_multi/3306/plugin/*.so* mr,
          /var/lib/mysql_multi/3306/ r,
          /var/lib/mysql_multi/3306/** rwk,
          /var/run/mysqld/mysqld3306.pid rw,
          /var/run/mysqld/mysqld3306.sock rw,
          /run/mysqld/mysqld3306.pid rw,
          /run/mysqld/mysqld3306.sock w,

      - А затем перезагрузить apparmor:

          sudo /etc/init.d/apparmor reload

    9. Запустить все экземпляры mysql
      - Для этого выполнить:

          mysqld_multi start      | запустить
          mysqld_multi report     | проверить

    10. Создать нового пользователя multi_admin всем новым экземплярам
      - У которых ещё нет этого пользователя.
      - Для этого надо последовательно подключаться к каждому экземпляру.
      - Подставляя соотв.порт. Например, подключимся к 3307:

          mysql --host=127.0.0.1 --port=3307 -uhomestead -psecret

      - И создавать ему нового пользователя с правом SHUTDOWN:

          CREATE USER 'multi_admin'@'localhost' IDENTIFIED BY 'multipass';
          GRANT SHUTDOWN ON *.* TO 'multi_admin'@'localhost'; 

      - Посмотреть всех пользователей mysql можно так:

          SELECT CONCAT(QUOTE(user),'@',QUOTE(host)) UserAccount FROM mysql.user;

    11. Завершить работу всех экземпляров mysql
      - Чтобы убедиться, что эта функция работает.
      - Для этого выполнить:

          mysqld_multi stop       | завершить
          mysqld_multi report     | проверить

    12. Добавить переадресацию порта в конфиг homestead
      - Чтобы новый экземпляр mysql был доступен с хоста ВМ.
      - Для этого открываем homestead.yaml.
      - И добавляем там в ports:

          ports:
              - send: 33070
                to: 3307      

      - Надо убедиться, что не используются табы, а лишь пробелы.
      - И надо соблюдать именно такие отсупы.
      - Затем, homestead надо перезагрузить из терминала хоста:

          homestead halt
          homestead up
    
    13. Добавить включение всех экземпляров при запуске ОС
      - Если этого ещё не сделано ранее.
      - Сначала надо где-нибудь создать скрипт автозапуска.
      - Например, по адресу "/home/vagrant/mysqld_multi_startup.sh"
      - Вот его содержимое:

        /home/vagrant/mysqld_multi_startup.sh
        ------------------------------------------
          #!/bin/bash
          #

            # Проверить наличие каталога /var/run/mysqld
            # - Его может и не быть в наличии, ведь он при каждом перезапуске ОС пересоздаётся со стандартными правами.
            # - А ведь он нам нужен, чтобы назначить ему права 777.
            # - В этом случае, скрипт ждёт 5 секунд, и проверяет снова.

              # Подготовить переменную есть/нет
              IS="no";

              # Запустить цикл, пока IS=="no"
              while [ $IS == "no" ]; do

                # Если требуемые каталоги есть, то присвоить переменной IS значение "yes"
                if [ -d "/var/run/mysqld" ]; then
                  IS="yes"

                # В противном случае, подождать 5 сек., и попробовать снова
                fi
                sleep 5

              done

            # Назначить права 777 каталогу /var/run/mysqld
            sudo chmod 777 /var/run/mysqld -R

            # Назначить прова текущему логу ошибок
            sudo chmod 777 /var/log/mysql -R

            # Запустить все экземпляры mysql
            /usr/bin/mysqld_multi start

      - Затем надо добавить запуск этого скрипта на старте системы.
      - Для этого открываем crontab:

          crontab -e

      - И добавляем в конце такую строку:

          @reboot /home/vagrant/mysqld_multi_startup.sh


  > Возможные ошибки, и решения
    - На любом этапе, если что-то не работает, см.лог:
        sudo nano /var/log/mysql/error.log

    1. [ERROR] Failed to create file(file: './auto.cnf', errno 13)


Б10. Решение проблемы: Cookie::get() возвращает null

  --------------------------------------
  Подоглавление:

    # Проблема
    # Решение

  --------------------------------------

  > Введение
    - Ставим куку пользователю вот так:

        Cookie::queue('ivan', '123');

    - Потом хотим её получить вот так:

        Cookie::get('ivan')

    - А получаем почему то null. В чём дело?

  > Решение
    - У Laravel есть middleware под названием "EncryptCookies".
    - Он пытается расшифровать все входящие с запросом куки.
    - А также, он сверяет их MAC'и.
    - Если ему что-то не удаётся, он просто назначает куке null.
    - Вывод:

        Middleware "EncryptCookies" не может прочитать не 
        зашифрованные ранее laravel'ом с помощью Crypt::encrypt
        куки.

    - Когда мы ставик куку вот так:

        Cookie::queue('ivan', '123');

    - Эта кука не шифруется автоматически.
    - Поэтому, когда мы читаем её вот так:

        Cookie::get('ivan')

    - Middleware "EncryptCookies" назначает её null.
    - Чтобы этого не происходило, надо ставить куку так:

        Cookie::queue('ivan', Crypt::encrypt('123'));


В1. Новая архитектура приложений

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

  # Типы пакетов
  # Описание типов пакетов
  # Схемы прямых зависимостей
  # События вместо сервис-контейнеров и DI
  # Как работают D,L,W-пакеты
  # Как работают K-пакеты
  # Домены и URI
  # Пространства имён пакетов
  # События Event и Broadcast
  # Логика выбора L-шаблона для D-пакета
  # Автообновление баз данных M-пакетов при composer update
  # Авторегистрация сервис-провайдеров пакетов
  # Сразу редактировать локальные репозитории
  # Создание/Удаление ресурсов приложения командами из терминала
  # Автоматический динамический роутинг
  # Автоматическое меню для авто- и ручных-роутов
  # Аутентификация и авторизация
  # Локализация
  # Подробнее о конфигах пакетов
  # Автоматическая минификация css и js
  # Удалённое создание новых релизов
  # Просто немного про виджеты
  # Автоматизация клиент-серверной валидации
  # Связи между таблицами баз данных разных M-пакетов
  # 

--------------------------------------

> Ссылки


> Введение
  - Сейчас 31 декабря 2015 года.
  - Уже около 2 лет я плотно работаю с Laravel.
  - К этому времени удалось построить из него модульное приложение.
  - Но построенный вариант оказался не очень удобен на практике.
  - В этой главе я сконцентрирую весь свой опыт web-разработки.
  - Чтобы в итоге получить идеальную архитектуру web-приложения.
  - Максимально удобную для разработки, на основе Laravel ~5.2.


> Типы пакетов

    M - базы данных и логика.

    D - blade-документы для @extends blade-шаблонов.
    L - blade-шаблоны.
    W - blade-документы (виджеты) для @include в другие blade-документы. 

    R - ресурсы общего назначения.
    P - public-ресурсы (js/css/img).
    K - knockout-компоненты.

      ● Каждый пакет - отдельный пакет composer.
      ● Пакет каждого типа имеет свою структуру.


> Описание типов пакетов

  # M - базы данных и логика

    ● Формат ID: M1, M2, ...
    ● Файловая структура:

      /M1
        readme.md
        composer.json
        settings.php
        ServiceProvider.php
        /Database
        /Middlewares
          AfterMiddleware.php
          BeforeMiddleware.php
        /Models
        /Commands
        /Console
        /EventHandlers
        /Cnfupds

  # D - blade-документы для @extends blade-шаблонов

    ● Формат ID: D1, D2, ...
    ● Файловая структура:

      /D1
        readme.md
        composer.json
        settings.php
        ServiceProvider.php
        Controller.php
        view.blade.php
        /Localization
          /en
            localization.php
          /ru
            localization.php
        /Public
          /Images
        /Minify
          c.css
          m.js
          f.js
          j.js
        /Cnfupds

  # L - blade-шаблоны

    ● Формат ID: L1, L2, ...
    ● Файловая структура:

      /L1
        readme.md
        composer.json
        settings.php
        ServiceProvider.php
        Composer.php
        Controller.php
        layout.blade.php
        /Localization
          /en
            localization.php
          /ru
            localization.php
        /Public
          /Images
        /Minify
          c.css
          m.js
          f.js
          j.js
        /Cnfupds

  # W - blade-документы (виджеты) для @include в другие blade-документы

    ● Формат ID: W1, W2, ...
    ● Файловая структура:

      /L1
        readme.md
        composer.json
        settings.php
        ServiceProvider.php
        Composer.php
        Controller.php
        widget.blade.php
        /Localization
          /en
            localization.php
          /ru
            localization.php
        /Public
          /Images
        /Minify
          c.css
          m.js
          f.js
          j.js
        /Cnfupds

  # R - ресурсы общего назначения

    ● Формат ID: R1, R2, ...
    ● Файловая структура строго не регламентирована.
      Но ниже описаны обязательные файлы:

      /R1
        readme.md
        composer.json
        ServiceProvider.php

  # P - public-ресурсы (js/css/img)

    ● Формат ID: P1, P2, ...
    ● Файловая структура:

      /P1
        readme.md
        composer.json
        ServiceProvider.php
        /Public
          /Images
        /Minify
          c.css
          j.js

  # K - knockout-компоненты

    ● Формат ID: K1, K2, ...
    ● Файловая структура:

      /K1
        readme.md
        composer.json
        ServiceProvider.php
        /Public
          /Images
        /Minify
          c.css
          j.js

> Схемы прямых зависимостей

    M <--- R                R <--- R
    D <--- M,L,W,R,P,K      P <--- P   
    L <--- M,W,R,P,K        K <--- P
    W <--- M,R,P,K
  
      ● Пакеты разных типов могут зависеть друг от друга.
      ● Допустимые схемы зависимостей см.выше.
      ● Зависимости пакета прописываются в его composer.json.


> События вместо сервис-контейнеров и DI
  - SC/DI в первую очередь обеспечивают независимость интерфейсов от реализаций.
  - Однако, в нашей пакетной реализации, для них места нет.
  - Ту же функцию у нас с успехом выполняют события.


> Как работают D,L,W-пакеты

  # Работа D

    Общее
      - D могут работать только с предназначенными для них L.
      - D не предназначены для работы без L.

    URL
      - Каждый D в приложении имеет свой URL (домен и URI).
      - Они указываются в опубликованном файле настроек пакета.

    Формирование, данные
      - Представление D формируется в контроллере D-пакета.
      - Оттуда же в D передаются данные.

    AJAX-запросы
      - AJAX-запросы от D ловит и обрабатывает тот же контроллер.

  # Работа L

    Общее
      - L предназначены для того, чтобы D от них зависели.
      - L не предназначены для работы без D.

    URL
      - Каждый L в приложении имеет свой URL (домен и URI).
      - Они указываются в опубликованном файле настроек пакета.
      - Вродет таких: site.ru/api/l1, site.ru/api/l2

    Формирование, данные
      - Представление L формируется в контроллере D-пакета.
      - Данные для L передаются из композера представления L-пакета.

    AJAX-запросы
      - Посылаются контроллеру L-пакета по его URL.
      - Например, на: site.ru/api/l1

  # Работа W

    Общее
      - W предназначены для того, чтобы @include'ить их в D,L-представления.
      - W не предназначены для работы без D или L.

    URL
      - Каждый W в приложении имеет свой URL (домен и URI).
      - Они указываются в опубликованном файле настроек пакета.
      - Вродет таких: site.ru/api/w1, site.ru/api/w2

    Формирование, данные
      - Представление W формируется в контроллере D-пакета.
      - Данные для W передаются из композера представления W-пакета.

    AJAX-запросы
      - Посылаются контроллеру W-пакета по его URL.
      - Например, на: site.ru/api/l1


> Как работают K-пакеты

  # Общее
    - От K-пакетов могут зависеть D,L,W-пакеты.
    - K-пакет содержит knockoutjs-компоненты.

  # Передача данных компоненту
    - За это отвечает использующий этот компонент D,L,W-пакет.
    - Этот пакет имеет модель компонента у себя в наблюдаемой.
    - И должен записать туда требующиеся компоненту данные.

  # AJAX-запросы

    Общее
      - Компонент шлёт AJAX-запросы контроллеру того пакета,
        который его использует.
      - Это могут быть D,L,W-пакеты.
      - У каждого из D,L,W-пакетов есть собственная модель.
      - Если пакет использует компонент, то модель компонента
        записывается в наблюдаемую модели этого пакета.
      - И пакет обязан записать в модель компонента, в наблюдаемую
        ajaxurl URL своего API.

    Ключ
      - В каждом AJAX-запросе от K-пакета, внутри data, должно
        быть значение с ключём "key".
      - В нём должен лежать ключ, указывающий:
          1) На то, от какого K-пакета пришёл запрос.
          2) Какое действие требуется сделать.
      - Формат ключа таков: [ID K-пакета]:[ID действия].
      - Примеры: "K1:1", "K1:2", "K2:1".


> Домены и URI
  - D,L,W-пакетам назначаются домены и URI.
  - Происходит это в опубликованных файлах настроек этих пакетов.
    Пример:

    'domain' => 'acme.com',
    'uri'    => '/users'

  - По URL D-пакета можно открыть этот документ.
  - По URL L,W-пакетов находятся их API для обработки AJAX-запросов.


> Пространства имён пакетов

  # Общая информация
    - Каждый пакет имеет своё пространство имён.
    - Имя пр.имён совпадает с ID пакета (напр.: M1, D1, L1, ...).

  # Пространство имён указывается в composer.json пакета
    - Например, есть у нас пакет M1.
    - В его composer.json указываем пр.имён:

      "autoload": {
        "psr-4": {"M5\\": ""}
      }

  # Пространство имён для разрабатываемых пакетов
    - Указывается в composer.json всего проекта.
    - Аналогичным образом, как и в composer.json пакета.


> События Event и Broadcast

  # Общая информация
    - Архитектура приложения подразумевает наличие лишь 2-х событий.
    - Это события Event (обычное) и Broadcast (трансляция).

  # Событие Event
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "keys" - является обязательным.
    - Он содержит массив строк-ключей.
    - Каждый обработчик реагирует только на определённые ключи.
    - Если в keys есть хотя бы 1 такой ключ, обработчик среагирует.

  # Событие Broadcast
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "channels" - является обязательным.
    - Он содержит массив строк-каналов.
    - Клиенты-подписчики реагируют на сообщения лишь по определёным каналам.
    - По аналогии, как обработчики реагируют лишь на определнные ключи.


> Регистрация и публикация ресурсов пакетов

  # Общая информация
    - Всем и каждому пакету требуется регистрировать и/или публиковать ресурсы.
    - У каждого пакета за этот процесс отвечает файл ServiceProvider.php.
    - Содержимое его зависит от типа пакета.
    - Ведь каждому типу пакета требуется регистр-ть и/или публиковать что-то своё.

  # Когда производится
    - У пакета M1 есть в конфиге опция "development_mode".
    - Если она true, то при каждом запросе.
    - Если она false, то при каждом composer update приложения.

  # Где запускается
    - У пакета M1 есть before middleware.
    - Также, у него есть консольная команда "m1:allrespublish".
    - В middleware реализуется зависящая от "development_mode" логика.
    - Эта middleware дёргается при каждом запросе к приложению.
    - Естественно, значение "development_mode" следует кэшировать на N минут.

  # M-пакеты

    Публикация
      1) Публикация файла settings.php в /config
        - Новый файл должен иметь имя, совпадающее с ID пакета (напр.: M1.php).

    Регистрация
      1) Регистрация Before- и After-middleware
      2) Регистрация пар 'событие-обработчик'
      3) Регистрация консольных команд.
      4) Файлы локализации L-пакета из /Localization
        - Из /ru в /lang/ru, из /en в /lang/en и т.д.
        - С именами, совпадающими с именем пакета (напр.: M1.php).

    Минификация
      - Нет.

  # D-пакеты

    Публикация
      1) Публикация файла settings.php в /config
        - Новый файл должен иметь имя, совпадающее с ID пакета (напр.: D1.php).
      2) Содержимое каталога /Public
      3) Файлы локализации D-пакета из /Localization
        - Из /ru в /lang/ru, из /en в /lang/en и т.д.
        - С именами, совпадающими с именем пакета (напр.: D1.php).

    Регистрация
      1) Регистрация представления
        - Пространство имён для представления совпадает с ID D-пакета.

    Минификация
      - Требуется. В Public для каждого D-пакета.
      - c.min.css / j.min.js

  # L-пакеты

    Публикация
      1) Публикация файла settings.php в /config
        - Новый файл должен иметь имя, совпадающее с ID пакета (напр.: L1.php).
      2) Содержимое каталога /Public
      3) Файлы локализации L-пакета из /Localization
        - Из /ru в /lang/ru, из /en в /lang/en и т.д.
        - С именами, совпадающими с именем пакета (напр.: L1.php).

    Регистрация
      1) Регистрация представления-шаблона
        - Пространство имён для представления совпадает с ID L-пакета.
      2) Регистрация композера представления шаблона

    Минификация
      - Нет.

  # W-пакеты

    Публикация
      1) Публикация файла settings.php в /config
        - Новый файл должен иметь имя, совпадающее с ID пакета (напр.: W1.php).
      2) Содержимое каталога /Public
      3) Файлы локализации L-пакета из /Localization
        - Из /ru в /lang/ru, из /en в /lang/en и т.д.
        - С именами, совпадающими с именем пакета (напр.: W1.php).

    Регистрация
      1) Регистрация представления-виджета
        - Пространство имён для представления совпадает с ID W-пакета.
      2) Регистрация композера представления шаблона

    Минификация
      - Нет.

  # R-пакеты
    - Никаких стандартных регистраций/публикаций нет.
    - Содержимое ServiceProvider.php у каждого R-пакета своё.

  # P-пакеты

    Публикация
      1) Содержимое каталога /Public

    Регистрация
      - Нет.

    Минификация
      - Нет.

  # K-пакеты

    Публикация
      1) Содержимое каталога /Public

    Регистрация
      - Нет.

    Минификация
      - Нет.


> Логика выбора L-шаблона для D-пакета

  # D-пакет может зависеть от >= 1 L-шаблона
    - Зависимости эти прописаны в composer.json D-пакета.
    - Минимум он может зависеть от 1 шаблона.
    - Но никто не запрещает добавить > 1 шаблона в зависимости.

  # Стандартная логика выбора шаблона
    - По умолчанию применяется 1-й шаблон.
    - То есть, который стоит выше всех composer.json D-пакета.
    - Остальные же шаблоны игнорируются.

  # Реализация кастомной логики выбора шаблона
    - Имя выбранного шаблона передаётся представлению D-пакета из контроллера.
    - Как выбирается это имя по умолчанию, указано выше.
    - Но никто не запрещает реализовать в контроллере кастомную логику.
    - Выбор шаблона, к примеру, может зависеть от содержимого query string GET-запроса.


> Автообновление баз данных M-пакетов при composer update

  # Суть
    - У каждого M-пакета есть каталог Database.
    - В нём должны лежать файлы *.sql.
    - В качестве имён должны быть использованы цифры >= 1.
    - Нумерация должна начинаться с 1, с инкрементацие по 1.
    - Например: 1.sql, 2.sql, 3.sql.
    - Файл 1.sql содержит sql для установки начальной БД модуля.
    - Файлы с именем >= 2 - это sql-коды для обновления БД модуля.
    - Также, в Database лежит .mwb файл с workbench-моделью модуля.
    - Вот как это всё выглядит (пример):

      /Database
        model.mwb
        1.sql
        2.sql
        3.sql

  # Когда происходит обновление БД модуля
    - Обновление производит скрипт из M1.
    - Который выполняется при каждом composer update.

  # Ведение истории
    - Нельзя при каждом composer update выполнять все sql-файлы.
    - Так можно легко потерять важные данные.
    - Например, при таком раскладе, при каждом composer update
      все данные из таблицы m1.table будут теряться:
        1.sql - создать таблицу m1.table
        2.sql - удалить таблицу m1.table
        3.sql - создать таблицу m1.table
    - Чтобы этого не происходило, скрипту требуется знать,
      какие .sql файлы для модуля уже были ранее выполнены.
    - Эти данные записываются в файле настроек модуля в config/*
    - У каждого модуля в файле настроек есть настройка "DatabaseUpdates".
    - Она должна содержать массив цифр, обозначающих имена .sql файлов.
    - И означает, что соотв. .sql-обновления уже были применены,
      и выполнять их повторно не требуется.

        'DatabaseUpdates' => [1,2,3],


> Авторегистрация сервис-провайдеров пакетов

  # Суть
    - Сервис-провайдеры есть у пакетов всех типов.
    - При установке пакета СП надо добавлять в app.php.
    - При удалении пакета СП надо удалять из app.php.

  # Это делает специальная консольная команда
    - Она выполняется при каждом composer update.


> Сразу редактировать локальные репозитории

   "psr-4": {
       "App\\": "app/",
       "M8\\": "vendor/4gekkman/M8/",
       "M10\\": "vendor/4gekkman/M10/"
   }

     ● В dev.app пакеты не устанавл-ся.
     ● В require его composer.json их нет.
     ● Вместо, в psr-4 прописаны их простр-ва имён.
     ● Все пакеты находятся в vendor/4gekkman.
     ● Они одновременно локаль.репозит-ии github.
     ● Изменения в них сохр.в репы на gh каждые 3ч.
     ● Это лучше, чем если бы они не были лок.ре-ми.
     ● Иначе пришлось бы муторно копировать вручную.


> Создание/Удаление ресурсов приложения командами из терминала

  # Суть
    - Приложение поддерживает несколько разных типов пакетов.
    - Каждый из них имеет свою, особую структуру данных.
    - Принцип создания нового пакета любого типа прост.
    - Надо скопировать шаблон в /vendor/4gekkman, переименовать
      в ID пакета (уникальный у вендора), и внести ряд изменений
      в файлы пакета для подготовки его к работе.
    - Принцип удаления похож, но всё делается в обратном порядке.
    - Почему неудобно проделывать эти операции вручную:
      1) Это занимает прилично времени.
      2) Нужно постоянно держать в голове кучу нюансов.
      3) Приложением трудно пользоваться другим людям.
    - Речь идёт не только о целых пакетах, но и их частях,
      например, командах, обработчиках и т.д.

  # Автоматизация
    - Поэтому, следует автоматизировать создание/удаление ресурсов.
    - Это можно сделать с помощью пар команда / консольная команда.

  # Автоматизация создания ресурсов
    - За создание должна отвечать к.команда: "m1:new".
    - Она должна выспрашивать, какой ресурс надо создать.
    - Выспрашивать необходимые для его создания параметры.
    - И запускать соответствующую команду для его создания.
    - И, в итоге, создавать ресурс, если надо регистрировать и т.д.
    - За создание разных ресурсов отвечают разные команды.
    - Но консольная команда одна.

  # Автоматизация удаления ресурсов
    - По аналогии с созданием, только к.команда: "m1:del".


> Автоматический динамический роутинг

  # Общая информация
    - За роутинг отвечает отдельный M-пакет.
    - В нём есть дополнительный файл routes.php.
    - Он регистрируется в сервис-провайдере M-пакета.
    - И заменяет собой всё содержимое routes.php файла laravel.

  # Для каких пакетов актуален роутинг
    - Для D,L,W-пакетов.
    - У D-пакетов URL ведёт на их контроллер, который обрабатывает
      как GET-, так и POST-запросы.
    - У L,W-пакетов URL также ведёт на их контроллеры, но они
      предназначены для обработки AJAX POST-запросов.

  # Автоматический сбор информации для M-пакета роутера
    - Будем называть M-пакет, осуществляющий роутинг, роутером.
    - У роутера есть обработчик, реагирующий на событие
      с ключём "m1:afterupdate".
    - Это событие в возбуждается при выполнении команды
      парсинга приложения в M1.
    - Вместе с событием передаётся вся собранная парсером
      структура приложения.
    - Для каждого D,L,W-пакета парсер, среди прочего, извлекает
      из его конфига домен и URI.
    - Соответственно, связка информации ID D,L,W-пакета, его домен и URI,
      и является роутом. Определённый URL указывает на контроллер
      определённого D-пакета.

  # Возможность добавлять ручные роуты
    - Автоматические роуты редактировать нельзя.
    - Их можно только включить / отключить.
    - А вот ручные роуты добавлять / удалять / редактировать можно.
    - И делать это можно в специальном D-интерфейсе M-пакета - роутера.


> Автоматическое меню для авто- и ручных-роутов

  # Общая информация
    - Здесь описан общий принцип организации подобного меню.
    - Для такого меню следует создать отдельный M-пакет.
    - Меню требуется только для роутов D-пакетов.

  # Автоматический сбор данных при обновлении роутера
    - После парсинга приложения в M1 обработчик в Роутере ловит событие.
    - В конце своей работы, он также отправляет событие с опред.ключём.
    - В событии данные по авто.роутам D-пакетов, и всем ручным роутам.
    - Из этих роутов формируются пункты меню.
    - У каждого роута есть имя с разными локализациями.

  # Группировка
    - Пункты меню можно добавлять в разные группы (это уже вручную).
    - Каждой группе можно назначать иконку в опред.формате.
    - Иконку можно брать из любого подключенного (зависимости) P-пакета.


> Аутентификация и авторизация

  # Общая информация
    - За аутентификацию / авторизацию отвечает отдельный M-пакет.
    - Этот же M-пакет отвечает за управление пользователями и правами.
    - Будем называть этот M-пакет "пользовательским".

  # Где проводится аутентификация
    - Аутентификация проводится в before middleware польз-кого пакета.

  # Где проводится авторизация

    1) Авторизация доступа к роутам
      - Для каждого URL каждого роута можно настроить доступ.
      - По сути, это доступ к документам D,W,L-пакетов.
      - Она проводится в том же before middleware польз-кого пакета.
      - Просто проверяет URL запроса, смотрит ID запрашивающего
        пользователя, и смотрит, есть ли доступ.

    2) Авторизация команд
      - Для каждой команды каждого M-пакета можно настраивать доступ.
      - Запуск любой команды производится с помощью php-хелпера runcommand.
      - Первым делом этот хелпер проверяет наличие прав.
      - Он смотрит полный путь к команде, смотрит ID запрашивающего
        пользователя, и смотрит, есть ли доступ.
      - И только если доступ есть, runcommand выполняет команду.
      - А если нет, то возвращает соответствующий код ошибки.


> Локализация

  # Общая информация
    - Лучше сразу делать приложение с возможностями локализациями.
    - Наверняка потребуется разрабатывать приложение для пользователей,
      разговаривающих на разных языках.
    - За основу следует взять 2 языка, RU и EN.
    - Всё приложение должно "из коробки" поддерживать эти языки.

  # Глобальная локализация
    - В конфиге /config/app.php есть опция "locale".
    - Это и есть параметр локализации всего приложения.
    - По умолчанию, все пакеты ориентируются именно на неё.

  # Локальная локализация
    - Доступна для M,D,L,W-пакетов.
    - P,K-пакеты используют лишь глобальную локализацию.
    - В конфигах M,D,L,W-пакетов также есть опция locale.
    - По умолчанию, для неё доступны 3 значения:
      "RU", "EN".
    - По умолчанию, везде стоит значение "".
    - Это означает, что надо использовать глобальную локаль.

  # Локализация в M,D,L,W-пакетах

    Общее
      - Файлы локализации всего приложения лежат в /resources/lang/*
      - У каждого M,D,L,W-пакета есть каталог /Localization:

          /Localization
            /en
              localization.php
            /ru
              localization.php

      - Публикация файлов-локализаций производится в сервис-провайдерах
        этих пакетов.
      - Они публикуются в /resources/lang, в каталоге /ru, /en и т.д.
      - Файлы локализации переименовываются в ID D,L,W-пакета.
      - Допустим, при публикации файлов локализации пакета D1:

          /resources
            /lang
              /ru
                D1.php
              /en
                D1.php

    Как пользоваться
      - С помощью php-хелпера trans.
      - Например, в D1 есть фраза с ключём "welcome".
      - А пакет D1 использует глобальную локаль (она EN).
      - Тогда, извлечь фразу с ключём "welcome" можно
        так:
          trans('en.d1.welcome')        // где-нибудь в контроллере D1
          {{ trans('en.d1.welcome') }}  // где-нибудь в представлении D1

  # Локализация в P,K-пакетах

    Получение глобальной локали
      - Контроллер любого D-пакета должен возвращать глобальную локаль.
      - В глобальной js-переменной.
      - Все скрипты из P,K-пакетов ищут эту переменную.
      - И смотрят, какая там стоит локаль.

    Захардкоженная локализация
      - Локализация в P,K-пакетах захардкожена в JS-коде.
      - На каком языке выводить инфу, зависит от глобальной локали (см.выше).


> Подробнее о конфигах пакетов

  # Конфиги публикуются для M,D,L,W-пакетов
    - У них есть в структуре файлы settings.php

  # Как публикуются
    - У каждого из этих пакетов есть сервис провайдер.
    - В нём прописана публикация конфигов в /config
    - Имя конфига каждого пакета равно имени его ID.
    - Например: D1.php, W1.php, M1.php, и т.д.
    - Публикация производится вместе со всеми остальными ресурсами.
    - Если режим development mode включен, то при каждом запросе и allrespublish.
    - Если выключен, то только при каждом allrespublish.

  # Как обновляются
    - Речь ниже пойдёт, разумеется, тольк о M,D,L,W-пакетах.
    - У каждого из них есть каталог файлами:

      /Cnfupds
        cfgupdate_1.php    // Это Laravel-команда
        cfgupdate_2.php    // Это Laravel-команда
        ...

    - Каждый файл содержит код для обновления конфига пакета.
    - И у каждого в конфиге есть массив "cnfupdshistory".
    - Также имеется команда С33_mdlw_cfgs_update и
      консольная команда T11_mdlw_cfgs_update.
    - Команда С33 выполняется при запуске к.команды m1:afterupdate.
    - Она извлекает содержимое cnfupdshistory.
    - cnfupdshistory может содержать возрастающую последовательность
      цифр типа ['1','2','3'] и так далее.
    - Далее, она извлекает массив цифр из имён файлов из Cnfupds.
    - Если в cnfupdshistory нет цифры для каких либо файлов,
      то с команда с помощью exec выполняет (в порядке возрастания)
      код из этих файлов. И записывает их цифры-имена в cnfupdshistory.

  # Примеры работы

    Общие вводные
    -------------
      - В /Cnfupds уже 3 файла: cfgupdate_1.php, cfgupdate_2.php, cfgupdate_3.php
      - Массив cnfupdshistory: ['1','2','3'].

    Сценарий 1 - установка с нуля
    -----------------------------
      - В /config записывается новый конфиг пакета.
      - Никакие файлы из /cnfupds не устанавливаются.
      - Всё ОК.

    Сценарий 2 - установка на ['1']
    -------------------------------
      - Пакет был установлен ранее, конфиг уже опубликован.
      - Массив cnfupdshistory: ['1'].
      - Команда C33 выполняет сначала 2.php, затем 3.php.
      - И записывает cnfupdshistory: ['1','2','3'].

> Автоматическая минификация css и js

  # Минификация выполняется для D-пакетов
    - Файлы c.min.css и j.min.js помещаются в public для D-пакета.

  # Общая информация
    - CSS и JS для минификации собираются с D,L,W,P,K-пакетов.
    - Эти файлы лежат в каталогах /Minify каждого из этих пакетов.
    - Содержимое /Minify отличается в зависимости от типа пакета:

      D-пакеты    L-пакеты    W-пакеты    P-пакеты    K-пакеты
          c.css       c.css       c.css       c.css       c.css
          m.js        m.js        m.js        j.js        j.js
          f.js        f.js        f.js
          j.js        j.js        j.js

    - Минификация осуществляется пакетом matthiasmullie/minify.

  # CSS и JS ресурсы D,L,W,P,K-пакетов не доступны публично
    - Эти ресурсы перечислены выше, они содержат комменты и не минифицированы.
    - Они не доступны для клиентов, и не публикуются в public проекта.
    - Вместо этого они собираются для D-пакетов в нужном порядке.
    - И публикуются в Public'ах D-пакетов в виде c.min.css и j.min.js.


> Удалённое создание новых релизов

  # Где написана текущая версия пакета
    - В composer.json пакета. В extra -> version.
    - Версия в формате 1.0.0.
    - Последняя цифра: патч. Средняя: минорная версия. Первая - мажорная.

  # Создание релиза на GitHub через API
    - Сабж можно создать через API.

  # Использование команд в M1
    - В M1 должны быть 3 команды:

      newrelease_patch [id пакета]    // создать новый patch-релиз
      newrelease_minor [id пакета]    // создать новый minor-релиз
      newrelease_major [id пакета]    // создать новый major-релиз

    - Скрипт команды смотрит версию пакета в его composer.json.
    - Добавляе к ней единицу:

      +0.0.1    // в случае newrelease_patch
      +0.1.0    // в случае newrelease_minor
      +1.0.0    // в случае newrelease_major

    - И создаёт новый релиз на GitHub через его API.

  # Ключ для доступа к GitHub
    - Указывается в конфиге модуля M1.


> Просто немного про виджеты

  # Как работает
    - Представление виджета вставляется в любое blade-представление.
    - Это происходит с помощью blade-директивы @include.
    - Композер представления формирует данные для виджета.
    - Как правило, виджет привязан к M-пакету, и зависит от него.
    - Как правило, виджет состоит из KO-компонента.
    - Присланные данные вставляются в модель этого компонента.
    - И компонент формирует нужный HTML-код.
    - Плюс, в компоненте могут быть настроены web-сокеты.

  # Для чего пригодятся виджеты
    - Допустим, есть шаблон административной части.
    - В нём есть аналог системного трея в операционных системах.
    - Там должен быть список иконок, представляющих M-пакеты.
    - Список переменный, зависящий от зависимостей шаблона.
    - В этой ситуации очень удобно использовать W-пакеты.
    - Шаблон будет показывать лишь интерфейсы W-пакетов,
      зависимости от которых прописаны в его composer.json.

  # Включение/выключение виджетов
    - Допустим, C,L-пакет зависит от 10 виджетов.
    - Эти зависимости прописаны в его composer.json.
    - Но за отображение виджетов отвечает логика пользовательского кода.
    - Это зависит от кода представления, и от кода серверной части.
    - Как правило, серв.ч. должна передать в представление массив.
    - А в массиве список адресов к виджетам, которые надо отобразить.
    - Соответственно, логика "какой виджет какому пользователю показывать"
      должна находитсья в серверной части, в месте, где формируется
      этот самый массив.


> Автоматизация клиент-серверной валидации

  # За клиент-серверную валидацию отвечают P- и R-пакеты
    - P-пакет содержит JS-библиотеку для осуществления валидации:

      1] j.js
        - Это библиотека для осуществления JS-валидации.
        - Функции из неё лежат в отдельномо объекте.

    - R-пакет содержит PHP-библиотеку для осуществления валидации:

      1] validator.php
        - Это библиотека для осуещствления PHP-валидации.
        - Функции из неё префиксятся ID пакета (напр., "J1_").

      2] ServiceProvider.php
        - Здесь подключается validator.php (помимо прочего).

  # Алиасы для правил
    - Каждое правило валидации имеет своё цифровое ID.
    - Но сложно запомнить чисто по номеру, какое правило какую валидацию делает.
    - Поэтому, кажодму правилу можно ещё назначить буквенный алиас.

  # Валидация в клиенте
    - В клиенте для передачи на сервер готовится JSON-строка.
    - Она имеет определённую, строго заданную структуру.
    - Для свойств-данных там можно указать, надо ли валидировать.
    - И если надо, то каким правилом, и каков текст ошибки.
    - Сам вызов валидатора вшит в коммуникационную функцию.
    - В её параметрах можно задать 2 колбэка (успех/неудача валидации).
    - Если они не заданы, то будут применены стандартные сценарии.

  # Валидация на сервере
    - Валидация свойств-данных проводится в контроллере.
    - Контроллер ожидает получить данные строго заданной структуры.
    - Контроллер передаёт все поступившие данные в валидатор как есть.
    - Валидатор валидирует те св-ва-данные, которым это было назначено.
    - Валидатор возвращает массив с 2-мя ключами: status и data.
    - В случае неудачи: status == -3, data содержит строку с ошибкой.
    - В случае успеха: status == 0, data пуста.

  # Локализация
    - Чтобы не паритсья с локализацией.


> Связи между таблицами баз данных разных M-пакетов

  # Введение в проблемы

    1) Хранение межпакетных данных
      - В M4 есть таблица MD1_routes.
      - В M1 есть таблица MD2_packages.
      - Приложению нужны связи между роутами и пакетами.
      - Оно хочет знать для каждого пакета, с какими роутами он связан.
      - Оно хочет знать для каждого роута, с какими пакетами он связан.
      - Для этой связи требуется наличие pivot-таблицы.
      - Но где её хранить?

    2) Обеспечение наличия связей в моделях
      - M1 и M4 полностью независимы друг от друга.
      - И могут как присутствовать в системе, так и отсутствовать.
      - Если оба присутствуют, связи в соотв.моделях должны быть.
      - Если оба отсутствуют, связей с воотв.моделях быть не должно.

    3) Безопасный запрос данных из БД другой модели
      - M4 может потребоваться запросить из M1 данные.
      - Это можно сделать через событие, но это не удобно.
      - При прямом запросе, если M4 не будет в системе, будет error.

    4) Очистка pivot-таблицы в зависимом M-пакета
      - Сначала M1 и M4 могут присутствовать в системе.
      - В pivot-таблице их связи в M4 могут накапливаться данные.
      - Потом M4 может быть удалена вместе с БД.
      - А потом M4 может быть установлена заново, вместе с БД.
      - На этом этапе, данные в pivot в M4 уже являются неверными.
      - Их следует удалить.

  # Решение всех проблем

    1) Хранение межпакетных данных
      - Эти данные хранятся в базе зависящего M-пакета.
      - То есть того, кому нужны данные от связанного M-пакета.
      - Они хранятся в pivot-таблице с именем "/^md200[0-9]{1}$/"
      - В этом M-пакете, связанная таблица должна быть связана
        с этой pivot-таблицей как обычно, 1:n связью
      - Pivot-таблица должна находиться на жёлтой плашке "Foreign".
      - На плашке также должен присутствовать текстовый комментарий.
      - В description таблицы должна быть json-строка с информацией:

          {
            "mpackid":"M1",           // С каким M-пакетом связь
            "table":"MD2_packages",   // С какой таблицей в этом M-пакете связь
            "version":">=1.0"          // Требуемая версия М-пакета
          }

      - Эта инфа будет использована для авто-создания связей в моделях.
      - Доступ к этим данным можно осуществлять с помощью такого запроса:

          DB::select("SELECT table_comment FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='m4' AND table_name='md2000'");  

    2) Обеспечение наличия связей в моделях
      - При каждом afterupdate производится обновление моделей и связей.
      - За это отвечает специальная команда C36_workbench_sync.
      - Она вставляет межпакетные связи в обе связанные модели
        лишь в том случае, если оба пакета/базы, модели/таблицы в наличии.
      - Перед использованием, всегда надо проверять наличие 
        метода-связи в классе-модели.

          method_exists("\M4\Models\MD1_routes", "m1_packages") 

      - Межпакетная связь имеет префикс в виде id_inner того
        M-пакета, с которым связь. Например: "m1_packages".

    3) Безопасный запрос данных из БД другой модели
      - Осуществляется через хелпер r1_query.
      - Он принимает callback с запросом.
      - Применяет его через try .. catch.
      - С случае успеха возвращает коллекцию.
      - В случае неудачи возвращает NULL.

    4) Очистка pivot-таблицы в зависимом M-пакете
      - Осуществляется отдельной командой C38_clear_interpack_rels.
      - Эта команда выполняется при каждом afterupdate.
      - Ищет md200* в существующих M-пакетах.
      - Проверяет присутствие M-пакетов/БД и моделей/таблиц,
        с которыми md200* должны быть связаны.
      - В случае отсутствия, делает truncate для этой md200*.

  # Кейсы

    1) Межпакетная связь между M4 и M1

      Описание
      --------
        - Роуты должны быть связаны с D,L,W-пакетами.
        - Иначе им не узнать адреса контроллеров, куда
          направлять соответствующие запросы.
        - Поэтому, в модели M4 создаётся новая foreign-связь.
        - Создаётся таблица md2000, с полями id_route и id_package.
        - Её связывают 1:n связью с таблицей роутов.
        - В её description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages
        \M4\Models\MD1_routes

      Использование r1_routes
      -----------------------      
        - При создании роута пользователю надо дать выбор.
        - С каким D,L,W-пакетом требуется связать этот роут.
        - Для этого, надо запросить список id_inner всех их.
        - Это необходимо делать с помощью r1_routes.
        - Если r1_routes вернёт NULL, сообщить пользователю,
          что доступных для связи пакетов нет.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000
      --------------------------------------
        - При создании нового роута, он связывает с пакетом.
        - При удалении роута, все его связи с пакетами удаляются.
        - Перед Attach / Detach присутствие связи проверяется
          спомощью метода method_exists. 
        - Если связи нет, то Attach / Detach не выполняются.
        - Всё равно это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

    2) Межпакетная связь между M5 и M1

      Описание
      --------
        - Права должны быть связаны с пакетами и командами.
        - Это позволит автоматически создавать права типов
          "access" и "exec".
        - Поэтому, в модели M5 создаются 2 новых foreign-связи.
        - Создаётся таблица md2000, с полями id_privilege и id_package.
        - Создаётся таблица md2001, с полями id_privilege и id_command.  
        - Их связывают 1:n связями с таблицей прав.
        - В их description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages <---> \M5\Models\MD1_privileges
        \M1\Models\MD2_packages <---> \M5\Models\MD5_commands

      Использование r1_routes
      -----------------------
        - Применяется при создании автоматических прав.
        - Для этого требуется извлечь все D,L,W-пакеты и 
          все команды.      
        - Если r1_routes вернёт NULL, использовать пустую коллекцию.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000 и md2001
      -----------------------------------------------
        - Создание / Удаление права происходит лишь на основе
          данных, извлечённых r1_routes из M5.
        - Если r1_routes вернёт NULL, то создавать автоматические
          права будет не для кого.
        - И это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.


В2. Установка laravel и homestead

--------------------------------------
Подоглавление:

  # Введение
  # Установка laravel
  # Установка homestead

--------------------------------------

> Введение
  - Краткая инструкция по установке laravel и homestead.
  - По homestead, описывается установка для отдельного проекта.


> Установка laravel
  
  1) Скачать laravel с официального репозитория на github
    - https://github.com/laravel/laravel

  2) Распаковать в каталог проекта
    - Например, создать каталог c:\project
    - И распаковать туда.

  3) В терминале, в каталоге проекта, выполнить composer install
    - Сабж.

> Установка homestead
  - Удобно иметь отдельный бокс homestead для каждого проекта.
  - Как это реализуется:

    1) Прописываем в composer.json проекта зависимость homestead
      - Переходим в каталог проекта.
      - Открываем composer.json.
      - Прописываем в require-dev зависимость от homestead, указав нужную версию:

          "laravel/homestead": "3.0.1"

      - Делаем composer update.

    2) Запускаем команду make
      - В каталоге проекта запускаем команду make.
      - Вот так:

          vendor\bin\homestead make

      - Это создаёт в каталоге проекта Vagrantfile и homestead.yaml.

    3) Настраиваем homestead.yaml
      - Вот пример настройки:

          ---
          ip: "192.168.10.10"
          memory: 2048
          cpus: 2
          hostname: dev.app
          name: dev.app
          provider: virtualbox

          authorize: C:\WebDev\bin\ssh\Homestead - app.dev\id_rsa.pub

          keys:
              - C:\WebDev\bin\ssh\Homestead - app.dev\id_rsa

          # folders:
          #     - map: "C:/WebDev/dev.app"
          #       to: "/home/vagrant/dev.app"
          #       type: nfs

          sites:
              - map: dev.app
                to: "/home/vagrant/dev.app/Public"

          databases:
              - general

          # blackfire:
          #     - id: foo
          #       token: bar
          #       client-id: foo
          #       client-token: bar

          ports:
            - send: 3000
              to: 3000
            - send: 3001
              to: 3001
          #     - send: 7777
          #       to: 777
          #       protocol: udp
      
    4) Отключаем mapping каталогов (если надо)
      - Открываем Vagrantfile в корне проекта.
      - В него прописываем:

          Сразу после строки:
            Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

          Вставляем строку
            config.vm.synced_folder ".", "/vagrant", disabled: true

    5) Запускаем нужный бокс homestead
      - Можно получить последнюю версию бокса homestead,
        выполнив vagrant box update
      - Выполняем команду vagrant up.
      - При этом vagrant ищет ближайший vagrantfile.
      - Начинает он поиски с текущего каталога.
      - Таким образом, надо выполнять vagrant up в каталоге проекта.
      - И тогда будет запущен бокс именно для этого проекта.

    6) Подключаемся через putty по 127.0.0.1:2222
      - Сабж.
  

В3. Оформление нового пакета composer

--------------------------------------
Подоглавление:

  # Введение
  # Инструкция

--------------------------------------

> Введение
  - Допустим, ты разработал новый пакет любого типа.
  - Теперь его надо оформить подобающим образом.
  - Сделать локальный репозиторий, сделать удалённый на github.
  - Создать первый релиз этого пакета.
  - В этой главе краткая и достаточная инструкция.

> Инструкция

  1) Создать локальный git-репозиторий - выполнить git init
    - Кликнуть правой кнопкой мыши по папке с пакетом.
    - Нажать git init.

  2) Создать удалённый git-репозиторий на github
    - Зайти на github.
    - Создать новый репозиторий.
    - Имя его должно совпадать с ID пакета.

  3) Связать локальный репозиторий с удалённым
    - Для этого перейти в каталог локального репозитория.
    - И выполнить команду:

      git remote add [имя удал.репо.] [адрес удал.репо]

    - Например:

      git remote add M1 git@github.com:4gekkman/M1.git

    - Внимание! Регистр 'm1' или 'M1' имеет значение!

  4) Добавить в GitAutoPushScript.ps1 запись для авто-push
    - Этот скрипт каждый 3 часа автоматически делат push.
    - Следует добавить туда новый локальный репозиторий.
    - И вручную выполнить push одноимённой командой.

  5) Создать первый релиз пакета (версия 1.0.0)
    - Зайти на github, в репозиторий пакета.
    - Нажать на ссылку releases.
    - Создать там новый релиз.


В4. Как открыть >= 2 моделей workbench одновременно

--------------------------------------
Подоглавление:

  # Введение
  # Инструкция

--------------------------------------

> Введение
  - У MySQL Workbench есть традиционное ограничение.
  - Он не позволяет открыть > 1 модели одновременно.
  - Это делает работу с ним менее удобной, чем она могла бы быть.
  - В этой главе описано, как обойти данное ограничение.


> Инструкция

  1) Открыть настройки Workbench
    - Edit -> Preferences

  2) Разрешить запускать более 1 экземпляра workbench
    - Other -> Allow more than one instance of MySQL Workbench to run

  3) Запустить доп.экземпляры Workbench, открыть там нужные модели
    - Но не открывать одну и ту же модель в разных экземплярах.


В5. Как посмотреть очередь задач с драйвером redis

--------------------------------------
Подоглавление:

  # Введение
  # Инструкция

--------------------------------------

> Введение
  - В Laravel можно добавлять задачи в очередь.
  - Одним из драйверов для очередей является redis.
  - Встроенной функции для просмотра очереди нет.
  - Ниже приведён код для просмотра очереди.


> Инструкция

  1. Запустить tinker
    - Открыть терминал на сервере.
    - Перейти в корневой каталог приложения.
    - Запустить tinker:

        php artisan tinker

  2. Посмотреть очередь, можно выполнив команду
    - Выполнить команду:

        Queue::getRedis()->command('LRANGE',['queues:default', '0', '-1']);

  3. Очистить очередь, можно выполнив команду:
    - Выполнить команду:

        Queue::getRedis()->command('DEL',['queues:default']);


В6. Оформление локального и удалённого (на GitHub) репозиториев для пакета

--------------------------------------
Подоглавление:

  # Введение
  # Инструкция

--------------------------------------

> Введение
  - Широкое применение нашли системы контроля версий.
  - Одной из самых популярных таких систем является GitHub.
  - Для каждого модуля я создаю локальный и удалённый репозитории.
  - Cron автоматически делает push на GitHub каждый 3 часа.
  - Три основных причины, зачем использовать такую систему:

    1) Резервное копирование
    2) Контроль версий и обновление
    3) Совместная разработка

> Инструкция

  1. Подготовка SQL (для M-пакетов)
    - Если речь идён не об M-пакете, пропустить этот шаг.
    - В каталог Database разместить файлы:

      "1.sql"     // Первичная установка БД M-пакета

      "2.sql"     // Обновления
      "3.sql"     // для
      "4.sql"     // БД
      ...         // M-пакета

    - SQL-код в этих файлах должен быть организован таким
      образом, что если с нуля, последовательно выполнить
      их один за другим, должна получиться последняя версия
      базы данных M-пакета.
    - Плюс, в Database должен лежать файл с последней версией
      workbench-модели базы данных M-пакета.

  2. Подготовка readme.md
    - Файл должен соответствовать формату mark down (для github).

  3. Создать локальный git-репозиторий, и скопировать туда модуль
    - Сделать это можно 2-мя способами:

      1) Выполнить git init в терминале, в каталоге пакета.
      2) Щёлкнуть ПК мыши по папке, и выбрыть git init here.

  4. Создать удалённый репозиторий на github
    - Перейти по ссылке: https://github.com/new
    - Создать новый репо. Имя, как ID пакета. Например: 'M1'.
    - Внимание: имя репо д.б. в верхнем регистре!

  5. Связать локальный репозиторий с удалённым
    - Открыть терминал, перейти в каталог локального репо.
    - Выполнить: 

        git remote add [имя удал.репо.] [адрес удал.репо]
        git remote add M1 git@github.com:4gekkman/M1.git    // Пример

    - Внимание: регистр 'm1'/'M1' имеет значение! Использовать верхний!

  6. Добавить запись в GitAutoPushScript.ps1
    - Это конфиг для авто push в удалённый репо.
    - Создать там соответствующую запись для нового репо.

  7. Выполнить push и создать новый релиз
    - Выполнить скрипт GitAutoPushScript.ps1.
    - Зайти на GitHub и создать там релиз пакета версии 1.0.0.


В7. Работа с Carbon

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Справочник

    1]  Создание экземпляра \Carbon\Carbon

      ::new \Carbon\Carbon()      | На основе формата даты/времени из php-класса DateTime
      ::parse()                   | Спарсить дату/время из строки
      ::now()                     | С датой/временем на момент создания
      ::today()                   | С датой - сегодня, временем - 00:00:00
      ::tommorow()                | С датой - завтра, временем - 00:00:00
      ::yesterday()               | С датой - вчера, временем - 00:00:00

      ::create()                  | Создать дату/время из аргументов, не указанным назначить значения по умолчанию
      ::createFromDate()          | Создать дату из аргументов, время - 00:00:00
      ::createFromTime()          | Создать время из аргументов, дата - today
      ::createFromFormat()        | Указать формат, строку в нём, и создать из неё (см. форматы для DateTime, timezone можно указать цифрой)
      ::createFromTimestamp()     | Создать из timestamp
      ::createFromTimeStampUTC()  | Создать из timestamp с UTC0

      ::copy()                    | Скопировать существующий объект Carbon

      ::maxValue()                | Создать с MAX датой/временем (2038-01-18 22:14:07)
      ::minValue()                | Создать с MIN датой/временем (2038-01-18 22:14:07)

    2]  Локализация вывода

      - ::setLocale()               | Назначить локаль классу Carbone, примеры: 'en', 'ru'

    3]  Геттеры

      ->year            | Год
      ->month           | Месяц
      ->day             | День
      ->hour            | Час
      ->minute          | Минута
      ->second          | Секунда
      ->micro           | Микросекунды
      ->dayOfWeek       | Номер для недели
      ->dayOfYear       | Номер дня года
      ->weekOfMonth     | День недели месяца
      ->weekOfYear      | День недели года
      ->daysInMonth     | Дней в месяце
      ->timestamp       | Таймштамп
      ->age             | Возраст относительно now
      ->quarter         | Квартал

      ->offset          | UTC-смещение в секундах
      ->offsetHours     | UTC-смещение в часах
      ->dst             | true/false действует зимнее/летнее время
      ->local           | true/false такое же ли UTC-смещение, как у local
      ->utc             | установлено ли UTC-смещение == 0
      ->timezone        | возвращает экземпляр DateTimeZone
      ->timezoneName    | возвращает имя временной зоны, например: America/Toronto

    4] Сеттеры

      ->year        | Год
      ->month       | Месяц   | 13: year++ и +1 месяц
      ->day         | День
      ->hour        | Час
      ->minute      | Минута
      ->second      | Секунда

      ->timestamp   | Таймстамп
      ->timezone    | Временная зона

    5]  Форматирование строки

      ->toDateTimeString()      | использует __toString()
      ->toDateString()          | 1975-12-25
      ->toFormattedDateString() | Dec 25, 1975
      ->toTimeString()          | 14:15:16
      ->toDateTimeString()      | 1975-12-25 14:15:16
      ->toDayDateTimeString()   | Thu, Dec 25, 1975 2:15 PM
      ->format()                | 'l jS \\of F Y h:i:s A' => Thursday 25th of December 1975 02:15:16 PM

    6]  Сравнение (проводится в UTC0)

      ->eq()    | equal            | $c1->eq($c2) 
      ->ne()    | not equal        | $c1->ne($c2)
      ->gt()    | greater          | $c1->gt($c2)
      ->gte()   | greater or equal | $c1->gte($c2)
      ->lt()    | less             | $c1->lt($c2)
      ->lte()   | less or equal    | $c1->lte($c2)

      ->between()  | is between (true/false) | $c1->between($c2, c3)
      ->max()      | get max of 2 carbons    | $c1->max($c2)
      ->min()      | get min of 2 carbons    | $c1->min($c2)

      ->isWeekday()         | Рабочий ли день
      ->isWeekend()         | Выходной ли
      ->isYesterday()       | Вчерашний ли день
      ->isToday()           | Сегодняшний ли день
      ->isTomorrow()        | Завтрашний ли день
      ->isFuture()          | Это дата/время в будущем?
      ->isPast()            | Это дата/время в прошлом?
      ->isLeapYear()        | Это високосный год?
      ->isSameDay($carbon)  | Этот тот же день, что в карбоне в аргументе?
      ->isBirthday()        | $c1->isBirthday($c2)

    7]  Добавление и вычитание

      ->addYears(5);      | добавить N лет             
      ->addYear();        | добавить 1 год            
      ->subYear();        | вычесть 1 год
      ->subYears(5);      | вычесть N лет

      ->addMonths(60);    | добавить N месяцев            
      ->addMonth();       | добавить 1 месяц            
      ->subMonth();       | вычесть 1 месяц            
      ->subMonths(60);    | вычесть N месяцев           

      ->addDays(29);      | добавить 29 дней            
      ->addDay();         | добавить 1 день            
      ->subDay();         | вычесть 1 день            
      ->subDays(29);      | вычесть N дней            

      ->addWeekdays(4);   |             
      ->addWeekday();     |             
      ->subWeekday();     |             
      ->subWeekdays(4);   |             

      ->addWeeks(3);      | добавить N недель            
      ->addWeek();        | добавить 1 неделю            
      ->subWeek();        | вычесть 1 неделю            
      ->subWeeks(3);      | вычесть N недель            

      ->addHours(24);     | добавить N часов            
      ->addHour();        | добавить 1 час            
      ->subHour();        | вычесть 1 час            
      ->subHours(24);     | вычесть N часов            

      ->addMinutes(61);   | добавить N минут            
      ->addMinute();      | добавить 1 минуту          
      ->subMinute();      | вычесть 1 минуту            
      ->subMinutes(61);   | вычесть N минут            

      ->addSeconds(61);   | добавить N секунд            
      ->addSecond();      | добавить 1 секунду            
      ->subSecond();      | вычесть 1 секунду            
      ->subSeconds(61);   | вычесть N секунд            
   
    8]  Разница ($c2 по умолчанию == now)

      1-й параметр: $c2 по умолчанию == now
      2-й параметр: true - абсолютное значение без минуса, false - минус может присутствовать

      ->diffInSeconds()   | в секундах  | $c1->diffInSeconds($c2)
      ->diffInMinutes()   | в минутах   | $c1->diffInMinutes($c2)
      ->diffInHours()     | в часах     | $c1->diffInHours($c2)
      ->diffInDays()      | в днях      | $c1->diffInDays($c2)
      ->diffForHumans()   | текстом     | $c1->diffForHumans($c2)  | 5 seconds from now

    9] Модификаторы

      ->startOfDay()      | установить на начало дня
      ->endOfDay()        | установить на конец дня
      ->startOfMonth()    | установить на начало месяца
      ->endOfMonth()      | установить на конец месяца
      ->startOfYear()     | установить на начало года
      ->endOfYear()       | установить на конец года
      ->startOfDecade()   | установить на начало десятилетия
      ->endOfDecade()     | установить на конец десятилетия
      ->startOfCentury()  | установить на начало века
      ->endOfCentury()    | установить на конец века
      ->startOfWeek()     | установить на начало недели
      ->next()            | ?
      ->previous()        | ?
      ->average()         | установить среднее между двумя карбонами  | $start->average($end);


--------------------------------------

# Ссылки

  > Официальная документация Carbon
      http://carbon.nesbot.com/docs/

  > Допустимые форматы даты и времени для DateTime
      http://php.net/manual/ru/datetime.formats.php


# Введенение
  - Carbon наследует от стандартного php-класса DateTime.
  - Он дополняет его функционал, упрощает работу с датой и временем.
  - Carbon уже по умолчанию установлен в Laravel.


# Справочник

  //----------------------------------------//
  // 1]  Создание экземпляра \Carbon\Carbon //
  //----------------------------------------//

    // new \Carbon\Carbon($str, $tz)
    //----------------------------------------//
    // - На основе формата даты/времени из php-класса DateTime

      $carbon = new Carbon();                                   // equivalent to Carbon::now()
      $carbon = new Carbon('first day of January 2008', '3');   // здесь 3, это utc-смещение

    // ::parse($str)
    //----------------------------------------//
    // - Спарсить дату/время из строки

      $carbon = Carbon::parse('first day of December 2008')->addWeeks(2);
      
    // ::now($tz)
    //----------------------------------------//
    // - С датой/временем на момент создания

      $carbon = Carbon::now();
      $carbon = Carbon::now(3);  // UTC + 3
      
    // ::today($tz)
    //----------------------------------------//
    // - С датой - сегодня, временем - 00:00:00

      $carbon = Carbon::today();
      $carbon = Carbon::today(3);   // UTC + 3
      
    // ::tommorow($tz)
    //----------------------------------------//
    // - С датой - завтра, временем - 00:00:00

      $carbon = Carbon::tommorow();
      $carbon = Carbon::tommorow(3);   // UTC + 3      

    // ::yesterday($tz)
    //----------------------------------------//
    // - С датой - вчера, временем - 00:00:00

      $carbon = Carbon::yesterday();
      $carbon = Carbon::yesterday(3);   // UTC + 3 
      
    // ::create($year, $month, $day, $hour, $minute, $second, $tz)
    //----------------------------------------------------------//
    // - Создать дату/время из аргументов, не указанным назначить значения по умолчанию

      $carbon = Carbon::create(2000, 1, 1, 0, 0, 0);
      
    // ::createFromDate($year, $month, $day, $tz)
    //----------------------------------------------//
    // - Создать дату из аргументов, время - 00:00:00

      $carbon = Carbon::createFromDate(null, 12, 25);
      
    // ::createFromTime($hour, $minute, $second, $tz)
    //-----------------------------------------------//
    // - Создать время из аргументов, дата - today

      $carbon = Carbon::createFromTime(12, 0, 0, 'Europe/London');
      
    // ::createFromFormat($format, $string)
    //----------------------------------------//
    // - Указать формат, строку в нём, и создать из неё (см. форматы для DateTime, timezone можно указать цифрой)

      $carbon = Carbon::createFromFormat('Y-m-d H', '1975-05-21 22');
      
    // ::createFromTimestamp($timestamp, $tz)
    //----------------------------------------//
    // - Создать из timestamp

      $carbon = Carbon::createFromTimestamp(-1, '3');
      
    // ::createFromTimeStampUTC($timestamp)
    //----------------------------------------//
    // - Создать из timestamp с UTC0

      
    // ::copy()
    //----------------------------------------//
    // - Скопировать существующий объект Carbon

      $carbon = Carbon::now();
      $carbon2 = $carbon->copy();
      
    // ::maxValue()
    //----------------------------------------//
    // - Создать с MAX датой/временем (2038-01-18 22:14:07)

      $carbon = Carbon::maxValue();
      
    // ::minValue()
    //----------------------------------------//
    // - Создать с MIN датой/временем (2038-01-18 22:14:07)

      $carbon = Carbon::minValue();

  //------------------------//
  // 2]  Локализация вывода //
  //------------------------//

    // ::setLocale($locale)
    //----------------------------------------//
    // - Назначить локаль классу Carbone, примеры: 'en', 'ru'

      // Назначить локаль
      Carbon::setLocale('ru');

      // Тест
      echo Carbon::now()->addYear()->diffForHumans();   // через 1 год

  //-------------//
  // 3]  Геттеры //
  //-------------//

    // Без примеров. См. список в оглавлении.

  //-------------//
  // 4]  Сеттеры //
  //-------------//    

    // Текучие сеттеры
    //----------------------------------------//

      $carbon = Carbon::now();
      $carbon
        ->year(1975)
        ->month(5)
        ->day(21)
        ->hour(22)
        ->minute(32)
        ->second(5)
        ->toDateTimeString();

  //---------------------------//
  // 5]  Форматирование строки //
  //---------------------------// 

    // Без примеров. См. список в оглавлении.

  //-----------------------------------//
  // 6]  Сравнение (проводится в UTC0) //
  //-----------------------------------// 

    // Без примеров. См. список в оглавлении.

  //----------------------------//
  // 7]  Добавление и вычитание //
  //----------------------------// 

    // Без примеров. См. список в оглавлении.

  //---------------------------------------//
  // 8]  Разница ($c2 по умолчанию == now) //
  //---------------------------------------// 

    // Без примеров. См. список в оглавлении.


B8. Использование веток пакетов composer

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Ликбез

    - Репозиторий
    - Релиз
    - Тег
    - Зависимости
    - Псевдонимы

--------------------------------------

> Ссылки

  # Статья "Use a GitHub Branch as a Composer Dependency"
      http://www.lornajane.net/posts/2014/use-a-github-branch-as-a-composer-dependency

  # Статья в официальной документации про alias'ы для branch'ей
      https://getcomposer.org/doc/articles/aliases.md

  # Ответ на stackoverflow про отличие branch'ей от tag'ов
      http://stackoverflow.com/questions/14613540/git-tag-in-branches

  # Статья в официальной документации про версии
      https://getcomposer.org/doc/articles/versions.md

  # Иллюстрации бранчей
      https://www.google.ru/search?q=git+branch&newwindow=1&espv=2&biw=1536&bih=758&source=lnms&tbm=isch&sa=X&ved=0ahUKEwjg96vLgtrKAhVEFywKHXIuA0gQ_AUIBigB#imgrc=uesluf7rqmfJ3M%3A

  # Видео про merge бранчей
      https://www.youtube.com/watch?v=yyLiplDQtf0


> Введение
  - При разработке проекта часто нужно внести доработки в пакет.
  - Причём, эти доработки специфичны именно для этого проекта.
  - То есть, они не должны быть добавлены в master-ветку пакета.
  - Поэтому, доработанный вариант выносится в отдельную ветку.
  - В этой главе обсудим нюансы применения этой техники.


> Ликбез

  Репозиторий
  - Это хранилище для git-проекта.
  - Репозитории бывают локальные и удалённые.
  - Локальные: на твоём компьютере, например.
  - Удалённые: github, например.
  - Шаблон имени репозитория: [владелец]/[название].
  - Например: "doctrine/common".

  Релиз
  - Это последний коммит указанного бранча.
  - Который помечен уникальным для репозитория тегом.

  Тег
  - Указатель на конкретный релиз.
  - Теги и бранчи никак не связаны.
  - Формат тега (примар): 1.0.0

  Бранч
  - Это отдельная ветка коммитов.
  - Бранч, это указатель на последний коммит в ветке.

  Зависимости
  - Для подключения зависимости надо,во-первых, указать 
    имя репозитория; во-вторых, какой коммит качать.
  - Указать коммит можно 2-мя способами:

    1) Диапазон тегов
      - Будет использовао коммит, на который указывает тег.
      - Можно указать не конкретный тег, а диапазон тегов.
      - В этом случае под тегом можно понимать версии.
      - Если указан диапазон, будет использована последняя 
        доступная версия.
      - Пример (>=1.0.0 и < 2.0.0):

          "doctrine/common": "~1.0"

    2) Бранч
      - Будет использовать последний коммит из указанного бранча.
      - Для этого строка должна начинаться с "dev-".
      - Пример (укажем бранч bugfix):

          "doctrine/common": "dev-bugfix"  

  Псевдонимы
  - Допустим, имеются у нас 2 пакета, M1 и L1.
  - В composer.json проекта прописано:

      "repositories": [
          {
              "type": "git",
              "url": "https://github.com/4gekkman/M1.git"
          },
          {
              "type": "git",
              "url": "https://github.com/4gekkman/L1.git"
          }          
      ]

      "require": {
          "4gekkman/M1": "1.0.5",
          "4gekkman/L1": "1.0"
      }

  - При этом, пакет L1 зависит от M1 версии "1.0.5".
  - Тут появился новый проект, где потребовалось изменить M1.
  - Был создан новый бранч secondary для M1.
  - Теперь require выглядит так:

      "require": {
          "4gekkman/M1": "dev-secondary",
          "4gekkman/L1": "1.0"
      }

  - Но ведь L1 то требует версию "1.0.5" пакета M1.
  - И "dev-secondary" никак ей не соответствует.
  - Чтобы исправить ситуацию, используем inline alias:

      "require": {
          "4gekkman/M1": "dev-secondary as 1.x",
          "4gekkman/L1": "1.0"
      }

  - Теперь при запросе версий "~1.0" пакета M1 будет
    возвращаться бранч dev-secondary. 


B9. Концепция frontend-части моего фреймворка

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение

--------------------------------------

> Ссылки

  # CSS-фреймворк bootstrap
      http://getbootstrap.com/

  # Биржа тем и шаблонов для bootstrap
      https://wrapbootstrap.com/

  # Фронтенд-фреймворк Remark
      http://getbootstrapadmin.com/

> Введение
  - Совокупность P,K-пакетов представляет frontend-часть моего фреймворка.
  - Её могут использовать D,W,L-пакеты.
  - В этой главе описана концепция frontend-части моего фреймворка.


Постановка целей
- 




Что из себя представляет фронтенд-фреймворк

  1) Набор файлов, готовых к пре-процессингу
    - Например, файлы .less, использующие переменные и т.д.
    - Каждый файл содержит стили для своей категории эл-тов.

  2) Конфиг для параметров для пре-процессора
    - Здесь можно указать значения параметров, используемых в каждом файле.
    - Таким образом, можно проводить кастомизацию.

  3) JS-функционал
    - Фронтенд, это не только css, но и JS.
    - Соответственно, есть набор JS-файлов.


Кастомизация элементов в конкретном документе
- Допустим, у меня в фреймворке есть стили кнопок.
- Допустим, мне надо использовать кнопки в опред.документе.
- Причём одновременно и стандартные, и с кастомными стилями.
- Так вот, кастомные стили можно поместить в css документа.


Файловая структура фронтенд-фреймворка


/sass
  alerts.scss
  labels.scss
  panels.scss

/components
  dropdown.js
  popover.js

/vendorjs
  /Alertify


Концепт использования фронтенд-фреймворка

  # Каждому ресурсу свой пакет
    - Каждому .scss свой P-пакет
    - Каждому JS свой P-пакет  
    - Каждому компоненту свой K-пакет  

  # Большое число P- и K-пакетов
    - В итоге число этих пакетов будет идти на сотни.
    - Вручную подключать их к каждому новому документу не вариант.
    
  # Единая точка сборки
    - Создаём W-пакет.
    - Добавляем ему в зависимости все пакеты фронтенд-фреймворка.
    - Подключив этот W-пакет к любому документу, мы подключаем к нему фреймворк.
    - Это быстрый, но не оптимальный с т.з. ресурсозатрат способ.

  # Оптимизация для каждого документа
    - Как правило, каждый документ использует лишь часть возможностей фреймворка.
    - Однако, загрузка неиспользуемого функционала напрасно тратит ресурсы.
    - Оптимизировать, можно отключит W-пакет из зависимостей документа.
    - А вместо него добавив лишь используемые пакеты фреймворка.

  # Кастомизация стилей через конфиги
    - У каждого P-пакета фреймворка есть свой конфиг.
    - Этот конфиг содержит .scss переменные для данного пакета.
    - Этот конфиг публикуется в /config проекта Laravel.
    - Конфиги учитываются при компиляции scss в css.
  
  # Кастомизация стилей через c.css документа
    - Никто не запрещает перезаписать стили фреймворка в документе.
    - Можно либо полностью перезаписывать классы.
    - Либо, скажем, добавлять туда что-нибудь миксинами.

  # Применение компонентов
    - Компоненты также используют стили фреймворка.
    - Их можно применять стандартным для knockoutjs способом.
    - Во время применения можно задавать объект с параметрами.
    - Каждый компонент называется также, как и его пакет.

  # Прямое применение различного JS-функционала
    - Фреймворк также может содержать P-пакеты с JS-библиотеками.
    - Во время разработки можно напрямую применять этот функционал.

  # Использование только скаченных сторонних зависимостей
    - Лучше не пользоваться ссылками на сторонние зависимости.
    - Потому что ссылка может упасть, и всё посыпется.
    - Версия пакета должна совпадать с реальной версией зависимости.


Концепт развития фронтенд-фреймворка

  # Соглашение
    - Все пакеты с одинаковой мажорной версией д.б. совместимы.
    - Во время разработки это следует учитывать.

  # Дополнение и исправление существующего функционала
    - Сабж.

  # Добавление нового функционала
    - Сабж.

  # Обновление сторонних зависимостей
    - Сабж.


Концепт справочника по фреймворку

  # Справочник в виде админки
    - Справочник должен быть представлен в виде админки.
    - В которой функционал фреймворка демонстрируется.

  # Отдельный M-пакет для учёта компонентов фреймворка
    - Для учёта всех компонентов м.б. создан отдельный M-пакет.
    - Причём, этот справочник может охватывать и бэкенд тоже.
    - И к нему соответствующие интерфейсы.


Как можно использовать bootstrap и другие css фреймворки

  # Для вдохновения
    - Можно смотреть, что там есть.
    - И добавлять это в свой фреймворк.

  # Для копипасты
    - Многое можно скопипастить.


Как можно использовать сторонний JS-функционал

  # Добавлять в проект в виде P-пакетов
    - Создаёшь P-пакет.
    - Скачиваешь с оф.сайта функционал.
    - Добавляешь его в P-пакет.
    - Создаёшь релиз P-пакета той же версии, что функционал.

  # Обновлять периодически
    - Сабж.





PostCSS
- https://github.com/postcss/postcss
- https://github.com/jonathantneal/precss  // SASS in PostCSS


SASS
- http://sass-lang.com/guide
- Bootstrap 4 будет на SASS.





Концепция кастомизации CSS с помощью Less
- Можно заменить простой CSS на LESS.
- Команда minify может выполнять компиляцию less-файлов.
- И добавлять результаты в итоговый c.min.css.
- Less-файлы могут хранитсья в P-пакетах.
- P-пакеты могут иметь конфиги с настройками для css.
- Команда minify может эти настройки считывать.
- И компилировать less-файлы с их учётом.






Сегодня я наконец-то дошёл до frontend-части моего фреймворка, и начал заниматься ей вплотную.

И нашёл крутой инструмент для работы с CSS.
Называется - PostCSS.
Суть в паре слов:
- PostCSS это модуль для nodejs.
- Для PostCSS есть более 200 JS-плагинов.
- PostCSS может на вход принимать css-файл, пропускать его через указанные JS-плагины, и выплёвывать результат.

Какие возможности это открывает (на примере):
- Допустим, мы написали стили для различных панелек.
- И засунули эти стили в composer-пакет.
- И хотим их кастомизировать в разных проектах.
- У нашего пакета может быть конфиг, публикуемый в каталог config проекта laravel.
- В конфиге мы можем с помощью параметров кастомизировать наши стили.
- Потом, при сборке итогового css, эти параметры учитываются.





С чего начать

  1) Составить методичку по SASS
  2) Составить методичку по PostCSS и нужным плагинам
  3) Создать точку сборки в виде W-пакета
  4) Модифицировать P-пакеты, для работы с SASS и PostCSS.
  5) Модифицировать команду minify (часть, связанную с css).
  6) Начать работу над админкой и фреймворком.




Проблема излишней загрузки зависимостей для клиента

  # Суть
    - Допустим, есть 3 документа: D1,D2,D3.
    - Все они используют одни и те же фронтенд-зависимости.
    - Эти зависимости выстраиваются в глубокое дерево.
    - Для каждого D-пакета формируем c.min.css и j.min.js.
    - В итоге получаем 3 комплекта: c.min.css + j.min.js.
    - Посетив 3 этих документа, клиент загружает 3 этих комплекта.
    - В результате клиент вынужден 2 лишних раза загружать ряд ресурсов.
    - Например, если D1,D2,D3 зависят от jquery, клиент 3 раза его загружает.

  # Суть решения
    - NodeJS + NPM + bower + Gulp + wiredep + gulp-sass + PostCSS + Laravel Elixir.
    - https://www.youtube.com/watch?v=PNlTFa-XzIM

  # Как это приблизительно работает

    1) Работу P,K-пакетов и minify оставляем, как есть
      - Они также получают c.min.css и j.min.js.
      - Которые должны подключаться ПОСЛЕ всех прочих зависимостей.

    2) D,L,W,P,K-пакеты могут зависеть от bower-пакетов
      - Эти зависимости можно прописывать в спец.json-конфигах.
      - Подобный конфиг должен быть в каждом D,L,W,P,K-пакете.

    3) Команда по синхронизации bower-конфига со списком bower-зависимостей пакета
      - При каждом запуске afterupdate запускается спец.команда.
      - Она пробегает все D,L,W,P,K-пакеты.
      - Заглядывает в их json-конфиги с bower-зависимостями.
      - И добавляет их в require в глобальный bower конфиг проекта.
      - Но без повторений, и вообще, производя соотв.синхронизацию.
      - А в конце заставляет bower все эти зависимости скачать.

    4) В каждом D-пакете будет свой gulpfile.js
      - В нём одно задание, используещее wiredep.
      - Оно вставляет все bower-зависимости в представление D-пакета.
      - Причём, перед j.min.js и c.min.css, которые формируются командой minify.

    5) Дополнительная обработка с помощью gulp
      - Можно дополнительно обработать, скажем, c.min.css.


В10. Настройка отправки почты из Laravel через gmail-аккаунт

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Инструкция по настройке 

--------------------------------------

> Ссылки

  # Статья на http://learninglaravel.net/ (en)
      http://learninglaravel.net/learn-to-send-emails-using-gmail-and-sendgrid-in-laravel-5

> Введение
  - Здесь описана настройка отправки email в Laravel.
  - Почта будет отправляться через smtp, используя gmail-аккаунт.

> Инструкция по настройке    

  1. Заведи gmail-аккаунт с 2-факторной авторизацией

  2. Настрой .env
    - Например:

      MAIL_DRIVER=smtp
      MAIL_HOST=smtp.gmail.com
      MAIL_PORT=587
      MAIL_USERNAME=4gekkman.mailacc.devapp@gmail.com
      MAIL_PASSWORD=yczyntpjhhfprklb
      MAIL_ENCRYPTION=tls  

  3. Предоставь доступ к аккаунту google приложениям
    - https://accounts.google.com/UnlockCaptcha

  4. Создай спец. пароль для laravel в google
    - https://support.google.com/accounts/answer/185833?hl=ru&ctx=ch_DisplayUnlockCaptcha


В11. Работа с HybridAuth

--------------------------------------
Подоглавление:

  # Ссылки
  # Введение
  # Обзор HybridAuth


--------------------------------------

> Ссылки

  # Официальный сайт и документация HybridAuth
      http://hybridauth.sourceforge.net/

  # Официальный репозиторий на GitHub
      https://github.com/hybridauth/hybridauth

  # HybridAuth на Packagist
      https://packagist.org/packages/hybridauth/hybridauth

  # Официальная документация провайдера Steam для HybridAuth
      http://hybridauth.sourceforge.net/userguide/IDProvider_info_Steam.html

> Введение

  • 














  • HybridAuth является open source решением
    - Его можно бесплатно использовать в своих проектах.

  • HybridAuth является абстрактным API между твоим приложением и API чужих социальных сервисов
    - То есть, используется один и тот же функционал при работе с разными API.
    - Не надо учить API facebook, twitter, google и т.д. Используй один и тот же функционал.

  • HybridAuth позволяет аутентифицировать пользователей через чужие сервисы
    




    - Наш сервис по запросу пользователя получает token на доступ к его API от другого сервиса.
    - По этому токену через этот API наш сервис получает инфу об аккаунте пользователя на другом сервисе.
    - Подробнее о том, как это происходит, отдельно расписано ниже.



    - Пользователь входит в свой аккаунт на другом сервисе.
    - Этот другой сервис свой специальный API.
    - Пользователь даёт нашему сервису право совершать кое-какие



  • HybridAuth позволяет авторизовать своё приложение на чужих сервисах
 



  - HybridAuth позволяет организовать аутентификацию через другие сервисы.
  - HybridAuth является открытым программным обеспечением.
  - HybridAuth имеет очень большое число провайдеров, обеспечивающих
    взаимодействие с аутентификационными API разных сервисов,
    в том числе, и со Steam.
  - Далее по тексту, в большинстве мест, будем называть HybridAuth, как HA.

> Обзор HybridAuth

  • HybridAuth, как абстрактный API
    - HA действует, как абстрактный API между твоим и сторонними сервисами.
    - Например, между твоим приложением, и Facebook, Twitter, Google и т.д.

  • Главными задачами HA являются аутентификация и авторизация

    ▪ Аутентификация

      1. Пользователь заходит на твой сайт.
      2. Нажимает на кнопку, например, "Войти через Steam".
      3. Переадресуется на аутентификационную страницу провайдера.
        - В данном случае в качестве провайдера выступает Steam.
        - Его аутентиф.страница находится по адресу:
            https://steamcommunity.com/openid/
      4. Там он должен разрешить твоему сайту кое-что делать с его аккаунтом.
        - Если пользователь не залогинен в Steam, ему придётся ещё ввести логин/пароль.
        - Там есть список действий, который пользователь разрешает делать
          твоему сайту с его аккаунтом.
        - Если пользователь со всем согласен, он нажимает "Sign in".
      5. Он попадает обратно на твой сайт вместе с зашифрованным токеном
        - Наличие этого токена означает успешную аутентификацию.

    ▪ Авторизация











