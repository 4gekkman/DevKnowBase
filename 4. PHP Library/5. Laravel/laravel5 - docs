////============================================================////
////																													  ////
////           Laravel 5.1 - актуальная документация					  ////
////																													  ////
////============================================================////
//// 			        		   ////
//// 			  Ссылки			 ////
//// 			        		   ////
////=====================////

	# Официальный сайт Laravel
			http://laravel.com/

	# Официальная документация по laravel 5.1
			http://laravel.com/docs/5.1

	# Laravel IDE Helper Generator
			https://github.com/barryvdh/laravel-ide-helper

////==========================================================////
//// 			        		       ////
//// 			  Оглавление			 ////
//// 			        		       ////
////=========================////

  # А. Основы

    А1.  Установка Laravel
    А2.  Настройка Laravel
    А3.  Laravel Homestead и Vagrant
    А4.  Routing
    А5.  Middleware
    А6.  Контроллеры
    А7.  HTTP-запросы, cookie, files, инфа о запросе
    А8.  HTTP-ответы, редирект, макросы для ответов
    А9.  Views (представления)
    А10.  Шаблонизатор Blade

  # Б. Архитектура

    Б1.  Жизненный цикл HTTP-запроса в Laravel 5
    Б2.  Структура приложения
    Б3.  Service Providers
    Б4.  Service Container
    Б5.  Contracts (интерфейсы для SC)
    Б6.  Facades

  # В. База данных

    В1.  Основы работы с БД в Laravel
    В2.  Query Builder (конструктор запросов)
    В3.  Eloquent ORM
    В4.  Schema Builder (конструктор таблиц)
    В5.  Миграции
    В6.  Заселение

  # Г. Сервисы

    Г1.  Кэш
    Г2.  Коллекции (обертки для работы с массивами)
    Г3.  Команды
    Г4.  Шифрование
    Г5.  Envoy
    Г6.  Ошибки & логи
    Г7.  События
    Г8.  Хранилища (в ФС / облаке)
    Г9.  Хэширование
    Г10.  Вспомогательные функции общего назначения     
    Г11.  Локализация
    Г12.  Почта
    Г13.  Разработка composer-пакетов для Laravel
    Г14.  Очереди задач
    Г15.  Сессии
    Г16.  Валидация
    Г17.  Планировщик задач
    Г18.  Трансляция событий через websocket
    Г19.  CLI Artisan


////==========================================================////


А1.  Установка Laravel

  --------------------------------------
  Подоглавление:

    - Системные требования
    - Сроки поддержки Laravel 5.1
    - При установке на Ubuntu
    - Установка Laravel
    - Установка авто-дополнения команд Laravel в PHPStorm
    - Решение проблемы со "swiftmailer" при установке

  --------------------------------------

  > Системные требования
    - PHP >= 5.5.9
    - MCrypt PHP Extension
    - OpenSSL PHP Extension
    - Mbstring PHP Extension
    - Tokenizer PHP Extension


  > Сроки поддержки Laravel 5.1
    - Устранение багов в течение 2-х лет с момента релиза.
    - Устранение проблем с безопасностью в течение 3-х лет с момента релиза.


  > При установке на Ubuntu
    - При установке php5 может не установиться PHP JSON extension.
    - Чтобы установить это дополнение отдельно, надо ввести команду:

        apt-get install php5-json


  > Установка Laravel

      1. Открыть консоль и перейти в папку, куда будем устанавливать.
      2. Скачать composer (если его ещё нет) в эту папку одной из следующих команд:

        php -r "eval('?>'.file_get_contents('https://getcomposer.org/installer'));"
        php -r "readfile('https://getcomposer.org/installer');" | php

      3. С помощью composer устанвоить Laravel:
        - [имя проекта] в команде ниже заменить на оное.
        - Этим именем будет называться папка с проектом (по умолчанию, её имя будет laravel).
        - Выполнить команду:

          php composer.phar create-project laravel/laravel [имя проекта] --prefer-dist

      4. В консоли Windows можно установить путь к каталогу проекта по умолчанию
        - notepad $profile
        - В начале файла пишем:

            # Изменить папку "по умолчанию", с которой запускается PowerShell, на указанную:
            Set-Location "[путь к каталогу с новым проектом]";


  > Установка авто-дополнения команд Laravel в PHPStorm

    > Введиние
      - По умолчанию в PHPStorm (<=v7.1.2) нет автокомплита для laravel.
      - Нет также и специального плагина, как для многих других фреймворков.
      - А без автокомплита работать гораздо менее удобно, чем с ним.

    > Решение
      - Поможет решить проблему "Laravel IDE Helper Generator".
      - Ссылка на него есть выше в ссылках.
      - Автокомплит устанавливается при установке нового проекта laravel.
      - Процесс установки:

      1. В "Laravel/composer.json" добавить следующее:

          {
            "require": {
              "doctrine/dbal": "~2.3",
              "barryvdh/laravel-ide-helper": "2.*"
            }
          }

      2. В каталоге Laravel выполнить команду:
        - Выполнить команду:

            php ..\composer.phar update

        - Если возникнет ошибка:
            "Call to undefined method Illuminate\Foundation\Application::getCachedCompilePath()"
        - Удалить vendor/compiled.php и запустить update снова.


      3. Добавить service-provider в 'Laravel/app/config/app.php':

          'providers' => array(
            ...

            'Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider',

          ),

      4. В папке Laravel выполнить следующие команды:

          php artisan clear-compiled
          php artisan ide-helper:generate

         - Это сгенерирует файл "_ide_helper.php" на основе файлов проекта.


  > Решение проблемы со "swiftmailer" при установке

    > Описание
      - При установке laravel через composer может возникать ошибка.
      - Ошибка связана со "swiftmailer".
      - Ошибка возникает при установке в глубоко зарытую поддиректорию.
      - Как следствие, установка не происходит до конца, и laravel не работает корректно.
      - Описание проблемы на форуми и её решение (eng):
          http://forumsarchive.laravel.io/viewtopic.php?pid=57658

    > Решение
      - Устанавливать новый проект laravel в папку "C:\laravel"
      - При такой установке ошибка возникать не будет, т.к. путь короткий.
      - Установленный laravel после установки переносить куда надо.


А2.  Настройка Laravel

  --------------------------------------
  Подоглавление:

		Вводная информация
		------------------
    	- Введение в настройку

		Прикладная информация
		---------------------
	    - Сгенерировать 32-значный ключ приложения
	    - Как получить значение какого-нибудь свойства из config'а
	    - Как установить значение какого-нибудь свойства из config'а
	    - Как организовать пресеты св-в config'а для разных сред запуска приложения?
	    - Ускорение приложения за счёт кэширования конфигов
	    - Как перевести приложение в режим: "тех.обсллуживания"?

		Подробный разбор конфигов laravel 5
		-----------------------------------
			1] config/app.php						// Общие
			2] config/auth.php					// Аутентификация
			3] config/cache.php					// Кэширование
			4] config/compile.php				// Компиляция ресурсов
			5] config/database.php			// Базы данных
			6] config/filesystems.php		// Файловые системы
			7] config/mail.php					// Электронная почта
			8] config/queue.php					// Отложенные задачи
			9] config/services.php			// Настройки сторонних сервисов
			10] config/session.php			// Сессии
    	11] config/view.php					// Представления

  --------------------------------------

  > Введение в настройку
    - После установки настраивать что-либо необходимости нет.
    - Если устраивают настройки "по умолчанию", можно сразу приступать к работе.
    - Все настройки Laravel лежат в папке app/config.
    - Все настройки разбиты на группы.
    - Каждую группу представляет отдельный .php файл в папке config.
    - Каждый параметр .php файлах хорошо задокументирован.

  > Сгенерировать 32-значный ключ приложения
    - Должен состоять из 32 случайных символов.
    - Этот ключ должен лежать в APP_KEY в файле [проект]\.env
    - Если его не установить, сессии и прошие шифрованные данные НЕ БУДУТ В БЕЗОПАСНОСТИ!
    - При установке Laravel через composer, он генерирует оный автоматически, и можно не беспокоиться.

  > Как получить значение какого-нибудь свойства из config'а
    - Имеется в виду, из каталога [проект]/config
    - Есть 2 варианта:

      1. Через класс Config
        - Это можно сделать через класс Config, используя метод get
        - Например, получим значение параметра 'appzone' из конфига 'config/app.php':

            Config::get('app.timezone');

        - А что, если запрашиваемого параметра не существует? Тогда мы можем
          указать значение "по умолчанию", которое будет возвращено в этом случае:

            $timezone = Config::get('app.timezone', 'UTC');

      2. Через функцию-помощник config
        - Аналогично, получить значение параметра 'appzone' можно так:

            config('appzone');

  > Как установить значение какого-нибудь свойства из config'а
    - Новое значение будет установлено не "на постоянку", а только на время текущего запроса.
    - Это можно сделать через класс Config, используя метод set
    - Например, установим в конфиге 'config/database.php' значение параметра
      'default' равным 'sqlite':

        Config::set('database.default', 'sqlite');


  > Как организовать пресеты св-в config'а для разных сред запуска приложения?

    > Введение в проблему
      - Приложение может быть запущено в разных средах.
      - В зависимости от этого, оно может работать в разных режимах.
      - Примеры:

          Среда                 Задача
          -----------------------------------------
          Домашний компьютер    Разработка
          Облачный сервер       Продакшн

      - Некоторые св-ва config'а при этом должны различаться.

    > Что было в laravel 4.2
      - Конфигурационные файлы хранились в каталоге app/config
      - Для каждый среды создавался каталог app/config/[среда]
      - А в этом каталоге файлы с теми же именами, что у конфигов в app/config
      - А в этих файлах те же св-ва, что в файлах в app/config
      - Допустим, приложени запущено в среде [среда]. Тогда:

          1. Считываются все файлы из app/config/[среда]
          2. Значения св-в из них "затирают" значения одноимённых
             свойств из app/config.
             Если св-во отсутствует, то оно не затирается, а берётся
             из app/config.

    > Что в laravel 5
      - По адресу [проект]/.env лежит файл для настройки конфига.
      - Он имеет формат ключ=значение. Вот пара записей из него:

            APP_ENV=local
            DB_HOST=localhost

      - Для каждой среды можно иметь отдельный такой файл.
      - Из файла-конфига получить значение по ключю и .env можно
        с помощью функции env, вот так:

          env('APP_ENV')

			- Обратите внимание, что этот приём часто используется в конфигах.
      - Проверить, подключен ли .env, скажем, для среды local можно так:

          $app->environment('local')    // 1 - если да, 0 - если нет.

  > Ускорение приложения за счёт кэширования конфигов
    - Закэшировать конфиги можно artisan-командой config:cache
    - Это должно быть частью процесса развертки приложения на сервер в продакшн.

  > Как перевести приложение в режим: "тех.обсллуживания"?

    > Введение в проблему
      - Иногда в приложение нужно внести изменение, и это требует времени.
      - Если приложение в продакшене, для пользователей на время обновления
        надо показать что-нибудь вроде: "сайт на тех.обслуживании".
      - Предусмотрен ли в Laravel для этого какой-нибудь функционал?

    > Решение
      - В Laravel приложение можно перевести в режим "обслуживания".
      - Для этого надо перейти в папку приложения и выполнить команду:

          php artisan down

      - А для выведения приложения из режима "обслуживания":

          php artisan up

      - Когда приложение находится в режиме "обслуживания", пользователи
        при заходе по любому роуту приложения будут видеть только
        одно заданное view. В нём то как раз и должно быть написано что-то вроде
        "Извините, сайт находится на тех. обслуживании".
      - Задать это view можно в файле "app/start/global.php". Например:

          App::down(function()
          {
              return Response::view('maintenance', array(), 503);
          });

      - Если анонимная функция, переданная методу down, вернёт NULL, то
        факт наличия включённого режима "обслуживания" будет проигнорирован
        для этого запроса.
      - Никакие отложенные задания (компонент Queue) при включённом в приложении
        режиме "обслуживания" выполняться не будут. А продолжат, только при
        переключении приложения в нормальный режим.


  > Подробный разбор конфигов laravel 5

		1] config/app.php
		-----------------

      # debug     | Если true, показывает подробную информацию о возник-их ошибках.э
                    Если false, показывает минималистичную инфу.

      # url       | Используется как базовый URL при автогенерации URL при
                    использовании комант artisan

      # timezone  | Имя временной зоны

      # locale    | Имя локали

			# fallback_locale	| Запасная локаль (когда основная не доступна)

      # key       | Это должна быть строка из случайных 32 символов, используется
                    сервисом Illuminate encrypter для шифрования.
										Надо задать перед деплоем, иначи шифрованные данные будут не безопасны!
			# cipher		| Механизм шифрования

			# log				| Режим ведения лога:
			              - single   // один файл-лог
										- daily    // на каждый день отдельный файл-лог
									  - syslog   // ?
										- errorlog // ?

      # providers | Массив классов типа "service provider", которые будут
                    автоматом загружаться при запросе к приложению.
                    Можно добавлять свои.

      # aliases   | Массив в формате ключ/значение, где ключ - псевдоним,
                    значение - путь к папке с классом. При старте приложения
                    каждому из классов в "значении" назначается соответствующий
                    псевдоним из "ключа". Можно добавлять свои.


		2] config/auth.php
		------------------

      # driver   | Драйвер, который будет использован для аутентификации.
                   Доступные варианты: 'Eloquent', 'Database'

      # model    | Если driver == 'Eloquent', нужно указать, какую модель
                   использовать для извлечения пользователей.

      # table    | Если driver == 'Database', нужно указать, какую таблицу
                   в БД использовать для извлечения пользователей.

      # password | Это массив с параметрами для напоминальщиков паролей.
									 - email		// представление
									 - table		// таблица для сброса паролей
									 - expire		// секунд

		3] config/cache.php
		-------------------

			# default     | Какая технология будет использована для кеширования.
                      Доступные варианты:
                      "file", "database", "apc", "memcached", "redis", "array", и т.д.

			# stores			| здесь можно определить все доступные приложенияю
										  хранилища кэша:
											"file", "database", "apc", "memcached", "redis", "array", и т.д.

      # prefix      | При хранении кэша через memcached и apc, могут быть и другие
                      приложения, которые используют те же ключи и затрут кэш. Поэтому
                      надо добавить всем ключам некий префикс.


		4] config/compile.php
		---------------------

      # files				| Доп.классы для компиляции командой artisan optimize.
										  Это д.б. классы, присутствующие в большинстве запросов.
											Иначе, такой класс лучше сюда не размещать, чтобы не тормозить приложения зря.

			# providers		| Управление файлами, которые должны быть скомпилированы.
											Здесь - список сервис-провайдеров, выполняющих компиляцию.
											Полезно для получения итоговых файлов из разных используемых пакетов.


		5] config/database.php
		----------------------

      # fetch       | Здесь можно настроить, в каком виде будут извлекаться
                      результаты из БД.
                      - По умолчанию: как экземпляры PHP stdClass object
                      - Но можно настроить, чтобы извлекались в виде массива

      # default     | Указать, какое из соединений, указанных в 'connections'
                      надо использовать "по умолчанию". Другие тоже можно
                      будет использовать с помощью коллекции соединений Database.

      # connections | Коллекция соединений с БД, которые сможет использовать
                      приложение. Для работы с ними используется PDO, так что
                      для каждой СУБД должен быть в наличии работающий драйвер.

      # migrations  | Указать таблицу для работы с миграциями

      # redis       | Настройки для работы с БД Redis


		6] config/filesystems.php
		-------------------------

			# default			| Файл.система, которую laravel должен использовать по умолчанию.
											На выбор: local, s3, rackspace, ... (можно добавить свои в disks)

			# cloud				| Облачная файловая система по умолчанию
											(многие приложения используют обе: и локальную, и облачную ФС)

			# disks				| Список доступных приложению ФС и их настроек.


		7] config/mail.php
		------------------

      # driver      | Какая технология будет использоваться для работы с почтой.
                      Доступны: "smtp", "mail", "sendmail", "mailgun", "mandrill", "log"

      # host        | Хост SMTP сервера, который будет использован приложением
                      для работы с почтой.

      # port        | SMPT порт, который будет использовать приложение для
                      доставки почты пользователям.

      # from        | Глобальный "From" адрес в виде массива с 2-мя параметрами:
                      'address' и 'name'.
                      - По умолчанию значения у них null, значет отключены.
                      - Если указать значения, то они будут использованы при отправки
                        каждого письма приложением.

      # encryption  | Протокол шифрования для отправки почты, по умолчанию "TLS"

      # username    | Имя пользователя для подключения к SMTP-серверу

      # password    | Пароль для подключения к SMTP-серверу

      # sendmail    | Если driver == 'sendmail', то надо указать путь к папке
                      с sendmain на этом сервере.

      # pretend     | - Если true, то письма на самом деле не будут отправлятсья
                        получателю, а будут записываться в логи приложения.
                        Это режим, который удобно использовать для разработки.
                      - Если false (по умолчанию), то будут.


		8] config/queue.php
		-------------------

      # default     | Указать, какая технология будет использоваться для
                      работы отложенными задачами. Доступные варианты:
											"null", "sync", "database", "beanstalkd", "sqs", "iron", "redis"

      # connections | Коллекция соединений с сервисами отложенных задач

      # failed      | Указать соединение с БД и таблицу, куда будут
                      записываться отчёты о проваленных queue-заданиях.


		9] config/services.php
		----------------------

      ... идёт перечисление сервисов и их настроек ...


		10] config/session.php
		----------------------

      # driver          | Указать какая технология будет использоваться для
                          работы с сессиями. Доступные варианты:
                          "file", "cookie", "database", "apc", "memcached", "redis", "array"

      # lifetime        | Время в минутах, в течение которого хранятся
                          сессионные данные, и после которого они становятся expired

      # expire_on_close | Можно сделать так, чтобы сессионные данные становились
                          expired сразу после закрытия браузера, тогда надо указать true.
                          По умолчанию укзано false.

      # files           | Если driver == 'file', то надо указать папку, где будут
                          хранится сессионные файлы.

      # connection      | Если driver == "database', или driver == "redis", то
                          МОЖНО указать имя соединения из коллекции соединений
                          в файле database.php, которое будет использоваться.

      # table           | Если driver == "database', то надо указать таблицу в БД,
                          в которой будут хранитсья данные сессий.

      # lottery         | Некоторым технологиям по работе с сессиями надо вручную
                          периодически очищать своих хранилища от старых сессий.
                          Здесь указана вероятность запуска этого процесса на каждом
                          запросе (по умолчанию, случайная от 2% до 100%).

      # cookie          | Здесь указано имя сессионной куки, которая будет
                          содержать UID сессии. Используется для любой сессионной
                          технологии.

      # path            | Адрес (начиная от корня приложения), начиная с которого
                          будет проверяться доступность сессионной куки. По умолчанию
                          стоит корень приложения '/'

      # domain          | ?

      # secure          | Если true, сессионные куки отправляются обратно на сервер
                          только в случае, если используется защищённое HTTPS-соединение.
                          По умолчанию false.

		11] config/view.php
		-------------------

      # paths       | Здесь можно указать массив путей, в которых Laravel будет
                      искать представления (view). По умолчанию указан только
                      один путь: "resources/views".

      # compiled  	| Путь, где будут храниться все скомпилированных шаблоны blade.
											По умолчанию, в storage/framework/views


А3.  Laravel Homestead и Vagrant

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Зачем нужен Vagrant в разработке?
    # Что насчет продакшн-сервера?
    # Что в комплекте в homestead 2.0?
    # Комментарии по настройкам в homestead.yaml
    # MySql и Homestead
    # Переадресация портов из реального мира в homestead

    # Пошаговая инструкция установки Homestead на Windows 8.1
    # Полный список команд Homestead
    # Работать с homestead по ssh лучше через Putty

	  # Как перенести БД (mysql) в HomeStead с помощью WorkBench
		# Возможные проблемы, и их решения

				1) "No input file specified" при попытке открыть сайт
				2) Таблица 'homestead.[имя таблицы]' не найдена
				3) Отсутствует модуль ImageMagic в php в homestead
				4) При каждом halt/up дропаются мои базы данных
				5) Как увеличить memory_limit в php.ini?
				6) Laravel выдаёт ошибку: predis недоступен
				7) Nginx не обрабатывает запросы, хотя в homestead.yaml всё указано

    # Ускорение homestead, уменьшение времени отклика
    # Добавить новый mysql-сервер в homestead для нового проекта
    # Отдельный homestead для каждого проекта

  --------------------------------------

  > Ссылки

    # Видео tutorial (en) по установке Vagrant и Laravel на Windows
        http://www.youtube.com/watch?v=7jPnneunSV4

    # Инструкция (ru) на habr по установке Vagrant и Laravel на Windows
        http://habrahabr.ru/post/251529/

    # Документация по Laravel Homestead
        http://laravel.com/docs/5.0/homestead

    # Оф. сайт Vagrant
        http://www.vagrantup.com/

    # Оф. сайт VirtualBox
        https://www.virtualbox.org/

    # Оф. сайт PHP для Windows
        http://windows.php.net/download/

    # Оф. сайт Git Bash для Windows
        https://msysgit.github.io/


  > Зачем нужен Vagrant в разработке?

    > Как CLI для виртуальных машин
      - Vagrant, это такая обёртка для виртуальных машин.
      - Он в работе использует VirtualBox, без него не работает.

    > Быстрый способ развернуть среду разработки
      - Да, можно самому скачать образ Linux, поставить, настроить среду разработки.
      - С помощью Vagrant можно это сделать 1 командой.
      - Есть оф.образ для Vagrant от разраб. Laravel - называется Homestead.
      - В нём есть всё необходимое для разработки под Laravel.

    > Как среда разработки в другой ОС
      - Допустим, ты используешь Windows, как основную систему.
      - Но разрабатывать лучше под Linux, т.к. твой сервак работает на нём.
      - В этом случае можно поднять с помощью Vagrant виртуалку Homestead с Ubuntu.
      - И разрабатывать под неё.

    > Для совместной разработки
      - Допустим, работу над проектом ведёт команда разработчиков.
      - И необходимо, чтобы у всех у них была одна и та же среда разработки.
      - В этом случае, можно использовать, скажем, Homestead.


  > Что насчет продакшн-сервера?
    - Разумеется, homestead не для продакшн.
    - Ведь это виртуальная машина для VirtualBox.
    - Для продакшн в облаке рекомендуется использовать Forge.


  > Что в комплекте в homestead 2.0?

      Ubuntu 14.04
      PHP 5.6
      HHVM
      Nginx
      MySQL
      Postgres
      Node (With Bower, Grunt, and Gulp)
      Redis
      Memcached
      Beanstalkd
      Laravel Envoy
      Blackfire Profiler


  > Комментарии по настройкам в homestead.yaml

    > Зачем нужен и где находится
      - Нужен для быстрой и лёгкой настройки бокса homestead.
      - Находится по адресу: c:\users\[пользователь]\.homestead\homestead.yaml

    > Комментарии о значении каждой из настроек:

      ip          // ip адрес сервера, который надо добавить в hosts
      memory      // сколько памяти выделено серверу, в мегабайтах
      cpus        // сколько процессоров выделено серверу, в штуках
      provider    // какая система виртуализации используется (virtualbox по умолчанию)

      authorize   // путь к публичному ключу авторизации по SSH

      keys        // путь к секретным ключам авторизации по SSH

      folders     // каталоги, которые синхронизируются у хозяина и гостя
                    - В них следует хранить свои проекты.

      sites       // сайты (их адреса надо прописывать в hosts)

      databases   // имена баз данных, которые homestead создаст на сервере mysql

      variables   // ?


  > MySql и Homestead

    > Основное
      - MySql по умолчанию присутствует в homestead, как и указано выше.
      - Логин и пароль по умолчанию: homestead / secret
      - Порт при подключении из homestead: 3306 (его и надо указывать в настройках laravel)
      - Порт при подключении с машины-хозяина: 33060 (например, из WorkBench).
      - Адрес: 127.0.0.1

    > Создание нового подключения в MySql WorkBench на машине-хозяине
      - Использовать порт 33060, адрес 127.0.0.1, и указанные выше логин с паролем.


  > Переадресация портов из реального мира в homestead

      SSH: 2222       -> Forwards To 22
      HTTP: 8000      -> Forwards To 80
      MySQL: 33060    -> Forwards To 3306
      Postgres: 54320 -> Forwards To 5432


  > Пошаговая инструкция установки Homestead на Windows 8.1

    1. Скачать и установить VirtualBox.
      - См.ссылку выше.

    2. Скачать и установить Vagrant.
      - См.ссылку выше.

    3. Скачать и установить PHP для Windows
      - Non Thread Save
      - Добавить путь к php в PATH Windows

    4. Скачать composer
      - Перейти в каталог, в который требуется скачать composer.
      - Выполнить одну из следующих команд:

        php -r "eval('?>'.file_get_contents('https://getcomposer.org/installer'));"
        php -r "readfile('https://getcomposer.org/installer');" | php

      - Прописать путь к composer.phar в Path.
      - Для этого выполнить notepad $profile и прописать туда (заменив [путь]):

          # Глобальная ссылка на композер
          function composer() { php C:\[путь]\composer.phar }

    5. Установить CLI homestead 2.0
      - Для этого выполнить команду:

          composer global require "laravel/homestead=~2.0"

      - CLI Homestead 2.0 будет установлен по следующему адресу:

          C:\Users\[пользователь]\AppData\Roaming\Composer\vendor\bin

      - Его необходимо добавить в PATH, и перезагрузить окно консоли.
      - После этого по команде homestead должна выводитсья справка.

    7. Создать файл homestead.yaml
      - Для этого выполнить команду:

          homestead init

      - Этот файл будет создан в каталоге:

          C:\Users\[пользователь]\.homestead

    8. Установить какую-нибудь из реализаций Bash для windows:
      
      # Что можно установить?
        1) Putty (рекомендуется)
          - Это единственный нормально работающий вариант для windows (11.08.2015).
          - Рекомендуется устанавливать именно его.
        2) Git Bash
          - Тоже работает, но глючит.

      # Про Git Bash
        - Например, Git Bash. См.ссылку выше.
        - После этого можно прописать путь к sh.exe в PATH.
        - И переходить в режим bash из powershell, когда нужно, вводя команду:

            sh --login -i

        - А выйти из этого режима можно, введя exit.
        - Чтобы упростить всё, можно добавить в $profile функцию:

            1. Открыть profile, введя: notepad $profile
            2. Добавить функцию:

              # Вход в режим bash shell:
              function bash() { sh --login -i }

        - Теперь в режим bash можно входить, набрав: bash

    9. Создать ssh-ключи для доступа к homestead через ssh
      - Для этого сначала перейти в bash-режим.
      - Затем ввести команду:

          ssh-keygen -t rsa -C "4gekkman@gmail.com"

      - При этом в каталоге C:\Users\German\.ssh должны создаться 2 ключа:
        # id_rsa      | секретный ключ
        # id_rsa.pub  | открытый ключ

    10. Настроить homestead.yaml
      - Ниже приведена рабочая конфигурация с комментариями.

      ---
      ip: "192.168.10.10"
      memory: 4096
      cpus: 2
      provider: virtualbox

      authorize: C:\Users\German\.ssh\id_rsa.pub

      keys:
          - C:\Users\German\.ssh\id_rsa

      folders:
          - map: C:\WebDev\projects
            to: /home/vagrant/projects
            type: nfs

      sites:
          - map: zaste.ru
            to: /home/vagrant/projects/zaste.ru/app/Public
          - map: lk.zaste.ru
            to: /home/vagrant/projects/zaste.ru/app/Public
          - map: img.zaste.ru
            to: /home/vagrant/projects/zaste.ru/app/Public  

      databases:
          - general

      variables:
          - key: APP_ENV
            value: local

      # blackfire:
      #     - id: foo
      #       token: bar
      #       client-id: foo
      #       client-token: bar

      # ports:
      #     - send: 93000
      #       to: 9300
      #     - send: 7777
      #       to: 777
      #       protocol: udp

    11. Установить box с homestead
      - Для этого выполнить команду: homestead up
      - Устанавливается довольно долго, можно пока попить чайку.
      - Кстати, если запустить VirtualBox, то мы увидим бокс Homestead.

    12. Отредактировать файл hosts
      - Вставить туда такую строку:

          192.168.10.10 homestead

    13. Подключиться к боксу homestead по ssh и установить laravel
      - Для подключения по SSH надо в bash-режиме ввести:

          homestead ssh

      - Затем перейти в каталог Code, адрес к которому указан в разделе
        folders файла homestead.yaml
      - И установить в него свежую версию laravel:

          composer create-project laravel/laravel [имя проекта] --prefer-dist


  > Полный список команд Homestead
    - Можно вывести, введя: homestead list
    - Основные команды:

      up        // запустить (установить, если нет) виртуальную машину homestead
      halt			// остановить виртуальную машину

			destroy   // удалить виртуальную машину homestead

      suspend   // поставить на паузу ВМ homestead
      resume    // снять с паузы ВМ homestead

      list      // список команд homestead
      ssh       // соединиться с ВМ homestead по ssh

      init      // создать конфиг homestead.yaml
      edit      // редактировать конфиг homestead.yaml
      status    // показать статус виртуальной машины


  > Работать с homestead по ssh лучше через Putty

    > Почему?
      - Нормально отображаются русские шрифты.
      - Ничего не съезжает при редактировании текста в редакторе.
      - Вообще, минимум беспокойств, всё работает хорошо.
      - Скачать putty можно здесь:
          http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html

    > Как подключиться по логину и паролю?
      - Использовать адрес 127.0.0.1 и порт 2222.
      - Логин и пароль: vagrant

    > Как подключаться по ключам

      1. Скачать puttygen.exe
        - И сгенерировать из секретного rsa-ключа ключ в формате putty.
        - Положить его в каталог [пользователь]/.ssh

      2. Настроить putty и сохранить конфигурацию
        - Параметры в session: адрес 127.0.0.1 и порт 2222.
        - В ssh -> auth указать созданных в пункте 1 ключ.
        - Сохранить конфигурацию в session.
        - При подключении указать логин: vagrant

    > Как добавить putty в ConEmu

      1. Добавить в настройках ConEmu новый Task:
        - В Startup -> Tasks нажать внизу на плюсик.
        - Добавить Task с именем PuTTY, и кодом запуска:

            putty.exe -new_console

      2. Теперь putty можно запускать в терминале conemu.


	> Как перенести БД (mysql) в HomeStead с помощью WorkBench

		1. Сделать дамп старой БД
			- Открыть MySQL WorkBench.
			- Подключиться к старой БД.
			- Далее в меню: server -> data export
			- Выбрать "as a single file", указать прочие опции.
			- Нажать export, и будет создан дамп.

		2. Импортировать сделанный дамп в БД в homestead
			- Открыть MySQL WorkBench.
			- Подключиться к MySQL-серверу Homestead.
			- Далее в меню: server -> data import

	> Возможные проблемы, и их решения

		1) "No input file specified" при попытке открыть сайт

			Проблема
			--------
				- Добавили новый сайт через homestead.yaml
				- Перезагрузили виртуальную машину (halt/up)
				- При попытке зайти на сайт, получае такую надпись в браузере:
						"No input file specified"

			Решение
			-------
				- Подключиться к homestead по ssh через PuTTY
				- К сведению, homestead по умолчанию использует HTTP-сервер nginx
			 	- Зайти в каталог /etc/nginx/sites-available
				- Проверить, есть ли там файл-конфиг с именем, равным хосту сайта
				- И правильные ли в нём содержатся настройки
				- В общем, если нет: создать, настроить.
				- Для надежности можно ещё перезапустить homestead:
						homestead halt
						homestead up

		2) Таблица 'homestead.[имя таблицы]' не найдена

			Проблема
			--------
				- В homestead.yaml, в Variables, есть переменная APP_ENV
				- Она содержит значение local
				- Это обозначает имя среды, и предназначается для Laravel
				- Laravel 4 в таком случае идёт в каталог app/config/local
				- И перезаписывает основные конфиги конфигами оттуда
				- А Homestead кладёт туда конфиг database.php
				- В котором указывает имя БД: homestead

		  Решение для laravel4
			--------------------
				- Удалить каталог app/config/local

		3) Отсутствует модуль ImageMagic в php в homestead

			Проблема
			--------
				- Такого модуля там нет.
				- Без него сервер изображений не будет работать.

			Решение
			-------
				- Установить этот модуль.
				- Для этого ввести следующие команды в терминале homestead:

					sudo apt-get install imagemagick
					sudo apt-get install php5-imagick
					sudo service nginx restart

				- Проверить модули php и убедиться, что там есть imagemagic:

					php -m

		4) При каждом halt/up дропаются мои базы данных
			- На самом деле, их дропает команда provision.
			- И лишь в том случае, если имя БД есть в homestead.yaml.
			- Эта команда как бы возвращает всё в первоначальное состояние.

		5) Как увеличить memory_limit в php.ini?
			- Сначала надо увеличить оный в /etc/php5/fpm/php.ini до величины X.
			- Затем в /etc/php5/fpm/php.ini добавить такую строку (в конец):

					php_admin_value[memory_limit] = [X]M

			- В ней [X] надо заменить на соотв.значение.

		6) Laravel выдаёт ошибку: predis недоступен

			Проблема
			--------
			  - Возникает, если механизмом сессий установлен redis
				- А именно, в файле .env, в корне приложения, SESSION_DRIVER=redis
				- Всё потому, что в laravel 5 по умолчанию отсутствует пакет с predis
				- А predis, это redis-библиотека для php.

				Решение
				-------
			  	1. В composer.json, в require, добавтить "predis/predis": "~1.1@dev"
					2. Выполнить в каталоге приложения команды:

							composer update
							composer dump-autoload

	  7) Nginx не обрабатывает запросы, хотя в homestead.yaml всё указано
			- Надо зайти в каталог /etc/nginx/avaible-sites
			- И проверить, есть ли там файл, имя которого совпадает с хостом.
			- Если есть, то зайти внутрь, и проверить, всё ли там правильно.
			- Если нет, то надо создать, и правильно заполнить.
			- А затем перезагрузить сервер (halt/up).

  > Ускорение homestead, уменьшение времени отклика

    # Суть проблмы
      - Слишком большое время отклика при работе с homestead.
      - Оно даже может достигать 75 секунд в некоторых случаях.
      - В результате, nginx возвращает timeout 504, что печально.
      - Да и каждый раз ждать десятки секунд перезагрузки страницы не хочется.

    # Возможные решения (могут дополнять друг друга)

      1) Фиксированный жесткий диск, вместо динамического
        
        # Общая информация
          - Первоисточник в этом топике: https://laracasts.com/discuss/channels/general-discussion/for-those-who-find-homesteadvagrantvirtualbox-slow-on-windows
          - Автор утверждает, что homestead тормозит из-за динамического жесткого диска.
          - Мол, надо сделать его фиксированным, и это существенно ускорит отображение веб-документов.

        # Как проверить, динамический ли диск настроен для homestead
          - Открыть программу virtualbox.
          - Зайти в настройки бокса homestead.
          - Открыть раздел "носители", и щёлкнуть по нему.
          - Выбрать box-disk1.vmdk, щёлкнув по нему.
          - Справа будет подробная информация о нём.
          - При установке homestead, по умолчанию идёт именно динамический диск.

        # Пошаговая инструкция по конвертации диска из динамического в фиксированный
            На основе статьи: http://maxrohde.com/2014/06/21/convert-dynamically-sized-virtualbox-vdi-hard-drive-to-fixed-size/

          1] Получить путь к файлу .vmdk, который надо конвертировать

            1.1] Получить путь
              - Открыть программу VirtualBox в окне windows.
              - Открыть настройки виртуальной машины homestead.
              - Открыть вкладку носители (слева).
              - Щёлкнуть по подключенному динамическому жесткому диску.
              - Посмотреть справа, в его свойствах - "расположение".
              - Скопировать куда-нибудь это расположение.

            1.2] Если путь содержит в себе кракозябры
              - Например, выглядит так:

                  C:\Users\Р“РµСЂРјР°РЅ\VirtualBox VMs\settler_default_1434987271004_24349_1439740072455_33253\box-disk1.vmdk

              - То придётся его куда-нибудь скопировать в другое место.
              - Чтобы путь не содержал кракозябры.
              - Например:

                  "C:\Users\German\VirtualBox VMs\homestead\Virtual Drives\box-disk1.vmdk"

          2] Открыть окно терминала и перейти в каталог VirtualBox
            - Для этого, ввести в окне терминала:

                cd “C:\Program Files\Oracle\VirtualBox”

            - Если VirtualBox установлен по другому адресу, используйте его.

          3] Вручную удалить динамический жесткий диск
            - Внимание! Этот шаг выполняется, только если в пункте 1] путь к диску содержал кракозябры, и диск был скопирован в другое место.
            - Открыть программу VirtualBox, настройки бокса homestead, раздел Носители.
            - Удалить из носителей динамический жесткий диск.
            - Выполнить в терминале команду, чтобы посмотреть список зарегистрированных в virtualbox жестких дисков:

                .\VBoxManage.exe list hdds

            - Найти там динамич.жесткий диск от homestead'а.
            - Скопировать куда-нибудь его UUID.
            - Выполнить следующую команду (шаблон), чтобы его удалить:

                .\vboxmanage closemedium disk <UUID of your drive> --delete

            - Пример:

                .\vboxmanage closemedium disk f84af9ea-14f1-4005-bf1f-953ae05b5213 --delete

            - Убедиться в том, что диск удалён, ещё раз запустив команду list hdds.

          4] Создать фиксированную копию динамического диска
            - Для этого надо выполнить следующую команду (шаблон):

                .\VBoxManage.exe clonehd "ПУТЬ К ФАЙЛУ .vmdk" "ПУТЬ К ФАЙЛУ .vdi" --variant Fixed

            - Где вместо "ПУТЬ К ФАЙЛУ .vmdk" надо вставить путь из 1].
            - А вместо "ПУТЬ К ФАЙЛУ .vdi" вставить такой же путь, только .vmdk заменить на .vdi
            - Пример:

                .\VBoxManage.exe clonehd "C:\Users\German\VirtualBox VMs\homestead\Virtual Drives\box-disk1.vmdk" "C:\Users\German\VirtualBox VMs\homestead\Virtual Drives\box-disk1.vdi" --variant Fixed

            - Это может занять прилично времени, например, 30-60 минут.

          5] Выполнить шаг №3, если он ещё не выполнен

          6] Добавить созданный фиксированный диск в virtualbox
            - Открыть программу VirtualBox, настройки бокса homestead, раздел Носители.
            - Добавить.

      2) Передача файлов через NFS
        
        # Общая информация
          - Играет ключевое значение в ускорении.

        # Решение для Mac и Ubuntu
          - В homestead.yaml надо для каждого каталога указать type: nfs
          - Например:

              folders:
                  - map: C:\WebDev\projects
                    to: /home/vagrant/projects
                    type: nfs              

          - Причём, проследить, чтобы в файле не было табуляций (вместо них пробелы).
          - Иначе, будет ошибка.

        # Решение для Windows

          1] Установить плагин winnfsd для vagrant
            - Это позволит использовать NFS с vagrant на windows.
            - Для этого ввести в окне терминала windows следующее:

                vagrant plugin install vagrant-winnfsd

          2] Скачать модифицированный файл winnfsd
            - Скачать его можно по ссылке ниже.
            - Надо искать последнюю версию, в нижней части ветки.
            - Ссылка:

                https://bitbucket.org/jankowfsky/winnfsd/issues/9/rename-file-on-vm-does-not-work-previously

          3] Заменить оригинальный WinNFSd.exe на модифицированный
            - Для этого пройти по адресу (пример):

                C:\Users\German\.vagrant.d\gems\gems\vagrant-winnfsd-1.1.0\bin

            - Затем открыть диспетчер задач, и убить старый процесс WinNFSd.exe.

          4] Открыть homestead.yaml и убедиться, что там мапится лишь 1 каталог
            - Потому что эта штука не работает, если мапятся >= 2 каталогов.
            - При наличии нескольких проектов, надо их сложить в 1 каталог.
            - А этот каталог и мапить.
            - Например:

                folders:
                    - map: C:\WebDev\projects
                      to: /home/vagrant/projects
                      type: nfs            

          5] Внести изменения в homestead.rb
            - Первым делом, открыть этот файл.
            - Он лежит по адресу (пример):

                C:\Users\German\AppData\Roaming\Composer\vendor\laravel\homestead\scripts

            - Найти там следующий кусок кода:

                # Register All Of The Configured Shared Folders
                if settings.include? 'folders'
                 settings["folders"].each do |folder|
                   mount_opts = folder["type"] == "nfs" ? ['actimeo=1'] : []
                   config.vm.synced_folder folder["map"], folder["to"], type: folder["type"] ||= nil, mount_options: mount_opts
                 end
                end    

            - И заменить на следующий:        

                # Reorder folders for winnfsd plugin compatilibty
                # see https://github.com/GM-Alex/vagrant-winnfsd/issues/12#issuecomment-78195957
                settings["folders"].sort! { |a,b| a["map"].length <=> b["map"].length } 

                # Register All Of The Configured Shared Folders
                if settings.include? 'folders'
                 settings["folders"].each do |folder|
                   mount_opts = folder["type"] == "nfs" ? ['nolock,vers=3,udp,noatime,actimeo=1'] : []
                   config.vm.synced_folder folder["map"], folder["to"], type: folder["type"] ||= nil, mount_options: mount_opts
                 end
                end  

          6] В конфиге nginx отключить sendfile
            - Для этого открыть окно терминала homestead'а.
            - В нём ввести:

                sudo nano /etc/nginx/nginx.conf

            - Найти там настройку sendfile (CTRL + W).
            - И изменить её значение на off. Сохранить.
            - Это позволит избежать проблем с кэшированием при использовании NFS.

          7] Добавить правило в фаервол
            - Фаервол мешает NFS работать, и не позволит ему загрузиться.
            - Чтобы NFS работал нормально, надо добавить в фаервол доп.правила.
            - А именно, надо добавить правило, разрешающее любые действия файлу:

                C:\Users\German\.vagrant.d\gems\gems\vagrant-winnfsd-1.1.0\bin\WinNFSd.exe

            - В ESET Smart Security это делается так.
            - Щёлчёк по икноке в трее -> дополнительные настройки.
            - Сеть -> Персональный фаервол -> Правила и зоны.
            - Настройки редактора зон и правил -> Создать.
            - Создать правило по имени WinNFSd.
            - На вкладке "Локальный" выбрать указанный выше файл.

          8] Перезагрузить

              homestead halt
              homestead up

        # Возможные проблемы для решения для Windows

          1] Проблема с портом 8000
            - Внезапно, homestead перестаёт работать.
            - В ответ на запрос получаем: "no input file specified".
            - А при попытке перезагрузить homestead получаем:

                Vagrant cannot forward the specified ports on this 
                VM, since they would collide with some other 
                application that is already listening on these ports. 
                The forwarded port to 8000 is already in use on the 
                host machine 

            - Видимо, порт 8000 начинает использоваться какой-то сторонней программой.
            - Решить это можно так.
            - Надо открыть файл:

                C:\Users\German\AppData\Roaming\Composer\vendor\laravel\homestead\scripts\homestead.rb

            - В нём найти строку "Default Port Forwarding".
            - И в объекте изменить 8000 на 8001. И сохранить.
            - Выключить homestead с помощью команды: homestead halt
            - Убить процесс WinNFSd.exe.
            - После этого homestead должен стартовать нормально.        
          
          2] Ошибка 502
            - Локальный сайт в homestead не открывается.
            - Возникает ошибка 502.
            - Она означает проблему с php-fpm.
            - Проблема возникала на homestead 0.4.0.
            - Надо было перейти в:
                C:\Users\German\AppData\Roaming\Composer\vendor\laravel
            - Скачать новый homestead отсюда:
                https://github.com/laravel/homestead
            - И закачать в ту папку, убрав старый.

  > Добавить новый mysql-сервер в homestead для нового проекта

    # Суть проблемы
      - Я использую модульную структуру для приложений.
      - Каждый модуль у меня содержится в отдельной БД.
      - Примеры имён таких БД: "M1", "M2", "M3" ...
      - На сервере MySQL не может быть 2 БД с одинаковым именем.
      - А имена БД для модулей менять запрещено.
      - Итог: 2 моих разных проекта не могут использовать 1 сервер MySQL.
      - Следствие: под каждый мой проект нужен отдельный сервер MySQL.
      - Рассмотрим, как в homestead добавить новый сервер MySQL.

    # Пошаговое решение

      1. Добавить порт для нового MySQL-сервера в homestead.yaml
        - Допустим, у нас уже есть MySQL-сервер, использующий порт 3306.
        - А порт 3307 свободен, и мы его хотим добавить под новый MySQL-сервер.
        - Открываем конфиг homestead.yaml, и туда добавляем:

            ports
                ... [здесь переадресации других портов] ...
                - send: 33070
                  to: 3307
                ... [здесь переадресации других портов] ...     

        - При этом следим за соблюдением отступов.
        - И чтобы не было нигде табов вместо пробелов.
        - Сохраняем, дело сделано.

      2. Подготовить место для наших будущих баз
        - Допустим, базы текущего сервера лежат в: /var/lib/mysql
        - А каталог /var/lib/mysql2 отсутствует.
        - Выполнить следующее:

          cd /var/lib                           | перейти в каталог lib
          mkdir /var/lib/mysql2                 | создать каталог mysql2 в lib
          chown -R mysql:mysql /var/lib/mysql2  | сделать (рекурсивно) владельцем каталога mysql

      3. Подготовить место для логов

          mkdir /var/log/mysql2                 | создать каталог mysql2 в /var/log
          chown -R mysql:mysql /var/log/mysql2  | сделать mysql его владельцем

      4. Скопировать конфиги старого mysql для нового

          mkdir /etc/mysql2                         | создать каталог mysql2 в /etc
          cp /etc/mysql/my.cnf /etc/mysql2/my.cnf   | скопировать в него конфиг старого mysql

      5. Заменить в новом конфиге mysql на mysql2 там, где надо

        [client]
        port              | с 3306 на 3307
        socket            | с mysqld.sock на mysqld2.sock

        [mysqld_safe]
        socket            | с mysqld.sock на mysqld2.sock

        [mysqld]
        pid-file          | с mysqld.pid на mysqld2.pid
        socket            | с mysqld.sock на mysqld2.sock
        port              | с 3306 на 3307
        datadir           | с /var/lib/mysql на /var/lib/mysql2
        log_error         | с /var/log/mysql/error.log на log_error = /var/log/mysql2/error.log

      6. Отредактируем конфиг в apparmor 
        - Откроем конфиг: nano /etc/apparmor.d/usr.sbin.mysqld
        - И добавим туда:

          /etc/mysql2/*.pem r,
          /etc/mysql2/conf.d/ r,
          /etc/mysql2/conf.d/* r,
          /etc/mysql2/my.cnf r,
          /usr/sbin/mysqld mr,
          /var/log/mysql2.log rw,
          /var/log/mysql2.err rw,
          /var/lib/mysql2/ r,
          /var/lib/mysql2/** rwk,
          /var/log/mysql2/ r,
          /var/log/mysql2/* rw,
          /var/run/mysqld/mysqld2.pid w,
          /var/run/mysqld/mysqld2.sock w,        

      7. Займёмся базой

          cp /etc/mysql/my.cnf /usr/share/mysql/my-default.cnf
          mysql_install_db –datadir=/var/lib/mysql2/

      8. Запустим наш новый сервер mysql

          /usr/bin/mysqld_safe –defaults-file=/etc/mysql2/my.cnf

      9. Установим root-пароль

          /usr/bin/mysqladmin -u root -S /var/run/mysqld/mysqld2.pid password ‘somepassword’      

  > Отдельный homestead для каждого проекта
    - Удобно иметь отдельный бокс homestead для каждого проекта.
    - Как это реализуется:

      1) Прописываем в composer.json проекта зависимость homestead
        - Переходим в каталог проекта.
        - Открываем composer.json.
        - Прописываем в require-dev зависимость от homestead, указав нужную версию:

            "laravel/homestead": "3.0.1"

        - Делаем composer update.

      2) Запускаем команду make
        - В каталоге проекта запускаем компнду make.
        - Вот так:

            vendor\bin\homestead make

        - Это создаёт в каталоге проекта Vagrantfile и homestead.yaml.

      3) Настраиваем homestead.yaml
        - Вот пример настройки:

                ---
                ip: "192.168.10.10"
                memory: 2048
                cpus: 2
                hostname: development.app
                name: development.app
                provider: virtualbox

                authorize: C:\WebDev\bin\ssh_keys_for_homestead\id_rsa.pub

                keys:
                    - C:\WebDev\bin\ssh_keys_for_homestead\id_rsa

                folders:
                    - map: "C:/WebDev/projects/development.app"
                      to: "/home/vagrant/development.app"
                #      type: nfs

                sites:
                    - map: development.app
                      to: "/home/vagrant/projects/development.app/app/Public"

                databases:
                    - general

                # blackfire:
                #     - id: foo
                #       token: bar
                #       client-id: foo
                #       client-token: bar

                # ports:
                #     - send: 50000
                #       to: 5000
                #     - send: 7777
                #       to: 777
                #       protocol: udp
        
      4) Запускаем нужный бокс homestead
        - Можно получить последнюю версию бокса homestead,
          выполнив vagrant box update
        - Выполняем команду vagrant up.
        - При этом vagrant ищет ближайший vagrantfile.
        - Начинает он поиски с текущего каталога.
        - Таким образом, надо выполнять vagrant up в каталоге проекта.
        - И тогда будет запущен бокс именно для этого проекта.

      5) Подключаемся через putty по 127.0.0.1:2222
        - Сабж.


А4.  Routing

  --------------------------------------
  Подоглавление:

    - Введение
    - Наглядный пример
		- Как изменить путь, где Laravel ищет routes.php
    - Декомпозиция описания Routing

  --------------------------------------

  > Введение
    - Routing - переводится как маршрутизация. А route - маршрутизатор.
    - Все роуты хранятся в файле "app/http/routes.php".
		- Этот файл загружается в приложение сервис-провайдером
			App\Providers\RouteServiceProvider.
    - Роутов в routes.php может быть сколько угодно.
    - Роут на входе проверяет условия: метод запроса, адрес запроса.
    - Если условия выполняются - роут срабатывает. Иначе - не срабатывает.
    - Сработавший роут выполняет заданную в описании функцию.
    - Это может быть анонимная функция, описанная прямо в routes.php.
    - А может быть ссылка на метод контроллера. А контроллер при этом
      находятся в отдельном файле-классе, в каталоге "app/http/controllers".

  > Наглядный пример
    - Этот роут реагирует на запрос методом GET к корню сайта.
    - Реакция состоит в выполнеии анонимной функции.
    - Анонимная функция просто возвращает строку.

        Route::get('/', function()
        {
            return 'Hello World';
        });

	> Как изменить путь, где Laravel ищет routes.php
		- Это определяется в сервис-провайдере app/Providers/RouteServiceProvider.php
		- Там, в public function map, можно прописать путь к routes.php

  > Декомпозиция описания Routing

    5.  Routing
      5.1.  Основы роутинга. Роутинг на анонимную функцию.
        - Роутинг можно проводить на анонимную функцию или на контроллер.
        - Здесь описаны основы роутинга на анонимную функцию.

      5.2.  Параметры роутинга.
        - В пути роута можно указывать плейсхолдеры.
        - Можно получить значение плейсхолдера в функции, которую исполняет роут.
        - С помощью where и RegExp можно задавать ограничения для плейсхолдеров.
        - С помощью Route::pattern можно задавать глобальные ограничения на конкретный
          плейсхолдер, действующие во всём файле routes.php.

      5.3.  Защита от CSRF (Cross Site Request Forgery)
        - При отправке ajax-запроса надо в HTTP-заголовок "X-CSRF-TOKEN"
				  помещать значение csrf-токена {{ csrf_token() }}.
				- На сервере сервис-провайдер 'App\Http\Middleware\VerifyCsrfToken'
				  проверяет токен, если верный - пропускает, иначе нет.
			  - Работает для запросов всеми методами, кроме HEAD, GET и OPTIONS.

      5.4.  Именованные роуты.
        - Роутам можно задавать имена.
        - На именованные роуты можно делать редиректы по их имени.
        - Также по имени роута с помощью URL::route можно формировать URL.
        - Route::currentRouteName(): получить имя текущего запущенного роута

      5.5.  Группировка роутов.
        - Несколько роутов можно объединять в группы.
        - Это позволяет применить фильтр ко всей группе сразу.
        - Также это позволяет задать namespace для всей группы сразу.

      5.6.  Роутинг поддоменов.
        - Поддомен в пути роута также можно задавать с помощью плейсхолдера.
        - Это по сути тоже самое, что описано в 4.2.

      5.7.  Префиксинг группы роутов.
        - Группе роутов можно установить префикс.

      5.8.  Связывание роута с моделью.
        - Можно передать колбэк-функции роута экземпляр класса модели.
        - Можно использовать номер экземпляра как плейсхолдер в пути роута.

      5.9.  Возбуждение ошибки 404.
        - В колбэк-функции роута можно вручную возбудить ошибку 404.
        - Сделать это можно функцией: App::abort(404)

      5.10. Роутинг на контроллер.
        - Роутинг не обязательно надо осуществлять на анонимную функцию.
        - Иначе так можно засорить файл routes.php под завязку.
        - Если объём кода велик, стоит осуществлять роутинг на метод контроллера.
        - Контроллер - класс в отдельном файле.
        - Контроллеры в Laravel хранятся в папке "app/controllers".


  > 5.1.  Основы роутинга. Роутинг на анонимную функцию.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры роутинга на анонимную функцию

    --------------------------------------

    > Введение
      - Роутинг можно проводить на анонимную функцию или на контроллер.
      - Здесь описаны основы роутинга на анонимную функцию.
      - Такой роутинг стоит использовать, если объём кода не велик.
      - В противном случае стоит использовать роутинг на метод контроллера,
        т.о. вынеся большой объём кода в отдельный файл контроллера.

    > Примеры роутинга на анонимную функцию
      - Роут, реагирующий на запрос методом GET к корню сайта:

            Route::get('/', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запрос методом POST по адресу '/foo/bar' от корня:

            Route::post('foo/bar', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запросы методами GET и POST к корню сайта:

            Route::match(array('GET', 'POST'), '/', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запрос любым методом по адресу 'foo' от корня:

            Route::any('foo', function()
            {
                return 'Hello World';
            });

      - Роут, реагирующий на запрос методом GET по адресу 'foo' от корня,
        при этом запрос должен быть через протокол HTTPS:

            Route::get('foo', array('https', function()
            {
                return 'Must be over HTTPS';
            }));

      - Сгенерировать абсолютный URL к роуту можно:

            $url = URL::to('foo');		// так ...
						$url = url('foo');				// ... или так


  > 5.2.  Параметры роутинга.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры

    --------------------------------------

    > Введение
      - В пути роута можно указывать плейсхолдеры.
      - Можно получить значение плейсхолдера в функции, которую исполняет роут.
      - С помощью where и RegExp можно задавать ограничения для плейсхолдеров.
      - С помощью Route::pattern можно задавать глобальные ограничения на конкретный
        плейсхолдер, действующие во всём файле routes.php.

    > Примеры

      > Параметры роутинга
        - Как часть пути роута указывается 1 или более плейсхолдеров.
        - Их значения внутри роутинговой функции можно получить из аргументов.
        - Имена аргументов должны совпадать с именами соотв. плейсхолдеров.
        - В примере ниже использован плейсхолдер {id}.
        - Его значение внутри аноним.функции можно получить из аргумента $id.

            Route::get('user/{id}', function($id)
            {
                return 'User '.$id;
            });

        - ОСТОРОЖНО: символ "_" не может содержаться в параметрах роутинга.

      > Необязательные параметры роутинга
        - Можно сделать параметры роутинга необязательными.
        - Но при этом их возможное наличие будет предусмотрено конструкуией.
        - На необязательность указывает символ '?' в конце плейсхолдера.
        - В примере ниже использован плейсхолдер {name?}
        - Если в запросе плейсхолдер останется пуст, то значение $name будет null

            Route::get('user/{name?}', function($name = null)
            {
                return $name;
            });

      > Необязательные параметры роутинга с заданными значениями "по умолчанию"
        - Значение "по умолчанию" - чему будет равен параметр, если его плейсхолдер
          в пути не будет заполнен.
        - В предыдущем примере null является значением "по умолчанию" для $name.
        - А в примере ниже у параметра $name зачение по умолчанию: 'John'

            Route::get('user/{name?}', function($name = 'John')
            {
                return $name;
            });

      > Фильтрация параметров с помощью метода where и RegExp
        - Фильтр как бы говорит: "если параметр матчится с заданным RegExp,
          и все остальные условия выполнены, то запускай роут. Иначе - нет.".
        - В примере ниже {name} должен состоять из латинских букв в любом
          регистре, иначе роут не будет запущен:

            Route::get('user/{name}', function($name)
            {
                //
            })
            ->where('name', '[A-Za-z]+');

        - В примере ниже {id} должен состять полностью из цифр, иначе роут
          не будет вызван:

            Route::get('user/{id}', function($id)
            {
                //
            })
            ->where('id', '[0-9]+');

        - А вот как это делается сразу для нескольких параметров:

            Route::get('user/{id}/{name}', function($id, $name)
            {
                //
            })
            ->where(array('id' => '[0-9]+', 'name' => '[a-z]+'))

      > Фильтрация с помощью RegExp: глобальный паттерн
        - В примерах выше фильтрацию приходилось прописывать для каждого роута.
        - Вместо этого для конкретного параметра можно сделать перманентный фильтр.
        - Он будет действовать на все параметры в файле routes.php.
        - Сделать это можно с помощью метода Route::pattern
        - В примере ниже такой перманентный фильтр установлен для параметра {id}.
          Он должен состоять полностью из цифр, иначе роут не будет запущен:

            Route::pattern('id', '[0-9]+');

      > Доступ к значению параметров извне колбэк-функции роута
        - Допустим, надо получить доступ к значению параметров из фильтров
          (функций-обработчиков событий before и after).
        - Сделать это можно с помощью функции Route::input, как в примере ниже:

            Route::filter('foo', function()
            {
                if (Route::input('id') == 1)
                {
                    //
                }
            });


  > 5.3.  Защита от CSRF (Cross Site Request Forgery)

    --------------------------------------
    Подоглавление:

      - Введение
			- Построение защиты от CSRF в Laravel 5

    --------------------------------------

		> Введение
			- CSRF является распространённым методом хакерской атаки.
			- Прихоидт AJAX-запрос от пользователя, но с другого хоста.
			- Этот запрос использует аутентиф.куки пользователя.
			- Но запрос инициирован и управляется хакером, владеющим тем хостом.
			- Защита: принимать запросы только со своего хоста.
			- Для этого при формировании view мы выдаём ему уникальный токен.
			- При поступлении AJAX-запроса сверяем, если не подходит - отклоняем.

		> Построение защиты от CSRF в Laravel 5

			При отправке AJAX-запроса методом POST из клиента
			-------------------------------------------------
				- Требуется задавать HTTP-заголовок "X-CSRF-TOKEN".
				- И инициировать его значением csrf-токена: {{ csrf_token() }}
				- В противном случае, middleware VerifyCsrfToken.php не пропустит запрос.

			При приёме ajax-запроса методом POST из клиента
			-----------------------------------------------
				- По умолчанию, в app/Htpp/Kernel.php изначально подключен
					middleware 'App\Http\Middleware\VerifyCsrfToken'.
				- Он проверяет запросы всеми методами, кроме HEAD, GET и OPTIONS.
				- Он извлекает значение из заголовка HTTP-запроса "X-CSRF-TOKEN".
				- И сверяет его с правильным csrf-токеном.
				- Если подходит, то пропускает запрос, а если нет, то не пропускает.


  > 5.4.  Именованные роуты.

    --------------------------------------
    Подоглавление:

      - Введение
      - Примеры

    --------------------------------------

    > Введение
      - Роутам можно задавать имена.
      - На именованные роуты можно делать редиректы по их имени.
      - Также по имени роута с помощью URL::route можно формировать URL.
      - Route::currentRouteName(): получить имя текущего запущенного роута

    > Примеры
      - Вот как можно задать имя роуту на анонимную функцию при его
        определении:

          Route::get('user/profile', array('as' => 'profile', function()
          {
              //
          }));

      - А вот как это сделать для роута на метод контроллера:

          Route::get('user/profile', array('as' => 'profile', 'uses' => 'UserController@showProfile'));

      - Вот как можно теперь сделать редирект:

          $redirect = Redirect::route('profile');

      - А вот так можно сделать URL:

          $url = URL::route('profile');

      - И вот так получить имя сработавшего роута из него самого:

          $name = Route::currentRouteName();


  > 5.5.  Группировка роутов.

    --------------------------------------
    Подоглавление:

      - Введение
      - Где определять middleware для применения к роутам
      - Применение указанных middleware к группе роутов
      - Квалификация всех контроллеров в группе указанынм пр.имён

    --------------------------------------

    > Введение
      - Несколько роутов можно объединять в группы.
      - Это позволяет применить фильтр ко всей группе сразу.
      - Также это позволяет задать namespace для всей группы сразу.

    > Где определять middleware для применения к роутам
      - Сам middleware-класс класть в app/Http/Middleware
      - Подключать его к приложению в файле app/Http/Kernel.php:
        в св-ве $routeMiddleware.

    > Применение указанных middleware к группе роутов
      - Допустим, мы хотим применить набор middleware к группе роутов.
      - Это можно сделать так:

          Route::group(['middleware' => ['foo', 'bar']], function()
          {
              Route::get('/', function()
              {
                  // Has Auth Filter
              });

              Route::get('user/profile', function()
              {
                  // Has Auth Filter
              });
          });

    > Квалификация всех контроллеров в группе указанынм пр.имён
      - А вот так можно для всех роутров в группе обозначить, что все
        пути к контроллерам будут квалифицироваться указанным пр.имён:

          Route::group(['namespace' => 'Admin'], function()
          {

            // Controllers Within The "App\Http\Controllers\Admin" Namespace

            Route::group(['namespace' => 'User'], function()
            {

                // Controllers Within The "App\Http\Controllers\Admin\User" Namespace
            
            });

          });

      - Причём, по умолчанию RouteServiceProvider включает файл routes.php
        в пространство имён групп, что позволяет в каталоге app\Http\Controllers
        определять классы-контроллеры, без указания namespace-префикса App\Http\Controllers 


  > 5.6.  Роутинг поддоменов.

    --------------------------------------
    Подоглавление:

      - Введение
      - Пример

    --------------------------------------

    > Введение
      - Поддомен в пути роута также можно задавать с помощью плейсхолдера.
      - Это по сути тоже самое, что описано в 4.2.

    > Пример
      - Пример ниже показывает, как разруливать поддомены.
      - Для этого надо определить группу.
      - В неё надо передать массив атрибутов группы с параметром domain
        и строкой с доменом, где в кач-ве поддомена использован плейсхолдер.
      - Внутри группы надо разместить роуты, разруливающие поддомены.
      - В роут имя задействованного поддомена передаётся в виде аргумента.
      - Имя аргумента должно совпадать с именем плейсхолдера.
      - В примере ниже имя плейсходлера {account}, имя аргумента $account.

        Route::group(array('domain' => '{account}.myapp.com'), function()
        {

            Route::get('user/{id}', function($account, $id)
            {
                //
            });

        });


  > 5.7.  Префиксинг группы роутов.

    --------------------------------------
    Подоглавление:

      - Введение
      - Пример 1: простое использование prefix
      - Пример 2: использование prefix с параметром роутинга
      - Пример 3: использование prefix с ограниченным параметром роутинга

    --------------------------------------

    > Введение
      - Группе роутов можно установить префикс.

    > Пример 1: простое использование prefix

        Route::group(array('prefix' => 'admin'), function()
        {

            Route::get('user', function()
            {
                // Matches The "/admin/users" URL
            });

        });

    > Пример 2: использование prefix с параметром роутинга

        Route::group(['prefix' => 'accounts/{account_id}'], function()
        {
            Route::get('detail', function($account_id)
            {
                //
            });
        });    

    > Пример 3: использование prefix с ограниченным параметром роутинга

        Route::group([
            'prefix' => 'accounts/{account_id}',
            'where' => ['account_id' => '[0-9]+'],
        ], function() {

            // Define Routes Here
        });


  > 5.8.  Связывание роута с моделью.

    --------------------------------------
    Подоглавление:

      - Введение
      - Особенности
      - Пример

    --------------------------------------

    > Введение
      - Можно передать колбэк-функции роута экземпляр класса модели.
      - Можно использовать номер экземпляра как плейсхолдер в пути роута.
      - Например, вместо того, чтобы передавать роуту ID пользователя, можно
        передать объект-экземпляр класса User, соответствующий этому ID.
        Т.Е. ID в пути роута приведёт к передаче объекта (а не ID) в роут.

    > Особенности

      > Нет модели? Держи ошибку 404.
        - Если указанная модель не будет найдена, то будет ошибка 404.

    > Пример
      - Работать это будет так. В ответ на, например, запрос "profile/1"
        в колбэк-функцию роута будет передан экземпляр класса User,
        отвечающий ID == 1. Получить к нему доступ можно через атрибут $user.
      - Как реализовать:

        1. Свяжем параметр user с моделью App\User
          - Делать это надо в app/Providers/RouteServiceProvider.php, в методе boot.
          - Пишем там такую строку:

              $router->model('user', 'App\User');

        2. Определим роут с параметром {user}:

            Route::get('profile/{user}', function(User $user)
            {
                //
            });


А5.  Middleware

  --------------------------------------
  Подоглавление:

    # Введение
 
      - Что такое middleware
      - Глобальные middleware, middleware на роутах
      - Before-, after- и terminable-middleware
      - Параметры в middleware

    # Определение и использование middleware

      - Создание нового класса-middleware
      - Код для before-middleware
      - Код для after-middleware
      - Код для terminable-middleware
      - Регистрация глобального middleware в $middleware
      - Регистрация роут-middleware, использование (в т.ч. с параметрами)
      - Определение и использование terminable middleware

  --------------------------------------

  > Введение
    
    Что такое middleware
    --------------------
      - Это фильтр, сквозь который проходит запрос.
      - Он представляет из себя отдельный php-класс.
   
    Глобальные middleware, middleware на роутах
    -------------------------------------------
      - Middleware м.б. как глобальными, так и прикрепленными к конкретным роутам.
      - Через глобальные middleware проходят ВСЕ запросы к приложению.
      - А через прикреплённые к роуту middleware проходят лишь запросы к этому роуту.

    Before-, after- и terminable-middleware
    ---------------------------------------
      - Бывают 3 типа middleware:

        1) Before-middleware
          - Код в middleware будет выполнен до обработки
            запроса приложением.

        2) After-middleware
          - Код в middleware будет выполнен уже после
            обработки запроса приложением.
          - Но ещё до отправки ответа клиенту.

        3) Terminable-middleware
          - Код в middleware будет выполнен уже после
            обработки запроса приложением.
          - И уже после отправки ответа клиенту.

    Параметры в middleware
    ----------------------
      - При определении middleware можно предусмотреть параметры.
      - Параметры можно указывать при прикреплении middleware роуту.


  > Определение middleware

    Создание нового класса-middleware
    ---------------------------------
      
      # Artisan-командой 
        - Создать новый middleware можно artisan-командой.
        - По умолчанию, новый файл появится в каталоге app/Http/Middleware/
        - Вот эта команда:

            php artisan make:middleware [имя нового middleware]

      # Вручную
        - Можно создать middleware и вручную.
        - Как выглядит содержимое класса-middleware, см.ниже.

    Код для before-middleware
    -------------------------

      <?php namespace App\Http\Middleware;

        use Closure;
        class NewMiddleware {

          /**
           * Handle an incoming request.
           *
           * @param  \Illuminate\Http\Request  $request
           * @param  \Closure  $next
           * @return mixed
           */
          public function handle($request, Closure $next, param1, param2, ...)
          {

              // ... код ...

              return $next($request);

          }

        }

    Код для after-middleware
    ------------------------

      <?php namespace App\Http\Middleware;

        use Closure;
        class NewMiddleware {

          /**
           * Handle an incoming request.
           *
           * @param  \Illuminate\Http\Request  $request
           * @param  \Closure  $next
           * @return mixed
           */
          public function handle($request, Closure $next, param1, param2, ...)
          {

              $response = $next($request);

              // ... код ...
              
              return $response;

          }

        }

    Код для terminable-middleware
    -----------------------------
      - Иногда надо выполнить код уже после ОТПРАВКИ запроса клиенту.
      - В том время, как обычные after-middleware выполняют код перед
        отправкой запроса клиенту, но после его обработки приложением.
      - Ну так вот, это позволяют делать т.н. terminable (заключительная) middleware
      - Например:

          В Laravel есть сессионная middleware, и она отправляет
          сессионные данные в хранилище лишь после того, как 
          ответ на запрос УЖЕ был отправлен пользователю.

          Эта сессионная middleware определена в app/Http/Kernel.php,
          в св-ве $middleware.

      - Вот, как выглядит terminable-middleware:

          use Closure;
          use Illuminate\Contracts\Routing\TerminableMiddleware;

          class StartSession implements TerminableMiddleware {

              public function handle($request, Closure $next)
              {
                  return $next($request);
              }

              public function terminate($request, $response)
              {
                  // Store the session data...
              }

          }  


    Регистрация глобального middleware в $middleware
    ------------------------------------------------
      
      # Регистрация
        - Допустим, мы хотим, чтобы наш middleware был глобальным.
        - Для этого его надо зарегистрировать таковым.
        - Открываем файл app/Http/Kernel.php.
        - В нём есть переменная $middleware. А в ней массив.
        - Добавляем наш новый middleware в этот массив.
        - Вуаля! Наш middleware стал глобальным. 
        - Теперь все HTTP-запросы к приложению проходят через него.

      # Порядок выполнения
        - От первого к последнему, как они идут в массиве $middleware.

    Регистрация роут-middleware, использование (в т.ч. с параметрами)
    -----------------------------------------------------------------

      # Регистрация
        - Допустим, мы хотим использовать наш middleware в роутах.
        - То есть, прикреплять к одному или более роутов.
        - И все запросы к этим роутам будут проходить через этот middleware.
        - Открываем файл app/Http/Kernel.php.
        - В нём есть переменная $routeMiddleware. А в ней массив.
        - Добавляем наш новый middleware в этот массив.
        - При этом, наш middleware получает удобный короткий псевдоним.

      # Использование
        - Рассмотрим пример использования.
        - Допустим, имеем GET-роут с URI 'admin/profile'.
        - И хотим применять роут-middleware с псевдонимом 'auth'.
        - Вот, как это делается:

            Route::get('admin/profile', ['middleware' => 'auth', function () {
                //
            }]);        

      # Использование с параметрами
        - Допустим, мы хотим проверять роль посетителя.
        - И если он не 'editor', то не пускать его в документ.
        - Для этого мы можем применить параметр:

            Route::put('post/{id}', ['middleware' => 'role:editor', function ($id) {
                //
            }]);


А6.  Контроллеры

  --------------------------------------
  Подоглавление:

    - Введение
    - Как изменить default-путь к папке с контроллерами
    - Основы работы с контроллерами
    - Контроллеры и пространства имён
    - Контроллеры и middleware
    - Неявные (RESTful) контроллеры (::controller)
    - Ресурсные контроллеры (::resource)
    - Контроллеры и dependency injection 
    - Кэширование роутов на контроллеры

  --------------------------------------

  > Введение
    - Выше уже было описано, что у роута может быть 2 варианта колбэк-функции.
    - Роут может быть на анонимную функцию или на метод контроллера.
    - Когда кода мало, то быстрее и проще сделать роут на анонимку прямо в routes.php.
    - Когда кода много, то лучше сделать роут на метод класса-контроллера.
    - Это позволит не засорять routes.php, сгребая всё в 1-ну кучу.
    - Обычно все файлы-контроллеры хранятся в папке "app/Http/controllers".
      - Этот путь для них зарегистрирован по умолчанию в composer.json.
      - Однако, можно положить файл-контроллер и в любую подпапку.
      - Например, положили мы его в папку "app/controllers/myFolder".
      - Теперь, чтобы всё заработало, надо выполнить команду композера dump-autoload.
    - Внимение! После создания нового класса-контроллера, надо выполнить
      команду композера dump-autoload, чтобы laravel увидел контроллер.

  > Как изменить default-путь к папке с контроллерами
    - Его можно изменить в App\Providers\RouteServiceProvider
    - Также потребуется изменить namespace в самих контроллерах.

  > Основы работы с контроллерами

    > Введение
      - В 1-м php-файле должен быть только 1 класс-контроллер.
      - Класс-контроллер наследует от класса Controller, который наследует от BaseController.
      - Controller также хранится в папке "app/Http/controllers".
      - В BaseController можно поместить некую общую для всех контроллеров логику.
      - Controller наследует от класса BaseController.

    > Примеры
      - Пример класса-контроллера:

          app/Http/Controllers/UserController
          -----------------------------------

            <?php

              namespace App\Http\Controllers;
              use App\Http\Controllers\Controller;
              
              class UserController extends Controller {

                  // Показать представление с профилем указанного пользователя
                  public function showProfile($id)
                  {
                      $user = User::findOrFail($id);
                      return view('user.profile', ['user' => user]);
                  }

              }

            ?>

      - Назначим метод showProfile из контроллера UserController в качестве
        колбэк функции для роута:

          Route::get('user/{id}', 'UserController@showProfile');

      - Если для контроллера задействованы пр.имён, то вот как можно
        было бы, например, написать пример выше:

          Route::get('foo', 'Namespace\FooController@method');

      - Можно задать имя для контроллера в определении роута
        (пока не понятно зачем это надо):

          Route::get('foo', array('uses' => 'FooController@method',
                                                  'as' => 'name'));

      - Сгенерировать URL на controller action можно так:

          // вариант 1
          $url = URL::action('App\Http\Controllers\FooController@method');

          // вариант 2
          $url = action('App\Http\Controllers\FooController@method');

      - Чтобы при генерации URL не указывать полный путь к контроллеру,
        можно сделать так:

          // Зарегистрировать путь к каталогу с контроллерами
          URL::setRootControllerNamespace('App\Http\Controllers');

          // А затем уже сгенерировать URL, лишь по имени класса-контроллера
          $url = action('FooController@method');

      - Получить имя запущенного controller action можно так:

          $action = Route::currentRouteAction();

  > Контроллеры и пространства имён

    app/Providers/RouteServiceProvider.php
    --------------------------------------

      > $namespace
        - В этом св-ве указывается пр.имён для корневого каталога с контроллерами.
        - По умолчанию, указано: 'App\Http\Controllers'

      > public function map
        - Эта функция запускает файл routes.php.
        - В ней указан, соответственн, путь к этому файлу.
        - И запускается он сразу в пр.имён, указанном в $namespace.

    Помещение контроллеров во вложенные в app/Http/Controllers каталоги
    -------------------------------------------------------------------
      - Допустим, есть каталог: app/Http/Controllers/Admin
      - Что надо сделать, чтобы в routes.php можно было обращаться 
        к контроллерам, которые лежат в этом каталоге?
      - Нужно при их определении, указывать следующее пространство
        имён: namespace App\Http\Controllers\Admin

  > Контроллеры и middleware

    Назначение middleware контроллеру в routes.php
    ----------------------------------------------

      Route::get('profile', [
          'middleware' => 'auth',
          'uses' => 'UserController@showProfile'
      ]);

    Назначение middleware контроллеру в конструкторе контроллера
    ------------------------------------------------------------

      app/Http/Controllers/UserController
      -----------------------------------
        class UserController extends Controller {

            /**
             * Instantiate a new UserController instance.
             */
            public function __construct()
            {
                $this->middleware('auth');

                $this->middleware('log', ['only' => ['fooAction', 'barAction']]);

                $this->middleware('subscribed', ['except' => ['fooAction', 'barAction']]);
            }

        }

  > Неявные (RESTful) контроллеры (::controller)

    > Введение
      - REST API - это такая архитектура, которая позволяет посылая запросы
        на один и тот же URI, но разными HTTP-методами и с разным набором
        параметров, получать разные ответы.
      - Т.Е., в этом пункте: RESTful контроллеры вокруг HTTP-методов.
      - Laravel позволяет организовать такую архитектуру. Для этого понадобятся
        1 роут и 1 класс-контроллер.
      - Этот класс-контроллер и называют "RESTful controller".
      - Внимение! После создания нового класса-контроллера, надо выполнить
        команду композера dump-autoload, чтобы laravel увидел контроллер.

    > Практика

      # Вот как определяется роут, который будет работать с REST-контроллером:
        - 1-й аргумент: базовый URI для контроллера
        - 2-й аргумент: имя класса REST-контроллера

          Route::controller('users', 'UserController');

      # Вот как определяется класс REST-контроллера:
        - Внутри него для разруливания запросов определяются методы.
        - Имя метода определяется по шаблону: [HTTP-метод] + [имя метода].
        - [HTTP-метод] должен быть написан полностью маленькими буквами.
        - [имя метода] должно начинаться с большой буквы.
        - Если [имя метода] содержит несколько слов, то осуществить запрос
          по такому URI можно, указывая в запросе эти слова через '-'.
        - Все методы, у которых [имя метода] == 'Index', срабатывают при
          запросе к базовому URI контроллера. В примере выше это: 'users'.
        - В примерах ниже допустим, что:
          - URL нашего сайта "www.site.ru"
          - Роут определён как в примере выше

          class UserController extends Controller  {

            // Этот метод сработает вот в каком случае:
            // - Запрос должен осуществляться HTTP-методом GET
            // - Запрос должен быть по адресу: "www.site.ru/users"
              public function getIndex()
              {
                  //
              }

            // Этот метод сработает вот в каком случае:
            // - Запрос должен осуществляться HTTP-методом POST
            // - Запрос должен быть по адресу: "www.site.ru/users/profile"
              public function postProfile()
              {
                  //
              }

            // Этот метод сработает вот в каком случае:
            // - Запрос может осуществляться любым HTTP-методом
            // -Запрос должен быть по адресу: "www.site.ru/login"
              public function anyLogin()
              {
                  //
              }

            // Этот метод сработает вот в каком случае:
            // - Запрос должен осуществляться HTTP-методом GET
            // - Запрос должен быть по адресу: "www.site.ru/users/admin-profile"
              public function getAdminProfile()
              {
                  //
              }

          }

  > Ресурсные контроллеры (::resource)

    > Введение
      - По сути это тоже самое, что REST-контроллер.
      - Но архитектура работы с ресурсными контроллерами несколько отичается.
      - Их предназначение - выстраивание REST-архитектуры вокруг ресурсов.
      - Например, управление работой с какими-нибудь фотографиями или другими ресурсами.

    > Фиксированный набор методов ресурсного контроллера

      > Введение
        - В отличие от REST-контроллера, у класса ресурсного контроллера
          изначально есть ограниченный набор методов.


      > Изначальный набор методов ресурсного контроллера:

      HTTP-Метод  Путь                        Имя метода    Имя роута
    ------------------------------------------------------------------------
      GET         /resource                   index         resource.index
      GET         /resource/create            create        resource.create
      POST        /resource                   store         resource.store
      GET         /resource/{resource}        show          resource.show
      GET         /resource/{resource}/edit   edit          resource.edit
      PUT/PATCH   /resource/{resource}        update        resource.update
      DELETE      /resource/{resource}        destroy       resource.destroy


    > Работа с ресурсными контроллерами

      # Так можно с помощью 1-й artisan-команды в консоли быстро создать
        готовый шаблон ресурсного контроллера в папке 'app/controllers'.

          // Создать ресурсный контроллер
          // - С именем PhotoController
          // - С полным набором шаблонов-методов

            php artisan controller:make PhotoController

          // Создать ресурсный контроллер с опцией --only
          // - Эта опция позволяет указать в команде через запятую имена методов.
          // - Шаблоны в классе-ресурсном-контроллере будут созданы только для них
          // - А для не указанных методов шаблоны будут отсутствовать

            php artisan controller:make PhotoController --only=index,show

          // Создать ресурсный контроллер с опцией --except
          // - Эта опция позволяет указать в команде через запятую имена методов.
          // - Шаблоны в классе-ресурсном-контроллере НЕ будут созданы только для них
          // - А для не указанных методов шаблоны будут присутствовать

            php artisan controller:make PhotoController --except=index

      # Вот как можно зарегистрировать ресурсный контроллер для роута:

            Route::resource('photo', 'PhotoController');

      # Чтобы расширить ресурсный контроллер дополнительными методами,
        сверх изначального набора, нужно:
        - Создать этот метод в классе ресурсного контроллера.
        - До регистрации ресурсного контроллера создать роут на этот
          дополнительный метод.

            Route::get('photo/my', 'PhotoController@mymethod');
            Route::resource('photo', 'PhotoController');

      # По умолчанию роут, для которого зарегистрирован ресурсный контроллер,
        пропускает запрос для каждого из зарегистрированных в классе методов
        из стандартного набора.

          //Однако при определении роута с помощью параметра 'only' можно указать
          //список имён методов из стандартного набора, и только для них
          //роут будет осуществлять марштуризацию:
            Route::resource('photo', 'PhotoController',
                            array('only' => array('index', 'show')));

          //А с помощью параметра 'except' можно указать список имён методов
          //из стандартного набора, и роут будет осуществлять марштуризацию
          //для всех, кроме этих:
            Route::resource('photo', 'PhotoController',
                            array('except' => array('create', 'store', 'update', 'delete')));

  > Контроллеры и dependency injection                             
    
    DI в конструктор контроллера
    ----------------------------
      - При работе с контроллерами используется Laravel service container.
      - Это мощный инструмент для управления зависимостями классов.
      - В результате, можно добавлять зависимости прямо в конструктор контроллера.
      - Например:

        app/Http/Controllers/UserController.php
        ---------------------------------------
          <?php namespace App\Http\Controllers;

          use Illuminate\Routing\Controller;
          use App\Repositories\UserRepository;

          class UserController extends Controller {

              /**
               * The user repository instance.
               */
              protected $users;

              /**
               * Create a new controller instance.
               *
               * @param  UserRepository  $users
               * @return void
               */
              public function __construct(UserRepository $users)
              {
                  $this->users = $users;
              }

          }    

    DI в метод контроллера
    ----------------------
      - Можно добавлять зависимости и прямо в методы контроллера.
      - Причем это работает и для Implicit Controllers (::controller)!
      - Например:


        app/Http/Controllers/UserController.php
        ---------------------------------------
          <?php namespace App\Http\Controllers;

          use Illuminate\Http\Request;
          use Illuminate\Routing\Controller;

          class UserController extends Controller {

              /**
               * Store a new user.
               *
               * @param  Request  $request
               * @return Response
               */
              public function store(Request $request)
              {
                  $name = $request->input('name');

                  //
              }

          }      

      - Кроме того, метод контроллера может ожидать input из параметров роута.
      - Тогда можно просто перечислить их после собственных зависимостей.
      - Например:

        app/Http/Controllers/UserController.php
        ---------------------------------------
          <?php namespace App\Http\Controllers;

          use Illuminate\Http\Request;
          use Illuminate\Routing\Controller;

          class UserController extends Controller {

              /**
               * Store a new user.
               *
               * @param  Request  $request
               * @return Response
               */
              public function store(Request $request, $id)
              {
                  //
              }

          }             

  > Кэширование роутов на контроллеры
    - Если приложение использует в основном роуты на контроллеры.
    - То использование их кэширования существенно ускорит приложение.
    - Сгенирировать кэш роутов можно командой: 

        php artisan route:cache

    - Теперь файл app/Http/routes.php больше не используется.
    - А вместо него используется сгенерированный кэш.
    - Поэтому, при любых изменениях в routes.php, надо снова выполнить команду!
    - Так что, эту возможность лучше использовать уже на работающем проекте,
      а не во время разработки, чтобы выиграть немного скорости.
    - Чтобы всё отменить, надо выполнить команду:

        php artisan route:clear


А7.  HTTP-запросы, cookie, files, инфа о запросе

  --------------------------------------
  Подоглавление:

    - Как получить доступ к Request в контроллере?
    - Извлечение входных данных
    - Сохранение входных данных между запросами
    - Работа с файлами на входе
    - Работа с куками
    - Получение информации о запросе

  --------------------------------------

  > Как получить доступ к Request в контроллере?

      Способ №1: через фасад Request
      ------------------------------
        - Если класс-контроллер находится в пространстве имён.
        - То нужно импортировать в него фасад Request, чтобы получить доступ
          к классу \Illuminate\Support\Facades\Request.
        - Короче говоря, вот варианты получения доступа к классу Request:

          1) Обращаться к нему напрямую:

              $name = \Illuminate\Support\Facades\Request::input('name');

          2) Обращаться к фасаду класса напрямую:
            - А фасады у нас живут в глобальном пространстве имён.
            - Поэтому, можно обращаться от "корня" пр.имён:

              $name = \Request::input('name');

          3) Импортировать класс в текущее пространство имён:

              use \Illuminate\Support\Facades\Request;
              $name = Request::input('name');

          4) Импортировать фасад в текущее пр.имён:

              use Request;
              $name = Request::input('name');


      Способ №2: через DI в метод контроллера
      ---------------------------------------
        - Допустим, у нас есть RESTful контроллер (вокруг HTTP-методов).
        - И нам нужен доступ к Request в его методе getIndex.
        - Тогда, при определении метода, делаем в него DI:

            public function getIndex(Request $request) {

              // И вот, у нас есть доступ:
              $name = Request::input('name');

            }

  > Извлечение входных данных

    > Введение
      - Получить входные данные из экземпляра Illuminate\Http\Request 
        можно с помощью нескольких простых методов.
      - Беспокоиться по поводу метода запроса нестоит. Каков бы не был метод
        запроса, данные нужно получать одними и теми же способами.
      - В случае поступления строки в формате JSON, работать с ней также
        можно используя ключи для получения значений, как и с другими форматами.

    > Примеры:
      - Извлечь входное значение с ключем 'name':

          $name = Request::input('name');

      - Извлечь входное значение с ключем 'name'. А если их нет, то
        выражение вернёт значение по умолчанию - в данном случае 'Sally':

          $name = Request::input('name', 'Sally');

      - Определить, передано ли на вход значение с ключем 'name':

          if (Request::has('name'))
          {
              //
          }

      - Извлечь всю входную строку из тела запроса:

          $input = Request::all();

      - Извлечь все входные данные, кроме указанных:

          $input = Request::except('credit_card');

      - Извлечь только указанные входные данные:

          $input = Request::only('username', 'password');

      - При получении данных от формы, можно использовать нотацию
        через точку для доступа к переданны массивам:

          $input = Request::get('products.0.name');

  > Сохранение входных данных между запросами

    > Введение:
      - Часто требуется где-нибудь сохранить поступившие данные между запросами.
      - В Laravel для этого реализован удобный функционал.

    > Добавление входных данных в сессию

      - Добавить всю входную информацию в сессию:

          Request::flash();

      - Добавить только указанные данные в сессию:

          Request::flashOnly('username', 'email');

      - Добавить в сессию все данные, кроме указанных:

          Request::flashExcept('password');

    > Извлечение старых входных данных из сессии

      - Извлечь старые входные данные из сессии:

          Request::old('username');

  > Работа с загруженными входными файлами

    > Введение:
      - На вход могут поступать и файлы.
      - Для работы с ними у Laravel тоже есть функционал.
      - Метод Request::file возвращает объект-экземпляр класса
        "Symfony\Component\HttpFoundation\File\UploadedFile", который
        является наследником класса SplFileInfo, что и обеспечивает наличие
        набора методов для работы с файлом.

    > Функционал:
      - Извлечение переданного приложению файла:

          $file = Request::file('photo');

      - Определить, был ли загружен указанный файл:

          if (Request::hasFile('photo'))
          {
              //
          }

      - Перемещение загруженного файла по адресу $destinationPath,
        в который включено имя файла:

          Input::Request('photo')->move($destinationPath);

      - Перемещение загруженного файла по адресу $destinationPath,
        но имя файла-результата указано отдельно в $fileName:

          Input::Request('photo')->move($destinationPath, $fileName);

      - Получить абсолютный путь к загруженному файлу:

          $path = Request::file('photo')->getRealPath();

      - Получить исходное имя загруженного файла:

          $name = Request::file('photo')->getClientOriginalName();

      - Получить расширения загруженного файла:

          $extension = Request::file('photo')->getClientOriginalExtension();

      - Получить размер загруженного файла:

          $size = Request::file('photo')->getSize();

      - Получить MIME-тип загруженного файла:

          $mime = Request::file('photo')->getMimeType();

  > Работа с куками

    > Введение:
      - Каждая кука, созданная Laravel, зашифрована.
      - Также, каждая кука подписана аутентификационным кодом.
      - Если клиент изменит куку вручную, приложение сочтёт такие куки
        не валидными.

    > Функционал:
      - Извлечение значения куки с ключём 'name':

          $value = Request::cookie('name');

      - Добавить новую куку к объекту Response:

          $minutes = 120;
          $cookie = cookie('name', 'value', $minutes);

          $response = new Illuminate\Http\Response('Hello World');
          $response->withCookie($cookie);

      - Добавить "вечную" (5 лет) куку к объекту Response:

          $cookie = cookie()->forever('name', 'value');

          $response = new Illuminate\Http\Response('Hello World');
          $response->withCookie($cookie);      

      - Добавить новую куку к следующему запросу:

          $minutes = 120;
          Cookie::queue('name', 'value', $minutes);

      - Создать куку, которая действует вечно, и добавить к след.запросу:

          Cookie::queue( Cookie::forever('name', 'value') );

      - Удалить куку по ключу:

          Cookie::queue( Cookie::forget('key') );

  > Получение информации о запросе

    > Введение:
      - Класс Request наследует класс "Symfony\Component\HttpFoundation\Request".
      - И поэтому содержит много методов для извлечения информации о запросе.

    > Примеры:
      - Получить URI запроса:

          $uri = Request::path();

      - Узнать метод запроса:

          $method = Request::method();

          if (Request::isMethod('post'))
          {
              //
          }

      - Проверить, бьётся ли путь запроса с RegExp:

          if (Request::is('admin/*'))
          {
              //
          }

      - Получить URL запроса:

          $url = Request::url();

      - Извлечь URI сегмент

          $segment = Request::segment(1);

      - Извлечь указанный заговок запроса:

          $value = Request::header('Content-Type');

      - Извлечь указанное значение из $_SERVER:

          $value = Request::server('PATH_INFO');

      - Выяснить, проходит ли это соединение через HTTPS:

          if (Request::secure())
          {
              //
          }

      - Выяснить, AJAX это запрос, или не AJAX:

          if (Request::ajax())
          {
              //
          }

      - Выяснить, является ли Content-Type запроса JSON-ом:

          if (Request::isJson())
          {
              //
          }

      - Выяснить, требует ли запрос в ответ JSON-строку:

          if (Request::wantsJson())
          {
              //
          }

      - Выяснить, в каком формате запрос требует ответ. Информация основана
        на на HTTP-заголовке Accept:

          if (Request::format() == 'json')
          {
              //
          }


А8.  HTTP-ответы, редирект, макросы для ответов

  --------------------------------------
  Подоглавление:

    - Основы формирования и отправки ответа на запрос
    - Формирование ответа в форматах: JSON, JSONP, file download response
    - Функции-макросы (автоматизация генерации Response-экземпляра)
    - Редиректы

  --------------------------------------

  > Основы формирования и отправки ответа на запрос

    > Введение
      - Приложение на Laravel создано, чтобы получать запросы от пользователей.
      - На каждый запрос приложения обязано дать ответ.
      - Запрос в нём представлен объектом класса Request.
        - На входе этот класс формируется из HTTP-запроса, включающего тело.
        - На выходе мы получаем экземпляр - контейнер информации о запросе.
      - Ответ в Laravel представлен объектом класса Response.
        - На входе этот класс формируется из default-значений, заданных программистом,
          а также учитывается содержание объекта Request.
        - На выходе этот класс возвращает HTTP-ответ, включая тело.
        - Класс Response наследует от "Symfony\Component\HttpFoundation\Response",
          что обеспечивает набор методов для формирования HTTP-ответов.

    > Примеры
      - Из колбэк-функции роута вернуть строку. Будет автоматически сформирован
        response-объект, а из него HTTP-ответ с указанной телом-строкой и всеми
        остальными параметрами, вычисленными автоматом:

          Route::get('/', function()
          {
              return 'Hello World';
          });

      - В колбэк-функции роута вручную сформировать response-объект, и
        вернуть его:

          Route::get('/', function()
          {
            $contents = [значение];
            $statusCode = [значение];
            $value = [значение];

            // Создать новый экземпляр response-объекта

              // Способ 1
              // - Но если класс-контроллер находится в пространстве имён.
              // - То надо сначала импортировать фасад Response.
              $response = Response::make($contents, $statusCode);

              // Способ 2
              // - Обращаемся прямо к фасаду Response, который в глоб.пр.имён
              $response = \Response::make($contents, $statusCode);

              // Способ 3
              // - Обращаемся прямо к фасаду Response, который в глоб.пр.имён
              $response = new \Response($contents, $statusCode);

              // Способ 4
              // - Используя функцию-хелпер response
              $response = response($contents, $statusCode);

            // Добавить в него HTTP-заголовок
            $response->header('Content-Type', $value);

            return $response;
          });

      - Если на выход надо послать view, то вместо Response::make надо
        использовать метод Response::view. Он также возвращает экземпляр
        класса Response:

          Route::get('/', function()
          {
            $value = [значение];

            // Создать новый экземпляр response-объекта в формате view
            $response = Response::view('hello');

            // Добавить в него HTTP-заголовок
            $response->header('Content-Type', $value);

            return $response;
          });

      - А вот так можно послать куки вместе с ответом:

          Route::get('/', function()
          {
            $content = [значение];
            $cookie = [значение];

            // Создать новый экземпляр response-объекта в формате view
            $response = new Response($content);

            // Добавить в него куки
            $response->withCookie($cookie);

            return $response;
          });


  > Формирование ответа в форматах: JSON, JSONP, file download response

    > Создание ответа в формате JSON
      $response = Response::json(array('name' => 'Steve', 'state' => 'CA'));

    > Создание ответа в формате JSONP
      $response = Response::json(array('name' => 'Steve', 'state' => 'CA'))->setCallback(Input::get('callback'));

    > Создание ответа в формате 'file download response':
      - В Laravel скачкой файлов управляет synfony'вский модуль 'HttpFoundation'.
      - Он требует, чтобы имя файла было в кодировке ASCII.

        // Вариант 1
        $response = Response::download($pathToFile);

        // Вариант 2
        return Response::download($pathToFile, $name, $headers);

  > Функции-макросы (автоматизация генерации Response-экземпляра)

    > Введение
      - Позволяют создать макросы по формированию ответов.
      - Такой макрос можно можно использовать в роутах и контроллерах.
      - Цель: каждый раз не писать один и тот же код по созданию
        response-объекта, а автоматизировать этот процесс в функции.
      - Так что макрос - это функция, которая возвращает объект класса
        Response, а её имя становится стат.методом класса Response.

    > Примеры:
      - Создать макрос:

          Response::macro('caps', function($value)
          {
              return Response::make(strtoupper($value));
          });

      - Использовать макрос:

          $response = Response::caps('значение');

  > Редиректы

    > Введение
      - Из колбэк-функции роута можно произвести редирект на другую функцию.
      - Для этого надо вернуть объект класса  Illuminate\Http\RedirectResponse.
      - Целевая функция редиректа также обязана либо вернуть ответ, либо
        также осуществить редирект.
      - Есть 3 вида редиректа
          - На URI
          - На именованый роут
          - На метод контроллера

    > Примеры
      - Редирект на URI:
          return Redirect::to('user/login');
          return redirect('user/login');    // ... или так

      - Перед редиректом добавить в объект сессионные данные:

          $r = Redirect::to('user/login');
          $r->with('message', 'Login Failed');
          return $r;

      - Редирект на именованый роут:
          return Redirect::route('login');

      - Редирект на именованый роут с параметрами:
          return Redirect::route('profile', array(1));

      - Редирект на именованый роут с именоваными параметрами:
          return Redirect::route('profile', array('user' => 1));

      - Редирект на метод контроллера:
          return Redirect::action('HomeController@index');

      - Редирект на метод контроллера с параметрами:
          return Redirect::action('UserController@profile', array(1));

      - Редирект на метод контроллера с именованными параметрами:
          return Redirect::action('UserController@profile', array('user' => 1));

      - Редирект на предыдущий URL
          return Redirect::back();   
          return Redirect::back()->withInput();   


А9.  Views (представления)

  --------------------------------------
  Подоглавление:

    - Введение
    - Передача данных во view
    - Views во вложенных каталогах
    - Общие данные для всех views
    - Вложенные друг в друга views
    - View Composers
    - View Creators

  --------------------------------------

  > Введение
    - Представления, это HTML-документы приложения.
    - Так реализуется MVC:

        Представления отдельно, 
        серверная логика в контроллерах отдельно,
        логика по работе с моделями отдельно в классах-моделях

    - Представления представляют из себя PHP-файлы.
    - Представления по умолчанию хранятся в resources/views.
    - CSS, JS, прочие ресурсы, по умолчанию в resources/assets.

  > Передача данных во view

    2 варианта добавить данные в объект View
    ----------------------------------------

      1) При создании

        $view = View::make('greeting', array('name' => 'Taylor'));

      2) С помощью метода with

        $view = View::make('greeting');
        $view->with('name', 'Taylor');

    Пример возврата представления с данными из роута
    ------------------------------------------------

        Route::get('/', function()
        {
            return View::make('greeting', array('name' => 'Taylor'));
            // return view('greeting', array('name' => 'Taylor'));    // ... или так
        });

    Пример приёма данных в представлении (не blade)
    -----------------------------------------------

        <!-- View stored in resources/views/greeting.php -->
        <html>
            <body>
                <p>Hello, my name is <?php echo $name; ?></p>
                <p>I am <?php echo $age; ?> years old.</p>
            </body>
        </html>

    Пример приёма данных в представлении (blade)
    --------------------------------------------

        <!-- View stored in resources/views/greeting.blade.php -->
        <html>
            <body>
                <p>Hello, my name is {{ $name; }}</p>
                <p>I am {{ $age; }} years old.</p>
            </body>
        </html>

  > Views во вложенных каталогах
    - Каталог для представлений по умолчанию: resources/views
    - Но можно размещать представления и во вложенных в него каталогах.
    - Скажем, в resources/views/myViews
    - Вот как к нему тогда можно обратиться:

        Route::get('/', function()
        {
            return View::make('myViews.greeting', array('name' => 'Taylor'));
            // return view('myViews.greeting', array('name' => 'Taylor'));    // ... или так
        });

  > Общие данные для всех views

    Какие есть варианты расшарить данные для N представлений
    --------------------------------------------------------

      1) Метод share класса View
        - Этот код лучше всего разместить в каком-нибудь сервис-провайдере.
        - Например, в методе boot() сервис-провайдера app/Providers/AppServiceProvider.php

        View::share('name', 'Steve');
        // view()->share('name', 'Steve')  // ... или так

      2) В контракте Illuminate\Contracts\View\Factory

      3) Используя view composer.

  > Вложенные друг в друга views
    - Иногда может потребоваться передать одно представление в другое.
      Допустим, подпредставление хранится в "app/views/child/view.php".
      Тогда передать его в представление 'greeting' можно так:

        $view = View::make('greeting')->nest('child', 'child.view');
        $view = View::make('greeting')->nest('child', 'child.view', $data);

    - Переданное подпредставление будет доступно в представлении по
      указанному имени. В нашем примере, это 'child':

        <html>
            <body>
                <h1>Hello!</h1>
                <?php echo $child; ?>
            </body>
        </html>

  > View Composers

    > Введение
      - Событие composing возбуждается непосредственно перед рендерингом представления.
      - Рендеринг - получение DOM-структуры представления из его модели.
      - С помощью метода View::composer объекту-представлению можно назначить
        функцию-обработчик (анонимную или метод класса) события composing.
      - В Laravel такие обработчики называют "композер представления" (View Composer).
      - Их используют, если в представление каждый раз перед его рендерингом
        надо передавать фиксированный набор данных.

    > Архитектура использования
      
      Где хранить код функции-обработчика
      -----------------------------------

        1) В анонимной функции
          - Которая назначается при определении композера.
          - Например:

              View::composer('myview', function($view) {
                // ... код ...
              });

          - Так назначить композер нескольким представлениям:

              View::composer(['myview1', 'myview2'], function($view)
              {
                  //
              }); 

          - Так можно назначить композер ВСЕМ представлениям:

              View::composer('*', function($view)
              {
                  //
              });    

          - А так можно определить несколько композеров за раз:

              View::composers([
                  'App\Http\ViewComposers\AdminComposer' => ['admin.index', 'admin.profile'],
                  'App\Http\ViewComposers\UserComposer' => 'user',
                  'App\Http\ViewComposers\ProductComposer' => 'product'
              ]);          
              


        2) В отдельном файле-классе-композере
          - Сначала под такие файлы лучше всего создать каталог.
          - Скажем, app/Http/ViewComposers
          - Код надо помещать в метод compose класса.
          - Пример:

              app/Http/ViewComposers/ProfileComposer.php
              ------------------------------------------
              <?php namespace App\Http\ViewComposers;

                use View; // ... или: use Illuminate\Contracts\View\View;


                class ProfileComposer {

                  public function compose(View $view) {

                    // Добавить в представление переменную $count со
                    // значением User::count()
                      $view->with('count', User::count());

                  }

                }     

              ?>     

      Где подключать композеры к проекту
      ----------------------------------
        - В каком-нибудь сервис-провайдере.
        - Например, в методе boot() сервис-провайдера app/Providers/AppServiceProvider.php

  > View Creators
    - Это почти тоже самое, что View Composers.
    - Отличие в том, что 'View Creator' срабатывает в начале создания нового
      экземпляра представления. А 'View Composer' срабатывает в начале создания
      DOM-представления из объекта-экземпляра представления. Последнее происходит
      при возвращении объекта-экземпляра представления командой return из
      функции-обработчика, которую запустил роут.
    - Вот переписка на стаке, которая также поясняет вышеописанные отличия:
        http://stackoverflow.com/questions/19265237/difference-between-view-composer-and-creator-in-laravel-4


А10.  Шаблонизатор Blade

  --------------------------------------
  Подоглавление:

    # Введение
    
      - Что такое шаблонизатор Blade
      - Зачем нужен шаблонизатор Blade
      - Принцип работы шаблонизатора Blade наглядно
      - Разница между section/show и yield

    # Определение и использование шаблона

      - Определение представления-шаблона
      - Определение представления, использующего шаблон
      - Возвращение blade-представления клиенту при роутинге

    # Вывод данных в представлении с помощью Blade

      - {{ $foo }}                | вывод значения $foo в blade-представлении
      - @{{ $foo }}               | blade удалит @, но оставит остальное как есть
      - {{ $name or 'Default' }}  | если $name == false, выведет 'Default'
      - {!! $name !!}             | не пропускает $name через htmlentities 

    # Управляющие структуры

      - if - elseif - else - endif
      - unless - endunless
      
      - for - endfor
      - foreach - endforeach
      - forelse - empty - endforelse
      - while - endwhile

    # Прочие возможности

      - @include
      - {{-- Коммент --}}
      - @inject

    # Расширение blade новыми директивами

      - Про возможность расширения
      - Пример расширение blade директивой @datetime($var)


  --------------------------------------

  > Введение

    Что такое шаблонизатор Blade
    ----------------------------
      - Это шаблонизатор, поставляемый вместе с Laravel.
      - Blade позволяет использовать PHP прямо в представлении.
      - Все blade-представления компилируются в PHP, и кэшируются.
      - Так, что шаблонизация не добавляет никаких накладных расходов.
      - Представления blade легко узнать по расширению файла: [имя].blade.php
      - По умолчанию, представления хранят в resources/views. Но это не обязательно.

    Зачем нужен шаблонизатор Blade
    ------------------------------
      - Часто надо на сайте требуется сделать много почти одинаковых документов.
      - В этих документах есть определённая часть разметки, совпдающая на 100%.
      - Различаются эти страницы контентом, либо какой-нибудь доп.разметкой внутри.
      - Так зачем в каждой странице каждый раз снова и снова писать одно и тоже?
      - Получается неэффективно, плюс загромождает код документов.
      - Поэтому придумали решение - использовать шаблоны разметки.
      - Ту часть, которая на 100% совпадает, выносят в отдельный файл-шаблон.
      - И используют этот шаблон уже во всех остальных требуемых документах.
      - Технология, реализующая это, называется шаблонизатором.
      - В Laravel есть собственный встроенный шаблонизатор: 'Blade'.

    Принцип работы шаблонизатора Blade наглядно
    -------------------------------------------
      - Бывает, что у группы док-в одинаковых эл-тов на X%.
      - Представим, что есть N документов, у которых X% одинаковых эл-тов.
      - Мы можем каждый из них разработать полностью отдельно.
      - Такое решение имеет следующие минусы:

          - Выполнено на X% больше бесполезной работы.
          - Если надо что-то изменить в одинак.части, то менятьвсе N док-ов.

      - Рассмотрим это на примере.

        - Допустим, есть N вот таких вот документов.
        - У них всё одинаковое, кроме содержимого p с id=='w'.

        Документ 1                   Документ 2                       Документ N
        --------------------------   --------------------------  ...  --------------------------

          <http>                       <http>                           <http>
            <head>                       <head>                           <head>
            </head>                      </head>                          </head>
            <body>                       <body>                           <body>

              <p>Одинаковая часть</p>      <p>Одинаковая часть</p>          <p>Одинаковая часть</p>

              <p id='w'>Разная часть:      <p id='w'>Разная часть:          <p id='w'>Разная часть:
               Документ №1</p>              Документ №2</p>                  Документ №[N]</p>

            </body>                      </body>                          </body>
          </http>                      </http>                          </http>

        - Допустим, решили не использовать шаблонизацию, и каждый док-т делать отдельно.
        - Тогда придётся лишние N-1 раз писать их "одинаковую" часть:

                                  <http>
                                    <head>
                                    </head>
                                    <body>

                                      <p>Одинаковая часть</p>

                                    </body>
                                  </http>

        - А если понадоб-ся измен. везде один.часть, придётся изменять N файлов.
        - Избежать описанных выше минусов можно, применяя шаблонизацию.
        - Laravel позволяет организовать шаблонизацию с помощью blade.
        - Создадим шаблон 'layouts/l1_layout.blade.php'.
        - Какой использовать вариант - без разницы, суть одна.


            Вариант №1.                     Вариант №2.
            Использ-е: section / show.      Использ-е: yield

            layouts/l1_layout.blade.php     layouts/l1_layout.blade.php
            ---------------------------     ---------------------------

              <http>                          <http>
                <head>                          <head>
                </head>                         </head>
                <body>                          <body>

                  <p>Одинаковая часть</p>         <p>Одинаковая часть</p>

                  <p id='w'>                      <p id='w'>

                    @section('content')
                                                    @yield('content')
                    @show

                  </p>                            </p>

                </body>                         </body>
              </http>                         </http>

        - Теперь нам надо создать наши N документов на основе этого шаблона.
        - Вот как они теперь будут выглядеть:

        Документ 1                               Документ 2                              Документ N
        --------------------------               --------------------------      ...     --------------------------
        @extends('lk_grumart._layouts.main')     @extends('lk_grumart._layouts.main')    @extends('lk_grumart._layouts.main')

          @section('content')                       @section('content')                     @section('content')
            <p id='w'>                                <p id='w'>                              <p id='w'>
              Разная часть:                             Разная часть:                           Разная часть:
              Документ №1                              Документ №2                              Документ №[N]
            </p>                                      </p>                                    </p>
          @stop                                     @stop                                   @stop

        - Как видно, количество лишнего кода (а значит и работы) серьёзно сократилось.
        - Внести изменение в пост. часть можно теперь легко в шаблоне, 1 раз для N файлов.
        - Важный момент здесь - @extends должно быть в самом-самом начале файла.
        - Даже если туда затесается какой-нибудь BOM или пробел, работать не будет.
        - *Примеч.: роут должен вести не на шаблон, а как раз на 1 из этих N файлов.

    Разница между section/show и yield
    ----------------------------------
      - Только в том, что внутри section/show в шаблоне можно задать доп. контент.
      - В то время, как с помощью yield доп. контента не задашь.
      - Например:

            Доп. контент с section/show               Без доп. контента с yield
           -----------------------------              --------------------------

               <http>                                    <http>
                 <head>                                    <head>
                 </head>                                   </head>
                 <body>                                    <body>

                   @section('diff')                          @yield('diff');
                     <span>Доп. контент</span>
                     [сюда вставятся данные из             </body>
                      section/stop документа-            </http>
                      наследника шаблона]
                   @show

                 </body>
               </http>

      - Вот и вся разница.


  > Определение и использование шаблона

    Определение представления-шаблона
    ---------------------------------
      - Вот, как создаются blade-шаблоны.
      - Создадим файл resources/views/layouts/master.blade.php

          <html>
              <head>
                  <title>App Name - @yield('title')</title>
              </head>
              <body>
                  @section('sidebar')
                      This is the master sidebar.
                  @show

                  <div class="container">
                      @yield('content')
                  </div>
              </body>
          </html>      

      - Теперь этот шаблон можно использовать в blade-представлениях.

    Определение представления, использующего шаблон
    -----------------------------------------------
      - Определим blade-представление, наследующее шаблон выше.
      - Создадим файл resources/views/layouts/child.blade.php
      - Какой шаблон наследовать указано в @extends.
      - @extends должно идти первой строкой в файле представления.
      - Это представление заполняет 3 секции шаблона:
          1) title
          2) sidebar
          3) content
      - Вот содержимое представления:

          @extends('layouts.master')

          @section('title', 'Page Title')

          @section('sidebar')
              @parent

              <p>This is appended to the master sidebar.</p>
          @endsection

          @section('content')
              <p>This is my body content.</p>
          @endsection      

    Возвращение blade-представления клиенту при роутинге
    ----------------------------------------------------
      - Итак, мы определили blade-шаблон.
      - Мы определили blade-представление, использующее шаблон.
      - Теперь, мы хотим вернуть всё это добро клиенту.
      - При роутинге, в ответ на запрос. Как это сделать?
      - Ответ: надо вернуть лишь blade-представление.
      - Оно автоматически задействует blade-шаблон, указанный в @extends.
      - Причём, при возвращении .blade.php указывать не надо.
      - Пример:

          Route::get('blade', function () {
              return view('child');
          });          


  > Вывод данных в представлении с помощью Blade

    {{ $foo }}
    ----------
      - Вывод значения $foo в blade-представлении.
      - Перед выводом пропускает через htmlentities.
      - Например:

          Hello, {{ $name }}.   // Hello, Boris.

    @{{ $foo }}
    -----------
      - Blade удалит @, но оставит остальное как есть.
      - Некоторые js-фреймворки тоже используют конструкцию {{ }}
      - Если выражение относится к ним, то перед ним ставим @.
      - Blade удалит @, но само выражение оставит как есть.
      - И тогда, оно попадёт в клиент, и там js-фреймворк его обработает.
      - Пример:

          Hello, @{{ $name }}.   // Hello, Boris.

    {{ $name or 'Default' }}
    ------------------------
      - Eсли $name == false, выведет 'Default'.
      - Это, по сути, тернарный оператор. Можн написать так:

          {{ isset($name) ? $name : 'Default' }}

      - А можно использовать blade-вариант:

          {{ $name or 'Default' }}

      - Результат будет один.

    {!! $name !!}
    -------------
      - Не пропускает $name через htmlentities, в отличие от {{ $name }}.
      - С точки зрения безопасности, опасная штука.
      - Нельзя выводить $name, если точно не знаешь, что в нём.
      - Пример:

          Hello, {!! $name !!}.


  > Управляющие структуры

    if - elseif - else - endif
    --------------------------

      @if (count($records) === 1)
          I have one record!
      @elseif (count($records) > 1)
          I have multiple records!
      @else
          I don't have any records!
      @endif


    unless - endunless
    ------------------

      @unless (Auth::check())
          You are not signed in.
      @endunless


    for - endfor
    ------------

      @for ($i = 0; $i < 10; $i++)
          The current value is {{ $i }}
      @endfor


    foreach - endforeach
    --------------------

      @foreach ($users as $user)
          <p>This is user {{ $user->id }}</p>
      @endforeach


    forelse - empty - endforelse
    ----------------------------

      @forelse ($users as $user)
          <li>{{ $user->name }}</li>
      @empty


    while - endwhile
    ----------------

      @while (true)
          <p>I'm looping forever.</p>
      @endwhile


  > Прочие возможности

    @include
    --------
      - Позволяет вставить одно представление в другое.
      - А что же с переменными, доступными родительскому представлению?
      - Они все станут доступны и дочернему (которое инклюдится).
      - Пример:

          <div>
              @include('shared.errors')

              <form>
                  <!-- Form Contents -->
              </form>
          </div>   

      - Кроме того, можно даже передать дочернему представлению доп.данные.
      - Вот так:

          @include('view.name', ['some' => 'data'])
             
    {{-- Коммент --}}
    -----------------
      - Так выглядят blade-комментарии.
      - Всё, что в них содержится, не попадает в конечную HTML-разметку.
      - Пример:

        {{-- Этот комментарий не попадёт в конечную HTML-разметку --}}

    @inject
    -------
      - Позволяет извлечь сервис из сервис-контейнера.
      - Первым аргументом принимает имя переменной, в котору. будет помещена служба.
      - Вторым аргументом принимает имя класса/интерфейса службы, которую нужно извлечь.
      - Пример:

          @inject('metrics', 'App\Services\MetricsService')

          <div>
              Monthly Revenue: {{ $metrics->monthlyRevenue() }}.
          </div>      


  > Расширение blade новыми директивами

    Про возможность расширения
    --------------------------
      - Blade можно расширять своими, кастомными директивами.
      - Имеется в виду, директивы в стили @[имя директивы].
      - Это можно делать методе boot любого сервис-провайдера.
      - Нужно использовать метод Blade::directive.

    Пример расширение blade директивой @datetime($var)
    --------------------------------------------------
      - Создадим для примера директиву @datetime($var).
      - Она форматирует и возвращает переданную $var.
      - Дело происходит в методе boot() сервис-провайдера (неважно какого):

          Blade::directive('datetime', function($expression) {
              return "<?php echo with{$expression}->format('m/d/Y H:i'); ?>";
          });      

      - Как видно, была использована вспомогательная функция with.



Б1.  Жизненный цикл HTTP-запроса в Laravel 5

  --------------------------------------
  Подоглавление:

    - Введение
    - Жизненный цикл запроса в Laravel-приложении

      1. Все запросы попадают в файл "public/index.php"
      2. Ядро HTTP (app/Http/Kernel.php)

    - Особое внимание следует обратить на service providers

  --------------------------------------

  > Введение
    - Это будет общий обзор жизненного цикла процесса в Laravel 5.

  > Жизненный цикл запроса в Laravel-приложении

    > Пошаговый обзор прохождения запроса через приложение

      1. Все запросы попадают в файл "public/index.php"
        - Они направляются туда в настройках веб-сервера (apache/nginx).
        - В index.php почти нет кода, это лишь стартовая точка для фреймворка.
        - Файл index.php загружает сгенерированный композером autoloader,
          и затем извлекает экземпляр приложения Laravel из bootstrap/app.php
        - Первое действиее, которое делает сам Laravel, он создаёт экземпляр
          приложения / service container'а.

      2. Ядро HTTP (app/Http/Kernel.php)

        Общие слова
        -----------
          - Далее запрос отправляется либо в ядро HTTP, либо в ядро console.
          - В зависимости от типа запроса, который поступил в приложение.
          - Эти 2 ядра являются центральными точками, через которые проходят все запросы.
          - Пока, сосредоточимся на ядре HTTP, которое лежит в app/Http/Kernel.php

        $bootstrappers
        --------------
          - app/Http/Kernel.php реализует класс Illuminate\Foundation\Http\Kernel
          - В последнем определено св-во $bootstrappers, которое содержит массив.
          - Массив содержит адреса классов относительно каталога vendors\Laravel
          - Это адреса "вшитых" в ядро сервис-провайдеров, которые готовят приложение
            перед обработкой запроса.
          - Вот их список (laravel 5.0.16), из названий видно, что они делают:

              protected $bootstrappers = [
                'Illuminate\Foundation\Bootstrap\DetectEnvironment',
                'Illuminate\Foundation\Bootstrap\LoadConfiguration',
                'Illuminate\Foundation\Bootstrap\ConfigureLogging',
                'Illuminate\Foundation\Bootstrap\HandleExceptions',
                'Illuminate\Foundation\Bootstrap\RegisterFacades',
                'Illuminate\Foundation\Bootstrap\RegisterProviders',
                'Illuminate\Foundation\Bootstrap\BootProviders',
              ];

          - Добавлять сюда что-то вручную не требуется.

        $middleware
        -----------
          - В app/Http/Kernel.php определено свойство $middleware, которое содержит массив.
          - Массив содержит адреса классов относительно app/Http/Middleware
          - ВСЕ http-запросы к приложению последовательно проходят через все классы
            в этом массиве (сверху-вниз), и лишь потом попадают в приложение.
          - Т.Е., по большу счёту, это фильтры для ВСЕХ запросов.

        $routeMiddleware
        ----------------
          - В app/Http/Kernel.php определено свойство $routeMiddleware, которое содержит массив.
          - Массив содержит массив с данными в формате: ключ => значение
          - Значение:

            - Это адрес класса с middleware, относительно КОРНЯ приложения.
            - Например: 'App\Http\Middleware\Authenticate'

          - Ключ:

            - Это имя, по которому потом можно привязать middleware, чей адрес
              в значении, к определённому роуту.

          - Т.Е., по большому счёту, здесь определяются фильтры, которые в
            routes.php можно привязывать к конкретным роутам или группам.
          - Причём, before или after это фильтр, определяется в коде данного middleware.

        Итого
        -----
          - В ядре HTTP запрос проходит через строй классов-middleware.
          - Может пройти через все, или на каком-то из классов его "завернут" или "остановят".
          - Например, если просто "остановить" запрос, то приложение не верёнт никакого ответа клиенту.
          - А можно "завернуть", т.е. перенаправить на указанный роут.
          - Например, завернуть не аутентиф.пользователя на роут регистрации.
          - Ну а если запрос никуда не "завернули", и не "остановили" на этом этапе,
            то в конечном счёте он попадает в тот контроллер, который изначалоно и запрашивал.

  > Особое внимание следует обратить на service providers
    - Внимательные уже обратили внимание на следующую деталь.
    - Она находится в app/Http/Kernel.php, в массиве $bootstrappers.
    - А именно: 'Illuminate\Foundation\Bootstrap\RegisterProviders'.
    - Т.Е. на этапе прохождения запроса через HTTP-ядро app/Http/Kernel.php,
      происходит также регистрация сервис-провайдеров.
    - Список которых указан в конфиге config/app.php, в массиве
      providers.


Б2.  Структура приложения

  --------------------------------------
  Подоглавление:

    - Введение
    - Обзор стандартной структуры каталогов в корне приложения
    - Обзор структуруы каталогов в /app

  --------------------------------------

  > Введение
    - У Laravel есть стандартная структура каталогов и файлов.
    - Она вполне неплоха как для малых, так и для больших приложений.
    - Но в принципе, каждый может менять эту структуру как хочет.
    - Нет ограничений на то, где какой класс в приложении находится.
    - Ведь Composer автоматически загружает соответствующие классы.

  > Обзор стандартной структуры каталогов в корне приложения

    app
    ---
      - Содержит код ядра вашего приложения.

    bootstrap
    ---------
      - Содержит несколько файлов.
      - Они загружают фреймворк и настраивают автозагрузку.

    config
    ------
      - Содержит конфиги приложения.

    database
    --------
      - Содержит migrations и seeds.

    public
    ------
      - Содержит index.php приложения.
      - А также ресурсы приложения, такие как css, js и т.д.

    resources
    ---------
      - Содержит представления.
      - Содержит такие ресурсы, как LESS, SASS, CoffeScript и т.д.
      - И языковые файлы.

    storage
    -------
      - Содержит скомпилированные шаблоны blade.
      - Файлы сессий, кэша, и другие генерируемые фреймворком файлы.

    tests
    -----
      - Содержит автоматические тесты.

    vendor
    ------
      - Содержит зависимости, подгруженные композером.

  > Обзор структуруы каталогов в /app
    
    > Вводные
      - "Мясо" вашего приложения находится в каталоге app.
      - По умолчанию, он находится в пр.имён App.
      - И автозагружается композером по стандарту PSR-4.
      - Можно изменить это пространство имён командой: app:name

    > Http и Console
      - В app, в числе прочих, есть каталоги Http и Console.
      - Думайте о Http и Console, как о поставщиках API в "ядро" вашего приложения.
      - Т.Е. они делают так, что в вашем приложении становится доступны разнообразные
        API к разнообразным инструментам, которые и можно там использовать.
      - HTTP и Console содержат механизмы для взаимодействия с вашим приложением.
      - Но не содержат его логики.
      - Проще говоря, есть 2 пути выполнять команды в приложении:

        1) Каталог Сonsole
          - Содержит ваши artisan-команды.

        2) Каталог Http
          - Содержит ваши контроллеры, фильтры и запросы.

    > Многие из классов в app можно создавать artisan-командой
      - Посмотреть список доступных для этого команд можно так:

          php artisan list make

    > Обзор прочих каталогов
    
      Commands
      --------
        - Содержит команды вашего приложения.
        - Команды могут добавляться в очередь выполнения вашего приложения.
        - А также могут выполняться синхронно, в течении жизненного цикла запроса.

      Events
      ------
        - Содержит классы событий.
        - Конечно, использовать классы для определения событий не обязательно.
        - Однако, именно в этом каталоге они создаются по умолчанию соотв.командой artisan.

      Handlers
      --------
        - Содержит классы-обработчики для команд и событий.
        - В ответ на команду или событие, срабатывает соотв.обработчик.
        - То есть, классы-обработчики содержат конкретную логику для исполнения.

      Services
      --------
        - Содержит различные сервисы-помощники для вашего приложения.
        - Например, Registrar помогает валидировать и создавать новых пользователей.
        - Или это могут быть сервисы с внешними API.
        - Или измерительные системы, или сервисы, собирающие данные с вашего приложения.

      Exceptions
      ----------
        - Содержит обработчики исключений вашего приложения.
        - Отличное место, чтобы ловить возбуждённые приложением исключения.


Б3.  Service Providers

  --------------------------------------
  Подоглавление:

    - Введение
    - Как создать service provider
    - Отложенный service provider

  --------------------------------------

  > Введение
    - Service Providers (SP) занимают центральное место в Laravel.
    - Сервисы ядра, ваше собств.приложение, снаряжаются при помощи SP-ов.
    - Запрос появляется, и всё приводится в готовность, чтобы его принять и обработать.
    - Сначала выполняются SP фреймворка, потом выполняются SP приложения.
    - Что могут делать SP? По большому счёту, что угодно, но в основном:
      
      - Регистрируют связки в сервис-контейнер.
      - Регистрируют обработчиков событий.
      - Регистрируют фильтры приложения.
      - Регистрируют роуты приложения.
      - И т.д.

    - Т.О., SP занимают центральное место в настройке вашего приложения.
    - В конфиге config/app.php есть массив providers.
    - Он содержит все SP, которые будут выполнены в вашем приложении.
    - Многие из них "отложенные", т.е. будут выполнены при возникновении потребности.
    - В данной главе описано, как создать и зарегистрировать собственный SP.

  > Как создать service provider

    1. Создать файл-класс нового SP в app/providers
      - Для этого можно просто выполнить artisan-команду:

          php artisan make:provider [имя нового sp]

      - Все SP должны реализовывать класс Illuminate\Support\ServiceProvider
      - Этот абстрактный класс требует реализации минимум 1 метода: register.
      - В register нужно только добавлять связи в сервис-контейнер.
      - Не следует в нём регистрировать обработчики событий, роуты, или другой функционал.

    2. Подготовить и наполнить кодом метод register
      - Рассмотрим пример простейшего SP.
      - Он содержит лишь метод register, и находится в пр.имён App\Providers
      - И использует этот метот для определения реализации
        Riak\Contracts\Connection в сервис-контейнере.
      - Итак, пример простейшего SP:

        app/providers/RiakServiceProvider.php
        -------------------------------------
          <?php namespace App\Providers;

          use Riak\Connection;
          use Illuminate\Support\ServiceProvider;

          class RiakServiceProvider extends ServiceProvider {

              // Регистрация связей в сервис-контейнер
              public function register()
              {
                  $this->app->singleton('Riak\Contracts\Connection', function($app)
                  {
                      return new Connection($app['config']['riak']);
                  });
              }

          }

      - Но вообще, можно указывать любое пр.имён в пределах приложения.
      - Ну и класть файлы-классы-SP в соответствующие места.
      - Composer все равно их автоматически загрузит.

    3. Подготовить и наполнить кодом метод boot
      - Этот метод будет запущен ПОСЛЕ регистрации ВСЕХ service provider'ов.
      - Т.Е., в boot код уже имеет доступ ко всему снаряжённому всеми SP функционалу.
      - Итак, допустим, нам требуется зарегистрировать обработчик событий в boot.
      - Сделать это можно так:

        app/providers/RiakServiceProvider.php
        -------------------------------------
          <?php namespace App\Providers;

          use Event;
          use Illuminate\Support\ServiceProvider;

          class EventServiceProvider extends ServiceProvider {

              // Выполнение после-регистрационных действий
              public function boot()
              {
                  Event::listen('SomeEvent', 'SomeEventHandler');
              }

              // Регистрация связей в сервис-контейнер
              public function register()
              {
                  // ... код ...
              }

          }      

    4. Зарегистрировать service provider
      - Все SP зарегистрированы в конфиге config/app.php.
      - В нём есть массив providers, в котором перечислены все SP.
      - По умолчанию, SP в этом списке разделены на 2 группы:

        1) Laravel Framework Service Providers...
        2) Application Service Providers...

      - Для регистрации нового SP, добавляем его имя во 2-ю группу.
      - Имя, разумеется, должно быть квалифицировано соотв.пр.имён.

  > Отложенный service provider
    - Его можно сделать, если ваш SP ТОЛЬКО регистрирует связи в сервис-контейнер.
    - Можно отложить его регистрацию до того момета, когда он на самом деле понадобится.
    - Это поможет ускорить приложение, т.к. отложенный SP не будет загружаться при каждом запросе.
    - Laravel компилирует и сохраняет список отложенных SP.
    - И только при попытке обращения к одному из них, Laravel загружает этот SP.
    - Чтобы сделать SP отложенным:

        1) Надо указать св-во defer, равным true

            protected $defer = true;

        2) Надо определить метод provides
          - Который должен вернуть связи для сервис-контейнера.
          - Которые данный SP и регистрируют.

    - Итак, полный пример отложенного SP:

      app/providers/RiakServiceProvider.php
      -------------------------------------      
        <?php namespace App\Providers;

        use Riak\Connection;
        use Illuminate\Support\ServiceProvider;

        class RiakServiceProvider extends ServiceProvider {

            /**
             * Indicates if loading of the provider is deferred.
             *
             * @var bool
             */
            protected $defer = true;

            /**
             * Register the service provider.
             *
             * @return void
             */
            public function register()
            {
                $this->app->singleton('Riak\Contracts\Connection', function($app)
                {
                    return new Connection($app['config']['riak']);
                });
            }

            /**
             * Get the services provided by the provider.
             *
             * @return array
             */
            public function provides()
            {
                return ['Riak\Contracts\Connection'];
            }

        }


Б4.  Service Container

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Суть 'Service Container' и 'Dependency Injection' наглядно
    - Использование

      Б4.1. Доступ к SC
      -----------------
        - Через $this->app в методе register() сервис-провайдеров
        - Через фасад App.
        - Через контракт Illuminate\Contracts\Container\Container.

      Б4.2. Регистрацация связок SC
      -----------------------------
        - Регистрация резолвера (создаёт экземпляры класса) в SC
        - Регистрация синглтона (всегда возвр. 1-й созданный экземпляр класса) в SC
        - Регистрация экземпляра класса в SC

      Б4.3. Извлечение из SC
      ----------------------
        - Извлечение из SC методом make
        - Извлечение из SC в стиле работы с массивом
        - Извлечение из SC через DI через конструктор класса

      Б4.4. Регистрация в SC / извлечение из SC реализации интерфейса
      ---------------------------------------------------------------
        - Интерфейсы называют контрактами (Contracts)
        - Связывание в SC интерфейса с его реализацией методом bind
        - Извлечение реализации интерфейса из SC через DI через конструктор класса

      Б4.5. Разное
      ------------
        - Контекстное связывание: применение разных реализаций интерфейса для разных классов
        - DI можно делать в роутах, фильтрах, обработчиках событий, контроллерах и т.д.
        - Событие извлечения из SC      


  --------------------------------------

  > Ссылки

    - Inversion of control (wiki en):
        http://en.wikipedia.org/wiki/Inversion_of_control

    - Пара статей о том, что такое IoC:
        http://www.apofig.com/2010/08/dependency-injection-inversion-of.html#cat
        http://vladimirsblog.com/laravel-inversion-of-control/

    - Dependency Injection (wiki en):
        http://en.wikipedia.org/wiki/Dependency_injection

    - Пара статей о том, что такое DI:
        http://www.apofig.com/2011/07/dependency-injection-inversion-of.html
        http://vladimirsblog.com/laravel-dependency-injection-for-beginners/

    - Хороший пример работы с IoC в Laravel:
        http://vladimirsblog.com/laravel-dependency-injection-in-practic/


  > Введение
    - Laravel Service Container (SC), это мощный инструмент для управления зависимостями между классами.
    - Ранее (в laravel 4.2), SC назывался IoC-контейнером.
    - Термин Dependency Injection (DI) означает внедрение зависимостей в класс.
    - DI можно осуществить через конструктор, или через методы-setter'ы.
    - Создаваемый класс может использовать внедрённые классы в своей работе.
    - Глубокое понимание SC является ключём к построению мощных, больших приложений.
    - А также для понимания работы ядра Laravel.


  > Суть 'Service Container' и 'Dependency Injection' наглядно
    
    Суть проблемы - клубок связей между классами
    --------------------------------------------
      - Принцие SOLID гласит: 1 класс - 1 обязанность.
      - Допустим, есть "Класс 1" (К1). Ему для работы нужен "Класс 2" (К2).
      - К1 пользуется свойствами и методами К2.
      - Можно сказать, К1 связан и зависит от К2.
        - При изменении К2 придётся менять и код К1. Это односторонняя связь.
        - При изменении К1 придётся менять К2. Это уже двусторонняя связь.
      - Наличие таких связей является плохой практикой.
        - С ростом размеров приложений их становится трудно отслеживать.
        - Изменил что-нибудь где-нибудь, и N других классов перестало работать.
        - В общем, получается как спутанный клубок ниток. Хаос.

    Service Container (SC) - устраняет связи между классами
    -------------------------------------------------------
      - Концепция SC позволяет решить проблему.
      - Связь "К1 - К2" заменяется на "К1 - И1 - К2". 
      - Где И1 - интерфейс, API которого никогда не меняется, а К2 является его реализацией.
      - При осуществлении след.изменений, код К1 изменять не требуется:
          
          "К1 - И1 - К3"     |    
          "К1 - И1 - К4"     | ... меняем реализации И1 по очереди на К3, К4, К5, ...
          "К1 - И1 - К4"     |    
                ...          |

      - При осуществлении след.изменений, код К5 изменять не требуется:

          "К2 - И1 - К1"     |    
          "К3 - И1 - К1"     | ... меняем классы, использующие И1, на К2, К3, К4, ...
          "К4 - И1 - К1"     |    
                ...          |         

      - Итого, устранены связи между К1 и К2. Миссия выполнена.

    Dependency Injection (DI)
    -------------------------
      - Что такое DI на примере ситуации: "К1 - И1 - К2"?
      - Это процесс подстановки реализации И1 (К2) в К1.
      - Рассмотрим простой пример.

        - Мы продаём подкасты на сайте за деньги.
        - При покупке надо выполнять некие действия.
        - В том числе, посылать покупателю email о покупке.
        - В данном случае роли распределяются так:
          
            К1: PurchasePodcastHandler
            И1: Illuminate\Contracts\Mail\Mailer
            К2: реализация интерфейса Mailer

        - Как видим, К2 передана в К1 через конструктор К1.
        - И записана в св-во mailer в К1.
        - Это и есть процесс "внедрения зависимости".
        - Код примера:

          <?php namespace App\Handlers\Commands;

            use App\User;
            use App\Commands\PurchasePodcastCommand;
            use Illuminate\Contracts\Mail\Mailer;

            class PurchasePodcastHandler {

              // 1. Подготовить св-во для экземпляра класса-реализации Mailer
              protected $mailer;

              // 2. Конструктор класса
              // - В качестве аргумента передаём в него реализацию
              public function __construct(Mailer $m) {

                  // Записать реализацию в $mailer
                  $this->mailer = $m;

              }

              // 3. Код-обработчик покупки
              public function handle(PurchasePodcastCommand $command)
              {
                  // ... применяем здесь mailer ...
              }

            }

          ?>        

    Иллюстрация
    -----------

                               --------------------------------
                               |Интерфейс, от которого зависит|
      ------------------       |пользовательский код          |
      |Пользовательский|       |------------------------------|
      |код.            | ----> |По совместительству - слот, в |
      ------------------       |который Service Container     | <-----|
                               |подставит одну из реализаций  |       |
                               |интерфейса во время выполнения|       |
                               |пользовательского кода        |       |
                               --------------------------------       |
                                                                      |
                                                                      |
                                                           -----------|
           Service Container подставит                     |
           в слот одну из этих                             |
           реализаций класса-зависимости.                  |
           Кукую именно? Зависит от того,                  |
           как разработчик настроил          --------------|------------------------
           Service Container                 |                  |                  |
                                             |                  |                  |
                                             |                  |                  |
                                  ------------------   ------------------   ------------------
                                  |Класс-реализация|   |Класс-реализация|   |Класс-реализация|
                                  |интерфейса. v1  |   |интерфейса. v2  |   |интерфейса. v3  |
                                  ------------------   ------------------   ------------------  

  > Использование
  
  //-------------------//
  // Б4.1. Доступ к SC //
  //-------------------//

    > Через $this->app в методе register() сервис-провайдеров
      - В сервис-провайдере доступ к SC можно получить через $this->app.
      - А метод register() сервис-провайдера хорошее место для регистрации в SC.
 
    > Через фасад App.
      - Есть фасад 'Illuminate\Support\Facades\App'.
      - Для него есть псевдоним 'App' в aliases в config/app.php
      - Через этот фасад и его псевдоним можно получить доступ к SC.

    > Через контракт Illuminate\Contracts\Container\Container.
      - Можно внедрить экземпляр SC в свой класс через его конструктор
      - Собственно, по механизму DI, описанному выше.
      - По всей видимости, он будет внедрён с использованием паттерна синглтон.


  //-------------------------------//
  // Б4.2. Регистрацация связок SC //
  //-------------------------------//
  // - Доступ к SC в примерах получаем через $this->app
  // - Т.Е. подразумеваем, что примеры находятся в сервис-провайдере
  
    > Регистрация резолвера (создаёт экземпляры класса) в SC
      - Резолвер создаёт и возвращает ссылку на объект указанного класса.
      - Зарегистрируем в SC новую связку-резолвер класса FooBar:

          $this->app->bind('FooBar', function($app)
          {
              return new FooBar($app['SomethingElse']);
          });      

    > Регистрация синглтона (всегда возвр. 1-й созданный экземпляр класса) в SC
      - Синглтон при обращении в 1-й раз создаёт и возвращает ссылку 
        на объект указанного класса.
      - А при обращении в >= 2 раз просто возвращает ссылку на тот 
        объект, который был создан при обращении в 1-й раз.
      - Зарегистрируем в SC новую связку-синглтон класса FooBar:

          $this->app->singleton('FooBar', function($app)
          {
              return new FooBar($app['SomethingElse']);
          });      

    > Регистрация экземпляра класса в SC
      - Можно просто добавить в SC готовый экземпляр какого-нибудь класса.
      - Например, создадим экземпляр класса FooBar:

          $fooBar = new FooBar(new SomethingElse);

      - И добавим в SC связку, возвращающую fooBar:

          $this->app->instance('FooBar', $fooBar);


  //------------------------//
  // Б4.3. Извлечение из SC //
  //------------------------//
  // - Доступ к SC в примерах получаем через $this->app
  // - Т.Е. подразумеваем, что примеры находятся в сервис-провайдере
    
    > Извлечение из SC методом make
      - Во-первых, извлечь элемент из SC можно методом make.
      - Получим доступ к элементу в SC по ключу FooBar:

          $fooBar = $this->app->make('FooBar');      


    > Извлечение из SC в стиле работы с массивом
      - Во-вторых, SC реализует интерфейс ArrayAcces.
      - Значит, можно извлечь эл-т из SC, как из массива.
      - Получим доступ к элементу в SC по ключу FooBar:

          $fooBar = $this->app['FooBar'];


    > Извлечение из SC через DI через конструктор класса
      - В-треьих (и главных) можно поступить следующим образом.
      - Но лишь в конструкторе класса, который буде отрезолвлен SC.
      - Можно указать нужную зависимость в качестве его аргумента.
      - И при резолве класса SC, он сам извлечёт нужную зависимость из себя.
      - Например, лежит у нас в SC связка-резолвер "UserRepository".
      - И пишем мы контроллер. Указываем эту связку в аргументе его конструктора.
      - В результате, экземпляр класса UserRepository доступен в любом месте
        кода контроллера, как $users.
      - Код:

          <?php namespace App\Http\Controllers;

          use Illuminate\Routing\Controller;
          use App\Users\Repository as UserRepository;

          class UserController extends Controller {

              // Для хранения экземпляра UserRepository
              // - Он будет сюда положен, когда SC разресолвит
              //   данный контроллер.
              protected $users;

              // Конструктор контроллера
              public function __construct(UserRepository $users)
              {
                  // При резолве контроллера, SC автоматически
                  // извлекает UserRepository из себя, и добавляет
                  // сюда в качестве аргумента
                  $this->users = $users;

              }

              // Функция show контроллера
              public function show($id)
              {
                  // Здесь можем обратиться к users
              }

          }

          ?>      


  //-----------------------------------------------------------------//
  // Б4.4. Регистрация в SC / извлечение из SC реализации интерфейса //
  //-----------------------------------------------------------------//
  
    > Интерфейсы называют контрактами (Contracts)
      - Выше была описана концепция работы Laravel Service Container.
      - Там были упомянуты интерфейсы, которые рвут зависимости между классами.
      - Так вот, в Laravel такие интерфейсы называют "contracts" (контракты).
      - Контракты ядра Laravel хранятся в каталоге:

          vendor/laravel/framework/src/illuminate/contracts

      - Хранить пользвательские контракты можно где угодно.
      - Например, создать для них каталог:

          app/Contracts


    > Связывание в SC интерфейса с его реализацией методом bind
      
      Задача для примера
      ------------------
        - Допустим, в проекте требуется сервис для отправки SMS.
        - И есть 3 хороших сервиса-кандидата, у каждого свой PHP-API.
        - Причём в будущем возможна замена одного сервеса на другой.
        - Либо, использование какого-либо из этих сервисов в зависимости от контекста.
        - Требуется применить концепцию SC и решить эту ситуацию.

      Пошаговое решение
      -----------------

        1. Создать необходимые каталоги (если нет):

          1) Каталог для пользовательских контрактов, если его ещё нет
            - Можно где угодно. Ну, допустим, по адресу: app/Contracts

          2) Каталог для реализаций пользовательских контрактов
            - Скажем, по адресу: app/Services

        2. Создать в этом каталоге интерфейс SmsInterface:

          <?php namespace App\Contracts;

            interface iSMS {

              // Отправить sms
              public function send($event, array $data);

              // ... другие методы ...

            }

          ?>   

        3. Создать реализации интерфейса SmsInterface в app/Services
          - Для каждого из SMS-сервисов свою реализацию.

        4. Зарегистрировать связку интерфейс-реализация в SC
          - Перед этим выбрать какую-нибудь 1-ну из реализаций.
          - И зарегистрировать:

              $this->app->bind('App\Contracts\SmsInterface', 'App\Services\SmsMagic');


    > Извлечение реализации интерфейса из SC через DI через конструктор класса
      - См. выше "Извлечение из SC через DI через конструктор класса".
      - При обращении к интерфейсу по имени, SC подставит связанную с ним реализацию.


  //--------------//
  // Б4.5. Разное //
  //--------------//

    > Контекстное связывание: применение разных реализаций интерфейса для разных классов
      
      Проблема
      --------
        - Допустим, зарегистрировали в SC реализацию интерфейса iSMS.
        - Но что, если в опред.классах надо использовать другую реализацию?
        - То есть, надо, чтобы SC при DI подставлял другую реализацию?

      Решение
      -------
        - В Laravel есть механизм "контекстного связывания" в SC.
        - По умолчанию действует та реализация iSMS, которую мы назначили.
        - Но, скажем, в классе App\Handlers\Commands\CreateOrderHandler
          мы хотим использовать другую реализацию.
        - Это можно сделать вот так:

          $this->app->when('App\Handlers\Commands\CreateOrderHandler')
            ->needs('App\Contracts\EventPusher')
            ->give('App\Services\PubNubEventPusher');


    > DI можно делать в роутах, фильтрах, обработчиках событий, контроллерах и т.д.
      - Сабж.

    > Событие извлечения из SC   
      - SC возбуждает событие каждый раз при извлечении из него.
      - Можно отлавливать эти события, используя метод 'resolving'.
      - Например:

          $this->app->resolving(function($object, $app)
          {
            // Срабатывает, когда SC резолвит объект любого типа
          });        

      - И вот ещё:

          $this->app->resolving(function(FooBar $fooBar, $app)
          {
            // Срабатывает, когда SC резолвит объект типа FooBar
          }); 


Б5.  Contracts (интерфейсы для SC)

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Как применяются контракты: в двух словах
    - Контракты, как краткий справочник функционала фреймворка

  --------------------------------------

  > Ссылки

    # Собственный, официальный GitHub-репозиторий всех контрактов Laravel
        https://github.com/illuminate/contracts

    # Оф.справка по контрактам Laravel (en), с их полным списком
        http://laravel.com/docs/5.0/contracts


  > Введение
    - В Laravel есть технология, которая называется Service Container.
    - Суть: убирает связи между классами, вставляя между ними интерфейс.
    - Она подробно описана в одной из глав в данной документации.
    - Так вот, такие интерфейсы в терминологии Laravel называются Contracts.


  > Как применяются контракты: в двух словах

    Где определяются контракты
    --------------------------
      - Контракты ядра Laravel находятся по адресу:
          vendor/laravel/framework/src/Illuminate/Contracts
      - Каталога для пользосательских контрактов "из коробки" не предусмотрено.
      - Но его можно самостоятельно создать. Неплохое место для этого:
          app/Contracts

    Где определяются реализации контрактов ядра
    -------------------------------------------
      - Где определяются реализации для контрактов ядра, точно не известно.
      - Так как не задокументировано, в каких сервис-провайдерах происходит
        связывание в SC контрактов ядра с его реализациями методом bind.
      - И, соответственно, нельзя посмотреть, где эти реализации лежат.
      - Я предполагаю, что в vendor/laravel/framework/src/Illuminate

    Где определяются реализации пользовательских контрактов
    -------------------------------------------------------
      - Каталога для реализаций пользовательских контрактов "из коробки" не предусмотрено.
      - Но его можно самостоятельно создать. Неплохое место для этого:
          app/Services
      - Набор реализаций для каждого контракта также можно класть в отдельный каталог.
      - Например, реализации для контракта SmsInterface можно класть в каталог:
          app/Services/Sms

    Где производится связывание в SC польз.контрактов с его реализациями методом bind
    ---------------------------------------------------------------------------------
      - Лучшее место для этого, метод register() какого-нибудь сервис-провайдера.
      - Лучше всего даже создать отдельный сервис-провайдер для этих целей.
      - И положить в доступный для этого "из коробки" каталог app/Providers
      - И не забыть его добавить в массив providers в config/app.php
      - Хотя, для этих целей разработчики уже создали сервис-провайдер:
          app/Providers/AppServiceProvider.php
      - И рекомендуют регистрировать связки в SC в его методе register.


  > Контракты, как краткий справочник функционала фреймворка
    - Имеются в виду контракты функционала ядра фреймворка.
    - Ведь эти интерфейсы требуют реализации обозначенных в них функций.
    - И каждый метод интерфейса задокументирован прямо в нём.
    - Так что, можно просматривать контракты, и видеть список доступных методов.


Б6.  Facades

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Использование фасадов

      - Где лежат фасады?
      - Что из себя представляет класс-фасад?
      - Пример класса-фасада
      - Псевдонимы для фасадов
      - Доступ к фасаду через псевдоним не из глобального пр.имён

    - Создание своего фасада
    - Проблема с автозагрузкой фасадов в аргументах

  --------------------------------------

  > Ссылки

    # Оф.справка по фасадам Laravel (en), с их полным списком
        http://laravel.com/docs/5.0/facades


  > Введение

    Предисловие про SC
    ------------------
      - В Laravel есть технология, которая называется Service Container.
      - Суть: убирает связи между классами, вставляя между ними интерфейс.
      - Она подробно описана в одной из глав в данной документации.

    3 способа обратиться к SC
    -------------------------
      1) Через $this->app в сервис-провайдерах.
      2) Через фасад App
      3) Через DI контракта Illuminate\Contracts\Container\Container в класс

    3 способа извлечь связку из SC
    ------------------------------
      1) Методом make
      2) В стиле работы с массивом
      3) Через DI через конструктор класса

    Не слишком ли много действий? Представляем фасады!
    --------------------------------------------------
      - Допустим, мы хотим извлечь из SC какой-то элемент.
      - Сначала надо обратиться к SC одним из 3-х способов.
      - Потом вспомнить ключ и извлечь из SC элемент одним из 3-х способов.
      - Как-то это всё напряжно, не находите?
      - Чтобы сделать жизнь проще, придумали классы-фасады.
      - Они:
        1) Выполняют всю вышеуказанную работу за вас.
        2) Имеют запоминающееся и простое название.

    Псевдонимы для фасадов
    ----------------------
      - Однако, совершать операции по извлечению из SC всё ещё не комфортно.
      - Посудите сами, чтобы обратиться к фасаду View, надо написать такую простыню:
          Illuminate\Support\Facades\View
      - Поэтому придумали для фасадов псевдонимы.
      - Они перечислены в массиве aliases в config/app.php.
      - Псевдонимы определены в глобальном пространстве имён.
      - Теперь обратиться к фасаду View откуда угодно можно так:
          \View


  > Использование фасадов         

    Где лежат фасады?
    -----------------
      - Все классы-фасады лежат в слелующем каталоге:
          vendor/laravel/framework/src/Illuminate/Support/Facades

    Что из себя представляет класс-фасад?
    -------------------------------------
      - Он наследует от класса Facades.
      - Имеет лишь 1 метод: getFacadeAccessor.
      - Единственная задача этого метода: 
          вернуть строку с ключем эл-та из SC, который фасад должен извлекать.

    Пример класса-фасада
    --------------------

      vendor/laravel/framework/src/Illuminate/Support/Facades/app.php
      ---------------------------------------------------------------
        <?php namespace Illuminate\Support\Facades;

          class App extends Facade {

            // Извлечь компонент 'app' из SC и вернуть
            protected static function getFacadeAccessor()
            {
              return 'app';
            }

          } 

        ?>   

    Псевдонимы для фасадов
    ----------------------
      - Псевдонимы фасадов перечислены в массиве aliases в config/app.php
      - Псевдонимы определены в глобальном пространстве имён.
      - Они делают извлечение из SC ещё более удобным.
      - Пример извлечения view (допустим, код из любого сервис-провайдера):

        Без фасада и псевдонима
        -----------------------
          $view = $this->app->make('FooBar');

        С фасадом
        ---------
          $view = \Illuminate\Support\Facades\View;

        С фасадом и псевдонимом
        -----------------------
          $view = \View;

            .. или ..

          use View;
          $view = View;


    Доступ к фасаду через псевдоним не из глобального пр.имён
    ---------------------------------------------------------
      - Псевдонимы фасадов определены в глобальном пр.имён.
      - Поэтому такой доступ возможен только из него:

          $view = View;

      - Так было в любом месте кода в Laravel 4.*
      - Но в Laravel 5 используется стандарт PSR-4.
      - И большая часть кода находится не в глобальном пр.имён.
      - В этом случае, действовать надо так:

          $view = \View;    // абсолютный путь к псевдониму от глоб.пр.имён

      - Или так:

          use View;         // импорт псевдонима в текущее пр.имён
          $view = View;     // обращение к View в текущем пр.имён


  > Создание своего фасада

    3 вещи, которые нужно сделать, чтобы создать фасад
    --------------------------------------------------

      1) Добавить связку в Service Container
        - Как работать с SC подробно описано в одной из глав этого руководства.

      2) Создать класс-фасад
        - Где они лежат, и как выглядят, описано выше.

      3) Добавить псевдоним для фасада в aliases в config/app.php
        - Без псевдонимов удобство использования фасадов для извлечения
          элементов из SC под вопросом.


  > Проблема с автозагрузкой фасадов в аргументах
    - В некоторых случаях классы из массива aliases недоступны.
    - Допустим, есть у нас такой псевдоним:
        ApiTimeoutException => \ServiceWrapper\ApiTimeoutException
    - И пробуем мы его применить за пределами пр.имён \ServiceWrapper:
        catch(ApiTimeoutException $e)
    - Не сработает.
    - Поскольку PHP не пытается автоподгружать undefined-классы в аргументах.
    - Единственный выход в таких случаях, отказаться от псевдонимов.
    - И импортировать нужные классы с помощью use.


В1.  Основы работы с БД в Laravel

  --------------------------------------
  Подоглавление:

    - Настройка
    - Разные настройки соединения для операций чтение/запись.
    - Выполнение запросов
    - Работа с транзакциями
    - Доступ к другим соединениям и манипуляции с ними
    - Ведение лога запросов

  --------------------------------------

  > Настройка
    - Настроить подключения к БД в Laravel можно в файле "app/config/database.php".
    - Все соединения там хранятся в массиве в параметре "connections".
    - В этом же файле можно указать соединение "по умолчанию" в параметре "default".
    - А всего Laravel поддерживает 4 СУБД: MySQL, Postgres, SQLite, SQL Server.

  > Разные настройки соединения для операций чтение/запись.

    > Введение
      - Иногда может понадобиться установить разные настройки для операций чтения/записи.
        - Операции чтения: SELECT
        - Операции записи: INSERT, UPDATE, DELETE.
      - Laravel позволяет это организовать.
      - И это будет работать независимо от того, каким способом сделан запрос:
        простой запрос, query builder или Eloquent ORM.

    > Как реализуется
      - Реализуется всё с помощью ключей 'read' и 'write'
      - Эти ключи добавляются в массив настроек соединения.
      - В каждом из них могут быть все теже самые параметры, что в массиве настроек.
      - В случае операции чтения значения из массива 'read' заменят значения
        соответствующих параметров в массиве настроек соединения.
      - В случае операции записи значения из массива 'write' заменят значения
        соответствующих параметров в массиве настроек соединения.

    > Пример:

      1 Вот у нас в файле database.php в массиве 'connections' есть ключ 'mysql',
        который символизитует одно из соединений. В нём лежит вот такой массив с
        настройками этого соединения:

          'mysql' => array(
              'host'      => 'localhost:3308',
              'driver'    => 'mysql',
              'database'  => 'database',
              'username'  => 'root',
              'password'  => '',
              'charset'   => 'utf8',
              'collation' => 'utf8_unicode_ci',
              'prefix'    => '',
          )

      2 Допустим, мы хотим, чтобы для операций чтения/записи были разные
        значения 'host'. Тогда этот массив будет выглядеть так:

          'mysql' => array(
              'read' => array(
                  'host' => '192.168.1.1',
              ),
              'write' => array(
                  'host' => '196.168.1.2'
              ),
              'driver'    => 'mysql',
              'database'  => 'database',
              'username'  => 'root',
              'password'  => '',
              'charset'   => 'utf8',
              'collation' => 'utf8_unicode_ci',
              'prefix'    => '',
          )

  > Выполнение запросов

    > Введение
      - Как только соединение с БД настроено, можно делать к ней запросы.
      - Функционал для этого сконцентрирован и доступен через псевдоним DB фасада.

    > Практика
      
      Запрос SELECT с использованием не именованной связки
      ----------------------------------------------------
        - Здесь использован 1 плейсхолдер '?'.
        - Значение которого заменяется в запросе на 1.

            $results = DB::select('select * from users where id = ?', array(1));

      Запрос SELECT с использованием именованной связки
      -------------------------------------------------
        - Здесь использован 1 именованный плейсхолдер ':id'.
        - Значение которого заменяется в запросе на 1.

            $results = DB::select('select * from users where id = :id', ['id' => 1]);

      Запрос INSERT
      -------------
        - Здесь уже использованы 2 плейсхолдера '?'. 
        - Значение первого в запросе заменяется на 1, а втого на 'Dayle'.
            
            DB::insert('insert into users (id, name) values (?, ?)', array(1, 'Dayle'));

      Запрос UPDATE
      -------------
            DB::update('update users set votes = 100 where name = ?', array('John'));

      Запрос DELETE
      -------------
            DB::delete('delete from users');

      Выполнить SQL-запрос из строки
      ------------------------------
            DB::statement('drop table users');

      Назначить функцию-обработчик
      ----------------------------
        - Лучше всего это делать в каком-нибудь сервис-провайдере.
        - Она будет отлавливать все события, возбуждаемые при исполнении запросов к БД.

            DB::listen(function($sql, $bindings, $time)
            {
                //
            });

  > Работа с транзакциями

    > Введение
       - Функционал Laravel позволяет рабоать и с транзакциями.
       - Если внутри транзакции возникает любое исключение, происходит ролбэк автоматом.

    > Практика
      - Способ №1: использовать метод DB::transaction
          Выполнить несколько запросов одной транзакцией:

            DB::transaction(function()
            {
                DB::table('users')->update(array('votes' => 1));

                DB::table('posts')->delete();
            });

      - Способ №2: управление транзакцией вручную

          // Начать транзакцию
            DB::beginTransaction();

          // Сделать коммит
            DB::commit();

          // Сделать ролбэк
            DB::rollback();

  > Доступ к другим соединениям и манипуляции с ними

    > Практика:
      - В приложении может быть настроено > 1 соединения. Что, если мы
        хотим выполнить операцию не с default-соединением?
        Это можно сделать так:

          $users = DB::connection('foo')->select(...);

      - Получить ссылку на underlying PDO-объект-соединение можно так:

          $pdo = DB::connection()->getPdo();

      - Сделать реконнект соединения можно так:

          DB::reconnect('foo');

      - Сделать дисконнект соединения можно так:

          DB::disconnect('foo');

  > Ведение лога запросов

    > Введение
      - По умолчанию Larvel ведёт лог всех запросов к БД, которые были сделаны
        в этом экземпляре приложения, в оперативной памяти.
      - Минус такого подхода - если запросов очень много, то приложение может
        начать расходовать много оперативки.

    > Практика:

      - Отключить ведение лога запросов к БД в оперативке:
          DB::connection()->disableQueryLog();

      - Получить массив исполненных запросов:
          $queries = DB::getQueryLog();


В2.  Query Builder (конструктор запросов)

  --------------------------------------
  Подоглавление:

    - Введение
    - Функционал

      1]  Selects

        - Извлечь все строки из таблицы
        - Извлечь и обработать из таблицы все данные, кусками по 100 шт.
        - Извлечь первую найденную строку из таблицы
        - Извлечь значение из одной ячейки из одной найденной строки
        - Извлечь массив полей из указанной колонки таблицы
        - Извлечь из таблицы все строки, но только из указанных столбцов
        - Уточнение запроса SELECT
        - Дополнить уже существующий запрос select новым столбцом
        - Использование оператора where
        - Использование оператора orWhere
        - Использование оператора whereBetween
        - Использование оператора whereNotBetween
        - Использование операторов WhereIn / WhereNotIn с массивом значений
        - Использование оператора whereNull
        - Использование "динамических" where
        - Использование Order By, Group By, Having
        - Использование OFFSET и LIMIT

      2]  Joins

        - Inner join
        - Left join
        - Продвинутые inner join

      3]  Advanced Wheres

        - Группировка нескольких "И"-where
        - Применение exists-утверждения

      4]  Aggregates

        - count() - вернуть кол-во строк в таблице        
        - max(col) - вернуть MAX значение в столбце col        
        - min(col) - вернуть MIN значение в столбце col        
        - avg(col) - найти среднее среди значений столбца col        
        - sum(col) - найти сумму значений в столбце col        

      5]  Raw SQL Expressions
      
      6]  Inserts

        - Вставить строку значений в таблицу
        - Вставить строку значений в таблицу с автоинкрементом
        - Вставить несколько строк в таблицу

      7]  Updates

        - Обновить значения в указанных столбцах, в указанных строках
        - Инкремент/декремент значения в указанном столбце/ах
      
      8]  Deletes

        - Удалить указанные строки из таблицы
        - Удалить все строки из таблицы
        - Операция truncate

      9]  Unions

        - Создать запрос и сохранить его в $first
        - Объединить запрос $first и ещё один запрос

      10]  Pessimistic Locking

        - Применение shared lock
        - Применение lock for update

  --------------------------------------
  

  > Введение


    В общем про "Query Builder"
    ---------------------------
      - В Laravel можно делать запросы к БД вручную их прописывая, как строку.
      - Как делать такие запросы, описано выше в главе 10.
      - А можно использовать специальный функционал "Query Builder".
      - В этой главе как раз и описывается использование этого функционала.

    Недостатки и преимущества функционала "Query Builder"
    -----------------------------------------------------

      > Относительно чего сравниваем "Query Builder"?
        - Относительно ввода запросов к БД вручную, как описано в главе 10.

      > Недостатки
        - Вручную можно составить запрос гибче.
        - Вручную при составлении запроса можно использовать особенности
          конкретной СУБД, а при использовании "Query Builder" нельзя.

      > Преимущества
        - Универсален. Работает со всеми 4-мя поддерживаемыми СУБД. При этом
          использовать надо один и тот же функционал без изменений. Как следствие,
          можно использовать любую БД из поддерживаемых, даже не зная диалектов.
        - Нет необходимости "чистить" строки-параметры, передаваемые функционалу
          "Query Builder", чтобы защититься от SQL Injection. Потому что этот
          функционал использует PDO.
        - Удобен. Благодаря "IDE Helper Generator" в PHPStorm для всех классов
          Laravel, в т.ч. DB, работает автозавершение.


  > Функционал

    //-------------//
    // 1]  Selects //
    //-------------//

      Извлечь все строки из таблицы
      -----------------------------
        - Извлечь их:

            $users = DB::table('users')->get();

        - Пробежаться по всем строкам, и вывести содержание поля 'name' каждой:
            foreach ($users as $user)
            {
                dd($user->name);
            }

      Извлечь и обработать из таблицы все данные, кусками по 100 шт.
      --------------------------------------------------------------
        - Сделать это:

          DB::table('users')->chunk(100, function($users)
          {
              foreach ($users as $user)
              {
                  //
              }
          });

        - Остановить извлечение на текущей итерации, можно вернув false:

          DB::table('users')->chunk(100, function($users)
          {
              //

              return false;
          });        

      Извлечь первую найденную строку из таблицы
      --------------------------------------------
        - В таблице 'users' найти все строки, в которых значение в столбце
          'name' равно 'John', и вернуть первую из них:

            $user = DB::table('users')->where('name', 'John')->first();

        - Вывести на экран значение из столбца 'name' из найденной строки:

            dd($user->name);

      Извлечь значение из одной ячейки из одной найденной строки
      ----------------------------------------------------------
        - В таблице 'users' найти все строки, в которых значение в столбце
          'name' равно 'John', и из первой из них извлечь и вернуть значение
          из столбца 'name':

            $name = DB::table('users')->where('name', 'John')->pluck('name');

      Извлечь массив полей из указанной колонки таблицы
      -------------------------------------------------
        - Извлечь массив значений полей колонки 'title' таблицы 'roles':

            $roles = DB::table('roles')->lists('title');

      Извлечь из таблицы все строки, но только из указанных столбцов
      --------------------------------------------------------------
        - Из таблицы 'users' из столбцов 'name' и 'email' извлечь
          все строки:

            $users = DB::table('users')->select('name', 'email')->get();

      Уточнение запроса SELECT
      ------------------------

        # Извлечь только данные из указанных столбцов
          $users = DB::table('users')->select('name', 'email')->get();

        # Извлечь все уникальные строки (дублирующие не возвращать)
          $users = DB::table('users')->distinct()->get();

        # Извлечь все, применив псевдоним для столбца name
          $users = DB::table('users')->select('name as user_name')->get();


      Дополнить уже существующий запрос select новым столбцом
      -------------------------------------------------------
        - Создать SQL-запрос и сохранить его в переменную. Он должен из
          таблицы 'users' извлечь все строки для столбца 'name':

            $query = DB::table('users')->select('name');

        - Дополнить запрос $query - чтобы он извлекал данные ещё из из
          столбца 'age':

            $query = $query->addSelect('age');

        - Выполнить запрос $query и получить результат:

            $users = $query->get();

      Использование оператора where
      -----------------------------
        - Из таблицы 'users' извлечь все строки, у которых в столбце
          'votes' значение > 100:

            $users = DB::table('users')->where('votes', '>', 100)->get();

      Использование оператора orWhere
      -------------------------------
        - Из таблицы 'users' извлечь все строки, у которых или в столбце
          'votes' значение > 100, или в столбце 'name' значение 'John':

            $users = DB::table('users')
                                ->where('votes', '>', 100)
                                ->orWhere('name', 'John')
                                ->get();

      Использование оператора whereBetween
      ------------------------------------
        - Из таблицы 'users' извлечь все строки, у которых значение
          в столбце 'votes' находится между 1 и 100:

            $users = DB::table('users')
                                ->whereBetween('votes', array(1, 100))->get();

      Использование оператора whereNotBetween
      ---------------------------------------
        - Из таблицы 'users' извлечь все строки, у которых значение
          в столбце 'votes' находится НЕ между 1 и 100:

            $users = DB::table('users')
                                ->whereNotBetween('votes', array(1, 100))->get();

      Использование операторов WhereIn / WhereNotIn с массивом значений
      -----------------------------------------------------------------
        
        # WhereIn
          - Из таблицы 'users' извлечь все строки, у которых значение в
            столбце 'id' равно хотя бы одному из переданных в массиве значений:

              $users = DB::table('users')
                                  ->whereIn('id', array(1, 2, 3))->get();

        # WhereNotIn
          - Из таблицы 'users' извлечь все строки, у которых значение в
            столбце 'id' НЕ равно НИ одному из переданных в массиве значений:

              $users = DB::table('users')
                                  ->whereNotIn('id', array(1, 2, 3))->get();
                                    

      Использование оператора whereNull
      ---------------------------------
        - Из таблицы 'users' извлечь все строки, у которых значения в
          столбце 'updated_at' равны null (не установлены):

            $users = DB::table('users')
                                ->whereNull('updated_at')->get();

      Использование "динамических" where
      ----------------------------------
        - Для гибкого построения запросов, это интересно.
        - Примеры:

          $admin = DB::table('users')->whereId(1)->first();

          $john = DB::table('users')
                              ->whereIdAndEmail(2, 'john@doe.com')
                              ->first();          

          $jane = DB::table('users')
                              ->whereNameOrAge('Jane', 22)
                              ->first();

      Использование Order By, Group By, Having
      ----------------------------------------
        - Извлечь все строки из таблицы 'users'.
        - Отсортировать их по убыванию (orderBy).
        - Сгруппировать по столбцу count (groupBy).
        - Вернуть те строки, у которых значение в столбце 'count' > 100.

            $users = DB::table('users')
                                ->orderBy('name', 'desc')
                                ->groupBy('count')
                                ->having('count', '>', 100)
                                ->get();

      Использование OFFSET и LIMIT
      ----------------------------
        - Примечания:
          - skip(n) - это offset, а take(n) - это limit
          - Отсчёт строк в таблицы нечинается не с 1, а с 0.
        - Извлечь все строки из таблицы 'users'. Из них вернуть вернуть
          5 строк, начиная с №11 включительно:

            $users = DB::table('users')->skip(10)->take(5)->get();


    //-----------//
    // 2]  Joins //
    //-----------//

      Inner join
      ----------
        - Есть 3 таблицы: 'users', 'contacts' и 'orders.
        - В результирующей таблице должны быть только следующие столбцы:
          'users.id', 'contacts.phone' и 'orders.price'.
        - В результирующую таблицу должны попасть только те строки, которые
          удовлетворяют условиям.
        - Условие 1: users.id == contacts.user_id
        - Условие 2: users.id == orders.user_id
        - На выходе будет массив объектов, где каждый объект представляет
          одну результирующую строку.

          $result = DB::table('users')
                      ->join('contacts', 'users.id', '=', 'contacts.user_id')
                      ->join('orders', 'users.id', '=', 'orders.user_id')
                      ->select('users.id', 'contacts.phone', 'orders.price');

      Left join
      ---------
        - Есть 2 таблицы: 'users' и 'posts'.
        - Нужно для каждой строки из 'users' вывести все строки из 'posts',
          для которых 'users.id' == 'posts.user_id'. Если, например, у
          юзера с users.id = 2 в таблице 'posts' есть 3 поста, то для него
          будут выведены 3 строки: слева будут одинаковые строки из
          таблицы 'users', в которых users.id == 2, а справа разные строки
          из таблицы 'posts' с постами этого юзера.
        - На выходе будет массив объектов, где каждый объект представляет
          одну результирующую строку.

          DB::table('users')
                  ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
                  ->get();

      Продвинутые inner join
      ----------------------

        // Один
          DB::table('users')
                  ->join('contacts', function($join)
                  {
                      $join->on('users.id', '=', 'contacts.user_id')->orOn(...);
                  })
                  ->get();

        // Два
          DB::table('users')
                  ->join('contacts', function($join)
                  {
                      $join->on('users.id', '=', 'contacts.user_id')
                           ->where('contacts.user_id', '>', 5);
                  })
                  ->get();

    //---------------------//
    // 3]  Advanced Wheres //
    //---------------------//

      Группировка нескольких "И"-where
      --------------------------------
        - Вот QB-выражение:

            DB::table('users')
                        ->where('name', '=', 'John')
                        ->orWhere(function($query)
                        {
                            $query->where('votes', '>', 100)
                                  ->where('title', '<>', 'Admin');
                        })
                        ->get();

        - На выходе оно даёт вот такой SQL:

            SELECT * FROM users WHERE name = 'John' OR
                                    (votes > 100 and title <> 'Admin')

      Применение exists-утверждения
      -----------------------------
        - Вот QB-выражение:

            DB::table('users')
                        ->whereExists(function($query)
                        {
                            $query->select(DB::raw('*'))
                                  ->from('orders')
                                  ->whereRaw('orders.user_id = users.id');
                        })
                        ->get();

        - На выходе даёт вот такой SQL:

            SELECT * FROM users
              WHERE EXISTS (
                  SELECT * FROM orders WHERE orders.user_id = users.id
              )


    //----------------//
    // 4]  Aggregates //
    //----------------//

      count() - вернуть кол-во строк в таблице
      ----------------------------------------  
        $users = DB::table('users')->count();

      max(col) - вернуть MAX значение в столбце col
      ---------------------------------------------
        $price = DB::table('orders')->max('price');

      min(col) - вернуть MIN значение в столбце col
      ---------------------------------------------
        $price = DB::table('orders')->min('price');

      avg(col) - найти среднее среди значений столбца col
      ---------------------------------------------------
        $price = DB::table('orders')->avg('price');

      sum(col) - найти сумму значений в столбце col
      ---------------------------------------------
        $total = DB::table('users')->sum('votes');


    //-------------------------//
    // 5]  Raw SQL Expressions //
    //-------------------------//

      > Введение
        - Описан функционал QB, позволяющий вставлять строки с кусками
          произвольного SQL в запрос, составленный с помощью QB.
        - Это позволяет писать более гибкие запросы, используя QB.
        - Также здесь описано инкрементирование/декрементирование
          всех значений в указанной колонке таблицы.

      > Практика

        - В этом примере в функцию select() вставлен кусок SQL-кода
          с помощью DB::raw(), описывающий это выражение SELECT:

            $users = DB::table('users')
                         ->select(DB::raw('count(*) as user_count, status'))
                         ->where('status', '<>', 1)
                         ->groupBy('status')
                         ->get();


    //-------------//
    // 6]  Inserts //
    //-------------//

      Вставить строку значений в таблицу
      ----------------------------------

          DB::table('users')->insert(
              array('email' => 'john@example.com', 'votes' => 0)
          );

      Вставить строку значений в таблицу с автоинкрементом
      ----------------------------------------------------

          $id = DB::table('users')->insertGetId(
              array('email' => 'john@example.com', 'votes' => 0)
          );

      Вставить несколько строк в таблицу
      ----------------------------------

          DB::table('users')->insert(array(
              array('email' => 'taylor@example.com', 'votes' => 0),
              array('email' => 'dayle@example.com', 'votes' => 0),
          ));


    //-------------//
    // 7]  Updates //
    //-------------//

      Обновить значения в указанных столбцах, в указанных строках
      -----------------------------------------------------------

        DB::table('users')
            ->where('id', 1)
            ->update(['votes' => 1]);

      Инкремент/декремент значения в указанном столбце/ах
      ---------------------------------------------------      

        DB::table('users')->increment('votes');
        DB::table('users')->increment('votes', 5);
        DB::table('users')->decrement('votes');
        DB::table('users')->decrement('votes', 5);

        DB::table('users')->increment('votes', 1, ['name' => 'John']);


    //-------------//
    // 8]  Deletes //
    //-------------//

      Удалить указанные строки из таблицы
      -----------------------------------
        - Из таблицы 'users' удалить все строки, в которых в столбце
          'votes' значение < 100:

            DB::table('users')->where('votes', '<', 100)->delete();

      Удалить все строки из таблицы
      -----------------------------        

          DB::table('users')->delete();

      Операция truncate
      -----------------
        - В отличие от delete, является не транзакционной.
        - В отличие от delete, работает быстрее (удаляет/создаёт таблицу).

          DB::table('users')->truncate();


    //------------//
    // 9]  Unions //
    //------------//

      Создать запрос и сохранить его в $first
      ---------------------------------------
          $first = DB::table('users')->whereNull('first_name');

      Объединить запрос $first и ещё один запрос
      ------------------------------------------
          $users = DB::table('users')->whereNull('last_name')->union($first)->get();


    //--------------------------//
    // 10]  Pessimistic Locking //
    //--------------------------//

      Применение shared lock
      ----------------------
        - Запустить операцию SELECT с "shared lock", то есть указанная
          таблица будет заблокирована на запись во время операции:

            DB::table('users')->where('votes', '>', 100)->sharedLock()->get();

      Применение lock for update
      --------------------------      
        - Запустить операцию SELECT с "lock for update":

            DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();


В3.  Eloquent ORM

  --------------------------------------
  Подоглавление:

    - Что такое ORM
    - Введение в Eloquent ORM

      - Общая информация об Eloquent
      - Модели eloquent
      - Модели и интерфейсы (контракты)
      - Все методы query builder применимы к моделям Eloquent

    - Функционал Eloquent ORM

      1]  Основы Eloquent

        - all()               | извлечь все записи
        - find()              | извлечь запись по первичному ключу
        - findOrFail()        | извлечь запись по ПК, или возбудить исключение
        - foreach collection  | осуществление перебора результатов запроса циклом foreach
        - count()             | подсчёт кол-ва эл-в в результате запроса (агрегирующий функционал)
        - whereRaw()          | применение raw sql в запросе
        - chunk() и foreach   | извлечение и перебор кусками по N штук (для больших объёмов данных)
        - on()                | уточнение соединения, которое будет использовано при запросе
        - onWriteConnection() | заставить применить 'write'-соединение, а не 'read' (актуально, если для них в настройках указаных разные хосты)
        
        - Создание минимального класса-модели Eloquent
        - Образцово-показательный класс-модель

      2]  Ограничения на столбцы при создании новой модели

        - Что такое mass assignment, в чём его опасность
        - Встроенная в Eloquent защита: черный и белый списки
        - Белый список: $fillable
        - Черный список: $guarded
        - Заблокировать все св-ва модели от mass assignment

      3]  Insert, Update, Delete

        - save() [создание]   | создать модель, наполнить, сохранить в БД, получить id новой модели
        - save() [обновление] | извлечь модель по id, изменить, сохранить в БД
        - push()              | аналог save, только сохраняет ещё и связи модели (http://stackoverflow.com/questions/17035682/eloquent-push-and-save-difference)
        - create()            | создать/наполнить/сохранить модель в 1 действие
        - firstOrCreate()     | извлечь модель по атрибутам, а если нет, то создать/наполнить/сохранить
        - firstOrNew()        | извлечь модель по атрибутам, а если нет, то создать/наполнить (но не сохранить)
        - update()            | обновить указ.столбцы указ.образом в указ.выборке строк
        - delete()            | удалить указанную модель (или выборку моделей)
        - destroy()           | удалить указанную модель по ключу (принимает и массив ключей)
        - touch()             | обновить лишь timestamps модели
  
      4]  Мягкое удаление

        - Что такое мягкое удаление (soft delete)
        - Как включить мягкое удаление в модели
        
        - withTrashed()       | в результат должны попадать "мягко удалённые" модели
        - onlyTrashed()       | в результат должны попадать ТОЛЬКО "мягко удалённые" модели
        - restore()           | вынуть "мягко удалённую/ые" модель/модели из "корзины"
        - forceDelete()       | удалить модель из БД (а не положить в корзину, "мягко удалив")
        - trashed()           | определить, лежит ли модель в "корзине" (является ли "мягко-удаленной")

      5]  Временные метки моделей

        - Про временные метки модели created_at / updated_at
        - Как включить/выключить автозаполнение created_at / updated_at
        - Как изменить формат timestamp

      6]  Заготовки запросов (query scopes)

        - Общая информация о заготовках запросов
        - Заготовка запроса без параметров
        - Заготовка запроса с параметрами
        - Использование заготовок запросов

      7]  Глобальные заготовки запросов (global scopes)

        - Общая информация о глобальных заготовках запросов
        - Пошаговая инструкция, как создать глобальную заготовку запроса

      8]  Collections

        - Общая информация о коллекциях моделей Eloquent
        - Кастомизация объекта-коллекции
        
        - contains()              | содержит ли коллекция модель с указанным первичным ключём
        - toArray()               | конвертировать коллекцию в массив
        - toJson()                | конвертировать коллекцию в JSON-строку
        - each()                  | итерация по коллекции
        - filter() и values()     | фильтрация коллекции, сброс ключей
        - sortBy(), sortByDesc()  | сортировка коллекции по столбцу по возрастанию/убыванию

      9]  Accessors & Mutators

        - Общая информация об ассессорах & мутаторах
        - Использование ассессоров
        - Использование мутаторов

      10]  Date Mutators (скорее, Accessors)

        - Общая информация про мутатор дат 
        - Настройка мутатора дат модели

      11]  Автоматическое приведение типов столбцов

        - Суть автоприведения типов столбцов
        - Пример полезного использования
        - Список типов, в которые можно преобразовывать

      12]  События модели, наблюдатель модели

        - Общая информация о событиях модели
        - Список событий модели
        - Отмена операций из обработчиков событий: creating \ updating \ saving \ deleting
        - Обработчики событий можно регистрировать в сервис-провайдере
        - Пример применения событий на благо проекта

        - Класс-наблюдатель модели (точка сбора всех обработчиков модели)

      13]  Преобразование в массив / JSON

        - Модель -> массив
        - Модель -> JSON
        - Возвращаемая модель авто-преобразуется в JSON
        - Исключение столбцов из результата преобразования в массив \ JSON
        - Добавление доп.данных в результаты преобразования в массив \ JSON

      14]  Связи между таблицами

        14.1]  Связи
        ------------
          > Общая информация о связях между таблицами в SQL
          > hasOne()                | связь 1:1 "прямая"

            - Определить прямую 1:1 связь в классе-модели
            - Задать имена столбцов с Foreign Key и Local Key
            - Использовать заданную прямую 1:1 связь

          > belongsTo()             | связь 1:1 "обратная", связь 1:n "обратная"

            - Определить обратную 1:1 связь в классе-модели
            - Задать имена столбцов с Foreign Key и Local Key
            - Использовать заданную обратную 1:1 связь

          > hasMany()               | связь 1:n "прямая"

            - Определить прямую 1:n связь в классе-модели
            - Использовать прямую 1:n связь
            - Определить обратную 1:n связь в классе-модели
            - Использовать обратную 1:n связь

          > hasManyThrough()        | связь 1:n "транзитная" 

            - Определить транзитную 1:n связь в классе-модели
            - Использовать транзитную 1:n связь

          > morphMany()             | связь 1:n, 1:x, 1:y, ... "полиморфная"
          
            - Что такое полиморфная связь?
            - Структура таблиц для организации полиморфной связи
            - Определение полиморфной связи
            - Использование полиморфной связи
            - Получение родителя полиморфной связи по дочке

          > belongsToMany()         | связь n:m

            - Общая информация про m:n связь
            - Определение n:m связи (прямой и обратной)
            - Использование n:m связи
          
          > morphToMany()           | связь n:m, n:x, n:y, ... "полиморфная"


        14.2]  Запросы через связи: advanced where и динамические св-ва
        ---------------------------------------------------------------

          - has()         | при запросе к модели X, установить огран.на связанные с ней значения модели Y
          - whereHas()    | продвинутый has

          - Динамические св-ва (напр.: $phone->user->email)

        14.3]  Устраниние проблемы N+1 методом "жадной загрузки"
        --------------------------------------------------------

          - Суть проблемы N+1
          - with()        | ленивая подгрузка связей при извлечении из модели
          - load()        | ленивая подгрузка связей для УЖЕ извлеченной коллекции данных

        14.4]  Insert в связанные модели через связи
        --------------------------------------------

          - save()        | сделать insert модели через связь
          - saveMany()    | сделать insert массива моделей через связь
          - associate()   | (для belongsTo связей) проставляет FK для дочерней модели (belongsTo)
          - attach()      | (для m:n связей) добавить новую запись в pivot-таблицу через связь
          - detach()      | (для m:n связей) удалить запись из pivot-таблицы через связь
          - sync()        | (для m:n связей) оставляет в pivot-таблице только связи с указанными id

        14.5]  Обновление updated_at родит.модели при обновлении дочерней
        -----------------------------------------------------------------

          - Свойство модели $touches

        14.6]  Работа с промежуточными таблицами (при связи n:m)
        --------------------------------------------------------

          - Динамическое свойство pivot
          - withPivot()             | что будет содержать объект в св-ве pivot
          - withTimestamps()        | включить авто-поддержку столбцов created_at/updated_at в pivot-таблице
          - detach()                | удалить запись из pivot-таблицы
          - updateExistingPivot()   | изменить существующую запись в pivot-таблице (без удаления)
          - Создание своей, кастомной pivot-таблицы [по требованию]


  --------------------------------------

  > Что такое ORM

      > Проблема
        - Объектно-ориентированная программа использует в работе объекты.
        - Для сохранения состояния приложения эти объекты надо хранить в БД.
        - Структура БД для каждого объекта своя.
        - При сохранении приложения каждый раз приходится конвертировать объекты
          в формат, требуемый БД, и сохранять их.
        - При загрузке приложения каждый раз приходится извлекать данные из
          БД и формировать из них объекты.
        - Делать каждый раз всё это напряжно.

      > Решение
        - Использовать технологию ORM.
        - ORM позволяет автоматизировать вышеописанные задачи.
        - Это позволяет вообще абстрагироваться от способа хранения объектов в БД.
        - ORM - Object-Relational Mapping - Объектно-Реляционное Проекцирование.
        - ORM фактически создаёт двустороннюю проекцию между ООП-моделью и БД,
          отсюда и название: объектно-реляционное проецирование.
        - Двусторонняя проекция означает - изменения в ООП-модели приводит к
          автоматич. изменениям в БД в соотв. с системой связей. И наоборот.
        - При работе с ООП-моделью изменения в БД ORM вносит автоматом.
        - По сути своей ORM является реализацией шаблона проектирования
          приложений ActiveRecord.

      > Об ActiveRecord (AR)

        > Введение
          - Это шаблон проектирования приложений.
          - Был описан Мартином Фаулером в книге "Patterns of Enterprise Application Architecture".
          - Является самым популярным способом доступа к данным реляционных баз данных
            в объектно-ориентированном программировании.

        > Общие принципы работы
          - Пусть существует таблица в БД.
          - Для данной таблицы создаётся специальный AR-класс.
          - Таблица и AR-класс являются двусторонней проекцией.
          - Каждый объект-экземпляр AR-класса представляет одну строку таблицы.
          - При создании нового экземпляра в таблицу добавляется новая строка.
          - При чтении полей объекта считываются соотв.связям значения из строки БД.
          - При изменении/удалении экземпляра, изменяется/удаляется соотв.связям строка в БД.


  > Введение в Eloquent ORM
    
    Общая информация об Eloquent
    ----------------------------
      - Eloquent ORM поставляется в комплекте с Laravel.
      - Eloquent в переводе на русский язык означает "Красноречивый".
      - Представляет собой простую реализацию шаблона пректирования ActiveRecord.
      - Как и описано выше, Eloquent ORM - это ресурс для организации двусторонней
        проекции между таблицей в БД и ООП-моделью в приложении.
      - Перед началом работы с Eloquent ORM следует убедиться, что соединение
        с БД настроено и работает, сделать этом можно в файле "config/database.php".
    
    Модели eloquent
    ---------------
      - Каждая модель в Laravel представлена отдельный .php файлом.
      - Файл-модель содержит 1 класс, наследующий от класса
          Illuminate\Database\Eloquent\Model
      - В Laravel модели по умолчанию хранятся в папке 'app'.
      - Но их можно положить куда угодно, где они м.б. автоподгружены композером.

    Модели и интерфейсы (контракты)
    -------------------------------
      - Желательно, чтобы модель реализовывала интерфейс.
      - Это позволяет убрать жёсткую связь между контроллером и моделью.
      - В случае изменений в модели, не придётся менять код в контроллере.

    Все методы query builder применимы к моделям Eloquent
    -----------------------------------------------------
      - Сабж.

  > Функционал Eloquent ORM

    //---------------------//
    // 1]  Основы Eloquent //
    //---------------------//

      // all()
      //----------------------------------------//
      // - извлечь все записи

        $users = User::all();

      // find()
      //----------------------------------------//
      // - извлечь запись по первичному ключу
        
        $user = User::find(1);

      // findOrFail()
      //----------------------------------------//
      // - извлечь запись по ПК, или возбудить исключение

        - Пример:

          $model = User::findOrFail(1);
          $model = User::where('votes', '>', 100)->firstOrFail();

        - Это позволит ловить соответствующие исключения.
        - Для этого надо добавить соотв.логику в app/Exceptions/Handler.php
        - Ниже показано, как в него добавлена обработка исключения ModelNotFoundException:

              use Illuminate\Database\Eloquent\ModelNotFoundException;

              class Handler extends ExceptionHandler {

                  public function render($request, Exception $e)
                  {
                      if ($e instanceof ModelNotFoundException)
                      {
                          // Custom logic for model not found...
                      }

                      return parent::render($request, $e);
                  }

              }          

      // foreach collection
      //----------------------------------------//
      // - осуществление перебора результатов запроса циклом foreach

          $users = User::where('votes', '>', 100)->take(10)->get();

          foreach ($users as $user)
          {
              var_dump($user->name);
          }

      // count()
      //----------------------------------------//
      // - подсчёт кол-ва эл-в в результате запроса (агрегирующий функционал)

        $count = User::where('votes', '>', 100)->count();

      // whereRaw
      //----------------------------------------//
      // - применение raw sql в запросе

        $users = User::whereRaw('age > ? and votes = 100', [25])->get();

      // chunk() и foreach
      //----------------------------------------//
      // - извлечение и перебор кусками по N штук (для больших объёмов данных)
      
        User::chunk(200, function($users)
        {
            foreach ($users as $user)
            {
                //
            }
        });

      // on()
      //----------------------------------------//
      // - уточнение соединения, которое будет использовано при запросе

        $user = User::on('connection-name')->find(1);

      // onWriteConnection()
      //----------------------------------------//
      // - заставить применить 'write'-соединение, а не 'read' (актуально, если для них в настройках указаных разные хосты)

        $user = User::onWriteConnection()->find(1);

      Создание минимального класса-модели Eloquent
      --------------------------------------------
        
        # Минимальный класс-модель выглядит так

          <?php namespace App;
            use Illuminate\Database\Eloquent\Model;
            class Some extends Model {

              //

            }  
          ?>

        # Создать его в app/ можно командой artisan:

          php artisan make:model [имя модели]


      Образцово-показательный класс-модель
      ------------------------------------

        <?php 

          //------------//
          // Оглавление //
          //------------//
          // 
          //  А. Указать пространство имён
          //  Б. Импортировать необходимые классы
          //  В. Класс-модель
          //  
          //    В1. Импорт классов в модель
          //    В2. Настройки модели
          //    
          //      В2.1. Использовать или нет мягкое удаление
          //      В2.2. Имя соединения с БД
          //      В2.3. Имя таблицы, которую использует модель
          //      В2.4. Имя столбца с первичным ключём
          //      В2.5. Настройка втоинкремента столбца с первичным ключём
          //      В2.6. Автообслуживание столбцов created_at / updated_at
          //      В2.7. Настроить "мягкое удаление"
          //      В2.8. Настроить "белый список" mass assignment
          //      В2.9. Настроить "черный список" mass assignment
          //      В2.10. Настроить автоприведение типов
          //      В2.11. Настроить список $hidden (исключ.столбцов из результата при преобразовании в массив/json)
          //      В2.12. Настроить список $visible (только столбцы из списка будут в преобразовании в массив/json)
          //      В2.13. Настроить список $appends (список столбцов, которые добавляются к результату при преобразовании модели в массив/json)
          //    
          //    В3. Заготовки запросов модели (scopes)
          //    
          //      В3.1. ...
          //    
          //    В4. Связи модели
          //    
          //      В4.1. ...
          //    
          //    В5. Ассессоры
          //    В6. Мутаторы
          // 
          //---------------------------------------------//

          //------------------------------//
          // А. Указать пространство имён //
          //------------------------------//
          // - А что, если модель в app/Domain/Models
          // - Тогда: namespace App\Domain\Models
          namespace App;

          //-------------------------------------//
          // Б. Импортировать необходимые классы //
          //-------------------------------------//

            // Собственно, сам eloquent
            use Illuminate\Database\Eloquent\Model;
            
            // Реализация мягкого удаления
            use Illuminate\Database\Eloquent\SoftDeletes;

            // Контракт модели (!!! заменить на актуальный !!!)
            use Illuminate\Contracts\ModelInterface;

          //-----------------//
          // В. Класс-модель //
          //-----------------//
          class User extends Model implements ModelInterface {

            //-----------------------------//
            // В1. Импорт классов в модель //
            //-----------------------------//            
            
              // Интерфейс модели
              use ModelInterface;

              // Использовать или нет мягкое удаление
              // use SoftDeletes;
              // protected $dates = ['deleted_at'];

            //----------------------//
            // В2. Настройки модели //
            //----------------------//

              // В2.1. Использовать или нет мягкое удаление // 
              //--------------------------------------------//
              // use SoftDeletes;
              // protected $dates = ['deleted_at'];

              // В2.2. Имя соединения с БД //
              //---------------------------//
              // - По умолчанию, указанное в 'default' в config/database.php
              // protected $connection = '';

              // В2.3. Имя таблицы, которую использует модель //
              //----------------------------------------------//
              // - По умолчанию, имя класса модели с 's' на конце
              // protected $table = '';

              // В2.4. Имя столбца с первичным ключём //
              //--------------------------------------//
              // - По умолчанию 'id'
              // $primaryKey = '';    

              // В2.5. Настройка втоинкремента столбца с первичным ключём //
              //----------------------------------------------------------//
              // - По умолчанию включено. Включено: true, выключено: false. 
              // - В Eloquent, по умолчанию, для столбца с первичным ключём, включён авто-инкремент.
              // $incrementing = false;    

              // В2.6. Автообслуживание столбцов created_at / updated_at //
              //---------------------------------------------------------//
              // - По умолчанию включено. Включено: true, выключено: false. 
              // - Если true, laravel будет автоматич.обновл. значения timestamp в этих столбцах.
              public $timestamps = false;

              // В2.7. Настроить "мягкое удаление" //
              //-----------------------------------//
              // - По умолчанию выключено. 
              // - Если вкл., то eloquent-команда delete() на самом деле не будет удалять строку из таблицы.
              //   - Вместо этого в её столбце "deleted_at" значение null будет заменено на текущий timestamp.
              //   - На самом же деле удалить строку в этом случае можно eloquent-командой forceDelete().
              // - Если выкл., то eloquent-команда delete() на самом деле будет удалять строку.
              // protected $dates = ['deleted_at'];

              // В2.8. Настроить "белый список" mass assignment //
              //------------------------------------------------//
              // protected $fillable = ['id', 'password'];

              // В2.9. Настроить "черный список" mass assignment //
              //-------------------------------------------------//
              // protected $guarded = ['id', 'password'];
              // protected $guarded = ['*'];
              
              // В2.10. Настроить автоприведение типов //
              //---------------------------------------//
              // protected $casts = [
              //     'options' => 'array',
              // ];                 

              // В2.11. Настроить список $hidden //
              //---------------------------------//
              // - Эта настройка срабатывает при преобразовании модели в массив \ JSON.
              // - Указанные в списке столбцы будут исключены из результатов преобразования.
              
              // protected $hidden = ['password'];                

              // В2.12. Настроить список $visible //
              //---------------------------------//
              // - Эта настройка срабатывает при преобразовании модели в массив \ JSON.
              // - Только указанные в списке столбцы будут присутствовать в результатах преобразования.
              
              // protected $visible = ['first_name', 'last_name'];

              // В2.13. Настроить список $appends //
              //---------------------------------//
              // - Эта настройка срабатывает при преобразовании модели в массив \ JSON.
              // - Указанные в списке столбцы будут добавлены к результатам преобразования.
              // - Какие именно значения будут добавлены, указывается в соотв. ассессорах.
              
              // protected $appends = ['is_admin'];


            //----------------------------------------//
            // В3. Заготовки запросов модели (scopes) //
            //----------------------------------------//          
            // - Как использовать (пример): 
            //     User::name1()->name2()->get();


              // В3.1.  //
              //---------------------------------------// 
              
              // public function scopeName1($query, $param1, $param2) {
              // 
              //     return $query->where('votes', '>', 100);
              // 
              // }  


              // В3.2.  //
              //---------------------------------------// 
              
              // public function scopeName2($query, $param1, $param2) {
              // 
              //     return $query->where('gender', '=', 'W');
              // 
              // }  
   

            //------------------//
            // В4. Связи модели //
            //------------------// 

              // В4.1.  //
              //---------------------------------------// 
              // public function user()
              // {
              //    return $this->belongsTo('App\User');
              // }

              // В4.2.  //
              //---------------------------------------// 
              // public function user()
              // {
              //    return $this->belongsTo('App\User', 'local_key');
              // }    


            //---------------//
            // В5. Ассессоры //
            //---------------//
            //| Настраиваем ассессоры модели
            //|
            //| - Аксессор позволяет при получении объекта модели "слегка обработать"
            //|   данные из указанных столбцов - т.е. вносить в них указанные изменения.
            //|   Вообще, это напоминает фильтр.
            //|
            //| - Разберём, из чего состоит имя аксессора в примере ниже:
            //|
            //|     get           | обозначает, что это аксессор
            //|     Name          | обозначает имя столбца, для которого предназначен этот аксессор
            //|     Attribute     | это просто техническая часть функции-аксессора, она всегда неизменна
            //|
            //| - Что делать, если имя столбца в стиле snake_case?
            //|   - Писать его всё равно в CamelCase.
            //|   - Например, если имя столбца id_user, то имя функции-аксессора будет: getIdUserAttribute
            //|          

              // В5.1. Мутатор дат //
              //-------------------// 
              // public function getDates()
              // {
              //     return ['created_at', 'updated_at'];
              // }

              // В5.2. Пример ассесора //
              //-----------------------// 
              // - Допустим, у нас в столбце "user_name" лежит значение "иван".
              // - А мы хотим при получении данного объекта, чтобы "иван" было с большой буквы.
              // - Тогда добавляем в модель вот такой аксессор:            
              
              // public function getUserNameAttribute($value) {
              // 
              //     return ucfirst($value);
              // 
              // } 


            //--------------//
            // В6. Мутаторы //
            //--------------//
            //| Настраиваем мутаторы модели
            //|
            //| - Мутатор позволяет при записи в модель "слегка обработать" записываемое
            //|   значение - т.е. внести в него указанные изменения.
            //|   Вообще, это напоминает фильтр.
            //|
            //| - Разберём, из чего состоит имя мутатора в примере ниже:
            //|
            //|    set           | обозначает, что это аксессор
            //|    Name          | обозначает имя столбца, для которого предназначен этот аксессор
            //|    Attribute     | это просто техническая часть функции-аксессора, она всегда неизменна
            //|
            //| - Что делать, если имя столбца в стиле snake_case?
            //|   - Писать его всё равно в CamelCase.
            //|   - Например, если имя столбца id_user, то имя функции-аксессора будет: getIdUserAttribute
            //|          

              // В6.1. Пример мутатора  //
              //------------------------// 
              // - Допустим, у нас есть столбец "user_name", в котором должно лежать имя пользователя.
              // - А мы хотим при записи значений в этот, чтобы оно автоматом записывалось в стиле ucfirst.
              // - Тогда добавляем в модель вот такой мутатор:           
              
              // public function setUserNameAttribute($value) {
              // 
              //     $this->attributes['user_name'] = ucfirst($value);
              // 
              // }

          } // конец класса-модели
        ?>


    //------------------------------------------------------//
    // 2]  Ограничения на столбцы при создании новой модели //
    //------------------------------------------------------//

      Что такое mass assignment, в чём его опасность
      ----------------------------------------------
        - При создании экземпляра модели конструктору передаётся массив параметров.
        - Из этих параметров конструктор собирает экземпляр и возвращает его.
        - Допустим, массив параметров формируется из полей формы пользователем.
        - Здесь скрыта серьёзная проблема безопасности приложения.
        - Хакер может вручную послать POST-запрос с массивом, который содержит
          даже те параметры, которых не было в форме. Например: isAdmin == true.
        - Чтобы обезопаситься, на сервере нужно иметь 2 списка - белый/чёрный -
          параметров, значения которых разрешено/запрещено принимать от пользователя.      

      Встроенная в Eloquent защита: черный и белый списки
      ---------------------------------------------------
        - При создании нового экземпляра модели её конструктору передаётся
          массив атрибутов.
        - Св-ва модели заселяются значениями атрибутов из этого массива
          методом 'mass assignment'.
        - В Eloquent предусмотрены 2 списка - белый (fillable) и чёрный
          (guarded). В этих списках можно явно указать имена св-в модели,
          которые могут/не могут быть заселены методом 'mass assignment'.
        - В Eloquent по умолчанию все св-ва находятся в guarded-списке.
        - Поэтому разработчик должен явно указать в fillable-списк те
          свойства модели, которые он собирается заселять методом 'mass assignment'.

      Белый список: $fillable
      -----------------------
        - Для определения белого списка, требуется в классе-модели определить
          св-во $fillable, и присвоить ему массив строк, каждая из которых
          обозначает имя св-ва модели, которое может быть инициировано
          методом 'mass assignment'.
        - Если $fillable и $guarded опущены, то т.к. в Eloquent все св-ва
          модели неявно находятся в guarded-списке, ни одно св-во модели не
          доступно для 'mass assignment'.
        - Если $fillable присутствует, а $guarded опущено, то для 'mass assignment'
          доступны только свойства, указанные в $fillable. А все остальные - не доступны.
        - Пример определения $fillable. В этой модели св-ва 'first_name', 'last_name', 'email'
          будут доступны для 'mass assignment', а все остальные - не доступны.

            <?php namespace App;
              use Illuminate\Database\Eloquent\Model;
              class Some extends Model {

                protected $fillable = array('first_name', 'last_name', 'email');

              }  
            ?>

      Черный список: $guarded
      -----------------------
        - В Eloquent все св-ва модели неявно находятся в guarded-списке.
        - Для явного определения чёрного списка, требуется в классе-модели
          определить св-во $guraded, и присвоить ему массив строк, каждая из которых
          обозначает имя св-ва модели, которое НЕ может быть инициировано
          методом 'mass assignment'.
        - Если $fillable и $guarded опущены, то т.к. в Eloquent все св-ва
          модели неявно находятся в guarded-списке, ни одно св-во модели не
          доступно для 'mass assignment'.
        - Если $guarded присутствует, а $fullable опущен, то для 'mass assignment'
          не доступны только свойства, указанные в $guarded. А все остальные
          доступны.
        - Пример определения $guarded. В этой модели св-ва 'id' и 'password'
          будут не доступны для 'mass assignment', а все остальные св-ва
          модели будут доступны:

            <?php namespace App;
              use Illuminate\Database\Eloquent\Model;
              class Some extends Model {

                protected $guarded = array('id', 'password');

              }  
            ?>

      Заблокировать все св-ва модели от mass assignment
      -------------------------------------------------
        - Особой нужны в этом выражении нет. Оно применено по умолчанию
        - И все столбцы и так по умолчанию заблокированы от mass assignment.

            <?php namespace App;
              use Illuminate\Database\Eloquent\Model;
              class Some extends Model {

                protected $guarded = ['*'];

              }  
            ?>


    //----------------------------//
    // 3]  Insert, Update, Delete //
    //----------------------------//

      // save() [создание]
      //----------------------------------------//
      // - создать модель, наполнить, сохранить в БД, получить id новой модели

        // Создать новый объект-экземпляр модели User
          $user = new User;

        // Инициализировать св-во 'name' в созданном объекте:
          $user->name = 'John';

        // Сохранить созданный экземпляр в таблице БД:
          $user->save();

        // Получить ID новой модели
          $id = $user->id;

      // save() [обновление]
      //----------------------------------------//
      // - извлечь модель по id, изменить, сохранить в БД

        // Получить экземпляр модели, представляющий нужную строку таблицы БД
          $user = User::find(1);

        // Внести нужные изменения
          $user->email = 'john@foo.com';

        // Сохранить этот экземпляр обратно в БД
          $user->save();
       
      // push()
      //----------------------------------------//
      // - аналог save, только сохраняет ещё и связи модели
      // - подробнее про push: http://stackoverflow.com/questions/17035682/eloquent-push-and-save-difference

        $user->push();

      // create()
      //----------------------------------------//
      // - создать/наполнить/сохранить модель в 1 действие
      // - только надо учитывать черный/белый листы mass assignment

        // создать/наполнить/сохранить модель в 1 действие
        $user = User::create(['name' => 'John']);

      // firstOrCreate()
      //----------------------------------------//
      // - извлечь модель по атрибутам, а если нет, то создать/наполнить/сохранить
      // - только надо учитывать черный/белый листы mass assignment

        $user = User::firstOrCreate(['name' => 'John']);

      // firstOrNew()
      //----------------------------------------//
      // - извлечь модель по атрибутам, а если нет, то создать/наполнить (но не сохранить)
      // - только надо учитывать черный/белый листы mass assignment
      // - !!! чтобы сохранить модель, созданную методом firstOrNew(), в БД, надо ещё сделать save()

        $user = User::firstOrNew(['name' => 'John'])

      // update()
      //----------------------------------------//
      // - обновить указ.столбцы указ.образом в указ.выборке строк
      // - !!! при этом события модели не возбуждаются !!!

        $affectedRows = User::where('votes', '>', 100)->update(['status' => 2]);

      // delete()
      //----------------------------------------//
      // - удалить указанную модель (или выборку моделей)
     
        // Найти и удалить модель с ключём 1
        $user = User::find(1);
        $user->delete();

        // Удалить целую выборку моделей
        $affectedRows = User::where('votes', '>', 100)->delete();

      // destroy()
      //----------------------------------------//
      // - удалить указанную модель по ключу (принимает и массив ключей)

        User::destroy(1);
        User::destroy([1, 2, 3]);
        User::destroy(1, 2, 3);

      // touch()
      //----------------------------------------//
      // - обновить лишь timestamps модели

        $user = User::find(1);
        $user->touch();


    //---------------------//
    // 4]  Мягкое удаление //
    //---------------------//

      Что такое мягкое удаление (soft delete)
      ---------------------------------------
        - Soft delete отличается от обычного delete тем, что строка не
          удаляется из таблицы БД.
        - Вместо этого ей в столбец 'deleted_at' добавляется timestamp.
        - Если у модели включён 'soft delete', то метод delete() не будет
          больше как раньше удалять соотв.строки из таблицы, а будет
          добавлять timestamp в столбец 'deleted_at'.
        - При запросе у модели экземпляров, 'soft deleted' экземпляры в
          результат попадать не будут.
        - А чтобы они всё-таки попадали в результат, нужно использовать
          метод withTrashed()
        - А чтобы в результате были ТОЛЬКО 'soft deleted' экземпляры,
          можно применить метод onlyTrashed()
        - Подробнее функционал описан ниже.

      Как включить мягкое удаление в модели
      -------------------------------------

          use Illuminate\Database\Eloquent\SoftDeletes;
          class User extends Model {

              use SoftDeletes;
              protected $dates = ['deleted_at'];

          }

      // withTrashed()
      //----------------------------------------//
      // - в результат должны попадать "мягко удалённые" модели

        $users = User::withTrashed()->where('account_id', 1)->get();

      // onlyTrashed()
      //----------------------------------------//
      // - в результат должны попадать ТОЛЬКО "мягко удалённые" модели

        $users = User::onlyTrashed()->where('account_id', 1)->get();

      // restore()
      //----------------------------------------//
      // - вынуть "мягко удалённую/ые" модель/модели из "корзины"

        // Вынуть 1 модель
        $user->restore();

        // Вынуть сразу пачку моделей
        User::withTrashed()->where('account_id', 1)->restore();

      // forceDelete()
      //----------------------------------------//
      // - удалить модель из БД (а не положить в корзину, "мягко удалив")

        $user = User::find(1);
        $user->forceDelete();

      // trashed()
      //----------------------------------------//
      // - определить, лежит ли модель в "корзине" (является ли "мягко-удаленной")

        $user = User::find(1);
        if ($user->trashed())
        {
            //
        }


    //-----------------------------//
    // 5]  Временные метки моделей //
    //-----------------------------//

      Про временные метки модели created_at / updated_at
      --------------------------------------------------
        - По умолчанию в классе-модели неявно $timestamps == true
        - Это значит, что Eloquent автоматически создаёт и обслуживает в таблице
          колонки 'created_at' и 'updated_at.
        - В колонке 'created_at' Eloquent помещает timestamp создания строки таблицы.
        - В колонке 'updated_at' Eloquent помещает timestamp последнего изменения строки таблицы.
        - Если функционал включён, Eloquent добавляет значения в эти столбцы автоматом.
        - Если таких колонок в таблице нет, то надо их добавить вручную.

      Как включить/выключить автозаполнение created_at / updated_at
      -------------------------------------------------------------

        - По умолчанию функционал ведения колонок с timestamp включён,
          т.е. в классе-модели $timestamps == true.
        - Чтобы отключить этот функционал, нужно сделать $timestamps == false.
        - Пример:

              class User extends Eloquent {

                protected $timestamps = false;

              }

      Как изменить формат timestamp
      -----------------------------
        - С помощью функции getDateFormat()
        - Пример:

            public function getDateFormat() {

              return 'Y-m-d H:i:s';

            }


    //---------------------------------------//
    // 6]  Заготовки запросов (query scopes) //
    //---------------------------------------//

      Общая информация о заготовках запросов
      --------------------------------------
        - 99% всех запросов к модели требуется использовать в >= 2 местах кода.
        - Так зачем каждый раз, снова и снова, "изобретать велосипед?"
        - Лучше создать в модели соответствующие заготовки запросов.
        - И каждый раз, когда требуется соотв.запрос, использовать соотв.заготовку.
        - Заготовка запроса, это просто метод модели; он осуществляет запрос, и возвращает результат.
        - Он может также принимать параметры при вызове, которые могут влиять на результат.
        - У имени этого метода ДОЛЖЕН быть префикс 'scope'. Например: scopePopular().
        - При вызове метода, к нему надо обращаться уже БЕЗ ПРЕФИКСА.

      Заготовка запроса без параметров
      --------------------------------
      - В контексте класса-модели:

        public function scopePopular($query)
        {
            return $query->where('votes', '>', 100);
        }

      Заготовка запроса с параметрами
      -------------------------------
      - В контексте класса-модели:

        public function scopeSex($query, $sex)
        {
            return $query->where('sex', '=', $sex);
        }

      Использование заготовок запросов
      --------------------------------
      - Использование одновременно 2-х заготовок запросов:

        $users = User::popular()->sex('M')->get();
   

    //---------------------------------------------------//
    // 7]  Глобальные заготовки запросов (global scopes) //
    //---------------------------------------------------//

      Общая информация о глобальных заготовках запросов
      -------------------------------------------------
        - Бывает, заготовку требуется применять почти ко всем запросам.
        - И каждый раз приходится в запросе применять данную заготовку.
        - Но легче было бы, чтобы она автоматически применялась ко всем запросам.
        - А там, где её не надо применять, можно было бы вручную указывать.
        - Именно это и позволяют делать глобальные заготовки запросов.

      Пошаговая инструкция, как создать глобальную заготовку запроса
      --------------------------------------------------------------

        1. Создать трейт
          - Можно создать собственный трейт.
          - В нём должна быть функция, имя которой соотв.шаблону:

              boot[имя трейта]

          - Можно использовать готовый трейт по адресу:
              \vendor\laravel\framework\src\Illuminate\Database\Eloquent\SoftDeletes.php
          - В этом трейте есть такая функция:

              public static function bootSoftDeletes() {

                  static::addGlobalScope(new SoftDeletingScope);

              }
        
        2. Подключить трейт к модели
          - Подключить трейт к модели можно как обычно.
          - Используя ключевое слово use:

              use bootSoftDeletes;

          - Теперь, при загрузке модели, метод bootSoftDeletes будет выполнен.
          - В нём и можно зарегистрировать глобальную заготовку запроса.

        3. Подготовить класс с заготовленным глобальным запросом
          - Он должен реализовывать интерфейс ScopeInterface.
          - И, соответственно, содержать 2 метода: apply и remove.
          - Содержимое apply будет автоматом исполняться при загрузке модели.
          - А метод remove можно применить к запросу вручную, чтобы как бы сказать:
            "не надо применять к данному запросу глобальную заготовку"
          - Примеры методов apply и remove:

              public function apply(Builder $builder, Model $model)
              {
                  $builder->whereNull($model->getQualifiedDeletedAtColumn());

                  $this->extend($builder);
              }

              public function remove(Builder $builder, Model $model)
              {
                  $column = $model->getQualifiedDeletedAtColumn();

                  $query = $builder->getQuery();

                  foreach ((array) $query->wheres as $key => $where)
                  {
                      // If the where clause is a soft delete date constraint, we will remove it from
                      // the query and reset the keys on the wheres. This allows this developer to
                      // include deleted model in a relationship result set that is lazy loaded.
                      if ($this->isSoftDeleteConstraint($where, $column))
                      {
                          unset($query->wheres[$key]);

                          $query->wheres = array_values($query->wheres);
                      }
                  }
              }


    //-----------------//
    // 8]  Collections //
    //-----------------//

      Общая информация о коллекциях моделей Eloquent
      ----------------------------------------------
        - В ответ на запрос к модели Eloquent мы получаем результат.
        - Этот результат может содержать лишь 1 модель:

            $user = Users::find(1);                     // 1 модель

        - А может содержать и набор моделей:

            $users = Users::where('age','>',10)->get(); // набор моделей

        - Так вот, этот результат-набор является объектом класса Collection.
        - Поэтому говорят: "извлечь коллекцию результатов".
        - Класс Collection также содержит некоторые полезные методы для работы.
        - Collection реализует интерфейс IteratorAggregate, поэтому с коллекцией
          можно работать, как с массивом.

      Кастомизация объекта-коллекции
      ------------------------------
        - Для конкретной модели можно кастомизировать объект-коллекцию.
        - Сделать так, что при запросе, она будет возвращать его, а не стандартный.
        - В модернизированном объекте-коллекции могут быть доп.методы и т.д.
        - Для этого в модели можно определить метод newCollection.
        - И в этом методе вернуть, собственно, объект модернизированного класса-коллекции.
        - Например:

            class User extends Model {

                public function newCollection(array $models = [])
                {
                    return new CustomCollection($models);
                }

            }        



      // contains()
      //----------------------------------------//
      // - содержит ли коллекция модель с указанным первичным ключём

        $roles = User::find(1)->roles;
        if ($roles->contains(2))
        {
            //
        }

      // toArray()
      //----------------------------------------//
      // - конвертировать коллекцию в массив

        $roles = User::find(1)->roles->toArray();

      // toJson()
      //----------------------------------------//
      // - конвертировать коллекцию в JSON-строку
      // - при приведении коллекции к строке, будет возвращена JSON-строка

        $roles = User::find(1)->roles->toJson();  // json-строка         
        $roles = (string) User::find(1)->roles;   // json-строка

      // each()
      //----------------------------------------//
      // - итерация по коллекции

        $roles = User::find(1)->roles;
        $roles->each(function($role)
        {
            //
        });        

      // filter() и values()
      //----------------------------------------//
      // - фильтрация коллекции, сброс ключей

        // Фильтровать
        $users = $users->filter(function($user)
        {
            return $user->isAdmin();
        });

        // Сбросить ключи
        $users->values();

        // Привести к json
        $users_json = $users->toJson();

      // sortBy(), sortByDesc()
      //----------------------------------------//
      // - сортировка коллекции по столбцу по возрастанию/убыванию

        // По возрастанию
        $roles = $roles->sortBy('created_at');
        $roles = $roles->sortBy(function($role)
        {
            return $role->created_at;
        });

        // По убыванию
        $roles = $roles->sortByDesc('created_at');
        $roles = $roles->sortByDesc(function($role)
        {
            return $role->created_at;
        });


    //--------------------------//
    // 9]  Accessors & Mutators //
    //--------------------------//

      Общая информация об ассессорах & мутаторах
      ------------------------------------------
        - При работе с моделью, мы извлекаем и назначаем значения столбцов.
        - Иногда при этом для некоторых столбцов требуется производить одну и ту же работу.
        - Скажем, при извлечении имени, делать большой его первую букву, о остальные маленькими.
        - И проводить аналогичную работу при назначения значения для имени.
        - Именно такими вещами и могут заниматься ассессоры и мутаторы, в атоматическом режиме.

      Использование ассессоров
      ------------------------
        - Допустим, у нас есть eloquent-модель Users.
        - А в ней есть столбец 'first_name'.
        - И нам надо каждый раз при извлечении:
          - Делать большой его первую букву, о остальные маленькими.
        - Причём, мы хотим, чтобы это присходило автоматически.
        - Для этого мы создаём в модели такой метод-ассессор:

            public function getFirstNameAttribute($value)
            {
                return ucfirst($value);
            }

      Использование мутаторов
      -----------------------
        - Допустим, у нас есть eloquent-модель Users.
        - А в ней есть столбец 'first_name'.
        - И нам надо каждый раз при изменении его значения:
          - Делать большой его первую букву, о остальные маленькими.
        - Причём, мы хотим, чтобы это присходило автоматически.
        - Для этого мы создаём в модели такой метод-ассессор:

            public function setFirstNameAttribute($value)
            {
                $this->attributes['first_name'] = strtolower($value);
            }


    //----------------------------------------//
    // 10]  Date Mutators (скорее, Accessors) //
    //----------------------------------------//

      Общая информация про мутатор дат 
      --------------------------------
        - Ранее уже упомянались столбцы created_at / updated_at.
        - Их Eloquent может обслуживать автоматически, если так настроена модель.
        - Эти столбцы, как нетрудно догадаться, имеют тип datetime.
        - В обычных условиях, при извлечении мы бы получали объект PHP-класса DateTime.
        - Но Eloquent, по умолчанию, возвращает объект класса Carbon.
        - Последний дополняет DateTime новым, полезным функционалом.
        - Но что, если мы хотим объекты Carbon и при извлечении из других столбцов?
        - Это можно устроить, перезаписав метод getDates модели.
        - P.S. Мутатор дат скорее стоило назвать ассессором дат.

      Настройка мутатора дат модели
      -----------------------------
        - Для этого надо перезаписать метод getDates() модели.
        - По умолчанию (неявно), он выглядит так:

            public function getDates()
            {
                return ['created_at', 'updated_at'];
            }

        - Но мы можем его изменить, добавив/убрав компоненты:

            public function getDates()
            {
                return ['created_at'];
            } 

            public function getDates()
            {
                return ['created_at', 'updated_at', 'my_datetime_column'];
            }   

        - Полностью отключить мутатор дат можно, оставив массив пустым:

            public function getDates()
            {
                return [];
            }        


    //-----------------------------------------------//
    // 11]  Автоматическое приведение типов столбцов //
    //-----------------------------------------------//

      Суть автоприведения типов столбцов
      ----------------------------------
        - Допустим, есть у нас некая таблица со столбцами.
        - Каждый столбец, разумеется, содержит данные определённого типа.
        - И допустим, есть >= 1 столбцов, при извлечении из которых нужен другой тип.
        - Например, лежит там строка, а нужен булев тип.
        - Тут 3 варианта:

            1) Приводить каждый раз в ручную.
            2) Написать ассессор, который будет приводить.
            3) Использовать автоприведение типов.

        - Автоприведение типов настраивается в свойстве $casts модели.

      Пример полезного использования
      ------------------------------
        - Допустим, есть столбец 'options', в котором лежит JSON-строка.
        - Каждый раз при её извлечении, нам надо преобразовывать её в массив.
        - В этом случае, можно применить автоприведение типов.
        - Вот, как это делается:

            protected $casts = [
                'options' => 'array',
            ];        

      Список типов, в которые можно преобразовывать
      ---------------------------------------------

        - integer
        - real
        - float
        - double 
        - string 
        - boolean 
        - object 
        - array.


    //-----------------------------------------//
    // 12]  События модели, наблюдатель модели //
    //-----------------------------------------//

      Общая информация о событиях модели
      ----------------------------------
        - Модели в Eloquent могут генерировать ряд событий.
        - Этим событиям можно назначать функции-обработчики.
        - В последних можно выполнять любую желаемую логику.

      Список событий модели
      ---------------------

        - creating    | перед созданием новой модели
        - created     | после создания новой модели

        - updating    | перед обновлением модели
        - updated     | после обновления модели

        - saving      | перед сохранением модели (возбуждается также при creating\created и updating\updated)
        - saved       | после сохранения модели (возбуждается также при creating\created и updating\updated)

        - deleting    | перед удалением модели
        - deleted     | после удаления модели

        - restoring   | перед восстановлением модели
        - restored    | после восстановления моделия

      Отмена операций из обработчиков событий: creating \ updating \ saving \ deleting
      --------------------------------------------------------------------------------
        - Если вернуть false из обработчика, можно отменить действие по умолчанию.
        - Например, добавим такой обработчик в модель:

            User::creating(function($user)
            {
                if ( ! $user->isValid()) return false;
            }); 
            
        - Он срабатывает перед созданием новой модели.
        - Если аргумент в if == false, то обработчик вернёт false.       
        - В результате чего новая модель создана не будет.

      Обработчики событий можно регистрировать в сервис-провайдере
      ------------------------------------------------------------
        - В L5 для этого предусмотрен сервис-провайдер app/Providers/EventServiceProvider.php
        - В документации рекомендуют регистрировать обработчики в его методе boot.
        - Но вообще, это можно делать в любом сервис-провайдере.

      Пример применения событий на благо проекта
      ------------------------------------------
        - Допустим, в БД есть таблицы users, groups и privileges.
        - В users есть столбцы groups и privileges.
        - Они содержат строки вида: '1,3,5'.
        - Которые обозначают, в каких группах состоит, какими правами обладает (перечисление соотв. id).
        - А в groups есть также аналогичный столбец privileges.
        - Получается, при удалении строки из privileges, надо:
          1) Проверить всех users, и удалить из столбца privileges соотв. id.
          2) Проверить все groups, и удалить из столбца privileges соотв. id.
        - Вручную это делать каждый раз муторно.
        - Оптимальный вариант: в обработчике события deleted.

      Класс-наблюдатель модели (точка сбора всех обработчиков модели)
      ---------------------------------------------------------------
        - Событий у модели много, и обработчиков можно назначить тоже много.
        - Может не быть желания пихать все эти обработчики в сервис-провайдер.
        - А положить их в какой-нибудь отдельный класс.
        - Этот класс, в терминологии L5, называют классом-наблюдателем.
        - Вот, как он может выглядеть (пример):

            class UserObserver {

                public function saving($model)
                {
                    //
                }

                public function saved($model)
                {
                    //
                }

            }  

        - Но его надо зарегистрировать в сервис-провайдере:

            User::observe(new UserObserver);


    //-------------------------------------//
    // 13]  Преобразование в массив / JSON //
    //-------------------------------------//

      Модель -> массив
      ----------------

        # Модель в массив
          $user = User::with('roles')->first();
          return $user->toArray();

        # Коллекцию в массив
          $users = User::all();
          return $users->toArray();

      Модель -> JSON
      --------------

        # Модель в JSON
          $user = User::with('roles')->first();
          return $user->toJson(); 
          
        # Коллекцию в массив
          $users = User::all();
          return $users->toJson();                 

      Возвращаемая модель авто-преобразуется в JSON
      ---------------------------------------------
        - Сабж.
        - Пример:

            Route::get('users', function()
            {
                return User::all();
            });        

      Исключение столбцов из результата преобразования в массив \ JSON
      ----------------------------------------------------------------
        - Допустим, не все столбцы мы хотим видеть в результате.
        - Если мы хотим скрыть опред.столбцы, используем $hidden:

            class User extends Model {

                protected $hidden = ['password'];

            }        

        - А если хотив видеть лишь столбцы из опред.списка, используем $visible:

            class User extends Model {

                protected $visible = ['first_name', 'last_name'];

            }    

      Добавление доп.данных в результаты преобразования в массив \ JSON
      -----------------------------------------------------------------            
        - Часто, надо добавить в результаты преобразование доп.столбцы.
        - Скажем, некие "вычисленные" данные, или данные из других таблиц.
        - В процессе разработки это постоянно требуется делать тут и там.
        - Допустим, надо добавлять столбец 'is_admin' к результату преобразования.
        - Вот, как это можно делать:

          1) Добавить ассессор для этого (не существующего в таблице) столбца:
            - Причём, в имени ассессора использовать верблюжью нотацию.
            - Код:

              public function getIsAdminAttribute()
              {
                  return $this->attributes['admin'] == 'yes';
              }                    

          2) Добавить 'is_admin' в массив в св-ве $appends
            - Причём appends соблюдает правила в $visible и $hidden.


    //----------------------------//
    // 14]  Связи между таблицами //
    //----------------------------//

      //--------------//
      // 14.1]  Связи //
      //--------------//

        Общая информация о связях между таблицами в SQL
        -----------------------------------------------

          # Общая информация о связях в SQL
            - Между таблицами в БД могут предполагаться определённы связи.
            - В терминах SQL эти связи называют "внешние ключи", или "foreign keys".
            
          # Общая информация о связях в Eloquent
            - Eloquent позволяет определять связи в классах-моделях.
            - Он эмулирует их в PHP, их оформление на сервере БД не требуется.
            - Через класс-модель можно осуществлять доступ к её связям.

          # Прямая связь
            - Например, прямая связь типа 1:1, задаваемая методом hasOne().
            - Такая связь ищет FK в связанной модели (а не в той, где определена).
            - А не в ту, в которой эта связь непосредственно определена.
            - Например, пусть модель X связана с моделью Y связью 'con' типа hasOne.
            - То есть, связь определена в X, а FK при этом добавлен в Y.
            - Тогда, через X можно получить доступ к Y:

                $y = X::find(1)->con;

          # Обратная связь
            - Но вот получить X через Y нельзя без наличия "обратной связи".
            - Например, обратная связь типа 1:1, задаваемая методом belongsTo().
            - Такая связь ищет FK непосредственно в модели, в которой определена.
            - В нашем случае, связь belongsTo определяем в X.
            - И в X же FK и добавляется.

          # Дочерняя связанная модель
            - В которой находится столбец с FK.

          # Родительская связанна модель
            - В которой определена связь, которая ищет столбец с FK в другой модели.


        // hasOne()
        //----------------------------------------//
        // - связь 1:1 "прямая"

          Определить прямую 1:1 связь в классе-модели
          -------------------------------------------
            - Свяжем модели 'User' и 'Phone'
            - Определим в 'User' прямую 1:1 связь с 'Phone'.
            - В результате через 'User' можно будет получить Phone.
            - Eloquent будет искать в 'Phone' столбец 'user_id' с FK.
            - В данной связи, 'Phone' - дочерняя, а 'User' - родительская модель. 
            - Определение связи в 'User':

                class User extends Model {

                    public function phone()
                    {
                        return $this->hasOne('App\Phone');
                    }

                }

          Задать имена столбцов с Foreign Key и Local Key
          -----------------------------------------------
            
            # Как Eloquent по умолчанию определяет имя FK
              - По шаблону: [имя модели]_id
              - Имеется в виду модель, в которой определена прямая связь.

            # Как Eloquent по умолчанию определяет имя LK
              - Это 'id'.

            # Как задать имена FK / LK при определении связи
              - Это 2-й и 3-й аргументы в методе hasOne:
                  hasOne([дочерняя модель], [имя FK], [имя LK])
              - Эти аргументы являются не обязательными.
              - Скажем, можно задать 2-й аргумент, но не задавать 3-й.
              - Пример:

                  class User extends Model {

                      public function phone()
                      {
                          return $this->hasOne('App\Phone', 'foreign_key', 'local_key');
                      }

                  }

          Использовать заданную прямую 1:1 связь
          --------------------------------------          
            - Применим связь, и получим телефон через модель User:

                $phone = User::find(1)->phone;

            - При этом "за сценой" будет выполнен следующий SQL:

                select * from users where id = 1
                select * from phones where user_id = 1 


        // belongsTo()
        //----------------------------------------//
        // - связь 1:1 "обратная", связь 1:n "обратная"

          Определить обратную 1:1 связь в классе-модели
          ---------------------------------------------
            - Свяжем модели 'User' и 'Phone'
            - Определим в 'Phone' обратную 1:1 связь с 'User'.
            - В результате через 'Phone' можно будет получить модели 'User'.
            - Eloquent будет искать в 'Phone' столбец 'user_id' с FK.
            - Определение связи в 'Phone':

                class Phone extends Model {

                    public function user()
                    {
                        return $this->belongsTo('App\User');
                    }

                }          

          Задать имена столбцов с Local Key и Parent Key
          ----------------------------------------------
            
            # Как задать имена LK / PK при определении связи
              - Это 2-й и 3-й аргументы в методе hasOne:
                  hasOne([дочерняя модель], [имя LK], [имя PK])
              - Эти аргументы являются не обязательными.
              - Скажем, можно задать 2-й аргумент, но не задавать 3-й.
              - Пример:

                class Phone extends Model {

                    public function user()
                    {
                        return $this->belongsTo('App\User', 'local_key', 'parent_key');
                    }

                } 

          Использовать заданную обратную 1:1 связь
          ----------------------------------------          
            - Применим связь, и получим телефон через модель User:

                $user = Phone::find(1)->user;


        // hasMany()
        //----------------------------------------//
        // - связь 1:n "прямая"

          Определить прямую 1:n связь в классе-модели
          -------------------------------------------
            - Свяжем модели 'Post' и 'Comment'
            - Определим в 'Post' прямую 1:n связь с 'Comment'.
            - В результате через 'Post' можно будет получить модели 'Comment'.
            - Eloquent будет искать в 'Comment' столбец 'post_id' с FK.
            - Определение связи в 'Phone':

                class Post extends Model {

                    public function comments()
                    {
                        
                        // Если устраивают названия FK и LK по умолчанию
                        return $this->hasMany('App\Comment');

                        // Если хотим указать назчания FK/LK сами
                        // return $this->hasMany('App\Comment', 'foreign_key', 'local_key');
                    
                    }

                }         

          Использовать прямую 1:n связь
          -----------------------------
            - Получим коллекцию комментариев по определенному посту:

                $comments = Post::find(1)->comments;

            - Получим 1 найденный  коммент. к опред.посту с опред.заголовком:

                $comment = Post::find(1)->comments()->where('title', '=', 'foo')->first();

          Определить обратную 1:n связь в классе-модели
          ---------------------------------------------
            - Свяжем модели 'Post' и 'Comment'
            - Определим в 'Comment' обратную 1:n связь с 'Post'.
            - В результате через 'Comment' можно будет получить модели 'Post'.
            - Eloquent будет искать в 'Comment' столбец 'post_id' с FK.
            - Определение связи в 'Comment':

                class Comment extends Model {

                    public function post()
                    {

                        // Если устраивают названия LK и PK по умолчанию
                        return $this->belongsTo('App\Post');
                    
                        // Если хотим указать назчания LK/PK сами
                        return $this->belongsTo('App\Post', 'local_key', 'parent_key');

                    }

                }

          Использовать обратную 1:n связь
          -------------------------------
            - Получим пост, которому принадлежит найденный комментарий

                $post = Comment::find(1)->post;


        // hasManyThrough()
        //----------------------------------------//
        // - связь 1:n "транзитная"

          Определить транзитную 1:n связь в классе-модели
          -----------------------------------------------
            - Свяжем модели 'Country' - 'User' - 'Post'.
            - То есть, 'Country' будет связана с 'Post' через 'User'.
            - Определим для этого в 'Country' транзитную 1:n связь.
            - В результате через 'Country' можно будет получить модели 'Post'.
            - Eloquent будет искать в 'Post' столбец 'country_id' с FK.
            - Определение связи в 'Country':

                class Country extends Model {

                    public function posts()
                    {

                        // Если устраивают названия FK и LK по умолчанию
                        return $this->hasManyThrough('App\Post', 'App\User');

                        // Если хотим указать назчания FK/LK сами
                        // return $this->hasManyThrough('App\Post', 'App\User', foreign_key', 'local_key');

                    }

                }

          Использовать транзитную 1:n связь
          ---------------------------------
            - Получим коллекцию постов, сделанных пользователями из опред.страны:

                $posts = Country::find(1)->posts;


        // morphMany()
        //----------------------------------------//
        // - связь 1:n, 1:x, 1:y, ... "полиморфная"

          Что такое полиморфная связь?
          ----------------------------
            - Когда 1 модель может принадлежать n другим моделям.
            - Например, есть 4 модели: 
                'Comments'  | комментарии
                'Blogs'     | записи в блоге
                'Goods'     | товарные позиции
                'News'      | новости
            - Комментировать можно записи в блоге, тов.позиции, новости.
            - Удобно было бы иметь для хранения комментов лишь 1 таблицу.
            - И из моделей блогов/тов.позиций/новостей иметь доступ к комментам.
            - В стиле: "так, покажи мне все коменты для этой записи блога".
            - Если бы было всего 2 модели, то в 'Comment' мы бы поместили связь belongTo 1:n.
            - Но в нашем случае, потребуется полиморфная связь.
            - В данном случае, модель 'Comment' будет принадлежать одновременно 3-м остальным.
            - Иллюстрация полиморфной связи:

                                 ------------
                                 | Comments |  принадлежит этим 3-м...
                                 ------------
                                  |   |  |
                                  |   |  |
                  -----------------   |  --------------------         
                  |                   |                     |
                ---------           ---------             --------
                | Blogs |           | Goods |             | News |
                ---------           ---------             --------

          Структура таблиц для организации полиморфной связи
          --------------------------------------------------

            Comments
                id
                comment
                morphowner_id      // id владельца комента (записи в блоге / тов.позиции / новости)
                morphowner_type    // тип владельца коммента (имя класса-владельца: 'blogs' / 'goods' / 'news' )

            Blogs
                id

            Goods
                id

            News
                id

          Определение полиморфной связи
          -----------------------------

            # Дочерняя модель
            class Comments extends Model {
              public function morphowner(){
                return $this->morphTo();
              }
            }

            # Родительские модели
            class Blogs extends Model {
              public function comments(){
                return $this->morphMany('App\Blogs', 'morphowner');
              }
            }
            class Goods extends Model {
              public function comments(){
                return $this->morphMany('App\Goods', 'morphowner');
              }
            }  
            class News extends Model {
              public function comments(){
                return $this->morphMany('App\News', 'morphowner');
              }
            }              

          Использование полиморфной связи
          -------------------------------

            $blog = Blogs::find(1);
            foreach($blog->comments as $comment) {
              //
            }

            $good = Goods::find(1);
            foreach($good->comments as $comment) {
              //
            }            

            $news = News::find(1);
            foreach($news->comments as $n) {
              //
            }   

          Получение родителя полиморфной связи по дочке
          ---------------------------------------------

            $comment = Comments::find(1);
            $owner = $comment->morphowner;


        // belongsToMany()
        //----------------------------------------//
        // - связь n:m

          Общая информация про m:n связь
          ------------------------------
            - Допустим, у есть 2 таблицы 'teachers' и 'students' со связью m:n.
            - У одного учителя может быть несколько учеников.
            - У одного ученика может быть несколько учителей.
            - Но где же нам хранить, у какого ученика какие учителя; у какого
              учителя какие ученики? Делать это в этих 2-х таблицах не удобно.
            - Как раз для этой цели мы и создаём 3-ю промежуточную pivot-таблицу.
            - Наглядный пример:

              # pivot-таблица
                - Изначально у нас 2 таблицы: 'teachers' и 'students'.
                - Между ними связь m:n.
                - Разбиваем эту связь на 1 связи типа 1:n методом bridge-таблицы.
                - Вот как в результате выглядит схема:

                | Teachers |                          | Students |
                |----------|                          |----------|
                | id       |------|              |----| id       |
                | name     |      |              |    | name     |
                                  |              |
                                  | |   Pivot  | |
                                  | |----------| |
                                  | | teach_id |-|
                                  |-| stud_id  |

              # Пример реальной pivot-таблицы:
                - Из этого примера наглядно видно, как используеся bridge-таблица.
                - По ней можно однозначно определить, какой учитель связан с
                  какими студентами, и наоборот, какой студент связан с какими учителями.

                teach_id      |      stud_id
                ----------------------------
                    1               1
                    1               2
                    1               3
                    2               1
                    2               2
                    2               3
                    2               4
                            ...

          Определение n:m связи (прямой и обратной)
          -----------------------------------------

            # Прямая
            class Teacher extends Model {

                public function students()
                {
                    // Если устраивает значения по умолчанию для:
                    // - pivot-таблицы, FK, LK
                    return $this->belongsToMany('App\Student');
                
                    // Если требуется указать:
                    // - имя pivot-таблицы
                    return $this->belongsToMany('App\Student', 'user_roles');

                    // Если требуется указать:
                    // - имя pivot-таблицы
                    // - FK, LK
                    return $this->belongsToMany('App\Student', 'user_roles', 'user_id', 'foo_id');

                }

            }

            # Обратная (определяется аналогично)
            class Student extends Model {

                public function teachers()
                {
                    // Если устраивает значения по умолчанию для:
                    // - pivot-таблицы, LK, PK
                    return $this->belongsToMany('App\Teacher');
                
                    // Если требуется указать:
                    // - имя pivot-таблицы
                    return $this->belongsToMany('App\Teacher', 'user_roles');

                    // Если требуется указать:
                    // - имя pivot-таблицы
                    // - LK, PK
                    return $this->belongsToMany('App\Teacher', 'user_roles', 'user_id', 'foo_id');

                }

            }


          Использование n:m связи
          -----------------------

            # Получить коллекцию всех студентов данного учителя
            $students = Teacher::find(1)->students;          

            # Получить коллекцию всех учителей данного студента
            $teachers = Student::find(1)->teachers;  


        // morphToMany()
        //----------------------------------------//
        // - связь n:m, n:x, n:y, ... "полиморфная"

          Что такое m:n полиморфная связь?
          --------------------------------         
            - Тоже самое, что обычная полиморфная связь.
            - Только в формате m:n, и с pivot-таблицей.


          Структура таблиц для организации n:m полиморфной связи
          ------------------------------------------------------

            posts
                id - integer
                name - string

            videos
                id - integer
                name - string

            tags
                id - integer
                name - string

            taggables
                tag_id - integer
                taggable_id - integer
                taggable_type - string 

          Определение полиморфной n:m связи
          ---------------------------------

            # Дочерняя модель
            class Tag extends Model {

                public function posts()
                {
                    return $this->morphedByMany('App\Post', 'taggable');
                }

                public function videos()
                {
                    return $this->morphedByMany('App\Video', 'taggable');
                }

            }

            # Родительские модели
            class Post extends Model {

                public function tags()
                {
                    return $this->morphToMany('App\Tag', 'taggable');
                }

            }   
            class Video extends Model {

                public function tags()
                {
                    return $this->morphToMany('App\Tag', 'taggable');
                }

            }    

          Использование полиморфной n:m связи
          -----------------------------------

            # Получить коллекцию видео по указанному тегу
            $videos = Tags::find(1)->videos;

            # Получить коллекцию постов по указанному тегу
            $videos = Tags::find(1)->posts;
                       

      //-----------------------------------------------------------------//
      // 14.2]  Запросы через связи: advanced where и динамические св-ва //
      //-----------------------------------------------------------------//

        // has()
        //----------------------------------------//
        // - при запросе к модели X, установить огран.на связанные с ней значения модели Y

          # Получить все посты, имеющие хотя бы 1 комментарий
          $posts = Post::has('comments')->get();

          # Получить все посты, имеющие 3 или более комментариев
          $posts = Post::has('comments', '>=', 3)->get();

          # Получить все посты, за которые хоть раз голосовали
          # - Здесь, через дот-нотацию, мы дёргаем связь votes модели Comments:
          $posts = Post::has('comments.votes')->get();


        // whereHas()
        //----------------------------------------//
        // - продвинутый has

          # Получить все посты, к которым есть комменты, начинающиеся с 'foo'
          $posts = Post::whereHas('comments', function($q)
          {
              $q->where('content', 'like', 'foo%');

          })->get();


        Динамические св-ва (напр.: $phone->user->email)
        -----------------------------------------------       
          - Получить доступ к связям модели можно через "динамические свойства" (ДС).
          - Например:

              # В модели Phone определена следующая связь:

                  class Phone extends Model {
                    public function user(){
                      return $this->belongsTo('App\User');
                    }
                  }

              # Получим из Phone телефон с id == 1
              $phone = Phone::find(1);

              # Получим связанного с $phone пользователя без ДС
              $user = $phone->user()->first();

              # Получим связанного с $phone пользователя с ДС
              $user = $phone->user;

          - При использовании ДС, eloquent умно подбирает нужный метод.
          - Где надо использует first() - и мы получаем в резуьтате модель.
          - А где надо использует get() - и мы получаем в результате коллекцию моделей.


      //----------------------------------------------------------//
      // 14.3]  Устраниние проблемы N+1 методом "жадной загрузки" //
      //----------------------------------------------------------//
      // - В оф.документации это называется "Eager Loading"

        Суть проблемы N+1
        -----------------
          - Покажем суть данной проблемы на примере.
          - Допустим, есть модель Book, связанная с моделью Author:

              class Book extends Model {
                public function author() {
                  return $this->belongsTo('App\Author');
                }
              }   

          - Извлечём коллекцию всех книг:

              $books = Book::all();   // допустим, книг 25 штук

          - Теперь пробежимся по всем книгам с помощью foreach:

              foreach (Book::all() as $book)  // 1 запрос
              {
                  echo $book->author->name;   // 25 запросов
              }  

          - 1 запрос уходит на извлечение коллекции всех книг.
          - И ещё 25 запросов к Author для извлечения автора каждой из 25 книг.
          - Итого, 26 запросов к БД вместо 1-го, что нехило её грузит.
          - Это и есть проблема N+1.


        // with()
        //----------------------------------------//
        // - ленивая подгрузка связей при извлечении из модели

          # Пример ленивой подгрузки связей
            - Снова извлечём коллекцию книг.
            - Но на этот раз, в этом же запросе, извлечём и авторво этих книг:

                $books = Book::with('author')->get();

            - "За сценой", на самом деле, было выполнено 2 SQL-запроса:

                SELECT * FROM books
                SELECT * FROM authors WHERE id in (1, 2, 3, 4, 5, ..., 25)              

            - Теперь пробежимся по всем книга с помощью foreach.
            - На этот раз, данная операция вообще не потребует обращений к БД:

                foreach ($books as $book)       // 0 запросов
                {
                    echo $book->author->name;   // 0 запросов
                }  

            - Примененная операция называется "ленивая подгрузка" (Eager Loading).
            

          # Вообще, можно лениво подгружать и более 1 связи за раз

              $books = Book::with('author', 'publisher')->get();


          # А также можно лениво подгружать вложенные связи, через дот-нотацию:

              $books = Book::with('author.contacts')->get();           


          # Также можно указать условия для ленивой подгрузки
            - Скажем, есть 2 модели, Users и Posts.
            - Модель Users содержит связь posts с моделью Posts.
            - И вот, при извлечении пользвателей, мы хотим лениво подгружать их посты.
            - Но не все, а лишь те, которые содержат слово "алькаида".
            - Это может быть полезным для выявления потенциальных террористов.
            - Вот, как это делается:

                $users = User::with(['posts' => function($query)
                {
                    $query->where('content', 'like', '%алькаида%');

                }])->get();    

            - Или можем, скажем, сортирнуть посты каждого пользователя по дате создания:

                $users = User::with(['posts' => function($query)
                {
                    $query->orderBy('created_at', 'desc');

                }])->get();                    


        // load()
        //----------------------------------------//
        // - ленивая подгрузка связей для УЖЕ извлеченной коллекции данных

          - Допустим, мы уже извлекли коллекцию книг:

              $books = Book::all();

          - Но при извлечении не стали использовать ленивую подгрузку.
          - А теперь нам вдруг понадобилось подгрузить связи.
          - Но грузить базу снова извлечением той же коллекции книг не хочется.
          - Тогда, мы можем лениво подгрузить данные из связей для УЖЕ извлеченной коллекции.
          - Вот так:

              $books->load('author', 'publisher');

          - Аналогично с with(), можно применять ограничения:

              $books->load(['author' => function($query)
              {
                  $query->orderBy('published_date', 'asc');
              }]);          


      //------------------------------------------------//
      // 14.4]  Insert в связанные модели через связи   //
      //------------------------------------------------//

        // save()
        //----------------------------------------//
        // - сделать insert модели через связь
        // - при использовании для m:n связей, attach выполняется автоматом "за кадром"

          - Допустим, есть у нас 2 модели, Post и Comment.
          - И в Post есть связь comments с Comment.
          - Извлекли мы какой-нибудь пост:

              $post = Post::find(1);

          - И хотим теперь через связь добавить в Comment новый комментарий.
          - То есть, добавить новую строчку в конец таблицы comments, связанной с моделью Comment.
          - Для этого, сначала создаём новую модель-комментарий:

              $newComment = new Comment(['message' => 'A new comment.']);

          - А затем, с помощью метода save(), добавляем в Commens прямо через связь comments:

              $comment = $post->comments()->save($newComment);


        // saveMany()
        //----------------------------------------//
        // - сделать insert массива моделей через связь

          - А что, если надо сделать insert через связь не 1-й, а N моделей?
          - Для этого уже надо использовать метод saveMany:

            # Готовим массив с моделями:

              $comments = [
                  new Comment(['message' => 'A new comment.']),
                  new Comment(['message' => 'Another comment.']),
                  new Comment(['message' => 'The latest comment.'])
              ];

            # Извлекаме нужный пост и делаем insert через связь:
              $post = Post::find(1);
              $post->comments()->saveMany($comments);


        // associate()
        //----------------------------------------//
        // - (для belongsTo связей) проставляет FK для дочерней модели (belongsTo)

          - При обновлении связи belongsTo, можно использовать метод associate.
          - Он установит FK для дочерней модели:

              $account = Account::find(10);
              $user->account()->associate($account);
              $user->save();


        // attach()
        //----------------------------------------//
        // - (для m:n связей) добавить новую запись в pivot-таблицу через связь

          - Допустим, есть у нас 2 модели, User и Role.
          - Они связаны связью Many To Many (m:n).
          - Мы извлекаем какого-нибудь пользователя:

              $user = User::find(1);

          - И хотим через m:n связь добавить ему новую роль.
          - Вот, как это делается с помощью метода attach():

              $user->roles()->attach(1);

          - Если надо добавить много ролей, можно передать массив:

              $user->roles()->attach([1,2,3]]);

          - Вторым аргументом можно передать массив данных.
          - Они добавятся в соотв.столбцы pivot-таблицы, в соотв.строку:

              $user->roles()->attach(1, ['expires' => $expires]);


        // detach()
        //----------------------------------------//
        // - (для m:n связей) удалить запись из pivot-таблицы через связь

          $user->roles()->detach(1);
          $user->roles()->detach([1, 2, 3]);


        // sync()
        //----------------------------------------//
        // - (для m:n связей) оставляет в pivot-таблице только связи с указанными id

          - Допустим, имеются 2 модели, User и Role.
          - Они связаны m:n связью.
          - И есть вот такая pivot-таблица между ними:

              id  user_id role_id
              1    2       1
              2    2       2          
              3    2       5
              4    2       10

          - Как видно, у пользователя №2 есть 4 роли [1,2,5,10].
          - А мы, допустим, хотим, чтобы было толко 2 роли: [1,7]
          - Было бы неудобно по 1-й удалять/добавлять эти роли.
          - Проще сказать: "пусть у него будет лишь эти 2 роли".
          - Для этого и можно использовать sync:

              User::find(2)->roles()->sync([1, 7]);

          - После этого, pivot-таблица станет выглядеть так:

              id  user_id role_id
              1    2       1
              2    2       7   


      //-------------------------------------------------------------------//
      // 14.5]  Обновление updated_at родит.модели при обновлении дочерней //
      //-------------------------------------------------------------------//

        Свойство модели $touches
        ------------------------
          - Рассмотрим снова 2 модели, Post и Comment.
          - Модель они связаны 1:n связью.
          - В Post есть hasMany-связь comments.
          - А в Comment есть belongTo-связь post.
          - А в таблице posts есть столбец 'updated_at'.
          - Допустим, у нас какой-нибудь из комментариев обновляется.
          - Нужно ли нам обновлять 'updated_at' поста, которому принадлежит этот коммент?
          - Если да, то такое можно устроить с помощью свойства $touches.
          - Нужно в модель Comment добавить это св-во, содержащее массив.
          - А в массив добавить имена связей, в нашем случае:

              $touches = ['post'];


      //----------------------------------------------------------//
      // 14.6]  Работа с промежуточными таблицами (при связи n:m) //
      //----------------------------------------------------------//

        Динамическое свойство pivot
        ---------------------------
          - Через него можно получить доступ к pivot-таблице.
          - Пусть, например, модели User и Role связаны n:m связью.
          - Тогда доступ к pivot-таблице можно получать так:

              $user = User::find(1);
              $updated_at = $user->pivot->updated_at;

              foreach($user->roles as $role) {
                $created_at = $role->pivot->created_at;
              }

        // withPivot()
        //----------------------------------------//
        // - что будет содержать объект в св-ве pivot

          - По умолчанию, только соответствующие ключи.
          - Вроде: user_id, role_id.
          - Но ведь pivot-таблица может содержать доп.столбцы с доп.данными.
          - Но этих данных, по умолчанию, в объекте в св-ве pivot не будет.
          - А чтобы были, надо при определении связи явно указать имена столбцов с доп.данными:

              return $this->belongsToMany('App\Role')->withPivot('foo', 'bar');

        // withTimestamps()
        //----------------------------------------//
        // - включить авто-поддержку столбцов created_at/updated_at в pivot-таблице

          - Допустим, в pivot-таблице у нас есть столбцы created_at/updated_at.
          - И мы хотим, чтобы Laravel автоматически вписывал в них актуальные значения.
          - Тогда, при определении n:m связи, надо использовать св-во withTimestamps():

              return $this->belongsToMany('App\Role')->withTimestamps();

        // detach()
        //----------------------------------------//
        // - удалить запись из pivot-таблицы

          User::find(1)->roles()->detach();

        // updateExistingPivot()
        //----------------------------------------//
        // - изменить существующую запись в pivot-таблице (без удаления)

          User::find(1)->roles()->updateExistingPivot($roleId, $attributes);


        Создание своей, кастомной pivot-таблицы [по требованию]
        -------------------------------------------------------
          - Написать пункт [по требованию]


В4.  Schema Builder (конструктор таблиц)

  --------------------------------------
  Подоглавление:

    - Введение
    - Функционал

      1]  Создание & удаление таблиц

        - create()        | создать новую таблицу в БД
        - rename()        | переименовать таблицу
        - connection()    | уточнить, какое соединение использовать для операции
        - drop()          | удалить таблицу

      2]  Выбор движка таблицы

        - engine          | при создании указать движок таблицы (innodb по умолчанию)

      3]  Добавление столбцов

        - Добавление столбцов при создании таблицы
        - Добавление столбцов в существующую таблицу
        - Список доступных для назначения типов столбцов
        - Управление порядком столбцов с помощью after в MySql

      4]  Изменение столбцов

        - Перед изменением столбцов добавить doctrine/dbal в composer.json
        - change()        | изменить столбец

      5]  Переименование столбцов

        - Перед переименованием столбцов добавить doctrine/dbal в composer.json
        - renameColumn()  | переименовать столбец

      6]  Удаление столбцов

        - Перед удалением столбцов добавить doctrine/dbal в composer.json
        - dropColumn      | (в конф.объекте) удалить столбец/столбцы

      7]  Проверка наличия столбца/таблицы

        - hasTable()      | проверить налиие таблицы
        - hasColumn()     | проверить наличие столбца

      8]  Назначение индексов столбцам

        - Как назначить индекс столбцу
        - Список доступных индексов

      9]  Удаление индексов

        - Как удалить индекс
        - Список функционала для удаления разных типов индексов

      10]  Назначение внешнего ключа столбцу

        - Как назначить внешний ключ
        - Задать опции FK "on delete", "on update"
        - Удалить FK можно с помощью dropForeign
        - При создании FK на int с инкрементом, столбец с FK д.б. unsigned

      11]  Удаление столбцов created_at, updated_at, deleted_at

        - Как удалить столбцы timestamps, nullableTimestamps, softDeletes

   
  --------------------------------------

  > Введение
    - У Laravel есть класс Schema.
    - Он позволяет работать с таблицами БД: добавлять, изменять, удалять.
    - Для этого он содержит соответствующий функционал.
    - Он позволяет работать со всеми 4-мя СУБД, которые поддерживает Laravel.
    - Причём для всех СУБД функционал унифицирован, один и тот же.


  > Функционал

    //--------------------------------//
    // 1]  Создание & удаление таблиц //
    //--------------------------------//

      // create()
      //----------------------------------------//
      // - создать новую таблицу в БД
      // - первый аргумент: имя новой таблицы
      // - второй аргумент: анон.функ., которая возвращает объект с параметрами создания новой таблицы

        Schema::create('users', function($table)
        {
            $table->increments('id');
        });      

      // rename()
      //----------------------------------------//
      // - переименовать таблицу

        Schema::rename($from, $to);

      // connection()
      //----------------------------------------//
      // - уточнить, какое соединение использовать для операции

        Schema::connection('foo')->create('users', function($table)
        {
            $table->increments('id');
        });            

      // drop()
      //----------------------------------------//
      // - удалить таблицу

        Schema::drop('users');
        Schema::dropIfExists('users');            


    //--------------------------//
    // 2]  Выбор движка таблицы //
    //--------------------------//

      // engine
      //----------------------------------------//
      // - при создании указать движок таблицы (innodb по умолчанию)

        Schema::create('users', function($table)
        {
            $table->engine = 'InnoDB';

            $table->string('email');
        });     


    //-------------------------//
    // 3]  Добавление столбцов //
    //-------------------------//

      Добавление столбцов при создании таблицы
      ----------------------------------------
        - Можно добавлять столбцы на этапе создания таблицы.
        - Это делается в конфиг.объекте, возвращаемом анон.функцией.
        - Например, создадим таблицу с 1 столбцом - 'id' с AI и PK:

          Schema::create('users', function($table)
          {
              $table->increments('id');
          });         

      Добавление столбцов в существующую таблицу
      ------------------------------------------
        - Можно добавить столбцы в существующую таблицу.
        - Для этого надо использовать метод table().
        - Добавление производится конфиг.объекте, возвращаемом анон.функцией.
        - Например, добавим в таблицу 'users' новый столбец строкового типа 'email':

          Schema::table('users', function($table)
          {
              $table->string('email');
          });

      Список доступных для назначения типов столбцов
      ----------------------------------------------

        - bigIncrements ('id');                       | Incrementing ID using a "big integer" equivalent
        - bigInteger    ('votes');                    | BIGINT equivalent to the table
        - binary        ('data');                     | BLOB equivalent to the table       
        - boolean       ('confirmed');                | BOOLEAN equivalent to the table             
        - char          ('name', 4);                  | CHAR equivalent with a length           
        - date          ('created_at');               | DATE equivalent to the table             
        - dateTime      ('created_at');               | DATETIME equivalent to the table             
        - decimal       ('amount', 5, 2);             | DECIMAL equivalent with a precision and scale               
        - double        ('column', 15, 8);            | DOUBLE equivalent with precision, 15 digits in total and 8 after the decimal point                 
        - enum          ('choices', ['foo', 'bar']);  | ENUM equivalent to the table                           
        - float         ('amount');                   | FLOAT equivalent to the table         
        - increments    ('id');                       | Incrementing ID to the table (primary key)     
        - integer       ('votes');                    | INTEGER equivalent to the table         
        - json          ('options');                  | JSON equivalent to the table           
        - jsonb         ('options');                  | JSONB equivalent to the table           
        - longText      ('description');              | LONGTEXT equivalent to the table               
        - mediumInteger ('numbers');                  | MEDIUMINT equivalent to the table           
        - mediumText    ('description');              | MEDIUMTEXT equivalent to the table               
        - morphs        ('taggable');                 | Adds INTEGER taggable_id and STRING taggable_type           
        - nullableTimestamps();                       | Same as timestamps(), except allows NULLs     
        - smallInteger  ('votes');                    | SMALLINT equivalent to the table         
        - tinyInteger   ('numbers');                  | TINYINT equivalent to the table           
        - softDeletes   ();                           | Adds deleted_at column for soft deletes 
        - string        ('email');                    | VARCHAR equivalent column         
        - string        ('name', 100);                | VARCHAR equivalent with a length             
        - text          ('description');              | TEXT equivalent to the table               
        - time          ('sunrise');                  | TIME equivalent to the table           
        - timestamp     ('added_on');                 | TIMESTAMP equivalent to the table           
        - timestamps    ();                           | Adds created_at and updated_at columns 
        - rememberToken ();                           | Adds remember_token as VARCHAR(100) NULL 
        - nullable      ();                           | Designate that the column allows NULL values 
        - default       ($value);                     | Declare a default value for a column       
        - unsigned      ();                           | Set INTEGER to UNSIGNED 

      Управление порядком столбцов с помощью after в MySql
      ----------------------------------------------------

        $table->string('name')->after('email');


    //------------------------//
    // 4]  Изменение столбцов //
    //------------------------//

      Перед изменением столбцов добавить doctrine/dbal в composer.json
      ----------------------------------------------------------------
        - Иначе не будет работать.

      // change()
      //----------------------------------------//
      // - изменить столбец

        Schema::table('users', function($table)
        {
            $table->string('name', 50)->change();
        });

        Schema::table('users', function($table)
        {
            $table->string('name', 50)->nullable()->change();
        });        

    //-----------------------------//
    // 5]  Переименование столбцов //
    //-----------------------------//

      Перед переименованием столбцов добавить doctrine/dbal в composer.json
      ---------------------------------------------------------------------
        - Иначе не будет работать.

      // renameColumn()
      //----------------------------------------//
      // - переименовать столбец 
      // - !!! переименование enum-столбцов не поддерживается (04.06.2015)    

        Schema::table('users', function($table)
        {
            $table->renameColumn('from', 'to');
        });


    //-----------------------//
    // 6]  Удаление столбцов //
    //-----------------------//

      Перед удалением столбцов добавить doctrine/dbal в composer.json
      ---------------------------------------------------------------
        - Иначе не будет работать.

      // dropColumn
      //----------------------------------------//
      // - удалить столбец/столбцы
      // - происходит в конфигурационном объекте

        # Удалить 1 столбец
          Schema::table('users', function($table)
          {
              $table->dropColumn('votes');
          });     

        # Удалить 3 столбца
          Schema::table('users', function($table)
          {
              $table->dropColumn(['votes', 'avatar', 'location']);
          });


    //--------------------------------------//
    // 7]  Проверка наличия столбца/таблицы //
    //--------------------------------------//

      // hasTable()
      //----------------------------------------//
      // - проверить налиие таблицы

        if (Schema::hasTable('users'))
        {
            //
        }


      // hasColumn()
      //----------------------------------------//
      // - проверить наличие столбца

        if (Schema::hasColumn('users', 'email'))
        {
            //
        }

    //----------------------------------//
    // 8]  Назначение индексов столбцам //
    //----------------------------------//                        

      Как назначить индекс столбцу
      ----------------------------
        - Это нужно делать в конфигурационном объекте в анон.функции.
        - Либо в create(), либо в table().
        - Пример:

            Schema::table('users', function($table)
            {
                $table->string('email')->unique();
            }); 
            
      Список доступных индексов
      -------------------------

        - primary('id');                | Adding a primary key
        - primary(['first', 'last']);   | Adding composite keys
        - unique('email');              | Adding a unique index
        - index('state');               | Adding a basic index

    //-----------------------//
    // 9]  Удаление индексов //
    //-----------------------//

      Как удалить индекс
      ------------------
        - Для этого надо указать его имя.
        - Имя индекса формируется Laravel автоматически по шаблону:
            [имя таблицы]_[имя столбца]_[тип индекса]
        - Например, удалим из табл.'users', у столбца 'email' unique-индекс:

            Schema::table('users', function($table)
            {
                $table->dropUnique('users_email_unique');
            });        

      Список функционала для удаления разных типов индексов
      -----------------------------------------------------

        - dropPrimary('users_id_primary');   | Dropping a primary key from the "users" table   
        - dropUnique('users_email_unique');  | Dropping a unique index from the "users" table   
        - dropIndex('geo_state_index');      | Dropping a basic index from the "geo" table

    //----------------------------------------//
    // 10]  Назначение внешнего ключа столбцу //
    //----------------------------------------//

      Как назначить внешний ключ
      --------------------------
        - Laravel поддерживает возможность назначать внешний ключ.
        - Например:

            Schema::table('groups', function($table)
            {
                $table->integer('user_id')->unsigned();
                $table->foreign('user_id')->references('id')->on('users');      
            });  

        - В этом примере мы изменили таблицу 'groups'.
        - Подразумевается, что таблица users и столбец id в ней существуют.
        - В groups мы создали столбец 'user_id' типа unsigned int.
        - И создали в нём внешний ключ, указывающий на столбец id таблицы users.

      Задать опции FK "on delete", "on update"
      ----------------------------------------

        $table->foreign('user_id')
              ->references('id')->on('users')
              ->onDelete('cascade');

      Удалить FK можно с помощью dropForeign
      --------------------------------------

        $table->dropForeign('posts_user_id_foreign');      

      При создании FK на int с инкрементом, столбец с FK д.б. unsigned
      ----------------------------------------------------------------
        - Сабж.

    //-----------------------------------------------------------//
    // 11]  Удаление столбцов created_at, updated_at, deleted_at //
    //-----------------------------------------------------------//        

      Как удалить столбцы timestamps, nullableTimestamps, softDeletes 
      ---------------------------------------------------------------

        - $table->dropTimestamps();   | Dropping the created_at and updated_at columns from the table
        - $table->dropSoftDeletes();  | Dropping deleted_at column from the table


В5.  Миграции

  --------------------------------------
  Подоглавление:

    # Введение
    # Что из себя представляет файл-миграция
    # Порядок применения миграций, таблица Migrations
    # Создание миграции

      Нюанс: выбирать БД перед использованием Schema
      make:migration [имя]                    | создать миграцию [имя] в каталоге по умолчанию
      make:migration [имя] --path [адрес]     | создать миграцию [имя] в каталоге [адрес]
      make:migration [имя] --table [таблица]  | создать миграцию [имя] для изменения таблицы [таблица]
      make:migration [имя] --create [таблица] | создать миграцию [имя] для создания таблицы [таблица]

    # Использование миграций

      Нюанс: при использовании homestead, запускать эту команду в его терминале
      migrate --path=[путь]                 | запустить новые миграции по адресу [путь]
      migrate --path=[путь] --force         | запустить новые миграции по адресу [путь], не запрашивая подтверждения в случае ожидаемой потери данных
      migrate:rollback --path=[путь]        | выполнить down() всех ранее применённых миграций по адресу [путь] из последнего пакета
      migrate:reset --path=[путь]           | выполнить down() ВСЕХ ранее применённых миграций по адресу [путь]
      migrate:refresh --path=[путь]         | выполнить down() ВСЕХ ранее применённых миграций по адресу [путь], а затем снова их применить
      migrate:status --path=[путь]          | посмотреть статус всех миграций по адресу [путь]

  --------------------------------------

  > Введение
    - Миграции представляют собой систему контроля версий для таблиц в БД проекта.
    - Допустим есть проект, над которым работают 5 человек.
    - Каждый ведёт разработку в локальной среде, на локальной БД.
    - По мере разработки структура таблиц в проекте может изменяться.
    - При этом, надо, чтобы локальные БД всех 5 разработчиков были синхронизированы.
    - Один из вариантов этого добиться, использовать миграции.
    - Когда какой-нибудь из разработчиков изменяет структуру БД, он создаёт миграцию.
    - Миграция, это по сути скрипт, вносящий в "старую" версию соотв.изменения.
    - Остальные разработчики видят новую миграцию, применяют её, и она вносит нужные изменения в структуру их БД.
    - Вот схематично, как всё это выглядит:

                        БД v1  БД v2  БД v3  БД v4  БД v5  ............
        ---------------------------------------------------------------                
        Разработчик 1 | И, СМ  up     up     up     up
        Разработчик 2 | up     И, СМ  up     up     up
        Разработчик 3 | up     up     И, СМ  up     up
        Разработчик 4 | up     up     up     И, СМ  up
        Разработчик 5 | up     up     up     up     И, СМ


        -----------------------------------> линия времени

        - Обозначения:

            И  - изменил БД
            СМ - создал миграцию
            up - применил миграцию

        - Миграции:

            database/migrations
                2015_06_07_105201_migration1
                2015_06_08_105201_migration2
                2015_06_09_105201_migration3
                2015_06_10_105201_migration4
                2015_06_11_105201_migration5


  > Что из себя представляет файл-миграция

    # Общая информация
      - Миграция - это php-файл.
      - Содержит 1 класс, наследующий от Illuminate\Database\Migrations\Migration
      - Его метод up() содержит schema-builder-скрипт, вносящий соотв.изменения в БД.
      - Его метод down() содержит schema-builder-скрипт, возвращающий "все как было".
      - Создавать миграцию вручную нельзя, только командой migrate:make.

    # Файл-миграция (пример)

      <?php

      use Illuminate\Database\Schema\Blueprint;
      use Illuminate\Database\Migrations\Migration;

      class CreateFlightsTable extends Migration
      {
          /**
           * Run the migrations.
           *
           * @return void
           */
          public function up()
          {
              Schema::create('flights', function (Blueprint $table) {
                  $table->increments('id');
                  $table->string('name');
                  $table->string('airline');
                  $table->timestamps();
              });
          }

          /**
           * Reverse the migrations.
           *
           * @return void
           */
          public function down()
          {
              Schema::drop('flights');
          }
      }

  > Порядок применения миграций, таблица Migrations

    # Таблица Migrations
      - Laravel автоматически создаёт таблицу Migrations.
      - Делает он это при первом применении миграции.
      - Таблица создаётся в соединении/БД по умолчанию.
      - Эта таблица имеет следующую структуру:

        migration                                 bath
        ----------------------------------------------
        2014_10_12_000000_migrationname1          1
        2014_10_13_100000_migrationname2          1
        2014_10_14_102340_migrationname3          2
        2014_10_15_123340_migrationname4          2
        2014_10_16_342300_migrationname5          2

      - В столбце migration содержится имя и timestamp миграции.
      - А в столбце bath id пакета, с которым она была применена.

    # Пакетный принцип применения миграций
      - Миграции в указанном каталоге применяются пакетами.
      - Команда make:migration применяет все ранее не примененные
        миграции из указанного каталога.
      - Факт применения каждой из миграций записывается в таблицу Migrations.
      - И помечается текущим timestamp'ом, и номером id пакета.

    # Пакетный принцип отмены миграций
      - Допустим, есть такая команда migrate:reset.
      - Эта команда выполняет down() всех миграций из последнего пакета.
      - В таблице Migrations ищет самыое большое значение в столбце bath.
      - И для миграций, помеченных этим id, и выполняет их методы down().


  > Создание миграции

    Нюанс: выбирать БД перед использованием Schema
    ----------------------------------------------
      - Код в up() и down() использует Schema Builder.
      - Последний работает с соединением и базой данных по умолчанию.
      - А в модульном приложении, у каждого модуля своя отдельная база данных.
      - Поэтому, перед применением Schema, надо менять БД по умолчанию на нужную.
      - Как это делать, см. в наработках по Laravel:
          "Б4. Как изменить базу данных по умолчанию для текущего запроса"


    // make:migration [имя]
    //----------------------------------------//
    // - Создать миграцию [имя]

      - Создавать миграции можно в консоли с помощью Artisan CLI.
      - Для создания миграции используется команда migrate:make.
      - Создадим миграцию с именем 'create_users_table'
      - При этом методы up и down будут абсолютно пусты.

        php artisan make:migration create_users_table


    // make:migration [имя] --path [адрес]
    //----------------------------------------//
    // - Создать миграцию [имя] в каталоге [адрес]

      - По умолчанию файл-миграция создаётся в каталоге 'app/database/migrations'.
      - Создадим файл-миграцию в каталоге 'app/migrations'

        php artisan make:migration foo --path=app/migrations


    // make:migration [имя] --table [таблица]
    //----------------------------------------//
    // - Создать миграцию [имя] для изменения таблицы [таблица]

      - Для этого надо при создании миграции указать опцию '--table'.
      - В значении опции надо указать имя таблицы, которую будет изменять миграция.
      - Эта опция влияет по сути только на содержание методов up и down.
      - Они уже не будут пусты, как при создании миграции без флагов.
      - А будут содержать выражение для изменения таблицы Schema::table.

        php artisan make:migration add_votes_to_user_table --table=users


    // make:migration [имя] --create [таблица]
    //----------------------------------------//
    // - Создать миграцию [имя] для создания таблицы [таблица]

      - Для этого надо при создании миграции указать опцию '--create'.
      - В значении опции надо указать имя таблицы, которую будет создавать миграция.
      - Эта опция влияет по сути только на содержание методов up и down.
      - Они уже не будут пусты, как при создании миграции без флагов.
      - А будут содержать выражение для изменения таблицы Schema::create.

        php artisan make:migration create_users_table --create=users


  > Использование миграций

    Нюанс: при использовании homestead, запускать эту команду в его терминале
    -------------------------------------------------------------------------
      - Если вы используете homestead.
      - То надо подключиться к нему по ssh.
      - Перейти там в каталог с проектом.
      - И запускать команды migrate... оттуда.
      - Так советуют делать разработчики Laravel 5.1.

    // migrate --path=[путь]
    //----------------------------------------//
    // - Запустить новые миграции по адресу [путь]
    // - Адрес указывается относительно корня приложения

      - Допустим, у нас есть модуль M1.
      - И все его миграции хранятся в каталоге:

          app/Domains/lk_zaste_ru/M1/Database/Migrations

      - И мы хотим запустить все новые миграции для него.
      - Для этого, выполняем такую команду:

          php artisan migrate --path="app/Domains/lk_zaste_ru/M1/Database/Migrations"


    // migrate --path=[путь] --force
    //----------------------------------------//
    // - Запустить новые миграции по адресу [путь], не запрашивая подтверждения в случае ожидаемой потери данных
    // - Адрес указывается относительно корня приложения

      - Выполнение миграции может привести к потере данных.
      - Ведь миграция может изменять структуру таблиц базы данных.
      - А в таблицах может храниться какая-то информация.
      - И при изменении структуры, эта информация может быть потеряна.
      - Чтобы защитить пользователей, команда отслеживает этот момент.
      - И в случае ожидаемой потери данных, запрашивает подтверждение.
      - Но если мы выполняем команду в коде, это приведёт к его зависанию.
      - Поэтому, можно отменить запрос этого подтверждения:

          php artisan migrate --path="app/Domains/lk_zaste_ru/M1/Database/Migrations" --force


    // migrate:rollback --path=[путь]
    //----------------------------------------//
    // - Выполнить down() всех ранее применённых миграций по адресу [путь] из последнего пакета
    // - Адрес указывается относительно корня приложения

      php artisan migrate:rollback --path="app/Domains/lk_zaste_ru/M1/Database/Migrations"


    // migrate:reset --path=[путь]
    //----------------------------------------//
    // - Выполнить down() ВСЕХ ранее применённых миграций по адресу [путь]
    // - Адрес указывается относительно корня приложения

      php artisan migrate:reset --path="app/Domains/lk_zaste_ru/M1/Database/Migrations"


    // migrate:reset --path=[путь]
    //----------------------------------------//
    // - Выполнить down() ВСЕХ ранее применённых миграций по адресу [путь], а затем снова их применить
    // - Адрес указывается относительно корня приложения

      php artisan migrate:refresh --path="app/Domains/lk_zaste_ru/M1/Database/Migrations"


    // migrate:status --path=[путь]
    //----------------------------------------//
    // - Посмотреть статус всех миграций по адресу [путь]
    // - Адрес указывается относительно корня приложения

      php artisan migrate:status --path="app/Domains/lk_zaste_ru/M1/Database/Migrations"


В6.  Заселение

  --------------------------------------
  Подоглавление:

    # Введение
    # Что из себя представляет класс-заселятель
    # Создание заселятелей

      make:seeder [имя]                     | создать класс-засеятель [имя] в database/seeders

    # Использование заселятелей

      $this->call('[имя]')                  | в методе run() засеятеля выполнить засеятель [имя]
      php artisan db:seed --class=[класс]   | выполнить засеятель [класс]

  --------------------------------------

  > Введение

    # Основное
      - Часто требуется добавить в БД некие тестовые данные.
      - В Laravel есть удобный функционал для этого.
      - В этой главе его описание.

    # Классы-заселятели
      - Заселятели, как и миграции, представляют из себя php-классы.
      - По умолчанию, в Laravel 5.1, они должны храниться в database/seeders


  > Что из себя представляет класс-заселятель

    # Общая информация
      - Заселятель - это php-файл.
      - Содержит 1 класс, наследующий от Illuminate\Database\Seeder
      - Должен содержать всего лишь 1 метод run()
      - В методе run() должен содержаться Query Builder скрипт.
      - Этот скрипт и должен наполнять нужные таблицы нужными данными.

    # Файл-заселятель (пример)

      <?php

        use DB;
        use Illuminate\Database\Seeder;
        use Illuminate\Database\Eloquent\Model;

        class DatabaseSeeder extends Seeder
        {
            /**
             * Run the database seeds.
             *
             * @return void
             */
            public function run()
            {
                DB::table('users')->insert([
                    'name' => str_random(10),
                    'email' => str_random(10).'@gmail.com',
                    'password' => bcrypt('secret'),
                ]);
            }
        }


  > Создание заселятелей

    // make:seeder [имя]
    //----------------------------------------//
    // - Создать класс-засеятель [имя] в database/seeders

      php artisan make:seeder UserTableSeeder


  > Использование заселятелей

    // $this->call('[имя]')
    //----------------------------------------//
    // - В методе run() засеятеля выполнить заселятель [имя]
    // - Пример в контексте класса-засеятеля:

      public function run()
      {
          Model::unguard();

          $this->call('UserTableSeeder');
          $this->call('PostsTableSeeder');
          $this->call('CommentsTableSeeder');
      }


    // php artisan db:seed --class=[класс]
    //----------------------------------------//
    // - Выполнить засеятель [класс]

      php artisan db:seed --class=UserTableSeeder


Г1.  Кэш

  --------------------------------------
  Подоглавление:

    - Настройка
    - Что такое memcached?
    - События при кэшировании
    - API для работы с кэшем в Laravel 5

      - put()             | сохр.знач.в кэш с указ.ключём на N минут, или до указанной даты/времени (перезаписать)
      - add()             | сохр.знач.в кэш с указ.ключём на N минут, или до указанной даты/времени (не перезаписывать, если такой ключ уже есть)
      - has()             | проверить, существует ли значение указанным ключем в кэше
      - get()             | извлечь значение из кэша или вернуть указанное значение
      - forever()         | сохранить значение в кэше навсегда (5 лет)
      - remember()        | извлечь, а если неудача, то сохранить указанное
      - rememberForever() | комбинация remember и forever
      - pull()            | извлечь значение по ключу из кэша, и удалить его оттуда
      - forget()          | удалить значение по ключу из кэша
      - store()           | доступ к не-дефолтному-хранилищу кэша
      - increment()       | (кроме драйвера database) инкрементировать значение в кэше по ключу
      - decrement()       | (кроме драйвера database) декрементировать значение в кэше по ключу
      - tags()->put()     | пометить кэш с указанным ключём указанными тегами, при его помещении в хранилище
      - tags()->get()     | 
      - tags()->flush()   | 

  --------------------------------------

  > Настройка

    > Введение
      - Laravel обеспечивает унифицированный API для нескольких систем кэширования.
      - Доступные варианты: "file", "database", "apc", "memcached", "redis", "array"
      - Конфиг для настройки кэша находится в файле 'config/cache.php'.
      - По умолчанию параметру 'default' установлено значение 'file'.
      - При этом сериализованные объекты сохраняются в файлах в папке 'storage/framework/cache'
      - Для крупных приложений рекомендуется не использовать 'file'-кэширование.
      - А вместо этого использовать системы кэширования в оперативке memcached/APC/redis.

    > Параметры в конфиге

      # 'default'
        - Какая система кэширования будет использоваться по умолчанию.
        - Какая бы ни была выбрана, API для работы используется один и тот же.
        - Доступные варианты: "file", "database", "apc", "memcached", "redis", "array"
        - Значение, которое стаит "из коробки": 'file'.

      # 'stores'
        - Массив, содержащий подмассивы, в каждом из которых описано хранилище кэша.
        - По умолчанию, здесь перечислены все стандартные хранилища, которые поддерживает Laravel 5.

      # 'prefix'
        - Используется при хранении кэша в оперативке (memcached, APC).
        - Хранить кэш в оперативке могут и другие приложения одновременно.
        - По этой причине могут возникать коллизии ключей сохраняемых значений.
        - Чтобы этого избежать, требуется придать уникальность ключам приложения.
        - Для этого им всем можно добавить некий уникальный префикс.
        - В этом параметре как раз этот префикс и можно указать.
        - "Из коробки" установлен префикс 'laravel'.

  > Что такое memcached?
    - Система кэширования, которая хранит данные в оперативной памяти.
    - Хранит данные в парах ключ/значение.
    - Её использование ускоряет работу, снижает нагрузку на БД и жёсткие диски.
    - Memcached устанавливается как отдельный сервис.
    - К нему можно получить доступ по сети.
    - Memcached не привязан к отдельным процессам PHP.
    - Благодаря этому кэш расшарен между процессами, что очень удобно.
    - Memcached может кэшировать любые типы данных, в т.ч. объекты.
    - Потому любые типы при помещении в кэш сериализуются в строку.

  > События при кэшировании

      Event::listen('cache.hit', function($key, $value) {
          //
      });

      Event::listen('cache.missed', function($key) {
          //
      });

      Event::listen('cache.write', function($key, $value, $minutes) {
          //
      });

      Event::listen('cache.delete', function($key) {
          //
      });  


  > API для работы с кэшем в Laravel 5

    // put()
    //----------------------------------------//
    // - сохр.знач.в кэш с указ.ключём на N минут, или до указанной даты/времени (перезаписать)
    // - если данные с этим ключём уже есть в кэше, они перезаписываются

      # Сохранения кэша на $minutes минут
      Cache::put('key', 'value', $minutes);

      # Сохранение кэша до указанной даты и времени
        - Получить датавременное значение: сейчас + 10 минут.
          
            $expiresAt = Carbon::now()->addMinutes(10);

        - Поместить данные в кэш до $expiresAt:

            Cache::put('key', 'value', $expiresAt);


    // add()
    //----------------------------------------//
    // - сохр.знач.в кэш с указ.ключём на N минут, или до указанной даты/времени (не перезаписывать, если такой ключ уже есть)
    // - если данные с этим ключём уже есть в кэше, они НЕ перезаписываются

      # Сохранения кэша на $minutes минут
      Cache::add('key', 'value', $minutes);

      # Сохранение кэша до указанной даты и времени
        - Получить датавременное значение: сейчас + 10 минут.
          
            $expiresAt = Carbon::now()->addMinutes(10);

        - Поместить данные в кэш до $expiresAt:

            Cache::add('key', 'value', $expiresAt);


    // has()
    //----------------------------------------//
    // - проверить, существует ли значение с указанным ключем в кэше
    // - неявно к 'key' добавляется prefix из настроек.

        if (Cache::has('key'))
        {
            //
        }


    // get()
    //----------------------------------------//
    // - извлечь значение из кэша или вернуть указанное значение

      # Извлечь из кэша значение по ключу
      $value = Cache::get('key');

      # Извлечь из кэша значение по ключу, а если такого нет, вернуть указанное значение
      $value = Cache::get('key', 'default');

      # И более гибкий вариант с анонимной функцией
      $value = Cache::get('key', function() { return 'default'; }      


    // forever()
    //----------------------------------------//
    // - сохранить значение в кэше навсегда (5 лет)

      # Сохранить значение с ключём в кэше на 5 лет:
      Cache::forever('key', 'value');


    // remember()
    //----------------------------------------//
    // - извлечь, а если неудача, то сохранить указанное

      - Метод сначала пытается извлечь из кэша значение с указанным ключём.
      - Если неудача, то он сохраняет указанное значение с этим же ключём.
      - В примере ниже попробуем извлечь из кэша значение 'users'.
      - А если не получится, то сохранить в кэш с ключём 'users' то,
        что вернёт анонимная фукнция.
      - Код:

        $value = Cache::remember('users', $minutes, function()
        {
            return DB::table('users')->get();
        });


    // rememberForever()
    //----------------------------------------//
    // - комбинация remember и forever

        $value = Cache::rememberForever('users', function()
        {
            return DB::table('users')->get();
        });    


    // pull()
    //----------------------------------------//
    // - извлечь значение по ключу из кэша, и удалить его оттуда

      $value = Cache::pull('key');


    // forget()
    //----------------------------------------//
    // - удалить значение по ключу из кэша

      Cache::forget('key');


    // store()
    //----------------------------------------//
    // - доступ к не-дефолтному-хранилищу кэша

      $value = Cache::store('foo')->get('key');


    // increment()
    //----------------------------------------//
    // - (кроме драйвера database) инкрементировать значение в кэше по ключу

      Cache::increment('key');
      Cache::increment('key', $amount);


    // decrement()
    //----------------------------------------//
    // - (кроме драйвера database) декрементировать значение в кэше по ключу

      Cache::decrement('key');
      Cache::decrement('key', $amount);


    // tags()->put()
    //----------------------------------------//
    // - (кроме драйверов file и database) пометить кэш с указанным ключём указанными тегами, при его помещении в хранилище

      - С помощью метода tags() можно создавать "меченный" кэш.
      - Любой кэш можно "пометить" 1 или более строками.
      - Примеры:

          Cache::tags('people', 'authors')->put('John', $john, $minutes);
          Cache::tags(['people', 'artists'])->put('Anne', $anne, $minutes);    


    // tags()->get()
    //----------------------------------------//
    // - (кроме драйверов file и database) 

      - Получить доступ к "меченному" кэшу просто так нельзя.
      - Для этого надо указать те же метки, в том же порядке, что при его добавлении.
      - Примеры:

          $anne = Cache::tags('people', 'artists')->get('Anne');
          $john = Cache::tags(['people', 'authors'])->get('John');      


    // tags()->flush(
    //----------------------------------------//
    // - (кроме драйверов file и database) 

      - Иногда требуется удалить весь "меченный" кэш с определенными метками.
      - Для этого можно испльзовать метод flush().
      - Будет удалён любой кэш, в котором присутствует хоть 1 из указанных меток.
      - Например, метка 'people' присутствует и в кэше 'john', и в кэше 'anne'.
      - Значит, следующая команда удалит оба этих кэша:

          Cache::tags('people')->flush();

      - А метка 'authors' присутствует только в кэше 'john'.
      - Следующая команда удалит только кэш 'john', но не 'anne':

          Cache::tags('authors')->flush();


Г2.  Коллекции (обертки для работы с массивами)

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Использование

  --------------------------------------

  > Ссылки

    # Полный API для работы с коллекциями здесь:
        http://laravel.com/api/master/Illuminate/Support/Collection.html


  > Введение
    - Для работы с массивами можно использовать класс-обертку
        Illuminate\Support\Collection
    - Он содержит много вспомогательных методов для работы с массивами.


  > Использование

    # Создать коллекцию
    $collection = collect([1, 2, 3]);
    $collection = Collection::make([1, 2, 3]);    

    # Пример

      $collection = collect(['taylor', 'abigail', null])->map(function($name)
      {
          return strtoupper($name);
      })
      ->reject(function($name)
      {
          return empty($name);
      });    


Г3.  Команды

  --------------------------------------
  Подоглавление:

    # Введение

      - Введение в проблему: повторное использование функционала
      - Решение: выносить повторно используемый функционал из контроллера в команды

    # Создание команд
    
      - Что из себя представляет команда
      - Как выглядит базовый класс-команда
      - Как выглядит добавление зависимостей в класс-команду
      - Создание нового класса-команды командой artisan
    
    # Запуск команд

      - 2 способа запустить команду
      - Запуск команды в фоновом режиме (через очередь задач)
      - Возврат значения из команды

  --------------------------------------

  > Введение
    
    Введение в проблему: повторное использование функционала
    --------------------------------------------------------
      - Допустим, у нас есть интерфейс, позволяющий создать нового пользователя.
      - У этого интерфейса есть контроллер.
      - Который может принять ajax-запрос, и создать в ответ нового пользователя.
      - Но что, если где-нибудь в другом месте кода, за пределами данного контроллера, 
        тоже требуется создать нового пользователя?
      - Например: в другом контроллере / в обработчике события / иных местах ?
      - То есть, возникает проблема повторного использования данного фукнционала.
      - Неужели надо делать CTRL + C, CTRL + V? 
      - Это была бы плохая оч. практика, такой код потом трудно поддерживать.

    Решение: выносить повторно используемый функционал из контроллера в команды
    ---------------------------------------------------------------------------
      - Итак, следует придерживаться следующего правила относительно
        функционала в контроллере:

          "Из контроллера в отдельные команды следует выносить весь
           тот функционал, который когда-либо предполагается использовать
           где-либо за пределами данного контроллера, либо даже в его 
           пределах более 1 раза".

      - Повторно используемый код следует инкапсулировать где-то.
      - Это может быть, скажем, отдельная функций (так я поступал в L4).
      - В L5 был предложен механизм команд.
      - В нём код функционала выносится в отдельные классы-файлы.


  > Создание команд

    Что из себя представляет команда
    --------------------------------
      - Это отдельный .php файл, который содержит 1 PHP-класс.
      - Имена файла и PHP-класса должны совпадать.
      - Класс наследует от класса Command.
      - Класс реализует интерфейс SelfHandling.
      - По умолчанию, класс содержит лишь 2 метода:

          1) __construct
            - Позволяет передать в команду нужные ресурсы

          2) handle
            - Собственно, код команды.
            - Сюда тоже через аргументы можно передать нужные классы.
            - Они будут автоматически вставлены из сервис-контейнера.

    Как выглядит базовый класс-команда
    ----------------------------------

      <?php namespace App\Jobs;

        use App\Jobs\Job;
        use Illuminate\Queue\SerializesModels;
        use Illuminate\Queue\InteractsWithQueue;
        use Illuminate\Contracts\Bus\SelfHandling;
        use Illuminate\Contracts\Queue\ShouldQueue;

        class PurchasePodcast extends Job implements SelfHandling {

          // Подключить пару трейтов
          use InteractsWithQueue, SerializesModels;

          // Конструктор
          public function __construct()
          {
            // ...
          }

          // Код команды
          public function handle()
          {
            // ...
          }

        }

      ?>

    Как выглядит добавление зависимостей в класс-команду
    ----------------------------------------------------

      class PurchasePodcast extends Job implements SelfHandling {

          protected $user, $podcast;

          // Конструктор
          public function __construct(User $user, Podcast $podcast)
          {
              $this->user = $user;
              $this->podcast = $podcast;
          }

          // Код команды
          public function handle()
          {
              
              // ... логика команды ...

              // Используем добавленные зависимости
              event(new PodcastWasPurchased($this->user, $this->podcast));
          
          }

      }

    Создание нового класса-команды командой artisan
    -----------------------------------------------
      - Новый класс-команду можно создать такой artisan-командой:

          php artisan make:command PurchasePodcast

      - Он по умолчанию создастся в каталоге app/Commands.


  > Запуск команд

    2 способа запустить команду
    ---------------------------

      1) Дурацкий: вызвать метод handle команды напрямую
        - Так делать не следует.
        - Не для этого функционал команд создавался.

      2) Умный: через фасад Bus

        Bus::dispatch( new PurchasePodcast(Auth::user(), Podcast::findOrFail($podcastId)) );      

    Запуск команды в фоновом режиме (через очередь задач)
    -----------------------------------------------------
      - Для этого класс-команда должен выглядеть несколько иначе.
      - Он должен также реализовывать интерфейс
          Illuminate\Contracts\Queue\ShouldQueue
      - И он должен использовать трейты :
          Illuminate\Queue\SerializesModels
          Illuminate\Queue\InteractsWithQueue
      - В итоге, он должен выглядеть так:

        <?php namespace App\Jobs;

          use App\Jobs\Job;

          use Illuminate\Queue\SerializesModels;
          use Illuminate\Queue\InteractsWithQueue;
          use Illuminate\Contracts\Bus\SelfHandling;
          use Illuminate\Contracts\Queue\ShouldQueue;

          class PurchasePodcast extends Job implements SelfHandling, ShouldQueue {

            use InteractsWithQueue, SerializesModels;

            // Конструктор
            public function __construct()
            {
              // ...
            }

            // Код команды
            public function handle()
            {
              // ...
            }

          }

        ?>

      - При создании такого класса через artisan, надо указать флаг --queued:

          php artisan make:command PurchasePodcast --queued

      - При использовании, в итоге, команда будет добавлена в очередь.

    Возврат значения из команды
    ---------------------------
      - Производится, только если команда запущена в "реалтайм".
      - А если через очередь задач, то не производится.


Г4.  Шифрование

  --------------------------------------
  Подоглавление:

    - Введение
    - Настройка
    - Использование

      - Зашифровать значение
      - Расшифровать зашифрованное значение

  --------------------------------------

  > Введение
    - Laravel имеет средства для сильного шифрования.
    - Они соответствуют Advanced Encryption Standart (AES).
    - Эффект достигается за счет PHP-дополнения openssl.
    - Ранее же использовалось PHP-дополнение Mcrypt.

  > Настройка
    - Перед использованием надо установить секретный ключ.
    - В config/app.php, свойство 'key'.
    - Он должен состоять ровно из 32 символов.
    - Если его не установить, зашифрованные значения будут не в безопасности. 

  > Использование

    # Зашифровать значение

        $encrypted = Crypt::encrypt('secret');

    # Расшифровать зашифрованное значение

        $decrypted = Crypt::decrypt($encryptedValue);


Г5.  Envoy

  --------------------------------------
  Подоглавление:

    # Введение
    # Установка
    # Настройка

      - Создание файла-конфига для Envoy
      - @servers    | cписок удаленных серверов
      - @setup      | определение переменных перед выполнением задач
      - @include    | подгрузить другой php-файл
      - @task       | определение задач

        - Задача при запуске выполнится на удал.сервере 'web'
        - Задача при запуске выполнится на удал.серверах 'web' и 'web-2' последовательно
        - Задача при запуске выполнится на удал.серверах 'web' и 'web-2' параллельно
        - Задача перед запуском требует подтверждения в окне терминала

    # Выполнение Envoy-задач

  --------------------------------------

  > Введение
    - Envoy позволяет выполнять задачи на удалённых серверах.
    - Envoy требует php >= 5.4.
    - Envoy работает только на операционных системах Mac / Linux.

  > Установка
    - Установить envoy можно через composer.
    - Надо добавить в requere файла composer.json следующее:

        "laravel/envoy": "~1.0"

    - И выполнить команды:

        composer update
        composer dump-autoload

    - Обновить Envoy можно так:

        composer global update

  > Настройка
    
    Создание файла-конфига для Envoy
    --------------------------------
      - Надо создать главный конфиг в корне проекта.
      - Он должен называться "Envoy.blade.php".
      - Списки серверов, задачи и прочее определяется здесь.

    @servers - cписок удаленных серверов
    ------------------------------------
      - @servers позволяет задать список удалённых серверов.
      - Каждый из них имеет своё имя.
      - При определении задачи можно уточнять, на каком сервере
        или серверах она должна будет выполнена.
      - Зададим список из 2-х серверов:

          @servers(['web' => '192.168.1.1', 'web-2' => '192.168.1.2'])      

    @setup - определение переменных перед выполнением задач
    -------------------------------------------------------
      - Здесь можно определить переменные.
      - Или выполнить другую общую PHP-работу внутри Envoy-файла.
      - Пример:

          @setup
              $now = new DateTime();

              $environment = isset($env) ? $env : "testing";
          @endsetup      

    @include - подгрузить другой php-файл
    -------------------------------------
      - Позволяет подгрузить любой php-файл.
      - Например:

          @include('vendor/autoload.php');

    @macro - определить набор задач для послед.выполнения
    -----------------------------------------------------
      - Допустим, есть у нас 2 задачи.
      - И часто надо их выполнить в определенной последовательности.
      - Тогда есть смысл задать макрос:

          // Макрос
          @macro('deploy')
              foo
              bar
          @endmacro

          // Определение задачи 1
          @task('foo')
              echo "HELLO"
          @endtask

          // Определение задачи 2
          @task('bar')
              echo "WORLD"
          @endtask       

      - Выполнить теперь этот макрос можно так: envoy run deploy

    @task - определение задач
    -------------------------
      - @task позволяет определить задачу.
      - Первым аргументом можно задать имя задачи.
      - Вторым аргументом указать, на каких удаленных серверах
        она должна будет выполниться.
      - Примеры:


        # Задача при запуске выполнится на удал.сервере 'web'
          
          @task('foo', ['on' => 'web'])
              ls -la
          @endtask


        # Задача при запуске выполнится на удал.серверах 'web' и 'web-2' последовательно
        # - Выполнение задач будет происходить последовательно.
        # - Сначала на сервере 'web', потом на сервере 'web-2'

          @task('deploy', ['on' => ['web', 'web-2']])
              cd site
              git pull origin {{ $branch }}
              php artisan migrate
          @endtask


        # Задача при запуске выполнится на удал.серверах 'web' и 'web-2' параллельно 
        # - Выполнение задач будет происходить параллельно.

          @task('deploy', ['on' => ['web-1', 'web-2'], 'parallel' => true])
              cd site
              git pull origin {{ $branch }}
              php artisan migrate
          @endtask


        # Задача перед запуском требует подтверждения в окне терминала
        @task('deploy', ['on' => 'web', 'confirm' => true])
            cd site
            git pull origin {{ $branch }}
            php artisan migrate
        @endtask  

  > Выполнение Envoy-задач
    - Выполнить Envoy-задачу или макрос можно так:

        envoy run foo

    - Передать переменные при выполнении задачи можно так.
    - Допустим, передадим переменную branch в envoy-задачу:

        envoy run deploy --branch=master

    - А вот так её можно принять и использовать:

        @servers(['web' => '192.168.1.1'])
        @task('deploy', ['on' => 'web'])
            cd site
            git pull origin {{ $branch }}
            php artisan migrate
        @endtask    


Г6.  Ошибки & логи

  --------------------------------------
  Подоглавление:

    - Настройка
    - Обработка ошибок
    - HTTP-исключения
    - Кастомные представления для HTTP-исключения 404, и прочих
    - Ведение лога

  --------------------------------------

  > Настройка
    
    Общая настройка в config/app.php
    --------------------------------
      - Средства журналирования настраиваются в классе 
          Illuminate\Foundation\Bootstrap\ConfigureLogging
      - Класс использует настройки из конфига config/app.php
      - По умолчанию logger настроен использовать дневные логи.
      - Однако, это поведение можно изменить в config/app.php,
        в свойстве 'log'.
      - Из коробки, Laravel поддерживает 4 режима ведения лога:
        1) single
        2) daily
        3) syslog
        4) errorlog

    Показывать ли ошибки в браузере, или нет?
    -----------------------------------------
      - Настраивается в св-ве debug, в конфиге config/app.php.
      - Оно по умолчанию ссылкается на переменную APP_DEBUG из .env.
      - Возможны 2 значения:

          1) true     | (по умолчанию) показывать все ошибки в браузере
            - Это ставить при разработке.
            - !!! Ни в коем случае не оставлять включенным на работающем проекте.
            - Иначе хакеры могут узнать, как что устроено у тебя в проекте.

          2) false    | не показывать все ошибки в браузере
            - Это ставить на работающем проекте.

  > Обработка ошибок
    
    Общее
    -----
      - Все ошибки обрабатываются классом App\Exceptions\Handler.
      - Он содержит 2 метода: report и render.

    Метод report
    ------------  
      - Используется для журналирования исключения.
      - Либо, для отправки их на внешние сервисы, как BugSnag.
      - По умолчанию, метод report просто передает исключение
        своему базовому классу, который его логгирует.
      - Однако, можно изменить это поведение.
      - Если надо обрабатывать разные исключения разными способами,
        можно использовать php-оператор instanceof:

        /**
         * Report or log an exception.
         *
         * Отличное место, чтобы посылать исключения на Sentry, Bugsnag, и т.д.
         *
         * @param  \Exception  $e
         * @return void
         */
        public function report(Exception $e)
        {
            if ($e instanceof CustomException)
            {
                //
            }

            return parent::report($e);
        }        

    Метод render
    ------------
      - Ответственен за преобразование исключения в http-ответ.
      - По умолчанию, исключение передаётся базовому классу, который
        формирует http-ответ за вас.
      - Однако, можно формировать и свой собственный ответ.
      - Св-во dontReport обработчика исключений содержит массив типов
        исключений, которые не должны быть зажурналированы. 
      - По умолчанию, исключения, выброшенные в результате ошибки
        404, не журналируются. Можно добавить и другие типы исключению в этот массив.

  > HTTP-исключения
    - Некоторые исключения описывают код ошибки с сервера.
    - Например, это может быть ошибка (404) "page not found". Или ошибка
      (401) "unauthorized error". Или ошибка (500), сгеренировання разработчиком.
    - Примеры:

        // Возбудить исключение 404
          App::abort(404);

        // Возбудить исключение 403 с сообщением
          App::abort(403, 'Unauthorized action.');

  > Кастомные представления для HTTP-исключения 404, и прочих
    - Их надо помещать в каталог resources/views/errors/
    - Имя представления должно совпадать с кодом ошибки.
    - Скажем, если нам нужно кастомное представление
      для исключения 404.
    - Кладём его по следующему адресу и со следующим именем:
        resources/views/errors/404.blade.php

  > Ведение лога

    > Введение
      - Laravel позволяет вести лог с помощью модуля Monolog.
      - Про модуль Monolog можно прочитать выше.
      - По умолчанию, Laravel создаёт 1 log-файл для приложения, который
        хранится по адресу "storage/laravel.log".

    > 7 видов сообщений для сохранения в лог
      - debug
      - info
      - notice
      - warning
      - error
      - critical
      - alert

    > Практика
      - Записывать информацию в лог можно так:

          Log::info('This is some useful information.');

          Log::warning('Something could be going wrong.');

          Log::error('Something is really going wrong.');

      - Получить доступ к используемому Laravel экземпляру Monolog можно так:

          $monolog = Log::getMonolog();

      - Можно зарегистрировать обработчикй событий, чтобы перехватывать
        в нём сообщения, передаваемые логу:

          Log::listen(function($level, $message, $context)
          {
              //
          });


Г7.  События

  --------------------------------------
  Подоглавление:

    # Введение
    # Класс-событие

      - Общая информация о классе-событии
      - Генерация класса-события artisan-командой
      - Как выглядит базовый класс-событие

    # Класс-обработчик события

      - Общая информация о классе-обработчике событий
      - Анонимная функция vs класс-обработчик
      - Генерация класса-обработчика события artisan-командой
      - Как выглядит базовый класс-обработчик события

    # Назначить событию обработчик(и)

      - Где назначать
      - Как назначить 1 класс-обработчик 1 событию
      - Как назначить N классов-обработчиков 1 событию
      - Как назначить 1 анон.функцию-обработчик 1 событию
      - Как остановить всплытие события в обработчике

    # Добавление сработавших обработчиков в очередь задач
    
      - О добавлении сработавших обработчиков в очередь задач
      - Сгенерировать класс-обработчик события (с пометкой "в очередь")

    # EventObserver: единое место для группы обработчиков

      - Суть EventObserver
      - Регистрация EventObserver
      - Пример базового класса EventObserver

    # Возбуждение событий

      - Event::fire() / event()   | возбудить событие

  --------------------------------------

  > Введение
    - В Lavarel 5 реализован функционал событий.
    - События в L5 можно условно разделить на 2 категории:

      1) Стандартные события L5
      2) Пользовательские события

    - По умолчанию, все события хранятся в: app/Events
    - А все обработчики событий в: app/Listeners
    - Любому событию можно назначать обработчик.
    - Обработчиком может быть:

      1) Отдельный PHP-класс с методом handle
      2) Простая анонимная функция.

  > Класс-событие
    
    Общая информация о классе-событии
    ---------------------------------
      - Обычный класс-событие содержит в себе лишь 1 метод: конструктор.
      - При возбуждении события, создаётся новый экземпляр этого класса.
      - При его создании, в конструтор можно передать аргументы.
      - И в конструкторе можно выполнить некую логику.
      - После чего сохранить в экземпляре события некую информацию.
      - Т.Е., класс-событие является всего-лишь контейнером для данных.
      - Эти данные потом можно получить в обработчике этого события.

    Генерация класса-события artisan-командой
    -----------------------------------------
      - Класс-событие появится в каталоге app/Events.
      - Команда:

          php artisan make:event [имя события без .php]

    Как выглядит базовый класс-событие
    ----------------------------------

      <?php namespace App\Events;

      use App\Podcast;
      use App\Events\Event;
      use Illuminate\Queue\SerializesModels;

      class PodcastWasPurchased extends Event
      {
          use SerializesModels;

          public $podcast;

          // Создать новый экземпляр события
          public function __construct(Podcast $podcast)
          {
              $this->podcast = $podcast;
          }
      }

  > Класс-обработчик события
    
    Общая информация о классе-обработчике событий
    ------------------------
      - Содержит в себе 2 метода, конструктор и handle.
      - Метод handle принимает в качестве аргумента объект-событие.
      - Из него и можно извлечь сохранённые в нём данные.
      - Которые можно использовать при обработке этого события.
      - Вся логика обработки находится в методе handle.
    
    Анонимная функция vs класс-обработчик
    -------------------------------------
      - Классы-обработчики событий, в общем, использовать не обязательно.
      - Вместо них можно использовать и анонимные функции (про это ниже).
      - Что использовать? По ситуации.

    Генерация класса-обработчика события artisan-командой
    -----------------------------------------------------
      - Можно artisan-командой.
      - Класс-обработчик появится в каталоге app/Handlers/Events.
      - Команда: 

          php artisan handler:event [имя обработчика без .php] --event=[имя события, которое должен обрабатывать, без .php]

    Как выглядит базовый класс-обработчик события
    ---------------------------------------------
      <?php namespace App\Listeners;

      use App\Events\PodcastWasPurchased;
      use Illuminate\Queue\InteractsWithQueue;
      use Illuminate\Contracts\Queue\ShouldQueue;

      class EmailPurchaseConfirmation
      {
          
          // Создать экземпляр планировщика событий
          public function __construct()
          {
              //
          }

          // Функция-обработчик события
          public function handle(PodcastWasPurchased $event)
          {
              // Access the podcast using $event->podcast...
          }
      }

  > Назначить событию обработчик(и)

    Где назначать
    -------------
      - В каком-нибудь сервис-провайдере.
      - По умолчанию, для этого предусмотрен: app/Providers/EventServiceProvider

    Как назначить 1 класс-обработчик 1 событию
    ------------------------------------------
      - Это можно сделать с помощью метода listen.
      - А также с помощью фасада Event.
      - Пример:

        - Назначим событию 'App\Events\PodcastWasPurchased'
        - Обработчик 'App\Handlers\Events\EmailPurchaseConfirmation'

          Event::listen('App\Events\PodcastWasPurchased', 
            'App\Handlers\Events\EmailPurchaseConfirmation');    

    Как назначить N классов-обработчиков 1 событию
    ----------------------------------------------  
      - Сделать это можно в св-ве $listen сервис-провайдера EventServiceProvider.
      - Пример:

          protected $listen = [
              'App\Events\PodcastWasPurchased' => [
                  'App\Handlers\Events\EmailPurchaseConfirmation1',
                  'App\Handlers\Events\EmailPurchaseConfirmation2',
              ],
          ];      

    Как назначить 1 анон.функцию-обработчик 1 событию
    -------------------------------------------------
      - Это можно сделать с помощью метода listen.
      - А также с помощью фасада Event.
      - Пример:

        - Назначим событию 'App\Events\PodcastWasPurchased'
        - Обработчик в виде анонимной функции:

          Event::listen('App\Events\PodcastWasPurchased', function($event)
          {
              // Handle the event...
          });        

    Как остановить всплытие события в обработчике
    ---------------------------------------------
      - Нужно вернуть из него false.
      - Например:

          Event::listen('App\Events\PodcastWasPurchased', function($event)
          {
              
              return false;

          });         

  > Добавление сработавших обработчиков в очередь задач
    
    О добавлении сработавших обработчиков в очередь задач
    -----------------------------------------------------
      - По умолчанию, сработавший обработчик выполняется немедленно и синхронно.
      - Но иногда требуется изменить это поведение.
      - И добавить эту задачу в конец очереди задач.
      - Это может быть продиктовано желанием распределить нагрузку на систему.
      - Либо, скажем, желанием выполнить определенные задачи, в определенном порядке.

    Сгенерировать класс-обработчик события (с пометкой "в очередь")
    ---------------------------------------------------------------
      - Можно artisan-командой.
      - Класс-обработчик появится в каталоге app/Handlers/Events.
      - В конце надо добавить флаг: '--queued'
      - Команда: 

          php artisan handler:event [имя обработчика без .php] --event=[имя события, которое должен обрабатывать, без .php] --queued

      - Отличаться такой класс-обработчик будет лишь в одном.
      - Он должен реализовывать интерфейс ShouldQueue.
      - Вот так:

          <?php namespace App\Listeners;

          use App\Events\PodcastWasPurchased;
          use Illuminate\Queue\InteractsWithQueue;
          use Illuminate\Contracts\Queue\ShouldQueue;

          class EmailPurchaseConfirmation implements ShouldQueue
          {
              //
          }      

  > EventObserver: единое место для группы обработчиков

    Суть EventObserver
    ------------------
      - Вообще-то, в оф.документации L5 это называется "Event Subscriber".
      - Это класс, в котором:

        1) Есть метод subscribe для назначения событиям обработчиков.
        2) Есть набор методов, которые и являются обработчиками.

      - В нём удобно группировать обработчики по какому либо признаку.
      - Например, собрать все обработчики событий для данного интерфейса.
      - Чтобы не создавать для каждого из них отдельный класс-обработчик.
      - Таким образом, мы уменьшаем кол-во файлов, и увеличиваем простоту.
      - Но, конечно, если обработчики велики, можно и отдельные файлы создавать.

    Регистрация EventObserver
    -------------------------
      - Зарегистрировать EventObserver можно в любом сервис-провайдере.
      - По умолчанию, для этого предусмотрен: app/Providers/EventServiceProvider
      - В его функции boot можно написать что-то вроде:

          $subscriber = new UserEventHandler;
          Event::subscribe($subscriber);        

    Пример базового класса EventObserver
    ------------------------------------

      class UserEventHandler {

          // Обработчик 1
          public function onUserLogin($event)
          {
              // ...
          }

          // Обработчик 2
          public function onUserLogout($event)
          {
              // ...
          }

          // Назначение событиям обработчиков
          public function subscribe($events)
          {
              $events->listen('App\Events\UserLoggedIn', 'UserEventHandler@onUserLogin');
              $events->listen('App\Events\UserLoggedOut', 'UserEventHandler@onUserLogout');
          }

      }

  > Возбуждение событий

    Event::fire() / event() 
    -----------------------

      # Общая информация
        - Эти 2 метода идентичны, и позволяют возбудить событие.

      # Event::fire()
        - Здесь мы пользуемся фасадом Event.
        - Как обычно, надо не забывать его импортировать в текущее пр.имён.
        - В качестве аргумента принимает экземпляр класса-события, которое надо возбудить.

      # event()
        - Это просто вспомогательная функция.
        - Она упрощает жизнь, не надо париться с импортом фасада в текущее пр.имён.
        - В качестве аргумента принимает экземпляр класса-события, которое надо возбудить.

      # Примеры использования

        Event::fire(new MyEventClass($arg1, $arg2));
        event(new MyEventClass($arg1, $arg2));


Г8.  Хранилища (в ФС / облаке)

  --------------------------------------
  Подоглавление:

    # Введение
    # Настройка
    # Основы использования

      - Фасад Storage для взаимодействия с ФС
      - disk()            | по имени получить ссылку на объект, представляющий диск
      - exists()          | проверить, существует ли файл по указанному пути
      - get()             | извлечь файл
      - put()             | разместить файл
      - prepend()         | добавить текст в начало файла
      - append()          | добавить текст в конец файла
      - delete()          | удалить файл / файлы
      - copy()            | скопировать файл в другое место
      - move()            | переместить файл в другое место
      - size()            | получить размер файла
      - lastModified()    | получить дату последнего изменения файла 
      - files()           | извлечь все файлы из каталога (не рекурсивно)
      - allFiles()        | извлечь все файлы из каталога (рекурсивно)
      - directories()     | извлечь все каталоги в каталоге (не рекурсивно)  
      - allDirectories()  | извлечь все каталоги в каталоге (рекурсивно)   
      - makeDirectory()   | создать каталог
      - deleteDirectory() | удалить каталог

    # Кастомные файловые системы
    # Внимание! Установка storage path
    # Внимание! Особенности использования Storage в командах

  --------------------------------------

  > Введение
    - Laravel обеспечивает отличный слой абстракции для работы с ФС.
    - Всё это благодаря PHP-пакету Flysystem от Frank de Jonge.
    - Пакет обеспечивает один и тот же API для работы с:

        - Локальной файловой системой
        - Amazon S3
        - Rackspace Cloud Storage

  > Настройка
    
    Конфигурация
    ------------
      - Настройки лежат в конфиге config/filesystems.php
      - Тут можно настроить все необходимые хранилища в disks.
      - Указать хралище по умолчанию в default.
      - И указать облачное хранилище по умолчанию в cloud.
      - В disks => local => root можно указать корн.кат.локальной ФС.

    Перед использованием Amazon S3 и Rackspace, установить пакеты
    -------------------------------------------------------------

      Amazon S3: league/flysystem-aws-s3-v2 ~1.0
      Rackspace: league/flysystem-rackspace ~1.0

  > Основы использования


    Фасад Storage для взаимодействия с ФС
    -------------------------------------
      - Его можно использовать для взаимодействия с настроенными ФС.


    // disk()
    //----------------------------------------//
    // - по имени получить ссылку на объект, представляющий диск

      $disk = Storage::disk('s3');
      $disk = Storage::disk('local');


    // exists()
    //----------------------------------------//
    // - проверить, существует ли файл по указанному пути

      # Проверить на диске s3
      $exists = Storage::disk('s3')->exists('file.jpg');

      # Проверить на диске по умолчанию
      if (Storage::exists('file.jpg'))
      {
          //
      }


    // get()
    //----------------------------------------//
    // - извлечь файл

      $contents = Storage::get('file.jpg');


    // put()
    //----------------------------------------//
    // - разместить файл
    
      Storage::put('file.jpg', $contents);


    // prepend()
    //----------------------------------------//
    // - добавить текст в начало файла     

      Storage::prepend('file.log', 'Prepended Text');


    // append()
    //----------------------------------------//
    // - добавить текст в конец файла   

      Storage::append('file.log', 'Appended Text');


    // delete()
    //----------------------------------------//
    // - удалить файл / файлы

      Storage::delete('file.jpg');
      Storage::delete(['file1.jpg', 'file2.jpg']);    


    // copy()
    //----------------------------------------//
    // - скопировать файл в другое место

      Storage::copy('old/file1.jpg', 'new/file1.jpg');


    // move()
    //----------------------------------------//
    // - переместить файл в другое место

      Storage::move('old/file1.jpg', 'new/file1.jpg');


    // size()
    //----------------------------------------//
    // - получить размер файла

      $size = Storage::size('file1.jpg');


    // lastModified()
    //----------------------------------------//
    // - получить дату последнего изменения файла   

      $time = Storage::lastModified('file1.jpg');


    // files()
    //----------------------------------------//
    // - извлечь все файлы из каталога (не рекурсивно)

      $files = Storage::files($directory);


    // allFiles()
    //----------------------------------------//
    // - извлечь все файлы из каталога (рекурсивно)

      $files = Storage::allFiles($directory);


    // directories()
    //----------------------------------------//
    // - извлечь все каталоги в каталоге (не рекурсивно)  

      $directories = Storage::directories($directory);


    // allDirectories()
    //----------------------------------------//
    // - извлечь все каталоги в каталоге (рекурсивно)   

      $directories = Storage::allDirectories($directory);


    // makeDirectory()
    //----------------------------------------//
    // - создать каталог 

      Storage::makeDirectory($directory);


    // deleteDirectory()
    //----------------------------------------//
    // - удалить каталог    

      Storage::deleteDirectory($directory);

  > Кастомные файловые системы
    - В L5 есть драйверы для Flysystem для нескольких файловых хранилищь.
    - А именно:

        - Локальной файловой системой
        - Amazon S3
        - Rackspace Cloud Storage

    - Однако, ничто не мешает создать и использовать драйверы для других хранилищь.
    - В руководстве по L5 утверждают, что это не так уж и сложно.
    - Для этого надо:

        1) Создать сервис-повайдер
          - Например: DropboxFilesystemServiceProvider

        2) В методе boot сервис-провайдера
          - Вызвать метод extend через фасад Disk
          - Первым аргументом передать имя драйвера.
          - А вторым анон.функцию с аргументами $app и $config
          - Анон.функ. должна вернуть экземпляр класа 
            League\Flysystem\Filesystem

        3) Добавить новую ФС в config/filesystems.php

    - Пример для dropbox:

      <?php namespace App\Providers;

      use Storage;
      use League\Flysystem\Filesystem;
      use Dropbox\Client as DropboxClient;
      use League\Flysystem\Dropbox\DropboxAdapter;
      use Illuminate\Support\ServiceProvider;

      class DropboxFilesystemServiceProvider extends ServiceProvider {

          public function boot()
          {
              Storage::extend('dropbox', function($app, $config)
              {
                  $client = new DropboxClient($config['accessToken'], $config['clientIdentifier']);

                  return new Filesystem(new DropboxAdapter($client));
              });
          }

          public function register()
          {
              //
          }

      } 

  > Внимание! Установка storage path
    - Storage path можно установить в local->root в config/filesystems.php.
    - Это будет корневым каталогом для всех путей, используемых Storage.
    - Рекомендуется установить в качестве storage path: 

        base_path('app')        // т.е. каталог app, лежащий в корне приложения

    - Тогда, скажем, вот так можно узнать вес файла routes.php:

        $size = Storage::size('routes.php');

  > Внимание! Особенности использования Storage в командах
    
    # Суть проблемы
      - Допустим, имеется у нас 5 команд, использующих Storage.
      - В каждой из этих команд указывается свой root, таким образом:

          config(['filesystems.disks.local.root' => base_path('vendor/4gekkman')]);

      - И есть у нас artisan-команда, запускающая по очереди эти команды.
      - При запуске первой команды, для фасада Storage создаётся новый
        экземпляр Filesystem, который всасывает строку с root из конфига.
      - При запуске 2-й и последующих команд, фасад Storage будет
        возвращать СТАРЫЙ ЭКЗЕМПЛЯР, с root ИЗ ПЕРВОЙ КОМАНДЫ.
      - Поэтому, во 2-й и последующих командах, изменение root в 
        конфиге перед использованием Storage НЕ БУДЕТ ИМЕТЬ ЭФФЕКТА.

    # Решение
      - Надо в каждой команде создавать новый экземпляр Filesystem.
      - Перед созданием, конечно, изменив root в конфиге на нужный (см.выше).
      - Новый экземпляр всосёт из конфига этот root, и всё будет как надо.
      - Удобнее всего это делать в конструкторе класса, вот так:

          $this->storage = new \Illuminate\Filesystem\FilesystemManager(app());

      - И далее в коде обращаться к нему через это свойство.
      - Например, получить список всех каталогов в root-каталоге:

          $dirs = $this->storage->directories();



Г9.  Хэширование

  --------------------------------------
  Подоглавление:

    - Ссылки
    - Введение
    - Про хэширование в общем
    - Про расшифровку хэшей радужными таблицами
    - Класс Hash в Laravel

  --------------------------------------

  > Ссылки

    - Статья "Безопасное хранение паролей" на хабре про bcrypt:
        http://habrahabr.ru/post/159043/

    - Статья "Как надо хэшировать пароли, а как не надо" на хабре про bcrypt:
        http://habrahabr.ru/post/210760/

    - Статья про радужные таблицы и взлом хэшей:
        http://habrahabr.ru/post/130965/

    - Статья "криптостойкость 1000-кратного хэшированного пароля"
        http://habrahabr.ru/post/100301/

    - Статья "Хэширование" на wiki:
        https://ru.wikipedia.org/wiki/Хеширование

  > Введение
    - Часто может требоваться захэшировать какие-либо данные.
    - Хэш-функции md5 и sha-1 признаны не надёжными, лучше от них отказатсья.
    - Вместо них рекомендуется использовать хэш-фукнцию bcrypt.
    - О ней, и как её использовать в Laravel, и идёт речь в этой главе.

  > Про хэширование в общем

    > Общее
      - Хэширование - процесс одностороннего преобразование входных данных
        в выходную строку заданной длины.
      - Хэш-функция: выполняющая процесс хэширования.
      - Хэш - строка, результат работы хэш-функции.
      - Хэш-функция всегда выдаёт один и тот же хэш для одних и тех же данных.
      - Хэш не даёт даже намёка о том, что из себя представляли исходные данные.
      - Предполагается, что обратно получить из хэша исходные данные нельзя.

    > Криптографические хэши
      - Существуют криптографические и нет хэш-функции.
      - К криптографическим относятся: md5, sha-1, bcrypt и т.д.
      - К не крпитографическим: функции для создания контрольных сумм и т.д.
      - Криптографические хэши отличаются следующим:

        # Необратимость
            Для заданного хэша m должно быть вычислительно
            неосуществимо найти блок данных X, для которого H(X) == m.

        # Стойкость к коллизиям 1-го рода
            Для заданных данных М должно быть вычислительно
            неосуществимо подобрать другие данные N != M, для для которых
            H(N) == H(m)

        # Стойкость к коллизиям 2-го рода
            Должно быть вычислительно неосуществимо подобрать пару
            данных M и N, имеющих одинаковый хэш.

    > Зачем нужно
      - Например, надо нам сохранит пароль "ivan1234" в базе данных.
      - А пароль этот принадлежит пользователю Ивану.
      - Можно хранить пароль в открытом виде, прямо так: "ivan1234".
      - Но тогда его могут украсть: админ, взломать базу и т.д.
      - И злоумышленник по этому паролю сможет авторизваться, как Иван.
      - Чтобы этого не произошло, лучше не хранить пароль в открытом виде.
      - А хранить хэш пароля.
      - Если злоумышленник получит хэш, он не сможет узнать пароль.
      - Конечно, он может попытаться взломать хэш, чтобы узнать пароль.
      - Но взломать bcrypt сегодня мегасложно.
      - Вот Иван хочет авторизоваться, и вводит свой пароль.
      - Мы хэшируем этот пароль и сравниваем результат с хэшем в базе.
      - Если совпадает, то авторизуем Ивана.


  > Про расшифровку хэшей радужными таблицами
    - Злоумышленник заранее составляет таблицу "пароль" - "хэш".
    - Затем, допустим, он украл хэш пароля какого-нибудь пользователя.
    - И может за пару секунд найти его в этой радужной таблице.
    - Радужная таблица может быть гигантской - терабайты информации.
    - В сети открыто валяются радужные таблицы по популярным хэщ-функциям.

  > Класс Hash в Laravel

    > Как работает
      - Для хэширования использует php-функцию password_hash.
      - password_hash($value, PASSWORD_BCRYPT, array('cost' => $cost)).
      - Подробнее о ней в официальной справке php:
          http://nl1.php.net/manual/en/function.password-hash.php

    > Функционал

        # Захэшировать пароль функцией bcrypt

          $password = Hash::make('secret');

        # Сравнить строку и захэшированный пароль
          - Допустим, пользователь решил авторизоваться в приложении.
          - И он ввёл пароль.
          - А у нас в базе сохранён пароль в виде хэша.
          - Надо же теперь как то их сравнить, чтобы определить, правильный
            ли пароль ввёл пользователь?

          if (Hash::check('secret', $hashedPassword)) {
              // The passwords match...
          }

        # Проверить, требуется ли перехэшировать пароль
          - [Видимо бывают случаи, когда требуется...]

          if (Hash::needsRehash($hashed) {
              $hashed = Hash::make('secret');
          }


Г10.  Вспомогательные функции общего назначения 

  --------------------------------------
  Подоглавление:

    Введение
    1. Массивы

      - array_add()     | добавить в массив пару 'key' => 'value'
      - array_set()     | добавить в массив пару 'key' => 'value' (dot-нотация)

      - array_except()  | удалить эл-т с указанным ключём 
      - array_forget()  | удалить эл-т с указанным ключём в dot-нотации  
      
      - array_sort()    | сортировка массива с использованием анон.функции
      - array_where()   | фильтрация массива с использованием анон.функции
      
      - array_first()   | возвращает 1-й эл-т массива, прошедший true-тест 
      - array_last()    | возвращает последний эл-т массива, прошедший true-тест 
      
      - head()          | извлечь первый элемент массива
      - last()          | извлечь последний элемент массива
      
      - array_fetch()   | извлечь массив значений по ключу в dot-нотации (аналог array_pluck, только ключ должен быть в dot-нотации)
      - array_flatten() | извлечь массив значений (извлекает все значения со всех уровней многоур.массива) 
      - array_get()     | извлечь значение по ключу в dot-нотации
      - array_only()    | извлечь массив указанных пар ключ/значение (принимает массив ключей, пары с этими ключами и извлекает.)
      - array_pluck()   | извлечь массив значений по ключу
      - array_pull()    | извлечь значение по ключу, и удалить его из массива

      - array_dot()     | сделать из многоур.массива одноуровневый, используя dot-нотацию, и вернуть результат
      - array_divide()  | дербанит массив на 2, с ключами и значениями
    
    2. Пути

      - app_path()      | абсолютный путь к каталогу app
      - base_path()     | абсолютный путь к корню приложения
      - config_path()   | абсолютный путь к каталогу config
      - public_path()   | абсолютный путь к каталогу public
      - storage_path()  | абсолютный путь к каталогу storage

    3. Роутинг

      - get()       | зарегистрировать GET-роут в роутере
      - post()      | зарегистрировать POST-роут в роутере
      - put()       | зарегистрировать PUT-роут в роутере
      - patch()     | зарегистрировать PATCH-роут в роутере
      - delete()    | зарегистрировать DELETE-роут в роутере
      - resource()  | зарегистрировать RESTful ресурсный роут в роутере

    4. Строки

      - camel_case      | конвертирует строку в верблюжью нотацию (fooBar)
      - studly_case     | конвертирует строку в studly-нотацию (FooBar)
      - snake_case      | конвертирует строку в змеиную нотацию (foo_bar)
      
      - class_basename  | извлекает имя класса, отбрасывая пр.имён
      
      - ends_with       | проверяет, заканчивается ли строка указанной подстрокой
      - starts_with     | проверяет, начинается ли строка указанной подстрокой
      - str_contains    | проверить, содержит ли строка указанную подстроку

      - e               | запускает для строки htmlentities, с поддержкой UTF-8
      - str_limit       | ограничивает кол-во букв в строке, обрезает лишнее, заканчивает указанной подстрокой
      - str_finish      | добавить в конец строки подстроку, удалить её повторы
      - str_is          | матчится ли строка паттерном, в котором можно использовать *
      - str_plural      | конвертировать строку во множеств.число (только eng)
      - str_singular    | конвертировать строку в единств.число (только eng)
      - str_random      | сгенерировать случайную строку указанной длины
      - str_slug        | создать строку-идентификатор (slug) с учётом ограничений URL.
      - trans           | перевести переданную языковую строку
      - trans_choice    | перевести переданную языковую строку с интонацией

    5. URL

      - action        | сгенерировать URL на метод контроллера
      - route         | сгенерировать URL на именованный роут
      - asset         | сгенерировать URL на указанный ресурс
      - secure_asset  | сгенерировать HTML-ссылку на указанный ресурс используя HTTPS
      - secure_url    | сгенерировать абсолютный URL на указанный путь используя HTTPS
      - url           | сгенерировать абсолютный URL на указанный путь

    6. Разное

      - csrf_token  | получить значение текущего CSRF токена
      - dd          | вывести dump переменной и завершить скрипт
      - elixir      | get the path to a versioned Elixir file
      - env         | вернуть значение переменной среды (из .env), или вернуть значение по умолчанию
      - event       | возбудить указанное событие
      - value       | вернуть значение, возвращаемое аргументом-анонимной функцией
      - view        | получить экземпляр представления по указанному адресу
      - with        | вернуть объект указанного класса


  --------------------------------------

  //----------//
  // Введение //
  //----------//

    - Вместе с Laravel поставляется набор вспомогательных функций.
    - Это функции, дополняющие стандартный набор PHP по ряду направлений.
    - Направления: массивы, пути, строки, URL и прочие.
    - В этом пункте будут перечислены и описаны все эти функции.


  //------------//
  // 1. Массивы //
  //------------//

    Что такое dot-нотация?
    ----------------------
      - Это нотация для ключей массивов.
      - Её используют некоторые из нижепредставленных функций.
      - Она используется при работе с многомерными массивами.
      - Допустим, есть у нас вот такой массив:

          $arr = array('foo' => array('bar' => 'ivan'));

      - С использованием dot-нотации ключ 'bar' можно обозначить так:

          foo.bar

      - Благодаря такому приёму любой многомерный массив можно представить
        в виде одномерного с dot-нотацией.


    // array_add()
    //----------------------------------------//
    // - добавить в массив пару 'key' => 'value'

      $array = ['foo' => 'bar'];
      $array = array_add($array, 'key', 'value');


    // array_set()
    //----------------------------------------//
    // - добавить в массив пару 'key' => 'value' (dot-нотация)

      $array = ['names' => ['programmer' => 'Joe']];
      array_set($array, 'names.editor', 'Taylor');


    // array_except()
    //----------------------------------------//
    // - удалить эл-т с указанным ключём

      $array = array_except($array, ['keys', 'to', 'remove']);


    // array_forget()
    //----------------------------------------//
    // - удалить эл-т с указанным ключём в dot-нотации  

      $array = ['names' => ['joe' => ['programmer']]];
      array_forget($array, 'names.joe');


    // array_sort()
    //----------------------------------------//
    // - сортировка массива с использованием анон.функции 

      $array = [
          ['name' => 'Jill'],
          ['name' => 'Barry']
      ];

      $array = array_values(array_sort($array, function($value)
      {
          return $value['name'];
      }));


    // array_where()
    //----------------------------------------//
    // - фильтрация массива с использованием анон.функции

      $array = [100, '200', 300, '400', 500];

      $array = array_where($array, function($key, $value)
      {
          return is_string($value);
      });

      // Array ( [1] => 200 [3] => 400 )


    // array_first()
    //----------------------------------------//
    // - возвращает 1-й эл-т массива, прошедший true-тест 

      $array = [100, 200, 300];

      $value = array_first($array, function($key, $value)
      {
          return $value >= 150;
      });


    // array_last()
    //----------------------------------------//
    // - возвращает последний эл-т массива, прошедший true-тест 

      $array = [350, 400, 500, 300, 200, 100];

      $value = array_last($array, function($key, $value)
      {
          return $value > 350;
      });

      // 500


    // head()
    //----------------------------------------//
    // - извлечь первый элемент массива

      $first = head($this->returnsArray('foo'));


    // last()
    //----------------------------------------//
    // - извлечь последний элемент массива

      $last = last($this->returnsArray('foo'));


    // array_fetch()
    //----------------------------------------//
    // - извлечь массив значений по ключу в dot-нотации (аналог array_pluck, только ключ должен быть в dot-нотации) 

      $array = [
          ['developer' => ['name' => 'Taylor']],
          ['developer' => ['name' => 'Dayle']]
      ];

      $array = array_fetch($array, 'developer.name');

      // ['Taylor', 'Dayle'];


    // array_flatten()
    //----------------------------------------//
    // - извлечь массив значений (извлекает все значения со всех уровней многоур.массива) 

      $array = ['name' => 'Joe', 'languages' => ['PHP', 'Ruby']];
      $array = array_flatten($array);
      // ['Joe', 'PHP', 'Ruby'];


    // array_get()
    //----------------------------------------//
    // - извлечь значение по ключу в dot-нотации
    // - для объектов надо испольовать object_get

      $array = ['names' => ['joe' => ['programmer']]];
      $value = array_get($array, 'names.joe');
      $value = array_get($array, 'names.john', 'default');


    // array_only()
    //----------------------------------------//
    // - извлечь массив указанных пар ключ/значение (принимает массив ключей, пары с этими ключами и извлекает.)

      $array = ['name' => 'Joe', 'age' => 27, 'votes' => 1];
      $array = array_only($array, ['name', 'votes']);


    // array_pluck()
    //----------------------------------------//
    // - извлечь массив значений по ключу

      $array = [['name' => 'Taylor'], ['name' => 'Dayle']];
      $array = array_pluck($array, 'name');
      // ['Taylor', 'Dayle'];


    // array_pull()
    //----------------------------------------//
    // - извлечь значение по ключу, и удалить его из массива

      $array = ['name' => 'Taylor', 'age' => 27];
      $name = array_pull($array, 'name');


    // array_dot()
    //----------------------------------------//
    // - сделать из многоур.массива одноуровневый, используя dot-нотацию, и вернуть результат

      $array = ['foo' => ['bar' => 'baz']];
      $array = array_dot($array);
      // ['foo.bar' => 'baz'];


    // array_divide()
    //----------------------------------------//
    // - дербанит массив на 2, с ключами и значениями

      $array = ['foo' => 'bar'];
      list($keys, $values) = array_divide($array);


  //---------//
  // 2. Пути //
  //---------//

    // app_path()
    //----------------------------------------//
    // - дербанит массив на 2, с ключами и значениями

      $path = app_path();


    // base_path()
    //----------------------------------------//
    // - дербанит массив на 2, с ключами и значениями

      $path = base_path();


    // config_path()
    //----------------------------------------//
    // - дербанит массив на 2, с ключами и значениями

      $path = config_path();


    // public_path()
    //----------------------------------------//
    // - дербанит массив на 2, с ключами и значениями

      $path = public_path();


    // storage_path()
    //----------------------------------------//
    // - дербанит массив на 2, с ключами и значениями

      $path = storage_path();


  //------------//
  // 3. Роутинг //
  //------------//

    // get()
    //----------------------------------------//
    // - зарегистрировать GET-роут в роутере

      get('/', function() { return 'Hello World'; });


    // post()
    //----------------------------------------//
    // - зарегистрировать POST-роут в роутере

      post('foo/bar', 'FooController@action');


    // put()
    //----------------------------------------//
    // - зарегистрировать PUT-роут в роутере

      put('foo/bar', 'FooController@action');


    // patch()
    //----------------------------------------//
    // - зарегистрировать PATCH-роут в роутере

      patch('foo/bar', 'FooController@action');


    // delete()
    //----------------------------------------//
    // - зарегистрировать DELETE-роут в роутере

      delete('foo/bar', 'FooController@action');


    // resource()
    //----------------------------------------//
    // - зарегистрировать RESTful ресурсный роут в роутере

      resource('foo', 'FooController');           


  //-----------//
  // 4. Строки //
  //-----------//

    // camel_case()
    //----------------------------------------//
    // - конвертирует строку в верблюжью нотацию (fooBar)

      $camel = camel_case('foo_bar');  // fooBar


    // studly_case()
    //----------------------------------------//
    // - конвертирует строку в studly-нотацию (FooBar)

      $value = studly_case('foo_bar');  // FooBar


    // snake_case()
    //----------------------------------------//
    // - конвертирует строку в змеиную нотацию (foo_bar)

      $snake = snake_case('fooBar');  // foo_bar


    // class_basename()
    //----------------------------------------//
    // - извлекает имя класса, отбрасывая пр.имён

      $class = class_basename('Foo\Bar\Baz');   // Baz


    // ends_with()
    //----------------------------------------//
    // - проверяет, заканчивается ли строка указанной подстрокой

      $value = ends_with('This is my name', 'name');


    // starts_with()
    //----------------------------------------//
    // - проверяет, начинается ли строка указанной подстрокой

      $value = starts_with('This is my name', 'This');


    // str_contains()
    //----------------------------------------//
    // - проверить, содержит ли строка указанную подстроку

      $value = str_contains('This is my name', 'my');


    // e()
    //----------------------------------------//
    // - запускает для строки htmlentities, с поддержкой UTF-8

      $entities = e('<html>foo</html>');


    // str_limit()
    //----------------------------------------//
    // - ограничивает кол-во букв в строке, обрезает лишнее, заканчивает указанной подстрокой

      str_limit($value, $limit = 100, $end = '...')
      $value = str_limit('The PHP framework for web artisans.', 7);   // The PHP...        


    // str_finish()
    //----------------------------------------//
    // - добавить в конец строки подстроку, удалить её повторы

      $string = str_finish('this/string', '/');  // this/string/


    // str_is()
    //----------------------------------------//
    // - матчится ли строка паттерном, в котором можно использовать *

      $value = str_is('foo*', 'foobar');


    // str_plural()
    //----------------------------------------//
    // - конвертировать строку во множеств.число (только eng)

      $plural = str_plural('car');


    // str_singular()
    //----------------------------------------//
    // - конвертировать строку в единств.число (только eng) 

      $singular = str_singular('cars');


    // str_random()
    //----------------------------------------//
    // - сгенерировать случайную строку указанной длины

      $string = str_random(40);


    // str_slug()
    //----------------------------------------//
    // - создать строку-идентификатор (slug) с учётом ограничений URL.

      str_slug($title, $separator);


    // trans()
    //----------------------------------------//
    // - перевести переданную языковую строку

      $value = trans('validation.required'):


    // trans_choice()
    //----------------------------------------//
    // - перевести переданную языковую строку с интонацией

      $value = trans_choice('foo.bar', $count);


  //--------//
  // 5. URL //
  //--------//

    // action()
    //----------------------------------------//
    // - сгенерировать URL на метод контроллера

      $url = action('HomeController@getIndex', $params);


    // route()
    //----------------------------------------//
    // - сгенерировать URL на именованный роут

      $url = route('routeName', $params);


    // asset()
    //----------------------------------------//
    // - сгенерировать URL на указанный ресурс

      $url = asset('img/photo.jpg');


    // secure_asset()
    //----------------------------------------//
    // - сгенерировать HTML-ссылку на указанный ресурс используя HTTPS

      echo secure_asset('foo/bar.zip', $title, $attributes = []);


    // secure_url()
    //----------------------------------------//
    // - сгенерировать абсолютный URL на указанный путь используя HTTPS

      echo secure_url('foo/bar', $parameters = []);


    // url()
    //----------------------------------------//
    // - сгенерировать абсолютный URL на указанный путь

      echo url('foo/bar', $parameters = [], $secure = null);


  //-----------//
  // 6. Разное //
  //-----------//

    // csrf_token()
    //----------------------------------------//
    // - получить значение текущего CSRF токена

      $token = csrf_token();


    // dd()
    //----------------------------------------//
    // - вывести dump переменной и завершить скрипт

      dd($value);


    // elixir()
    //----------------------------------------//
    // - get the path to a versioned Elixir file

      elixir($file);


    // env()
    //----------------------------------------//
    // - вернуть значение переменной среды (из .env), или вернуть значение по умолчанию

      env('APP_ENV', 'production')


    // event()
    //----------------------------------------//
    // - возбудить указанное событие

      event('my.event');


    // value()
    //----------------------------------------//
    // - вернуть значение, возвращаемое аргументом-анонимной функцией

      $value = value(function() { return 'bar'; });


    // view()
    //----------------------------------------//
    // - получить экземпляр представления по указанному адресу

      return view('auth.login');


    // with()
    //----------------------------------------//
    // - вернуть объект указанного класса

      $value = with(new Foo)->doWork();


Г11.  Локализация

  --------------------------------------
  Подоглавление:

    # Введение
    # Языковые файлы
    
      - Где хранятся языкоыве файлы 
      - Пример содержимого языкового файла 
      - Назначить язык по умолчанию в конфиге
      - Назначить "запасной" язык по умолчанию
      - Изменить язык по умолчанию в realtime

    # Основы использования

      - Извлечение строк из языкового файла
      - Использование плейсхолдеров в возвращаемых строках
      - Определить по ключу, содержит ли языковой файл соотв.строку

    # Работа со склонениями

  --------------------------------------

  > Введение
    - Фасад Lang удобно позволяет извлекать строки на разных языках.
    - Это позволяет легко поддерживать приложение на многих языках

  > Языковые файлы

    Где хранятся языкоыве файлы
    ---------------------------
      - Они лежат в каталоге resources/lang
      - В lang должны быть подкаталоги, символизирующие
        поддерживаемые приложением языки.
      - Допустим, приложение поддерживает русский и английский.
      - Тогда структура в lang будет такова:

        /resources
            /lang
                /ru
                  messages.php
                /en
                  messages.php

    Пример содержимого языкового файла
    ----------------------------------
      - ЯФ просто возвращают массив элементов: ключ => значение
      - По ключу потом можно извлекать соответствующие значения.
      - А значениями и служат строки на соотв.языках.
      - Пример ЯФ:

          <?php

            return [
                'welcome' => 'Welcome to our application'
            ];

          ?>

    Назначить язык по умолчанию в конфиге
    -------------------------------------
      - Можно в конфиге config/app.php, в св-ве locale.

    Назначить "запасной" язык по умолчанию
    --------------------------------------
      - К примеру, если мы запросили строку на языке по умолчанию.
      - Но этой строки почему-то не оказалось в наличии.
      - Тогда система заменяет её строкой на "запасном" языке по умолчанию.
      - Установить его можно в конфиге config/app.php, в св-ве fallback_locale.

    Изменить язык по умолчанию в realtime
    -------------------------------------
      - Можно с помощью App::setLocale.
      - Например:

          App::setLocale('en');

  > Основы использования

    Извлечение строк из языкового файла
    -----------------------------------
      - Извлечём из языкового файла messages строку welcome.
      - причём, сделаем это для языка, установленного по умолчанию.
      - Итак:

          $str = Lang::get('messages.welcome');

      - Либо можно использовать вспомогательную функцию trans.
      - Она является синонимом для Lang::get.
      - Вот так:

          $str = trans('messages.welcome');

      - Если строки с таким ключём не существует.
      - Ни для основной локали, ни для вспомогательной.
      - То будет возвращён ключ: 'messages.welcome'

    Использование плейсхолдеров в возвращаемых строках
    --------------------------------------------------
      - При определении строки, можно использовать именованные плейсхолдеры.
      - Потом, при извлечении, можно передать массив значений для плейсхолдеров.
      - Допустим, в messages.welcome у нас есть такая строка:

          'welcome' => 'Welcome, :name',

      - Как видно, в ней есть плейсхолдер :name
      - При извлечении передадим для него значение:

          $str = Lang::get('messages.welcome', ['name' => 'Dayle']);

      - В итоге, получим строку: 'Welcome, Dale'.

    Определить по ключу, содержит ли языковой файл соотв.строку
    -----------------------------------------------------------

      if (Lang::has('messages.welcome'))
      {
          //
      }
 
  > Работа со склонениями

    Введение в проблему со склонениями
    ----------------------------------
      - Многие языки имеют много сложных правил, касающихся склонения.
      - Решение этой проблемы также предусмотрено в L5.

    Решение проблемы со склонениями
    -------------------------------
      - Допустим, есть у нас в языковом файле строка "Товар".
      - В русском языке это слово склоняется: "Товара", "Товаров".
      - Не создавать же 3 отдельных ключа для каждого из них.
      - Вместо этого, можно записать их через pipe:

          'goods' => 'Товар|товара|товаров',

      - И запрашивать можно так:

          $str = Lang::choice('товар|товара|товаров', $count, [], 'ru');


Г12.  Почта

  --------------------------------------
  Подоглавление:

    # Ссылки

      - Основы email
      - Email в Laravel
      - Бесплатные SMTP-сервера
      - Сервисы HTTP-API

    # Введение
    # Как работает электронная почта

      - Схема отправки письма через SMTP-сервер
      - Про SMTP, MUA и MTA

    # Настройка работы с email в Laravel
    
      - Где лежит конфиг
      - Содержимое конфига    

    # В итоге, что же использовать?

      - Предисловие
      - Варианты
      
        - свой SMTP-сервер (1 / 5 / 5)
        - бесплатный сторонний SMTP-сервер (5 / 1 / 5)
        - платный сторонний SMTP-сервер (5 / 3 / 1)
        - сторонний SMTP-сервис (5 / 3 / 1)
        - лог

    # Настройка "SMTP" через SMTP-сервер mailgun
    # Основы использования Mail-API в Laravel

      - send()                | отправить email

        - Пример использования send()
        - $message->to()      | позволяет указать ФИО получателя, и его адрес email
        - $message->from()    | позволяет указать ФИО отправителя, и его адрес email
        - $message->subject() | позволяет указать тему письма.
        - $message->attach()  | позволяет прикрепить к письму файл

      - raw()                 | отправить email с простой строкой
  
    # Прикрепление изображений в представлении письма
    # Добавление отправки писем в очередь задач

      - Проблема: отправка email'ов может тормозить приложение
      - Решение: добавлять отправку email'ов в очередь задач

        - queue()     | добавить мгновенно в стандартную очередь задач
        - later()     | добавить через N секунд в стандартную очередь задач
        - queueOn()   | добавить мгновенно в указанную очередь задач

    # Работа с почтой во время локальной разработки

  --------------------------------------

  > Ссылки

    Основы email
    ------------
    
      - Что такое SMTP (статья на wiki):
          https://ru.wikipedia.org/wiki/SMTP

      - PHP-фукнция mail(), официальный справочник:
          http://php.net/manual/ru/book.mail.php

      - Статья "Как работает электронная почта"
          http://www.pcwork.ru/kak_rabotaet_elektronnaya_pochta_deystvuyuschaya_sistema_server_smtp.htm


    Email в Laravel
    ---------------

      - Статья "Sending Email with Laravel 4" на culttt.com (en):
          http://culttt.com/2014/04/14/sending-email-laravel-4/

      - Оф. сайт SwiftMailer:
          http://swiftmailer.org/

      - Оф. справочник laravel 4 (en):
          http://laravel.com/docs/4.2/mail

      - Оф. справочник классов laravel 4 (см. класс illuminate\mail):
          http://laravel.com/api/4.2/


    Бесплатные SMTP-сервера
    -----------------------

      > mail.ru     | MAX 1 сообщение в минуту
      > yandex.ru   | MAX 150 сообщений в день
      > meta.ua     | MAX 200 сообщений в день
      > ukr.net     | MAX 250 сообщений в день
      > rambler.ru  | MAX 200 сообщений в час
      > gmail.com   | MAX 500 сообщений в день
      > mailgun.org | MAX 10000 сообщений в месяц


    Сервисы HTTP-API
    ----------------

      > https://mailgun.com
        - 10000 сообщений/месяц бесплатно.
        - Свыше 10k надо платить $0.00050 за каждый отправленный email.
        - Итого, платные 1000 сообщений будет стоить $0.5.

      > https://www.mandrill.com/
        - 12000 сообщений/месяц бесплатно.
        - Свыше 12k по $0.2 за каждую 1000 сообщений.

      > http://sendgrid.com/
        - 200 сообщений/день бесплатно (6000/месяц).
        - За $10 можно купить 40000 сообщений
        - Итого, платные 1000 сообщений будет стоить $0.25.

      > http://www.epochta.ru/
        - 6000 сообщений/месяц бесплатно.
        - Свыше 6k сообщений $10 за каждые 10000 сообщений.
        - Итого, платные 1000 сообщений будут стоить $1.


  > Введение
    - 99% приложений требуется уметь отправлять email.
    - В Laravel для этого используется библиотека SwiftMailer.
    - В L5, в Illuminate\Mail, реализован единый API для работы с email.

  > Как работает электронная почта

    Схема отправки письма через SMTP-сервер
    ---------------------------------------

            -------      -------
         -> | MTA | ---> | MTA | ->
         |  -------      -------  |
         |                        |
         |                        |
         |                        |
        -------              -------
        | MUA |              | MUA |
        -------              -------

      # Ситуация
        - Надо отправить письмо по адресу ivanpetrov@mail.ru
        - Письмо будет отправлять приложение PHP-функцией mail().
        - Имеется настроенный MTA Sendmail.

      # Как всё происходит

        1. Применяем функцию mail() и отправляем письмо нашему MTA Sendmail через порт 25.
        2. Он запращивает у DNS-сервера адрес mail.ru, и пересылает письмо местному MTA через порт 25.
        3. MTA на mail.ru передаёт письмо местному POP3-серверу, который кладёт его в ящик клиента.


    Про SMTP, MUA и MTA
    -------------------

      # SMTP
        - Simple Mail Transfer Protocol - простой протокол передачи почты.
        - Предназначен для передачи электронной почты в сетях TCP/IP.
        - Впервые описан в RFC 821 в 1982 году.
        - Предназначен для передачи исходящей почты с использованием порта TCP 25.
        - Работает обычно через порт 25.

      # MUA - Mail User Agent - клиент электронной почты
        - Программа-клиент, которая передаёт письмо для передачи на SMTP-сервер.

      # MTA - Mail Transfer Agent - агент пересылки сообщений
        - Это и есть сервер электронной почты, или SMTP-сервер.
        - Список самых известных MTA доступен в этой статье wiki:
            https://ru.wikipedia.org/wiki/Почтовый_сервер


  > Настройка работы с email в Laravel
    
    Где лежит конфиг
    ----------------
      - Конфиг лежит по адресу "config/mail.php".
      - В нём можно настроить работу с email в Laravel 5.

    Содержимое конфига
    ------------------

      driver
      ------
        - Позволяет выбрать драйвер для работы с email.
        - Доступны следующие варианты:

          > smtp
            - Используем сторонний SMTP-сервер для отправки писем.
            - В интернете полно сторонних общедоступных SMTP-серверов.
            - По умолчанию установлен SMTP-сервер: "smtp.mailgun.org"

          > mail
            - Будем отправлять письма встроенной в PHP функцией mail().
            - Она требует, чтобы был установлен SMTP-сервер sendmail.
            - Подробнее про эту функцию см. в официальном справочнике:
                http://php.net/manual/ru/book.mail.php

          > sendmail
            - Используем SMTP-сервер Sendmail.

          > mailgun
            - Используем через API сервис mailgun.com для отправки писем.
            - Т.Е. письма мы отправляем через HTTP, используя API сервиса.

          > mandrill
            - Используем через API сервис mandrill.com для отправки писем.
            - Т.Е. письма мы отправляем через HTTP, используя API сервиса.

          > log
            - Отправляем все письма в лог.
            - Этот режим можно использовать для отладки приложения.


      host
      ----
        - Используется, если в 'driver' выбран "SMTP".
        - Здесь можно задать host стороннего SMTP-сервера.
        - По умолчанию установлен 'smtp.mailgun.org'.

      port
      ----
        - Порт для работы с SMTP-сервером.
        - По умолчанию стоит порт 587 (для работы с 'smtp.mailgun.org')

      from
      ----
        - Можно указать глобальные исходящий адрес и имя отправителя.
        - Эти значения будут использоваться при отправке всех писем.

      encryption
      ----------
        - Протокол шифрования.
        - По умолчанию указан 'tls'.
        - Авторы уверяют, что это надёжно и безопасно.

      username
      --------
        - Используется, если в 'driver' выбран "SMTP".
        - Часть для использования SMTP-сервера требуется аутентификация.
        - Здесь можно указать name для аутентификации.

      password
      --------
        - Используется, если в 'driver' выбран "SMTP".
        - Часть для использования SMTP-сервера требуется аутентификация.
        - Здесь можно указать password для аутентификации.

      sendmail
      --------
        - Используется, если в 'driver' выбран "sendmail".
        - Содержить путь к папке, в которой находится Sendmail.
        - По умолчанию указан путь '/usr/sbin/sendmail -bs'.

      pretend
      -------
        - Pretend переводится, как "претворяться".
        - По умолчанию значение этой опции false.
        - Если true, то почта не отправляется и попадает в лог.
        - Удобно использовать для отладки.


  > В итоге, что же использовать?

    Предисловие
    -----------
      - В Laravel доступно много инструментов для работы с почтой.
      - Какой же из них в какой ситуации лучше использовать?
      - Рассмотрим плюсы и минусы разных вариантов.
      - Будем оценивать по 3-м параметрам:

          Простота / Ограничения / Фин.затраты

      - Оценку будем проводить по 5-бальной шкале.

    Варианты
    --------

      #1: свой SMTP-сервер (1 / 5 / 5)

        > Обсуждение
          - Установить и настроить свой SMTP-сервер на своём серваке.
          - Потребуется время, чтобы в этом разобраться, поэтому это сложно.
          - Но зато никаких ограничений, и никаких фин. затрат.

        > Выводы
          - Такой вариант подойдёт для реальных проектов, он вполне надёжен.

      #2: бесплатный сторонний SMTP-сервер (5 / 1 / 5)

        > Обсуждение
          - Использовать бесплатный сторонний SMTP-сервер проще простого.
          - Но все они имеют неприятные ограничения на кол-во отправляемых писем.
          - Поэтому данный вариант не надёжен:
            - Если лимит будет исчерпан, отправка перестанет работать.

        > Лимиты популярных бесплатных SMTP-серверов:

          - mail.ru     | MAX 1 сообщение в минуту
          - yandex.ru   | MAX 150 сообщений в день
          - meta.ua     | MAX 200 сообщений в день
          - ukr.net     | MAX 250 сообщений в день
          - rambler.ru  | MAX 200 сообщений в час
          - gmail.com   | MAX 500 сообщений в день
          - mailgun.org | MAX 10000 сообщений в месяц

        > Выводы
          - Практически не подходит для реальных проектов, т.к. не надёжен.
          - Можно использовать, если кол-во сообщений гарантировано ниже лимитов.
          - Плюс можно попользоваться для тестирования.

      #3: платный сторонний SMTP-сервер (5 / 3 / 1)

        > Обсуждение
          - Как отдельное решение практически отсутствует на рынке.
          - В наше время идёт в составе комплексного SMTP-сервиса.

        > Выводы
          - См. SMTP-сервисы

      #4: сторонний SMTP-сервис (5 / 3 / 1)

        > Обсуждение
          - Обычно объединяет в себе 2 API: по протоколам SMTP и HTTP.
          - Обычно позволяет отправлять N 1-ых сообщений/мес. бесплатно.
          - Свыше бесплатного лимита обычно берёт деньги за каждое сообщение.
          - Обычно предоставляет ряд доп.функционала для работы с почтой.

        > Рассмотрим несколько SMTP-сервисов

          # https://mailgun.com
            - 10000 сообщений/месяц бесплатно.
            - Свыше 10k надо платить $0.00050 за каждый отправленный email.
            - Итого, платные 1000 сообщений будет стоить $0.5.

          # https://www.mandrill.com/
            - 12000 сообщений/месяц бесплатно.
            - Свыше 12k по $0.2 за каждую 1000 сообщений.

          # http://sendgrid.com/
            - 200 сообщений/день бесплатно (6000/месяц).
            - За $10 можно купить 40000 сообщений
            - Итого, платные 1000 сообщений будет стоить $0.25.

          # http://www.epochta.ru/
            - 6000 сообщений/месяц бесплатно.
            - Свыше 6k сообщений $10 за каждые 10000 сообщений.
            - Итого, платные 1000 сообщений будут стоить $1.

        > Выводы
          - При использовании будет являться источником доп. постоянных расходов.
          - Но зато обеспечивает качественное SMTP-решение.
          - Можно использовать в реальном проекте, если не жалко денег,
            и неохота париться с организацией своей почтовой архитектуры.

      #5: лог

        > Обсуждения
          - Вместо реальной отправки сообщений можно посылать их в лог Laravel.

        > Выводы
          - Удобно использовать для отладки.


  > Настройка "SMTP" через SMTP-сервер mailgun

    > Предисловие
      - Это будет инструкция по настройке Laravel для работы через
        сторонний SMTP-сервер.
      - То есть в параметре "driver" мы выбираем "SMTP".
      - В качестве стороннего SMTP-сервера будем использовать smtp.mailgun.com
      - Как использовать SMTP-сервер smtp.mailgun.com описано у них в справке:
          http://documentation.mailgun.com/user_manual.html#smtp-relay

    > Инструкция

      1. Создать учётную запись на mailgun.com
        - Она понадобится нам для авторизации на их smtp-сервере.
        - Если учётная запись там уже есть, можно пропустить этот этап.
        - Заходим на mailgun.com и создаём новую учётную запись.

      2. Посмотреть SMTP-логин, SMTP-пароль, номера портов
        - Зайти в панель управления mailgun, раздел "Domains".
        - Зайти в доступный домен, щёлкнув по нему.
        - Посмотреть значения следующих параметров:

          # SMTP Hostname
            - Скорее всего это: smtp.mailgun.org

          # Default SMTP Login
            - Логин для подключения к SMTP-серверу

          # Default Password
            - Пароль для подключения к SMTP-серверу

        - Посмотреть номера портов.
        - Обычно SMTP-сервер слушает порты 25, 587 и 465.

      3. Записать SMTP-логин и SMTP-пароль в файл настроек laravel mail.php
        - SMTP-логин записать в параметр 'username'.
        - SMTP-пароль записать в параметр 'password'.

      4. Всё, теперь должно работать.


  > Основы использования Mail-API в Laravel

    // send()
    //----------------------------------------//
    // - отправить email

      Пример использования send()
      ---------------------------
        
        # Отправление письма
          - Отправим электронное письмо.
          - Представление для него возьмём по адресу:
              resources/views/emails/welcome.php    
          - В представление передадим переменную $key со значемем value.
          - Назначим получателя: John Smith, foo@example.com
          - Назначим тему сообщения: 'Welcome!'
          - Код:

              Mail::send('emails.welcome', ['key' => 'value'], function($message)
              {
                  $message->to('foo@example.com', 'John Smith')->subject('Welcome!');
              });

        # Пояснения по аргументам:

            1) Представление для письма.
            2) Аргумент: массив данных, который передаётся в представление
              - Как в представлении получить доступ к переданной переменной key?
              - Вот так: $key 
            3) Аргумент: анон.функция, где можно настроить сообщение

        # Внимание: не надо передавать $message в представление вручную.
          - Имеется в виду, в массиве, во 2-м аргументе. 
          - $message всегда передаётся в представление письма автоматически.

        # Можно выбрать, какое использовать представление: text или html

          > text
            Mail::send('text' => 'emails.welcome', ['key' => 'value'], function($message)
            {
                // ...
            });     

          > html (по умолчанию)
            Mail::send('html' => 'emails.welcome', ['key' => 'value'], function($message)
            {
                // ...
            }); 

      $message->to()
      --------------
        - Позволяет указать ФИО получателя, и его адрес email.
        - Это происходит в контексте анонимной функции 3-го аргумента метода send.
        - Например:

            $message->to('foo@example.com', 'John Smith');

      $message->from()
      ----------------      
        - Позволяет указать ФИО отправителя, и его адрес email.
        - Это происходит в контексте анонимной функции 3-го аргумента метода send.
        - Например:

            $message->from('foo@example.com', 'John Smith');

      $message->subject()
      -------------------
        - Позволяет указать тему письма.
        - Это происходит в контексте анонимной функции 3-го аргумента метода send.
        - Например:

            $message->subject('Welcome!');

      $message->attach()
      ------------------
        - Позволяет прикрепить к письму файл.
        - Это происходит в контексте анонимной функции 3-го аргумента метода send.
        - Например:

          # Прикрепить
            $message->attach($pathToFile);

          # Прикрепить, и указать имя файла в письме, и его mime-тип
            $message->attach($pathToFile, ['as' => $display, 'mime' => $mime]);


    // raw()
    //----------------------------------------//
    // - отправить email с простой строкой

      - Метод raw() служит, как упрощённая версия send().
      - Он позволяет быстро послать по email некую строку.
      - Полезно использовать, скажем, для короткиъ служебных сообщений.
      - Например, сообщений администратору о чём-то.
      - Пример:

        Mail::raw('Text to e-mail', function($message)
        {
            $message->from('us@example.com', 'Laravel');
            $message->to('foo@example.com')->cc('bar@example.com');
        });      

    Прикрепление изображений в представлении письма
    -----------------------------------------------

      Введение в проблему изображений в html-представлении письма
      -----------------------------------------------------------
        - В наше время обычно используют html-письма.
        - Для их отправки заранее заготавливают представления.
        - Эти представления могут содержать изображения.
        - Ведь при отправки письма, их тоже придётся отправлять.
        - Но как это реализовывать?

      Решение проблемы с inline-изображениями
      ---------------------------------------
        - Для этого следует использовать метод embed.
        - Вот, как это делается:

            <body>

                Here is an image:
                <img src="<?php echo $message->embed($pathToFile); ?>">

            </body>            

        - Аналогичным образом можно поступать и с файлами.
        - Вот так:

            <body>

                Here is an image from raw data:
                <img src="<?php echo $message->embedData($data, $name); ?>">

            </body>        

  > Добавление отправки писем в очередь задач

    Проблема: отправка email'ов может тормозить приложение
    ------------------------------------------------------
      - Допустим, клиент оформляет заказ.
      - И когда он нажмет на кнопку, ему д.б. отправлен email.
      - Если это делать в realtime, клиенту придётся ждать.
      - А если сервер загружен, возможно, ждать долго.
      - В этом и состоит проблема.

    Решение: добавлять отправку email'ов в очередь задач
    ----------------------------------------------------
      - Решением является сабж.
      - Для этого надо использовать метод queue фасада Mail.
      - Мы просто применяем его вместо метода send, и все дела.
      
        queue()
        -------
          Mail::queue('emails.welcome', $data, function($message)
          {
              $message->to('foo@example.com', 'John Smith')->subject('Welcome!');
          });        

      - Можно уточнить кол-во секунд, через которые выполнять задачу.
      - Вот так:

        later()
        -------
          Mail::later(5, 'emails.welcome', $data, function($message)
          {
              $message->to('foo@example.com', 'John Smith')->subject('Welcome!');
          });        

      - Можно уточнить, в какую конкретно очередь задач добавить оную.
      - Вот так:

        queueOn()
        ---------
          Mail::queueOn('queue-name', 'emails.welcome', $data, function($message)
          {
              $message->to('foo@example.com', 'John Smith')->subject('Welcome!');
          });        

  > Работа с почтой во время локальной разработки

    Зачем отправлять настоящие при разработке?
    ------------------------------------------
      - Допустим, разрабатываем мы некое приложение.
      - И оно должно по плану отправлять электронные письма.
      - Но надо ли нам, чтобы оно это делало во время разработки?
      - Имеется в виду, отправляло письма настоящим адресатам?
      - Не лучше ли переадресовать эти письма куда-нибудь в лог?
      - Просто, чтобы не спамить?

    Для реализации вышеописанного, есть 2 способа
    ---------------------------------------------

      1) Использовать метод pretend() для отправки писем
      2) В конфиге config/mail.php, в св-ве pretend указать true

    Куда будут попадать "притворные" письма
    ---------------------------------------
      - По умолчанию, в лог приложения.
      - Но что, если мы хотим увидеть html наших писем?
      - Тогда можно использовать сервисы, вроде MailTrap.io



Г13.  Разработка composer-пакетов для Laravel

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Использование механизма публикации ресурсов Laravel

      - Что такое механизм публикации ресурсов в Laravel (МПР)
      - Как МПР поможет в модульном приложении
      - Плюсы и минусы хранения публ.ресурсов в каталогах модулей
      - На период разработки: автопубликация ПР всех модулей при каждом запросе
      - Использование тегов для пометки операций publish модулей
      - Пошаговая инструкция использования МПР

    # Синтаксис markdown

      Прочее
      ------

        Простой текст   | заключается в <p></p>

      Заголовки
      ---------

        #               | заголовок H1
        ##              | заголовок H2
        ###             | заголовок H3
        ####            | заголовок H4
        #####           | заголовок H5
        ######          | заголовок H6

      Полосы
      ------

        ---             | горизонтальная полоса hr
        ***             | горизонтальная полоса hr
        ---             | горизонтальная полоса hr

      Акценты в тексте
      ----------------

        **текст**       | жирный текст <strong>текст</strong>
        _текст_         | италик текст <em>текст</em>
        ~~текст~~       | зачеркнутый текст <strike>текст</strike>

      Цитаты
      ------

        > текст         | цитата <blockquote><p>текст</p></blockquote>
        >> текст        | вложенная цитата  
        >>> текст       | вложенная цитата
        ...             | ... сколько угодно вложенных цитат

      Не нумерованные списки
      ----------------------
        * Текст         |
        + Текст         | - можно использовать * + - (без разницы)
        - Текст         |
          + Текст       |
            + Текст     | - пример организации вложенных списков
              * Текст   |

      Нумерованные списки
      -------------------
        1. Текст        |
        2. Текст        | - пример нумерованного списка
        3. Текст        |

        1. Текст        |
        1. Текст        | - пример нумер-го списка с автоматической нумерацией
        1. Текст        | 

      Код
      ---
        `код`           | - обозначить 1 строку кода код     
        
        [4 пробела]код  | - аналог 'код', надо min 2 строки, и min
        [4 пробела]код  |   по 4 пробела перед каждой из них

        '''код'''       | - обозначить > 1 строки кода

        ''' какая_подсветка | - Например: ''' javascript
            ...код...       | - Позволяет указать, какую подсветку синтаксиса использовать
        '''                 | 

      Таблица
      -------

        | id | name |
        | -- | ---- |
        | 1  | Иван |
        | 2  | Пётр |
        | 3  | Владимир |

      Ссылки
      ------
        [имя](http://ya.ru)         | ссылка "имя" на http://ya.com
        [имя](http://ya.ru "title") | ссылка с title'ом

      Якоря для создания меню (на примере мини-меню)
      ----------------------------------------------
        # Содержание
          - [Ссылки](#links)
          - [Введение](#intro)

        ## Ссылки <a id="links"></>
        Ссылки

        ## Введение <a id="intro"></>
        Введение        

      Изображения
      -----------
        [имя](http://ya.ru/1.gif)         | ссылка на изображение
        [имя](http://ya.ru/1.gif "title") | ссылка на изображение с title'ом


  --------------------------------------

  > Ссылки

    # Основные ссылки

      - Самый популярный репозиторий для Git
          https://github.com/

      - Сайт, где можно найти все пакеты для Laravel:
          https://packagist.org/

      - Статья "Creating custom packages with Laravel 5":
          http://www.codeanchor.net/blog/creating-custom-laravel-5-packages/

    # Разметка markdown

      - Статья на wiki про markdown
          https://ru.wikipedia.org/wiki/Markdown

      - Синтаксис markdown
          http://assemble.io/docs/Cheatsheet-Markdown.html
          https://help.github.com/articles/markdown-basics/
          https://help.github.com/articles/github-flavored-markdown/


  > Введение
    - Composer, это популярнейший менеджер зависимостей для PHP.
    - Пакеты composer, эта одно из ключевых вещей в контексте Composer.
    - Каждый пакет содержит некий код, который может понадобитьсья проекту.
    - В общем случае, пакеты composer не зависят ни от каких фреймворков.
    - В контексте же Laravel, все пакеты composer можно разделить на 2 категории:

      1) Автономные пакеты
        - Это как раз тот общий случай, описанный выше.
        - Данные пакеты никак не зависят ни от какого фреймворка.
        - Их можно установить в любой проект на PHP, и они будут работать.

      2) Пакеты, заточенные под Laravel
        - Эти пакеты заточены специально заточены под php-фреймворк Laravel.
        - В них могут содержаться сущности, присущие именно Laravel.
        - Например: роуты, контроллеры, представления и прочие.

    - В этой главе рассмотрим создание composer-пакетов для Laravel.


  > Использование механизма публикации ресурсов Laravel

    Что такое механизм публикации ресурсов в Laravel (МПР)
    ------------------------------------------------------
      - Он позволяет копировать файлы с заменой из одного каталога в другой.
      - Можно в СП заранее определить, что куда будет копироваться.
      - Для этого используется команда publish.
      - При каждом применении publish можно даже помечать операцию тегами.
      - Выполнить копирование можно так:

        # Выполнить ВСЕ операции publish с заменой (--force):
        artisan vendor:publish --force

        # Выполнить операции publish, помеченные тегом [тег], с заменой (--force):
        artisan vendor:publish --tag=[тэг] --force

        # Выполнить операции publish из конкретного сервис-провайдера:
        php artisan vendor:publish --provider="Vendor\Providers\PackageServiceProvider"

    Как МПР поможет в модульном приложении
    --------------------------------------
      - Разрабатываем модульное приложение.
      - Публичные ресурсы (ПР) каждого модуля лежат в его каталоге.
      - Однако, у приложения может быть лишь 1 каталог public.
      - И он находится (по умолчанию) по адресу /public

          /корень приложения
              /public

      - Допустим, у нас есть 10 модулей, у каждого есть свои публичные ресурсы:

          /корень приложения
              /domain
                  /module1
                      /public
                  /module2
                      /public
                  ...
                  /module10
                      /public

      - Чтобы всё работало, надо как-то доставить их в /public.
      - Чтобы в итоге получилась такая структура:

          /корень приложения
              /public
                  /domain
                      /module1
                          j.js
                          c.css
                      /module2
                          j.js
                          c.css
                      ...
                      /module10
                          j.js
                          c.css 

      - Именно это и поможет делать МПР.

    Плюсы и минусы хранения публ.ресурсов в каталогах модулей
    ---------------------------------------------------------

      Плюсы
      -----

        # ВСЕ ресурсы модуля хранятся в его каталоге
          - Это удобно, потому что "всё в одном месте".

        # При удалении модуля, не надо за ним подчищать ПР
          - Ведь ПР удалятся вместе с каталогом модуля

        # Проще переносить модули в другое место
          - Ведь всё, что касается модуля, лежит в его каталоге.

      Минусы
      ------

        # Это несколько сложнее, чем хранить ПР сразу в /public
          - При обновлении ПР в модуле, изменения ещё не вступают в силу.
          - Ведь в /public всё ещё лежат старые копии этих ПР.
          - И их надо заменить на новые ПР из каталога ресурсов, чтобы все заработало
          - Т.Е. надо применить команду: artisan vendor:publish --force

    На период разработки: автопубликация ПР всех модулей при каждом запросе
    -----------------------------------------------------------------------

      Суть проблемы
      -------------
        - Она описана выше, в "минусах" использования МПР.
        - Представим, что мы ведём разработку модуля.
        - Меняем что-то в js-файлах, обновляем браузер, смотрим результаты.
        - Получается, что после каждого изменения в js-файлах, надо вводить
          команду: artisan vendor:publish --force
        - Это может сделать процесс разработки невыносимым.

      Решение проблемы
      ----------------
        - На период разработки можно автоматизировать публикацию ресурсов.
        - И сделать это разом для всех модулей.
        - Публикация будет проходить автоматически при каждом запросе к приложению.
        - Для этого в любом сервис-провайдере надо просто выполнять artisan-команду:
            
            Artisan::call('vendor:publish', ['--force' => '']);

        - Это гарантирует, все ПР всех модулей обновлены в /public.
        - Правда, это замедлит работу приложения.
        - Поэтому, должно использоваться только во время разрабокти.

    Использование тегов для пометки операций publish модулей
    --------------------------------------------------------
      - При определении publish-операций для публикации ПР модулей,
        можно использовать один и тот же тег.
      - Например, тег 'modulesPubRes':

          $this->publishes([
              __DIR__.'/path/to/assets' => public_path('vendor/courier'),
          ], 'modulesPubRes');

      - Это позволит командой vendor:publish публиковать лишь ПР модулей.
      - Потому что просто команда - composer vendor:publish - публикует
        все ресурсы, из всех publish-операций, всех сервис-провайдеров.
      - Опубликовать все ресурсы с тегом modulesPubRes можно так:

          artisan vendor:publish --tag=modulesPubRes --force
          Artisan::call('vendor:publish', ['--tag' => 'modulesPubRes', '--force' => '']);

    Пошаговая инструкция использования МПР
    --------------------------------------

      0. Предисловие
        - Рассмотрим использование МПР для публикации ресурсов модуля.
        - Допустим, у нас есть модуль 'M2_users'.
        - Он может содержать сколько угодно интерфейсов.
        - У каждого из этих интерфейсов есть свои ПР.
        - В этом примере, рассмотрим публикацию ПР для 1-го из таких интерфейсов модуля.
        - Пусть ПР интерфейса модуля лежат в каталоге:

            /lk_zaste_ru/M2_users/Documents/Users/Public

        - Мы хотим организовать автопубликацию этих ресурсов в:

            /public/M2_users/Users

        - Причём, чтобы она производилась при каждом запросе к приложению.
        - Это нам понадобится для удобства на период разработки.

      1. Настроить базовый каталог и префекс для пр.имён модулей
        - Если это ещё ранее не сделано.
        - В данном случае, мы настраиваем для домена lk.zaste.ru.
        - Для этого открыть файл composer.json проекта.
        - В нём, в "autoload" -> "psr-4" добавить:

            "psr-4": {
              ...
              "lk_zaste_ru\\": "lk_zaste_ru"
            }

      2. Создать сервис-провайдер для интерфейса Users
       
        Где
        ---
          /lk_zaste_ru/M2_users/Documents/Users/InterfaceServiceProvider.php

        Что внутри
        ----------
          - Добавить следующую запись в метод boot.

            $this->publishes([

                base_path('lk_zaste_ru/M2_users/Documents/Users/Public') => 
                public_path('M2_users/Users'),

            ], 'modulesPubRes');          

          - В ней мы указали, что хотим публиковать ресурсы из:

              /lk_zaste_ru/M2_users/Documents/Users/Public

          - В:

              /public/M2_users/Users

          - И применили тег 'modulesPubRes'.

        Зарегистрировать
        ----------------
          - Добавить созданный сервис-провайдер в config/app.php
          - В свойство providers.
          - Вот так:

              'providers' => [
                ...
                'lk_zaste_ru\M2_users\Documents\Users\InterfaceServiceProvider',
              ]

      3. Выполнить команду: composer dump-autoload 
        - Чтобы композер всосал новые связи.
        - Команда:

            composer dump-autoload

      4. Протестировать, всё ли работает
        - Выполнить следующую команду artisan:

            php artisan vendor:publish --tag=modulesPubRes --force

        - В ответ вы должны получить нечто вроде:

            Copied Directory [\lk_zaste_ru\M2_users\Documents\Users\Public] To [\public\M2_users\Users]

        - И в /public должны появиться публичные ресурсы нашего интерфейса.
        - По адресу:

            \public\M2_users\Users

      5. Организовать автопубликацию ПР всех модулей при каждом запросе

        0) Обсуждение
          - Хорошо было бы организовать автопубликацию через сервис-провайдер.
          - Неважно какой, какой-нибудь, лишь бы работало.
          - Но, к сожалению, это не возможно.
          - Комана Artisan::call в методе boot сервис-провайдера не работает.
          - Что-то там зацикливается, и выдаёт ошибку.
          - Поэтому, организовывать автопубликацию будем через Middleware.

        1) Создать новый middleware
          - Создадим новый middleware в каталоге app/Http/Middleware.
          - Имя ему зададим такое: ModulesAutoResPublish
          - Для этого выполним команду:

              php artisan vendor:publish --tag=modulesPubRes --force

          - После этого надо обновить связи композера, выполнив:

              composer dump-autoload

        2) Поместить в новый middleware требуемый код
          - В метод handle нового middleware разместить:

              \Artisan::call('vendor:publish', ['--tag' => 'modulesPubRes', '--force' => true]);

        3) Применить новый middleware ко всем роутам
          - Как именно применять, зависит от того, как у вас роутинг организован.
          - Но в целом, данный middleware должен срабатывать для всех роутов.
          - Поэтому, допустим, можно обернуть все роуты в группу.
          - А к группе применить middleware:

              Route::group(['middleware' => ['\App\Http\Middleware\ModulesAutoResPublish']], function()
              {

                Route::get('/', 'WelcomeController@index');

              });



Г14.  Очереди задач

  --------------------------------------
  Подоглавление:

    # Введение
    
      - Что такое очередь задач
      - Зачем нужна очередь задач
      - В Laravel нет собственного механизма очередей задач

    # Настройка

      - Требуемые зависимости для механизмов очередей
      - Если планируете использовать очереди через таблицу в БД
      - Содержимое конфига config/queue.php

    # Основы использования

      - Очереди и eloquent-модели
      - release & delete  | вручную удалить задачу из очереди
      - --tries           | установить MAX кол-во неудачных попыток выполнить задачу
      - attempts()        | сколько уже было неудачных попыток выполнить задачу
      
      - push()            | добавить задачу в очередь
      - pushOn()          | добавить задачу в конкретную очередь
      - bulk()            | добавить N задач в очередь
      - later()           | добавить отложенную задачу в очередь
   
    # Демон vs внешний сервис

      - Чтобы очереди работали, нужен процесс, их запускающий
      - Демон queue:listener
      - Iron.io

    # Класс-задача vs анонимная функция

      - Что из себя представляет задача
      - Задача: класс-команда
      - Задача: анонимная функция

    # Провалившиеся задачи

      - Таблица провалившихся задач failed_jobs
      - Указать лимит на MAX число неудачных попыток выполнить задачу
      - Зарегистрировать событие "провал задачи"
      - Метод failed(), срабатывает в случае провала
      - Посмотреть список всех проваленных задач
      - Попробовать выполнить проваленную задачу с ID
      - Удалить проваленную задачу с ID из списка
    

  --------------------------------------

  > Введение

    Что такое очередь задач
    -----------------------
      - Она позволяет отложить трудоёмкие задачи на потом.
      - Их просто можно добавить в некую виртуальную очередь.
      - И они по очереди и исполнятся.
      - Также можно указывать, насколько требуется отложить задачу.
      - Или же, когда конкретно она должна быть исполнена.

    Зачем нужна очередь задач
    -------------------------
      - Чтобы откладывать трудоёмкие задачи на потом.
      - В результате чего интерфейс пользователя меньше тормозит.
      - Допустим, пользователь оформляет заказ, и нажимает на кнопку.
      - После этого ему должен быть отправлен email с подробностями заказа.
      - Ну зачем пользователю сидеть и ждать, пока это будет сделано?
      - Лучше, пусть эта задача выполнится секунд чере 5, фоном.

    В Laravel нет собственного механизма очередей задач
    ---------------------------------------------------
      - Зато он реализует единый API ко всем поддерживаемым механизмам.
      - А поддерживает Laravel 5.0 следующие механизмы очередей:

          sync        | это просто заглушка (задачи выполняются синхронно)
          database    | на основе таблицы в БД
          beanstalkd  | через сервер очередей beanstalkd
          sqs         | через сервис Амазона SQS (http://aws.amazon.com/ru/sqs)
          iron        | через сервис iron.io
          redis       | через key-value хранилище Redis


  > Настройка

    Требуемые зависимости для механизмов очередей
    ---------------------------------------------

      - Amazon SQS:   aws/aws-sdk-php
      - Beanstalkd:   pda/pheanstalk ~3.0
      - IronMQ:       iron-io/iron_mq ~1.5
      - Redis:        predis/predis ~1.0    

    Если планируете использовать очереди через таблицу в БД
    -------------------------------------------------------
      - Эту таблицу надо сначала в БД создать.
      - Можно это, конечно, сделать вручную.
      - Но легче ввести команду: 

          php artisan queue:table

      - Таблица будет создана в БД, указанной по умолчанию.

    Содержимое конфига config/queue.php
    -----------------------------------

      # 'default'
        - Драйвер по умолчанию для сервиса ПЗ.
        - Доступные варианты:

          # null
            - Драйвер отсутствует.

          # database
            - Механизм очередей на основе таблицы в БД.
            - Как создать эту таблицу, описано выше.

          # sync
            - Установлен по умолчаннию.
            - Значение: 'sync'.
            - Это драйвер для локального использования.

          # beanstalkd
            - Оф.сайт: http://kr.github.io/beanstalkd/
            - Зависимость: 'pda/pheanstalk ~3.0'.

          # sqs
            - Сервис Амазона SQS (http://aws.amazon.com/ru/sqs).
            - Зависимость: 'aws/aws-sdk-php'            

          # iron
            - Оф.сайт: http://www.iron.io/
            - Зависимость: 'iron-io/iron_mq ~1.5'.

          # Redis
            - Через key-value хранилище Redis.
            - Зависимость: 'predis/predis ~1.0'

      # 'connections'
        - Массив массивов настроек для различных драйверов.

      # 'failed'
        - Настройках сохранения информации о неудавшихся задачах.
        - Можно указать имя базы данных и таблицы.


  > Основы использования

    Очереди и eloquent-модели
    -------------------------
      - Допустим, команда принимает в конструкторе eloquent-модель.
      - При добавлении команды в очередь, будет передан лишь id модели.
      - Но когда пробьёт час задачи, и наступит её очередь выполниться.
      - И начнёт выполняться метод handle задачи.
      - Тогда модель будет извлечена из БД по этому самому id.
  
    release & delete
    ----------------
      - После успешного выполнения, задача автоматически удаляется из очереди.
      - А в случае неудачи, задача повторно добавляется в очередь.
      - В любом случае, может возникнуть желание удалить её из очереди вручную.
      - Для этого можно воспользоваться методами release и delete.
      - Чтобы получить к ним доступ, надо подключить трейт:

          use Illuminate\Queue\InteractsWithQueue;

      - Вот как можно применить release в методе handel задачи.
      - Пример:

          public function handle(SendEmail $command)
          {

              // Если кол-во неудачных попыток более 3
              // - "Выключить" задачу на 30 секунд
              if ($this->attempts() > 3)
              {
                  $this->release(30);
              }

              // Если кол-во неудачных попыток более 9
              // - Удалить задачу из очереди
              if ($this->attempts() > 9)
              {
                  $this->delete();
              }              

          }      

    --tries
    -------
      - Допустим, во время выполнения задачи возникло исключение.
      - Тогда, задача автоматически будет добавлена обратно в очередь.
      - И когда до неё снова дойдёт очередь, будет новая попытка её выполнить.
      - Неужели это будет повторяться бесконечно? Нет!
      - Лишь до тех пор, пока кол-во попыток не достигнет заданного максимума.
      - А задать максимум можно с помощью параметра --tries
      - Но это лишь в случае использования демонов (queue:listen, queue:work).
      - В случае использования сторонних решени

    // attempts()
    //----------------------------------------//
    // - сколько уже было неудачных попыток выполнить задачу

      if ($this->attempts() > 3)
      {
          //
      }      

    // push()
    //----------------------------------------//
    // - добавить задачу в очередь

      - Добавим в очередь задач команду SendMail.
      - И заодно передадим ей аргумент $message.
      - Добавим:

        Queue::push(new SendEmail($message));


    // pushOn()
    //----------------------------------------//
    // - добавить задачу в конкретную очередь

      Queue::pushOn('emails', new SendEmail($message));


    // bulk()
    //----------------------------------------//
    // - добавить N задач в очередь

      Queue::bulk([new SendEmail($message), new AnotherCommand]);


    // later()
    //----------------------------------------//
    // - добавить отложенную задачу в очередь

      - Добавим задачу SendEmail в очередь.
      - И скажем, что она должна выполниться через 15 минут.
      - Добавим:

        $date = Carbon::now()->addMinutes(15);
        Queue::later($date, new SendEmail($message));

      - Можно туда передать объект Carbon.
      - А можно просто число (в секундах).


  > Демон vs внешний сервис 

    Чтобы очереди работали, нужен процесс, их запускающий
    -----------------------------------------------------
      - Сабж.
      - Тут 2 варианта:

        1) Демон на нашем сервере
          - Демон раз в N секунд запускает наш механизм очередей.

        2) Внешний сервис, периодически "теребящий" наш скрипт
          - Внешний сервис раз в N секунд запускает наш мехаризм очередей.      

    Демон queue:listener
    --------------------
      - Запустить его можно так:

          php artisan queue:listen

      - Он будет работать до тех пор, пока его не выключат вручную.
      - Уточнить соединение, которое он будет использовать, можно так:

          php artisan queue:listen connection

      - Задать MAX кол-во неудачных попыток выполнить задачу, можно так:

          php artisan queue:listen --tries=5

      - Задать timeout в секундах для задачи можно так:

          php artisan queue:listen --timeout=60

      - Задать частоту опросов можно так:

          php artisan queue:listen --sleep=5

      - Выполнить первую задаче в очереди можно так:

          php artisan queue:work

    Iron.io
    -------
      - Сервис Iron.io
      - 29$/месяц минимум (09.06.2015)
      - Написать документацию по необходимости


  > Класс-задача vs анонимная функция

    Что из себя представляет задача
    -------------------------------
      - Тут 2 варианта:

        1) Отдельный класс (команда)
        2) Анонимная функция

    Задача: класс-команда
    ---------------------
      - Команды описаны в отдельном разделе этой методички.
      - В целом, лучше использовать отдельные классы-команды.
      - Их можно распихать по модулям, к которым они относятся.


    Задача: анонимная функция
    ------------------------- 
       
      Queue::push(function($job) use ($id)
      {
          Account::delete($id);

          $job->delete();
      });       


  > Провалившиеся задачи

    Таблица провалившихся задач failed_jobs
    ---------------------------------------
      - Допустим, мы добавили нашу задачу в очередь.
      - И она провалилась MAX заданное количество раз.
      - То есть, она так до конца и не исполнилась ни разу.
      - После этого, она автоматически попадает в таблицу failed_jobs.
      - Правда, сначала эту таблицу надо создать:

          php artisan queue:failed-table

    Указать лимит на MAX число неудачных попыток выполнить задачу
    -------------------------------------------------------------
      - Можно при запуске демона queue:listen.
      - Вот так:

          php artisan queue:listen connection-name --tries=3

    Зарегистрировать событие "провал задачи"
    ----------------------------------------
      - Оно будет выполнено, когда задача провалится.
      - Зарегистрировать его можно так:

          Queue::failing(function($connection, $job, $data)
          {
              //
          });          

    Метод failed(), срабатывает в случае провала
    --------------------------------------------
      - Его можно определить прямо в классе задачи.
      - Когда задача провалится, этот метод будет выполнен.
      - Пример:

          public function failed()
          {
              // Called when the job is failing...
          }      

    Посмотреть список всех проваленных задач
    ----------------------------------------
      - Можно так:

          php artisan queue:failed

      - В списке можно увидеть ID каждой проваленной задачи.

    Попробовать выполнить проваленную задачу с ID
    ---------------------------------------------
      - Можно так:

          php artisan queue:retry 5

    Удалить проваленную задачу с ID из списка
    -----------------------------------------
      - Можно так:

          php artisan queue:forget 5

      - А удалить все проваленные задачи из списка можно так:

          php artisan queue:flush


Г15.  Сессии

  --------------------------------------
  Подоглавление:

    # Введение
    # Настройка

      - Где находится конфиг сессий
      - Настройки в конфиге сессий
      - Если вы используете драйвер database для сессий

    # Основы использования

      - Хелпер session()  | помогает работать с сессиями
      - put()             | сохранить в сессию
      - push()            | сохранить в массив, который в сессии
      - get()             | извлечь из сессии
      - pull()            | извлечь из сессии, и удалить оттуда
      - all()             | извлечь всё из сессии
      - has()             | проверить по ключу, есть ли в сессии
      - forget()          | удалить из сессии по ключу
      - flush()           | удалить всё из сессии
      - regenerate()      | перегенерировать id сессии

      - flash()           | зафлэшить в сессию
      - reflash()         | перефлэшить все флэш-данные в сессии
      - keep()            | перевлэшить флэш-данные в сессии с указанными ключами

  --------------------------------------

  > Введение
    - Сессия позволяет сохранять данные между запросами пользователя.
    - Сессии используются, например, в механизме аутентификации пользователей.
    - Laravel предоставляет единый API для всех доступных реализаций сессионных механизмов.
    - Какой бы из них вы не выбрали, использовать надо один и тот же API.

  > Настройка
    
    Где находится конфиг сессий
    ---------------------------
      - По адресу: 'config/session.php'.
    
    Настройки в конфиге сессий
    --------------------------

      # driver
        - Указать какой механизм сессий будет задействован.
        - Какой бы из них вы не выбрали, использовать надо один и тот же API.
        - Доступные варианты:

          # 'file' [по умолчанию]
            - Сессионные данные будут храниться в файле.
            - Такой вариант подойдёт для большинства приложений.

          # 'cookie'
            - Сессионные данные будут храниться в куках.

          # 'database'
            - Сессионные данные будут храниться в базе данных.

          # 'aps'
            - Сессионные данные будут храниться в оперативной памяти.
            - APC - Alternative PHP Cache - дополнение к PHP.
            - Инструкция: http://php.net/apc/

          # 'memcached'
            - Сессионные данные будут храниться в оперативной памяти.
            - Более продвинутая система, чем APC.
            - Официальный сайт: http://memcached.org/

          # 'redis'
            - Сессионные данные будут хранитсья в redis.
            - Redis - это NoSQL база данных
            - Официальный сайт: http://redis.io/topics/quickstart
            - Скачать последнюю версию для windows можно здесь: https://github.com/rgl/redis/downloads

          # 'array'
            - Сессионные данные будут хранитсья в простом PHP-массиве.
            - Массив живёт до конца обработки запроса.
            - Данные между запросами не сохраняются.
            - !Этот драйвер используют ТОЛЬКО для unit-тестов!
            - Потому что по факту он не реализует механизм сессии.

      # lifetime        | Время в минутах, в течение которого хранятся
                          сессионные данные, и после которого они становятся expired

      # expire_on_close | Можно сделать так, чтобы сессионные данные становились
                          expired сразу после закрытия браузера, тогда надо указать true.
                          По умолчанию укзано false.

      # encrypt         | шифровать ли автоматически сессионные данные

      # files           | Если driver == 'file', то надо указать папку, где будут
                          хранится сессионные файлы.

      # connection      | Если driver == "database', или driver == "redis", то
                          надо указать имя соединения из коллекции соединений
                          в файле database.php, которое будет использоваться.

      # table           | Если driver == "database', то надо указать таблицу в БД,
                          в которой будут хранитсья данные сессий.

      # lottery         | Некоторым технологиям по работе с сессиями надо вручную
                          периодически очищать своих хранилища от старых сессий.
                          Здесь указана вероятность запуска этого процесса на каждом
                          запросе (по умолчанию, случайная от 2% до 100%).

      # cookie          | Здесь указано имя сессионной куки, которая будет
                          содержать UID сессии. Используется для любой сессионной
                          технологии.

      # path            | Адрес (начиная от корня приложения), начиная с которого
                          будет проверяться доступность сессионной куки. По умолчанию
                          стоит корень приложения '/'

      # domain          | ?

      # secure          | Если true, сессионные куки отправляются обратно на сервер
                          только в случае, если используется защищённое HTTPS-соединение.
                          По умолчанию false.

    Если вы используете драйвер database для сессий
    -----------------------------------------------
      - Допустим, мы используем 'database' в качестве значения параметра 'driver'.
      - Тогда нам надо создать таблицу, отвечающую всем требованиям.
      - Легко сделать это можно с помощью команд Schema Builder или Artisan.

      # Создать требуюмую таблицу с помощью Schema Builder

          Schema::create('sessions', function($table)
          {
              $table->string('id')->unique();
              $table->text('payload');
              $table->integer('last_activity');
          });

      # Создать требуюмую таблицу с помощью Artisan
        - Открыть консоль, перейти в корень приложения.
        - Выполнить следующие команды:

            php artisan session:table
            composer dump-autoload
            php artisan migrate


  > Основы использования

    // Хелпер session()
    //----------------------------------------//
    // - помогает работать с сессиями

      - Есть хелпер session(), помогающий работать с сессиями.
      - Если вызван без аргументов, возвращает объект-сессию:

        $session = session();

      - Либо его можно использовать с аргументами, как показано ниже.


    // put()
    //----------------------------------------//
    // - сохранить в сессию

      Session::put('key', 'value');
      session(['key' => 'value']);


    // push()
    //----------------------------------------//
    // - сохранить в массив, который в сессии

      Session::push('user.teams', 'developers');


    // get()
    //----------------------------------------//
    // - извлечь из сессии

      $value = Session::get('key');
      $value = session('key');


    // pull()
    //----------------------------------------//
    // - извлечь из сессии, и удалить оттуда

      $value = Session::pull('key', 'default');


    // all()
    //----------------------------------------//
    // - извлечь всё из сессии

      $data = Session::all();


    // has()
    //----------------------------------------//
    // - проверить по ключу, есть ли в сессии

      if (Session::has('users'))
      {
          //
      }


    // forget()
    //----------------------------------------//
    // - удалить из сессии по ключу

      Session::forget('key');      


    // flush()
    //----------------------------------------//
    // - удалить всё из сессии

      Session::flush();


    // regenerate()
    //----------------------------------------//
    // - перегенерировать id сессии

      Session::regenerate();


    // flash()
    //----------------------------------------//
    // - зафлэшить в сессию

      - Иногда требуется сохранить эл-т в сессию до следующего запроса.
      - Чтобы после след.запроса этот элемент самоудалился из сессии.
      - Такой способ сохранени по английски называют 'flash data'.
      - Зафлэшим в сессию элемент с ключём 'key' и значением 'value'.

        Session::flash('key', 'value'); 


    // reflash()
    //----------------------------------------//
    // - перефлэшить все флэш-данные в сессии

      - Допустим, мы зафлэшили некоторые данные в сессию на запросе №1.
      - Наступил запрос №2, и эти данные нам в сессии доступны.
      - Но на запросе №3 этих даных уже небудет.
      - А что, если нам надо, чтобы флэш-данные из запроса №2 перекочевали
        в запрос №3?
      - В этом поможет метод reflash().

        Session::reflash();    


    // keep()
    //----------------------------------------//
    // - перевлэшить флэш-данные в сессии с указанными ключами

      - Перефлэшить только элементы с ключами 'username' и 'email'.

        Session::keep(array('username', 'email'));    


Г16.  Валидация

  --------------------------------------
  Подоглавление:

    # Введение

      - Общая информация о валидации в Laravel
      - Есть ли польза от функционала валидации?

    # Использование механизма валидации Laravel

      - Создание объекта валидации $validator
      - $validator->after()     | назначить callback, кот.выполнится после валидации
      - $validator->fails()     | провалилась ли валидация

    # Работа с ошибками валидации

      - Создание объекта с ошибками валидации $messages
      - $messages->first('key', 'format') | получить первое сообщение об ошибке для поля key
      - $messages->get('key')             | получить все сообщения об ошибках для поля key
      - $messages->all('format')          | получить все сообщения об ошибках для всех полей
      - $messages->has('key')             | проверить, есть ли сообщение об ошибке для ключа key

      - Изменение сообщений об ошибках
      - В объекте-валидаторе: ошибка правила валидации
      - В объекте-валидаторе: атрибут-специфичная ошибка правила валидации
      - В языковом файле: ошибка правила валидации
      - В языковом файле: атрибут-специфичная ошибка правила валидации
      
      - Использование плейсхолдеров в сообщениях об ошибках
      - Как перезаписать сообщения об ошибках "стандартных" правил валидации
      - Какие правила вадилации приоритетнее: переданные в объект-валидатор, или из языкового файла

    # Условное задание правил валидации

      - Правило sometimes       | валидировать поле, если передано
      - $validator->sometimes() | валидировать поле, если выполнено условие

    # Кастомные правила валидации
      
      - Зачем нужны кастомные правила валидации
      - Где определять кастомные правила валидации
      - Определение кастомного правила валидации

  --------------------------------------

  > Введение
    
    Общая информация о валидации в Laravel
    --------------------------------------
      - Laravel поддерживает несколько подходов для валидации данных.
      - По умолчанию, используется трейт ValidatesRequests.
      - Его использует базовый класс-контроллер фреймворка.
      - Это позволяет удобно проверять входящие через HTTP-запрос данные.
      - Применяя разнообразные правила валидации, включая кастомные.

    Есть ли польза от функционала валидации?
    ----------------------------------------
      - При разработке приложения, приходится делать множество интерфейсов.
      - Из многих интерфейсов требуется принимать и проверять данные.
      - Для проверки данных часто требуется применять один и тот же проверочный функционал.
      - И так, из раза в раз, приходится copy-paste один и тот же функционал.
      - Это не удобно, поэтому, лучше воспользоваться функционалом валидации от Laravel.
      - Можно просто создавать кастомные правила валидации, по мере надобности.
      - Однажды созданное правило валидации можно использовать где и когда угодно.
      - Это удобно.


  > Использование механизма валидации Laravel

    Создание объекта валидации $validator
    -------------------------------------
      - Допустим, мы находимся в каком-нибудь контроллере.
      - И нам надо осуществлять в нём какую-то валидацию.
      - Перед осуществлением валидации, надо создать объект из сабжа.
      - Создать этот объект можно с помощью фасада Validator.
      - Данный фасад указывает на класс Illuminate\Validation\Factory.
      - Не забыть импортировать фасады Validator и Request в контроллер.
      - Итак, создаём объект-валидатор:

          $validator = Validator::make($request->all(), [
              'title' => 'required|unique:posts|max:255',
              'body' => 'required',
          ]);      

        1) Первый аргумент
          - Это данные для валидации.
          - В примере мы просто передаём все данные из запроса.

        2) Второй аргумент
          - К каким данным какие правила валидации применять.
          - Можно указывать как втроенные, так и кастомные.
          - Несколько правил можно указать через pipe, в стиле:
              'required|unique:posts|max:255'

    $validator->after()
    -------------------
      - Назначить callback, который выполнится после валидации.
      - Объекту-валидатору можно назначить анонимную функцию.
      - Она исполнится после осуществления валидации.
      - Это делается вот так (пример):

          $validator->after(function($validator) {
              if ($this->somethingElseIsInvalid()) {
                  $validator->errors()->add('field', 'Something is wrong with this field!');
              }
          });      

    $validator->fails()
    -------------------
      - Провалилась ли валидация (true/false).
      - С помощью falis() мы выполняем, собственно, саму валидацию.
      - Метод вернёт true в случае, если валидация прошла неудачно.
      - И вернёт false в случае, если валидация прошла успешно.
      - Вот, как его можно использовать:

          if ($validator->fails()) {
            
            // Что происходит в случае неудачной валидации
          
          }      


  > Работа с ошибками валидации

    Создание объекта с ошибками валидации $messages
    -----------------------------------------------
      - Получить объект со всеми ошибками валидации.
      - Работать с ним надо уже после проведения валидации.
      - Получить:

          $messages = $validator->errors();


    $messages->first('key', 'format')
    ---------------------------------
      - Получить первое сообщение об ошибке для поля key.
      - Второй аргумент не обязателен.
      - Пример:

          $msg = $messages->first('key');

      - Также можно извлечь значение сразу в определённом формате.
      - Например:

          $msg = $messages->first('key', '<p>:message</p>');


    $messages->get('key')
    ---------------------
      - Получить все сообщения об ошибках для поля key.
      - Ведь для 1 поля могут быть заданы N правил валидации.
      - Соответственно, может быть и N сообщений об ошибках.
      - Пример:

          $msgs = $messages->get('key');
          foreach ($msgs as $message) {
              //
          }          


    $messages->all('format')
    ------------------------
      - Получить все сообщения об ошибках для всех полей.
      - Аргумент здесь не обязателей.
      - Пример:

          $allMsgs = $messages->all();
          foreach ($allMsgs as $message) {
              //
          } 

      - Также можно извлекать значения сразу в определённом формате.    
      - Например:

          $allMsgs = $messages->all('<li>:message</li>');
          foreach ($allMsgs as $message) {
              //
          }            


    $messages->has('key')
    ---------------------
      - Проверить, есть ли сообщение об ошибке для ключа key.
      - Пример:

          if ($messages->has('key')) {
              //
          }

    
    Изменение сообщений об ошибках
    ------------------------------
      - Все правила валидации где-то определены.
      - Для каждого из правил определены и сообщения об ошибках.
      - Для "встроенных" правил они хранятся в en-языковом файле:
          resources/lang/en/validation.php
      - Для "кастомных" правил есть 2 варианта:

          1) Задавать сообщения об ошибках при определении объекта-валидатора
          2) Помещать их в ru-языковой файл в resources/lang/ru/validation.php

    В объекте-валидаторе: ошибка правила валидации
    ----------------------------------------------
      - Перед созданиме объекта-валидатора готовим переменную $messages.
      - Он должна содержать массив следующего характера:

        $messages = [
          'Имя правила валидации' => 'Сообщение об ошибке'
          ...
        ];

      - Например:

          $messages = [
            'required' => 'The :attribute field is required.',
          ];
        
      - Теперь, можно создавать объект-валидатор.
      - Передаём $messages 3-м аргументом в make:

          $validator = Validator::make($input, $rules, $messages);
   

    В объекте-валидаторе: атрибут-специфичная ошибка правила валидации
    ------------------------------------------------------------------
      - Иногда одно правило валидации применяется к разным полям.
      - И хотелось бы иметь разные сообщения об ошибках для разных полей.
      - Это атрибут-специфичные ошибки правила валидации.
      - Они определяются с использованием dot-нотации.
      - По следующему принципу:

          [имя правила].[имя атрибута]

      - Например:

          $messages = [
            'email.required' => 'We need to know your e-mail address!',
          ];      


    В языковом файле: ошибка правила валидации
    ------------------------------------------
      
      Где определены сообщения об ошибках для "встроенных" правил валидации
      ---------------------------------------------------------------------
        - Для каждого из правил определены сообщения об ошибках.
        - Для "встроенных" правил они хранятся в en-языковом файле:
            resources/lang/en/validation.php
      
      Как Laravel выбирает, какой языковой файл использовать?
      -------------------------------------------------------
        - В св-ве locale, в config/app.php указан язык приложения по умолчанию.
        - Например, если там указано 'ru', фреймворк будет использовать файл:
            resources/lang/en/validation.php
        - В том же конфиге есть св-во fallback_locale, где указана запасная локаль (скажем, 'en')
        - Если данные по ключу отсутствуют в ru, фреймворк берёт из запасной - en.

      Как переопределить сообщение об ошибке для встроенного правила валидации
      ------------------------------------------------------------------------
        - Тут есть 3 варианта:

          1) Изменить это сообщение в resources/lang/en/validation.php
            - Тогда оно будет изменено навсегда.

          2) Определить сообщение с таким же ключём в resources/lang/ru/validation.php
            - Имеется в языковом файле текущей локали по умолчанию
            - Тогда фреймворк будет использовать это сообщение

          3) Передать массив с сообщениями при создании объекта-валидатора
            - Этот массив передаётся методу Validator::make 3-им аргументом.
            - Данный способ описан выше.


    В языковом файле: атрибут-специфичная ошибка правила валидации
    --------------------------------------------------------------
      - Атрибут-специфичные сообщения об ошибках надо класть в массив 'custom'.
      - Он находится в ниженей части языкового файла.
      - Вот так это выглядит:

        <?php

          return [

            ...

            'custom' => [
              'attribute-name' => [
                'rule-name' => 'custom-message',
              ],
            ],      

          ];

        ?>

    Использование плейсхолдеров в сообщениях об ошибках
    ---------------------------------------------------
      - В сообщениях об ошибках можно использовать плейсхолдеры.
      - Примеры:

          $messages = [
              'same'    => 'The :attribute and :other must match.',
              'size'    => 'The :attribute must be exactly :size.',
              'between' => 'The :attribute must be between :min - :max.',
              'in'      => 'The :attribute must be one of the following types: :values',
          ]; 

      - :attribute будет заменён на имя валидируемого поля.
      - :size будет заменён на переданное в правиле валидации значение.


    Какие правила вадилации приоритетнее: переданные в объект-валидатор, или из языкового файла
    -------------------------------------------------------------------------------------------
      - По убыванию приоритетности:

        1) Переданные в объект-валидатор в массиве 3-м аргументом
        2) Определённе в языковом файле текущей локали
        3) Определённые в языковом файле запасной локали (обычно, en)


  > Условное задание правил валидации

    Правило sometimes
    -----------------
      - Имеется в виду правило валидации sometimes.
      - Оно означает: "валидировать поле, если передано".
      - Если во входном массиве поле для валидации передано, то валидирвоать его.
      - А если не передано, то не валидировать.
      - Пример использования:

          $validator = Validator::make($data, [
              'email' => 'sometimes|required|email',
          ]);      

    $validator->sometimes()
    -----------------------
      - Валидировать поле, если выполнено условие. Или условия.
      - Это можно назвать продвинутым вариантам правила валидации sometimes.
      - Здесь можно задавать уже любые условия.
      - Если эти условия выполнены, то валидация поля проводится.
      - А если не выполнены, то не проводится.
      - Пример:

        - Допустим, у нас сайт знакомств.
        - Нам надо проверять данные из формы регистрации.
        - В форме человек может указать в т.ч. пол: свой и предпочтение.
        - Если свой пол указан, то предпочитаемый пол берётся противоположный по умолчанию
        - А если не указан, то предпочитаемый пол становится обязательным для заполнения.
        - Вот, как можно реализовать такую проверку:

            $v = Validator::make($data, [
                'mysex' => 'required|sex',
            ]);            

            $validator->sometimes('partnersex', 'required|sex', function($input) {
              return !empty($input->mysex);
            });            


  > Кастомные правила валидации

    Зачем нужны кастомные правила валидации
    ---------------------------------------
      - В Laravel есть большой набор встроенных правил валидации.
      - Во многих ситуациях можно использовать их.
      - Правда, их сообщения об ошибках на английском языке.
      - Поэтому, их надо переопределять при создании объекта-валидатор, 
        или в русском языковом файле.
      - Проблема ещё в том, что стандартные правила заточены под en язык.
      - И кроме того, покрывают лишь ограниченный набор случаев.
      - Поэтому существует возможность создавать кастомные правила валидации.
      - И это хорошо.

    Где определять кастомные правила валидации
    ------------------------------------------
      - В методе boot() любого сервис-провайдера.

    Определение кастомного правила валидации
    ----------------------------------------
      - Дело происходит в контексте метода boot() сервис-провайдера.
      - Создадим кастомное правило валидации 'foo'.
      - Пример:

          Validator::extend('foo', function($attribute, $value, $parameters) {
              return $value == 'foo';
          });      

      - Вторым аргументом идёт анонимная функция.
      - Она принимает следующие аргументы:

        $attribute    | имя атрибута, который надо валидировать
        $value        | значение атрибута, который надо валидировать
        $parameters   | параметры, переданные в правило валидации

      - Если анон.функция вернёт true, значит валидация успешно прошла.
      - А если false, значит безуспешно.
      - Ещё есть вариант передать метод контроллера вместо анон.функции:

        Validator::extend('foo', 'FooValidator@validate');

      - Сообщение об ошибке для него можно определить, как описано выше.


Г17.  Планировщик задач

  --------------------------------------
  Подоглавление:

    # Введение

      - Cron в Linux
      - Периодическое выполнение работ в web-приложениях
      - Принцип работы планировщика задач в Laravel

    # Планированин задач

      - Общая информация о планировании задач
      - call()              | добавить closure в планировщик
      - command()           | добавить artisan команду в планировщик
      - exec()              | добавить команду ОС в планировщик
      - withoutOverlapping()| не запускать > 1 экземпл.задачи одновременно
      - then([closure])     | выполнится после выполнения задачи
      - thenPing([url])     | пошлёт 1 запрос на указанный url

      - cron('* * * * *')   | тонкая настройка периодичности запуска задачи
      - everyMinute()       | запускать каждую минуту
      - everyFiveMinutes()  | запускать каждые 5 минут
      - everyTenMinutes()   | запускать каждые 10 минут
      - everyThirtyMinutes()| запускать каждые 30 минут
      - hourly()            | запускать каждый час
      - daily()             | запускать каждый день
      - dailyAt('13:00')    | запускать каждый день в указанное время
      - twiceDaily()        | запускать 2 раза в день, в 1:00 и 13:00
      - weekly()            | запускать еженедельно
      - monthly()           | запускать ежемесячно
      - Эти методы можно комбинировать друг с другом

      - at()            | во сколько точно запускать
      - weekdays()      | только по будним дням
      - sundays()       | только по воскресеньям
      - mondays()       | только по понедельникам
      - tuesdays()      | только по вторникам
      - wednesdays()    | только по средам
      - thursdays()     | только по четвергам
      - fridays()       | только по пятницам
      - saturdays()     | только по субботам
      - when([Closure]) | только, если выполнено условие в closure (и оно вернуло true)

    # Работа с результатами выполненных задач

      - sendOutputTo()  | [ТОЛЬКО ДЛЯ command()] записывает вывод команды в указанный файл
      - emailOutputTo() | [ТОЛЬКО ДЛЯ command()] отправляет вывод команды на указанный адрес email

  --------------------------------------

  > Введение

    Cron в Linux
    ------------
      - В Linux есть такая программа Cron.
      - Она выполняет указанные программы с указанной периодичностью.
      - Например, Cron может запускать программу каждую минуту.

    Периодическое выполнение работ в web-приложениях
    ------------------------------------------------
      - В web-приложениях м.б. работы, которые надо выполнять периодически.
      - Представим, что мы разрабатываем интернет-магазин.
      - Имеется список товаров, и, допустим, 1 поставщик для них.
      - Данные о наличии и себестоимости товаров можно скачать с сайта поставщика.
      - Мы хотим, чтобы цены и наличие у нас были самые актуальные.
      - Поэтому, скачивать данные и обновлять по ним свою БД надо периодически.
      - Вот это как раз работа, которую можно поместить в планировщик задач.
      - Допустим, чтобы он выполнял её каждый час.

    Принцип работы планировщика задач в Laravel
    -------------------------------------------
      
      # Общий принцип крупным планом
        - В конфиг Cron'а в Linux мы добавляем задачу.
        - Эта задача выполняет ежеминутно artisan-команду schedule:run.
        - Команда выполняется в указанном нами экземпляре приложения Laravel.
        - Команда проверяет, какие задачи д.б. выполнены сейчас, и запускает их.
        - Эти самые задачи мы можем добавить в планировщик, и настроить (об этом ниже).
        - Задачами могут быть:

            1) Анонимная функция (АФ)
            2) Команды artisan
            3) Команды операционной системы

        - Собственно говоря, из АФ можно вызывать laravel-команды.
        - После выполнения кода, из АФ можно возвращать какую-нибудь строку.
        - А потом записывать её в файл, посылать по email, и т.д.
        - Но об этом ниже, в разделе про работу с результатами выполненных задач.

      # В какой именно конфиг cron'a добавлять задачу?

        1) Вариант №1: с помощью crontab -e
          - Вводим команду: crontab -e
          - И там, в конце, добавляем строку (шаблон):

              * * * * * php /path/to/artisan schedule:run 1>> /dev/null 2>&1      

          - Реальный пример:

              * * * * * php /home/vagrant/projects/zaste.ru/artisan schedule:run 1>> /dev/null 2>&1

        2) Вариант №2: в каталог /etc/cron.d
          - Для каждого проекта понадобится добавлять отдельную задачу.
          - Удобно для каждой задачи создавать отдельный файл в каталоге cron.d
          - Cron будет считывать все эти файлы, и выполнять задачи из них.
          - Особенности:

            - Имена файлов должны содержать лишь: a-z0-9_-
            - Владельцем файла должен быть root.
            - Права на запись д.б. лишь у пользователя (но не группы, и не общие).
            - В 6-м столбце команды должны содержать имя пользователя.

          - Пример имени такого файла: laravel-zaste
          - Это имя говорит о том, что файл имеет отношение к Laravel.
          - И указывает, что он относится конкретно к проекту zaste.
          - Пример содержимого файла:

              * * * * * root php /home/vagrant/projects/zaste.ru/artisan schedule:run 1>> /dev/null 2>&1          

  > Планированин задач

    Общая информация о планировании задач
    --------------------------------------
      - Планирование задач производится в app/Console/Kernel.php.
      - А именно, в методе schedule этого класса.
      - Все задачи планируются в 1 месте, потому что это удобно.
      - "На 1 экране" видно, какие задачи когда должны выполняться.
      - А логика самих задач лежит в отдельных laravel-классах-командах.
      - Вот, как выглядит Kernel.php, с примером планирования задачи:

          <?php namespace App\Console;

          use DB;
          use Illuminate\Console\Scheduling\Schedule;
          use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

          class Kernel extends ConsoleKernel
          {

              // Команды artisan приложения
              protected $commands = [
                  'App\Console\Commands\Inspire',
              ];

              // Здесь надо планировать задачи
              protected function schedule(Schedule $schedule)
              {

                  //--------------------//
                  // Ежедневно, в 00:00 //
                  //--------------------//
                  $schedule->call(function () {
                      DB::table('recent_users')->delete();
                  })->daily();
              
              }
          }      

    // call()
    //----------------------------------------//
    // - Добавить closure в планировщик.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->daily();


    // command()
    //----------------------------------------//
    // - Добавить artisan команду в планировщик.

      $schedule->command('emails:send --force')->daily();


    // exec()
    //----------------------------------------//
    // - Добавить команду ОС в планировщик.

      $schedule->exec('node /home/forge/script.js')->daily();


    // withoutOverlapping()
    //----------------------------------------//
    // - Не запускать > 1 экземпл.задачи одновременно.

      - По умолчанию, 2-я задача запустится, даже если 1-ая не закончила.
      - Такое поведение не всегда может устроить.
      - Поэтому, можно запретить оверлапинг:

        $schedule->command('emails:send')->withoutOverlapping();


    // then([closure]) 
    //----------------------------------------//
    // - Выполнится после выполнения задачи.

      - Можно выполнять некую работу после выполнения задачи.
      - Допустим, писать какие-нибудь данные в лог, и т.д.
      - Пример:

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->daily()->then(function(){

          // некая работа

        });


    // thenPing([url])
    //----------------------------------------//
    // - Пошлёт 1 запрос на указанный url.

      - Эта команда после выполнения задачи пингует указанный url.
      - Метод полезен для уведомления внешнего сервиса о завершении задачи.
      - Например такого, как Laravel Envoyer.
      - Команда требует наличия библиотеки Guzzle HTTP.
      - Нужно в composer.json проекта, в require, добавить зависимость:

          "guzzlehttp/guzzle": "~5.3|~6.0"

      - И не забыть выполнить dump-autoload после этого.
      - Пример использования thenPing:

          $schedule->call(function () {
              
            return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

          })->thenPing('http://www.site.ru/');


    // cron('* * * * *')
    //----------------------------------------//
    // - Тонкая настройка периодичности запуска задачи.

      - Подробнее об этом можно посмотреть в man'ах Cron'а.
      - Но приведём здесь достаточные справочные данные.
      - Как видно, у нас есть 5 звёздочек. 
      - Вот что они означают (в порядке слева-направо):

          1      2   3    4     5      
          -----------------------------
          минута час день месяц неделя 

      - Примеры:

          '17 * * * *'    | каждый час, на 17-й минуте
          '25 6 * * *'    | ежедневно, в 6:25
          '47 6 * * 7'    | еженедельно, в 6:47
          '52 6 1 * *'    | ежемесячно, 1-го числа, в 6:52

      - Пример использования:

          $schedule->call(function () {
              
            return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

          })->cron('17 * * * *');


    // everyMinute()
    //----------------------------------------//
    // - Запускать каждую минуту.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->everyMinute();


    // everyFiveMinutes()
    //----------------------------------------//
    // - Запускать каждые 5 минут.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->everyFiveMinutes();


    // everyTenMinutes()
    //----------------------------------------//
    // - Запускать каждые 10 минут.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->everyTenMinutes();


    // everyThirtyMinutes()
    //----------------------------------------//
    // - Запускать каждые 30 минут.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->everyThirtyMinutes();


    // hourly()
    //----------------------------------------//
    // - Запускать каждый час.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->hourly();


    // daily()
    //----------------------------------------//
    // - Запускать каждый день.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->daily();


    // dailyAt('13:00')
    //----------------------------------------//
    // - Запускать каждый день в указанное время.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->dailyAt('13:00');


    // twiceDaily()
    //----------------------------------------//
    // - Запускать 2 раза в день, в 1:00 и 13:00.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->twiceDaily();


    // weekly()
    //----------------------------------------//
    // - Запускать еженедельно.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->weekly();


    // monthly()
    //----------------------------------------//
    // - Запускать ежемесячно.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->monthly();


    Эти методы можно комбинировать друг с другом
    --------------------------------------------
      - Например, мы хотим, чтобы задача запускалась еженедельно.
      - Мы хотим уточнить, чтобы она запускалась по понедельникам.
      - А также хотим уточнить, чтобы она запускалась в 13:00.
      - Вот, как это устроить:

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->weekly()->mondays()->at('13:00');     


    // at()
    //----------------------------------------//
    // - Во сколько точно запускать.

      - См. пример выше.


    // weekdays()
    //----------------------------------------//
    // - Только по будним дням.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->weekdays(); 


    // sundays()
    //----------------------------------------//
    // - Только по воскресеньям.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->sundays(); 


    // mondays()
    //----------------------------------------//
    // - Только по понедельникам.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->mondays(); 


    // tuesdays()
    //----------------------------------------//
    // - Только по вторникам.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->tuesdays(); 


    // wednesdays()
    //----------------------------------------//
    // - Только по средам.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->wednesdays(); 


    // thursdays()
    //----------------------------------------//
    // - Только по четвергам.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->thursdays(); 


    // fridays()
    //----------------------------------------//
    // - Только по пятницам.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->fridays(); 


    // saturdays()
    //----------------------------------------//
    // - Только по субботам.

        $schedule->call(function () {
            
          return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

        })->saturdays(); 


    // when([Closure])
    //----------------------------------------//
    // - Только, если выполнено условие в closure (и оно вернуло true)

      - Возможно добавить доп.условия, необходимые для старта задачи.
      - Например, вернёмся к нашему примеру с интернет-магазином.
      - Перед запуском задачи можно проверить доступность данных от поставщика.
      - Можно также проверить, изменились ли они, и их валидность.
      - И если данные есть, валидны и новы, то выполнять задачу по обновлению.
      - Это как раз и можно организовать с помощью метода when.
      - Пример:

          $schedule->call(function () {
              
            return Bus::dispatch(new SomeCommand());  // запуск laravel-команды    

          })->when(function(){

            // Проверка всяких условий
            return true;

          }); 

  > Работа с результатами выполненных задач

    // sendOutputTo()
    //----------------------------------------//
    // - [ТОЛЬКО ДЛЯ command()] Записывает вывод команды в указанный файл.

      - !!! Не работае для call() !!!
      - Этот вывод можно записывать в файл.
      - Например:

          $schedule->command('emails:send')
            ->daily()
            ->sendOutputTo($filePath); 


    // emailOutputTo()
    //----------------------------------------//
    // - [ТОЛЬКО ДЛЯ command()] Отправляет вывод команды на указанный адрес email.  

      - !!! Не работае для call() !!!
      - Вывод команды можно отправлять и по email.
      - !НО перед emailOutputTo надо использовать sendOutputTo.
      - Иначе рабоать не будет.
      - Плюс, надо настроить почту в приложении, чтобы она работала.
      - Пример использования:

          $schedule->command('foo')
            ->daily()
            ->sendOutputTo($filePath)
            ->emailOutputTo('foo@example.com');       


Г18.  Трансляция событий через websocket

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

      - Про протокол HTTP
      - Про протокол WebSocket
      - О преимуществах протокола WebSocket над технологией AJAX
      - Проверка работоспособности Redis и Nodejs
      - Организация автозапуска queue listener и websocket-сервера при старте Ubuntu

    # Как работает транслятор: теоретическая база

      - Путь события от определения до клиента: наглядно
      - Про паттерн pub/sub
      - Redis, как посредник между Laravel и nodejs-сервером
      - Пояснения по именам каналов вдоль всей схемы
      - Как клиенты (в js) получают транслируемое сообщение?

    # Подготовка транслятора к работе

      - Настроить конфиг broadcasting.php
      - Установить Redis, и зависимость predis
      - Установить nodejs и необходимые модули
      - Запустить демон queue:listener
      - Подготовить и запустить nodejs-сервер

    # Использование транслятора
    
      - Определение транслируемого события
      - Как выглядит базовое транслируемое событие
      - Какие данные будут транслироваться

    # Приём сообщений от транслятора в клиенте (JS)

      - Подключить клиентскую библиотеку socket.io
      - Подключиться к серверу nodejs, и слушать нужные каналы

  --------------------------------------

  > Ссылки

    # Статья Ильи Кантора про websocket на learn.javascript.ru
        http://learn.javascript.ru/websockets

    # Видео Taylor Otwell про трансляцию событий через websocket в Laravel 5.1
        https://laracasts.com/lessons/broadcasting-events-in-laravel-5-1

    # Статьи на тему транслятора в L5 с драйвером Redis, в порядке убыванию по интересности:
        http://www.codetutorial.io/laravel-5-and-socket-io-tutorial/
        http://blog.nedex.io/laravel-5-1-broadcasting-events-using-redis-driver-socket-io/
        https://mattstauffer.co/blog/broadcasting-events-with-pusher-socket-in-laravel-5.1


  > Введение

    Про протокол HTTP
    -----------------
      - В 1992 году был опубликован протокол HTTP (Hypertext Transfer Protocol).
      - С тех пор используется, как основной, для взаимодействия с веб-приложениями.
      - HTTP обладает следующими характерными особенностями:

        1) Асимметричный 
          - Стороны взаимодействия не равны, а выполняют разные роли.
          - В данном случае, одна сторона - сервер, вторая - клиент.
          - Клиент может отправлять серверу HTTP-запросы.
          - А сервер должен возвращать клиенту HTTP-ответы.

        2) Синхронный
          - Клиент посылает на сервер HTTP-запрос.
          - И в ответ получает HTTP-ответ.
          - Ответ никак не может прийти раньше запроса.


    Про протокол WebSocket
    ----------------------
      - В 2011 году протокол WebSocket получил статус RFC.
      - Сейчас, в 2015 году, он не заменил HTTP, но дополнил его.
      - WebSocket обладает следующими характерными особенностями:

        1) Симметричный
          - Стороны взаимодействия являются равными участниками взаимодействия.
          - Здесь нет ролей клиента и сервера, как в HTTP.

        2) Асинхронный
          - Стороны могут отправлять друг-другу сообщения, и принимать их.
          - И делать это в любых количествах, без ограничений.

        3) Полнодуплексный
          - Дуплексное устройство может в любой момент делать следующее.
          - Передавать и принимать информацию.
          - Пример полнодуплексной связи: разговор по телефону.
          - Каждый может в любой момент времени что-нибудь сказать.
          - И каждый может в любой момент времени услышать, что ему говорят.
 
        4) Кроссдоменный
          - Есть такая технология ajax, она не является кроссдоменной.
          - То есть, вы не пошлёте ajax-запрос с одного сайта на другой.
          - Это было сделано в целях безопасности, для защиты от XSS.
          - А WebSocket не имеет подобных ограничений.
          - Это позволяет вашему js-скрипту взаимодействовать с сервером на другом домене.

    О преимуществах протокола WebSocket над технологией AJAX
    --------------------------------------------------------
      - WebSocket открывает широкие возможности.
      - Можно создавать "живые" web-приложения.
      - Которые ведут себя также, как обычные приложения в ОС.
      - В демонстрационных целях рассмотрим пример с чатом.
      - В чат приходят новые сообщения от разных польозвателей.
      - У всех этих пользователей открыт в браузере документ с чатом.
      - И требуется обновлять его без перезагрузки, чтобы все видели новые сообщения.
      - Итак:

        > Реализация чата через технологию AJAX
          - Требуется, чтобы все периодически клиенты опрашивали сервер.
          - То есть, посылали ajax-запрос на сервер 1 раз в единицу времени.
          - И если есть новые сообщения, извлекали с сервера, и публиковали в клиенте.
          - У такого способа есть существенные минусы:

            1) Сервер должен находиться на том же домене.
            2) Высокая нагрузка на сервер.
              - Допустим, в чате сидят N человек.
              - Как указано выше, все клиенты должны периодически опрашивать сервер.
              - Поэтому, раз в единицу времени на сервер приходят N запросов.
              - Причём, это надо делать часто (раз в секунду), иначе чат будет тормознутый.
              - Что характерно, большинство из этих запросов - напрасная трата ресурсов сервера.
              - Потому что запросы идут вне зависимости от того, появились ли новые сообщения.


        > Реализация чата через протокол WebSocket
          - Все клиенты устанавливают соединения с сервером.
          - Когда клиент написал сообщение, оно сразу попадает на сервер.
          - А сервер сразу транслирует его для всех клиентов.
          - Клиенты его сразу получают, и публикуют.
          - Плюсы по сравнению с ajax:

            1) Сервер может находиться на любом домене, где угодно в интернете
            2) Низкая нагрузка на сервер
              - Бесполезная передача данных отсутствует.
              - Передача идёт лишь в случае наличия необходимости.
            3) Мгновенная передача
              - Задержка на период опроса, как в ajax, отсутствует.
              - Сообщение от клиента на сервер передаётся сразу после нажатия на кнопку.
              - Сообщение от сервера клиенту передаётся сразу после получения.

      - Однако, всё это не значит, что HTTP и AJAX больше не нужны.
      - HTTP + AJAX + WebSocket гармонично дополняют друг друга.
      - По крайней мере, на данный момент (2015-06-12).
      - А что будет в будущем? Посмотрим.

    Проверка работоспособности Redis и Nodejs
    -----------------------------------------

      # Проверить работоспособность Redis
        - Для этого открыть окно терминала сервера.
        - И выполнить команду: 

            redis-cli ping

        - Ответ должен быть: PONG
        - Ещё можно ввести команду: 

             ps aux | grep redis

        - И увидеть, запущен ли процесс сервера redis.

      # Проверить работоспособность Nodejs
        - Для этого открыть окно терминала сервера.
        - И выполнить команду: 

            node -v

        - В ответе должна быть версия Nodejs.

    Организация автозапуска queue listener и websocket-сервера при старте Ubuntu
    ----------------------------------------------------------------------------

      # Зачем
        - Чтобы каждый раз при перезагрузке сервера не запускать их вручную.

      # Инструкция

        1. Открыть окно терминала сервера

        2. Открыть файл /etc/rc.local
          - Для этого выполнить команду:

              sudo nano /etc/rc.local

        3. В конце, но перед exit 0, дописать следующий код (пример):

            # Отладка
            # exec 2> /tmp/rc.local.debug
            # set -x

            # Проверить наличие необходимых каталогов
            # - Их может и не быть в наличии, т.к. NFS может ещё не успеть их подключить
            # - В этом случае, скрипт ждёт 5 секунд, и проверяет снова.

              # Подготовить переменную есть/нет
              IS="no";

              # Запустить цикл, пока IS=="no"
              while [ $IS == "no" ]; do

                # Если требуемые каталоги есть, то присвоить переменной IS значение "yes"
                if [ -d "/home/vagrant/projects/zaste.ru" ]; then
                  if [ -d "/home/vagrant/projects/zaste.ru/app/Websocket" ]; then
                    IS="yes"
                  fi
                # В противном случае, подождать 5 сек., и попробовать снова
                fi
                sleep 5

              done

            # Запустить демон queue:listen
            cd "/home/vagrant/projects/zaste.ru"
            php artisan queue:listen > /dev/null 2>&1 &

            # Запустить websocket-сервер
            cd "/home/vagrant/projects/zaste.ru/app/Websocket"
            nohup node socket.js > /dev/null 2>&1 &


  > Как работает транслятор: теоретическая база

    Путь события от определения до клиента: наглядно
    ------------------------------------------------

      -----------------      |  # Определить класс-событие 
      | Класс-событие |      |    
      -----------------      |    1. Список каналов   
                             |      - Куда транслировать.
              |              |      - Вернуть из метода broadcastOn, как массив строк.
Возбуждение   |              |
события       |              |    2. Данные
приводит к    |              |      - Которые транслировать.
её публикации |              |      - Это либо все public св-ва класса.
в определ-ые  |              |      - Либо вернуть из метода broadcastWith, как массив.
каланы в      |              |
Redis         |              |  # Возбудить событие 
              |              |    - Где-нибудь в коде.
              |              |    - Оно попадёт в Redis, в очередь. 
              |              |    
              |              |    
             \|/             |    
                             |    
          ---------          |  # Связующее звено
          | Redis |          |    - Между Laravel и nodejs.
          ---------          |    
                             |  # Реализует паттерн pub/sub 
Через паттерн |              |    - Laravel публикует событие в Redis.
pub/sub сообщ.|              |    - Используя паттерн pub/sub.
попадает к    |              |    - А подписчиком является сервер nodejs.
подписчику -  |              |
к nodejs     \|/             |
                             |
         ----------          |  # Подписчик в паттерне pub/sub Redis'а
         | Nodejs |          |    - Слушает все каналы.
         ----------          |    - Срабатывает при каждом новом сообщении.
                             |
Посылает     |               |  # Получив сообщение, транслирует клиентам
сообщение    |               |    - К nodejs подключены N клиентов.
всем подписч.|               |    - Им то он и транслирует данные.
через проток.|               |    - По протоколу websocket.
websocket    |               |
            \|/              |
                             |
         -----------         |  # Подключены к nodejs
         | Клиенты |         |    - Все клиенты подключены к nodejs.
         -----------         |
                             |  # Готовы принимать данные
                             |    - По протоколу websocket.
                             |
                             |


    Про паттерн pub/sub
    -------------------
      - Расшифровывается, как publisher/subsriber.
      - В этом паттерне есть 2 роли:

        1) Отправители
          - Могут публиковать сообщения.
          - Но эти соощения не адресованы конкретным получателям.
          - А посылаются в т.н. каналы.
          - По аналогии с частотой радио-канала.

        2) Подписчики
          - Могут принимать сообщения, отправляемые отправителями.
          - Но только из тех каналов, на которые подписаны.

      - Key-value хранилище Redis реализует паттерн pub/sub.


    Redis, как посредник между Laravel и nodejs-сервером
    ----------------------------------------------------
      
      # Redis, как посредник
        - Laravel не может сам отправить сообщение через websocket.
        - По какой причине, оставим за кадром.
        - Поэтому, приходится ему использовать nodejs.
        - Так как nodejs без проблем отправляет сообщения через websocket.
        - А общаются Laravel и nodejs посредством Redis.
        - А именно, используют паттерн pub/sub, которые реализует Redis.

      # Как происходит общение
        - Laravel публикует сообщение в Redis.
        - А nodejs "слушает" все возможные каналы.
        - При этом, к nodejs подключены N клиентов.
        - И получив сообщение, nodejs переправляет его клиентам.
        - По протоколу websocket.

   
    Пояснения по именам каналов вдоль всей схемы
    --------------------------------------------

      # В какие каналы Redis'а Laravel публикует сообщения
        - Класс транслируемого события где-то определен.
        - В нём есть метод broadcastOn.
        - Он возвращает массив строк.
        - Длина массива составляет N элементов.
        - В N каналов сообщения и транслируются.
 
      # На какие каналы Redis'а д.б. подписан сервер nodejs
        - На все каналы. Ведь классов-событий может быть много.
        - И в каждом из них есть свой метод broadcastOn.
        - Который возвращает свой набор имён каналов.
        - Поэтому, лучше пусть nodejs слушает все каналы.

      # Какие каналы слушать клиентам
        - Этот момент определяется в сервере nodejs (в функции emit).
        - Каждый клиент слушает те события, которые ему интересны.
        - Здесь есть важный нюанс в сфере уникальности.
        - По имени д.б. можно однозначно установить, что за
          событие было возбуждено в Laravel.
        - Для этого, в имени канала должно присутствовать
          имя этого события, квалифицированное полным пр.имён.
        - Подходящее решение, определять имя канала для клиентов, как:

            [x]:[y]

          - Где [x]: строка из массива из broadcastOn.
          - Где [y]: путь (с учётом пр.имён) к объекту-событию
          - Рассмотрим примерчик.
          - Допустим, broadcastOn возвращает такой масив:

            [
              'channel_1',
              'channel_2'
            ]

          - А событие у нас определено по адресу:
              App\\Events\\MyEventNameHere
          - При его возбуждении, Laravel опубликует его в 2
            канала со следующими именами:

              'channel_1:App\\Events\\MyEventNameHere'
              'channel_2:App\\Events\\MyEventNameHere'        


    Как клиенты (в js) получают транслируемое сообщение?
    ----------------------------------------------------

      # Клиентская библиотека socket.io
        - Клиенты используют данную js-библиотеку.
        - Вообще, socket.io имеет 2 части:

          1) Клиенсткую
          2) Серверную

        - Серверная часть поставляется, в виде модуля для nodejs.

      # Клиенты устанавливают соединения с сервером nodejs
        - Итак, клиенты используют библиотеку socket.io
        - С её помощью, они подключаются к серверу nodejs.
        - Устанавливают соединение, используя протокол websocket.

      # Каждый клиент "слушает" нужный ему канал
        - Выше было описано, как Laravel формирует имена каналов.
        - Каждый клиент должен подписаться на нужный ему канал.
        - Один клиент ждёт один набор событий, другой - другой набор.

      # Поймав новое событие, nodejs передаёт его всем подписчикам
        - Через открытые соединения, по протоколу websocket.
        - По соответствующим каналам.
        - Все подписчика данных каналов получают данное сообщение.


  > Подготовка транслятора к работе

    Настроить конфиг broadcasting.php
    ---------------------------------
      - Конфиг транслятора хранится в config/broadcasting.php
      - Транслятор в Laravel поддерживает "из коробки" 3 драйвера:

        1) Pusher  | через внешний платный сервис pusher.com
        2) Redis   | через key-value хранилище Redis
        3) Log     | для отладки

      - Мы в этой главе рассматриваем работу через Redis.

    Установить Redis, и зависимость predis
    --------------------------------------
      - Как установить и настроить Redis, читай в другой методичке.
      - К Laravel же нужно ещё подключить зависимость predis.
      - Для этого в composer.json, в require, указать:

          predis/predis ~1.0

      - И после этого выполнить команды:

          composer update
          composer dump-autoload

    Установить nodejs и необходимые модули
    --------------------------------------
      - Как установить и настроить Nodejs, читай в другой методичке. 
      - К нему ещё надо установить 2 модуля:

          socket.io
          ioredis

      - Для этого надо отркрыть окно терминала сервера.
      - И выполнить в нём следующие команды:

          npm install socket.io
          npm install ioredis

    Запустить демон queue:listener в фоновом режиме
    -----------------------------------------------
      - Этот демон описан в главе про очереди задач (см.оглавление).
      - Он необходим при передаче события из Laravel в Redis.
      - Как только событие возбуждено в Laravel, оно попадает в Redis.
      - Всё благодаря этому демону. 
      - Для запуска, надо перейти в корень проекта.
      - И выполнить следующую artisan-команду:

          php artisan queue:listen &

      - Проверить, всё ли работает, можно командой:

          ps aux | grep queue:listen

      - В выводе д.б. строка: php artisan queue:listen

    Подготовить и запустить nodejs-сервер
    -------------------------------------
      
      # Подготовить файл socket.js
        - И положить его в любое удобное место.
        - Это и будет наш nodejs-сервер.

      # Наполнить файл socket.js

        // 1. Подключить модули http и socket.io
          
          var app = require('http').createServer(handler);
          var io = require('socket.io')(app);


        // 2. Подключить модуль ioredis
        // - И создать новое подключение к Redis
          
          var Redis = require('ioredis');
          var redis = new Redis();


        // 3. Слушать HTTP-порт 6001
        // - По нему будут подключаться клиенты
          app.listen(6001, function() {
              console.log('Server is running!');
          });


        // 4. Собственно, код http-сервера nodejs
        // - Он лишь возвращает в ответе код 200 (ОК).
          function handler(req, res) {
              res.writeHead(200);
              res.end('');
          }


        // 5. Назначить функцию-обработчик
        // - Будет срабатывать каждый раз при подключении нового клиента к серверу
        // - А точнее, при создании нового соединения по протоколу websocket.
          io.on('connection', function(socket) {
              //
          });


        // 6. Слушать все каналы Redis'а (паттерн pub/sub)
          redis.psubscribe('*', function(err, count) {
              //
          });


        // 7. Назначить функцию-обработчик
        // - Срабатывает, когда в любой канал Redis'а поступает новое сообщение
          redis.on('pmessage', function(subscribed, channel, message) {
              
            // Распарсить message
            // - message.event  | содержит имя события в Laravel, квалифицированное полным пр.имён
            // - message.data   | содержит данные, которые надо отправить клиентам
              message = JSON.parse(message);
              
            // Отправить всем подписанным на канал клиентам данные
            // - Имя канала: channel + ':' + message.event
              io.emit(channel + ':' + message.event, message.data);
         
          });

      # Запустить сервер socket.js в фоновом режиме
        - Открыть окно терминала.
        - Перейти в нём в каталог с socket.js.
        - Выполнить команду:

            nohup nodejs socket.js > /dev/null 2>&1 &

        - Проверить, что сервер socket.js запущен.
        - Для этого выполнить команду: 

            ps aux | grep node

        - В выводе д.б. строка: nodejs socket.js
        - Если понадобится, можно завершить работу сервера.
        - Для этого в выводе команды выше надо посмотреть его PID.
        - И затем выполнить команду: kill [PID]


  > Использование транслятора

    Определение транслируемого события
    ----------------------------------
      - Транслируемое событие определяется почти также, как обычное.
      - Отличия заключаются в следующем:

        1) Должно реализовывать интерфейс ShouldBroadcast
          - Который находится в 
              Illuminate\Contracts\Broadcasting\ShouldBroadcast

        2) Должно содержать метод broadcastOn()
          - Обычное событие содержит лишь метод __construct()
          - А транслируемое ещё должно содержать broadcastOn()
          - К этому обязывает интерфейс, который реализует класс транс.события.
          - Данный метод возвращает массив строк-каналов.
          - В эти каналы и будет осуществляться трансляция.

        3) Может содержать метод broadcastWith()
          - Что происходит, если этого метода нет?
          - Транслятор передаёт все public-свойства класса-события.
          - А когда этот метод есть?
          - Он должен вернуть массив данных для трансляции.
          - Эти данные и передаются транслятором.

    Как выглядит базовое транслируемое событие
    ------------------------------------------

      <?php namespace App\Events;

      use App\User;
      use App\Events\Event;
      use Illuminate\Queue\SerializesModels;
      use Illuminate\Contracts\Broadcasting\ShouldBroadcast;

      class ServerCreated extends Event implements ShouldBroadcast      // реализует интерфейс ShouldBroadcast
      {
          use SerializesModels;

          public $user;   // это св-во экземпляра события будет передаваться транслятором

          // Создание нового экземпляра события
          public function __construct(User $user)
          {
              $this->user = $user;
          }

          // Массив каналов, куда транслятор должен транслировать
          public function broadcastOn()
          {
              return ['user.'.$this->user->id];
          }
      }

    Какие данные будут транслироваться
    ----------------------------------

      Вариант 1: метод broadcastWith() не определён
      ---------------------------------------------
        - Тогда будут транслироваться все public-свойства экземпляра события.
        - Например, есть у нас 1 public-свойство $user.
        - И оно содержит Eloquent-модель.
        - Тогда эти данные будут сериализованы и переданы:

            {
                "user": {
                    "id": 1,
                    "name": "Jonathan Banks"
                    ...
                }
            }    

      Вариант 2: метод broadcastWith() определён 
      ------------------------------------------
        - Он возвращает массив данных, которые будут транслироваться.
        - Например (в контексте класса-события):

          public function broadcastWith()
          {
              return ['name' => 'Иван', 'age' => 18];
          }        


  > Приём сообщений от транслятора в клиенте (JS)

    Подключить клиентскую библиотеку socket.io
    ------------------------------------------
      - Первым делом, надо подключить сабж.
      - Предположим, что она у вас лежит в 'assets/js/socket.io.js'.
      - Тогда подключается она так:

          <script src="{{ asset('assets/js/socket.io.js') }}"></script>

    Подключиться к серверу nodejs, и слушать нужные каналы
    ------------------------------------------------------
      - Теперь нам надо подключиться к серверу nodejs.
      - К тому самому, который мы написали и запустили ранее.
      - Порт надо использовать тот же, что указан в коде сервера.
      - В нашем случае, это был 6001.
      - Допустим, адрес нашего сервера: http://localhost:6001
      - Итак:

        <script>

          // Подключиться к серверу nodejs (socket.io)
          var socket = io('http://localhost:6001');

          // Слушать канал "channel_1:App\\Events\\MyEventNameHere"
          socket.on("channel_1:App\\Events\\MyEventNameHere", function(message){
               
            // ... этот код сработает при поступлении в канал нового сообщения ...
               
          });

        </script>    


Г19.  CLI Artisan

  --------------------------------------
  Подоглавление:

    # Введение

      - Общая информация об Artisan CLI
      - Как увидеть список команд, и справки по каждой
      - Синтаксис команд

    # Создание кастомных artisan-команд

      - Создать новую artisan-команду с помощью artisan-команды
      - Базовый класс-artisan-команда

      - Настройка аргументов в шаблоне artisan-команды:

        - '[имя] {user}'        | задать аргумент
        - '[имя] {user=foo}'    | задать аргумент с значением по умолчанию
        - '[имя] {--queue}'     | задать аргумент-опцию
        - '[имя] {--queue=}'    | задать аргумент-опцию со значением
        - '[имя] {--queue=foo}' | задать аргумент-опцию со значением по умолчанию
        - '[имя] {user : desc}' | задать описание аргументу / опции

      - Получение значений аргументов artisan-команды в handle():

        - $this->argument()    | извлечь значение аргумента по имени, или массив всех аргументов
        - $this->option()      | аналог argument, но без аргументов возвращает массив всех опций

      - Осуществление запроса информации у пользователя:

        - $this->ask()         | запросить ввод пользователем строки
        - $this->secret()      | запросить ввод пользователем строки в безопасном невидимом режиме
        - $this->confirm()     | спросить, согласен ли (y/n)
        - $this->anticipate()  | дать выбрать из нескольких вариантов + свободный ввод
        - $this->choice()      | дать выбрать строго из нескольких вариантов (без сводобного ввода)
        
      - Вывод информации в окно терминала:

        - $this->info()        | вывести в окно терминала сообщение цвета info
        - $this->comment()     | вывести в окно терминала сообщение цвета comment
        - $this->question()    | вывести в окно терминала сообщение цвета question
        - $this->error()       | вывести в окно терминала сообщение цвета error
        - $this->table()       | вывести в окно терминала таблицу данных
        
      - Прогресс-бар:

        - $this->output->progressStart()   | начать использовать прогресс-бар
        - $this->output->progressAdvance() | прибавить к значению прогресс-бара
        - $this->output->progressFinish()  | завершить использовать прогресс-бар

    # Регистрация кастомных artisan-команд

      - Регистрация в консольном Kernel.php
      - Регистрация в методе register любого сервис-провайдера

    # Запуск команд из кода

      - Artisan::call()     | запуск artisan-команд из кода в realtime
      - Artisan::queue()    | Размещение выполнения artisan-команд из кода в очереди задач

    # Стандартные опции artisan-команд в Laravel 5.1

      -h, --help        | справка по команде, а если её нет - по artisan
      -q, --quiet       | исполнить команду без вывода сообщений в окно терминала
      -V, --version     | вывести версию фреймворка в окно терминала
      -v, -vv, -vvv     | чем больше v, тем больше сведений будет выводиться в окно терминала
      --ansi            | выводить текст в формате ANSI
      --no-ansi         | выводить текст в формате не-ANSI
      -n                | не задавать никаких интерактивных вопросов
      --env             | указать среду, в которой будет выполняться команда

    # Стандартные artisan-команды в Laravel 5.1

      Общие
      -----
        clear-compiled    | удалить файл compiled class
        down              | перевести приложение в режим "тех.обсллуживания"
        up                | вывести приложение из режима "тех.обсллуживания"
        env               | вывести имя текущей среды приложения
        help              | тоже самое, что --help
        list              | вывести на экран список всех доступных опций и команд
        migrate           | запустить миграции базы данных
        optimize          | оптимизировать фрейворк, чтобы улучшить производительность
        serve             | запустить встроенный в Laravel консольный mini-php-сервер
        tinker            | "Поиграться" с приложением в командной строке
        
      app
      ---
        app:name            | Set the application namespace

      auth
      ----
        auth:clear-resets   | Flush expired password reset tokens

      cache
      -----
        cache:clear         | Flush the application cache
        cache:table         | Create a migration for the cache database table

      config
      ------
        config:cache        | Create a cache file for faster configuration loading
        config:clear        | Remove the configuration cache file

      db
      --
        db:seed             |  Seed the database with records

      event
      -----
        event:generate      | Generate the missing events and listeners based on registration

      handler
      -------
        handler:command     | Create a new command handler class
        handler:event       | Create a new event handler class

      key
      ---
        key:generate        | Set the application key

      make
      ----
        make:command        | Create a new command class
        make:console        | Create a new Artisan command
        make:controller     | Create a new resource controller class
        make:event          | Create a new event class
        make:job            | Create a new job class
        make:listener       | Create a new event listener class
        make:middleware     | Create a new middleware class
        make:migration      | Create a new migration file
        make:model          | Create a new Eloquent model class
        make:provider       | Create a new service provider class
        make:request        | Create a new form request class
        make:seeder         | Create a new seeder class        

      migrate
      -------
        migrate:install     | Create the migration repository
        migrate:refresh     | Reset and re-run all migrations
        migrate:reset       | Rollback all database migrations
        migrate:rollback    | Rollback the last database migration
        migrate:status      | Show the status of each migration      

      queue
      -----
        queue:failed        | List all of the failed queue jobs
        queue:failed-table  | Create a migration for the failed queue jobs database table
        queue:flush         | Flush all of the failed queue jobs
        queue:forget        | Delete a failed queue job
        queue:listen        | Listen to a given queue
        queue:restart       | Restart queue worker daemons after their current job
        queue:retry         | Retry a failed queue job
        queue:subscribe     | Subscribe a URL to an Iron.io push queue
        queue:table         | Create a migration for the queue jobs database table
        queue:work          | Process the next job on a queue     

      route
      -----
        route:cache         | Create a route cache file for faster route registration
        route:clear         | Remove the route cache file
        route:list          | List all registered routes      

      schedule
      --------
        schedule:run        | Run the scheduled commands

      session
      -------
        session:table       | Create a migration for the session database table

      vendor
      ------
        vendor:publish      | Publish any publishable assets from vendor packages      

      view
      ----
        view:clear          | Clear all compiled view files


  --------------------------------------

  > Введение
    
    Общая информация об Artisan CLI
    -------------------------------
      - Artisan CLI - интерфейс командной строки для работы с Laravel.
      - Доступен ряд стандартных команд, полезных при разработке приложений.
      - Основан на консольном компоненте из Synfony.
  
    Список команд, и справки по каждой
    ----------------------------------
      - Введя - php artisan list - можно увидеть список всех команд.
      - Введя - php artisan help [имя команды] - можно увидеть справку по команде.

    Синтаксис команд
    ----------------

      command [options] [arguments]

  > Создание кастомных artisan-команд

    Создать новую artisan-команду с помощью artisan-команды
    -------------------------------------------------------
      - Можно создавать свои кастомные artisan-команды.
      - Она представляет из себя отдельный файл с 1 php-классом.
      - Всё это должно быть оформлено в опред.формате (см.ниже).
      - Создать новый класс-artisan-команду можно командой artisan:

          php artisan make:console SomeArtisanCommand

      - Эта команда создаст класс-artisan-команду по адресу:

          app/Console/Commands/SomeArtisanCommand.php

      - При этом, при создании можно использовать опцию --command.
      - И в неё указать имя будущей artisan-команды для вызова в терминале:

          php artisan make:console SomeArtisanCommand --command=call:command          

    Базовый класс-artisan-команда
    -----------------------------

      # Шаблон artisan-команды
        - В св-ве $signature содержится шаблон artisan-команды.
        - Шаблон состоит из ключа, имени, и аргументов.
        - Аргументы будут доступны вот таким образом:

            $this->argument('user')

      # Описание artisan-команды
        - В св-ве $description содержится описание artisan-команды.
        - Оно будет отображаться при вызове списка команд, или справки.

      # Метод handle
        - Содержит логику команды. 
        - Код, который выполнится при вызове команды.

      # Возможности DI
        - Можно передавать в конструктор аргументы-объекты классов.
        - А из конструктора записывать данные в св-ва.
        - А эти св-ва потом использовать в handle.

      # Собственно, сам базовый класс-artisan-команда

        <?php

          namespace App\Console\Commands;

          use App\User;
          use App\DripEmailer;
          use Illuminate\Console\Command;
          use Illuminate\Foundation\Inspiring;

          class Inspire extends Command
          {
              // Шаблон artisan-команды
              protected $signature = 'email:send {user}';

              // Описание artisan-команды
              protected $description = 'Send drip e-mails to a user';

              // Св-ва для принятия значений аргументов из конструктора
              protected $drip;

              public function __construct(DripEmailer $drip)
              {
                  // Вызвать конструктор класса Command
                  parent::__construct();

                  // Записать значение аргумента в св-во $drip
                  $this->drip = $drip;
              }

              // Собственно, сам код artisan-команды
              public function handle()
              {
                  $this->drip->send(User::find($this->argument('user')));
              }
          }

    Настройка аргументов в шаблоне artisan-команды
    ----------------------------------------------

      # Общая информации о настройке аргументов
        - Чаще всего artisan-команды ожидают при вызове аргументы на входе.
        - При определении команды можно легко указать ожидаемые аргументы.
        - Это делается в св-ве $signature в artisan-классе-команде.
        - Она позволяет задать: имя, аргументы и опции artisan-команды.

      # '[имя] {user}'  
      # Задать аргумент

          protected $signature = 'email:send {user}';

      # '[имя] {user=foo}'
      # Задать аргумент с значением по умолчанию

          protected $signature = 'email:send {user=foo}';

      # '[имя] {--queue}'
      # Задать аргумент-опцию
        - Значение аргумента-опции == true, если опция будет применена.
        - Значение аргумента-опции == false, если опция не будет применена.
        - Как задать:

          protected $signature = 'email:send {user} {--queue}';

        - Например: php artisan email:send 1 --queue
        - Опция применена, значет значение queue будет true.

      # '[имя] {--queue=}'
      # Задать аргумент-опцию со значением
        - Иногда нужно, чтобы у аргумента-опции было значение.
        - Сделать это можно так:

          protected $signature = 'email:send {user} {--queue=}';

        - Теперь пользователь может передать через queue значение.

      # '[имя] {--queue=foo}'
      # Задать аргумент-опцию со значением по умолчанию

          email:send {user} {--queue=default}

      # '[имя] {user : desc}'
      # Задать описание аргументу / опции
        - Описание можно задавать через двоеточие.
        - Вот так:

          protected $signature = 'email:send
                                  {user : The ID of the user}
                                  {--queue= : Whether the job should be queued}';        


    Получение значений аргументов artisan-команды в handle()
    --------------------------------------------------------

      # $this->argument()
      # Извлечь значение аргумента по имени, или массив всех аргументов
        - Допустим, есть у нас аргумент {user} в шаблоне.
        - Извлечь его значение в коде можно так:

            $userId = $this->argument('user');

        - А извлечь массив всех аргументов:

            $arguments = $this->argument();

      # $this->option()
      # Извлечь значение опции по имени, или массив всех опций
        - Допустим, есть у нас опция {--queue} в шаблоне.
        - Извлечь её значение в коде можно так:

            $queueName  = $this->option('queue');

        - А извлечь массив всех аргументов:

            $options  = $this->option();

    Осуществление запроса информации у пользователя
    -----------------------------------------------

      # $this->ask()
      # Запросить ввод пользователем строки

        $name = $this->ask('What is your name?');

      # $this->ask()
      # Запросить ввод пользователем строки в безопасном невидимом режиме

        $this->secret('What is the password?');

      # $this->confirm()
      # Спросить, согласен ли (y/n)

        if ($this->confirm('Do you wish to continue? [y|N]')) {
            //
        }

      # $this->anticipate()
      # Дать выбрать из нескольких вариантов + свободный ввод

        $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);

      # $this->choice()
      # Дать выбрать строго из нескольких вариантов (без сводобного ввода)
        - Последним аргументом идёт значение, которое будет возвращено, если ни 1 вариант не выбран.
        - Код:

        $name = $this->choice('What is your name?', ['Taylor', 'Dayle'], false);


    Вывод информации в окно терминала
    ---------------------------------

      # $this->info() 
      # вывести в окно терминала сообщение цвета info

        $this->info('Display this on the screen');

      # $this->comment() 
      # вывести в окно терминала сообщение цвета comment

        $this->comment('Display this on the screen');

      # $this->question() 
      # вывести в окно терминала сообщение цвета question 

        $this->question('Display this on the screen');

      # $this->error()
      # вывести в окно терминала сообщение цвета error 

        $this->error('Display this on the screen');

      # $this->table()
      # вывести в окно терминала таблицу данных
        - Можно вывести инфу в виде удобной таблицы.
        - Вот, как это делается (на примере):

          $headers = ['Name', 'Email'];
          $users = App\User::all(['name', 'email'])->toArray();
          $this->table($headers, $users);        

        - В table первым аргументом передаётся массив с заголовками.
        - А авторым аргументом массив с данными.


    Прогресс-бар
    ------------

      # $this->output->progressStart() 
      # - начать использовать прогресс-бар    
        # $this->output->progressAdvance()
        # - прибавить к значению прогресс-бара
          # $this->output->progressFinish() 
          # - завершить использовать прогресс-бар

      - Проще всего показать работу прогресс-бара на примере.
      - Вот пример:

          $users = App\User::all();

          $this->output->progressStart(count($users));

          foreach ($users as $user) {
              $this->performTask($user);

              $this->output->progressAdvance();
          }

          $this->output->progressFinish();

  > Регистрация кастомных artisan-команд
    
    Регистрация в консольном Kernel.php
    -----------------------------------
      - Сделать это можно в консольном Kernel.php.
      - По умолчанию, он находится в: app/Console/Kernel.php.
      - В моём модульном приложении в: app/ConsoleKernel.php.
      - В общем, в Kernel.php есть свойство $commands.
      - Это свойствосодержит массив.
      - Вот в него и надо добавить регистрируемую команду.
      - Например:

          protected $commands = [
              'App\Console\Commands\SendEmails'
          ];

    Регистрация в методе register любого сервис-провайдера
    ------------------------------------------------------
      - Делается это следующим образом.
      - В св-ве $commands размещается массив со списком 
        artisan-команд для регистрации:

          $commands = [
              //'Vendor\Package\Commands\MyCommand',
          ];

      - Далее, с помощью метода commands, производится регистрация:

          $this->commands($commands);        

  > Запуск команд из кода

    # Artisan::call()
    # Запуск artisan-команд из кода в realtime

      $exitCode = Artisan::call('email:send', [
          'user' => 1, '--queue' => 'default'
      ]);    

    # Artisan::queue()
    # Размещение выполнения artisan-команд из кода в очереди задач

      Artisan::queue('email:send', [
          'user' => 1, '--queue' => 'default'
      ]);   




