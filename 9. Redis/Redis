=============================================================
Redis
Key-value хранилище информации


----------------------------------
Оглавление

  - Ссылки
  - Быстрый туториал
  - Установка и настройка
  - Использование в PHP с клиентом phpredis
  - Как сделать бэкап, и восстановиться из бэкапа

----------------------------------

> Ссылки

    - Официальный сайт Redis:
        http://redis.io

    - Официальная документация Redis:
        http://redis.io/documentation

    - Официальный, полный справочник команд Redis:
        http://redis.io/commands

    - Официальный интерактивный туториал по Redis:
        http://try.redis.io/


> Быстрый туториал
  - Эта глава создана, как конспект инерактивного туториала http://try.redis.io/
  - Redis, это key-value хранилище информации.
  - То, что часто называют NoSQL базами данных.
  - Он может хранить values (данные), доступ к которым есть по keys (ключам).
  - Записать значение "fido" с ключём "server:name" в Redis:

      SET server:name "fido"

  - Redis хранит записанные в него данные на постоянной основе.
  - Так что позже можно спокойно извлечь из него записанное значение:

      GET server:name     // "fido"

  - Другие общие операции, обеспечиваемые key-value хранилищами:

      # DEL     | удалить из хранилища пару key-value по указанному key
      # SETNX   | записать в хранилище пару key-value, если такого key ещё нет
      # INCR    | инкремент value в указанном key

  - Например:

      SET connections 10        // записали значение 10 с ключём connections
      INCR connections          // 11
      INCR connections          // 12
      DEL connections           // Удалили значение с ключём connections
      INCR connections          // 1 (значение с ключём создалось и стало 1)

  - Команда INCR позволяет предотвратить ошибки следующего рода.
  - Представим, что вместо INCR мы выполняем инкремент вручную:

      x = GET count
      x = x + 1
      SET count x

  - Представим, что x=10, и 2 клиента одновременно выполняют эту операцию.
  - Мы ожидаем, что на выходе x будет равен 12? А на самом деле, 11!
  - Это потому, что инкрементация таким способом - это не атомарная операция.
  - А вот INCR - атомарная, и предотвращает такие коллизии.
  - Redis обеспечивает много подобных атомарных операций (как INCR) для многих типов данных.

  - Redis'у можно сказать, чтобы key существовал только в течение времени t.
  - Например:

      SET someKey "someValue"   // создадим пару ключ-значение
      EXPIRE someKey 120        // скажем, чтобы через 120 секунд она была удалена

  - Проверить, сколько секунд ещё осталось жить паре можно командой TTL:

      TTL someKey   // (допустим, прошло 7 секунд): 113
      TTL someKey   // (допустим, прошло 130 секунд): -2
      TTL sfgihsd   // -1 (такой ключ никогда не существовал)

  - TTL возвращает -2, если такой ключ больше не существует (истёк из-за EXPIRE)
  - TTL возвращает -1, если к такому ключу не применялась команда EXPIRE.
  - Внимание! Если после EXPIRE назначить ключё значение, его TTL сбросится в -1:

      SET someKey "someValue1"
      EXPIRE someKey 120
      TTL someKey               // 119 (прошла 1 секунда)
      SET someKey "someValue2"  // Назначаем этому ключу новое значение
      TTL someKey               // TTL сбросился в -1

  - Redis работает также с более сложными значениями, чем простые строки.
  - Например, рассмотрим работу в Redis со списками (list). По сути это массивы.
  - Вот основные команды:

      # RPUSH   | вставить значение в конец массива
      # LPUSH   | вставить значение в начало массива
      # RPOP    | удалить последний элемент массива
      # LPOP    | удалить первый элемент массива
      # LLEN    | длина массива
      # LRANGE  | взять подмассив массива

  - Например:

    - Создадим массив friends: 0=>'Маша', 1=>'Иван', 2=>'Пётр'

        RPUSH friends 'Иван'    // в конец
        RPUSH friends 'Петр'    // в конец
        LPUSH friends 'Маша'    // в начало

    - Узнаем длину массива:
        LLEN friends            // 3

    - Извлечём 0-й элемент массива:
        LRANGE friends 0 0      // 'Маша'

    - Извлечём 1-й элемент массива:
        LRANGE friends 1 1      // 'Иван'

    - Извлечём элементы массива с 1-г по 2-й:
        LRANGE friends 1 2      // 'Иван', 'Пётр'

    - Удалим последний элемент массива:
        RPOP friends            // 'Пётр'
        LLEN friends            // 2 (уже 2, а не 3)


  - Рассмотрим ещё одну структуру данных, с которыми работает Redis - наборы (sets).
  - В наборах элементы не имеют определённого порядка, и могут появляться лишь 1 раз.
  - Вот несколько основных команд для работы с наборами:

      # SADD        | добавить указанное значение в набор
      # SREM        | удалить указанное значение из набора
      # SISMEMBER   | проверяет, есть или в наборе указанное значение (1/0)
      # SMEMBERS    | возвращает массив (list) значение указанного набора
      # SUNION      | для >= 2 наборов возвращает массив их объединённых значений

  - Например:

    - Создадим набор status из 4-х значений: "on", "off", "archive", "slon":

        SADD status "on"
        SADD status "off"
        SADD status "archive"
        SADD status "slon"

    - Удалим из набора значение "slon":

        SREM status "slon"

    - Проверим, есть ли в наборе указанные значения:

        SISMEMBER status "slon"     // 0
        SISMEMBER status "on"       // 1
        SISMEMBER status "off"      // 1
        SISMEMBER status "archive"  // 1

    - Получим массив (list) значений указанного набора:

        SMEMBERS status   // 1) "on", 2) "off", 3) "archive"

    - Протестируем команду SUNION.
    - Создадим ещё один набор:

        SADD colors "black"
        SADD colors "white"

    - Получим массив объединённых результатов наборов status и colors:

        // 1) "on", 2) "off", 3) "archive", 4) "black", 5) "white"
        SUNION status colors


  - Наборы обладают недостатком, в них нет порядка, и их нельзя сортировать.
  - Поэтому в Redis 1.2 был представлен тип "сорируемые наборы". Рассмотрим его:
  - Каждое значение в сортируемом наборе ассоциировано с назначенным числом.
  - Эти числа и используются для сортировки значений в сортируемом наборе.
  - Например:

    - Создадим сортируемый набор из фамилии-имени хакеров.
    - Каждому значению поставим в соответствие год рождения:

        ZADD hackers 1940 "Alan Kay"
        ZADD hackers 1906 "Grace Hopper"
        ZADD hackers 1953 "Richard Stallman"
        ZADD hackers 1965 "Yukihiro Matsumoto"
        ZADD hackers 1916 "Claude Shannon"
        ZADD hackers 1969 "Linus Torvalds"
        ZADD hackers 1957 "Sophie Wilson"
        ZADD hackers 1912 "Alan Turing"

    - Получим самого старшего хакера:

        ZRANGE hackers 0 0      // "Grace Hopper"

    - Получим хакеров с 2 по 4 (2,3,4) по старшенству:

        ZRANGE hackres 2 4      // 1) "Claude Shannon", 2) "Alan Kay", 3) "Richard Stallman"


  - Redis также умеет хранить объекты, которые здесь называются Хэшами (Hashes).
  - Например:

    - Создадим объект user:1000 с 3-мя полями

        HSET user:1000 name "Иван Петров"
        HSET user:1000 email "ivan@example.com"
        HSET user:1000 password "s3cret"

    - Или же можно назначить сразу 3 поля в одной команде:

        HMSET user:1001 name "Иван Петров" password "s3cret" email "ivan@example.com"

    - Получить все данные из объекта можно так:

        // 1) "name", 2) "Иван Петров", 3) "email", 4) "ivan@example.com", 5) "password", 6) "s3cret"
        HGETALL user:1000

    - Получить значение из конкретного поля можно так:

        HGET user:1001 name       // "Иван Петров"

  - Числовые значения поддерживаются таким же образом, как и строки.
  - Для них также есть команды для атомарного инкрементирования.
  - Рассмотрим пример:

    - Создадим объект user:1000 с 1 числовым полем

        HSET user:1000 visits 10

    - Инкрементируем это значение числом 1:

        HINCRBY user:1000 visits 1    // 11

    - Инкрементируем это значение числом 10

        HINCRBY user:1000 visits 10   // 21

    - Удалим visits:

        HDEL user:1000 visits

    - Инкрементируем visits числом 1 (значение будет создано и назначено):

        HINCBY user:1000 visits 1     // 1


> Установка и настройка

  ----------------------------------
  Оглавление

    - Введение
    - Установка на Windows
    - Установка на Linux/Ubuntu
    - Конфиг Redis
    - Примечание по поводу пароля Redis
    - Настройка "постоянства" хранения информации в Redis

  ----------------------------------

  > Введение
    - В этой главе будет описана установка и настройка Redis.
    - Причем для Windows отдельно, а для Linux/Ubuntu отдельно.

  > Установка на Windows
    - Установка Redis на Windows (64 бит) описана здесь:
        https://github.com/MSOpenTech/redis
        http://webdraft.org/article/set-up-redis-on-windows-7
    - Установка по шагам:

        1) Скачать последнюю версию Redis для Windows отсюда:
            https://github.com/MSOpenTech/redis

        2) В архиве, в папке /bin/release найти архив с билдом Redis.
          - Распаковать содержимое этого архива с билдом куда-нибудь.
          - Архив содержит такие файлы, как: redis-server.exe и т.д.

        3) Запустить сервер Redis:

          1 вариант:
            - Просто кликнуть по redis-server.exe, выполнив его.
            - Сервер Redis тогда запустится с default-конфигом.

          2 вариант:
            - Запустить сервер Redis из консоли, указав свой конфиг.
            - Это делается так ([..путь..] заменить на настоящий путь):

                c:\[..путь..]\redis-server.exe c:\[..путь..]\redis.conf

        4) Для работы с Redis потребуется phpredis - PHP extension for Redis.
            - Надо в конфиге php проверить, есть ли extension php_redis.dll.
            - Если нет, то надо установить: https://github.com/nicolasff/phpredis
            - В OpenServer php_redis.dll изначально есть.
            - P.S. вообще есть и много других клиентов, и не только для PHP:
                http://redis.io/clients

        5) Установить phpRedisAdmin:
          - Все инструкции на официальном репозитории программы:
              https://github.com/ErikDubbelboer/phpRedisAdmin
          - Это типа phpMyAdmin, только для Redis.
          - Т.Е. это web-приложения для работы с Redis.
          - Установка:

            - Перейти в папку с редисом:
                cd "C:\WebDev\0. Projects\grumart.ru\Redis"

            - Установить в неё композер:
                php -r "eval('?>'.file_get_contents('https://getcomposer.org/installer'));"

            - Установить phpRedisAdmin из композера:
                php composer.phar create-project -s dev erik-dubbelboer/php-redis-admin phpRedisAdmin

          - Запустить phpRedisAdmin (при запущенном сервере Redis) можно так.
          - Запустить на сервере с PHP файл index.php в папке phpRedisAdmin.
          - phpRedisAdmin позволяет добавлять/удалять/редактировать значения в Redis.

  > Установка на Linux/Ubuntu
    - Установка на Ubuntu описана здесь:
        https://www.linode.com/docs/databases/redis/redis-on-ubuntu-12-04-precise-pangolin
    - Первым делом надо подготовить систему к Redis, обновив её:

        sudo apt-get update
        sudo apt-get upgrade

    - Затем скачать и установить Redis

        sudo apt-get install redis-server

    - Настроить redis можно через конфиг /etc/redis/redis.conf
    - Перед внесением в него изменений рекомендуется создать резервную копию:

        cp /etc/redis/redis.conf /etc/redis/redis.conf.default

    - По умолчанию Redis запускается через ком.строку в интерактивном режиме.
    - Запустим сервер Redis с конфигом /etc/redis/redis.conf :

        redis-server /etc/redis/redis.conf

    - Сервер запущен, теперь можно с ним взаимодействовать в ком.строке.
    - Надо просто перед любой Redis-командой ставить префикс redis-cli.
    - Запуск Redis с такам конфигом полезен для тестирования и разработки.
    - На "боевых" системах Redis лучше запускать специальным 'init'-скриптом,
      на отдельном не привилегированном системном пользователе.

  > Конфиг Redis
    - При запуске Redis можно не указывать конфигурационный файл.
    - В этом случае будет использована вшитая defalut-конфигурация.

        # Запуск без указания конфига в Linux

            redis-server

        # Запуск без указания конфига в Windows

            redis-server.exe

    - А можно указать путь к конфигу.
    - В этом случае будет использована указанная конфигуация.

        # Запуск без указания конфига в Linux

            redis-server /etc/redis/redis.conf

        # Запуск без указания конфига в Windows

            redis-server.exe redis.conf

    - Все конфигурационные директивы Redis описаны здесь:
        https://raw.githubusercontent.com/antirez/redis/2.6/redis.conf

  > Примечание по поводу пароля Redis
    - Redis очень быстр.
    - Злоумышленник может перебирать по 150k паролей в секунду.
    - Поэтому пароль должен быть не менее 30 символов разл.регистра.
    - Лучше использовать не только цифры и буквы, но и всякие спец.символы.

  > Настройка "постоянства" хранения информации в Redis

    ----------------------------------
    Оглавление

      - Введение
      - Плюсы и минусы RDB
      - Плюсы и минусы AOF
      - RDB или AOF?
      - Настройка RDB в redis.conf
      - Настройка AOF в redis.conf

    ----------------------------------

    > Введение
      - Redis может хранить данные только в памяти, а может и на диске.
      - У него есть несколько разных режимов работе в этом плане:

        # Отключено
          - Можно вообще отключить "постоянство" хранения данных.
          - Тогда данные будут храниться только в оперативной памяти.
          - И только до тех пор, пока сервер Redis работает.

        # RDB
          - Раз в N минут все данные сохраняются на диск.
          - Если вдруг вырубится электричество, то последние данные будут потеряны.

        # AOF
          - Ведётся лог всех изменяющих данные операций на сервере.
          - При следующем запуске сервера все они будут выполнены.
          - В результате реконструируется состояние данных на сервере.
          - Со временем этот лог будет становиться гигантским.
          - А время запуска сервера Redis тоже будет становиться гигантским.

        # RDB + AOF
          - Их можно использовать вместе одновременно.
          - При запуске сервера данные восстанавливаются из AOF.
          - Т.К. точность восстановления в AOF заведомо выше.
          - Ведь в RDB часть данных могла быть утеряна в случае аварийной остановки сервера.


    > Плюсы и минусы RDB

     # Плюсы

      + Все данные с Redis сохраняются в 1 компаткный файл. Идеально для бэкапов.

      + Если надо восстановиться из бэкапа, то из файла это очень удобно делать.

      + RDB обладает MAX производительностью среди всех режимов.

      + С RDB сервер будет запускаться быстрее, чем с AOF.

     # Минусы

      - В случае аварийного завершения работы последние данные будут утеряны.
        Например, делаем мы бэкапы каждый час: в 13:00, 14:00 ... . И вдруг
        в 14:30 отключили электричество, и сервер вырубился. Данные за последние
        30 минут будут утеряны.

      - Во время бэкапа, если данных много, сервер может отказать обслуживать
        клиентов на те милисикунды, пока делается бэкап.


    > Плюсы и минусы AOF

     # Плюсы

      + Гибко настраиваемая политика обновления лога, позволяющая найти
        устраивающий баланс между производительностью и рисками потери данных.
        Можно синхронизироваться:
        1) Каждую секунду (по умолчанию)
          - Высокая производительность.
          - Риск потерять данные лишь за последнюю секунду.
        2) Каждую операцию
          - Производительность пониже.
          - Нет риска потерять никакие данные.

      + Отсутствуют проблемы с повреждением данных в случае аварийного
        завершения. Даже если последняя команда запишется в лог лишь на половину,
        инструмент redis-check-aof легко это исправит.

      + Когда AOF становится слишком большим, Redis автоматом его оптимизирует.
        Это абсолютно безопасно. Как это происходит:
        1) Redis продолжает вести лог в старом файле.
        2) И в это время создаёт новый файл.
          - Такой, чтобы MIN кол-вом команд создать текущие данные.
        3) Как только новый файл готов, Redis начинает вести лог в нём.

      + Лог в AOF ведётся в человеко-понятном формате. По сути это просто
        последовательный список Redis-команд. Представим, что мы случайно
        ввели команду FLUSHALL, и удалили все данные. Чтобы их восстановить,
        достаточно выключить сервер, удалить из AOF последнюю команду (FLUSHALL),
        и запустить сервер. Вся информация будет восстановлена.

     # Минусы

      - Обычно файл AOF больше, чем файл RDB, для одного и того же набора данных.

      - Медленнее, чем RDB. Но если установить обновление лога AOF каждую
        секунду, то производительность всё ещё остаётся на высоте.

    > RDB или AOF?

      > Предисловие
        - Проведём оценку разных вариантов.
        - Оценивать будем по 2-м параметрам: скорость и безопасность.
        - Мерилом будут баллы, от 1 до 5. Чем выше, тем лучше.

      > Оценка разных вариантов

        1 Скорость 5, безопасность 1
          - Отключить RDB и AOF.
          - Скорость будет MAX возможная.
          - Данные никак не защищены, и хранятся только в оперативке.
          - После выключения сервера Redis данные будут потеряны навсегда.

        2 Скорость 4, безопасность 2
          - RDB.
          - Возможные подтормаживания сервера Redis во время бэкапов.
          - В случае аварии утеря данных между текущим моментом и посл. бэкапом.

        3 Скорость 3, безопасность 3
          - AOF с обновлением лога 1 раз в секунду.
          - В случае аварии потеря данных за последнюю секунду работы.

        4 Скорость 2, безопаснть 4
          - AOF с обновлением лога при вводе каждой измен.данные команде.
          - Потеря данных практически исключается.

        5 Скорость 1, безопасность 5
          - AOF (кажд.измен.) + RDB (с периодом в N минут)
          - Потеря данных исключена.

      > Что соверуют разработчики Redis
        - Они говорят, что выбор надо делать в завис. от ситуации.
        - Но говорят, что им ближе RDB + AOF.
        - Говорят, что в будущем хотят даже объединить их в единую систему:

            RDB + AOF = [? некая единая система ?].


    > Настройка RDB в redis.conf

      > Предисловие
        - Чтобы настройки сработали, сервер Redis надо запускать, указав конфиг.
        - Настройки RDB в redis.conf находятся в секции "## SNAPSHOTTING  ##"

      > Параметры (самые важные)

        # save
          - Формат: save <seconds> <changes>
          - Делать бэкап раз в <seconds>, если произошло <changes> изменений.
          - Может появляться несколько раз.
          - По умолчанию стоят следующие значения:

              save 900 1      | сохранять раз в 900 секунд, если было хоть 1 изменение
              save 300 10     | сохранять раз в 300 секунд, если было хоть 10 изменений
              save 60 10000   | сохранять раз в 60 секунд, если было хоть 10000 изменений

        # stop-writes-on-bgsave-error
          - Принимает значения: [yes | no]. По умолчанию - yes.
          - На время бэкапа сервер блокирует операции изменения данных.

        # dbfilename
          - Тут указано, в какой файл сохранять данные.
          - По умолчанию стоит:

              dbfilename dump.rdb

        # dir
          - Папка, в которую будут помещаться RDB-файл и AOF-файл.
          - По умолчанию стоит:

              dir ./


    > Настройка AOF в redis.conf

      > Предисловие
        - Чтобы настройки сработали, сервер Redis надо запускать, указав конфиг.
        - Настройки RDB в redis.conf находятся в секции "## APPEND ONLY MODE  ##"

      > Параметры (самые важные)

        # appendonly
          - Вкл / Выкл AOF. Принимает значения [yes | no]
          - По умолчанию стоит:

              appendonly no

        # appendfilename
          - Файл, в котором будет вестись AOF-лог.
          - Он будет храниться в папке, указанной в параметре dir.
          - По умолчанию стоит:

              appendfilename appendonly.aof

        # appendfsync
          - Как часто будет обновляться лог AOF.
          - Доступны 3 варианта:

            1) always     | после каждой изменяющей данные операции
            2) everysec   | каждую секунду
            3) no         | никогда (?не понятно, зачем этот режим?)

          - По умолчанию стоит:

              appendfsync everysec

        # no-appendfsync-on-rewrite
          - Если одновременно происходят несколько операций (так сложилось):

            1) RDB создаёт бэкап.
            2) AOF оптимизирует лог.
            3) AOF обновляет лог.

          - То Redis может быть слишком долго заблокирован.
          - Если передать это опции значение yes, то в случае наличия
            не законченных операций 1 и 2, операция 3 будет отложена на
            30 секунд.
          - Есть риск потерять MAX последние 30 секунд лога в случае аварии.
          - По умолчанию выбран более безопасный вариант:

              no-appendfsync-on-rewrite no

        # auto-aof-rewrite-percentage
        # auto-aof-rewrite-min-size
          - Настройка авто-оптимизации лога AOF.
          - По умолчанию стоят такие настройки:

              auto-aof-rewrite-percentage 100
              auto-aof-rewrite-min-size 64mb

          - Если размер лога превысит 64mb, то он будет оптимизирован.


> Использование в PHP с клиентом phpredis

  ----------------------------------
  Оглавление

    - Введение
    - Класс RedisException
    - Предопределённые константы класса Redis
    - Класс Redis

    -- Удобный справочник по всем командам --
    |                                       |
    |       http://redis.io/commands#       |
    |                                       |
    -----------------------------------------

    -- Создание экземпляра --
      > new Redis()         | создать новый Redis-клиент

    --------------------------
    | Работа с соединением
    --------------------------
    | https://github.com/nicolasff/phpredis#connection

      > connect, open       | установить соединение с сервером Redis
      > pconnect, popen     | установить постоянное соединение с сервером Redis
      > auth                | пройти аутентификацию на сервере
      > select              | изменить выбранную базу данных для текущего соединения
      > close               | закрыть соединение с сервером Redis

      > ping                | пинговать сервер
      > setOption           | установить клиентскую опцию
      > getOption           | получить указанную клиентскую опцию
      > echo                | послать Redis'у строку, чтобы он ответил той же строкой

    --------------------------
    | Работа с сервером
    --------------------------
    | https://github.com/nicolasff/phpredis#server

      > config              | Получить или изменить значения параметров конфига Redis
      > flushAll            | Удалить все ключи из всех баз данных
      > flushDB             | Удалить все ключи из текущей выбранной БД

      > bgsave              | Асинхронно сохранить данные на диск
      > save                | Синхронно сохранить данные да ниск
      > lastSave            | Получить timestamp последнего сохранения на диск

      > info                | Получить информацию и статистику по серверу Redis
      > resetStat           | Сбросить статистику (которую можно получить методом info)
      > dbSize              | Кол-во ключей в выбранной базе данных
      > time                | Текущее серверное время

      > bgrewriteaof        | Асинхронно перезаписать AOF (Append-Only file)
      > slaveof             | Изменить slave status
      > slowlog             | Доступ к slowlog Redis'a

    --------------------------
    | Работа с ключами
    --------------------------
    | https://github.com/nicolasff/phpredis#keys-and-strings

      > del, delete   | удалить указанный ключ
      > dump          | поместить указ.ключ в корзину (restore - восстановить)
      > restore       | восстановить ключ из корзины (положенный туда командой dump)

      > expire, setTimeout, pexpire | установить время жизни ключа в секундах
      > expireAt, pexpireAt | указать timestamp, когда ключ истечёт
      > persist       | убрать все ограничения на время жизни ключа
      > ttl, pttl     | получить оставшееся время жизни ключа

      > rename, renameKey | переименовать ключ
      > renameNx      | переименовать ключ, но только если новый не существует

      > exists        | проверить, существует ли указанный ключ
      > type          | определить тип ключа (см. предопределённые константы Redis)
      > move          | переместить ключ в другую базу данных
      > sort          | сортировать эл-ты в массиве или сортируемом списке
      > migrate       | атомарная миграция ключа из 1 экземпляра Redis в другой
      > randomKey     | возвращает случайный ключ
      > object        | ?

      > keys, getKeys | найти ключи, удовлетворяющие указанному шаблону
      > scan          | сканировать на наличие ключей

    --------------------------
    | Работа со строками
    --------------------------
    | https://github.com/nicolasff/phpredis#keys-and-strings

      > get               | получить значение указанного ключа
      > mGet, getMultiply | массово извлечь из ключей значения
      > getRange          | получить подстроку строки в указанном ключе
      > getBit            | получить 1 указанный бит из значения указанного ключа

      > set               | назначить строковое значение ключу
      > getSet            | назначить значение указанному ключу, и вернуть прежнее
      > setex, psetex     | назначить ключу значение, одновременно установить время жизни
      > setnx             | назначить значение ключа, только если такой ключ не сущестует
      > append            | добавить подстроку в конец строки ключа
      > mSet, mSetNX      | массово назначить ключам значения
      > setRange          | перезаписать часть строки в ключе, начинающуюся с указанной позиции
      > setBit            | изменить 1 указанный бит значения указанного ключа

      > decr, decrBy      | декрементировать значение указанного ключа на указаную величину
      > incr, incrBy      | инкрементировать значение указанного ключа на указаную величину
      > incrByFloat       | декрементировать float-value указанного ключа на указанную величину

      > strlen            | получить длину строки в указанном ключе
      > bitcount          | подсчитать кол-во бит в значении указанного ключа
      > bitop             | осуществить побитовые операции между строками

    --------------------------
    | Работа с хэшами (объектами)
    --------------------------
    | https://github.com/nicolasff/phpredis#hashes

      > hGet          | получить значение поля хэша
      > hGetAll       | получить все поля и значения хэша
      > hVals         | получить все значения в хэше
      > hKeys         | получить все поля хэша
      > hMGet         | получить значения всех указанных полей хэша

      > hSet          | установить строковое значение указанному полю хэша
      > hSetNx        | тоже, что hSet, но только если это поле не существует
      > hMSet         | назначить указанные значения указанным полям хэша

      > hDel          | удалить 1 или более полей хэша
      > hExists       | определить, существует ли указанное поле хэша
      > hLen          | количество полей в хэше
      > gIncrBy       | инкрементировать int-значение поля хэша указанным числом
      > hIncrByFloat  | инкрементировать float-значение поля хэша указанным числом
      > hScan         | сканировать хэш

    --------------------------
    | Работа с массивами (lists)
    --------------------------
    | https://github.com/nicolasff/phpredis#lists

      > lPush             | вставляет >= 1 элементов в начало массива
      > lPushx            | вставляет >= 1 элементов в начало массива, если он существует
      > rPush             | вставляет >= 1 элементов в конец массива
      > rPushx            | вставляет >= 1 элементов в конец массива, если он существует

      > lPop              | удаляет и возвращает первый элемент массива
      > rPop              | удаляет и возвращает последний массива
      > blPop, brPop      | удалить и получить первый/последний элемент
      > brpoplpush        | удалить 1-й эл-т из массива, добавить в другой, и вернуть
      > rpoplpush         | удал.посл.эл-т из массива, добавить его в другой массив, и вернуть

      > lInsert           | вставить элемент перед/после указанного элемента
      > lSet              | установить значение эл-ту массива по его индексу
      > lIndex, lGet      | получить значение из массива по индексу


      > lRange, lGetRange | извлечь подмассив элементов
      > lRem, lRemove     | удалить элементы из массива
      > lTrim, listTrim   | обрезать массив

      > lLen, lSize       | получить длину/размер массива

    --------------------------
    | Работа с наборами (sets)
    --------------------------
    | https://github.com/nicolasff/phpredis#sets

      > sAdd                  | добавить >=1 значения в набор
      > sPop                  | удалить и вернуть последнее значение в наборе
      > sRem, sRemove         | удалить >= 1 значений из набора
      > sMove                 | переместить значение из одного набора в другой

      > sCard, sSize          | получить кол-во значений в наборе
      > sMembers, sGetMembers | получить все значения набора
      > sIsMember, sContains  | определить, есть ли указанное значение в наборе

      > sDiff                 | для >1 наборов получить набор уникальных значений
      > sDiffStore            | тоже, что sDiff, результат сохраняется в указанный ключ
      > sInter                | для >1 наборов получить набор НЕ уникальных значений
      > sInterStore           | тоже, что sInter, результат сохраняется в указанный ключ

      > sUnion                | сложить > 1 набора
      > sUnionStore           | сложить > 1 набора, и сохранить в указаный ключ

      > sRandMember           | получить >= 1 случайных значений из набора
      > sScan                 | сканировать набор

    --------------------------
    | Работа с сортируемыми наборами (sorted sets)
    --------------------------
    | https://github.com/nicolasff/phpredis#sorted-sets

      > zAdd          | добавить >= 1 эл-та в сорт.набор, или обновить их числа, если они уже существуют
      > zRem, zDelete | удалить >= 1 эл-т из сортируемого списка
      > zRemRangeByRank, zDeleteRangeByRank | удалить все эл-ты из указанного диапазона индексов
      > zRemRangeByScore, zDeleteRangeByScore | удалить все эл-ты из указанного диапазона чисел

      > zCard, zSize  | получить кол-во значений в сортируемом наборе
      > zCount        | кол-во эл-тов с числами в указанном диапазоне

      > zRank, zRevRank | получить индекс элемента в сортируемом списке
      > zScore        | получить число данного эл-та сортуруемого списка

      > zInter        | для >1 наборов получить набор НЕ уникальных значений, и сохранить в ключ

      > zRange        | вернуть подмассив эл-в набора из указанного диапазона индексов, отсортированный по числам по возрастанию
      > zRevRange     | тоже, что zRange, только сортировка по убыванию
      > zRangeByScore, zRevRangeByScore | вернуть подмассив эл-в набора из указанного диапазона чисел

      > zincrBy       | инкрементировать число эл-та указанным числом
      > zUnion        | сложить > 1 набора, и сохранить в указаный ключ
      > zScan         | сканировать набор

    --------------------------
    | PubSub
    --------------------------
    | https://github.com/nicolasff/phpredis#pubsub

      > subscribe   | подписаться на канал
      > psubscribe  | подписаться на канал, используя шаблон

      > publish     | отправить сообщение в канал

      > pubsub      | получить информацию о pub/sub системе Redis'а

    --------------------------
    | Транзакции
    --------------------------
    | https://github.com/nicolasff/phpredis#transactions

      > multi, exec, discard    | вход/выход из режима транзакций
      > watch, unwatch          | следит, не модифицирован ли ключ другой транзакцией


  ----------------------------------

  > Введение
    - Существует много клиентов для Redis, для разных языков программирования.
    - Только для PHP на 08.09.2014 существует 7 клиентов.
    - Обзор и ссылки на все доступные клиенты есть на оф.сайте Redis:

        http://redis.io/clients

    - В этой главе мы рассмотрим работу с Redis в PHP через клиент phpredis.
    - Вот ссылка на этот клиент:

        https://github.com/nicolasff/phpredis

    - Подразумевается, что сервер Redis запущен, а phpredis установлен.
    - Оф. справочник клиента по работе с классами Redis и RedisException здесь:

        https://github.com/nicolasff/phpredis#classes-and-methods

  > Класс RedisException
    - phpredis возбуждает RedisException, если не может соединиться с сервером Redis.
    - Это может произойти по следующим причинам:

      - Проблемы с интернетом.
      - Сервер Redis не запущен.
      - Сервер Redis перегружен.

    - Т.Е. это исключение возбуждается, только если сервер не доступен.
    - Во всех же остальных случаях, таких как:

      - Ключ не существует.
      - Неправильная команда
      - И т.д.

    - phpredis просто возвращает false.

  > Предопределённые константы класса Redis
    - Содержат те самые значения, которые возвращает метод type.

        # Redis::REDIS_STRING     // "String"
        # Redis::REDIS_SET        // "Set"
        # Redis::REDIS_LIST       // "List"
        # Redis::REDIS_ZSET       // "Sorted set"
        # Redis::REDIS_HASH       // "Hash"
        # Redis::REDIS_NOT_FOUND  // "Not found / other"


> Как сделать бэкап, и восстановиться из бэкапа

  > Сделать бэкап

    # RDB
      - Просто скопировать RDB-файл в безопасное место.
      - Угрозы целостности данных нет в связи с особенностью работы.

    # AOF
      - Просто скопировать лог в безопасное место.
      - Если при копировании посл. команда была повреждена, починить:

          redis-check-aof --fix


  > Восстановиться из бэкапа

    # Восстановление из RDB-файла, если AOF выключен
      - Просто поместить RDB файл в папку dir, указанную в конфиге.
      - Имя файла должно совпадать с указанным в директиве dbfilename в конфиге.
      - AOF должен быть выключен, директива appendonly no в конфиге.
      - И запустить сервер с этим конфигом. Данные будут восстановлены из файла.

    # Восстановление из AOF-лога
      - Поместить AOF-лог в папку dir, указанную в конфиге.
      - Имя файла должно совпадать с указанным в директиве appendfilename в конфиге.
      - AOF должен быть включён, директива appendonly yes в конфиге.
      - И запустить сервер с этим конфигом. Данные будут восстановлены из файла.





