////==================================================////
////                                                  ////
////                       gulp                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Официальный сайт gulp
        http://gulpjs.com/

    # Официальная документация по gulp 4
        https://github.com/gulpjs/gulp/tree/4.0/docs

    # Набор рецептов
        https://github.com/gulpjs/gulp/tree/4.0/docs/recipes

    # Плагины для gulp
        http://gulpjs.com/plugins/

    # Как написать плагин для gulp
        https://github.com/gulpjs/gulp/tree/4.0/docs/writing-a-plugin

  // Видео //
  //-------//

    # Скринкаст по gulp 4 от Ильи Кантора
        http://learn.javascript.ru/screencast/gulp

    # Плейлист по gulp 3 от LoftBlog
        https://www.youtube.com/playlist?list=PLY4rE9dstrJwXCz1utct9b6Vub9VWQoKo

  // Текст //
  //-------//

    # Приятная сборка frontend проекта (habr)
        https://habrahabr.ru/post/250569/

    # Самые нужные плагины для gulp
        https://habrahabr.ru/post/252745/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  gulp 4

    А1. Вводная информация
    А2. Установка и запуск задач на gulp
    А3. Потоки Vinyl-FS, gulp.dest + gulp.src
    А4. Делаем систему для сборки стилей на gulp



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Что такое gulp?

      - Приложения для NodeJS
      - Официально позиционируется, как
      - По сути является

    # Плагины
    # Vinyl-FS

      - Схема работы
      - Общая информация
      - Метафора

    # Простой наглядный пример использования

  --------------------------------------

  > Ссылки

    # Скринкаст по этой главе
        https://www.youtube.com/watch?time_continue=1&v=uPk6lQoTThE

  > Введение
    - Это глава с общей информацией о gulp 4.
    - В этой методичке описан именно gulp 4-й версии.

  > Что такое gulp?

    # Приложения для NodeJS
      - Представляет собой CLI-приложение для NodeJS.

    # Официально позиционируется, как
      - Streaming build system, или потоковая система сборки.

    # По сути является
      - Инструментом для описания и выполнение произвольного вида задач.
      - В gulpfile.js можно задавать любые задачи.
      - У них есть имя и функция, которая их выполняет.
      - Причём, новые задачи можно задавать, как комбинацию существующих.
      - И сборка проекта является лишь частным случаем таких задач.
      - В целом же, это могут быть любые задачи, не только касающиеся сборки.

  > Плагины
    - Есть много плагинов, позволяющих быстро задать многие востребованные задачи.
    - Они представляют из себя NodeJS-модули для работы с gulp.
    - И устанавливаются стандартным способом с помощью NPM.
    - Чтобы их использовать, надо просто require их в gulpfile.js
    - Посмотреть плагины можно на оф.сайте gulp: http://gulpjs.com/plugins/

  > Vinyl-FS

    # Схема работы

      |-------------|                                          |-------------|
      | File system |                                          | File system |
      |-------------|                                          |-------------|
            ||                                                       /\
            \/                                                       ||
      |------------|  |-------------|  |-------------|         |-------------|
      | Read files |->| Modify file |->| Modify file |-> ... ->| Write files |
      |------------|  |-------------|  |-------------|         |-------------|

    # Общая информация
      - Наличие Vinyl-FS делает gulp очень удобным именно для сборки проекта.
      - В ядре gulp существует виртуальная файловая система Vinyl-FS.
      - Она представляет каждый файл в виде JS-объекта, имеющего путь в ФС и т.д.
      - Эти объекты являются объектами специального класса Vinyl.
      - Представим, что gulp должен пропустить какой-то файл через N плагинов.
      - Он открывает поток для чтения данных (типа stream.Readable) и начинает читать файл.
      - Как нам известно из методички по NodeJS, чтение данных производится по
        кусочкам до 64 кб.
      - Как только 1-й кусочек прочинат, он посылается, как по трубопроводу,
        к 1-му плагину, потом ко 2-му, и т.д.
      - Тоже самое происходит со 2-ым, 3-им и т.д. считанными кусочками.
      - Также, gulp создаёт поток для записи данных (типа stream.Writable),
        и когда 1-й кусочек доходит до него, сразу записывает в указанное место.
      - Тоже самое делает со 2-м, 3-им и так далее кусочком.
      - То есть, изначальный файл может быть ещё не считан до конца,
        а 1-й кусочек уже прошёл через все плагины и записылся на выходе
        в новый файл.

    # Метафора
      - Представим, есть файл, его обработать N плагинами.
      - Gulp отрубает от него кусочки по 64 кб, и бросает в телепорт.
      - Телепорт символизирует из себя те самые N плагинов.
      - Каждый кусочек последовательно проходит через каждый плагин.
      - На выходе появляется сначала обработанный 1-й кусочек.
        За ним 2-й, 3-й и так далее.
      - В конечном счёте, кусочки собираются в итоговый файл.

  > Простой наглядный пример использования

      // 1] Подключить NodeJS-модули
      const gulp = require('gulp');
      const sass = require('gulp-sass');
      const autoprefixer = require('gulp-autoprefixer');

      // 2] Задать 1-ю задачу - обрабатывающую все *.scss файлы в dev
      gulp.task(function sass(){
        return gulp.src('dev/*.scss')       // Создать readable-поток, считывающий данные из dev/*.scss файлов
          .pipe(sass())                     // Обрабатывать данные плагином sass
          .pipe(autoprefixer())             // Обрабатывать данные плагином autoprefixer
          .pipe(gulp.dest('css/styles'));   // Создать writable-поток, записывающий файлы в css/styles
      });

      // 3] Задать 2-ю задачу - слежение за всеми *.scss файлами в dev
      // - Если какой-нибудь из них изменится, запускать серию указанных задач.
      // - В нашем случае, это задача: 'sass'
      gulp.task('default', gulp.series('sass', function(){
        gulp.watch('dev/*.scss', gulp.series('sass'));
      });


А2. Установка и запуск задач на gulp

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка gulp

      - Gulp понадобится иметь и локально, и глобально
      - Вариант №1: установить 2 gulp'а
      - Вариант №2: установить только локальный gulp

    # Запуск задач на gulp

      - Простейший пример
      - Можно (но не нужно) не указывать имя задачи, имя функции == имя задачи
      - Можно разбивать название задач на несколько слов
      - Каждая задача должна сообщать о завершении с помощью callback
      - 4 основных способа, как задача сигнализирует о своём завершении
      - Создание новых задач из старых, последовательный / параллельный порядок выполнения
      - Gulp не передаёт данные между задачами

  --------------------------------------

  > Ссылки

    # Скринкаст по этой главе
        https://www.youtube.com/watch?v=xptUdO3GuG8

  > Введение
    - В этой главе рассмотрим установку gulp.
    - А также запуск задач на gulp.

  > Установка gulp

    # Gulp понадобится иметь и локально, и глобально
      - Глобально, чтобы CLI был доступен из любого каталога.
      - Локально, поскольку gulp потребуется подключать через
        require к gulpfile, как модуль.

    # Вариант №1: установить 2 gulp'а
      - Один gulp установить локально.
      - Второй gulp установить глобально.
      - Глобально установить gulp 4 можно так:

          npm install -g gulp#4.0

      - Локально в выбранный каталог, его можно установить так.
      - Сначала создать там package.json (конфиг для NPM):

          npm init      // можно оставить всё по умолчанию

      - Затем установить gulp 4 локально в этот каталог:

          npm install gulpjs/gulp#4.0

      - После этого с gulp можно работать глобально.
      - Например:

          gulp -version

    # Вариант №2: установить только локальный gulp
      - Но в scripts в package.json добавить вручную запуск локального gulp.
      - Чтобы при запуске - gulp - из каталога проекта, запускался указанный скрипт.
      - Итак, сначала надо выбрать каталог, и создтаь там package.json (конфиг для NPM):

          npm init      // можно оставить всё по умолчанию

      - Затем установить gulp 4 локально в этот каталог:

          npm install gulpjs/gulp#4.0

      - Затем открыть package.json, и в "scripts" добавить:

          "gulp": "./node_modules/.bin/gulp"

      - После этого с gulp можно работать через npm run.
      - Например:

          npm run gulp -version

      - Далее будет предполагать, что использован этот вариант установки.

  > Запуск задач на gulp

    # Простейший пример
      - Сначала надо создать gulpfile.js - конфиг для gulp.
      - Он будет представлять из себя обычное NodeJS-приложение.
      - Вот простейший пример кода для этого файла, с простейшей задачей:

          'use strict';

          // 1] Подключить модуль gulp
          const gulp = require('gulp');

          // 2] Создать новую задачу с именем 'hello'
          gulp.task('hello', function(callback){

            // 2.1] Вывести сообщение
            console.log('Hello, world');

            // 2.2] Показать, что задача завершена
            callback();   // Если бы была ошибка, надо было бы передать в её в кач-ве аргумента callback

          });

      - Теперь из терминала можно запустить задачу hello.
      - И будет выведена строка "Hello, world".

          npm run gulp hello

    # Можно (но не нужно) не указывать имя задачи, имя функции == имя задачи
      - В современном gulp можно не указывать имя для task.
      - Если у функции есть имя, оно авто-ки становится именем задачи.
      - Пример - создаём задачу с именем hello:

          gulp.task('hello', function(callback){});   // вариант 1
          gulp.task(function hello(callback){});      // вариант 2

      - Отсюда следует, что можно сделать так:

          gulp.task(hello);
          function hello(){
            // ...
          }

      - Однако, у такого способа запуска задач есть недостаток.
      - Нельзя брать в качесте имени задач зарезервированные слова.
      - К примеру, default является зарезервирвоанным словом.
      - И нельзя сделать так (это не будет работать):

          gulp.task(default);
          function default(){
            // ...
          }

      - Поэтому, лучше всё же придерживаться классического способа определения задач.
      - Где у задачи есть название, и есть анонимная функция:

          gulp.task('hello', function(callback){});

    # Можно разбивать название задач на несколько слов
      - В проекте может быть очень много задач, десятки, сотни, и т.д.
      - Часто хочется каким-то образом сгруппировать эти задачи.
      - Это можно делать, используя префиксы к именам задач.
      - То есть, формировать имя задачи по шаблону:

          [префикс]:[имя задачи]

      - Например, есть у зас задачи, связанные с SASS.
      - Тогда их имена могут быть такие:

          gulp.task('sass:name1', function(callback){});
          gulp.task('sass:name2', function(callback){});
          gulp.task('sass:name3', function(callback){});

    # Каждая задача должна сообщать о завершении с помощью callback
      - Каждая задача в gulp запускается асинхронно.
      - А gulp хотел бы знать, если та или иная задача завершилась.
      - Для этого задача должна возбудить соотв.событие для gulp.
      - Это можно сделать через функцию callback из 1-го аргумента
        функции-задачи.
      - Пример:

          // 1] Задача, завершающаяся успешно
          gulp.task('sass:name1', function(callback){
            callback();   // Сообщить, что задача завершена успешно
          });

    # 4 основных способа, как задача сигнализирует о своём завершении

      'use strict';

      const gulp = require('gulp');

      // 1] Сигнализирует о завершении с помощью callback()
      gulp.task('hello', function(callback){
        console.log('hello');
        callback();
      });

      // 2] Возвращает объект класса Promise
      gulp.task('example:promise', function(){
        return new Promise((resolve, reject) => {
          // ...
          resolve('result');
        });
      });

      // 3] Возвращает поток
      gulp.task('example:stream', function(){
        return require('fs').createReadStream(__filename);  // Прочитанные данные никуда не передаются
      });

      // 4] Порождает новый дочерний процесс, и возвращает его
      gulp.task('example:process', function(){
        return require('child_process').spawn('ls', ['node_modules'], {stdio: 'inherit'});
      });

    # Создание новых задач из старых, последовательный / параллельный порядок выполнения
      - Например, можно создать задачу, выполняющую 4 задачи из примера выше.
      - Причём, можно настроить порядок выполнения:

        1) Последовательно
          - Для этого надо использовать метод series.
          - Пример:

              gulp.task('example', gulp.series('hello', 'example:promise', 'example:stream', 'example:process'));

        2) Параллельно
          - Для этого надо использовать метод parallel.
          - Пример:

              gulp.task('example', gulp.parallel('hello', 'example:promise', 'example:stream', 'example:process'));

    # Gulp не передаёт данные между задачами
      - Что бы ни вернула задача.
      - Следующая задача этого не получит.


А3. Потоки Vinyl-FS, gulp.dest + gulp.src

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Объекты Vinyl и объекты Buffer
    # Gulp передаёт объекты Vinyl между плагинами

      - Главное
      - Куда записывает файлы gulp.dest
        - Если передать строку
        - Если передать функцию

    # Важнейший св-ва объекта Vinyl

      Постоянные
        - contents    | Содержимое
        - path        | Путь к файлу
        - cwd         | Корневой каталог для запуска gulp
        - base        | Постоянная часть переданного паттерна

      Вычисляемые
        - relative    | Переменная часть переданного паттерна
        - dirname     | Путь к каталогу с файлом
        - basename    | Имя файла
        - stem        | Имя файла без расширения
        - extname     | Расширение файла без имени

    # NodeJS-модуль minimatch, применение в gulp.src

      - Вводная информация
      - Globe-паттерны
      - Примеры использования
        - Пример №1: считывание лишь файлов указанных расширений
        - Пример №2: считывание файлов из нескольких base-путей
        - Пример №3: последовательное считывание групп файлов
        - Пример №4: игнорирование указанных каталогов/файлов

    # Несколько полезных опций для gulp.src

      - Не читать контент файлов (read: false)
      - Чтение файлов только начиная с указаной даты (since: ...)
      - Создать для каждого файла readable-поток (buffer: false)
      - Явно указать cwd для задачи (cwd: "...")
      - Указать base в явном виде (base: "...")

  --------------------------------------

  > Ссылки

    # Скринкаст по этой главе
        https://www.youtube.com/watch?v=NBdKplKl_3Q

    # Оф.документация по объектам типа vinyl
        https://github.com/gulpjs/vinyl

    # NodeJS-модуль minimatch
        https://www.npmjs.com/package/minimatch

    # Glob-паттерны из unix-систем
        http://wiki.bash-hackers.org/syntax/pattern

  > Введение
    - Эта глава поможет разобраться в основах gulp и Vinyl-FS.

  > Объекты Vinyl и объекты Buffer

    # Основное
      - В ссылках главы есть оная на документацию по объектам Vinyl.
      - В соотв.репозитории лежит NodeJS-модуль под названием vinyl.
      - Его можно подключать к NodeJS-проекту и использовать.
      - Например:

          var File = require('vinyl');

          var coffeeFile = new File({
            cwd: "/",
            base: "/test/",
            path: "/test/file.coffee",
            contents: new Buffer("test = 123")
          });

      - Объекты типа vinyl имеют ряд методов (см.документацию).

    # Объекты Buffer
      - Как видно в примере выше, св-во contents содержит объект Buffer.
      - Это высокоэффективное средство NodeJS для работы с бинарными данными.
      - Технически, это непрерывная область памяти, заполненная этими данными.
      - Подробнее о них см. в методичке по NodeJS.

  > Gulp передаёт объекты Vinyl между плагинами

    # Главное
      - Объекты Vinyl можно назвать виртуальными файлами.
      - В виртуальной файловой системе Vinyl-FS.
      - Именно они и передаются по цепочки между плагинами в gulp.
      - В этом можно убедиться на практике:

          1) Создадим каталог source в корне проекта

            /source
              /1
                1.js
                2.js

          2) В gulpfile добавим код:

            'use strict';

            // 1] Подключить модуль gulp
            const gulp = require('gulp');

            // 2] Создать задачу default
            gulp.task('default', function(){
              return gulp.src('source/**/*.*')    // Создать readable-поток, считывающий данные из dev/*.scss файлов
                .on('data', function(file){       // Назначить readable-потоку обработчик события 'data' (возвращает этот же поток)
                  console.log(file);              // Вывести считанные потоком данные в консоль (объект Vinyl).
                })
                .pipe(gulp.dest('dest'));         // Создать writable-поток, записывающий файлы в css/styles
            });

          3) Запустить задачу default

              npm run gulp default

      - Запустив эту задачу, мы увидим в терминале, что передаётся между плагинами.
      - А именно, что это объекты типа Vinyl.

    # Куда записывает файлы gulp.dest

      ## Если передать строку
        - Метод dest может принять в качестве аргумента строку с путём.
        - Причём этот путь относительный, относительно абсолютного пути
          из св-ва cwd файла.
        - Если там каталога нет, то dest создаёт там новый каталог.
        - И записывает данные для каждого кусочка (Vinyl-файла) в файл:

            [путь из аргумента]/file.relative

        - Где relative, это одно из св-в Vinyl-файла (см.ниже).

      ## Если передать функцию
        - То эта функция должна вернуть строку с путём.
        - Она может вернуть тот или иной путь в зависимости от чего-то.
        - Например, функция может заглядывать в extname файла.
        - И если там '.js', возвращать путь к каталогу с js-файлами.
        - А если там '.css', возвращать путь к каталогу с css-файлами.
        - Пример:

            gulp.dest(function(file){

              // Если js-файл
              if(file.extname == '.js')
                return 'js';

              // Если css-файл
              if(file.extname == '.css')
                return 'css';

              // Если ни то, ни сё, путь по умолчанию
              return 'dest';

            });

  > Важнейший св-ва объекта Vinyl

    # Основное
      - См.список свойств в оглавлении.
      - Здесь будут лишь пояснения к некоторым из них.

    # Постоянные и вычисляемые св-ва
      - У объекта Vinyl есть 2 типа св-в: постоянные и вычисляемые.
      - Какие из них какие, обозначено в оглавлении главы.

    # Наглядная демонстрация св-в объекта Vinyl
      - Выше в пункте "Gulp передаёт объекты Vinyl между плагинами" есть пример.
      - В нём в обработчике события 'data' в терминал выводится объект Vinyl.
      - Но при таком выводе, свойств этого объекта всё равно в терминале не видно.
      - Можно модифицировать содержимое обработчика того примера таким
        образом, чтобы увидеть содержимое важных свойств объекта Vinyl:

          console.log({

            // Постоянные
            contents: file.contents,
            path:     file.path,
            cwd:      file.cwd,
            base:     file.base,        // '/home/vagrant/dev.app/gulptest/source/'

            // Вычисляемые
            relative: file.relative,    // '1/2.js'
            dirname:  file.dirname,     // '/home/vagrant/dev.app/gulptest/source/1'
            basename: file.basename,    // '1.js'
            stem:     file.stem,        // '1'
            extname:  file.extname      // '.js'

          });

    # base и relative
      - В примере выше методу src передан паттерн "source/**/*.*".
      - В этом паттерне есть постоянная часть: "source/".
      - И есть переменная часть: "/**/*.*".
      - Соответственно, путь для постоянной части записывается
        в base передаваемого между плагинами объекта Vinyl. Причём,
        это полностью квалифицированный путь от корня ФС.
      - А путь для переменной части передаваемого файла записывается
        в виде относительного пути относительно постоянной части.

  > NodeJS-модуль minimatch, применение в gulp.src

    # Вводная информация
      - В примерах выше для gulp.src был использован паттерн 'source/**/*.*'.
      - Для его "разбора" gulp внутри себя использует модуль minimatch.
      - Minimatch конвертирует glob-паттерны в JS-овские RegExp.
      - Glob-паттерны используются в unix-системах, типа звёздочки в пути и всё такое.
      - В итоге, в паттерне для gulp.src можно использовать
        те самые glob-паттерны из unix-систем.
      - Подробнее о них здесь: https://en.wikipedia.org/wiki/Glob_(programming)

    # Globe-паттерны

      **                  | Любой путь

      *	                  | Matches any string, including the null string (empty string)
      ?	                  | Matches any single character
      X	                  | Matches the character X which can be any character that has no special meaning
      \X	                | Matches the character X, where the character's special meaning is stripped by the backslash
      \\	                | Matches a backslash
      […]	                | Defines a pattern bracket expression (see below). Matches any of the enclosed characters at this position.

      [XYZ]	              | The "normal" bracket expression, matching either X, Y or Z
      [X-Z]	              | A range expression: Matching all the characters from X to Y (your current locale, defines how the characters are sorted!)
      [[:class:]]	        | Matches all the characters defined by a POSIX® character class: alnum, alpha, ascii, blank, cntrl, digit, graph, lower, print, punct, space, upper, word and xdigit
      [^…]	              | A negating expression: It matches all the characters that are not in the bracket expression
      [!…]	              | Equivalent to [^…]
      []...] or [-…]	    | Used to include the characters ] and - into the set, they need to be the first characters after the opening bracket
      [=C=]	              | Matches any character that is eqivalent to the collation weight of C (current locale!)
      [[.SYMBOL.]]	      | Matches the collating symbol SYMBOL

      ?(<PATTERN-LIST>)	  | Matches zero or one occurrence of the given patterns
      *(<PATTERN-LIST>)	  | Matches zero or more occurrences of the given patterns
      +(<PATTERN-LIST>)	  | Matches one or more occurrences of the given patterns
      @(<PATTERN-LIST>)	  | Matches one of the given patterns
      !(<PATTERN-LIST>)	  | Matches anything except one of the given patterns

    # Примеры использования

      ## Пример №1: считывание лишь файлов указанных расширений
        - Используем globe-паттерны на примере при работе с gulp.src
        - Допустим мы хотим, чтобы он читал лишь .js и .css файлы.
        - Для этого модифицируем один из предыдущих примеров:

            gulp.src('source/**/*.{js,css}')

      ## Пример №2: считывание файлов из нескольких base-путей
        - Используем globe-паттерны на примере при работе с gulp.src
        - Допустим, надо брать файлы не из одного, но нескольких каталогов.
        - Скажем, из каталогов source1 и source2.
        - Модифицируем пример выше, чтобы добиться этого:

            gulp.src('{source1,source2}/**/*.{js,css}')

      ## Пример №3: последовательное считывание групп файлов
        - Вообще, gulp.src ещё позволяет указывать и массив.
        - Например:

            gulp.src(['{source1,source2}/**/*.js', '{source1,source2}/**/*.css'])

        - В примере выше JS-файлы будут обработаны первыми.
        - А уже после них будут обработаны CSS-файлы.

      ## Пример №4: игнорирование указанных каталогов/файлов
        - Часто надо явно указать, чтобы src игнорировал указанные каталоги/файлы.
        - Например, чаще всего потребуется игнорировать каталог node_modules.

        ### Как делать НЕ надо
          - Вот так

            gulp.src(['**/*.*', '!node_modules/**'])

          - Gulp будет просматривать ВСЕ файлы в base path.
          - Включая те, которые лежать в node_modules.
          - И проверять их пути, если они не в "node_modules/**", считывать.
          - Но т.к. node_modules м.б. очень большим, получается медленно.

        ### Как лучше делать
          - Лучше не использовать паттернт отрицания вообще.
          - А вместо этого явно указывать, что нам нужно.
          - Это в разы, десятки раз увеличит скорость работы:

            gulp.src(['{css,js,source}/**/*.*', 'gulpfile.js', 'package.json'])


  > Несколько полезных опций для gulp.src

    # Не читать контент файлов (read: false)
      - Допустим, нам надо удалить некие видео-файлы.
      - Они очень тяжёлые, и читать их в память не хотелось бы.
      - Да и для их удаления это нам нен ужно.
      - Тогда, можно применить опцию read: false.
      - Пример:

        gulp.src(['movies/**/*.mp4'], {read: false})

      - В итоге, в contents vinyl-файлов в потоке будет null/

    # Чтение файлов только начиная с указаной даты (since: ...)
      - since: new Date(...)

    # Создать для каждого файла readable-поток (buffer: false)
      - Обычно gulp.src в contents каждого vinyl-файла в потоке
        кладёт объект Buffer с бинарными данными.
      - Но если применить buffer: false, то в contents будут
        лежать readable-потоки.
      - Эта возможность используется очень редко, т.к. большинство
        плагинов предполагают, что vinyl-файл уже считан полностью,
        и они могут работать с его содержимым.

    # Явно указать cwd для задачи (cwd: "...")
      - По умолчанию, cwd это каталог самого процесса gulp.
      - То есть, это тот каталог, где лежит gulpfile.js.
      - Но для каждой задачи можно явно указать cwd с помощью опции.

    # Указать base в явном виде (base: "...")
      - По умолчанию base вычисляется из 1-го аргумента в src.
      - Но можно указать его и в явном виде.

          gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})


А4. Делаем систему для сборки стилей на gulp

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Исходные условия

    # [gulp-sass] *.sass ---> *.css
    # [gulp-concat] *.sass ---> *.css ---> all.css
    # [gulp-debug] Выводить инфу о действиях gulp в терминал
    # [] Применение @import в sass
    # [gulp-sourcemaps] Формировать sourcemaps
    # [gulp-of] Задавать if-условия при pipe-инге

  --------------------------------------

  > Ссылки

    #

  > Введение
    - В этой главе мы рассмотрим создание системы сборки стилей на gulp.
    - Для стилей будем использовать препроцессор SASS.
    - Будем в процессе рассматривать различные важные плагины.
    - В конце концов, это будет готовое для продакшн решение.

  > Исходные условия

    /project
      /public
      /frontend
        /assets
          /img
          index.html
        /styles
          header.scss
          main.scss

  > [gulp-sass] *.sass ---> *.css

    # Формулировка
      - Надо найти все ".scss" стили в каталоге "/project/frontend/styles/"
      - Преобразовать их в ".css"
      - И сохранить в каталог "/project/public/"

    # Описание решения
      - Для преобразования scss->css применим плагин gulp-sass.
      - Для этого его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-sass

      - Для поиска .scss применяем glob-паттерн 'frontend/styles/**/*.scss'.
      - Результаты записываем в каталог public.

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/**/*.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

    # А что, если нам надо положить все стили в конкретный каталог внутри public

      ## Вариант №1
        - Можно явно указать base для gulp.src.
        - Пример:

            gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})

      ## Вариант №2
        - Можно изменить base в glob-паттерн.
        - На вот такой:

            gulp.src('frontend/**/*.scss')

        - В итоге base == 'frontend'.
        - И т.к. .scss лежат в каталоге frontend/styles,
          то они будут скопированы в frontend/styles.

  > [gulp-concat] *.sass ---> *.css ---> all.css

    # Формулировка
      - Надо сделать тоже самое, что в задаче №1.
      - Плюс объединить весь css в 1 файл "all.css".

    # Описание решения
      - Для объединения css-файлов нам понадобится плагин gulp-concat.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-concat

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const concat = require('gulp-concat');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})
              .pipe(sass())
              .pipe(concat('all.css'))
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp-debug] Выводить инфу о действиях gulp в терминал

    # Формулировка
      - По умолчанию gulp не выводит в терминал, что он делает.
      - Иногда такая информация требуется.
      - Задача: выводить в терминал, что делаег gulp.

    # Описание решения
      - Для этого нам понадобится плагин gulp-debug.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-debug

      - В итоге, получим вывод типа:

          [03:31:46] src frontend/styles/header.scss
          [03:31:46] src frontend/styles/main.scss
          [03:31:46] src 2 items
          [03:31:46] sass frontend/styles/header.css
          [03:31:46] sass frontend/styles/main.css
          [03:31:46] sass 2 items
          [03:31:46] concat frontend/all.css
          [03:31:46] concat 1 item

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const concat = require('gulp-concat');
        const debug = require('gulp-debug');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})
              .pipe(debug({title: 'src'}))
              .pipe(sass())
              .pipe(debug({title: 'sass'}))
              .pipe(concat('all.css'))
              .pipe(debug({title: 'concat'}))
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [] Применение @import в sass

    # Формулировка
      - Допустим, у нас имеются 2 .scss файла: "main" и "header".
      - И мы хотим их объединить в один файл main.css.
      - Причём, чтобы сначала шёл "header", а потом "main".
      - Аналогичным образом можно объединять сколько угодно файлов.

    # Описание решения
      - Для этого нам надо в начале "main" добавить строку:

          @import "header.scss";

      - И после этого можно уже работать с main.
      - При его обработке gulp'ом файл "header" будет подтянут и обработан.

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp-sourcemaps] Формировать sourcemaps

    # Что такое sourcemaps
      - Это специальная структура данных, актуальная при их преобразовании.
      - В ней содержатся данные о том, что было, и что стало, и где всё это.
      - Эта структура данных может быть:

        1) В конце самого модифицированного файла
        2) В отдельном одноимённом файле, в том же каталоге, с .map на конце.

      - По sourcemap браузер находит исходники для преобразованного файла.
      - И при отладке, если возникают ошибки, указывает на ошибку в исходнике.
      - Таким образом, sourcemaps незаменимый инструмент при разработке.

    # Формулировка
      - Необходимо обеспечить наличие sourcemaps при работе gulp.

    # Описание решения
      - Для этого нам понадобится плагин gulp-sourcemaps.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-sourcemaps

      - Плагин "gulp-sourcemaps" один из основных, и написан разработчиками gulp.
      - Интегрирован чуть менее, чем со всеми инструментами, меняющими содержимое файлов.
      - Что он делает:

        1) Перед изменением файла мы пропускаем его через sourcemaps.init()
          - Когда в него поступает новый vinyl-файл, плагин создаёт у него
            новое пустое свойство sourceMap (пустое, т.к. с файлом ещё ничего не делали).

        2) Каждый инструмент дописывает в sourceMap файла информацию
          - Как упоминалось выше, почти все инструменты поддерживают работу с sourceMap.
          - Если инструмент видит, что у файла есть это св-во, он дописывает туда инфу.

        3) Когда все изменения файла завершены, применяем sourcemaps.write()
          - К этому моменту св-во sourceMap содержит всю необходимую инфу.
          - Теперь его надо записать:

            3.1) В итоговый файл
              - Тогда надо применить write() без агрументов.

            3.2) В файл по указанному адресу
              - Например, в файл по соседству, с .map на конце.
              - Тогда надо применить write('.').

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const sourcemaps = require('gulp-sourcemaps');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sourcemaps.init())
              .pipe(sass())
              .pipe(gulp.dest('public'))
              .pipe(sourcemaps.write());

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });



