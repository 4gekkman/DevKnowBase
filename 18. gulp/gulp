////==================================================////
////                                                  ////
////                       gulp                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Официальный сайт gulp
        http://gulpjs.com/

    # Официальная документация по gulp 4
        https://github.com/gulpjs/gulp/tree/4.0/docs

    # Набор рецептов
        https://github.com/gulpjs/gulp/tree/4.0/docs/recipes

    # Плагины для gulp
        http://gulpjs.com/plugins/

    # Как написать плагин для gulp
        https://github.com/gulpjs/gulp/tree/4.0/docs/writing-a-plugin

  // Видео //
  //-------//

    # Скринкаст по gulp 4 от Ильи Кантора
        http://learn.javascript.ru/screencast/gulp

    # Плейлист по gulp 3 от LoftBlog
        https://www.youtube.com/playlist?list=PLY4rE9dstrJwXCz1utct9b6Vub9VWQoKo

  // Текст //
  //-------//

    # Приятная сборка frontend проекта (habr)
        https://habrahabr.ru/post/250569/

    # Самые нужные плагины для gulp
        https://habrahabr.ru/post/252745/


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  gulp 4

    А1. Вводная информация
    А2. Установка и запуск задач на gulp
    А3. Потоки Vinyl-FS, gulp.dest + gulp.src
    А4. Делаем систему для сборки стилей на gulp
    А5. Увеличение производительности при работе с файлами
    А6. Автоперезагрузка браузера: вводная информация
    А7. Автоперезагрузка браузера: browser-sync
    А8. Обработка ошибок


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Что такое gulp?

      - Приложения для NodeJS
      - Официально позиционируется, как
      - По сути является

    # Плагины
    # Vinyl-FS

      - Схема работы
      - Общая информация
      - Метафора

    # Простой наглядный пример использования

  --------------------------------------

  > Ссылки

    # Скринкаст по этой главе
        https://www.youtube.com/watch?time_continue=1&v=uPk6lQoTThE

  > Введение
    - Это глава с общей информацией о gulp 4.
    - В этой методичке описан именно gulp 4-й версии.

  > Что такое gulp?

    # Приложения для NodeJS
      - Представляет собой CLI-приложение для NodeJS.

    # Официально позиционируется, как
      - Streaming build system, или потоковая система сборки.

    # По сути является
      - Инструментом для описания и выполнение произвольного вида задач.
      - В gulpfile.js можно задавать любые задачи.
      - У них есть имя и функция, которая их выполняет.
      - Причём, новые задачи можно задавать, как комбинацию существующих.
      - И сборка проекта является лишь частным случаем таких задач.
      - В целом же, это могут быть любые задачи, не только касающиеся сборки.

  > Плагины
    - Есть много плагинов, позволяющих быстро задать многие востребованные задачи.
    - Они представляют из себя NodeJS-модули для работы с gulp.
    - И устанавливаются стандартным способом с помощью NPM.
    - Чтобы их использовать, надо просто require их в gulpfile.js
    - Посмотреть плагины можно на оф.сайте gulp: http://gulpjs.com/plugins/

  > Vinyl-FS

    # Схема работы

      |-------------|                                          |-------------|
      | File system |                                          | File system |
      |-------------|                                          |-------------|
            ||                                                       /\
            \/                                                       ||
      |------------|  |-------------|  |-------------|         |-------------|
      | Read files |->| Modify file |->| Modify file |-> ... ->| Write files |
      |------------|  |-------------|  |-------------|         |-------------|

    # Общая информация
      - Наличие Vinyl-FS делает gulp очень удобным именно для сборки проекта.
      - В ядре gulp существует виртуальная файловая система Vinyl-FS.
      - Она представляет каждый файл в виде JS-объекта, имеющего путь в ФС и т.д.
      - Эти объекты являются объектами специального класса Vinyl.
      - Представим, что gulp должен пропустить какой-то файл через N плагинов.
      - Он открывает поток для чтения данных (типа stream.Readable) и начинает читать файл.
      - Как нам известно из методички по NodeJS, чтение данных производится по
        кусочкам до 64 кб.
      - Как только 1-й кусочек прочинат, он посылается, как по трубопроводу,
        к 1-му плагину, потом ко 2-му, и т.д.
      - Тоже самое происходит со 2-ым, 3-им и т.д. считанными кусочками.
      - Также, gulp создаёт поток для записи данных (типа stream.Writable),
        и когда 1-й кусочек доходит до него, сразу записывает в указанное место.
      - Тоже самое делает со 2-м, 3-им и так далее кусочком.
      - То есть, изначальный файл может быть ещё не считан до конца,
        а 1-й кусочек уже прошёл через все плагины и записылся на выходе
        в новый файл.

    # Метафора
      - Представим, есть файл, его обработать N плагинами.
      - Gulp отрубает от него кусочки по 64 кб, и бросает в телепорт.
      - Телепорт символизирует из себя те самые N плагинов.
      - Каждый кусочек последовательно проходит через каждый плагин.
      - На выходе появляется сначала обработанный 1-й кусочек.
        За ним 2-й, 3-й и так далее.
      - В конечном счёте, кусочки собираются в итоговый файл.

  > Простой наглядный пример использования

      // 1] Подключить NodeJS-модули
      const gulp = require('gulp');
      const sass = require('gulp-sass');
      const autoprefixer = require('gulp-autoprefixer');

      // 2] Задать 1-ю задачу - обрабатывающую все *.scss файлы в dev
      gulp.task(function sass(){
        return gulp.src('dev/*.scss')       // Создать readable-поток, считывающий данные из dev/*.scss файлов
          .pipe(sass())                     // Обрабатывать данные плагином sass
          .pipe(autoprefixer())             // Обрабатывать данные плагином autoprefixer
          .pipe(gulp.dest('css/styles'));   // Создать writable-поток, записывающий файлы в css/styles
      });

      // 3] Задать 2-ю задачу - слежение за всеми *.scss файлами в dev
      // - Если какой-нибудь из них изменится, запускать серию указанных задач.
      // - В нашем случае, это задача: 'sass'
      gulp.task('default', gulp.series('sass', function(){
        gulp.watch('dev/*.scss', gulp.series('sass'));
      });


А2. Установка и запуск задач на gulp

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка gulp

      - Gulp понадобится иметь и локально, и глобально
      - Вариант №1: установить 2 gulp'а
      - Вариант №2: установить только локальный gulp

    # Запуск задач на gulp

      - Простейший пример
      - Можно (но не нужно) не указывать имя задачи, имя функции == имя задачи
      - Можно разбивать название задач на несколько слов
      - Каждая задача должна сообщать о завершении с помощью callback
      - 4 основных способа, как задача сигнализирует о своём завершении
      - Создание новых задач из старых, последовательный / параллельный порядок выполнения
      - Gulp не передаёт данные между задачами

  --------------------------------------

  > Ссылки

    # Скринкаст по этой главе
        https://www.youtube.com/watch?v=xptUdO3GuG8

  > Введение
    - В этой главе рассмотрим установку gulp.
    - А также запуск задач на gulp.

  > Установка gulp

    # Gulp понадобится иметь и локально, и глобально
      - Глобально, чтобы CLI был доступен из любого каталога.
      - Локально, поскольку gulp потребуется подключать через
        require к gulpfile, как модуль.

    # Вариант №1: установить 2 gulp'а
      - Один gulp установить локально.
      - Второй gulp установить глобально.
      - Глобально установить gulp 4 можно так:

          npm install gulpjs/gulp#4.0 -g

      - Локально в выбранный каталог, его можно установить так.
      - Сначала создать там package.json (конфиг для NPM):

          npm init      // можно оставить всё по умолчанию

      - Затем установить gulp 4 локально в этот каталог:

          npm install gulpjs/gulp#4.0

      - После этого с gulp можно работать глобально.
      - Например:

          gulp -version

    # Вариант №2: установить только локальный gulp
      - Но в scripts в package.json добавить вручную запуск локального gulp.
      - Чтобы при запуске - gulp - из каталога проекта, запускался указанный скрипт.
      - Итак, сначала надо выбрать каталог, и создтаь там package.json (конфиг для NPM):

          npm init      // можно оставить всё по умолчанию

      - Затем установить gulp 4 локально в этот каталог:

          npm install gulpjs/gulp#4.0

      - Затем открыть package.json, и в "scripts" добавить:

          "gulp": "./node_modules/.bin/gulp"

      - После этого с gulp можно работать через npm run.
      - Например:

          npm run gulp -version

      - Далее будет предполагать, что использован этот вариант установки.

  > Запуск задач на gulp

    # Простейший пример
      - Сначала надо создать gulpfile.js - конфиг для gulp.
      - Он будет представлять из себя обычное NodeJS-приложение.
      - Вот простейший пример кода для этого файла, с простейшей задачей:

          'use strict';

          // 1] Подключить модуль gulp
          const gulp = require('gulp');

          // 2] Создать новую задачу с именем 'hello'
          gulp.task('hello', function(callback){

            // 2.1] Вывести сообщение
            console.log('Hello, world');

            // 2.2] Показать, что задача завершена
            callback();   // Если бы была ошибка, надо было бы передать в её в кач-ве аргумента callback

          });

      - Теперь из терминала можно запустить задачу hello.
      - И будет выведена строка "Hello, world".

          npm run gulp hello

    # Можно (но не нужно) не указывать имя задачи, имя функции == имя задачи
      - В современном gulp можно не указывать имя для task.
      - Если у функции есть имя, оно авто-ки становится именем задачи.
      - Пример - создаём задачу с именем hello:

          gulp.task('hello', function(callback){});   // вариант 1
          gulp.task(function hello(callback){});      // вариант 2

      - Отсюда следует, что можно сделать так:

          gulp.task(hello);
          function hello(){
            // ...
          }

      - Однако, у такого способа запуска задач есть недостаток.
      - Нельзя брать в качесте имени задач зарезервированные слова.
      - К примеру, default является зарезервирвоанным словом.
      - И нельзя сделать так (это не будет работать):

          gulp.task(default);
          function default(){
            // ...
          }

      - Поэтому, лучше всё же придерживаться классического способа определения задач.
      - Где у задачи есть название, и есть анонимная функция:

          gulp.task('hello', function(callback){});

    # Можно разбивать название задач на несколько слов
      - В проекте может быть очень много задач, десятки, сотни, и т.д.
      - Часто хочется каким-то образом сгруппировать эти задачи.
      - Это можно делать, используя префиксы к именам задач.
      - То есть, формировать имя задачи по шаблону:

          [префикс]:[имя задачи]

      - Например, есть у зас задачи, связанные с SASS.
      - Тогда их имена могут быть такие:

          gulp.task('sass:name1', function(callback){});
          gulp.task('sass:name2', function(callback){});
          gulp.task('sass:name3', function(callback){});

    # Каждая задача должна сообщать о завершении с помощью callback
      - Каждая задача в gulp запускается асинхронно.
      - А gulp хотел бы знать, если та или иная задача завершилась.
      - Для этого задача должна возбудить соотв.событие для gulp.
      - Это можно сделать через функцию callback из 1-го аргумента
        функции-задачи.
      - Пример:

          // 1] Задача, завершающаяся успешно
          gulp.task('sass:name1', function(callback){
            callback();   // Сообщить, что задача завершена успешно
          });

    # 4 основных способа, как задача сигнализирует о своём завершении

      'use strict';

      const gulp = require('gulp');

      // 1] Сигнализирует о завершении с помощью callback()
      gulp.task('hello', function(callback){
        console.log('hello');
        callback();
      });

      // 2] Возвращает объект класса Promise
      gulp.task('example:promise', function(){
        return new Promise((resolve, reject) => {
          // ...
          resolve('result');
        });
      });

      // 3] Возвращает поток
      gulp.task('example:stream', function(){
        return require('fs').createReadStream(__filename);  // Прочитанные данные никуда не передаются
      });

      // 4] Порождает новый дочерний процесс, и возвращает его
      gulp.task('example:process', function(){
        return require('child_process').spawn('ls', ['node_modules'], {stdio: 'inherit'});
      });

    # Создание новых задач из старых, последовательный / параллельный порядок выполнения
      - Например, можно создать задачу, выполняющую 4 задачи из примера выше.
      - Причём, можно настроить порядок выполнения:

        1) Последовательно
          - Для этого надо использовать метод series.
          - Пример:

              gulp.task('example', gulp.series('hello', 'example:promise', 'example:stream', 'example:process'));

        2) Параллельно
          - Для этого надо использовать метод v.
          - Пример:

              gulp.task('example', gulp.parallel('hello', 'example:promise', 'example:stream', 'example:process'));

    # Gulp не передаёт данные между задачами
      - Что бы ни вернула задача.
      - Следующая задача этого не получит.


А3. Потоки Vinyl-FS, gulp.dest + gulp.src

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Объекты Vinyl и объекты Buffer
    # Gulp передаёт объекты Vinyl между плагинами

      - Главное
      - Куда записывает файлы gulp.dest
        - Если передать строку
        - Если передать функцию

    # Важнейший св-ва объекта Vinyl

      Постоянные
        - contents    | Содержимое
        - path        | Путь к файлу
        - cwd         | Корневой каталог для запуска gulp
        - base        | Постоянная часть переданного паттерна

      Вычисляемые
        - relative    | Переменная часть переданного паттерна
        - dirname     | Путь к каталогу с файлом
        - basename    | Имя файла
        - stem        | Имя файла без расширения
        - extname     | Расширение файла без имени

    # NodeJS-модуль minimatch, применение в gulp.src

      - Вводная информация
      - Globe-паттерны
      - Примеры использования
        - Пример №1: считывание лишь файлов указанных расширений
        - Пример №2: считывание файлов из нескольких base-путей
        - Пример №3: последовательное считывание групп файлов
        - Пример №4: игнорирование указанных каталогов/файлов

    # Несколько полезных опций для gulp.src

      - Не читать контент файлов (read: false)
      - Чтение файлов только начиная с указаной даты (since: ...)
      - Создать для каждого файла readable-поток (buffer: false)
      - Явно указать cwd для задачи (cwd: "...")
      - Указать base в явном виде (base: "...")

  --------------------------------------

  > Ссылки

    # Скринкаст по этой главе
        https://www.youtube.com/watch?v=NBdKplKl_3Q

    # Оф.документация по объектам типа vinyl
        https://github.com/gulpjs/vinyl

    # NodeJS-модуль minimatch
        https://www.npmjs.com/package/minimatch

    # Glob-паттерны из unix-систем
        http://wiki.bash-hackers.org/syntax/pattern

  > Введение
    - Эта глава поможет разобраться в основах gulp и Vinyl-FS.

  > Объекты Vinyl и объекты Buffer

    # Основное
      - В ссылках главы есть оная на документацию по объектам Vinyl.
      - В соотв.репозитории лежит NodeJS-модуль под названием vinyl.
      - Его можно подключать к NodeJS-проекту и использовать.
      - Например:

          var File = require('vinyl');

          var coffeeFile = new File({
            cwd: "/",
            base: "/test/",
            path: "/test/file.coffee",
            contents: new Buffer("test = 123")
          });

      - Объекты типа vinyl имеют ряд методов (см.документацию).

    # Объекты Buffer
      - Как видно в примере выше, св-во contents содержит объект Buffer.
      - Это высокоэффективное средство NodeJS для работы с бинарными данными.
      - Технически, это непрерывная область памяти, заполненная этими данными.
      - Подробнее о них см. в методичке по NodeJS.

  > Gulp передаёт объекты Vinyl между плагинами

    # Главное
      - Объекты Vinyl можно назвать виртуальными файлами.
      - В виртуальной файловой системе Vinyl-FS.
      - Именно они и передаются по цепочки между плагинами в gulp.
      - В этом можно убедиться на практике:

          1) Создадим каталог source в корне проекта

            /source
              /1
                1.js
                2.js

          2) В gulpfile добавим код:

            'use strict';

            // 1] Подключить модуль gulp
            const gulp = require('gulp');

            // 2] Создать задачу default
            gulp.task('default', function(){
              return gulp.src('source/**/*.*')    // Создать readable-поток, считывающий данные из dev/*.scss файлов
                .on('data', function(file){       // Назначить readable-потоку обработчик события 'data' (возвращает этот же поток)
                  console.log(file);              // Вывести считанные потоком данные в консоль (объект Vinyl).
                })
                .pipe(gulp.dest('dest'));         // Создать writable-поток, записывающий файлы в css/styles
            });

          3) Запустить задачу default

              npm run gulp default

      - Запустив эту задачу, мы увидим в терминале, что передаётся между плагинами.
      - А именно, что это объекты типа Vinyl.

    # Куда записывает файлы gulp.dest

      ## Если передать строку
        - Метод dest может принять в качестве аргумента строку с путём.
        - Причём этот путь относительный, относительно абсолютного пути
          из св-ва cwd файла.
        - Если там каталога нет, то dest создаёт там новый каталог.
        - И записывает данные для каждого кусочка (Vinyl-файла) в файл:

            [путь из аргумента]/file.relative

        - Где relative, это одно из св-в Vinyl-файла (см.ниже).

      ## Если передать функцию
        - То эта функция должна вернуть строку с путём.
        - Она может вернуть тот или иной путь в зависимости от чего-то.
        - Например, функция может заглядывать в extname файла.
        - И если там '.js', возвращать путь к каталогу с js-файлами.
        - А если там '.css', возвращать путь к каталогу с css-файлами.
        - Пример:

            gulp.dest(function(file){

              // Если js-файл
              if(file.extname == '.js')
                return 'js';

              // Если css-файл
              if(file.extname == '.css')
                return 'css';

              // Если ни то, ни сё, путь по умолчанию
              return 'dest';

            });

  > Важнейший св-ва объекта Vinyl

    # Основное
      - См.список свойств в оглавлении.
      - Здесь будут лишь пояснения к некоторым из них.

    # Постоянные и вычисляемые св-ва
      - У объекта Vinyl есть 2 типа св-в: постоянные и вычисляемые.
      - Какие из них какие, обозначено в оглавлении главы.

    # Наглядная демонстрация св-в объекта Vinyl
      - Выше в пункте "Gulp передаёт объекты Vinyl между плагинами" есть пример.
      - В нём в обработчике события 'data' в терминал выводится объект Vinyl.
      - Но при таком выводе, свойств этого объекта всё равно в терминале не видно.
      - Можно модифицировать содержимое обработчика того примера таким
        образом, чтобы увидеть содержимое важных свойств объекта Vinyl:

          console.log({

            // Постоянные
            contents: file.contents,
            path:     file.path,
            cwd:      file.cwd,
            base:     file.base,        // '/home/vagrant/dev.app/gulptest/source/'

            // Вычисляемые
            relative: file.relative,    // '1/2.js'
            dirname:  file.dirname,     // '/home/vagrant/dev.app/gulptest/source/1'
            basename: file.basename,    // '1.js'
            stem:     file.stem,        // '1'
            extname:  file.extname      // '.js'

          });

    # base и relative
      - В примере выше методу src передан паттерн "source/**/*.*".
      - В этом паттерне есть постоянная часть: "source/".
      - И есть переменная часть: "/**/*.*".
      - Соответственно, путь для постоянной части записывается
        в base передаваемого между плагинами объекта Vinyl. Причём,
        это полностью квалифицированный путь от корня ФС.
      - А путь для переменной части передаваемого файла записывается
        в виде относительного пути относительно постоянной части.

  > NodeJS-модуль minimatch, применение в gulp.src

    # Вводная информация
      - В примерах выше для gulp.src был использован паттерн 'source/**/*.*'.
      - Для его "разбора" gulp внутри себя использует модуль minimatch.
      - Minimatch конвертирует glob-паттерны в JS-овские RegExp.
      - Glob-паттерны используются в unix-системах, типа звёздочки в пути и всё такое.
      - В итоге, в паттерне для gulp.src можно использовать
        те самые glob-паттерны из unix-систем.
      - Подробнее о них здесь: https://en.wikipedia.org/wiki/Glob_(programming)

    # Globe-паттерны

      **                  | Любой путь

      *	                  | Matches any string, including the null string (empty string)
      ?	                  | Matches any single character
      X	                  | Matches the character X which can be any character that has no special meaning
      \X	                | Matches the character X, where the character's special meaning is stripped by the backslash
      \\	                | Matches a backslash
      […]	                | Defines a pattern bracket expression (see below). Matches any of the enclosed characters at this position.

      [XYZ]	              | The "normal" bracket expression, matching either X, Y or Z
      [X-Z]	              | A range expression: Matching all the characters from X to Y (your current locale, defines how the characters are sorted!)
      [[:class:]]	        | Matches all the characters defined by a POSIX® character class: alnum, alpha, ascii, blank, cntrl, digit, graph, lower, print, punct, space, upper, word and xdigit
      [^…]	              | A negating expression: It matches all the characters that are not in the bracket expression
      [!…]	              | Equivalent to [^…]
      []...] or [-…]	    | Used to include the characters ] and - into the set, they need to be the first characters after the opening bracket
      [=C=]	              | Matches any character that is eqivalent to the collation weight of C (current locale!)
      [[.SYMBOL.]]	      | Matches the collating symbol SYMBOL

      ?(<PATTERN-LIST>)	  | Matches zero or one occurrence of the given patterns
      *(<PATTERN-LIST>)	  | Matches zero or more occurrences of the given patterns
      +(<PATTERN-LIST>)	  | Matches one or more occurrences of the given patterns
      @(<PATTERN-LIST>)	  | Matches one of the given patterns
      !(<PATTERN-LIST>)	  | Matches anything except one of the given patterns

    # Примеры использования

      ## Пример №1: считывание лишь файлов указанных расширений
        - Используем globe-паттерны на примере при работе с gulp.src
        - Допустим мы хотим, чтобы он читал лишь .js и .css файлы.
        - Для этого модифицируем один из предыдущих примеров:

            gulp.src('source/**/*.{js,css}')

      ## Пример №2: считывание файлов из нескольких base-путей
        - Используем globe-паттерны на примере при работе с gulp.src
        - Допустим, надо брать файлы не из одного, но нескольких каталогов.
        - Скажем, из каталогов source1 и source2.
        - Модифицируем пример выше, чтобы добиться этого:

            gulp.src('{source1,source2}/**/*.{js,css}')

      ## Пример №3: последовательное считывание групп файлов
        - Вообще, gulp.src ещё позволяет указывать и массив.
        - Например:

            gulp.src(['{source1,source2}/**/*.js', '{source1,source2}/**/*.css'])

        - В примере выше JS-файлы будут обработаны первыми.
        - А уже после них будут обработаны CSS-файлы.

      ## Пример №4: игнорирование указанных каталогов/файлов
        - Часто надо явно указать, чтобы src игнорировал указанные каталоги/файлы.
        - Например, чаще всего потребуется игнорировать каталог node_modules.

        ### Как делать НЕ надо
          - Вот так

            gulp.src(['**/*.*', '!node_modules/**'])

          - Gulp будет просматривать ВСЕ файлы в base path.
          - Включая те, которые лежать в node_modules.
          - И проверять их пути, если они не в "node_modules/**", считывать.
          - Но т.к. node_modules м.б. очень большим, получается медленно.

        ### Как лучше делать
          - Лучше не использовать паттернт отрицания вообще.
          - А вместо этого явно указывать, что нам нужно.
          - Это в разы, десятки раз увеличит скорость работы:

            gulp.src(['{css,js,source}/**/*.*', 'gulpfile.js', 'package.json'])


  > Несколько полезных опций для gulp.src

    # Не читать контент файлов (read: false)
      - Допустим, нам надо удалить некие видео-файлы.
      - Они очень тяжёлые, и читать их в память не хотелось бы.
      - Да и для их удаления это нам нен ужно.
      - Тогда, можно применить опцию read: false.
      - Пример:

        gulp.src(['movies/**/*.mp4'], {read: false})

      - В итоге, в contents vinyl-файлов в потоке будет null/

    # Чтение файлов только начиная с указаной даты (since: ...)
      - since: new Date(...)

    # Создать для каждого файла readable-поток (buffer: false)
      - Обычно gulp.src в contents каждого vinyl-файла в потоке
        кладёт объект Buffer с бинарными данными.
      - Но если применить buffer: false, то в contents будут
        лежать readable-потоки.
      - Эта возможность используется очень редко, т.к. большинство
        плагинов предполагают, что vinyl-файл уже считан полностью,
        и они могут работать с его содержимым.

    # Явно указать cwd для задачи (cwd: "...")
      - По умолчанию, cwd это каталог самого процесса gulp.
      - То есть, это тот каталог, где лежит gulpfile.js.
      - Но для каждой задачи можно явно указать cwd с помощью опции.

    # Указать base в явном виде (base: "...")
      - По умолчанию base вычисляется из 1-го аргумента в src.
      - Но можно указать его и в явном виде.

          gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})


А4. Делаем систему для сборки стилей на gulp

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Исходные условия

    # [gulp-sass] *.sass ---> *.css
    # [gulp-concat] *.sass ---> *.css ---> all.css
    # [gulp-debug] Выводить инфу о действиях gulp в терминал
    # [@import] Применение @import в sass
    # [gulp-sourcemaps] Формировать sourcemaps
    # [gulp-if] Задавать if-условия при pipe-инге
    # [gulp-ignore] Исключать файлы по условию при pipe-инге

    # [gulp.series] Последовательное выполнение gulp-задач
    # [gulp.parallel] Параллельное выполнение gulp-задач

    # [gulp.watch] Автоматическая пересборка при изменениях

  --------------------------------------

  > Ссылки

    # Скринкасты Ильи по теме
        https://www.youtube.com/watch?v=_BFWG82mMkw
        https://www.youtube.com/watch?v=jocvHauHcA4

    # Плагин gulp-watch-network (для обхода проблемы с vagrant и gulp.watch)
        https://github.com/efacilitation/watch-network

  > Введение
    - В этой главе мы рассмотрим создание системы сборки стилей на gulp.
    - Для стилей будем использовать препроцессор SASS.
    - Будем в процессе рассматривать различные важные плагины.
    - В конце концов, это будет готовое для продакшн решение.

  > Исходные условия

    /project
      /public
      /frontend
        /assets
          /img
          index.html
        /styles
          header.scss
          main.scss

  > [gulp-sass] *.sass ---> *.css

    # Формулировка
      - Надо найти все ".scss" стили в каталоге "/project/frontend/styles/"
      - Преобразовать их в ".css"
      - И сохранить в каталог "/project/public/"

    # Описание решения
      - Для преобразования scss->css применим плагин gulp-sass.
      - Для этого его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-sass

      - Для поиска .scss применяем glob-паттерн 'frontend/styles/**/*.scss'.
      - Результаты записываем в каталог public.

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/**/*.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

    # А что, если нам надо положить все стили в конкретный каталог внутри public

      ## Вариант №1
        - Можно явно указать base для gulp.src.
        - Пример:

            gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})

      ## Вариант №2
        - Можно изменить base в glob-паттерн.
        - На вот такой:

            gulp.src('frontend/**/*.scss')

        - В итоге base == 'frontend'.
        - И т.к. .scss лежат в каталоге frontend/styles,
          то они будут скопированы в frontend/styles.

  > [gulp-concat] *.sass ---> *.css ---> all.css

    # Формулировка
      - Надо сделать тоже самое, что в задаче №1.
      - Плюс объединить весь css в 1 файл "all.css".

    # Описание решения
      - Для объединения css-файлов нам понадобится плагин gulp-concat.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-concat

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const concat = require('gulp-concat');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})
              .pipe(sass())
              .pipe(concat('all.css'))
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp-debug] Выводить инфу о действиях gulp в терминал

    # Формулировка
      - По умолчанию gulp не выводит в терминал, что он делает.
      - Иногда такая информация требуется.
      - Задача: выводить в терминал, что делаег gulp.

    # Описание решения
      - Для этого нам понадобится плагин gulp-debug.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-debug

      - В итоге, получим вывод типа:

          [03:31:46] src frontend/styles/header.scss
          [03:31:46] src frontend/styles/main.scss
          [03:31:46] src 2 items
          [03:31:46] sass frontend/styles/header.css
          [03:31:46] sass frontend/styles/main.css
          [03:31:46] sass 2 items
          [03:31:46] concat frontend/all.css
          [03:31:46] concat 1 item

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const concat = require('gulp-concat');
        const debug = require('gulp-debug');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/**/*.scss', {base: 'frontend'})
              .pipe(debug({title: 'src'}))
              .pipe(sass())
              .pipe(debug({title: 'sass'}))
              .pipe(concat('all.css'))
              .pipe(debug({title: 'concat'}))
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [@import] Применение @import в sass

    # Формулировка
      - Допустим, у нас имеются 2 .scss файла: "main" и "header".
      - И мы хотим их объединить в один файл main.css.
      - Причём, чтобы сначала шёл "header", а потом "main".
      - Аналогичным образом можно объединять сколько угодно файлов.

    # Описание решения
      - Для этого нам надо в начале "main" добавить строку:

          @import "header.scss";

      - И после этого можно уже работать с main.
      - При его обработке gulp'ом файл "header" будет подтянут и обработан.

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp-sourcemaps] Формировать sourcemaps

    # Что такое sourcemaps
      - Это специальная структура данных, актуальная при их преобразовании.
      - В ней содержатся данные о том, что было, и что стало, и где всё это.
      - Эта структура данных может быть:

        1) В конце самого модифицированного файла
        2) В отдельном файле, а в сам мод-ый файл дописывается лишь путь.

      - По sourcemap браузер находит исходники для преобразованного файла.
      - И при отладке, если возникают ошибки, указывает на ошибку в исходнике.
      - Таким образом, sourcemaps незаменимый инструмент при разработке.

    # Формулировка
      - Необходимо обеспечить наличие sourcemaps при работе gulp.

    # Описание решения
      - Для этого нам понадобится плагин gulp-sourcemaps.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-sourcemaps

      - Плагин "gulp-sourcemaps" один из основных, и написан разработчиками gulp.
      - Интегрирован чуть менее, чем со всеми инструментами, меняющими содержимое файлов.
      - Что он делает:

        1) Перед изменением файла мы пропускаем его через sourcemaps.init()
          - Когда в него поступает новый vinyl-файл, плагин создаёт у него
            новое пустое свойство sourceMap (пустое, т.к. с файлом ещё ничего не делали).

        2) Каждый инструмент дописывает в sourceMap файла информацию
          - Как упоминалось выше, почти все инструменты поддерживают работу с sourceMap.
          - Если инструмент видит, что у файла есть это св-во, он дописывает туда инфу.

        3) Когда все изменения файла завершены, применяем sourcemaps.write()
          - К этому моменту св-во sourceMap содержит всю необходимую инфу.
          - Теперь его надо записать:

            3.1) В итоговый файл
              - Тогда надо применить write() без агрументов.

            3.2) В файл по указанному адресу
              - Например, в файл по соседству, с .map на конце.
              - Тогда надо применить write('.').

    # Код решения

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const sourcemaps = require('gulp-sourcemaps');

        // 2] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 2.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sourcemaps.init())
              .pipe(sass())
              .pipe(sourcemaps.write())
              .pipe(gulp.dest('public'));

          // 2.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp-if] Задавать if-условия при pipe-инге

    # Что делает gulp-if
      - Позволяет задавать if-условия при pipe-инге.
      - Это намного удобнее, чем делать это традиционным путём через if() {}
      - Принимает 3 аргумента:

        1) Условие (true/false или callback)
        2) Если условие true (типа if)
        3) Если условие false (типа else)

    # Установка
      - Нам понадобится плагин gulp-if.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-if

    # Пример №1: true/false условие
      - Допустим, надо применять sourcemaps, только если x == true.

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const sourcemaps = require('gulp-sourcemaps');
        const gulpif = require('gulp-if');

        // 2] Задать условия
        var x = true;

        // 3] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 3.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(gulpif(x, sourcemaps.init()))
              .pipe(sass())
              .pipe(sourcemaps.write())
              .pipe(gulpif(x, gulp.dest('public')));

          // 3.2] Сигнализировать о завершении задачи
          callback();

        });

    # Пример №2: callback-условие
      - Допустим, надо применять sass() только если расширение
        файла равно ".scss".

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const gulpif = require('gulp-if');

        // 2] Задать условия
        var x = true;

        // 3] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 3.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(gulpif(function(file){
                return file.extname == ".scss";
              }, sass()))
              .pipe(gulp.dest('public'));

          // 3.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp-ignore] Исключать файлы по условию при pipe-инге

    # Что делает gulp-if
      - Позволяет фильтровать файлы в зависимости от условия.
      - Это намного удобнее, чем делать это традиционным путём через if() {}
      - Имеет 2 метода:

        include(condition)    // включить файл, если condition == true
        exclude(condition)    // исключить файл, если condition == true

    # Установка
      - Нам понадобится плагин gulp-if.
      - Его надо установить в проект
        (и записать в devDependencies в package.json):

          npm i -D gulp-ignore

    # Пример
      - Допустим, надо применять sass() только если расширение
        файла равно ".scss".
      - В противном случае, исключить vinyl-файл из потока.

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const ignore = require('gulp-ignore');

        // 2] Задать условия
        var x = true;

        // 3] Найти в указаном каталоге все *.scss файлы
        // - И сохранить их в public проекта
        gulp.task('styles', function(callback){

          // 3.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(ignore.exclude(function(file){
                return file.extname != ".scss";
              }))
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 3.2] Сигнализировать о завершении задачи
          callback();

        });

  > [gulp.series] Последовательное выполнение gulp-задач
    - Позволяет последовательно выполнить несколько gulp-задач.
    - Пример:

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const del = require('del');

        // 2] Задать условия
        var x = true;

        // 3] Задача №1: Обработка scss-файлов
        gulp.task('styles', function(callback){

          // 3.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 3.2] Сигнализировать о завершении задачи
          callback();

        });

        // 4] Задача №2: удаление каталога public
        gulp.task('clean', function(){
          return del('public');
        });

        // 5] Задача №3: сначала выполняет 'clean', а потом 'styles'
        gulp.task('build', gulp.series('clean', 'styles'));

  > [gulp.parallel] Параллельное выполнение gulp-задач
    - Позволяет параллельно выполнить несколько gulp-задач.
    - Пример:

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const del = require('del');

        // 2] Задать условия
        var x = true;

        // 3] Задача №1: Обработка scss-файлов
        gulp.task('styles', function(callback){

          // 3.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 3.2] Сигнализировать о завершении задачи
          callback();

        });

        // 4] Задача №2: удаление каталога public
        gulp.task('clean', function(){
          return del('public');
        });

        // 5] Задача №3: копирует всё из assets в public
        gulp.task('assets', function(){
          return gulp.src('frontend/assets/**')
              .pipe(gulp.dest('public'));
        });

        // 6] Задача №4:
        // - Сначала выполняет задачу 'clean'.
        // - А затем, параллельно, задачи styles и assets
        gulp.task('build', gulp.series(
          'clean',
          gulp.parallel('styles', 'assets')
        ));

  > [gulp.watch] Автоматическая пересборка при изменениях

    # Внимание! Проблемы при работе через виртуальные машины

      ## Описание проблемы
        - При работе через виртуальную машину будут проблемы.
        - Допустим, watch запущен на гостевой машине.
        - А мы в редакторе изменяем отслеживаемые файла на машине-хозяине.
        - В этом случае watch никак не среагирует на изменение файла.
        - А если изменить файл на гостевой машине, то среагирует.
        - То есть, проблема из-за работы через виртуальную машину.
        - Гостевая ОС не получает события изменения файлов, если
          файлы меняются на ОС-хозяине.

      ## Решение
        - За сценой, gulp.watch использует плагин chokidar.
        - У последнего в конфиге есть св-во usePolling == false по умолчанию.
        - Чтобы решить проблему, надо сделать usePolling == true.
        - Для этого надо иметь возможность установить из watch это
          свойство для chokidar.
        - gulp.watch этого не позволяет, поэтому нам понадобится отдельно
          установить плагин gulp-watch.
        - Он принимает 2 или 3 параметра:

            watch(glob, callback);
            watch(glob, config, callback);

        - Вот что они означают:

            ### glob
              - Это относительный путь к файлу.
              - Он может быть и glob-паттерном.

            ### config
              - Это объект-конфиг для chokidar.
              - Все св-ва можно глянуть здесь: https://github.com/paulmillr/chokidar

            ### callback
              - Это может быть анонимная функция.
              - А может быть gulp.series или gulp.parallel

        - Решение в том, чтобы в config передавать usePolling == true.
        - Пример:

            watch('frontend/styles/**/*.*', {usePolling: true}, gulp.series('styles'));

    # Суть
      - Ищё эту тему называют "инкрементальной сборкой".
      - Метод watch запускает демон, который следит за указанными фай-ми.
      - Файлы можно указать с помощью glob-паттерна в 1-м аргументе.
      - Любые изменения в этих кат-ах являются триггером.
      - Во 2-м аргументе можно передать gulp.series(...) / gulp.parallel(...)
      - Причём, просто имя задачи указать нельзя. Надо обернуть в series/parallel.

    # Пояснение к примеру
      - Допустим, мы хотим следить за всеми файлами в frontend/styles.
      - И за всеми файлами в frontend/assets.
      - Тогда применяем glob-паттерны: 'frontend/styles/**/*.*'
        и 'frontend/assets/**/*.*'
      - И хотим, чтобы при их изменении, запускалась задача build.
      - Тогда надо добавить в gulpfile вот такие строки:

          gulp.watch('frontend/styles/**/*.*', gulp.series('styles'));
          gulp.watch('frontend/assets/**/*.*', gulp.series('assets'));

    # Примечание по поводу отслеживания стилей
      - В gulp-sass есть внутренний кэш.
      - Поэтому, при изменении в исходники пересобирается не всё.
      - А данные берутся из кэша, и лишь вносится малое изменени.
      - Поэтому, операция проходит очень быстро.

    # Примечение по поводу отслеживания assets
      - Вот тут как раз при любом изменении public перезаписывается.
      - А этом долго, поэтому надо указать gulp'у, чтобы он перезаписывал
        только те файлы, которые изменились с момента его прошлого
        срабатывания.
      - Для этого в gulp.src задаётся параметр:
          {since: gulp.lastRun('assets')}

    # Пример (актуален при локальной разработке)
      - Код примера

          'use strict';

          // 1] Подключить модули
          const gulp = require('gulp');
          const sass = require('gulp-sass');
          const del = require('del');

          // 2] Задача №1: Обработка scss-файлов
          gulp.task('styles', function(callback){

            // 3.1] Найти и обработать .scss файлы, записать в public
            return gulp.src('frontend/styles/main.scss')
                .pipe(sass())
                .pipe(gulp.dest('public'));

            // 3.2] Сигнализировать о завершении задачи
            //callback();

          });


          // 3] Задача №2: удаление каталога public
          gulp.task('clean', function(){
            return del('public');
          });

          // 4] Задача №3: копирует всё из assets в public
          gulp.task('assets', function(){
            return gulp.src('frontend/assets/**', {since: gulp.lastRun('assets')})
                .pipe(gulp.dest('public'));
          });

          // 5] Задача №4:
          // - Сначала выполняет задачу 'clean'.
          // - А затем, параллельно, задачи styles и assets
          gulp.task('build', gulp.series(
            'clean',
            gulp.parallel('styles', 'assets')
          ));

          // 6] Задача №5: следить за файлами, запускать задачу при их изменении
          gulp.task('watch', function(){
            gulp.watch('frontend/styles/**/*.*', gulp.series('styles'));
            gulp.watch('frontend/assets/**/*.*', gulp.series('assets'));
          });

          // 7] Задача №6: сначала запустить build, затем watch
          gulp.task('dev', gulp.series('build', 'watch'));

      - Теперь надо запустить задачу build.
      - Для этого выполнить:

          npm run gulp build

      - В терминале будет запущен демон, отслеживающий изменения.
      - Для теста, можно внести изменения в какой-либо исходник.
      - И в терминале увидеть, что watch обнаружил изменения,
        и пересобрал всё.

    # Пример (актуален при разработке через виртуальные ОС)

        'use strict';

        // 1] Подключить модули
        const gulp = require('gulp');
        const sass = require('gulp-sass');
        const del = require('del');
        const watch = require('gulp-watch');

        // 2] Задача №1: Обработка scss-файлов
        gulp.task('styles', function(callback){

          // 3.1] Найти и обработать .scss файлы, записать в public
          gulp.src('frontend/styles/main.scss')
              .pipe(sass())
              .pipe(gulp.dest('public'));

          // 3.2] Сигнализировать о завершении задачи
          callback();

        });


        // 3] Задача №2: удаление каталога public
        gulp.task('clean', function(){
          return del('public');
        });

        // 4] Задача №3: копирует всё из assets в public
        gulp.task('assets', function(){
          return gulp.src('frontend/assets/**', {since: gulp.lastRun('assets')})
              .pipe(gulp.dest('public'));
        });

        // 5] Задача №4:
        // - Сначала выполняет задачу 'clean'.
        // - А затем, параллельно, задачи styles и assets
        gulp.task('build', gulp.series(
          'clean',
          gulp.parallel('styles', 'assets')
        ));

        // 6] Задача №5: следить за файлами, запускать задачу при их изменении
        gulp.task('watch', function(){
          watch('frontend/styles/**/*.*', {usePolling: true}, gulp.series('styles'));
          watch('frontend/assets/**/*.*', {usePolling: true}, gulp.series('assets'));
        });

        // 7] Задача №6: сначала запустить build, затем watch
        gulp.task('dev', gulp.series('build', 'watch'));


А5. Увеличение производительности при работе с файлами

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Опция "since" для gulp.src
    # Плагин "gulp-newer"
    # Плагин "gulp-remember", и: "gulp-cached", "gulp-autoprefixer"
    # Плагин "gulp-cache"

  --------------------------------------

  > Ссылки

    # Скринкаст Ильи по теме
        https://www.youtube.com/watch?v=uYZPNrT-e-8

    # Плагин "gulp-newer"
        https://www.npmjs.com/package/gulp-newer

    # Плагин "gulp-remember"
        https://www.npmjs.com/package/gulp-remember

    # Плагин "gulp-cache"
        https://www.npmjs.com/package/gulp-cache

  > Введение
    - При работе с файлами в gulp часто важна производительность.
    - В этой главе рассмотрены способы её увеличения.

  > Опция "since" для gulp.src
    - Актуально при использовании gulp.watch.
    - При 1-м запуске задачи НЕ срабатывает.
    - А срабатывает, начиная со 2-го и далее запуска задачи,
      осуществляемых watch-демоном.
    - Действует как фильтр, не пропуская файлы, дата последней
      модификации которых не изменилась с прошлого срабатывания watch.
    - Простой пример:

        'use strict';

        const gulp = require('gulp');
        gulp.task('assets', function(){
          return gulp.src('frontend/assets/**', {since: gulp.lastRun('assets')})
              .pipe(gulp.dest('public'));
        });
        gulp.watch('./frontend/assets/**/*.*', gulp.series('assets'));

  > Плагин "gulp-newer"
    - В отличии от решения с "since", срабатывает и при 1-м запуске.
    - Newer работает принципиально по другому, он сличает даты модификации
      исходного файла, и файла в месте назначения.
    - Это решение актуально для не инкрементальной сборки (через watch),
      а для обычной сборки, когда мы просто запускаем gulp-задачи.
    - Т.О. у "since" и "gulp-newer" разные области применения.
    - Простой пример:

        'use strict';

        const gulp = require('gulp');
        const newer = require('gulp-newer');
        gulp.task('assets', function(){
          return gulp.src('frontend/assets/**')
              .pipe(newer('public'))
              .pipe(gulp.dest('public'));
        });

    - Возможно также настроить более интеллектуальное сравнивание.
    - Например, чтобы в public искался файл с другим расширением.
    - Про это см.документацию плагина, ссылку см.в ссылках главы.

  > Плагин "gulp-remember", и: "gulp-cached", "gulp-autoprefixer"

    # Про плагин "gulp-autoprefixer"
      - Автоматически расставляет префиксы в css.

    # Про плагин "gulp-remember"

      ## Основное
        - Этот плагин кэширует все файлы, которые через него проходят.
        - Кэширование производится при 1-м запуске задачи.
        - В результате кэширования получается набор файлов.
        - При 2-м, 3-м ... n-м запуске задачи плагин сверяет набор
          поступивших на вход файлов, и закэшированных.
        - Если какие-то файлы есть в кэше, но нет на входе, то плагин
          эти недостающие файлы из кэша пускает дальше по трубе.
        - Таким образом решается проблема с конкатенацией, т.к.
          при конкатенации плагин gulp-concat должен получить
          не только изменённые файлы, но все.

      ## При удалении файла надо вручную удалять кэш о нём из remember
        - Для этого надо отлавливать на watcher'е событие unlink.
        - Это событие возбуждается chokidar'ом при удалении файла.
        - В событие будет передан аргумент с относительным путём к файлу.
        - Получить абсолютный путь по относительному можно с помощью плагина path.
        - И дальше с помощью метода remember.forget мы удаляем из

    # Про плагин "gulp-cached"

      ## Основное
        - Этим плагином можно заменить опцию "since".
        - Её проблема в том, что она фильтрует ф-лы по дате посл.модификации.
        - Если удалить файл в редакторе, а потом вернуть, нажав ctrl + z,
          то возвращённый файл не получит свежую дату модификации,
          и "since" его отфильтрует.
        - Чтобы с этим справиться, можно заменить "since" на плагин cached.
        - Cached отфильтровывает файлы по их содержимому.
        - Он не пропускает дальше файлы, у которых точно такое же содержимое.
        - Работает медленнее, чем "since", зато решает проблему.

      ## При удалении файла надо вручную удалять кэш о нём из cached
        - Для этого надо отлавливать на watcher'е событие unlink.
        - Это событие возбуждается chokidar'ом при удалении файла.
        - В событие будет передан аргумент с относительным путём к файлу.
        - Получить абсолютный путь по относительному можно с помощью плагина path.

    # Пример

      const gulp          = require('gulp');
      const debug         = require('gulp-debug');
      const concat        = require('gulp-concat');
      const autoprefixer  = require('gulp-autoprefixer');
      const remember      = require('gulp-remember');
      const cached        = require('gulp-cached');
      const path          = require('path');

      gulp.task('styles', function(){

        return gulp.src('frontend/styles/**/*.css')
            .pipe(cached('styles'))
            .pipe(autoprefixer())
            .pipe(remember('styles'))
            .pipe(concat('all.css'))
            .pipe(gulp.dest('public'))

      });

      gulp.task('watch', function(){

        gulp.watch('frontend/styles/**/*.css', gulp.series('styles')).on('unlink', function(filepath){
          remember.forget('styles', path.resolve(filepath));
          delete.cached.caches.styles[path.resolve(filepath)];
        });

      });

  > Плагин "gulp-cache"
    - Когда видит файл 1-й раз, запоминает его в кэше.
    - Ключ формируется по содержимому и другим параметрам.
    - А когда видит тот же файл снова, восстанавливает резульат обработки.


А6. Автоперезагрузка браузера: вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Принципы работы автоперезагрузки

      - Сервер + клиент
      - Серверная часть
      - Клиентская часть + браузерные расширения
      - Иллюстрация

    # Дополнительные преимущества от browser-sync

      - Шлёт действия браузера на сервер
      - Десктоп + планшет + смартфон = одновременная отладка
      - Иллюстрация

  --------------------------------------

  > Ссылки

    Livereload
    ----------

      # NodeJS-приложение, реализующее livereload-сервер
          https://www.npmjs.com/package/tiny-lr

      # Браузерные расширения для авто.вставки клиентского JS во все документы
          http://livereload.com/extensions/

    Browser-sync
    ------------

      # NodeJS-приложение, реализующее browser sync
          https://www.npmjs.com/package/browser-sync

      # Оф.сайт browser-sync
          https://www.browsersync.io/

  > Введение
    - Эта глава про эффективную и удобную организацию вёртски.
    - А именно, про автоперезагрузку браузера при изменении файлов.
    - Причём, можно гибка настраивать, какие файлы будут ослеживаться.
    - Например, можно отслеживать все файлы опред.расширений в проекте.
    - Самые известные инструменты: livereload и browser-sync

  > Принципы работы автоперезагрузки

    # Сервер + клиент
      - Все инструменты автоперезагрузки имеют общие принципы работы.
      - Они состоят из 2-ух частей, сервера и клиента.

    # Серверная часть
      - Представляет из себя простейший HTTP-сервер на NodeJS.
      - Который имеет простейший REST-API.
      - А также, включает демона, который отслеживает изменения
        в указанных каталогах и файлах.
      - Сервер устанавливает соединение с клиентом по websocket.
      - B при изменениях, сообщает ему информацию о них.

    # Клиентская часть + браузерные расширения
      - Состоит из JS-скрипта.
      - Этот скрипт должен присутствовать во всех документах.
      - Он устанавливает websocket-соединение с серверной частью.
      - Получает от сервера сигналы об изменениях, и реализует
        эти изменения в документе (ну или сам перезагружает его).
      - Вставлять его везде вручную не обязательно, для этого есть
        много браузерных расширений (см.ссылку в ссылках главы).

    # Иллюстрация

      |---------------------|
      |  /project           | Демон сервера отслеживает
      |    /frontend        | любые изменения в выбранных
      |      /styles        | каталогах и файлах
      |        index.scss   |-------------------------->|
      |        header.scss  |                           |
      |      /assets        |                           |
      |        img.jpg      |                           |
      |    index.php        |                           |
      |--------|------------|                           |
              /|\                                       |
               | Клиентский скрипт, получив             |
               | инфу об изменениях, изменяет           |
               | или перезагружает документ            \|/
               |                                        |
         |-------------------|                 |-------------------|
         |  Клиентская часть |     websocket   |  Серверная часть  |
         |  client.js        |<----------------|  tiny-lr          |
         |-------------------|                 |-------------------|

                              Сервер передаёт инфу
                              об изменениях клиенту
                              через websocket

  > Дополнительные преимущества от browser-sync

    # Шлёт действия браузера на сервер
      - Browser-sync не только присылает браузеру от сервера
        данные об изменениях в отслеживаемых каталогах/файлах.
      - Но и отправляет серверу информацию об изменениях в браузере.
      - А сервер, в свою очередь, пересылает эту инфу всем другим
        браузерам, на всех устройствах, в которых открыт этот документ.
      - Это может сильно упростить отладку на нескольких платформах
        одновременно.

    # Десктоп + планшет + смартфон = одновременная отладка
      - Открываешь документ одновременно на этих 3-ёх устройствах.
      - Кладёшь их так, чтобы их было видно одновременно.
      - И начинаешь отлаживать документ в браузере на десктопе.
      - И наблюдаешь всё одновременно на планшете и телефоне.

    # Иллюстрация

                        |--------------|
                        | browser-sync |
                        |--------------|
                           /|\     \|/
                   -------------------------
                  /|\                     \|/
            |--------------|        |--------------|
            |    chrome    |        |    safari    |
            |--------------|        |--------------|



А7. Автоперезагрузка браузера: browser-sync

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка browser-sync
    # Проброс портов 3000 и 3001

  --------------------------------------

  > Ссылки

    # NodeJS-приложение, реализующее browser sync
        https://www.npmjs.com/package/browser-sync

    # Оф.сайт browser-sync
        https://www.browsersync.io/

    # Оф.документация browser-sync
        https://www.browsersync.io/docs/

  > Введение
    - Эта глава подробно раскрывает тему работы с browser-sync.
    - И предоставляет подробный справочник по нему.

  > Установка browser-sync
    - Browser-sync является CLI-приложением.
    - Поэтому, его удобнее всего установить глобально:

        npm install -g browser-sync

    - Но при работе с Docker удобнее устанавливать локально:

        npm install -D browser-sync

  > Проброс портов 3000 и 3001
    
    • Введение в проблему
      - Допустим, имеется следующая ситуация:

        ▪ Хост на windows
        ▪ Гест-вм на linux
        ▪ Docker на гесте
        ▪ Node.js в docker-контейнере на гесте

      - У BS есть встроенный мини-вебсервер.
      - Он может использоваться, как:

        ▪ Прокси для нашего основного.
        ▪ Как самостоятельный сервер, обслуживающий указанную папку.

      - Этот веб-сервер по умолчанию работает на портах 3000 и 3001.
      - Мы к нему подключаемся по адресу: localhost:3000.
      - И любые изменения в отслеж.файлах посылают сообщ.серверу через websocket.
      - И сервер перезагружает документ.

    • Решение

      ▪ Часть 1
        - Пробросить порты 3000 и 3001 в docker-compose.yaml.
        - Для сервиса nginx.
        - После этого надо перезапустить проект.

      ▪ Часть 2
        - Пробросить порты 3000 и 3001 для виртуальной машины.
        - Это можно сделать в её VagrantFile.
        - После этого надо перезагрузить ВМ.











А8. Обработка ошибок

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    #

  --------------------------------------

  > Ссылки


  > Введение
    - Эта глава про эффективную работу с ошибками в gulp.




   




