////=================================================////
////                                                 ////
////                    Ionic 4.*                    ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  # Ionic

    • Сайт
      
        https://ionicframework.com

    • Документация

      ▪ Официальные доки (пока что v3.*)

        https://ionicframework.com/docs

      ▪ Доки для beta v4

        https://beta.ionicframework.com/docs/

    • Ionic Changelog (что изменилось в новой версии)

      https://github.com/ionic-team/ionic/blob/master/CHANGELOG.md

    • Репозиторий и документация для Ionic 4.*

      ▪ Ionic Core 4.0.0
          https://github.com/ionic-team/ionic/blob/master/core/README.md

      ▪ Ionic 4.* Docs
          https://github.com/ionic-team/ionic-docs

    • Маркет (плагины, темы, стартовые приложения)
    
        https://market.ionicframework.com

    • Магазин аксесуаров (футболки, наклейки и прочее)

        https://shop.ionicframework.com

    • Прогресс разработки ionic 4.*

        https://github.com/ionic-team/ionic/milestones

    • Форум и чат

        https://forum.ionicframework.com/
        http://ionicworldwide.herokuapp.com/

    • Twitter

      https://twitter.com/Ionicframework

    • Статьи про использование Ionic 4 + Vue

      ▪ Ionic 4 + Capacitor tutorials list #1
          https://ionictheme.com/ionic4-capacitor-tutorials-list-1/

      ▪ [02.06.2018] Building Mobile Apps With Capacitor And Vue.js
          https://www.smashingmagazine.com/2018/07/mobile-apps-capacitor-vue-js/

      ▪ [28.05.2018] Using the Capacitor in Vue.js app
          http://akhromieiev.com/tutorials/using-capacitor-in-vue-js-app/

      ▪ [15.02.2018]Ionic 4 Tutorial with Vue
          https://www.techiediaries.com/ionic-vue/

      ▪ [16.01.2018]Using Ionic 4 Components in Your Vue.js Apps
          https://alligator.io/vuejs/vue-ionic/

    • Демо-приложения на capacitor + vue + ionic 4

      ▪ A Mobile Demo App with Vue, Capacitor and Ionic 4 Components
          https://github.com/techiediaries/vue-capacitor-ionic-app

    • Блог

        https://blog.ionicframework.com/

    • Интересные посты в блоге

      ▪ [24.07.2018] Announcing the Ionic 4 Beta
          https://blog.ionicframework.com/announcing-ionic-4-beta/

      ▪ [23.07.2018] Announcing Ionic Identity Vault: Secure Biometric Authentication for Your Mobile App
          https://blog.ionicframework.com/announcing-ionic-identity-vault-secure-biometric-authentication-for-your-mobile-app/

      ▪ [22.06.2018] Using TestFlight for User Testing with Ionic
          https://blog.ionicframework.com/using-testflight-for-user-testing-with-ionic/

      ▪ [21.05.2018] Announcing Ionicons v4!
          https://blog.ionicframework.com/announcing-ionicons-v4/

      ▪ [18.04.2018] Ionic Semantic Versioning, Release Schedule and LTS
          https://blog.ionicframework.com/ionic-semantic-versioning-release-schedule-and-lts/

      ▪ [16.04.2018] Introducing A New Guide to Progressive Web Apps
          https://blog.ionicframework.com/introducing-a-new-guide-to-progressive-web-apps/

      ▪ [05.04.2018] Ionic at VueConf
          https://blog.ionicframework.com/ionic-at-vueconf/

      ▪ [20.03.2018] Using Ionic Deploy to Beta Test New Features
          https://blog.ionicframework.com/using-ionic-deploy-to-beta-test-new-features/

      ▪ [15.03.2018] Improved Perceived Performance with Skeleton Screens
          https://blog.ionicframework.com/improved-perceived-performance-with-skeleton-screens/

      ▪ [27.02.2018] Announcing Capacitor 1.0.0 Alpha
          https://blog.ionicframework.com/announcing-capacitor-1-0-0-alpha/

      ▪ [12.02.2018] Customizing Ionic Apps for Web & Mobile
          https://blog.ionicframework.com/customizing-ionic-apps-for-web-mobile/

      ▪ [16.01.2018] Announcing the Ionic PWA Toolkit Beta
          https://blog.ionicframework.com/announcing-the-ionic-pwa-toolkit-beta/

      ▪ [31.10.2017] Announcing Ionic DevApp
          https://blog.ionicframework.com/announcing-ionic-devapp/

      ▪ [25.10.2017] Ionic: 2017-18 Roadmap
          https://blog.ionicframework.com/ionic-2017-18-roadmap/

      ▪ [04.10.2017] WKWebView for All: A new webview for Ionic
          https://blog.ionicframework.com/wkwebview-for-all-a-new-webview-for-ionic/

      ▪ [18.09.2017] The end of Framework Churn
          https://blog.ionicframework.com/the-end-of-framework-churn/

  # Распределение версий на Android
  
    https://developer.android.com/about/dashboards/        


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Ionic 4.*

    А1. Как пользоваться документацией Ionic 4.*
    А2. Введение в Ionic
    А3. Установка Ionic
    А4. Процесс разработки Ionic-приложения
    А5. Компоненты Ionic'а
    А6. Организация layout'а в Ionic-приложении
    А7. Тематизация 
    А8. Публикация Ionic-приложения
    А9. FAQ
    А10. Ionic API (справочник)
    А11. Ionic CLI (справочник)
    А12. Ionic Native (справочник)

  # X.  Практика и наработки

    X1. 


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Как пользоваться документацией Ionic 4.*
--------------------------------------
Подоглавление:

  # Ссылки
  # Как обстоят дела с документацией на конец июля 2017
  # Как пользоваться документацией, пока она не опубликована
  
--------------------------------------

> Ссылки

  • Официальная документация Ionic 4.*
      https://github.com/ionic-team/ionic-docs

  • Ionic v4 component preview app
      https://github.com/ionic-team/component-preview

> Как обстоят дела с документацией на конец июля 2017

  Ionic v4 официально ещё не вышел.
  Документация официально нигде не опубликована.
  Текущея её версия лежит на github.

> Как пользоваться документацией, пока она не опубликована

  1. Сначала устанавливаем NodeJS и NPM, если ещё нет

    curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -
    sudo apt-get install -y nodejs
    npm i npm@latest -g
    npm update npm -g

  2. Открываем свой рабочий linux-дистрибутив
  3. Создаём папку ionic в корне и переходим в неё.
  4. Клонируем репозиторий с доками в неё:

    git clone https://github.com/ionic-team/ionic-docs.git docs  

  5. Переходим в docs, и устанавливаем все npm-зависимости

    cd docs
    npm install

  6. Устанавливаем Ionic v4 component preview app

    Это приложение, которое используется в документации
    для демонстрации компонентов Ionica вживую, так сказать.

    Его нужно отдельно склонировать в папку 
    /ionic/component-preview-app

      cd /ionic
      git clone https://github.com/ionic-team/component-preview.git component-preview-app

    Дальше идём в склонированное приложение,
    устанавливаем зависимости и собираем его:

      cd /ionic/component-preview-app
      npm install
      npm run build

    Дальше копируем папку /ionic/component-preview-app/docs-www
    в /ionic/docs/src/content/component-preview-app/

    Если что, папка component-preview-app находится
    в .gitignore проекта, так что можно без опаски
    делать git pull

  7. Устанавливаем документы для API, CLI, Native, Storage, Component preview

    cd /ionic/docs
    npm run api-docs

  8. Собираем проект

    npm run build

  9. Запускаем сервак

    npm run start

  10. Заходим в браузер и видим доки по адресу 

    localhost:3000/docs

  11. Периодически делаем git pull свежих изменений

    Разработчики Ionic периодически редактируют и
    обновляют доки, поэтому, пока ты их используешь
    в описанном выше режиме, надо их периодически
    обновлять.

    ▪ Обновление документации

      cd /ionic/docs
      git pull

      npm install
      npm run build

    ▪ Обновление Ionic v4 component preview app

      cd /ionic/component-preview-app
      git pull

      npm install
      npm run build

      Затем, копируем с заменой папку /ionic/component-preview-app/docs-www
      в /ionic/docs/src/content/component-preview-app/

    ▪ Обновление документов для API, CLI, Native, Storage, Component preview

      cd /ionic/docs
      git pull
      npm run api-docs
      npm run build


А2. Введение в Ionic
--------------------------------------

  # Что из себя представляет Ionic Framework?

    ▪ Общая информация об Ionic
    ▪ Какие цели преследовали авторы, создавая Ionic
      ▪ Кроссплатформенный
      ▪ Основан на веб-стандартах
      ▪ Прекрасная архитектура
      ▪ Простота
    ▪ Ionic является open source проектом с лицензией MIT
    ▪ Про Ionic CLI
    ▪ О совместимости с фреймворками
      ▪ Ionic v4 и JavaScript
      ▪ Ionic v4 и Angular
      ▪ Будут билды Ionic v4 для Vue и React
    ▪ О v4
    ▪ Про Ionic Pro
    ▪ Экосистема Ionic

  # Основные понятия

    ▪ Введение в основные понятия
    ▪ UI компоненты
    ▪ Непрерывность платформы: адаптация и мимикрия core-компонент под платформы
    ▪ Навигация, навигационные стеки, параллельная навигация
    ▪ Доступ к нативным платформам
    ▪ Архитектура
    ▪ Темы

  # Поддержка браузерами

    ▪ Поддержка браузерами на mobile
      ▪ Что с поддержкой у Ionic
      ▪ Что с поддержкой у Capacitor
      ▪ Что с поддержкой у Cordova
      ▪ Приложение на Capacitor и Ionic не пойдёт на 13.2% всех Android-устройств
      ▪ Приложение на Cordova и Ionic не пойдёт на 0.5% всех Android-устройств
      ▪ Краткие выводы: Cordova или Capacitor?

    ▪ Поддержка браузерами на desctop

  # Разъяснение за версии Ionic

    ▪ Используется SemVer (major.minor.patch)
    ▪ Расписание релизов
      ▪ Major Release
      ▪ Minor Release
      ▪ Patch Release
    ▪ Лог изменений

  # Поддержка

    ▪ Long Term Support (LTS)
    ▪ Платные опции поддержки

--------------------------------------

> Что из себя представляет Ionic Framework?

  • Общая информация об Ionic

    Ionic Framework - open source набор UI-инструментов для
    создания производительных, высококачественных мобильных
    и десктопных приложений, на основе веб-технологий
    (html, css, js).

    Ionic концентрируется на пользовательском интерфейсе
    (фронтенде), или на UI-взаимодействиях приложения 
    (элементы управления, взаимодействия, жесты, анимации).
    Его легко изучить, и легко использовать совместно
    с другими библиотеками или фреймворками, такими как
    Angular или Vue. Но можно обойтись и вообще без
    каких-либо других фронтенд-фреймворков.

    В настоящий момент, Ionic имеет официальную интеграцию
    с Angular, но авторы сообщают, что поддержка для 
    Vue и React в разработке.

  • Какие цели преследовали авторы, создавая Ionic

    ▪ Кроссплатформенный

      Пишем один код, одно приложение, которое работает
      на многих платформах, таких как iOS, Android, desctop,
      PWA (Progressive Web App)

      Девиз: "Write once, run anywhere".
             "Пишем одно приложение, которое работает везде".

    ▪ Основан на веб-стандартах

      Ionic основан на надёжных веб-технологиях: html, css, js.
      Поэтому, написанное сегодня Ionic-приложение будет 
      работоспособно на долгие-долгие годы вперёд. И никакая
      организация не сможет что-то там запретить или контролировать
      его (был бы камень в огород React Native, но в 
      феврале 2018 Facebook изменил лицензию React на MIT).

    ▪ Прекрасная архитектура

      Чистая, простая, функциональная. Ionic сконструирован
      работать и отображаться прекрасно прямо из коробки,
      на всех поддерживаемых платформах. Core-компоненты,
      типографика, интерактивные парадигмы и красивая
      и расширяемая базовая тема.

    ▪ Простота

      Ionic изначально разрабатывался таким образом, чтобы
      создание Ionic-приложений было лёгким и приятным делом,
      и любой специалист по веб-разработке мог быстро вникнуть
      и приступить к делу.

  • Ionic является open source проектом с лицензией MIT

    Ionic Framework является на 100% open source проектом,
    с лицензией MIT. Это означает, что его можно использовать
    в личных и коммерческих проектах бесплатно.

  • Про Ionic CLI

    Ionic CLI, это инструмент для быстрого создания
    новых Ionic-приложений из шаблонов, а также,
    в нём есть ряд полезных во время разработки оных команд.

    В нём также есть dev-сервер, инструменты для сборки 
    и отладки, и много чего ещё.

    Если у вас Ionic Pro, вы можете использовать CLI для
    экспорта кода и взаимодействия с вашим pro-аккаунтом
    через API.

  • О совместимости с фреймворками

    Ionic < 4 был заточен под Angular, без которого
    с ним нельзя было работать.

    А Ionic >= 4 перестал зависеть от Angular. Теперь
    с ним можно работать хоть вообще без фреймворков,
    хоть с тем же Vue или React, или любым другим
    фреймворком или библиотекой.

    То есть, теперь, Ionic превратился в независимую
    библиотеку.

    ▪ Ionic v4 и JavaScript

      Главной задачей при разработке Ionic v4 было убрать
      зависимость от Angular. Сделать так, чтобы 
      core-компоненты могли работать независимо, просто
      как обычный JS.

      В том время, как работа через фреймворки может быть
      удобна для разработки больших приложений большими
      командами, теперь возможно быстренько, местечково, 
      где-то там заюзать Ionic по-мелочи.

    ▪ Ionic v4 и Angular

      Angular сделал Ionic великим. В том время, как
      core-компоненты (как описано выше), в v4 были
      сделаны независимыми, пакет @ionic/angular делает
      интеграцию с инфраструктурой Angular очень простой.

      @ionic/angular включает всю функциональность, которую
      Angular-разработчики ожидают, и интегрируется с core-
      библиотеками Angular, вроде Angular router.

    ▪ Будут билды Ionic v4 для Vue и React

      Поддержка для других фреймворков ожидается в будущем
      релизе. В настоящий момент, разрабатываются 
      биндинги для Vue и React.

  • О v4

    Ionic Framework V4 является важным шагом вперёд.
    Есть существенные изменения, по сравнению с предыдущими 
    версиями, в лежащих в его основе технологиях. Новая
    версия сфокусирована на производительности, совместимости,
    и расширяемости.

    Хотя Ionic v4 имеет пакет @ionic/angular, позволяющий
    легко тесно интегрировать Ionic и Angular, он приобрел
    независимость от фреймворков. По сути, стал библиотекой,
    которую можно использовать хоть на чистом js, хоть с любым
    фреймворком.

    Переход на веб-стандарты позволил Ionic V4 полагаться
    скорее на то, на что способны браузеры, чем на то, на 
    что способен код из Angular.

    На практике, это означает мЕньшее время загрузки, 
    лучшая производительность, и меньше лишнего кода.

  • Про Ionic Pro

    Чтобы помочь управлять Ionic-приложениями на протяжении
    всего их жизненного цикла, команда Ionic предлагает
    платное решение Ionic Pro.

    Это платное решение идёт отдельно от open source 
    фреймворка Ionic, последний можно легко использовать
    без Pro.

    Ionic Pro помогает разработчикам и командам наблюдать
    и отслеживать ожибки во время выполнения кода, выполнять
    нативные сборки приложений в облаке, обновлять Ionic-
    приложения через push'и через личный кабинет.

    Чтобы получить Pro, нужно создать Ionic Account.
    Начать можно с бесплатного плана Starter.
    Ну, и можно перейти на какой-нибудь из платных планов,
    которые дают больше возможностей.

  • Экосистема Ionic

    Ionic Framework активно разрабатывается и поддерживается
    на полный рабочий день core-командой, а развитие экосистемы
    направляется международным сообществом разработчиков и 
    кантрибьютеров. Разработчики, большие и малые компании
    используют Ionic для создания прекрасных приложений,
    которые работают везде.

> Основные понятия

  • Введение в основные понятия

    Для новичков в разработке на Ionic, будет полезно
    увидеть общую картину того, как тут всё работает - 
    ключевую философию, концепты и инструменты в основе
    проекта.
    Прежде, чем погружаться в сложные темы, сначала
    следует понять основы Ionic Framework, и как он
    работает.

  • UI компоненты

    Ionic является библиотекой UI компонент, каждая из 
    которых может быть переиспользована, и которые
    используются в приложении, как строительные блоки.

    Компоненты Ionic построены на основе веб стандартов,
    с использованием HTML, CSS и JavaScript.

    Не смотря на то, что все компоненты собраны заранее,
    они изначально сделаны так, чтобы их можно было
    легко кастомизировать. Благодаря этому, для каждого
    приложения необходимые компоненты можно "допилить"
    индивидуально.

    Также, можно все компоненты глобально привязать к 
    теме, и потом легко менять тему всего приложения
    (подробнее о темах см.ниже).

  • Непрерывность платформы: адаптация и мимикрия core-компонент под платформы

    Platform Continuity - встроенная фича Ionic Framework,
    позволяющая разработчикам приложений использовать один
    и тот же код для разных платформ.

    Каждый компонент в Ionic адаптирует свой внешний вид
    и поведение в зависимости от того, на какой платформе
    он запущен в настоящий момент.

    Например, устройства Apple, такие как iPhone и iPad,
    используют свой iOS design language. 
    Аналогично, на устройствах под управлением Android
    используется язык дизайна от Google - Material Design.

    Если вы скачаете Ionic-приложение из Apple App Store,
    Ionic применит к нему тему для iOS. А если скачаете
    из Google Play, то тему для Android Material Design.

    Для платформы pwa Ionic по умолчания будет применять
    тему Material Design.

    Наконец, всё это дело можно настраивать, какие темы
    для каких платформ применять.

  • Навигация, навигационные стеки, параллельная навигация

    Традиционные сайты используют линейную историю. Это значит,
    что пользователь переходит по ссылкам на сайте вперёд,
    а может нажимать на кнопку "назад" и возвращаться в обратном
    порядке. Грубо говоря, имеется лишь 1 "навигационный стек".

    Ionic-приложения в этом плане могут сделать следующий шаг,
    и обеспечить параллельную навигацию. Это значит, что можно
    иметь >= 1 навигационного стека, и переключаться между ними
    в любой момент.

    Для приложений, разрабатываемых на Angular и ionic/angular, 
    авторы рекомендуют использовать Angular Router. Предыдущая
    версия Ionic поставлялась со своим собственным, встроенным
    роутером. Однако, от этой практики отказались, так что
    используйте роутер от фреймворка.

  • Доступ к нативным платформам

    Удивительным следствием того факта, что Ionic построен
    на основе веб-технологий, является то, что Ionic-приложения
    может работать практически на любой платформе:

      ▪ desktop computers
      ▪ phones
      ▪ tablets
      ▪ cars
      ▪ refrigerators
      ▪ ...

    Один и тот же код Ionic-приложения может работать на 
    многих платформах благодаря тому, что он основан на
    веб-стандартах и общем API, который есть на многих
    платформах.

    Одним из наиболее частых случаев использования Ionic,
    это сделать разом приложение, которое можно скачивать
    как из App Store, так и из Play Store. Благодаря тому,
    что и SDK для iOS, и SDK для Android предоставляют
    возможность использовать так называемые "web views",
    которые могут отрисовывать любое Ionic-приложение,
    это становится возможным.

    Такие проекты, как Capacitor и Cordova обычно используются,
    чтобы дать Ionic-приложениям доступ к нативным платформам.
    На практике это значит, что разработчики могут быстренько
    запилить веб-приложение, имея при этом доступ ко всем нативным
    API (таким как камера, GPS, и т.д.), и завернуть его в 
    iOS и Android приложение, и залить в сторы.

  • Архитектура

    Ionic-приложения структурированы вокруг идее о компонентах.
    Используя любой фронтенд-фрейморк по выбору, вы можете
    строить приложение из компонент, как кирпичный домик. 
    Вообще, сейчас все топовые фронтенд-фреймворки по
    такому же принципу и работают.
    Высокоуровневые "views", это лишь компоненты, которые 
    доступны по URL.

  • Темы

    В ядре, Ionic Framework построен с использованием CSS.
    Это позволяет нам использовать преимущества, которые 
    обеспечивают css-переменные. Это даёт возможность 
    невероятно легко разрабатывать приложение, которое 
    и выглядит прекрасно, и соответствует веб-стандартам.

    Из коробки авторы предлагают набор цветов для кастомизации
    тем. Но никто не мешает вообще все перетряхнуть, и 
    кастомизировать так, как больше нравится, как больше
    подходит для конкретной компании.

    Подробнее про темы смотрете в отдельной главе.

> Поддержка браузерами

  Изначальной целью Ionic сделать простым делом разработку
  мобильных приложений с использованием веб-технологий:
  html, css, js. Это даёт возможность Ionic-приложению
  с одним и тем же кодом работать на многих устройствах, 
  операционных системах, и во многих браузера.

  • Поддержка браузерами на mobile

    ▪ Что с поддержкой у Ionic

      Поддержка браузерами на мобильных платформах была
      в центре внимания, и тщательно тестировалась на
      следующих операционных системах:

      ▪ Android >= 4.4
      ▪ iOS >= 10

    ▪ Что с поддержкой у Capacitor

      Надо также учитывать ограничения Capacitor, если использовать
      Ionic в связке с ним. Capacitor поддерживает следующие системы:

      ▪ Android >= 5.0
      ▪ iOS >= 10

      Так что, по факту, на работу приложения на Capacitor + Ionic
      на Android 4.* рассчитывать не стоит.

    ▪ Что с поддержкой у Cordova

      Надо также учитывать ограничения Capacitor, если использовать
      Ionic в связке с ней. Cordova поддерживает следующие системы:

      ▪ Android >= 4.0.3
      ▪ iOS >= 8

    ▪ Приложение на Capacitor и Ionic не пойдёт на 13.2% всех Android-устройств
    
      Это данные на июль 2018.
      Основаны на данных о распространении версий Android от Google

        https://developer.android.com/about/dashboards/ 

      Готовы ли мы терять 13.2% рынка всех android-устройств?

      p.s. 

        На январь 2018 эта цифра составляла 19.3%. То есть, 
        за 7 месяцев снижение на 5.9%.

    ▪ Приложение на Cordova и Ionic не пойдёт на 0.5% всех Android-устройств

      Это данные на июль 2018.
      Основаны на данных о распространении версий Android от Google

        https://developer.android.com/about/dashboards/ 

    ▪ Краткие выводы: Cordova или Capacitor?

      1. Если тенденция снижения доли устройств под управлением
         Android < 5.0.0 продолжится, и она будет падать
         примерно на 1% в месяц, то уже к новому году она
         сократится примерно до 8%, а к следующему лету
         до 2-3%.

      2. Для экспериментов со стартапами сейчас подойдёт
         и Capacitor. К моменту релиза MVP ближайшего стартапа,
         что произойдёт не ранее, чем через 3-6 месяцев, 
         доля устройств под управлением Android < 5.0.0 
         должна будет сократиться примерно до 8%, и их
         потерю на старте начинающий стартап вполне в силе
         пережить. Да и кроме того, если человек не в состоянии
         обновить свой древний смартфон на Android 4.*, то
         вероятность того, что он будет пользоваться услугами
         нашего сервиса мала.

  • Поддержка браузерами на desktop

    Ionic работает прекрасно не только на мобильных устройствах,
    но, поскольку он основан на веб-технологиях, то и в 
    браузерерах на desktop чувствует себя отлично:

    ▪ Chrome
    ▪ Safari
    ▪ Edge
    ▪ Firefox

    Вообще-то, Capacitor ещё позволяет собирать 
    electron-приложения

> Разъяснение за версии Ionic

  • Используется SemVer (major.minor.patch)

    Ionic Framework следует соглашению о семантическом 
    версионировании SevVer:

      major.minor.path

    Major-изменения вносят обратно-несовместимые изменения
    Minor-изменения вносят обратно-совместимые изменения.
    Path-изменения просто фиксят какие-то баги.

  • Расписание релизов

    • Major Release

      Такие релизы выходят, когда необходимо внести кардинальные
      изменения в API. Мажорные релизы будут выходить каждые
      6 месяцев, и будут обратно-совместимыми для большинства
      разработчиков. Несколько кандидатов на релиз будут 
      публиковаться до релиза, чтобы сообщество могло оценить их,
      и выбрать победителя на релиз.

    • Minor Release

      Минорные релизы публикуются, когда добавляется новая
      фича, или вносятся какие-то изменения в API (обратно-
      совместимые). Команда Ionic будет тщательно тестировать
      любые изменения, так что можете быть уверены, что
      после обновления ничего не сломается. Однако, с новым
      кодом потенциально идут новые проблемы.

      Минорные релизы будут выходить каждый месяц, если
      для их выпуска будет достаточно основания.

    • Patch Release

      Будут выходить сразу после того, как какой-нибудь баг
      исправлен. При этом, без изменений в API, и без 
      обратно-несовместимых изменений.

      Планируется выпускать такие релизы каждую неделю,
      или чаще, если надо очень быстро поправить какой-то
      баг.

      Patch-релизы всегда будут публиковаться до minor-релизов,
      чтобы удостовериться, что первые исправили соответствующие
      баги до того, и не создали новых, до того, как добавлять
      новую фичу.

  • Лог изменений

    Чтобы узнать, какие изменения внёс тот или иной релиз,
    пройдите в changlog.

> Поддержка

  • Long Term Support (LTS)

    Для major-релизов исправление багов производится в 
    течение 2-х лет, а проблем с безопасностью - 3-х лет.

    Это означает следующее.
    Допустим, есть нынешний major-релиз, это 4.*.*.
    И вот, сегодня, релизнулся 5.0.0.
    С этого момента, начинается отсчёт времени в условном
    таймере до смерти 4.*.* - ещё 2 года с этого момента
    будут фиксить баги, и 3 года - проблемы с безопасностью.

    До 4.0 LTS-версий фреймворка НЕ существует.
    Это - первая.

  • Платные опции поддержки

    Ionic предлагает платную поддержку для команд и организаций.
    Но она, в основном, никому не нужна, по мнению автора
    этой методички =)


А3. Установка Ionic
--------------------------------------

  # Установка через Ionic CLI

    ▪ Установка Ionic CLI
    ▪ Создание Ionic-приложения из шаблонов

  # Подключение через CDN

    ▪ Подключение Ionic Framework через CDN
    ▪ Подключение Ionicons из CDN

  # Настройка среды окружения

    ▪ Node & NPM
    ▪ Git

  # Настройка среды для разработки под iOS

    ▪ Xcode
      ▪ Настройка Development Team
      ▪ Создание симулятора iOS

    ▪ ios-sim & ios-deploy

  # Настройка среды для разработки под Android

    ▪ Java
    ▪ Gradle
    ▪ Android Studio
      ▪ Установка Android Studio
      ▪ Установка Android SDK
      ▪ Настройка CLI
      ▪ Создание Android Virtual Device
      ▪ Настройка Android Device

--------------------------------------

> Установка через Ionic CLI

  Ionic-приложения создаются и разрабатываются преимущественно
  с помощью Ionic CLI. Оный является предпочтительным способом
  установки Ionic, и предлагает много полезных в разработке
  инструментов. Через него также можно запускать приложение,
  и взаимодействовать с Ionic Pro.

  • Установка Ionic CLI

    Прежде, чем продолжить, убедитесь, что последние версии
    NodeJS и NPM установлены.

    Затем можно установить Ionic CLI глобально:

      sudo npm install -g @ionic/core

  • Создание Ionic-приложения из шаблонов

    Создать Ionic-приложение можно, использовав один из 
    шаблонов, либо пустой шаблон. Три наиболее популярных
    варианта, говорящих сами за себя:

    ▪ blank
    ▪ tabs
    ▪ sidemenu

    Пример:

      ionic start myApp tabs

    Подробнее про это читайте в главе про создание и 
    разработку Ionic-приложения.

> Подключение через CDN

  Поскольку Ionic Framework состоит из веб-компонент,
  возможно просто подключить его в HTML-файл через
  CDN.

  • Подключение Ionic Framework через CDN

    Рекомендуется использовать unpgk. Рекомендуется
    подключать Ionic в <head></head> в html-файле:

      <script src="https://unpkg.com/@ionic/core@latest/dist/ionic.js"></script>

    Подключив его таким образом, возможно использовать 
    компоненты Ionic без установки чего-либо.

  • Подключение Ionicons из CDN

    Если вы используете Ionic, Ionicons идут в комплекте,
    и их не надо отдельно устанавливать.

    Но если вы хотите использовать Ionicons без Ionic,
    то можете просто подключить их через CDN:

      <script src="https://unpkg.com/ionicons@4.0.0/dist/ionicons.js"></script>

> Настройка среды окружения

  Для работы с Ionic нужны NodeJS и NPM.

  • Node & NPM

    Почти все современные инструменты для JS-проектов 
    используют NodeJS. Ionic не исключение. Установите
    последние версии NodeJS и NPM.

    После установки проверьте версии, загуглите в инете,
    какие последние, и сравните.

      node -v
      npm -v

  • Git

    Хотя Git не необходим, рекомендуется установить 
    его в последней версии. Чтобы проверить версию:

      git -v

> Настройка среды для разработки под iOS

  Чтобы разрабатывать под iOS, надо поднастроить среду.
  Разрабатывать под iOS можно только на MacOS.
  Так что, если у вас Windows или Linux, виртуальная
  машина с MacOS вам в помощь.

  • Xcode

    Xcode, это IDE для создания нативных iOS-приложений.
    Она включает в себя iOS SDK и Xcode CLI.
    Xcode можно скачать в магазине приложений App Store.
    Для этого понадобится аккаунт Apple.

    ▪ Настройка Development Team

      Все iOS-приложения должны быть подписаны, даже те,
      которые в разработке. К счастью, Xcode позволяет 
      легко делать это автоматически. Для этого нужен
      лишь Apple ID.

      Откройте Xcode и идите в Xcode -> Preferences -> Accounts.
      Добавьте Apple ID, если его там нет ещё.
      Залогинившись, в списке команд появится ваша Personal Team.

    ▪ Создание симулятора iOS

      Симулятор iOS эмулирует iOS-устройства на MacOS.
      Вот официальная инструкция от Apple, как его 
      настроить:

        https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/simulator_help_topics/Chapter/Chapter.html

      В принципе, это легко. Пройдите в Window -> Devices and
      Simulators. Создайте, например, симулятор iPhone X.

  • ios-sim & ios-deploy

    ios-sim и ios-deploy, это инструменты для деплоя
    приложения в iOS-симулятор и iOS-устройства в 
    процессе разработки.

    Их можо установить глобально через npm:

      npm install -g ios-sim
      npm install -g ios-deploy

> Настройка среды для разработки под Android

  Чтобы разрабатывать под Android, надо поднастроить среду.
  В отличие от разработкипод iOS, под Android можно
  разрабатывать на Windows, MacOS и Linux.

  • Java

    Нативные приложения под Android компилируются с помощью
    Java. Скачайте JDK8 (JDK10 ещё слишком новый на 07.2018) с 
    официального сайта:

      http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

  • Gradle

    Gradle это инструмент для сборки, используемый в 
    Android-приложениях, и может быть установлен отдельно.

    См.официальный сайт с инструкцией, где описана его
    установка:

      https://gradle.org/install/

  • Android Studio

    Android Studio, это IDE для создания нативных 
    Android-приложений. Он включает Android SDK, который
    понадобится настроить для использования в командной
    строке.

    ▪ Установка Android Studio

      Качнуть Android Studio можно бесплатно с официального
      сайта:

        https://developer.android.com/studio/

    ▪ Установка Android SDK

      Откройте Android Studio. Оно само заметит, что
      требуется установить SDK. На экране SDK Components
      Setup, который сам появится, установите SDK. Обратите
      внимание на Android SDK Locatin.

      Когда SDK установитяс, закройте Android Studio.
      
      На будущее, управлять версиями Android SDK можно
      в Android Studio, в меню Configure -> SDK Manager.

    ▪ Настройка CLI

      Android SDK поставляется с полезным CLI. Но прежде, 
      чем его можно будет использовать, надо установить
      кое-какие переменные среды.

      Как это сделать на Windows, погуглите в инете.

    ▪ Создание Android Virtual Device

      Android Virtual Devices (AVDs) - образы, которые 
      эмулятор Android использует для запуска Android OS.
      Подробнее про это см.официальную документацию:

        https://developer.android.com/studio/run/managing-avds

      Вообще, это не сложно. Пройдите в Tools -> AVD Manager.
      Нажмите Create Virtual Device, и дальше всё понятно.

      Когда AVD создан, запустите его в эмуляторе.
      Во время разработки можно держать эмулятор включенным.

    ▪ Настройка Android Device

      Для разработки можно использовать не только эмулятор,
      но и настоящее устройство с Android. Но для начала
      это устройство надо подготовить. Ниже описан быстрый
      способ, но подробнее можете глянуть тут:

        https://developer.android.com/studio/run/device

      Итак, настраиваем устройство:

      1. Включить USB Debugging на устройстве

        Откройте Settings. Перейдите в Developer Options,
        и включите USB debugging.

        Саму Developer Options ещё надо включить, если она
        уже не включена:

          Настройки -> Система -> О телефоне -> 7 раз тап по "Номер сборки"

      2. Убедиться, что устройство имеет разрешение подключиться к компьютеру

        На MacOS никаких доп.усилий не требуется.
        Для Windows, установите OEM USB Drivers.

          https://developer.android.com/studio/run/oem-usb

      Затем подключите устройство к компьютеру через USB,
      и выполните команду:

        adb devices

      Будет выведен список подключенных устройств, и ваше
      должно быть в нём.


А4. Процесс разработки Ionic-приложения
--------------------------------------

  # Старт нового Ionic-приложения /Starting/

    ▪ Команда ionic start
    ▪ Типы шаблонов

  # Структура проекта и добавление ресурсов через CLI /Scaffolding/ 

    ▪ Основной код твоего приложения будет в src/
    ▪ Структура проекта (на примере проекта на angular)
    ▪ Генерирование новых фич

  # Адаптация и под браузер, и под приложения /Cross Platform/

    ▪ Кое-что надо иметь в виду при адаптации под разные платформы
    ▪ Разруливание запросов к несуществующим на текущей платформе API
      ▪ Разруливание с API в Ionic Native
      ▪ Как определить в коде, что за платформа?
      ▪ Разруливание с API в браузере
    ▪ Адаптивная разметка под десктопы и мобилки: компонент Grid
    ▪ Универсальный способ локального хранения данных: Ionic Storage
      ▪ Что такое Ionic Storage
      ▪ Список поддерживаемых Ionic Storage хранилищ
      ▪ Почему SQLite в приоритете?
      ▪ Пример использования Ionic Storage

  # Упрощённый запуск на устройствах через Ionic DevApp /Running Overview/ 

    ▪ Команда ionic serve, приложение DevApp, livereload из коробки
    ▪ Ionic DevApp доступен для iOS и Android
    ▪ Надо подключить устройство и комп к одной сети
    ▪ Инструкция, как пользоваться DevApp
    ▪ DevApp поддерживает ограниченный список плагинов

  # Как деплоить на iOS-платформу с помощью Cordova/Capacitor /Running on iOS/

    ▪ Предварительная настройка iOS-проекта
    ▪ Запуск iOS-приложения через Xcode
    ▪ Запуск iOS-приложения через Ionic CLI
    ▪ Использование Safari Web Inspector
    ▪ Просмотр нативных логов

  # Как деплоить на Android-платформу с помощью Cordova/Capacitor /Running on Android/

    ▪ Предварительная настройка Android-проекта
    ▪ Запуск Android-приложения с помощью Capacitor
    ▪ Запуск Android-приложения с помощью Cordova
    ▪ Использование Chrome DevTools для отладки
    ▪ Просмотр нативных логов

  # Организация unit-тестов в ionic/angular приложениях /testing/
  # Подробнее про Web View /Web View/

    ▪ Что такое Web View
    ▪ CORS (кросс-доменный AJAX) всегда включен в Web View
      ▪ Что такое CORS
      ▪ Нативный плагин, чтобы обойтись без CORS
      ▪ Чеклист на пригодность к CORS для сервера
      
    ▪ Конвертация запросов file:// в http:// для Cordova и Capacitor
      ▪ Что на Cordova
      ▪ Что на Capacitor

    ▪ Реализации Web View на разных платформах

  # Про Ionic Storage /Ionic Storage/
  
    ▪ Как работает Ionic Storage
      ▪ Список поддерживаемых Ionic Storage хранилищ
      ▪ Почему SQLite в приоритете?
    ▪ Использование Ionic Storage
    ▪ Настройка Ionic Storage
    ▪ API для Ionic Storage
      
      Методы
      ▪ constructor   | создать новый экземпляр хранилища
      ▪ clear         | полностью очистить хранилище
      ▪ forEach       | пробежаться по всем парам key/value в хранилище
      ▪ get           | получить значение, связанное с указанным ключом
      ▪ keys          | список всех ключей в хранилище
      ▪ length        | кол-во ключей в хранилище
      ▪ ready         | готово ли хранилище
      ▪ remove        | удаление из хранилище пары key/value по ключу

      Свойства
      ▪ driver        | получить имя используемого драйвера
  
--------------------------------------

> Старт нового Ionic-приложения /Starting/

  • Команда ionic start

    Создать новое Ionic-приложение очень просто. Это
    можно сделать из командной строки командой:

      ionic start

    которая запросит инфу об имени проекта, и какой шаблон
    использвоать.

    В принципе, можно избежать интерактивных запросов и 
    указать все параметры сразу:

      ionic start myApp tabs --type=angular

    где myApp - название, tabs - тип, angular - фреймфорк.

  • Типы шаблонов 

    ▪ tabs
    ▪ sidemenu
    ▪ blank

    Посмотреть список всех доступных шаблонов можно
    командой:

      ionic start --list

    Эти шаблоны представляют собой отличное начало для
    любого приложения, и включают все лучшие практики
    для того, чтобы было потом легко поддерживать
    и масштабировать код.
    
> Структура проекта и добавление ресурсов через CLI /Scaffolding/

  • Основной код твоего приложения будет в src/

    Создав приложение из шаблона с помощью Ionic CLI, следующим
    шагом будет работа над фичами и компонентами. Большая
    часть разработки приложения будет проходить в папке src/

  • Структура проекта (на примере проекта на angular)

    src/
      app/                    | здесь основной код приложения
        components/
        pages/
        services/
        app.component.html
        app.component.spec.ts
        app.component.ts
        app.module.ts
        app-routing.module.ts
      assets/                 | папка для всяких ресурсов, типа картинки/шрифты/итп
      environments/
      theme/
      global.scss
      index.html              | точка входа в приложение
      karma.conf.js           | конфиг Angular'овского фреймворка для тестов
      main.ts
      polyfills.ts
      test.ts
      tsconfig.app.json
      tsconfig.spec.json

  • Генерирование новых фич

    Ionic CLI, с помощью коменды ionic generate, может
    генерировать различные ресурсы в проекте.

    Чтобы посмотреть, что именно оно может генерировать,
    запустите эту команду без аргументов:

      ionic generate
      ionic g         | сокращённый вариант

    Когда вы выберете, что именно хотите сгенерировать,
    Ionic запросит у вас name. Крайне рекомендуется
    префиксить name путём относительно корня проекта,
    чтобы ресурс генерировался там, где положено
    (почему-то Ionic CLI не может это сам делать)
   
      Например:

        pages/My New Page         |
        pages/tabs/Main Tab       | любой уровень вложенности
        pages/tabs/my/Main Tab    | 
      
      вместо просто названия без префикса:

        My New Page

    Чтобы избежать интерактивных запросов, можно указать
    name и type сразу в команде:

      ionic g page "pages/User Detail"

    где page - тип ресурса, "pages/User Detail" - где его создать.
    Ionic CLI использует за кадром инструменты фреймворка,
    чтобы оставаться максимально близко к лучшим практикам.
    Для ionic/angular, под капотом используется Angular CLI.

    После создания файлов и каталогов для новой страницы,
    CLI также автоматически обновит конфигурацию роутера,
    чтобы включить туда новую страницу. Это уменьшает
    кол-во работы, которую требуется проделать вручную.

    Справку про ionic g моно посмотреть так:

      ionic g --help

> Адаптация и под браузер, и под приложения /Cross Platform/

  • Кое-что надо иметь в виду при адаптации под разные платформы

    Ionic изначально создавался таким, чтобы разработка
    была лёгкой, вне зависимости от того, для какой
    платформы предназначается приложение.

    Ionic-приложения реально кроссплатформенные: работают
    на Android, iOS, Electron и PWA, и все это один и 
    тот же код.

    Однако, есть ряд вещей, которые надо иметь в виду, 
    оптимизируя приложение для работы на раных платформах.

  • Разруливание запросов к несуществующим на текущей платформе API

    Например, в коде нативных приложений могут производиться 
    запросы к API соответствующих нативных платформ, такие 
    например, как открытие камеры или получение геолокационных
    данных. 

    Эти запросы не будут работать при выполнении на pwa, 
    например, ведь там соответствующие API отсутствуют.
    В этом пункте описано, как разруливать эту ситуацию.

    ▪ Разруливание с API в Ionic Native

      Ionic Native имеет свою внутреннюю логику, чтобы
      определять, выполняется ли он в настоящий момент
      на той или иной платформе.

      Вместо возбуждения ошибки, он просто выведет в лог
      предупреждение, если выполняется не на нативной
      платформе, и соответствующие Cordova-плагины
      недоступны.

      Приложение не сломается, и продолжит работать,
      без соответствующего нативного функционала.

    ▪ Как определить в коде, что за платформа?

      В логике приложения, при каждом запросе к нативному 
      API, рекомендуется всегда проверять, на какой
      платформе происходит выполнение (ниже пример
      для Cordova):

        this.platform.ready().then(() => {
          if (this.platform.is('cordova')) {
            // make your native API calls
          } else {
            // fallback to browser APIs
          }
        });

    ▪ Разруливание с API в браузере

      Многие нативные API недоступны в браузере. С другой
      стороны, браузерное API постоянно улучшаетя и 
      дополняется. Надо по-умному всё делать, чтобы
      если, допустим, надо выбрать какой-то файл,
      но нативное API файловой системы недоступно, 
      и дело происходит в браузере, тогда открывалось
      окно с выбором файла на компе.

  • Адаптивная разметка под десктопы и мобилки: компонент Grid

    Если вы целитесь не только на мобильные платформы
    iOS и Android, но и хотите, чтобы ваше приложение
    нормально отображалось на компьютере в браузере,
    или через Electron, где ширина экрана большая,
    вам надо особое внимание уделить адаптивному
    дизайну.

    К счастью, в Ionic есть компонент Grid. Поэтому,
    можно завернуть контент в <ion-grid>...</ion-grid>,
    и сделать сеточку. Она, по сути, клон оной из
    бутстрапа.

    Пример:

      <ion-grid>
        <ion-row>
          <ion-col>
            <ion-item>
              <ion-label>Item 1</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 2</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 3</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 4</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 5</ion-label>
            </ion-item>
          </ion-col>
        </ion-row>
      </ion-grid>    
    
    С помощью атрибута fixed в элементе ion-grid можно
    сделать ширину элементов фиксированной, на основе
    ширины экрана (имеется в виду использование
    приставок типа -sm, -md, -lg, xl). Это хорошо для очень широких экранов,
    когда элементы стали бы необузданно растягиваться
    в ширину без этого атрибута.

    Прописав fixed, мы можем в элементе ion-col указать
    size по умолчанию в кол-ве столбцов (всего в сетке
    Ionic 12 столбцов, => 12 - это max ширина), а также
    размеры на основе текущей ширины браузера, такие как
    size-sm, size-md, size-lg, size-xl.

    Пример:

      <ion-grid fixed>
        <ion-row>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 1</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 2</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 3</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 4</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 5</ion-label>
            </ion-item>
          </ion-col>
        </ion-row>
      </ion-grid>

  • Универсальный способ локального хранения данных: Ionic Storage

    ▪ Большинству приложений надо хранить какие-то данные локально

      Большинству приложений надо сохранять какие-то 
      данные локально. Это может быть результат XHR-запроса
      в виде JSON-строки, или аутентификационный токен,
      или что-то ещё. 

      В принципе, для приложений, работающих в нативных
      средах, можно создать полноценную базу данных на
      основе SQLite, и складывать данные туда.

      Все эти механизмы для хранения данных имеют свои
      преимущества и недостатки, но разработчикам на
      Ionic не стоит об этом волноваться.. ведь есть
      Ionic Storage.

    ▪ Библиотека Ionic Storage

      ▪ Что такое Ionic Storage

        Это простое key-value хранилище для Ionic-приложений,
        основанное на LocalForage, с поддержкой SQLite из
        коробки. 

        Оно позволяет использовать лучшее доступное хранилище
        без необходимости взаимодействовать с ним напрямую,
        а используя один и тот же API.

      ▪ Список поддерживаемых Ionic Storage хранилищ

        В настоящий момент (конец июля 2018), отсортированный 
        список поддерживаемых хранилищь от лучшего к худшему:

        ▪ SQLite
        ▪ IndexedDB
        ▪ WebSQL
        ▪ LocalStorage

      ▪ Почему SQLite в приоритете?

        Одной важной причиной, по которой SQLite в приоритете,
        является то, что многие нативные платформы (iOS, например),
        в настоящее время, периодически и непредсказуемо чистят
        Local Storage (и IndexedDB), когда устройству начинает
        не хватать памяти. Чтобы избежать потери данных, лучше
        использовать хранищище с файлами, такое как SQLite.

      ▪ Пример использования Ionic Storage

        class MyClass {
          constructor(public storage: Storage) {}

          setData(key, value) {
            this.storage.set(key, value)
            .then(res => console.log(res))
          }
          getData(key) {
            this.storage.get(key)
            .then(keyVal => console.log('Key is', keyVal))
          }
        }      

> Упрощённый запуск на устройствах через Ionic DevApp /Running Overview/ 

  • Команда ionic serve, приложение DevApp, livereload из коробки

    Ionic DevApp расширяет возможности Ionic'а, позволяя
    легко тестировать приложения прямо на устройствах.
    DevApp предлагает наблюдать изменения в реальном времени,
    с богатой библиотекой предустановленных нативных плагинов
    для тестирования нативной функциональности приложения.

    Нет необходимости устанавливать сложные нативные SDK - 
    всё проворачивается одной простой командой:

      ionic serve

    после чего приложение будет немедленно готово к тестированию
    на всех устройствах, где установлен DevApp, с работающим
    из коробки LiveReload.

  • Ionic DevApp доступен для iOS и Android

    Чтобы начать пользоваться DevApp, надо сначала его
    установить на соответствующие устройства. Он
    бесплатен, нужно только завести Ionic-аккаунт.

  • Надо подключить устройство и комп к одной сети

    Чтобы вся эта тема с DevApp работала, необходимо,
    чтобы устройство с установленным на него и запущенным
    приложением DevApp, и компьютер, на котором вы ведёте
    разработку Ionic-приложения, были в одной сети.

  • Инструкция, как пользоваться DevApp

    1. Установить DevApp на устройство, и запустить.
    2. Подключить устройство и компьютер к одной сети.
    3. На компьютере выполнить в корне проекта:

      ionic serve

    4. На устройстве в DevApp ваш компьютер должен стать
       виден, выберите его из списка.
    5. Теперь, если вы обращаетесь к какой-то нативной
       функциональности, DevApp может это обрабатывать
       и возвращать корректную нативную имплементацию.

  • DevApp поддерживает ограниченный список плагинов

    Воспользуйтесь документацией по DevApp, чтобы
    проверить, какой список плагинов оно поддерживает
    в настоящий момент:

      https://ionicframework.com/docs/pro/devapp/

> Как деплоить на iOS-платформу с помощью Cordova/Capacitor /Running on iOS/

  В этом руководстве описано, как деплоить iOS-приложения,
  написанные на Ionic, с помощью Capacitor и Cordova.

  Есть 2 способа запускать Ionic-приложения на iOS:

    ▪ Через Xcode
    ▪ Через Ionic CLI (преимущество: live-reload)

  • Предварительная настройка iOS-проекта

    Перед тем, как приложения могут быть развернуты на 
    iOS-эмуляторах и устройствах, надо сначала
    настраивать из нативные проекты.

    1. Сгенерировать нативный проект, если он ещё не существует

      ▪ Capacitor

        ionic capacitor add ios

      ▪ Cordova

        ionic cordova prepare ios
 
    2. Установка "Package ID"

      ▪ Capacitor

        Откройте файл capacitor.config.json, и измените
        свойство appId.

      ▪ Cordova

        Откройте файл config.xml и измените атрибут
        id корневого элемента <widget>.

    3. Открытие проекта в Xcode

      ▪ Capacitor

        Либо запустите Xcode и откройте в нём проект 
        самостоятельно, либо выполните эту команду:

          ionic capacitor open ios

      ▪ Cordova    

        Запустите Xcode и откройте в нём проект, который
        находится в папке platforms/ios.

    4. Сверка Package ID

      В Xcode, слева, в навигации по проекту, выделите
      корневую папку, чтобы открылся редактор проекта.
      В разделе "Identity", удостоверьтесь, что Package ID
      совпадает с оным, который вы установили в пункте 2.

    5. Проверка, что "Automatically manage signing" включено

      В том же редакторе проекта, что в пункте 4, 
      в разделе "Signing" удостоверьтесь, что
      "Automatically manage signing" включёно.

      После чего, в дропбоксе ниже выберите соответствующую
      "Development Team" (как её сделать см.в методичке
      по Capacitor). После этого, Xcode попытается автоматически
      подписать ваш код.

  • Запуск iOS-приложения через Xcode

    В этом процессе, Xcode может автоматически решать
    общие проблемы с компиляцией и подписыванием кода.

    1. Разработать Ionic-приложение и синхронизировать файлы с нативной платформой

      После любых изменений, надо пересобирать Ionic-приложение,
      и лишь затем изменения можно увидеть на эмуляторе или 
      устройстве. Полученные после сборки www-файлы должны быть
      скопированы на платформу нативного проекта, для этого
      надо выполнить команду:

      ▪ Capacitor

        ionic capacitor copy ios

      ▪ Cordova      

        ionic cordova prepare ios

    2. Запуск проекта в эмуляторе, или на девайсе

      В Xcode, выберите эмулятор или устройство,
      и нажмите кнопку Play.

  • Запуск iOS-приложения через Ionic CLI

    Ionic CLI может собирать, копировать и развёртывать
    Ionic-приложения на iOS-эмуляторах и устройствах
    одной командой. 

    Также, он может поднять dev-сервер на NodeJS с 
    функционалом live-reload из коробки.

    ▪ Capacitor

      К сожалению, на конец июля 2018, live-reload для
      Capacitor ещё не работает.

    ▪ Cordova

      Выполните следующую команду, чтобы поднять
      сервер с live-reload:

        ionic cordova run ios -l

      После этого, каждый раз, когда вы будете вносить
      изменения в исходные файлы проекта, www-файлы
      пересобираются, копируются в проект, и вы сразу
      видите изменения на эмуляторе или устройстве
      без необходимости переразворачивать приложение.

  • Использование Safari Web Inspector

    В Safari есть поддержка Web Inspector для iOS эмуляторов
    и устройств. Откройте меню "Develop" и выберите эмулятор
    или устройство, затем выберите Ionic-приложение, чтобы
    открыть Web Inspector.

    Если меню Develop скрыто, включите его в настройках:
    Safari -> Preferences -> Advanced.

  • Просмотр нативных логов

    Нативные логи можно просмотреть в Xcode в Console.
    Если Console скрыта, включите её в настройках:
    View -> Debug Area -> Activate Console.

> Как деплоить на Android-платформу с помощью Cordova/Capacitor /Running on Android/

  В этом руководстве описано, как деплоить Android-приложения,
  написанные на Ionic, с помощью Capacitor и Cordova.

  Чтобы деплоить приложения на устройство с Android и 
  отлаживать их, разработчик должен включить на устройстве
  "developer mode" и "USB debugging". Как это сделать,
  описано здесь:

    https://developer.android.com/studio/debug/dev-options#enable

  • Предварительная настройка Android-проекта

    1. Сгенерировать нативный проект, если он ещё не существует

      ▪ Capacitor

        ionic capacitor add android

      ▪ Cordova

        ionic cordova prepare android

    2. Установка "Package ID"

      ▪ Capacitor

        Откройте файл capacitor.config.json, и измените
        свойство appId.

      ▪ Cordova

        Откройте файл config.xml и измените атрибут
        id корневого элемента <widget>.

  • Запуск Android-приложения с помощью Capacitor

    Capacitor использует Android Studio для сборки
    и выполнения приложения на эмуляторе или устройстве.

    К сожалению, на конец июля 2018, live-reload для
    Capacitor ещё не работает.

    1. Разработать Ionic-приложение и синхронизировать файлы с нативной платформой

      После любых изменений, надо пересобирать Ionic-приложение,
      и лишь затем изменения можно увидеть на эмуляторе или 
      устройстве. Полученные после сборки www-файлы должны быть
      скопированы на платформу нативного проекта, для этого
      надо выполнить команду:

      ionic capacitor copy android

    2. Запуск проекта в эмуляторе, или на девайсе

      В Android Studio, выберите эмулятор или устройство,
      и нажмите кнопку Run.

  • Запуск Android-приложения с помощью Cordova

    Ionic CLI может собирать, копировать и развёртывать
    Ionic-приложения на iOS-эмуляторах и устройствах
    одной командой. 

    Также, он может поднять dev-сервер на NodeJS с 
    функционалом live-reload из коробки.

    Выполните следующую команду, чтобы поднять
    сервер с live-reload:

      ionic cordova run ios -l

    После этого, каждый раз, когда вы будете вносить
    изменения в исходные файлы проекта, www-файлы
    пересобираются, копируются в проект, и вы сразу
    видите изменения на эмуляторе или устройстве
    без необходимости переразворачивать приложение.

  • Использование Chrome DevTools для отладки

    DevTools в Chrome поддерживает эмуляторы Android и
    устройство. Откройте Chrome и идите в 

      chrome://inspect

    при подключенном устройсте или запущенном эмуляторе,
    и выберите там приложение, которое надо отладить.

  • Просмотр нативных логов

    Нативные логи можно просматривать в Android Studio,
    в Console.

> Организация unit-тестов в ionic/angular приложениях /testing/

  Когда вы генерируете ionic/angular приложение через
  Ionic CLI, в нём автоматически настраиваются юнит-тесты
  через Jasmine. Это тоже самое, что происходит при создании
  нового проекта через Angular CLI. Подробнее о тестировании
  Angular-приложений написано в официальной инструкции:

    https://angular.io/guide/testing

  *Примечание автора методички:

    Подробно я не стал расписывать эту главу, поскольку
    она целиком про Angular, а я испольщую Vue.

> Подробнее про Web View /Web View/

  Web View позволяет запускать веб-приложения на нативных
  устройствах. 

  Ionic поддерживает Web View Plugin для приложений, 
  использующих Cordova. Плагин предоставляется
  автоматически при использовании с Ionic CLI.

  Для приложений, использующих Capacitor, Web View
  автоматически предоставляется.

  • Что такое Web View

    Ionic-приложения строятся с использованием веб-технологий,
    и отрисовываются с помощью Web Views, которые являются
    полноэкранными и полнофункциональными браузерами.

    Современные Web Views предлагают много встроенных HTML5
    APIs для доступа к нативному функционалу платформ, 
    такому как камиры, сенсоры, GPS, динамики, Bluetooth.
    Но часто требуется иметь доступ к специфичным для 
    платформ API - в Ionic-приложениях такой доступ
    приложение получает через связующий слой, который
    представляет из себя нативный плагин с JS-API.

    Ionic Web View плагин заточен под современные JS-приложения.
    Для iOS и Android, файлы приложения всегда хостятся с
    использованием протокола http:// на оптимизированном
    HTTP-сервере, который запускается на локальном устройстве.

  • CORS (кросс-доменный AJAX) всегда включен в Web View

    ▪ Что такое CORS

      Существует такая вещь в браузерах, как same-origin-policy 
      ля XSS (кросс-доменных запросов), которая мешает из JS 
      на одном сайте/домене слать запросы на любые другие домены.

      Так вот, технология CORS в современных браузерах позволяет
      преодолеть same-origin-policy. Идея проста – пусть клиент 
      шлет Аякс-запрос к чужому серверу. Браузер добавит в 
      запрос особые заголовки с информацией о том, что запрос 
      с другого домена. На их основании сервер решит, как 
      обрабатывать такой запрос, и добавит особые заголовки 
      в ответ. Удобно, правда?

      Подробнее читайте:

        http://grishaev.me/cors
        https://enable-cors.org/
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

    ▪ Нативный плагин, чтобы обойтись без CORS

      Если CORS не реализован на сервере, есть нативный плагин:

        https://beta.ionicframework.com/docs/native/http/

      который выполняет HTTP-запросы в нативном слое, которым
      не требуется CORS.

    ▪ Чеклист на пригодность к CORS для сервера

      Многие веб-фреймворки могут иметь встроенную поддержку
      CORS, либо какие-то дополнения, например, как пакет
      cors для Express. Если такого нет, то надо выполнить
      следующие действия, чтобы CORS на сервере мог работать:

      1. Разрешить http://localhost:8080 в качестве origin
         (см. Access-Control-Allow-Origin)

          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin

      2. Разрешить любые необходимые HTTP-методы
         (см. Access-Control-Allow-Methods)

          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods

      3. Разрешить любые необходимые HTTP-заголовки
         (см. Access-Control-Allow-Headers)

          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers

      4. Убедитсья, что сервер может обрабатывать
         preflight requests.

          https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request

  • Конвертация запросов file:// в http:// для Cordova и Capacitor

    Приложения на Cordova или Capacitor хостятся на локальном
    HTTP-сервере и работаю на протоколе http://

    Некоторые плагины, однако, пытаются получить доступ
    к файлам устройства через протокол file://

    Чтобы избежать проблем, пути к файлам на устройстве 
    должны быть переписаны на http-протокол. Например,
    путь:

      file:///path/to/device/file

    надо переписать по такому шаблону:

      http://<host>:<port>/<prefix>/path/to/device/file

    ▪ Что на Cordova

      Для Cordova-приложений Ionic Web View Plugin предоставляет
      функцию для конвертирования файловых URL: 

        window.Ionic.WebView.convertFileSrc()

      И есть соответствующий нативный плагин:

        @ionic-native/ionic-webview.

    ▪ Что на Capacitor

      В Capacitor-приложениях, файловые URL конвертируются
      автоматически.

  • Реализации Web View на разных платформах

    ▪ WKWebView на iOS

      https://developer.apple.com/documentation/webkit/wkwebview

    ▪ Web View на Android

      https://developer.chrome.com/multidevice/webview/overview

> Про Ionic Storage /Ionic Storage/

  • Как работает Ionic Storage

    Ionic Storage позволяет легко сохранять пары key/value
    и JSON-объекты. По сути, это один API для нескольких
    реализаций хранилищ, которые оно поддерживает. В зависимости
    от платформы, оно само решает, какую реализацию хранилища
    целесообразнее всего использовать, и применяет её.

    Когда запускаешь приложение на нативной платформе, 
    Storage отдаёт предпочтение SQLite, как одной из
    наиболее широко-используемых и основанных на сохранении
    данных в файлы баз данных. 

    Если приложение работает на web или pwa, Storage будет
    пробовать использовать IndexedDB, WebSQL и Localstorage,
    именно в таком порядке.

    ▪ Список поддерживаемых Ionic Storage хранилищ

      В настоящий момент (конец июля 2018), отсортированный 
      список поддерживаемых хранилищь от лучшего к худшему:

      ▪ SQLite
      ▪ IndexedDB
      ▪ WebSQL
      ▪ LocalStorage

    ▪ Почему SQLite в приоритете?

      Одной важной причиной, по которой SQLite в приоритете,
      является то, что многие нативные платформы (iOS, например),
      в настоящее время, периодически и непредсказуемо чистят
      Local Storage (и IndexedDB), когда устройству начинает
      не хватать памяти. Чтобы избежать потери данных, лучше
      использовать хранищище с файлами, такое как SQLite.    

  • Использование Ionic Storage

    Если вы предпочитаете использовать SQLite, установите
    cordova-sqlite-storage plugin:

      ionic cordova plugin add cordova-sqlite-storage

    Затем установите соответствующий пакет (идёт по 
    умолчанию для Ionic-приложений >= V2):

      npm install --save @ionic/storage

    Затем, добавьте в список imports в вашем объявлении 
    NgModule. Например в src/app/app.module.ts:

      import { IonicStorageModule } from '@ionic/storage';

      @NgModule({
        declarations: [
          // ...
        ],
        imports: [
          BrowserModule,
          IonicModule.forRoot(MyApp),
          IonicStorageModule.forRoot()
        ],
        bootstrap: [IonicApp],
        entryComponents: [
          // ...
        ],
        providers: [
          // ...
        ]
      })
      export class AppModule {}

    Наконец, вставьте в ваше приложение:

      import { Storage } from '@ionic/storage';

      export class MyApp {
        constructor(private storage: Storage) { }

        ...

        // set a key/value
        storage.set('name', 'Max');

        // Or to get a key/value pair
        storage.get('age').then((val) => {
          console.log('Your age is', val);
        });
      }

  • Настройка Ionic Storage

    Storage Engine может быть настроен как конкретными
    свойствами движка хранилища, так и кастомными 
    опциями для передачи в LocalForge.
    Подробнее об этом:

      https://github.com/localForage/localForage#configuration

    *Примечание:

      Любые кастомные конфигурации будут смёржены с 
      дефолнтыми конфигурациями.

    import { IonicStorageModule } from '@ionic/storage';

    @NgModule({
      declarations: [...],
      imports: [
        IonicStorageModule.forRoot({
          name: '__mydb',
    driverOrder: ['indexeddb', 'sqlite', 'websql']
        })
      ],
      bootstrap: [...],
      entryComponents: [...],
       providers: [...]
    })
    export class AppModule { }

  • API для Ionic Storage

    ▪ constructor
      создать новый экземпляр хранилища

      Создать новый экземпляр хранилища. Какой драйвер будет
      использован, зависит от алгоритма этого метода, как он
      работает описано выше в пункте про хранилища. Доступные
      драйверы, в порядке приоритетности:

        ['sqlite', 'indexeddb', 'websql', 'localstorage']

    ▪ clear
      полностью очистить хранилище

      Внимание: операция тяжёлая! 
      Возвращает: промис, который разрешается, когда
                  хранилище успешно очищено.

    ▪ forEach
      пробежаться по всем парам key/value в хранилище

      Возвращает: промис, который разрешается, когда
                  итерирование завершено.

    ▪ get
      получить значение, связанное с указанным ключом

      Возвращает: промис, который разрешается, когда
                  значение успешно извлечено.

    ▪ keys
      список всех ключей в хранилище

      Возвращает: промис, который разрешается, когда 
                  список ключей успешно извлечён.


    ▪ length  
      кол-во ключей в хранилище

      Возвращает: промис, который разрешается, когда
                  кол-во ключей в хранилище пересчитано.

    ▪ ready
      готово ли хранилище

      Возвращает: промис, который разрешается, когда
                  хранилище готово к использованию.

    ▪ remove
      удаление из хранилище пары key/value по ключу

      Возвращает: промис, который разрешается, когда
                  значение удалено.
    
    ▪ driver
      получить имя используемого драйвера


А5. Компоненты Ionic'а
--------------------------------------

  # О компонентах Ionic'а
  # Список core-компонентов Ionic'а

    ▪ Action Sheet    | вылезающее снизу окошко со списом действий
    ▪ Alert           | модальное окошко с текстом, inputs, кнопками
    ▪ Badge           | бэйдж с цифрой, как правило, внутри элемента
    ▪ Button          | кастомизируемая кнопка, обычная/круглая/FAB/outline/...
    ▪ Card            | карточка с контентом
    ▪ Checkbox        | чекбокс с внершим видом: чекбокса, радиобуттона, переключателя
    ▪ DateTime        | date time picker
    ▪ Fab             | FABы (плавающие кнопки действия)
    ▪ Grid            | CSS-сеточка для формирования макате приложения (клон Bootstrap'овской)
    ▪ Infinite scroll | бесконечный скролл с триггерами от дистанции снизу/сверху документа
    ▪ Input           | обычный текстовый input
    ▪ List            | списочек, позволяет организовать разное в список
    ▪ Loading         | загрузочка, модальный экран загрузки со спинером
    ▪ Menu            | менюшечка обычная, появляется слева по кнопке или свайпу
    ▪ Modal           | модалочка полноэкранная, отображает временный UI
    ▪ Nav             | навигация между страницами приложения
    ▪ Popover         | тултипчик с расширенным функционалом
    ▪ Range           | слайдерок, для выбора значения из диапазона
    ▪ Refresher       | обновлялочка, тянешь вниз и контент обновляется
    ▪ Searchbar       | искалочка, input для поиска/фильтрации
    ▪ Select          | аналог обычного select с расширенным функционалом
    ▪ Slides          | слайдер страниц, с пролистыванием свайпами
    ▪ Spinner         | набор анимированных SVG-спинеров
    ▪ Tabs            | навигационные табы
    ▪ Toast           | тосты обыкновенные, быстро появляются и исчезают
    ▪ Virtual Scroll  | производительный скроллинг больших списков

--------------------------------------

> О компонентах Ionic'а

  Ionic-приложения разрабатываются из высокоуровневых
  блоков, которые мы занываем "компоненты".

  Компоненты позволяют вам быстро собирать интерфейсы
  ваших приложений. Ionic поставляется с набором
  core-компонентов, включая модалки, попапы и карточки.

  Ниже вы можете найти их список, краткие описания, 
  и небольшие примеры кода. Живые примеры работы
  компонентов смотрите в официальной документации
  Ionic.

  Подробные же их API можете посмотреть в главе
  Ionic API.

> Список core-компонентов Ionic'а

  • Action Sheet | вылезающее снизу окошко со списом действий 

    Action Sheet вылезает снизу-вверх через нижний край
    экрана, и выводит список доступных действий.

    Иногда, список действий можно использовать в качестве
    альтернативы для меню, хотя, использовать его для
    навигации не рекомендуется.

  • Alert | модальное окошко с текстом, inputs, кнопками

    Представляет собой нечто большее, чем классический
    алерт из браузеров.

    Алерт является прекрасным способом предложить пользователю
    выбрать конкретное действие, или список действий. Алерты
    могут содержать текст, инпуты и кнопки. Они могут помочь
    показать пользователю важную информацию, или потребовать
    от него принять одно или несколько решений.

    Алерты следует использовать только для быстрых действий,
    таких как верификация пароля, маленькое уведомление от
    приложения, или быстрый выбор опций.

  • Badge | бэйдж с цифрой, как правило, внутри элемента
    

    Компонент значок - маленький компонент, через который,
    обычно, пользователю сообщается какое-то цифровое
    значение. Чаще всего используется внутри какого-нибудь
    элемента.

    Пример использования, кол-во новых сообщений от 
    пользователей в чате. Есть список пользователей,
    где в каждом элементе списка появляется значок
    с кол-вом новых сообщений от данного пользователя.

    Пример кода:

      <!-- Default -->
      <ion-badge>99</ion-badge>

      <!-- Colors -->
      <ion-badge color="primary">11</ion-badge>
      <ion-badge color="secondary">22</ion-badge>
      <ion-badge color="tertiary">33</ion-badge>
      <ion-badge color="success">44</ion-badge>
      <ion-badge color="warning">55</ion-badge>
      <ion-badge color="danger">66</ion-badge>    

  • Button | кастомизируемая кнопка, обычная/круглая/FAB/outline/...

    Кнопки являются важным способом взаимодействовать с 
    приложением, и перемещаться по нему. Они должны
    ясно сообщать, какое действие последует после 
    нажатия на них. Компонент Button позволяет серьёзно
    кастомизировать кнопки, изменяя цвет, форму и размер.

    Поддерживаются разные кнопки:

    ▪ Круглые
    ▪ FAB
    ▪ Outline-кнопки
    ▪ ... и многие другие ...

    Пример кода:

      <ion-button shape="round" color="primary" fill="outline">Hello World</ion-button>
      <ion-button size="small">Small Button</ion-button>

  • Card | карточка с контентом

    Компонент карточка является отличным способом отображать
    важные кусочки контента, и быстро становится основным
    шаблоном проектирование приложений.

    Карточка может содержать картинки, кнопки, текст и 
    много чего ещё. 

    Можно использовать одну карточку, можно список карточек,
    а можно сетку карточек.

    Пример кода:

      <ion-card>
        <ion-img src="/assets/myImg.png"></ion-img>

        <ion-card-content>
          <ion-card-title>Hello World</ion-card-title>

          <p>The content for this card</p>
        </ion-card-content>
      </ion-card>    

  • Checkbox | чекбокс с внершим видом: чекбокса, радиобуттона, переключателя

    Чекбоксы могут быть использованы в ситуациях, когда 
    нужно дать пользователю возможность сделать бинарное
    решение. 

    Чекбокс обеспечивает четкую визуализацию выбора в 
    стиле true/false.

    ion-checkbox ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Вы моете использовать:

                        Какой внешний вид предпочитаете
    ▪ ion-checkbox    | похожий на чекбоксы
    ▪ ion-radio       | похожий на радиобуттоны
    ▪ ion-toggle      | похожий на переключатели

    Пример кода:

      <ion-checkbox color="primary" checked></ion-checkbox>
      <ion-checkbox color="secondary"></ion-checkbox>
      <ion-checkbox color="danger" checked></ion-checkbox>
      <ion-checkbox color="light"></ion-checkbox>
      <ion-checkbox color="dark" checked></ion-checkbox>

  • DateTime | date time picker

    DateTime позволяет пользователю легко выбрать дату и
    время. Будет выглядить нативно на iOS, а для прочих
    платформ будет использоваться Material Design.

    DateTime ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-label>Date</ion-label>
        <ion-datetime display-format="MM/DD/YYYY"></ion-datetime>
      </ion-item>

  • Fab | FABы (плавающие кнопки действия)

    FAB расшифровывается, как FLOATING ACTION BUTTON,
    или, плавающая кнопка действия.

    Представляет из себя круглую кнопку, которая выполняет
    главное, или наиболее часто используемое действие
    на экране.

    Она может находиться в разных местах на экране, 
    и, обычно, окрашена в отличающийся от фона цвет,
    чтобы привлекать внимание.

    Позиционирование FAB также осуществляется с помощью
    атрибутов horizontal, vertical и slot.

    Пример кода:

      <ion-fab vertical="bottom" horizontal="end" slot="fixed">
        <ion-fab-button>
          <ion-icon name="add"></ion-icon>
        </ion-fab-button>
      </ion-fab>

  • Grid | CSS-сеточка для формирования макате приложения (клон Bootstrap'овской)

    Сеточка является отличным инструментом для формирования
    макета вашего приложения. Она очень похожа на оную в 
    Bootstrap, я думаю, клон, и авторы Ionic об этом
    явно говорят в документации.

    Используйте сеточку, чтобы ваше приложение выглядело
    прекрасно как на ultra wide экране настольного 
    компьютера, так и на мелком экране 4-го айфончика.

    Пример кода:

      <ion-grid>
        <ion-row>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
        </ion-row>

        <ion-row>
          <ion-col size="6">
            ion-col [size="6"]
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
        </ion-row>
      </ion-grid>

  • Infinite scroll | бесконечный скролл с триггерами от дистанции снизу/сверху документа

    Бесконечный скролл позволяет вам осуществлять некое 
    действие, когда пользователь доскроллит до определенного
    расстояния снизу или сверху документа. 

    Например, можно подгружать следующие элементы списка,
    если таковые имеются, если пользователь доскроллил
    до его низа.

    Этот компонент можно кастомизировать различными поддерживаемыми
    индикаторами загрузки.

    Пример кода:

      <ion-infinite-scroll>
        <ion-infinite-scroll-content
          loadingSpinner="bubbles"
          loadingText="Loading more data...">
        </ion-infinite-scroll-content>
      </ion-infinite-scroll>    

  • Input | обычный текстовый input         

    Инпуты позволяют пользователям вводить данные.
    Чаще всего их можно увидеть в формах и диалогах.

    Input ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-input required type="text" placeholder="First Name"></ion-input>
      </ion-item>

  • List | списочек, позволяет организовать разное в список

    Компонент списочек используется для отображение строк
    с информацией. Например, списка контактов, плейлист,
    или меню.

    В списке можно выводить карточки, элементы списка,
    и много чего ещё.

    Списки также хорошо поддаются кастомизации, и совпадают
    по дизайну с нативными на Android и iOS.

    Пример кода:

      <ion-list>
        <ion-item>
          <ion-avatar slot="start">
            <img src="assets/img/avatar-finn.png"></img>
          </ion-avatar>
          <ion-label>
            <h2>Finn</h2>
            <h3>I'm a big deal</h3>
            <p>Listen, I've had a pretty messed up day...</p>
          </ion-label>
        </ion-item>
      </ion-list>    

  • Loading | загрузочка, модальный экран загрузки со спинером

    Загрузочка является модальным экраном загрузки, который
    обычно используют, когда пользователю надо заблокировать 
    на время выполения каких-то действий возможность 
    взаимодействовать с интерфейсом.

  • Menu | менюшечка обычная, появляется слева по кнопке или свайпу

    Менюшечка является общим навигационным шаблоном для
    приложений. Она может быть 3-х видов:

    ▪ Постоянно на экране
    ▪ Выезжать свайпом через левый край экрана
    ▪ Вызываться кнопкой меню

    Пример кода:

      <ion-menu side="start">
        <ion-header translucent>
          <ion-toolbar color="secondary">
            <ion-title>Menu</ion-title>
          </ion-toolbar>
        </ion-header>
      </ion-menu>

  • Modal | модалочка полноэкранная, отображает временный UI

    Модалочка полноэкранная наезжает на экран, полностью его
    перекрывая (по сути, напоминает отдельный экран в SPA),
    и представляет собой временный UI.

    Модалочки полноэкранные часто используются для страниц
    логина или регистрации, составления сообщений, и выбора
    опций.

  • Nav | навигация между страницами приложения

    Навигация позволяет пользователям перемещаться между
    страницами вашего приложения.

    Концепция анимации и навигации в Ionic следуют 
    общепринятым стандартам. 

    Навигация в Ionic также может адаптироваться к большим
    viewports, используя ion-split-pane.

    Пример кода:

      <ion-app>
        <ion-nav root="page-one"></ion-nav>
      </ion-app>

  • Popover | тултипчик с расширенным функционалом

    Тултипчик представляет из себя окошечко, которое появляется
    поверх контента, и выглядящее, как тултип с расширенным
    функционалом.

    Чаще всего тултипчик используют в следующих ситуациях:

    ▪ Показать больше информации о текущем экране
    ▪ Выбрать часто используемый инструмент или настройку
    ▪ Показать список действий для текущего экрана

  • Range | слайдерок, для выбора значения из диапазона

    Слайдерок является элементом формы, который позволяет
    пользователям выбирать значение из диапазона путём
    перемещения ползунка.

    Range ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-range>
          <ion-icon slot="start" size="small" name="sunny"></ion-icon>
          <ion-icon slot="end" name="sunny"></ion-icon>
        </ion-range>
      </ion-item>

  • Refresher | обновлялочка, тянешь вниз и контент обновляется

    Обновлялочка представляет pull-to-request функциональность
    компонента content. 

    Чаще всего используется для обновления контента страницы.
    То есть, вам надо потянуть вниз, появится спиннер, 
    после чего контент на странице обновится.

    Пример кода:

      <ion-content fullscreen>
        <ion-refresher slot="fixed">
          <ion-refresher-content></ion-refresher-content>
        </ion-refresher>
      </ion-content>

  • Searchbar | искалочка, input для поиска/фильтрации

    Искалочка используется для поиска или фильтрации
    элементов. Обычно, она используется внутри
    ion-toolbar.

    Пример кода:

      <ion-toolbar>
        <ion-searchbar></ion-searchbar>
      </ion-toolbar>

  • Select | аналог обычного select с расширенным функционалом

    Компонент ion-select похож на обычный HTML'ый элемент 
    <select>, однако, позволяет проще сортировать и выбирать
    необходимую опцию. Его внешний вид совпадает с 
    select inputs на Android и iOS.

    Select ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-label>Hair Color</ion-label>
        <ion-select value="brown" ok-text="Okay" cancel-text="Dismiss">
          <ion-select-option value="brown">Brown</ion-select-option>
          <ion-select-option value="blonde">Blonde</ion-select-option>
          <ion-select-option value="black">Black</ion-select-option>
          <ion-select-option value="red">Red</ion-select-option>
        </ion-select>
      </ion-item>

  • Slides | слайдер страниц, с пролистыванием свайпами

    Слайдер позволяет легко делать функционал, основанный
    на слайдах, такой как галереи, туториалы. А также
    приложения, в которых есть возможно пролистывать
    страницы вправо-влево (например, калькулятор калогий
    ХиКи).

    Пример кода:

      <ion-slides pager="true">
        <ion-slide>
          <h1>Slide 1</h1>
        </ion-slide>

        <ion-slide>
          <h1>Slide 2</h1>
        </ion-slide>

        <ion-slide>
          <h1>Slide 3</h1>
        </ion-slide>
      </ion-slides>

  • Spinner | набор анимированных SVG-спинеров

    Компонент ion-spinner представляет собой набор
    анимированных SVG-спинеров. 

    Вы можете применять спинер, чтобы дать пользователям
    понять, что происходит какая-то активность.

    Пример кода:

      <ion-spinner></ion-spinner>
      <ion-spinner name="lines"></ion-spinner>

  • Tabs | навигационные табы

    Этот компонент включает навигационные табы, которые
    являются стандартным навигационным шаблоном в 
    современных приложениях.

    Табы могут отображать иконку и/или надпись, чтобы 
    давать понять пользователю, куда он попадёт, если
    нажмёт.

    По умолчанию, навигационны табы расположены в нижней
    части приложения, что соответствует руководствам
    Material Design и iOS Design. Однако, если надо,
    их можно поместить и сверху.

    Пример кода:

      <ion-tabs>
        <ion-tab label="Music" icon="musical-note"></ion-tab>
        <ion-tab label="Profile" icon="person"></ion-tab>
        <ion-tab label="people" icon="people"></ion-tab>
      </ion-tabs>

  • Toast | тосты обыкновенные, быстро появляются и исчезают

    Компонент тосты позволяет уведомить пользователя 
    коротким сообщением. Они быстро появляются и исчезают.

    Тосты могут появлятсья сверху, снизу, посередине, 
    иметь кнопку закрытия тоста.

    На планшетах или больших экранах настольных компьютеров
    или ноутбуков, ширина тостов не будет 100%, и они будут
    появляться по центру.

  • Virtual Scroll | производительный скроллинг больших списков

    Элемент виртуальный скролл является виртуальным списком,
    который позволяет вам обеспечить высокую производительность
    при скролле через ГИГАНТСКИЕ списки.

    Суть его состоит в том, что он отрисовывает лишь те 
    элементы, которые в текущий момент видимы на экране.

    Вообще, это известная техника для повышения производительности
    работы с большими списками на слабомощных мобильных устройствах.


А6. Организация layout'а в Ionic-приложении
--------------------------------------

  # Примеры layout'ов

    ▪ header, content and footer
      ▪ header + content
      ▪ footer + content
      ▪ header + footer + content

    ▪ header, content, tabs
    ▪ header, content, menu
    ▪ Split pane layouts (разные layout'ы в зависимости от ширины экрана)

  # Отзывчивая сеточка (responsive grid)

    ▪ Введение про сеточку в Ionic
    ▪ Как работает сеточка в Ionic
    ▪ Размеры сеточки, брейкпоинты: xs, sm, md, lg, xl
    ▪ Атрибуты сеточки
      
      ▪ no-padding    | убрать padding ячеек
      ▪ fixed         | настроить max ширину сетки

    ▪ CRUD-настройка брейкпоинтов
    ▪ Управление шириной колонок
      ▪ По умолчанию, ширина всех колонок в row одинакова
      ▪ Изменить ширину одной колонки в row
      ▪ Основанная на контенте ширины для колонки в row

    ▪ Управление адаптивностью
      ▪ Атрибут size для изменения ширины колонки для всех устройств
      ▪ Комбинация size и size-<bp> для перехода от стека к горизонтальным колонкам в зависимости от ширины экрана

    ▪ Управление взаимным порядком колонок
      ▪ Управление отступами (offset)
        ▪ Отступы без брейкпоинтов
        ▪ Отступы с брейкпоинтами      
      ▪ Управление взаимным порядком (push, pull)
        ▪ Взаимный порядок без брейкпоинтов
        ▪ Взаимный порядок с брейкпоинтами    

    ▪ Выравнивание колонок
      ▪ Вертикальное выравнивание колонок
        ▪ Относительное выравниваниевсех cols в row
        ▪ Персональное выравнивание отдельных col в row
      ▪ Горизонтальное выравнивание колонок

    ▪ Кастомизация сеточки

      ▪ --ion-grid-columns            | [12] изменение кол-ва колонок
      
      ▪ --ion-grid-padding            | [5px] изменение padding контейнера сетки
      ▪ --ion-grid-padding-xs         | [5px] изменение padding контейнера сетки для xs
      ▪ --ion-grid-padding-sm         | [5px] изменение padding контейнера сетки для sm
      ▪ --ion-grid-padding-md         | [5px] изменение padding контейнера сетки для md
      ▪ --ion-grid-padding-lg         | [5px] изменение padding контейнера сетки для lg
      ▪ --ion-grid-padding-xl         | [5px] изменение padding контейнера сетки для xl

      ▪ --ion-grid-width-xs           | [100%]   изменение ширины сетки для xs
      ▪ --ion-grid-width-sm           | [540px]  изменение ширины сетки для sm
      ▪ --ion-grid-width-md           | [720px]  изменение ширины сетки для md
      ▪ --ion-grid-width-lg           | [960px]  изменение ширины сетки для lg
      ▪ --ion-grid-width-xl           | [1140px] изменение ширины сетки для xl

      ▪ --ion-grid-column-padding:    | [5px] изменение padding колонки
      ▪ --ion-grid-column-padding-xs  | [5px] изменение padding колонки для xs
      ▪ --ion-grid-column-padding-sm  | [5px] изменение padding колонки для sm   
      ▪ --ion-grid-column-padding-md  | [5px] изменение padding колонки для md  
      ▪ --ion-grid-column-padding-lg  | [5px] изменение padding колонки для lg  
      ▪ --ion-grid-column-padding-xl  | [5px] изменение padding колонки для xl  

  # CSS-инструменты для управления сеткой

    См. https://beta.ionicframework.com/docs/layout/css-utilities

--------------------------------------

> Примеры layout'ов

  • Header, Content and Footer

    ▪ header + content

      Самый простой возможный layout состоит из header и 
      content. Большинство страниц в приложении обычно
      имеют и то, и другое. Но заголовок не требуется
      для использования контента.

      Пример кода:

        <ion-app>
          <ion-header>
            <ion-toolbar>
              <ion-title>Header</ion-title>
            </ion-toolbar>
          </ion-header>

          <ion-content padding>
            <h1>Main Content</h1>
          </ion-content>
        </ion-app>      

    ▪ footer + content

      Как в можете увидеть выше, toolbar в header появляется
      на экране над контентом. Но иногда приложению требуется
      тулбар под контентом, для этого и используют footer.

      Пример кода:

        <ion-app>
          <ion-content padding>
            <h1>Main Content</h1>
          </ion-content>

          <ion-footer>
            <ion-toolbar>
              <ion-title>Footer</ion-title>
            </ion-toolbar>
          </ion-footer>
        </ion-content>

    ▪ header + footer + content

      Никто не мешает комбинировать header и footer
      вместе, получая toolbar'ы как над, так и под
      контентом.

      Пример кода:

        <ion-app>
          <ion-header>
            <ion-toolbar>
              <ion-title>Header</ion-title>
            </ion-toolbar>
          </ion-header>

          <ion-content padding>
            <h1>Main Content</h1>
          </ion-content>

          <ion-footer>
            <ion-toolbar>
              <ion-title>Footer</ion-title>
            </ion-toolbar>
          </ion-footer>
        </ion-content>

  • header, content, tabs

    Этот layout состоит из заголовка, контента и табов
    снизу. Каждый таб может содержать статический контент,
    или навигационный стек, используя router-outlet или
    ion-nav.

    Пример кода:

      <ion-app>
        <ion-tabs>
          <ion-tab label="Home" icon="home">
            <ion-header>
              <ion-toolbar>
                <ion-title>Home</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Home Content</h1>
            </ion-content>
          </ion-tab>

          <ion-tab label="Map" icon="map">
            <ion-header>
              <ion-toolbar>
                <ion-title>Map</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Map Content</h1>
            </ion-content>
          </ion-tab>

          <ion-tab label="Camera" icon="camera">
            <ion-header>
              <ion-toolbar>
                <ion-title>Camera</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Camera Content</h1>
            </ion-content>
          </ion-tab>
        </ion-tabs>
      </ion-app>    

  • header, content, menu

    Это стандартный layout в мобильных приложениях, в нём
    есть возможность открытия/закрытия меню нажатием на 
    кнопку, или свайпом через левый край экрана.

    Чаще всего боковые меню используются для навигации,
    но могут содержать и какой-то контент.

    Пример кода:

      <ion-app>
        <ion-menu>
          <ion-header>
            <ion-toolbar color="primary">
              <ion-title>Menu</ion-title>
            </ion-toolbar>
          </ion-header>

          <ion-content>
            <ion-list>
              <ion-list-header>
                Navigate
              </ion-list-header>
              <ion-menu-toggle auto-hide="false">
                <ion-item button>
                  <ion-icon slot="start" name='home'></ion-icon>
                  <ion-label>
                    Home
                  </ion-label>
                </ion-item>
              </ion-menu-toggle>
            </ion-list>
          </ion-content>
        </ion-menu>

        <ion-page class="ion-page" main>
          <ion-header>
            <ion-toolbar>
              <ion-buttons slot="start">
                <ion-menu-toggle>
                  <ion-button>
                    <ion-icon slot="icon-only" name="menu"></ion-icon>
                  </ion-button>
                </ion-menu-toggle>
              </ion-buttons>
              <ion-title>Header</ion-title>
            </ion-toolbar>
          </ion-header>
          <ion-content padding>
            <h1>Main Content</h1>
            <p>Click the icon in the top left to toggle the menu.</p>
          </ion-content>
        </ion-page>
      </ion-app>

      <ion-menu-controller></ion-menu-controller>

  • Split pane layouts (разные layout'ы в зависимости от ширины экрана)

    Split pane layouts имеют более сложную структуру, потому
    что они могут комбинировать все предыдущие layouts.

    По сути, они работают, как адаптивный дизайн. Если ширина
    больше определённого значения, то показывается дополнительный
    элемент (например, постоянное мнею слева). А если меньше,
    то не показывается.

    По умолчанию, триггерная точка установлена на 768px
    (md breakpoint), но это можно настраивать через св-во 
    when.

    Ниже можно увидеть код примера, в котором меню видимо
    для sm-экранов (576px) и больше.

    Важно отметить, что элемент с атрибутом main будет 
    считаться главным контентом, который всегда видим. 
    Это может быть любой элемент, включая ion-nav, 
    ion-router-outlet, или ion-tabs.

    Пример кода:

      <ion-app>
        <ion-split-pane when="sm">
          <ion-menu>
            <ion-header>
              <ion-toolbar color="primary">
                <ion-title>Menu</ion-title>
              </ion-toolbar>
            </ion-header>

            <ion-content>
              <ion-list>
                <ion-list-header>
                  Navigate
                </ion-list-header>
                <ion-menu-toggle auto-hide="false">
                  <ion-item button>
                    <ion-icon slot="start" name='home'></ion-icon>
                    <ion-label>
                      Home
                    </ion-label>
                  </ion-item>
                </ion-menu-toggle>
              </ion-list>
            </ion-content>
          </ion-menu>

          <ion-page class="ion-page" main>
            <ion-header>
              <ion-toolbar>
                <ion-buttons slot="start">
                  <ion-menu-toggle>
                    <ion-button>
                      <ion-icon slot="icon-only" name="menu"></ion-icon>
                    </ion-button>
                  </ion-menu-toggle>
                </ion-buttons>
                <ion-title>Header</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Main Content</h1>
            </ion-content>
          </ion-page>

        </ion-split-pane>
      </ion-app>

> Отзывчивая сеточка (responsive grid)

  • Введение про сеточку в Ionic

    Сеточка является мощной flexbox-системой, ориентированной
    на мобильные устройства. Она позволяет организовывать
    кастомные layout'ы.

    Основными элементами сеточки являются эти трое:

    ▪ ion-grid    | сеточка
    ▪ ion-row     | строка
    ▪ ion-col     | колонка

    Колонки занимают всю строку по ширине. В одной строке
    может быть до 12 колонок. В рамках стратегии адаптивного
    дизайна, на определённых контрольных точках, зависимых
    от ширины окна браузера, кол-во колонок может становиться
    меньше или больше. Кол-во колонок можно настраивать через
    CSS.

  • Как работает сеточка в Ionic

    ▪ Пример сеточки (без атрибутов)

      <ion-grid>
        <ion-row>
          <ion-col>
            <div>
              1 of 3
            </div>
          </ion-col>
          <ion-col>
            <div>
              2 of 3
            </div>
          </ion-col>
          <ion-col>
            <div>
              3 of 3
            </div>
          </ion-col>
        </ion-row>
      </ion-grid>    

    ▪ Grid работает, как контейнер для rows и cols.
      Grid по умолчанию занимает полную ширину их 
      контейнера, но добавление атрибута fixed позволяет
      задать свою ширину для каждого из доступных размеров
      экрана (подробнее ниже).

    ▪ Rows - горизонтальные группа элементов col. 

    ▪ Контент надо класть в cols. Только cols можгут
      быть непосредственными детьми элементов rows.

    ▪ Атрибут "size-<breakpoint>" у col обозначает, сколько
      колонок заёмет данный col, учитывая, что в row 
      всего 12 колонок.

      Например, если назначить какому-то col атрибут 
      size="4", то он займёт 4 из 12 колонок, то есть,
      1/3 от ширины сетки.

    ▪ Cols без явно заданного значения для size автоматически
      получают равную ширину. Например, если в row есть 4 
      cols, то каждая col получит 25% ширины.

    ▪ Ширина cols всегда задаётся в %, поэтому они всегда
      тянутся и подстраиваются под ширину родительского
      элемента.

    ▪ У cols есть padding между ними. Но его можно удалить,
      добавив атрибут no-padding в элемент grid.

    ▪ У сетки есть 5 брейкпоинтов для различных ширин экрана:
      xs, sm, md, lg, lx. Подробнее о них ниже.

    ▪ Брейкпоинт сетки применяется к любой ширине, которая
      >= его собственной. Например, size-sm применяется
      к sm, md, lg, lx (если для md, lg, lx не указано
      иное, конечно).

    ▪ Сетку можно легко кастомизировать с помощью 
      CSS-переменных (см.ниже).

  • Размеры сеточки, брейкпоинты: xs, sm, md, lg, xl

    По умолчанию, сеточка занимает 100% ширины. Чтобы установить
    основанную на размере экрана ширину сеточки, используйте
    атрибут fixed. Ширина сеточки для каждого брейкпоинта 
    определён в CSS-переменныэ "--ion-grid-width-<breakpoint>".
    Подробнее об этом ниже.

    xs    100%      Не ставьте ширину сетки для xs экранов.
    sm    540px     Ставьте ширину сетки 540px, когда min-width: 576px
    md    720px     Ставьте ширину сетки 720px, когда min-width: 768px
    lg    960px     Ставьте ширину сетки 960px, когда min-width: 992px
    xl    1140px    Ставьте ширину сетки 1140px, когда min-width: 1200px

  • Атрибуты сеточки

    По умолчанию, сеточка занимает 100% ширины экрана, а 
    её ячейки имеют padding. С помощью нижеописанных атрибутов
    это можно менять.

    ▪ no-padding | убрать padding ячеек

      Удаляет padding из сеточки, чтобы между ячейками
      его не было.

    ▪ fixed | настроить max ширину сетки

      Позволяет настроить max ширину сетки на основе
      ширины экрана, используя xs, sm, md, lg, xl.

  • CRUD-настройка брейкпоинтов

    Брейкпоинты по умолчанию определены в CSS-переменных
    --ion-grid-breakpoints. Всё это можно легко 
    кастомизировать, задать другие значения для
    брейкпоинтов, переименовывать их, добавлять/удалять
    брейкпоинтов. Подробнее см.ниже.

                    Prefixes
                    ----------------------------------------
    Name    Value   With      Offset      Push      Pull
    --------------------------------------------------------
    xs      0       size-     offset-     push-     pull
    sm      576px   size-sm-  offset-sm-  push-sm-  pull-sm-
    md      768px   size-md-  offset-md-  push-md-  pull-md-
    lg      992px   size-lg-  offset-lg-  push-lg-  pull-lg-
    xl      1200px  size-xl-  offset-xl-  push-xl-  pull-xl-

  • Управление шириной колонок

    ▪ По умолчанию, ширина всех колонок в row одинакова

      По умолчанию, колонки в row занимают равную ширину
      для всех устройств и размеров экрана.

      |--|--|--|--|--|--|--|--|--|--|--|--|
      |-----|-----|-----|-----|-----|-----|

      Пример и код:

        |--1 из 3 --|--2 из 3 --|--3 из 3 --|
        |---- 1 из 2  ----|--- -2 из 2  ----|

        <ion-grid>
          <ion-row>
            <ion-col>
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col>
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Изменить ширину одной колонки в row

      Если установить вручную ширину для одной конкретной
      колонки, прочие колонки автоматически подстроятся,
      но их ширины останутся равными.

      Пример и код:

        |-1 из 3-|-----2 из 3-----|--3 из 3-|
        |-1 из 3---|---2 из 3---|----3 из 3-|

        <ion-grid>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size="8">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size="6">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Основанная на контенте ширины для колонки в row

      Если установить значение size-<breakpoint> в auto,
      ширина колонки будет подстраиваться под контент
      в ней. Такую колонку называют колонокой переменной
      ширины.

      Колонка, следующая сразу за колонкой переменной
      ширины, будет автоматически изменять свою ширину,
      чтобы подстроиться под последнюю.

      Пример и код:

        |--1 из 3 --|--content--|--3 из 3 --|
        |--1 из 3 --|--content 123--|-3 из 3|

        <ion-grid>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size="auto">
              <div>
                Variable width content
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
          <ion-row>
            <ion-col>
              <div>
                1 of 4
              </div>
            </ion-col>
            <ion-col>
              <div>
                2 of 4
              </div>
            </ion-col>
            <ion-col size="auto">
              <div>
                <ion-input placeholder="Variable width input"></ion-input>
              </div>
            </ion-col>
            <ion-col>
              <div>
                4 of 4
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

  • Управление адаптивностью

    ▪ Атрибут size для изменения ширины колонки для всех устройств

      Чтобы изменять ширину отдельных колонок, используйте
      атрибут size. Его значение может быть от 1 до 12. 
      Оно определяет, сколько колонок (из 12) данная
      колонка будет занимать.

      Пример и код:

        |---1/4----|-2/4--|--3/4-|----4/4---|

        <ion-grid>
          <ion-row>
            <ion-col size="4">
              <div>
                1 of 4
              </div>
            </ion-col>
            <ion-col size="2">
              <div>
                2 of 4
              </div>
            </ion-col>
            <ion-col size="2">
              <div>
                3 of 4
              </div>
            </ion-col>
            <ion-col size="4">
              <div>
                4 of 4
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Комбинация size и size-<bp> для перехода от стека к горизонтальным колонкам в зависимости от ширины экрана

      Используя комбинацию атрибутов size и size-<breakpoint>,
      можно организовать адаптивный эффект перехода от
      расположения колонок в виде вертикального стека
      (актуально для небольших экранов), к обачному горизонтальному
      расположению колонок в ряду, при расширении экрана.

      Пример вертикального стека (для узких экранов):

        |----1/3----|
        |----2/3----|
        |----3/3----|

      Пример горизонтального расположения тех же колонок 
      (для более широких экранов):

        |----1/3----|----2/3----|----3/3----|

      Пример кода:

      <ion-grid>
        <ion-row>
          <ion-col size="12" size-sm>
            <div>
              1 of 4
            </div>
          </ion-col>
          <ion-col size="12" size-sm>
            <div>
              2 of 4
            </div>
          </ion-col>
          <ion-col size="12" size-sm>
            <div>
              3 of 4
            </div>
          </ion-col>
          <ion-col size="12" size-sm>
            <div>
              4 of 4
            </div>
          </ion-col>
        </ion-row>
      </ion-grid>      

  • Управление взаимным порядком колонок

    ▪ Управление отступами (offset)

      С помощью атрибута offset можно управлять отступами
      колонок. Этот атрибут увеличивает margin left
      указанной колонки на указанное кол-во колонок
      n/12.

      ▪ Отступы без брейкпоинтов

        Например, в следующей сетке последняя колонка получила
        offset=3, в результате чего, находится от первой 
        колонки на расстоянии 3-х колонок.

                  offset3
        |--1/2---|        |--2/2---|

        <ion-grid>
          <ion-row>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3" offset="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

      ▪ Отступы с брейкпоинтами

        Также для offset, как и для size, можно использовать
        брейкпоинты, чтобы в зависимости от ширины экрана
        манипулировать отступами:

        <ion-grid>
          <ion-row>
            <ion-col size-md="3">
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size-md="3">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col size-md="3" offset-md="3">
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Управление взаимным порядком (push, pull)

      С помощью атрибутов push и pull можно управлять
      взаимным порядком колонок. Эти атрибуты смещают
      колонки вправо или влево на указанное число
      колонок n/12. 

      ▪ Взаимный порядок без брейкпоинтов

        В этом примере мы меняем местами колонки
        "1 of 2" и "2 of 2".

        <ion-grid>
          <ion-row>
            <ion-col size="9" push="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3" pull="9">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

      ▪ Взаимный порядок с брейкпоинтами

        <ion-grid>
          <ion-row>
            <ion-col size-md="6" push-md="3">
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size-md="3" push-md="3">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col size-md="3" pull-md="9">
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

  • Выравнивание колонок

    ▪ Вертикальное выравнивание колонок

      ▪ Относительное выравниваниевсех cols в row

        Все cols в row можно выровнять по 
        верхнему/нижнему краю, или по центру. Для этого
        на весь row применяют атрибуты:

        ▪ align-items-start
        ▪ align-items-center
        ▪ align-items-end

          Подробнее: 
          https://beta.ionicframework.com/docs/layout/grid/#customizing-the-grid

        Пример:justify-content-start

          <ion-grid>
            <ion-row align-items-start>
              <ion-col>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>

            <ion-row align-items-center>
              <ion-col>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>

            <ion-row align-items-end>
              <ion-col>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>
          </ion-grid>

      ▪ Персональное выравнивание отдельных col в row

        Аналогично, каждый col можно выравнивать по 
        верхнему/нижнему краю, или по центру. Для этого
        на каждом col используются атрибуты:

        ▪ align-self-start 
        ▪ align-self-center
        ▪ align-self-end

          Подробнее: 
          https://beta.ionicframework.com/docs/layout/grid/#customizing-the-grid

        Пример:

          <ion-grid>
            <ion-row>
              <ion-col align-self-start>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col align-self-center>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col align-self-end>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>
          </ion-grid>

    ▪ Горизонтальное выравнивание колонок

      Все cols могут горизонтально выравниваться внутри
      row, для этого можно на него применять атрибуты:

      ▪ justify-content-start
      ▪ justify-content-center
      ▪ justify-content-end
      ▪ justify-content-around
      ▪ justify-content-between

        Подробнее: 
        https://beta.ionicframework.com/docs/layout/grid/#customizing-the-grid

      Пример:

        <ion-grid>
          <ion-row justify-content-start>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-center>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-end>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-around>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-between>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
        </ion-grid> 

  • Кастомизация сеточки

    С помощью CSS-переменных можно производить кастомизацию
    сеточки. В оглавлении этого пункта перечислены 
    соответствующие переменные.


А7. Тематизация
--------------------------------------
  
  # Ссылки
  # Основы тематизации в Ionic

    ▪ Цвета
    ▪ Стандарты платформы
    ▪ CSS-переменные
    ▪ Брэндинг

  # Стили платформ

    ▪ Режимы Ionic'а (modes)
    ▪ Перезапись платформо-зависимых стилей компонентов

  # CSS-переменные для кастомизации Ionic-компонентов

    ▪ Установка значений для CSS-переменных
      ▪ Глобальные переменные
      ▪ Переменные селекторов
      ▪ Установка значений через JavaScript

    ▪ Извлечение значений CSS-переменных
      ▪ Используя CSS: css-функция var()
      ▪ Используя JavaScript: функция getPropertyValue()

  # Полезный инструмент: генератор цвета
  # Продвинутая тематизация

    ▪ Язык цвета

      ▪ Многослойные цвета
      ▪ Цвета приложения
      ▪ Ступенчатые цвета
      ▪ Цветовая карта
      ▪ Многослойные цвета в цветовой карте
      ▪ Alpha-проблема

    ▪ Применение стилей
  
--------------------------------------

> Ссылки

  • Генератор цвета
      https://beta.ionicframework.com/docs/theming/color-generator

  • Ionic CSS variables
      https://beta.ionicframework.com/docs/theming/css-variables/

  • Конфиг приложения, где можно выбрать режимы для платформ
      https://beta.ionicframework.com/api/config/Config

> Основы тематизации в Ionic

  Ionic Framework построен таким образом, чтобы быть
  чистым листом, который можно легко кастомизировать
  и модифицировать под свой бренд, при этом, оставаясь
  верным стандартам на разных платформах.

  Тематизация Ionic-приложений теперь легче лёгкого.
  Ведь сам фреймворк построен на CSS, имеет
  CSS-переменные, и идёт с предваретльно обработанными
  стилями по умолчанию, которые очень легко менять.

  • Цвета

    У Ionic'а есть 9 разных цветов, которые можно использовать,
    чтобы изменить цветовую схему многих компонентов.

    По факту, каждый цвет является коллекцией многих свойств,
    включая shade и tint, используемых по всему Ionic'у.

    При изменении цвета, важно установить все связанные с
    этим свойства. Это легко можно делать с помощью 
    инструмента "генератор цвета" (см.выше в ссылках).
    Ну, или можно вручную всё прописать, но это сложнее.

    Вот именя 9 цветов, которые используются в Ionic:

    ▪ Primary
    ▪ Secondary
    ▪ Tertiary
    ▪ Success
    ▪ Warning
    ▪ Danger
    ▪ Dark
    ▪ Medium
    ▪ Light

  • Стандарты платформы

    Ionic-компоненты адаптируют свои внешний вид и поведение
    в зависимости от платформы, на которой запущено приложение.

    Разработчики Ionic называют это свойство "Platform Continuity",
    или "Непрерывность Платформы".

    Это позволяет разработчикам создавать приложения, которые
    используют один и тот же код на разных платформах, но которые
    все ещё выглядят нативно на каждой из платформ.

    У Ionic'а есть 2 РЕЖИМА, которые используются для кастомизации
    внешнего вида компонентов, в зависимости от платформы:

    ▪ ios     | apple'овский стиль
    ▪ md      | material design

    Для каждой платформы назначен режим по умолчанию. 
    Для Apple'овских платформ ios, для остальных md.
    Однако, это легко можно менять в проекте.
    Подробнее об этом ниже, в главе "Стили платформ".

  • CSS-переменные

    Стили всех Ionic-компоненты используют CSS-переменные.
    Они добавляют динамичности изначально статичному CSS.
    Чтобы оно работало, нужен CSS-препроцессор SASS.

    Внешний вид приложения можно легко менять, меняя
    значения соответствующих CSS-переменных.

  • Брэндинг

    Если у вашего бренда есть какая-то особая цветовая 
    схема, то с помощью настройки 9 переменных цветов
    Ionic (описанных выше), вы можете полностью 
    кастомизировать цветовую схему приложения.

    Подробнее об этом смотрите ниже, в пункте
    "Продвинутая тематизация"

> Стили платформ

  Ionic-компоненты адаптируют свои внешний вид и поведение
  в зависимости от платформы, на которой запущено приложение.  

  Это позволяет один раз написать приложение, которое 
  на каждой платформе выглядит и ощущается нативным.

  ▪ Режимы Ionic'а (modes)

    Ionic использует режимы (modes) для кастомизации внешнего
    вида компонентов. Для каждой платформы назначен режим
    по умолчанию, но это можно изменить для проекта. Ниже
    показано, для какой платформы какой режим по умолчанию
    стоит:

      Платформа   Режим   Описание
      ----------------------------
      ios         ios     ios-стили для iphone, ipad, ipod
      android     md      material design для android-устройств 
      core        md      material design для не-ios-android платформ

    Например, при запуске приложения на android оно получит
    режим md по умолчанию. Элемент <ion-app> будет иметь
    class="md" и все компоненты будут использовать Material
    Design:

      <ion-app class="md">

  ▪ Перезапись платформо-зависимых стилей компонентов

    Каждый Ionic-компонент имеет до 3-х файлов* со стилями.
    Вот пример файлов стилей для компонента "badge":

      badge
      ├── badge.ios.scss                  # ios mode styles
      ├── badge.ios.vars.scss             # ios mode variables
      ├── badge.md.scss                   # md mode styles
      ├── badge.md.vars.scss              # md mode variables
      ├── badge.scss                      # shared styles for the badge
      └── badge.vars.scss                 # shared variables for the badge

      *Примечание:

        Не все компоненты имеют разные стили для разных
        режимов. Как следствие, не все компоненты имеют
        именно показанный выше набор стилевых файлов,
        какие-то из них могут отсутствовать.

    Модифицировать стили любого компонента можно путём 
    добавление соответствующего класса в элемент ion-app.

    Например, хотим мы, чтобы во всех компонентах badge
    на платформе ios текст был написан большими буквами.
    Для этого создать такой класс:

      .ios .badge {
        text-transform: capitalize;
      }

    Режим также скомбинирован с именем компонента, и затем
    добавлен в качестве класса в каждый компонент. Написанное
    выше может быть упрощено, и применено только к ios-bagdes:

      .badge-ios {
        text-transform: capitalize;
      }

    Есть также много CSS-переменных, которые можно использовать
    для перезаписывания стилей. Используя тот же пример выше,
    мы можем изменить ios-badges, используя CSS-переменную
    --badge-ios-text-transform

      :root {
        --badge-ios-text-transform: capitalize;
      }

    Список всех CSS-переменных Ionic доступен по ссылке
    выше, в ссылках.

> CSS-переменные для кастомизации Ionic-компонентов

  Ionic-компоненты построены с использованием CSS-переменных,
  чтобы можно было легко кастомизировать стили приложения.

  CSS-переменные позволяют хранить значение в одном месте,
  а затем использовать его во многих других местах. 

  Также, они позволяют изменять CSS динамически, прямо во
  время выполнения приложения, что ранее требовало наличия
  препроцессора.

  С помощью CSS-переменных легче лёгкого изменять стили
  Ionic-компонентов под свои брендовые нужды.

  ▪ Установка значений для CSS-переменных

    ▪ Глобальные переменные

      Значения для CSS-переменных можно установить глобально 
      в приложении в селекторе :root

        :root {
          --ion-color-primary: #00ff00;
        }

    ▪ Переменные селекторов

      Чтобы установить значение для CSS-переменной для 
      определённого компонента, добавьте его в этот
      селектор:

        .my-fancy-button {
          --ion-color-primary: #00ff00;
        }

    ▪ Установка значений через JavaScript

      Значения CSS-переменных можно также изменять
      с помощью JavaScript, используя setProperty()

        const el = document.querySelector('.my-fancy-button');
        el.style.setProperty('--ion-color-primary', '#ff0000');

  ▪ Извлечение значений CSS-переменных

    ▪ Используя CSS: css-функция var()

      CSS-функция var() позволяет извлечь значение CSS-переменной,
      указывая сколько угодно fallback-значений (на случай, если 
      значение CSS-переменной будет отсутствовать).

      В примере выше, значением для background-color будет установлено
      значение переменной --ion-color-primary, либо #00ff00,
      в случае, если не удастся его извлечь:

        .my-fancy-button {
          background-color: var(--ion-color-primary, #00ff00);
        }

    ▪ Используя JavaScript: функция getPropertyValue()

      Значение CSS-переменной можно изслечь в JavaScript
      с помощью функции getPropertyValue():

        const el = document.querySelector('.my-fancy-button');
        const color = el.style.getPropertyValue('--ion-color-primary');

> Полезный инструмент: генератор цвета

  На сайте Ionic есть очень полезные инструмент, который
  называется "Генератор цвета". Он позволяет визуально 
  создавать цветовые палитры для UI вашего приложения,
  и генерирует набор CSS-переменных для результатов. 
  Этот код можно скопировать к себе в приложение, и 
  изменить таким образом его цветовую схему.

  См.ссылку на генератор цвета выше, в ссылках.

> Продвинутая тематизация

  Основанная на CSS тематизация позволяет быстро кастомизировать
  цвета, загрузив CSS-файл, или изменив несколько CSS-свойств.

  • Язык цвета

    В Ionic цвета можно разбить на 2 группы:

    ▪ Цвета приложения  | --ion-color-primary
    ▪ Цветовая карта    | --ion-color-secondary

    Цветовая карта - абстрактная коллекция цветов, которая
    может быть использована во всём приложении. 

    ▪ Многослойные цвета

      ▪ contrast  | видимый относительно базового цвета
      ▪ shade     | немного более тёмный цвет относительно базового
      ▪ tint      | немного более светлый цвет относительно базового
      ▪ RGB       | RGB-версия основного цвета, позволяет применить opacity

      Например, secondary-цвет использует следующие
      CSS-свойства:

        --ion-color-secondary: #0cd1e8;
        --ion-color-secondary-rgb: 12,209,232;
        --ion-color-secondary-contrast: #000000;
        --ion-color-secondary-contrast-rgb: 0,0,0;
        --ion-color-secondary-shade: #0bb8cc;
        --ion-color-secondary-tint: #0bb8cc;

      Когда secondary применяется к кнопке, используется
      не только базовый цвет, но и contrast для текста,
      shade и tint для разных состояний кнопки.

    ▪ Цвета приложения

      Имена цветов приложения обычно соответствуют сфере их
      применения в компоненте. Ниже представлен список
      top-level цветов приложения:

        --ion-backdrop-color
        --ion-overlay-background-color
        --ion-background-color
        --ion-border-color
        --ion-box-shadow-color
        --ion-text-color
        --ion-tabbar-background-color
        --ion-tabbar-border-color
        --ion-tabbar-text-color
        --ion-tabbar-text-color-active
        --ion-toolbar-background-color
        --ion-toolbar-border-color
        --ion-toolbar-color-active
        --ion-toolbar-color-inactive
        --ion-toolbar-text-color
        --ion-item-background-color
        --ion-item-background-color-active
        --ion-item-border-color
        --ion-item-text-color
        --ion-placeholder-text-color

    ▪ Ступенчатые цвета

      Исследовав множество приложений и тем для них, 
      мы (команда Ionic) обнаружили, что в большинстве
      дизайнов фон никогда не является одним цветом.
      Всегда имеются тонкие вариации, используемые для
      обозначения важности и глубины во всём дизайне.
      Чтобы применить это в Ionic, мы создали ступенчатые
      цвета.

      Есть только 2 цвета, которые используются во всех
      Ionic-компонентах:

      ▪ --ion-text-color
      ▪ --ion-background-color

      Ступенчатые цвета позволяют лучше контролировать
      то, как выглядит ваше приложение.

      Цветовой шаг - тонкая вариация цвета на пути к 
      другому цвету.

      Например, цветовые шаги для --ion-text-color сдвигают
      его по направлению к --ion-background-color.

      Ступенчатые цвета также требуют наличие RGB-списка
      для контроля над alpha. См. "Alpha-проблема" ниже.

      Простой пример для иллюстрации концепции, 
      всего с 4-мя цветовыми шагами:

        --ion-text-color: #000000;
        --ion-background-color: #ffffff;
        --ion-background-color-step-250: #bfbfbf;
        --ion-background-color-step-500: #808080;
        --ion-background-color-step-750: #404040;
        --ion-background-color-step-1000: #000000;
        --ion-text-color-step-250: #404040;
        --ion-text-color-step-500: #808080;
        --ion-text-color-step-750: #bfbfbf;
        --ion-text-color-step-1000: #ffffff;

      В этом примере вы можете видеть, как цветовые 
      шаги для --ion-background-color смещают цвет
      из белого в чёрный. И как оные для --ion-text-color
      смещают цвет из чёрного в белый.

      Ionic используют номера цветовых шагов, как проценты
      для генерации этих цветов. Например, --ion-text-color-step-250,
      это --ion-text-color, смешанный с 25% цвета --ion-background-color.

      Ionic генерирует 20 шагов для каждого цвета, получая
      в результате следующий CSS:

        --ion-background-color: #ffffff;
        --ion-background-color-step-50: #f2f2f2;
        --ion-background-color-step-100: #e6e6e6;
        --ion-background-color-step-150: #d9d9d9;
        --ion-background-color-step-200: #cccccc;
        --ion-background-color-step-250: #bfbfbf;
        --ion-background-color-step-300: #b3b3b3;
        --ion-background-color-step-350: #a6a6a6;
        --ion-background-color-step-400: #999999;
        --ion-background-color-step-450: #8c8c8c;
        --ion-background-color-step-500: #808080;
        --ion-background-color-step-550: #737373;
        --ion-background-color-step-600: #666666;
        --ion-background-color-step-650: #595959;
        --ion-background-color-step-700: #4d4d4d;
        --ion-background-color-step-750: #404040;
        --ion-background-color-step-800: #333333;
        --ion-background-color-step-850: #262626;
        --ion-background-color-step-900: #191919;
        --ion-background-color-step-950: #0d0d0d;
        --ion-background-color-step-1000: #000000;
        --ion-text-color: #000000;
        --ion-text-color-step-50: #0d0d0d;
        --ion-text-color-step-100: #1a1a1a;
        --ion-text-color-step-150: #262626;
        --ion-text-color-step-200: #333333;
        --ion-text-color-step-250: #404040;
        --ion-text-color-step-300: #4d4d4d;
        --ion-text-color-step-350: #595959;
        --ion-text-color-step-400: #666666;
        --ion-text-color-step-450: #737373;
        --ion-text-color-step-500: #808080;
        --ion-text-color-step-550: #8c8c8c;
        --ion-text-color-step-600: #999999;
        --ion-text-color-step-650: #a6a6a6;
        --ion-text-color-step-700: #b3b3b3;
        --ion-text-color-step-750: #bfbfbf;
        --ion-text-color-step-800: #cccccc;
        --ion-text-color-step-850: #d9d9d9;
        --ion-text-color-step-900: #e6e6e6;
        --ion-text-color-step-950: #f2f2f2;
        --ion-text-color-step-1000: #ffffff;

      Вообще, цветовые шаги для текста/фона являются 
      зеркальным отражением друг-друга. Дизайнеры
      могут кастомизировать отдельные шаги, если необходимо.

      Например, может для дизайна надо, чтобы цвет
      ion-text-color-step-250 был розовым, а не серым.

    ▪ Цветовая карта

      Цветовая карта - коллекция абстрактных цветов, 
      которые используются во всех компонентах. Цветам
      в этой коллекции также присваиваются CSS-классы,
      чтобы можно было легко применять их к компонентам.

      Например, чтобы применить цвет primary к компоненту,
      можно просто добавить primary в качестве значения
      атрибута color компонента:

        <ion-button color="primary">Primary</ion-button>

      Вот список всех top-level цветов в цветовой карте:

        --ion-color-primary
        --ion-color-secondary
        --ion-color-tertiary
        --ion-color-success
        --ion-color-warning
        --ion-color-danger
        --ion-color-light
        --ion-color-medium
        --ion-color-dark

    ▪ Многослойные цвета в цветовой карте

      Предполагается, что цвета в цветовой карте должны
      быть многослойными - то есть, каждый такой цвет
      НЕ является одним лишь HEX-значением.

      Когда вы применяете 'primary' к кнопке, меняется не
      только цвет фона кнопки, но и цвет текста, цвета
      кнопки для состояний hover и active. Это только один
      маленький пример того, как применяеются многослойные
      цвета.

      В общем, если вы хотите изменить многослойный цвет,
      вам надо изменить цвет для всех его слоёв. Многослойный
      цвет состоит из:

      ▪ base      | базовый цвет
      ▪ contrast  | видимый относительно базового цвета
      ▪ shade     | немного более тёмный цвет относительно базового
      ▪ tint      | немного более светлый цвет относительно базового

      Например, цвет --ion-color-primary состоит из следующих
      CSS-свойств:

        --ion-color-primary: #488aff;
        --ion-color-primary-contrast: #ffffff;
        --ion-color-primary-shade: #3f79e0;
        --ion-color-primary-tint: #5a96ff;

      Ionic использует следующий шаблон для наименования
      цветов в цветовой карте:

        --ion-color-[name]-[variation]

      Вообще, причина применения многослойных цветов в том,
      что CSS не поддерживает любой метод для модификации
      цвета (mixing colors, tint, shading, etc).

      Цвета в цветовых картах также страдают от alpha-проблемы.
      Прочитайте про неё ниже, и при изменении многослойных
      цветов проверяйте, что сгенерировали RGB-список версий
      ваших цветов, и, таким образом, он может быть использовать
      для alpha-переходов.

    ▪ Alpha-проблема

      CSS в настоящий момент (начало августа 2018) не поддерживает
      granular alpha color цвета. Конечно, команда Ionic в курсе
      про rgba(), но проблема в том, что rgba() принимает только
      RGB-список. Например, вам не удастся сделать следующее:

        rgba(#ff0000, .5)

      Это означает, что для настройки только альфа-значения
      цвета, отдельно от самого цвета, требуется, сделать
      это через RGB-список. Чтобы решить эту проблему, 
      Ionic генерирует ступенчатый RGB-список, и цветовую
      карту. Рекомендуется при изменении любого из этих
      цветов перегенерировать и RGB-список, чтобы позволить
      использовать этот цвет для alpha-переходов.

      Вот RGB-список по умолчанию:

        --ion-color-primary-rgb: 72, 138, 255;
        --ion-color-secondary-rgb: 50, 219, 100;
        --ion-color-tertiary-rgb: 244, 169, 66;
        --ion-color-success-rgb: 16, 220, 96;
        --ion-color-warning-rgb: 255, 206, 0;
        --ion-color-danger-rgb: 245, 61, 61;
        --ion-color-light-rgb: 244, 244, 244;
        --ion-color-medium-rgb: 152, 154, 162;
        --ion-color-dark-rgb: 34, 34, 34;

        --ion-background-color-rgb: 255, 255, 255;
        --ion-text-color-rgb: 0, 0, 0;

      Как вы видите, используются в точности те же самые
      значения для цветов, но теперь они могут использоваться
      в rgba(). Например, primary может теперь быть 
      использовать так:

        color: rgba(var(--ion-color-primary-rgb), 0.25);

  • Применение стилей

    Стилизация приложения - такое же простое дело, как 
    применение CSS-файла с блоком :root, или использование
    JS для изменения значений CSS-свойств.

    Полная тематизация подразумевает наличие всех 
    CSS-переменных, которые будут использоваться
    по всей коллекции Ionic-компонентов.

    В этом небольшом примере лишь показано, как цвет
    primary может быть изменён через CSS:

      :root {
        --ion-color-primary: #ff0000;
        --ion-color-primary-contrast: #ffffff;
        --ion-color-primary-shade: #ae0000;
        --ion-color-primary-tint: #ff3633;
        --ion-color-primary-rgb: 255, 0, 0;
      }

    Можно менять цвет не глобально, а персонально для 
    конкретной кнопки:

      .my-fancy-button {
        --ion-color-primary: #ff0000;
        --ion-color-primary-contrast: #ffffff;
        --ion-color-primary-shade: #ae0000;
        --ion-color-primary-tint: #ff3633;
        --ion-color-primary-rgb: 255, 0, 0;
      }

    Это также можно делать через JS, функцией setProperty:

      const el = document.querySelector('.my-fancy-button');
      el.style.setProperty('--ion-color-primary', '#ff0000');
      el.style.setProperty('--ion-color-primary-contrast', '#ffffff');
      el.style.setProperty('--ion-color-primary-shade', '#ae0000');
      el.style.setProperty('--ion-color-primary-tint', '#ff3633');
      el.style.setProperty('--ion-color-primary-rgb', '255,0,0');


А8. Публикация Ionic-приложения
--------------------------------------

  # Ссылки
  # Публикация для PWA

    ▪ Превращение приложения в PWA
    ▪ Деплой PWA-приложения

  # Публикация для iOS в App Store

    ▪ Предварительные требования для публикации iOS-приложения
    ▪ Генерация release-сборки iOS-приложения
    ▪ Генерация сертификатов для подписи iOS-приложения
    ▪ Подпись iOS-приложения через XCode
    ▪ Обновление iOS-приложения

  # Публикация для Android в Play Store

    ▪ Генерация release-сборки Android-приложения
    ▪ Подпись APK-файла Android-приложения
    ▪ Отправка Android-приложения в Google Play Store
    ▪ Обновление Android-приложения

  # Публикация для Electron

    ▪ Публикация для macOS
    ▪ Публикация для Windows

--------------------------------------

> Ссылки

  • PWA
    
    ▪ Подробнее про PWA
        https://ionicframework.com/pwa

    ▪ Про Service Worker
        https://developers.google.com/web/fundamentals/primers/service-workers/

    ▪ Про Web Manifest
        https://developers.google.com/web/fundamentals/web-app-manifest/

  • iOS

    ▪ Где оплатить Apple Developers Account
        https://developer.apple.com/programs/

    ▪ Про сертификаты и подпись приложения
        https://help.apple.com/xcode/mac/current/#/dev3a05256b8

    ▪ Apple's member center
        https://developer.apple.com/membercenter

    ▪ Itunes Connect
        https://itunesconnect.apple.com/
 
  • Android

    ▪ Google Play Console
        https://play.google.com/apps/publish/?account=5139749501163457798#

  • Electron

    ▪ Официально руководство по Electron
        https://electronjs.org/docs/tutorial/first-app
 
> Публикация для PWA

  Поскольку Ionic-приложения основаны на веб-технологиях,
  они могут работать как на PWA, так и на нативных 
  платформах.

  • Превращение приложения в PWA

    Чтобы превратить приложение в PWA, есть 2 основных
    требования:

      ▪ Service Worker
      ▪ Web Manifest

    Можно добавить их в приложение вручную, либо, если 
    вы пишете на Angular, то пакет @angular/pwa позволит
    автоматизировать процесс.

    Пакет* @angular/pwa автоматически добавит Service Worker
    и Web Manifest в приложение. Чтобы добавить этот пакет
    в приложение, выполните:

      ng add @angular/pwa

    После добавления этого пакета, выполните ionic build --prod
    для сборки приложения, и папка www будет готова к деплою
    в качестве PWA.

    *Примечание:

      По умолчанию, пакет @angular/pwa поставляется с 
      логотипом Angular для иконки приложения. Не забудьте
      обновить в манифесте имя и иконки.

    Если вы разворачиваете приложения и на других каналах,
    таких как Cordova или Electron, вы можете удалить
    флаг "serviceWorker": true из angular.json. 

    Service Worker можно сгенерировать этой командой:

      ionic build --prod --service-worker

    *Примечание: 

      Такие фичи, как Service Worker, и многие JS API 
      (такие, как геолокация), требуют, чтобы приложение
      хостилось в безопасном месте. Если вы используете
      дешёвый хостинг, имейте в виду, что потребуется
      включить HTTPS, чтобы всё работало нормально.

  • Деплой PWA-приложения

    Хостинг Firebase предоставляет много преимуществ для
    PWA, включая быстрое время отклика, благодаря CDN'ам,
    включённый по умолчанию HTTPS, поддержка HTTP2 push.

    Для начала, установите Firebase CLI:

      npm install -g firebase-tools

    Затем перейтите в папку с проектом и выполните в ней:

      firebase init

    Эта команда* создаст конфиг firebase.json, и подготовит
    приложение к деплою.
      
    *Примечание:

      Команда firebase init задаст вам несколько вопросов,
      включая вопрос про редирект URL'ов на "/index.html".
      Убедитесь, что вы ответите yes на этот вопрос, но 
      ответите no на вопрос про перезапись вашего index.html.
      Благодаря этому роутинг, hard reload, и deep linking
      будут нормально работать в приложении.

    Последнее, что нужно проверить, чтобы было правильно
    настроено кэширование заголовков. Для этого, добавьте
    следующий код в firebase.json

      "headers": [
        {
          "source": "/build/app/**",
          "headers": [
            {
              "key": "Cache-Control",
              "value": "public, max-age=31536000"
            }
          ]
        },
        {
          "source": "sw.js",
          "headers": [
            {
              "key": "Cache-Control",
              "value": "no-cache"
            }
          ]
        }
      ]    

    Теперь, можно задеплоить приложение командой:

      firebase deploy

> Публикация для iOS в App Store

    Вообще, подробнее про это лучше почитай методички
    Cordova и Capacitor. Здесь же описан лишь примерный
    процесс, для общего развития, так сказать.

  • Предварительные требования для публикации iOS-приложения

    Для публикации iOS-приложения в App Store необходимо
    следующее:

    ▪ MacOS High Sierra
    ▪ XCode
    ▪ Оплаченный Apple Developers Account ($100/год)
    ▪ Сертификаты приложения для разработки и распространения

  • Генерация release-сборки iOS-приложения

    ▪ Cordova

      Если платформа iOS ещё не добавлена, добавьте
      её:

        ionic cordova platform add ios

      Когда платформа добавлена, запустите команду 
      build с флагом --prod :

        ionic cordova build ios --prod

      Это сгенерирует минифицированный код для web-части
      приложения, и скопирует его на платформу iOS.

      Далее, откройте файл .xcworkspace в ./platforms/ios/
      для запуска XCode.

  • Генерация сертификатов для подписи iOS-приложения

    Чтобы создать необходимые сертификаты и профили,
    посетите Apple's member center и следуйте инструкциям
    из документации apple.

    Есть 2 типа сетрификатов, которые здесь важны:

      ▪ Development
      ▪ Distribution

    Первый необходим во время разработки. Он позволяет 
    подписывать приложение и деплоить на устройства,
    к которым у сертификата есть доступ.

    Второй необходим для добавления приложения в App Store.
    Когда приложение подписано этим сертификатом, оно 
    может быть установлено на любое приложение.

  • Подпись iOS-приложения через XCode

    Когда сертификаты готовы, можно работать с ними через
    XCode, или вручную. Лучше доверить это дело XCode.
    Это позволит быть уверенным, что используются верные
    Development и Distribution сертификаты, на основе
    выбранного типа сборки.

    Перейдите в Product -> Archive. Это создаст сборку
    версии приложения, которая готова к добавлению в 
    App Store. Когда архив будет создан, откроется
    XCode Organizer.

    XCode Organizer отображает список сборок текущего
    приложения. Выберите последнюю сборку и нажмите
    "Upload to App Store". Там ещё должно быть место, где
    можно выбрать команду, инфа о приложении, и кнопка
    "Upload".

    Если успешно удалось залить приложение, оно должно
    появиться в Itunes Connect в "Activities". Там 
    можно включить "TestFlight" для бета-тестирования,
    либо можно отправить приложение в Apple для
    проверки.

  • Обновление iOS-приложения

    По мере роста приложения, его, скорее всего, надо 
    будет обновлять новыми фичами, фиксить баги.

    Приложения может быть обновлено двумя способами:

      ▪ Отправить новую версию на проверку в Apple.
      ▪ Обновить приложени push'em, например, через Ionic Deploy.

    Ionic Deploy позволяет внести изменения в приложение
    напрямую в реальном времени, без ожидания, пока 
    Apple проведёт свою проверку.

    *Примечание:  

      Чтобы iOS App Store принял обновленную сборку,
      файл config.xml должен быть отредактирован, в нём
      надо инкрементировать версию, затем пересобрать
      приложение для релиза следуя вышеописанным
      инструациям.

> Публикация для Android в Play Store

    Вообще, подробнее про это лучше почитай методички
    Cordova и Capacitor. Здесь же описан лишь примерный
    процесс, для общего развития, так сказать.

  • Генерация release-сборки Android-приложения

    ▪ Cordova

      Для генерации release-сборки Android-приложения,
      выполните следующую команду:

        ionic cordova build android --prod --release

      Это сгенерирует release-сборку, основанную на
      config.xml, и положит её в папку
      platforms/android/build/outputs/apk

      Ionic-приложение имеет стандартные настройки в 
      config.xml, но их можно менять.

  • Подпись APK-файла Android-приложения

    Во-первых, неподписанный APK надо подписать.
    Если ключ для подписи уже был создан,
    пропустите эти шаги и используйте его. Если нет, то
    сгенерируйте ключ используя команду keytool,
    которая идёт вместе с Android SDK:

      keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000

    Эта команда задаст несколько вопросов, и после завершения
    своей работы, создаст файл* my-release-key.keystore в 
    текущем каталоге.

    *Внимание:

      Сохраните этот файл и держите в безопасном месте.
      Если вы его потеряете, Google Play Store не будет
      принимать обновления для этого приложения!

    Чтобы подписать неподписанный APK, запустите jarsigner,
    который также идёт вместе с Android SDK:

      jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore HelloWorld-release-unsigned.apk alias_name

    Наконец, надо запустить zipalign, чтобы оптимизировать
    APK. Эта команда находится в 
    /path/to/Android/sdk/build-tools/VERSION/zipalign

    Например, на macOS с Android Studio, команда zipalign
    лежит в ~/Library/Android/sdk/build-tools/VERSION/zipalign

    Выполняем:

      zipalign -v 4 HelloWorld-release-unsigned.apk HelloWorld.apk

    Это сгенерирует финальный релизный бинарник, с именем
    типа HelloWorld.apk, который может быть добавлен в 
    Google Play Store.

  • Отправка Android-приложения в Google Play Store

    Теперь, когда release APK готов, можно загружать его
    в Play Store.

    Для этого, откройте Google Play Store Developer Console
    и создайте там новый аккаунт (если у вас ещё нет). 
    Это будет стоить $25 (разовый платёж).

    После оплаты аккаунта, создаёте новое приложение.
    Не забудьте заполнить описание приложения, добавить
    скриншоты, и т.п. Когда всё заполните, добавьте
    подписанный APK, и опубликуйте приложение.

  • Обновление Android-приложения

    По мере разработки приложения, скорее всего его понадобится
    обновлять, добавлять новые фичи и фиксы. Приложение можно
    обновить двумя способами:

      ▪ Отправить новую версию на проверку в Google Play Store.
      ▪ Обновить приложени push'em, например, через Ionic Deploy.

    Ionic Deploy позволяет внести изменения в приложение
    напрямую в реальном времени, без ожидания, пока 
    Apple проведёт свою проверку.

    *Примечание:  

      Чтобы Google Play Store принял обновленную сборку,
      файл config.xml должен быть отредактирован, в нём
      надо инкрементировать версию, затем пересобрать
      приложение для релиза следуя вышеописанным
      инструациям.

> Публикация для Electron

  Разработка desktop-приложени на Ionic позволяет разработчикам
  на 100% переиспользовать весь их код и поставлять 
  традиционное desktop-приложение, сохраняя доступ ко всем
  нативным фичам, вроде push-уведомлений. Это руководство
  подразумевает, что вы знакомы с Electron, и не описывает,
  как разрабатывать Electron-приложения.

  • Публикация для macOS

    ▪ Требования

      ▪ Последняя версия XCode
      ▪ Активный Apple Developers Account ($100/год).

    ▪ Публикация

      В руководстве Electron есть отдельный раздел про то,
      как публиквать приложение для macOS:

        https://electronjs.org/docs/tutorial/mac-app-store-submission-guide

  • Публикация для Windows

    ▪ Требования

      ▪ Windows 10 with Anniversary Update
      ▪ The Windows 10 SDK
      ▪ NodeJS
      ▪ electron-windows-store CLI

      Установить electron-windows-store через npm:

        npm install -g electron-windows-store

    ▪ Публикация

      В руководстве Electron есть отдельный раздел про то,
      как публиквать приложение для Windows:   

        https://electronjs.org/docs/tutorial/windows-store-guide

А9. FAQ
--------------------------------------

  # Build Errors

    ▪ Забыть () на декораторе
    ▪ Cannot resolve all parameters for MyClass ...
    ▪ No provider for ParamType! (MyClass -> ParamType)
    ▪ Can't bind to 'propertyName' since it isn't a known ...
    ▪ No provider for ControlContainer! (NgControlName -> ControlContainer)
    ▪ No component factory found for

  # Runtime Errors

    ▪ Пустой белый экран, ошибок нет
    ▪ Директива не работает
    ▪ Большой лаг при обработке события click
    ▪ Cordova-плагины не работают в браузере
    ▪ Множественные экземпляры provider'а

  # Native Errors

    ▪ Проблемы с подписыванием приложения
    ▪ Xcode build error 65
    ▪ Сбой версий Google Play Services

  # Подсказки разработчикам

    ▪ Обновление зависимостей
    ▪ Редакторы
    ▪ Использование Debugger'а
    ▪ Изменение режима (mode: md / ios)
    ▪ Использование iOS-симулятора
    ▪ Использование Genymotion Android Emulator
    ▪ Удалённая отладка - iOS и Safari
    ▪ Удалённая отладка - Android и Chrome
    ▪ Удалённая отдалка - VS Code Plugin

--------------------------------------

> Build Errors

  Подробнее о них см.в документации Ionic:
  https://beta.ionicframework.com/docs/faq/build

> Runtime Errors

  • Пустой белый экран, ошибок нет

    Это может происходить по разным причинам. Если вам не 
    удаётся найти решение в интернете, на форуме, попробуйте
    это:

    ▪ Root @Component has a template or templateUrl.
    ▪ Root @Component template has an <ion-nav> with a root property:

      <ion-nav [root]="rootPage"></ion-nav>

  • Директива не работает

    Есть несколько вещей, которые вы можете 
    проверить:

    ▪ убедитесь, что включили директиву в массив directives
      в @Component, который вы хотите её использовать
      (только, если версия вашего ionic-angular ниже RC0);

    ▪ в вашем селекторе нет очепяток;

    ▪ вы правильно используете селектор, как атрибут, элемент или класс;

    ▪ у вашего селектора верный синтаксис

      ▪ [attr] для attribute-селектора
      ▪ element для element-селектора
      ▪ .class для class-селектора

    Вот пример использования attribute-селектора:

      @Directive({
        selector: '[my-dir]' // <-- [my-dir] because it is an attribute
      })                     // Could be my-dir, [my-dir], .my-dir
      class MyDir {
        constructor() {
          console.log('I'm alive!');
        }
      }

      @Component({
        // We add my-dir as an attribute to match the directive's selector
        template: `<div my-dir>Hello World</div>`,

        // Alternatively, if you were attaching the directive to an element it would be:
        // template: `<my-dir>Hello World</my-dir>`
        // and if you were attaching by class the template would be:
        // template: `<div class="my-dir">Hello World</div>`

        directives: [MyDir] // <-- Don't forget me! (only if your ionic-angular version is below RC0)
      })
      class MyPage { }

  • Большой лаг при обработке события click

    Авторы рекоменюуют использовать событие "click" только
    на элементах, на которые должны именно кликать мышкой
    (а не тапать пальцем, и т.д). Как правило, это элементы
    <button> и <a>.

    Если вы используете событие click на элементах, которые
    обычно не являются кликабельными, вы получаете задержку
    обработки события в 300мс с момента клика по элементу и
    возбуждения события. Чтобы удалить эту задержку, вы 
    можете добавить атрибут tappable вашему элементу:

      <div tappable (click)="doClick()">I am clickable!</div>

  • Cordova-плагины не работают в браузере

    В какой-то момент, при разработке, вы можете вызвать
    Cordova-плагин, и получить warning:

      [Warning] Native: tried calling StatusBar.styleDefault, but Cordova is not
      available. Make sure to include cordova.js or run in a device/simulator
      (app.bundle.js, line 83388)

    Это происходит, когда вы пытаетесь вызвать нативный плагин,
    но Cordova недоступна. К счастью, Ionic Native выводит
    Warning вместо ошибки.

    В других случаях, когда плагин не был использован через
    Ionic Native, вы можете получить менее ясный warning:

      EXCEPTION: Error: Uncaught (in promise): TypeError: undefined is not an object
      (evaluating 'navigator.camera.getPicture')

  • Множественные экземпляры provider'а

    Это Angular-специфичная проблема, меня не касается.

> Native Errors

  • Проблемы с подписыванием приложения

    Ошибка:

      "Code Signing Error: Failed to create provisioning profile. 
      The app ID “com.csform.ionic.yellow” cannot be registered 
      to your development team. Change your bundle identifier 
      to a unique string to try again. Code Signing Error: 
      No profiles for ‘com.csform.ionic.yellow’ were found: 
      Xcode couldn’t find any iOS App Development provisioning 
      profiles matching ‘com.csform.ionic.yellow’. 
      Code Signing Error: Code signing is required for product 
      type ‘Application’ in SDK ‘iOS 11.1’"

    Решение:

      Запуск приложения на iOS-устройстве требует наличия
      provisioning-профиля. Если оный ещё не был создан,
      следуйте следующим указаниям:

      1. Установите Package ID

        ▪ Capacitor

          Откройте файл capacitor.config.json и измените
          свойство appId.

        ▪ Cordova

          Откройте файл config.xml и измените атрибут
          id корневого элемента <widget>.

      2. Откройте проект в XCode

        ▪ Capacitor

          Выполните эту команду, чтобы открыть приложение
          в XCode:

            ionic capacitor open ios

        ▪ Cordova   

          Откройте XCode. Используйте File -> Open 
          и выберите приложение, которое лежит в 
          папке platforms/ios.

      3. Слева в навигации по структуре проекта, выберите
         корневую папку. В разделе Identity, убедитесь,
         что Package ID, и оный, установленный в пункте №1,
         совпадают.

      4. В том же месте, что в пункте 3, в разделе Signing,
         убедитесь, что стоит галочка "Automatically manage
         signing". Затем, выберите Development Team. Как только
         вы этот сделаете, XCode попытается автоматически
         подготовить provisioning и signing.

  • Xcode build error 65

    Ошибка:

      "Error: Error code 65 for command: xcodebuild with 
      args: -xcconfig,/Users/tdit0703/IdeaProjects/
      sc-dahenfeld/platforms/ios/cordova/build-debug.
      xcconfig,-workspace,SC Dahenfeld.xcworkspace,
      -scheme,SC Dahenfeld,-configuration,Debug,
      -sdk,iphonesimulator,-destination,platform=
      iOS Simulator,name=iPhone X,build,CONFIGURATION_BUILD_DIR=
      /Users/tdit0703/IdeaProjects/sc-dahenfeld/platforms/ios/
      build/emulator,SHARED_PRECOMPS_DIR=/Users/tdit0703/IdeaProjects
      /sc-dahenfeld/platforms/ios/build/sharedpch"   

    Решение:

      Эта ошибка является кодом ошибки из XCode, которая 
      могла быть вызвана проблемами с provisioning, или
      старыми зависимостями Cordov'ы. Чтобы исправить эту ошибку,
      сначала убедитесь, что provisioning profile был создан
      с помощью указанных выше инстуркций и попробуйте запустить
      приложение из XCode.

      Если это не поможет, запустите следующие команды,
      которые создадут новый, свежий билд для Cordova:

        rm -rf node_modules
        rm -rf platform
        npm i
        ionic cordova platform add ios
        ionic cordova prepare ios
        ionic cordova build ios --prod

  • Сбой версий Google Play Services

    Ошибка:

      "Error: more than one library with package name 
      com.google.android.gms"

    Решение:

      Эта ошибка вызывается двумя разными плагинами, которые
      пытаются использовать разные версии Google Play Services.

      Чтобы исправить её, убедитесь, что вы работаете с 
      Cordova >= 7.1.0, и cordova-android >= 6.3.0.

      Чтобы обновить Cordova, выполните:

        npm install cordova@latest

      А чтобы обновить cordova-android:

        cordova platform update android

      Зависящие от Google Play Services теперь можно обновить,
      чтобы они использовали одну и ту же версию.

      Например, если pluginA использует версию 11.0 и pluginB
      использует версию 15.0, можно им указать, чтобы они
      использовали версию 15.0 оба. Для этого в config.xml:

        <plugin name=”pluginA” spec=”npm”>
          <variable name=”PLAY_SERVICES_VERSION” value=”15.0.0" />
        </plugin>
        <plugin name=”pluginB” spec=”npm”>
          <variable name=”PLAY_SERVICES_VERSION” value=”15.0.0" />
        </plugin>

> Подсказки разработчикам

  • Обновление зависимостей

    Рекомендуется обновлять пакеты через npm.
    Чтобы обновить зависимости, выполните:

      npm install <package-name>@<version|latest> --save

    Например, чтобы обновить пакет @ionic/angular,
    выполните:

      npm install @ionic/angular@latest --save

  • Редакторы

    Есть много редакторов кода на выбор:

      ▪ VSCode
      ▪ Atom
      ▪ Webstorm
      ▪ ...

    Авторы Ionic, по всей видимости, любители VSCode,
    так как активно его рекомендуют.

  • Использование Debugger'а

    Ключевое слово "debugger" можно использовать для 
    отладки приложения. Когда большинство браузеров видят
    в коде утвеждение "debugger", работающий JS останавливается,
    и браузер загружит свой дебаггер. 

    Использовать debugger можно, чтобы проставлять брэйкпоинты
    в приложении. Например, если функция возвращает неправильное
    значение, debugger можно использовать, чтобы остановить
    её выполнение на определенном этапе, и проверить
    переменные:

      function myBrokenFunction() {
        debugger;
        // do other stuff
      }

    Во время работы приложения, вызов этой функции поставит
    его JS-код на паузу. В devtools, можно продолжить выполнение
    кода строка за строкой, и найти, где функция ломается.

  • Изменение режима (mode: md / ios)

    По умолчанию, когда приложение просматривается в браузере,
    Ionic по умолчанию применяет md (material design). Однако,
    поскольку Ionic-компоненты адаптируются к платформе, на 
    которой выполняются, было бы полезно посмотреть, а как бы
    выглядело приложение на iOS. 

    Чтобы это сделать, просто добавьте в URI приложения:

      ?ionic:mode=ios

    *Примечание:

      Однако, это не меняет то, как браузер воспринимает,
      на какой платформе сейчас работае приложение. Платформа
      определяется путём определения устройства по user-agent.

      Поэтому, чтобы изменить это, вам надо менять user-agent.
      Чтобы сделать это, откройте Chrome DevTools, и переключите
      устройство на другое (Ctrl + Shift + i).

  • Использование iOS-симулятора

    Симулятор iOS позволяет тестировать и отлаживать приложение
    без реального устройства. Для использования симулятора, надо
    установить XCode. Чтобы запустить Ionic-приложение
    на Cordova в симуляторе:

      ionic cordova emulate ios -lc

    -lc запустит livereload и log console output в терминал.

    XCode также можно использовать для запуска эмулятора и 
    отладки приложения. Откройте XCode и откройте
    ../path-to-app/platforms/ios/myApp.xcodeproj.

    После загрузки приложения, консольный вывод и логи
    устройства будут отображаться в окне вывода XCode.

  • Использование Genymotion Android Emulator

    Вообще, в Android SDK есть свой, стандартный эмулятор.
    Однако, авторы Ionic утверждают, что он может быть
    иногда медленным и тормознутым.

    Поэтому, есть альтернативный эмулятор - Genymotion.
    И он также имеет доступ к нативному функционалу,
    такому, как GPS и камера.

  • Удалённая отладка - iOS и Safari

    Safari можно использовать для отладки Ionic-приложения
    на подключенном iOS-устройстве. Сначала, включите
    Web Inspector на подключенном устройстве:

      Settings > Safari > Advanced

    Затем, в Safari на Mac включите "Show develop menu in
    menu bar" в:

      Safari > Preferences > Advanced

    После этого, подключенные устройства должны появиться
    в меню Develop. Из него, можно использовать средства
    разработки Safari для отладки приложения.

  • Удалённая отладка - Android и Chrome

    Можно использовать Chrome DevTools для отладки приложения,
    когда оно запущено в браузере через ionic serve, 
    или на эмуляторе, или на физическом устройстве.

    Для отладки приложения, в Chrome идите в:

      chrome://inspect

    *Примечание:

      На физических устройствах надо в настройках включить
      Developer Mode.

      Как это сделать описано в методичке про Capacitor.

  • Удалённая отладка - VS Code Plugin

    У VSCode есть плагин для отладки Corodva-приложений.
    (https://marketplace.visualstudio.com/items?itemName=vsmobile.cordova-tools)

    Этот плагин создаёт мост между устройством и VSCode Devtools,
    и позволяет производить отладку прямо в редакторе.


А10. Ionic API (справочник)
--------------------------------------

  Component API

    # ion-action-sheet      | Fullscreen-модалка о списком действий поверх контента
      
      ▪ buttons               | Массив кнопок для Action Sheet
      ▪ cssClass              | Какие доп.классы применить. Если их > 1, надо разделять пробелами
      ▪ enableBackdropDismiss | [true] Если true, Action Sheet можно будет закрыть кликом по фону
      ▪ enterAnimation        | Анимация появления Action Sheet
      ▪ Builde                | Заголовок для Action Sheet
      ▪ header                | Заголовок для Action Sheet
      ▪ keyboardClose         | Должен ли Action Sheet закрыть клавиатуру
      ▪ leaveAnimation        | Анимация закрытия Action Sheet
      ▪ overlayId             | Уникальный ID экземпляра Action Sheet (для внутреннего использования)
      ▪ subHeader             | Подзаголовок для Action Sheet
      ▪ translucent           | [false] Включить ли полупрозрачность для Action Sheet
      ▪ willAnimate           | [true] Анимировать ли Action Sheet

      • dismiss()             | Закрыть Action Sheet
      • onDidDismiss()        | Вернуть промис, резолвящийся после закрытия Action Sheet (можно передать callback)
      • onWillDismiss()       | Вернуть промис, резолвящийся перед закрытием Action Sheet (можно передать callback)
      • present()             | Показать Action Sheet

      ► ionActionSheetDidDismiss  | Возбуждается после закрытия alert
      ► ionActionSheetDidLoad     | Возбуждается после загрузки alert
      ► ionActionSheetDidPresent  | Возбуждается после представления alert
      ► ionActionSheetDidUnload   | Возбуждается после выгрузки alert
      ► ionActionSheetWillDismiss | Возбуждается перед закрытием alert
      ► ionActionSheetWillPresent | Возбуждается перед представлением alert

    # ion-alert             | Не-fullscreen модалка с текстом и элементами формы

      ▪ buttons             | Массив кнопок для Alert
      ▪ cssClass            | Какие доп.классы применить. Если их > 1, надо разделять пробелами
      ▪ enableBackdropDismiss | [true] Если true, Action Sheet можно будет закрыть кликом по фону
      ▪ enterAnimation      | Анимация появления Action Sheet
      ▪ header              | Заголовок для Alert
      ▪ inputs              | Массив input'ов, которые показать в alert
      ▪ keyboardClose       | Должен ли Alert закрыть клавиатуру
      ▪ leaveAnimation      | Анимация закрытия Action Sheet
      ▪ message             | Главное сообщение для показа в alert
      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ overlayId           | Уникальный ID экземпляра Alert (для внутреннего использования).
      ▪ subHeader           | Подзаголовок для Action Sheet
      ▪ translucent         | [false] Включить ли полупрозрачность для Action Sheet
      ▪ willAnimate         | [true] Анимировать ли Action Sheet

      • dismiss()           | Закрыть Alert
      • onDidDismiss()      | Вернуть промис, резолвящийся после закрытия Alert (можно передать callback)
      • onWillDismiss()     | Вернуть промис, резолвящийся перед закрытием Alert (можно передать callback)
      • present()           | Показать Alert

      ► ionAlertDidDismiss  | Возбуждается после закрытия alert
      ► ionAlertDidLoad     | Возбуждается после загрузки alert
      ► ionAlertDidPresent  | Возбуждается после представления alert
      ► ionAlertDidUnload   | Возбуждается после выгрузки alert
      ► ionAlertWillDismiss | Возбуждается перед закрытием alert
      ► ionAlertWillPresent | Возбуждается перед представлением alert

    # ion-anchor            | 
    # ion-app               | 
    # ion-avatar            | 
    # ion-back-button       | 
    # ion-backdrop          | 
    # ion-badge             | 

    # ion-button            |
    # ion-buttons           |

    # ion-card              |
    # ion-card-content      |
    # ion-card-header       |
    # ion-card-subtitle     |
    # ion-card-title        |

    # ion-checkbox          |
 
    # ion-chip              |
    # ion-chip-button       |
    # ion-chip-icon         |
    
    # ion-grid              |
    # ion-col               |
    # ion-row               |

    # ion-content           |
    # ion-datetime          |

    # ion-fab               |
    # ion-fab-button        |
    # ion-fab-list          |

    # ion-footer            |
    # ion-header            |
    # ion-hide-when         |
    # ion-img               |

    # ion-infinite-scroll   |
    # ion-infinite-scroll-content  |

    # ion-input             |
    # ion-item-divider      |
    # ion-item-group        |
    # ion-item-option       |
    # ion-item-options      |
    # ion-item-sliding      |
    
    # ion-label             |
    # ion-list              |
    # ion-list-header       |
    # ion-loading           |

    # ion-menu              |
    # ion-menu-button       |
    # ion-menu-toggle       |

    # ion-modal             |
    # ion-modal-controller  |
    # ion-nav               |
    # ion-nav-pop           |
    # ion-nav-push          |
    # ion-nav-set-root      |
    # ion-note              |
    # ion-picker            |
    # ion-picker-column     |
    # ion-popover           |
    
    # ion-radio             |
    # ion-radio-group       |
    # ion-range             |
    # ion-range-knob        |
    # ion-refresher         |
    # ion-reorder           |
    # ion-reorder-group     |
    # ion-ripple-effect     |
    # ion-route             |
    # ion-route-redirect    |
    # ion-router            |
    # ion-router-outlet     |
    # ion-scroll            |
    # ion-searchbar         |
    # ion-segment           |
    # ion-segment-button    |
    # ion-select            |
    # ion-select-option     |
    # ion-select-popover    |
    # ion-show-when         |
    # ion-skeleton-text     |
    # ion-slide             |
    # ion-slides            |
    # ion-spinner           |
    # ion-split-pane        |

    # ion-tab               |
    # ion-tab-button        |
    # ion-tabbar            |
    # ion-tabs              |

    # ion-text              |
    # ion-textarea          |
    # ion-thumbnail         |
    # ion-title             |
    # ion-toast             |
    # ion-toggle            |
    # ion-toolbar           |
    # ion-virtual-scroll    |

  Programmatic API

    # ion-action-sheet-controller  | Программный контроль над компонентом action sheet

      • create()            | Создать Action Sheet, передав опции
      • dismiss()           | Закрыть Action Sheet
      • getTop()            | Получить самый недавний Action Sheet

    # ion-alert-controller         | Программный контроль над компонентом alert

      • create()            | Создать Alert, передав опции
      • dismiss()           | Закрыть Alert
      • getTop()            | Получить самый недавний Alert

    # ion-animation-controller     |
    # ion-loading-controller       |
    # ion-menu-controller          |
    # ion-picker-controller        |
    # ion-popover-controller       |
    # ion-refresher-content        |
    # ion-toast-controller         |

--------------------------------------

> ion-action-sheet

  Fullscreen-модалка о списком действий поверх контента.

  ▪ Описание

    Action Sheet является диалогом, который отображает набор
    опций. Оно появляется поверх контента приложения, и 
    должно быть закрыто вручную пользователем, прежде чем
    он сможет продолжить взаимодействие с пользователем.

    Есть несколько способов закрыть окно, в том числе кликнуть
    фон или нажать esc на desctop.

    ▪ Создание

      Action Sheet можно создать с помощью Action Sheet Controller,
      из массива buttons, в котором каждая кнопка имеет text, 
      handler и role. 

      Если обработчик возвращает false, то Action Sheet не будет
      закрыт.

      Опционально, Action Sheet может иметь title, subTitle и
      Icon.

    ▪ Особенности Buttons

      В качестве значения role для button могут быть также
      destructive или cancel. 

      Кнопки без определённого значения для role будут иметь
      вид по умолчанию для платформы.

      Кнопки с ролью cancel будут всегда отображаться в самом
      низу, вне зависимости от своего расположения в массиве.

      Все остальные кнопки, будут отображаться в том порядке,
      в котором они появляются в массиве buttons.

      Авторы рекомендуют размещать кнопку с ролью distructive
      в самом верху массива buttons.

      При закрытии Action Sheet путём тапа по фону, будет
      вызван обработчик кнопки с ролью cancel.

  ▪ Использование

    async function presentActionSheet() {
      const actionSheetController = document.querySelector('ion-action-sheet-controller');
      await actionSheetController.componentOnReady();

      const actionSheet = await actionSheetController.create({
        header: "Albums",
        buttons: [{
          text: 'Delete',
          role: 'destructive',
          icon: 'trash',
          handler: () => {
            console.log('Delete clicked');
          }
        }, {
          text: 'Share',
          icon: 'share',
          handler: () => {
            console.log('Share clicked');
          }
        }, {
          text: 'Play (open modal)',
          icon: 'arrow-dropright-circle',
          handler: () => {
            console.log('Play clicked');
          }
        }, {
          text: 'Favorite',
          icon: 'heart',
          handler: () => {
            console.log('Favorite clicked');
          }
        }, {
          text: 'Cancel',
          icon: 'close',
          role: 'cancel',
          handler: () => {
            console.log('Cancel clicked');
          }
        }]
      });
      await actionSheet.present();
    }  

  ▪ Свойства

    ▪ buttons
      - Массив кнопок для Action Sheet.
      - Атрибуты:

        ▪ buttons

      - Тип: ActionSheetButton[]

    ▪ cssClass
      - Какие доп.классы применить. Если их > 1, надо разделять пробелами.
      - Атрибуты:

        ▪ css-class

      - Тип: string

    ▪ enableBackdropDismiss
      - [true] Если true, Action Sheet можно будет закрыть кликом по фону.
      - Атрибуты:

        ▪ enable-backdrop-dismiss

      - Тип: boolean

    ▪ enterAnimation
      - Анимация появления Action Sheet.
      - Атрибуты:

        ▪ enter-animation

      - Тип: AnimationBuilder

    ▪ header
      - Заголовок для Action Sheet.
      - Атрибуты:

        ▪ header

      - Тип: string

    ▪ keyboardClose
      - Должен ли Action Sheet закрыть клавиатуру.
      - Атрибуты:

        ▪ keyboard-close

      - Тип: boolean

    ▪ leaveAnimation
      - Анимация закрытия Action Sheet.
      - Атрибуты:

        ▪ leave-animation

      - Тип: AnimationBuilder

    ▪ overlayId
      - Уникальный ID экземпляра Action Sheet (для внутреннего использования).
      - Атрибуты:

        ▪ overlay-id

      - Тип: number

    ▪ subHeader
      - Подзаголовок для Action Sheet.
      - Атрибуты:

        ▪ sub-header

      - Тип: string

    ▪ translucent
      - [false] Включить ли полупрозрачность для Action Sheet.
      - Атрибуты:

        ▪ translucent

      - Тип: boolean

    ▪ willAnimate
      - [true] Анимировать ли Action Sheet.
      - Атрибуты:

        ▪ will-animate

      - Тип: boolean

  ▪ Методы

    ▪ dismiss()       | Закрыть Action Sheet
    ▪ onDidDismiss()  | Вернуть промис, резолвящийся после закрытия Action Sheet (можно передать callback)
    ▪ onWillDismiss() | Вернуть промис, резолвящийся перед закрытием Action Sheet (можно передать callback)
    ▪ present()       | Показать Action Sheet

  ▪ События

    ▪ ionActionSheetDidDismiss  | Возбуждается после закрытия action sheet
    ▪ ionActionSheetDidLoad     | Возбуждается после загрузки action sheet
    ▪ ionActionSheetDidPresent  | Возбуждается после представления action sheet
    ▪ ionActionSheetDidUnload   | Возбуждается после выгрузки action sheet
    ▪ ionActionSheetWillDismiss | Возбуждается перед закрытием action sheet
    ▪ ionActionSheetWillPresent | Возбуждается перед представлением action sheet

> ion-alert

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

    Alert является диалогом, который предоставляет пользователью
    какую-то информацию, и/или собирает информацию у пользователя.

    Alert появляется поверх контента приложения, и должен 
    быть вручную уничтожен пользователем, прежде чем он
    сможет продолжить взаимодействие с приложение.

    Опционально, Alert может иметь title, subTitle и message.

    ▪ Создание

      Alert'ы можно создавать с помощью Alert Controller.
      Кастомизировать alert'ы можно, передавая параметры
      в метод "create" контроллера.

    ▪ Buttons

      В массиве buttons, каждая кнопка имеет свойства text,
      и (опционально) handler. 

      Если handler возвращает false, то alert НЕ закроется
      автоматически после нажатия на кнопку.

      Все кнопки будут отображаться в том же порядке, в каком
      они были добавлены в массив buttons, слева-направо.

      Самая правая (последняя) кнопка является главной.

      Опционально, кнопке можно добавить свойство role,
      значением может быть, например, cancel.

      Если role со значением cancel назначена одной из
      кнопок, то при закрытии alert путём нажания на 
      фон, будет вызван handler от этой кнопки.

    ▪ Inputs

      Alert'ы могут также включать различные input'ы, 
      через которые можно собирать различными способами
      данные у пользователя, которые передавать обратно
      в приложение.

      Radio's, checkboxes и text'овые input'ы использовать
      можно, но их нельзя смешивать в одном alert'е.
      Например, alert может состоять целиком из radio
      button'ов, или целиком из checkbox'ов, но он не
      может одновременно содержать и те, и другие.

      Однако, различные виды тестовых input'ов могут 
      быть смешаны. Например, таких как url, email,
      text, и т.д. 

      Если вам нужна сложная форма, которая не вписывается
      в ограничения alert, то рекомендуем вам собрать
      форму на modal, а не на alert.

  ▪ Использование

    async function presentAlert() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Alert',
        subHeader: 'Subtitle',
        message: 'This is an alert message.',
        buttons: ['OK']
      });
      return await alert.present();
    }

    async function presentAlertMultipleButtons() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Alert',
        subHeader: 'Subtitle',
        message: 'This is an alert message.',
        buttons: ['Cancel', 'Open Modal', 'Delete']
      });
      return await alert.present();
    }

    async function presentAlertConfirm() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Confirm!',
        message: 'Message <strong>text</strong>!!!',
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: (blah) => {
              console.log('Confirm Cancel: blah');
            }
          }, {
            text: 'Okay',
            handler: () => {
              console.log('Confirm Okay')
            }
          }
        ]
      });
      return await alert.present();
    }

    async function presentAlertPrompt() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Prompt!',
        inputs: [
          {
            placeholder: 'Placeholder 1'
          },
          {
            name: 'name2',
            id: 'name2-id',
            value: 'hello',
            placeholder: 'Placeholder 2'
          },
          {
            name: 'name3',
            value: 'http://ionicframework.com',
            type: 'url',
            placeholder: 'Favorite site ever'
          },
          // input date with min & max
          {
            name: 'name4',
            type: 'date',
            min: '2017-03-01',
            max: '2018-01-12'
          },
          // input date without min nor max
          {
            name: 'name5',
            type: 'date'
          },
          {
            name: 'name6',
            type: 'number',
            min: -5,
            max: 10
          },
          {
            name: 'name7',
            type: 'number'
          }
        ],
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {
              console.log('Confirm Cancel')
            }
          }, {
            text: 'Ok',
            handler: () => {
              console.log('Confirm Ok')
            }
          }
        ]
      });
      return await alert.present();
    }

    async function presentAlertRadio() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Radio',
        inputs: [
          {
            type: 'radio',
            label: 'Radio 1',
            value: 'value1',
            checked: true
          },
          {
            type: 'radio',
            label: 'Radio 2',
            value: 'value2'
          },
          {
            type: 'radio',
            label: 'Radio 3',
            value: 'value3'
          },
          {
            type: 'radio',
            label: 'Radio 4',
            value: 'value4'
          },
          {
            type: 'radio',
            label: 'Radio 5',
            value: 'value5'
          },
          {
            type: 'radio',
            label: 'Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 ',
            value: 'value6'
          }
        ],
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {
              console.log('Confirm Cancel')
            }
          }, {
            text: 'Ok',
            handler: () => {
              console.log('Confirm Ok')
            }
          }
        ]
      });
      return await alert.present();
    }

    async function presentAlertCheckbox() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Checkbox',
        inputs: [
          {
            type: 'checkbox',
            label: 'Checkbox 1',
            value: 'value1',
            checked: true
          },

          {
            type: 'checkbox',
            label: 'Checkbox 2',
            value: 'value2'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 3',
            value: 'value3'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 4',
            value: 'value4'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 5',
            value: 'value5'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6',
            value: 'value6'
          }
        ],
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {
              console.log('Confirm Cancel')
            }
          }, {
            text: 'Ok',
            handler: () => {
              console.log('Confirm Ok')
            }
          }
        ]
      });
      return await alert.present();
    }

  ▪ Свойства

    ▪ buttons 
      - Массив кнопок для Alert.
      - Атрибуты:

        ▪ buttons

      - Тип: (AlertButton | string)[]

    ▪ cssClass 
      - Какие доп.классы применить. Если их > 1, надо разделять пробелами.
      - Атрибуты:

        ▪ css-class

      - Тип: string
              
    ▪ enableBackdropDismiss 
      - [true] Если true, Action Sheet можно будет закрыть кликом по фону.
      - Атрибуты:  

        ▪ enable-backdrop-dismiss
              
      - Тип: boolean
 
    ▪ enterAnimation 
      - Анимация появления Action Sheet.
      - Атрибуты: 

        ▪ enter-animation
               
      - Тип: AnimationBuilder
        
    ▪ header 
      - Заголовок для Alert.
      - Атрибуты: 

        ▪ header
               
      - Тип: string
                
    ▪ inputs 
      - Массив input'ов, которые показать в alert.
      - Атрибуты: 

        ▪ inputs
               
      - Тип: AlertInput[]
                
    ▪ keyboardClose 
      - Должен ли Alert закрыть клавиатуру.
      - Атрибуты: 

        ▪ keyboard-close
               
      - Тип: boolean
         
    ▪ leaveAnimation 
      - Анимация закрытия Action Sheet.
      - Атрибуты: 

        ▪ leave-animation
               
      - Тип: AnimationBuilder
        
    ▪ message 
      - Главное сообщение для показа в alert.
      - Атрибуты: 

        ▪ message
               
      - Тип: string
               
    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string
                  
    ▪ overlayId 
      - Уникальный ID экземпляра Alert (для внутреннего использования).
      - Атрибуты: 

        ▪ overlay-id
               
      - Тип: number
             
    ▪ subHeader 
      - Подзаголовок для Action Sheet.
      - Атрибуты: 

        ▪ sub-header
               
      - Тип: string
             
    ▪ translucent 
      - [false] Включить ли полупрозрачность для Action Sheet.
      - Атрибуты: 

        ▪ translucent
               
      - Тип: boolean
           
    ▪ willAnimate 
      - [true] Анимировать ли Action Sheet.
      - Атрибуты: 

        ▪ will-animate
               
      - Тип: boolean
      
  ▪ Методы

    ▪ dismiss()           | Закрыть Alert
    ▪ onDidDismiss()      | Вернуть промис, резолвящийся после закрытия Alert (можно передать callback)
    ▪ onWillDismiss()     | Вернуть промис, резолвящийся перед закрытием Alert (можно передать callback)
    ▪ present()           | Показать Alert

  ▪ События

    ▪ ionAlertDidDismiss  | Возбуждается после закрытия alert
    ▪ ionAlertDidLoad     | Возбуждается после загрузки alert
    ▪ ionAlertDidPresent  | Возбуждается после представления alert
    ▪ ionAlertDidUnload   | Возбуждается после выгрузки alert
    ▪ ionAlertWillDismiss | Возбуждается перед закрытием alert
    ▪ ionAlertWillPresent | Возбуждается перед представлением alert 

> ion-anchor     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-app        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-avatar     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-back-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-backdrop   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-badge 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-button 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-buttons     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-card         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-card-content 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-card-header  

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-card-subtitle

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-card-title   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-checkbox

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-chip       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-chip-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-chip-icon  

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-grid

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-col 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-row 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-content 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-datetime

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-fab       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-fab-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-fab-list  

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-footer   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-header   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-hide-when

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-img      

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-infinite-scroll

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-infinite-scroll-content

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-input       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-item-divider

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-item-group  

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-item-option 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-item-options

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-item-sliding

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-label      

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-list       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-list-header

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-loading    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-menu       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-menu-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-menu-toggle

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-modal           

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-modal-controller

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-nav             

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-nav-pop         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-nav-push        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-nav-set-root    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-note            

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-picker          

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-picker-column   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-popover         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-radio         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-radio-group   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-range         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-range-knob    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-refresher     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-reorder       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-reorder-group 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-ripple-effect 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-route         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-route-redirect

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-router        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-router-outlet 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-scroll        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-searchbar     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-segment       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-segment-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-select        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-select-option 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-select-popover

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-show-when     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-skeleton-text 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-slide         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-slides        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-spinner       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-split-pane    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tab       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tab-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tabbar    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tabs      

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-text          

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-textarea      

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-thumbnail     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-title         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-toast         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-toggle        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-toolbar       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-virtual-scroll

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

  
  
> ion-action-sheet-controller 

  Программный контроль над компонентом action sheet.

  ▪ Описание

    Action Sheet можно создать или закрыть с помощью
    этого контроллера.

  ▪ Методы

    ▪ create()  | Создать Action Sheet, передав опции
    ▪ dismiss() | Закрыть Action Sheet
    ▪ getTop()  | Получить самый недавний Action Sheet

> ion-alert-controller

  Программный контроль над компонентом alert.

  ▪ Описание

    Alert'ы можно создавать и убирать с помощью этого
    контроллера.

  ▪ Использование

    async function presentAlert() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Alert',
        subHeader: 'Subtitle',
        message: 'This is an alert message.',
        buttons: ['OK']
      });
      return await alert.present();
    }


  ▪ Методы

    ▪ create()  | Создать Alert, передав опции в create
    ▪ dismiss() | Закрыть открытый Alert
    ▪ getTop()  | Получить самый недавний Alert


А11. Ionic CLI (справочник)
--------------------------------------

  #

--------------------------------------

>


Это про командную строку.


А12. Ionic Native (справочник)
--------------------------------------

  #

--------------------------------------

>


Это про доступ к нативному функционалу,
типа камеры, файловой системе, и прочему.






