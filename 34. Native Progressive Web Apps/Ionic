////=================================================////
////                                                 ////
////                    Ionic 4.*                    ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  # Ionic

    • Сайт
      
        https://ionicframework.com

    • Документация

      ▪ Официальные доки (пока что v3.*)

        https://ionicframework.com/docs

      ▪ Доки для beta v4

        https://beta.ionicframework.com/docs/

    • Ionic Changelog (что изменилось в новой версии)

      https://github.com/ionic-team/ionic/blob/master/CHANGELOG.md

    • Репозиторий и документация для Ionic 4.*

      ▪ Ionic Core 4.0.0
          https://github.com/ionic-team/ionic/blob/master/core/README.md

      ▪ Ionic 4.* Docs
          https://github.com/ionic-team/ionic-docs

    • Маркет (плагины, темы, стартовые приложения)
    
        https://market.ionicframework.com

    • Магазин аксесуаров (футболки, наклейки и прочее)

        https://shop.ionicframework.com

    • Прогресс разработки ionic 4.*

        https://github.com/ionic-team/ionic/milestones

    • Форум и чат

        https://forum.ionicframework.com/
        http://ionicworldwide.herokuapp.com/

    • Twitter

      https://twitter.com/Ionicframework

    • Статьи про использование Ionic 4 + Vue

      ▪ Ionic 4 + Capacitor tutorials list #1
          https://ionictheme.com/ionic4-capacitor-tutorials-list-1/

      ▪ [02.06.2018] Building Mobile Apps With Capacitor And Vue.js
          https://www.smashingmagazine.com/2018/07/mobile-apps-capacitor-vue-js/

      ▪ [28.05.2018] Using the Capacitor in Vue.js app
          http://akhromieiev.com/tutorials/using-capacitor-in-vue-js-app/

      ▪ [15.02.2018]Ionic 4 Tutorial with Vue
          https://www.techiediaries.com/ionic-vue/

      ▪ [16.01.2018]Using Ionic 4 Components in Your Vue.js Apps
          https://alligator.io/vuejs/vue-ionic/

    • Демо-приложения на capacitor + vue + ionic 4

      ▪ A Mobile Demo App with Vue, Capacitor and Ionic 4 Components
          https://github.com/techiediaries/vue-capacitor-ionic-app

    • Блог

        https://blog.ionicframework.com/

    • Интересные посты в блоге

      ▪ [24.07.2018] Announcing the Ionic 4 Beta
          https://blog.ionicframework.com/announcing-ionic-4-beta/

      ▪ [23.07.2018] Announcing Ionic Identity Vault: Secure Biometric Authentication for Your Mobile App
          https://blog.ionicframework.com/announcing-ionic-identity-vault-secure-biometric-authentication-for-your-mobile-app/

      ▪ [22.06.2018] Using TestFlight for User Testing with Ionic
          https://blog.ionicframework.com/using-testflight-for-user-testing-with-ionic/

      ▪ [21.05.2018] Announcing Ionicons v4!
          https://blog.ionicframework.com/announcing-ionicons-v4/

      ▪ [18.04.2018] Ionic Semantic Versioning, Release Schedule and LTS
          https://blog.ionicframework.com/ionic-semantic-versioning-release-schedule-and-lts/

      ▪ [16.04.2018] Introducing A New Guide to Progressive Web Apps
          https://blog.ionicframework.com/introducing-a-new-guide-to-progressive-web-apps/

      ▪ [05.04.2018] Ionic at VueConf
          https://blog.ionicframework.com/ionic-at-vueconf/

      ▪ [20.03.2018] Using Ionic Deploy to Beta Test New Features
          https://blog.ionicframework.com/using-ionic-deploy-to-beta-test-new-features/

      ▪ [15.03.2018] Improved Perceived Performance with Skeleton Screens
          https://blog.ionicframework.com/improved-perceived-performance-with-skeleton-screens/

      ▪ [27.02.2018] Announcing Capacitor 1.0.0 Alpha
          https://blog.ionicframework.com/announcing-capacitor-1-0-0-alpha/

      ▪ [12.02.2018] Customizing Ionic Apps for Web & Mobile
          https://blog.ionicframework.com/customizing-ionic-apps-for-web-mobile/

      ▪ [16.01.2018] Announcing the Ionic PWA Toolkit Beta
          https://blog.ionicframework.com/announcing-the-ionic-pwa-toolkit-beta/

      ▪ [31.10.2017] Announcing Ionic DevApp
          https://blog.ionicframework.com/announcing-ionic-devapp/

      ▪ [25.10.2017] Ionic: 2017-18 Roadmap
          https://blog.ionicframework.com/ionic-2017-18-roadmap/

      ▪ [04.10.2017] WKWebView for All: A new webview for Ionic
          https://blog.ionicframework.com/wkwebview-for-all-a-new-webview-for-ionic/

      ▪ [18.09.2017] The end of Framework Churn
          https://blog.ionicframework.com/the-end-of-framework-churn/

  # Распределение версий на Android
  
    https://developer.android.com/about/dashboards/        


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Ionic 4.*

    А1. Как пользоваться документацией Ionic 4.*
    А2. Введение в Ionic
    А3. Установка Ionic
    А4. Процесс разработки Ionic-приложения
    А5. Компоненты Ionic'а
    А6. Организация layout'а в Ionic-приложении
    А7. Тематизация 
    А8. Публикация Ionic-приложения
    А9. FAQ
    А10. Ionic API (справочник)
    А11. Ionic CLI (справочник)
    А12. Ionic Native (справочник)

  # X.  Практика и наработки

    X1. 


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Как пользоваться документацией Ionic 4.*
--------------------------------------
Подоглавление:

  # Ссылки
  # Как обстоят дела с документацией на конец июля 2017
  # Как пользоваться документацией, пока она не опубликована
  
--------------------------------------

> Ссылки

  • Официальная документация Ionic 4.*
      https://github.com/ionic-team/ionic-docs

  • Ionic v4 component preview app
      https://github.com/ionic-team/component-preview

> Как обстоят дела с документацией на конец июля 2017

  Ionic v4 официально ещё не вышел.
  Документация официально нигде не опубликована.
  Текущея её версия лежит на github.

> Как пользоваться документацией, пока она не опубликована

  1. Сначала устанавливаем NodeJS и NPM, если ещё нет

    curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -
    sudo apt-get install -y nodejs
    npm i npm@latest -g
    npm update npm -g

  2. Открываем свой рабочий linux-дистрибутив
  3. Создаём папку ionic в корне и переходим в неё.
  4. Клонируем репозиторий с доками в неё:

    git clone https://github.com/ionic-team/ionic-docs.git docs  

  5. Переходим в docs, и устанавливаем все npm-зависимости

    cd docs
    npm install

  6. Устанавливаем Ionic v4 component preview app

    Это приложение, которое используется в документации
    для демонстрации компонентов Ionica вживую, так сказать.

    Его нужно отдельно склонировать в папку 
    /ionic/component-preview-app

      cd /ionic
      git clone https://github.com/ionic-team/component-preview.git component-preview-app

    Дальше идём в склонированное приложение,
    устанавливаем зависимости и собираем его:

      cd /ionic/component-preview-app
      npm install
      npm run build

    Дальше копируем папку /ionic/component-preview-app/docs-www
    в /ionic/docs/src/content/component-preview-app/

    Если что, папка component-preview-app находится
    в .gitignore проекта, так что можно без опаски
    делать git pull

  7. Устанавливаем документы для API, CLI, Native, Storage, Component preview

    cd /ionic/docs
    npm run api-docs

  8. Собираем проект

    npm run build

  9. Запускаем сервак

    npm run start

  10. Заходим в браузер и видим доки по адресу 

    localhost:3000/docs

  11. Периодически делаем git pull свежих изменений

    Разработчики Ionic периодически редактируют и
    обновляют доки, поэтому, пока ты их используешь
    в описанном выше режиме, надо их периодически
    обновлять.

    ▪ Обновление документации

      cd /ionic/docs
      git pull

      npm install
      npm run build

    ▪ Обновление Ionic v4 component preview app

      cd /ionic/component-preview-app
      git pull

      npm install
      npm run build

      Затем, копируем с заменой папку /ionic/component-preview-app/docs-www
      в /ionic/docs/src/content/component-preview-app/

    ▪ Обновление документов для API, CLI, Native, Storage, Component preview

      cd /ionic/docs
      git pull
      npm run api-docs
      npm run build


А2. Введение в Ionic
--------------------------------------

  # Что из себя представляет Ionic Framework?

    ▪ Общая информация об Ionic
    ▪ Какие цели преследовали авторы, создавая Ionic
      ▪ Кроссплатформенный
      ▪ Основан на веб-стандартах
      ▪ Прекрасная архитектура
      ▪ Простота
    ▪ Ionic является open source проектом с лицензией MIT
    ▪ Про Ionic CLI
    ▪ О совместимости с фреймворками
      ▪ Ionic v4 и JavaScript
      ▪ Ionic v4 и Angular
      ▪ Будут билды Ionic v4 для Vue и React
    ▪ О v4
    ▪ Про Ionic Pro
    ▪ Экосистема Ionic

  # Основные понятия

    ▪ Введение в основные понятия
    ▪ UI компоненты
    ▪ Непрерывность платформы: адаптация и мимикрия core-компонент под платформы
    ▪ Навигация, навигационные стеки, параллельная навигация
    ▪ Доступ к нативным платформам
    ▪ Архитектура
    ▪ Темы

  # Поддержка браузерами

    ▪ Поддержка браузерами на mobile
      ▪ Что с поддержкой у Ionic
      ▪ Что с поддержкой у Capacitor
      ▪ Что с поддержкой у Cordova
      ▪ Приложение на Capacitor и Ionic не пойдёт на 13.2% всех Android-устройств
      ▪ Приложение на Cordova и Ionic не пойдёт на 0.5% всех Android-устройств
      ▪ Краткие выводы: Cordova или Capacitor?

    ▪ Поддержка браузерами на desctop

  # Разъяснение за версии Ionic

    ▪ Используется SemVer (major.minor.patch)
    ▪ Расписание релизов
      ▪ Major Release
      ▪ Minor Release
      ▪ Patch Release
    ▪ Лог изменений

  # Поддержка

    ▪ Long Term Support (LTS)
    ▪ Платные опции поддержки

--------------------------------------

> Что из себя представляет Ionic Framework?

  • Общая информация об Ionic

    Ionic Framework - open source набор UI-инструментов для
    создания производительных, высококачественных мобильных
    и десктопных приложений, на основе веб-технологий
    (html, css, js).

    Ionic концентрируется на пользовательском интерфейсе
    (фронтенде), или на UI-взаимодействиях приложения 
    (элементы управления, взаимодействия, жесты, анимации).
    Его легко изучить, и легко использовать совместно
    с другими библиотеками или фреймворками, такими как
    Angular или Vue. Но можно обойтись и вообще без
    каких-либо других фронтенд-фреймворков.

    В настоящий момент, Ionic имеет официальную интеграцию
    с Angular, но авторы сообщают, что поддержка для 
    Vue и React в разработке.

  • Какие цели преследовали авторы, создавая Ionic

    ▪ Кроссплатформенный

      Пишем один код, одно приложение, которое работает
      на многих платформах, таких как iOS, Android, desctop,
      PWA (Progressive Web App)

      Девиз: "Write once, run anywhere".
             "Пишем одно приложение, которое работает везде".

    ▪ Основан на веб-стандартах

      Ionic основан на надёжных веб-технологиях: html, css, js.
      Поэтому, написанное сегодня Ionic-приложение будет 
      работоспособно на долгие-долгие годы вперёд. И никакая
      организация не сможет что-то там запретить или контролировать
      его (был бы камень в огород React Native, но в 
      феврале 2018 Facebook изменил лицензию React на MIT).

    ▪ Прекрасная архитектура

      Чистая, простая, функциональная. Ionic сконструирован
      работать и отображаться прекрасно прямо из коробки,
      на всех поддерживаемых платформах. Core-компоненты,
      типографика, интерактивные парадигмы и красивая
      и расширяемая базовая тема.

    ▪ Простота

      Ionic изначально разрабатывался таким образом, чтобы
      создание Ionic-приложений было лёгким и приятным делом,
      и любой специалист по веб-разработке мог быстро вникнуть
      и приступить к делу.

  • Ionic является open source проектом с лицензией MIT

    Ionic Framework является на 100% open source проектом,
    с лицензией MIT. Это означает, что его можно использовать
    в личных и коммерческих проектах бесплатно.

  • Про Ionic CLI

    Ionic CLI, это инструмент для быстрого создания
    новых Ionic-приложений из шаблонов, а также,
    в нём есть ряд полезных во время разработки оных команд.

    В нём также есть dev-сервер, инструменты для сборки 
    и отладки, и много чего ещё.

    Если у вас Ionic Pro, вы можете использовать CLI для
    экспорта кода и взаимодействия с вашим pro-аккаунтом
    через API.

  • О совместимости с фреймворками

    Ionic < 4 был заточен под Angular, без которого
    с ним нельзя было работать.

    А Ionic >= 4 перестал зависеть от Angular. Теперь
    с ним можно работать хоть вообще без фреймворков,
    хоть с тем же Vue или React, или любым другим
    фреймворком или библиотекой.

    То есть, теперь, Ionic превратился в независимую
    библиотеку.

    ▪ Ionic v4 и JavaScript

      Главной задачей при разработке Ionic v4 было убрать
      зависимость от Angular. Сделать так, чтобы 
      core-компоненты могли работать независимо, просто
      как обычный JS.

      В том время, как работа через фреймворки может быть
      удобна для разработки больших приложений большими
      командами, теперь возможно быстренько, местечково, 
      где-то там заюзать Ionic по-мелочи.

    ▪ Ionic v4 и Angular

      Angular сделал Ionic великим. В том время, как
      core-компоненты (как описано выше), в v4 были
      сделаны независимыми, пакет @ionic/angular делает
      интеграцию с инфраструктурой Angular очень простой.

      @ionic/angular включает всю функциональность, которую
      Angular-разработчики ожидают, и интегрируется с core-
      библиотеками Angular, вроде Angular router.

    ▪ Будут билды Ionic v4 для Vue и React

      Поддержка для других фреймворков ожидается в будущем
      релизе. В настоящий момент, разрабатываются 
      биндинги для Vue и React.

  • О v4

    Ionic Framework V4 является важным шагом вперёд.
    Есть существенные изменения, по сравнению с предыдущими 
    версиями, в лежащих в его основе технологиях. Новая
    версия сфокусирована на производительности, совместимости,
    и расширяемости.

    Хотя Ionic v4 имеет пакет @ionic/angular, позволяющий
    легко тесно интегрировать Ionic и Angular, он приобрел
    независимость от фреймворков. По сути, стал библиотекой,
    которую можно использовать хоть на чистом js, хоть с любым
    фреймворком.

    Переход на веб-стандарты позволил Ionic V4 полагаться
    скорее на то, на что способны браузеры, чем на то, на 
    что способен код из Angular.

    На практике, это означает мЕньшее время загрузки, 
    лучшая производительность, и меньше лишнего кода.

  • Про Ionic Pro

    Чтобы помочь управлять Ionic-приложениями на протяжении
    всего их жизненного цикла, команда Ionic предлагает
    платное решение Ionic Pro.

    Это платное решение идёт отдельно от open source 
    фреймворка Ionic, последний можно легко использовать
    без Pro.

    Ionic Pro помогает разработчикам и командам наблюдать
    и отслеживать ожибки во время выполнения кода, выполнять
    нативные сборки приложений в облаке, обновлять Ionic-
    приложения через push'и через личный кабинет.

    Чтобы получить Pro, нужно создать Ionic Account.
    Начать можно с бесплатного плана Starter.
    Ну, и можно перейти на какой-нибудь из платных планов,
    которые дают больше возможностей.

  • Экосистема Ionic

    Ionic Framework активно разрабатывается и поддерживается
    на полный рабочий день core-командой, а развитие экосистемы
    направляется международным сообществом разработчиков и 
    кантрибьютеров. Разработчики, большие и малые компании
    используют Ionic для создания прекрасных приложений,
    которые работают везде.

> Основные понятия

  • Введение в основные понятия

    Для новичков в разработке на Ionic, будет полезно
    увидеть общую картину того, как тут всё работает - 
    ключевую философию, концепты и инструменты в основе
    проекта.
    Прежде, чем погружаться в сложные темы, сначала
    следует понять основы Ionic Framework, и как он
    работает.

  • UI компоненты

    Ionic является библиотекой UI компонент, каждая из 
    которых может быть переиспользована, и которые
    используются в приложении, как строительные блоки.

    Компоненты Ionic построены на основе веб стандартов,
    с использованием HTML, CSS и JavaScript.

    Не смотря на то, что все компоненты собраны заранее,
    они изначально сделаны так, чтобы их можно было
    легко кастомизировать. Благодаря этому, для каждого
    приложения необходимые компоненты можно "допилить"
    индивидуально.

    Также, можно все компоненты глобально привязать к 
    теме, и потом легко менять тему всего приложения
    (подробнее о темах см.ниже).

  • Непрерывность платформы: адаптация и мимикрия core-компонент под платформы

    Platform Continuity - встроенная фича Ionic Framework,
    позволяющая разработчикам приложений использовать один
    и тот же код для разных платформ.

    Каждый компонент в Ionic адаптирует свой внешний вид
    и поведение в зависимости от того, на какой платформе
    он запущен в настоящий момент.

    Например, устройства Apple, такие как iPhone и iPad,
    используют свой iOS design language. 
    Аналогично, на устройствах под управлением Android
    используется язык дизайна от Google - Material Design.

    Если вы скачаете Ionic-приложение из Apple App Store,
    Ionic применит к нему тему для iOS. А если скачаете
    из Google Play, то тему для Android Material Design.

    Для платформы pwa Ionic по умолчания будет применять
    тему Material Design.

    Наконец, всё это дело можно настраивать, какие темы
    для каких платформ применять.

  • Навигация, навигационные стеки, параллельная навигация

    Традиционные сайты используют линейную историю. Это значит,
    что пользователь переходит по ссылкам на сайте вперёд,
    а может нажимать на кнопку "назад" и возвращаться в обратном
    порядке. Грубо говоря, имеется лишь 1 "навигационный стек".

    Ionic-приложения в этом плане могут сделать следующий шаг,
    и обеспечить параллельную навигацию. Это значит, что можно
    иметь >= 1 навигационного стека, и переключаться между ними
    в любой момент.

    Для приложений, разрабатываемых на Angular и ionic/angular, 
    авторы рекомендуют использовать Angular Router. Предыдущая
    версия Ionic поставлялась со своим собственным, встроенным
    роутером. Однако, от этой практики отказались, так что
    используйте роутер от фреймворка.

  • Доступ к нативным платформам

    Удивительным следствием того факта, что Ionic построен
    на основе веб-технологий, является то, что Ionic-приложения
    может работать практически на любой платформе:

      ▪ desktop computers
      ▪ phones
      ▪ tablets
      ▪ cars
      ▪ refrigerators
      ▪ ...

    Один и тот же код Ionic-приложения может работать на 
    многих платформах благодаря тому, что он основан на
    веб-стандартах и общем API, который есть на многих
    платформах.

    Одним из наиболее частых случаев использования Ionic,
    это сделать разом приложение, которое можно скачивать
    как из App Store, так и из Play Store. Благодаря тому,
    что и SDK для iOS, и SDK для Android предоставляют
    возможность использовать так называемые "web views",
    которые могут отрисовывать любое Ionic-приложение,
    это становится возможным.

    Такие проекты, как Capacitor и Cordova обычно используются,
    чтобы дать Ionic-приложениям доступ к нативным платформам.
    На практике это значит, что разработчики могут быстренько
    запилить веб-приложение, имея при этом доступ ко всем нативным
    API (таким как камера, GPS, и т.д.), и завернуть его в 
    iOS и Android приложение, и залить в сторы.

  • Архитектура

    Ionic-приложения структурированы вокруг идее о компонентах.
    Используя любой фронтенд-фрейморк по выбору, вы можете
    строить приложение из компонент, как кирпичный домик. 
    Вообще, сейчас все топовые фронтенд-фреймворки по
    такому же принципу и работают.
    Высокоуровневые "views", это лишь компоненты, которые 
    доступны по URL.

  • Темы

    В ядре, Ionic Framework построен с использованием CSS.
    Это позволяет нам использовать преимущества, которые 
    обеспечивают css-переменные. Это даёт возможность 
    невероятно легко разрабатывать приложение, которое 
    и выглядит прекрасно, и соответствует веб-стандартам.

    Из коробки авторы предлагают набор цветов для кастомизации
    тем. Но никто не мешает вообще все перетряхнуть, и 
    кастомизировать так, как больше нравится, как больше
    подходит для конкретной компании.

    Подробнее про темы смотрете в отдельной главе.

> Поддержка браузерами

  Изначальной целью Ionic сделать простым делом разработку
  мобильных приложений с использованием веб-технологий:
  html, css, js. Это даёт возможность Ionic-приложению
  с одним и тем же кодом работать на многих устройствах, 
  операционных системах, и во многих браузера.

  • Поддержка браузерами на mobile

    ▪ Что с поддержкой у Ionic

      Поддержка браузерами на мобильных платформах была
      в центре внимания, и тщательно тестировалась на
      следующих операционных системах:

      ▪ Android >= 4.4
      ▪ iOS >= 10

    ▪ Что с поддержкой у Capacitor

      Надо также учитывать ограничения Capacitor, если использовать
      Ionic в связке с ним. Capacitor поддерживает следующие системы:

      ▪ Android >= 5.0
      ▪ iOS >= 10

      Так что, по факту, на работу приложения на Capacitor + Ionic
      на Android 4.* рассчитывать не стоит.

    ▪ Что с поддержкой у Cordova

      Надо также учитывать ограничения Capacitor, если использовать
      Ionic в связке с ней. Cordova поддерживает следующие системы:

      ▪ Android >= 4.0.3
      ▪ iOS >= 8

    ▪ Приложение на Capacitor и Ionic не пойдёт на 13.2% всех Android-устройств
    
      Это данные на июль 2018.
      Основаны на данных о распространении версий Android от Google

        https://developer.android.com/about/dashboards/ 

      Готовы ли мы терять 13.2% рынка всех android-устройств?

      p.s. 

        На январь 2018 эта цифра составляла 19.3%. То есть, 
        за 7 месяцев снижение на 5.9%.

    ▪ Приложение на Cordova и Ionic не пойдёт на 0.5% всех Android-устройств

      Это данные на июль 2018.
      Основаны на данных о распространении версий Android от Google

        https://developer.android.com/about/dashboards/ 

    ▪ Краткие выводы: Cordova или Capacitor?

      1. Если тенденция снижения доли устройств под управлением
         Android < 5.0.0 продолжится, и она будет падать
         примерно на 1% в месяц, то уже к новому году она
         сократится примерно до 8%, а к следующему лету
         до 2-3%.

      2. Для экспериментов со стартапами сейчас подойдёт
         и Capacitor. К моменту релиза MVP ближайшего стартапа,
         что произойдёт не ранее, чем через 3-6 месяцев, 
         доля устройств под управлением Android < 5.0.0 
         должна будет сократиться примерно до 8%, и их
         потерю на старте начинающий стартап вполне в силе
         пережить. Да и кроме того, если человек не в состоянии
         обновить свой древний смартфон на Android 4.*, то
         вероятность того, что он будет пользоваться услугами
         нашего сервиса мала.

  • Поддержка браузерами на desktop

    Ionic работает прекрасно не только на мобильных устройствах,
    но, поскольку он основан на веб-технологиях, то и в 
    браузерерах на desktop чувствует себя отлично:

    ▪ Chrome
    ▪ Safari
    ▪ Edge
    ▪ Firefox

    Вообще-то, Capacitor ещё позволяет собирать 
    electron-приложения

> Разъяснение за версии Ionic

  • Используется SemVer (major.minor.patch)

    Ionic Framework следует соглашению о семантическом 
    версионировании SevVer:

      major.minor.path

    Major-изменения вносят обратно-несовместимые изменения
    Minor-изменения вносят обратно-совместимые изменения.
    Path-изменения просто фиксят какие-то баги.

  • Расписание релизов

    • Major Release

      Такие релизы выходят, когда необходимо внести кардинальные
      изменения в API. Мажорные релизы будут выходить каждые
      6 месяцев, и будут обратно-совместимыми для большинства
      разработчиков. Несколько кандидатов на релиз будут 
      публиковаться до релиза, чтобы сообщество могло оценить их,
      и выбрать победителя на релиз.

    • Minor Release

      Минорные релизы публикуются, когда добавляется новая
      фича, или вносятся какие-то изменения в API (обратно-
      совместимые). Команда Ionic будет тщательно тестировать
      любые изменения, так что можете быть уверены, что
      после обновления ничего не сломается. Однако, с новым
      кодом потенциально идут новые проблемы.

      Минорные релизы будут выходить каждый месяц, если
      для их выпуска будет достаточно основания.

    • Patch Release

      Будут выходить сразу после того, как какой-нибудь баг
      исправлен. При этом, без изменений в API, и без 
      обратно-несовместимых изменений.

      Планируется выпускать такие релизы каждую неделю,
      или чаще, если надо очень быстро поправить какой-то
      баг.

      Patch-релизы всегда будут публиковаться до minor-релизов,
      чтобы удостовериться, что первые исправили соответствующие
      баги до того, и не создали новых, до того, как добавлять
      новую фичу.

  • Лог изменений

    Чтобы узнать, какие изменения внёс тот или иной релиз,
    пройдите в changlog.

> Поддержка

  • Long Term Support (LTS)

    Для major-релизов исправление багов производится в 
    течение 2-х лет, а проблем с безопасностью - 3-х лет.

    Это означает следующее.
    Допустим, есть нынешний major-релиз, это 4.*.*.
    И вот, сегодня, релизнулся 5.0.0.
    С этого момента, начинается отсчёт времени в условном
    таймере до смерти 4.*.* - ещё 2 года с этого момента
    будут фиксить баги, и 3 года - проблемы с безопасностью.

    До 4.0 LTS-версий фреймворка НЕ существует.
    Это - первая.

  • Платные опции поддержки

    Ionic предлагает платную поддержку для команд и организаций.
    Но она, в основном, никому не нужна, по мнению автора
    этой методички =)


А3. Установка Ionic
--------------------------------------

  # Установка через Ionic CLI

    ▪ Установка Ionic CLI
    ▪ Создание Ionic-приложения из шаблонов

  # Подключение через CDN

    ▪ Подключение Ionic Framework через CDN
    ▪ Подключение Ionicons из CDN

  # Настройка среды окружения

    ▪ Node & NPM
    ▪ Git

  # Настройка среды для разработки под iOS

    ▪ Xcode
      ▪ Настройка Development Team
      ▪ Создание симулятора iOS

    ▪ ios-sim & ios-deploy

  # Настройка среды для разработки под Android

    ▪ Java
    ▪ Gradle
    ▪ Android Studio
      ▪ Установка Android Studio
      ▪ Установка Android SDK
      ▪ Настройка CLI
      ▪ Создание Android Virtual Device
      ▪ Настройка Android Device

--------------------------------------

> Установка через Ionic CLI

  Ionic-приложения создаются и разрабатываются преимущественно
  с помощью Ionic CLI. Оный является предпочтительным способом
  установки Ionic, и предлагает много полезных в разработке
  инструментов. Через него также можно запускать приложение,
  и взаимодействовать с Ionic Pro.

  • Установка Ionic CLI

    Прежде, чем продолжить, убедитесь, что последние версии
    NodeJS и NPM установлены.

    Затем можно установить Ionic CLI глобально:

      sudo npm install -g @ionic/core

  • Создание Ionic-приложения из шаблонов

    Создать Ionic-приложение можно, использовав один из 
    шаблонов, либо пустой шаблон. Три наиболее популярных
    варианта, говорящих сами за себя:

    ▪ blank
    ▪ tabs
    ▪ sidemenu

    Пример:

      ionic start myApp tabs

    Подробнее про это читайте в главе про создание и 
    разработку Ionic-приложения.

> Подключение через CDN

  Поскольку Ionic Framework состоит из веб-компонент,
  возможно просто подключить его в HTML-файл через
  CDN.

  • Подключение Ionic Framework через CDN

    Рекомендуется использовать unpgk. Рекомендуется
    подключать Ionic в <head></head> в html-файле:

      <script src="https://unpkg.com/@ionic/core@latest/dist/ionic.js"></script>

    Подключив его таким образом, возможно использовать 
    компоненты Ionic без установки чего-либо.

  • Подключение Ionicons из CDN

    Если вы используете Ionic, Ionicons идут в комплекте,
    и их не надо отдельно устанавливать.

    Но если вы хотите использовать Ionicons без Ionic,
    то можете просто подключить их через CDN:

      <script src="https://unpkg.com/ionicons@4.0.0/dist/ionicons.js"></script>

> Настройка среды окружения

  Для работы с Ionic нужны NodeJS и NPM.

  • Node & NPM

    Почти все современные инструменты для JS-проектов 
    используют NodeJS. Ionic не исключение. Установите
    последние версии NodeJS и NPM.

    После установки проверьте версии, загуглите в инете,
    какие последние, и сравните.

      node -v
      npm -v

  • Git

    Хотя Git не необходим, рекомендуется установить 
    его в последней версии. Чтобы проверить версию:

      git -v

> Настройка среды для разработки под iOS

  Чтобы разрабатывать под iOS, надо поднастроить среду.
  Разрабатывать под iOS можно только на MacOS.
  Так что, если у вас Windows или Linux, виртуальная
  машина с MacOS вам в помощь.

  • Xcode

    Xcode, это IDE для создания нативных iOS-приложений.
    Она включает в себя iOS SDK и Xcode CLI.
    Xcode можно скачать в магазине приложений App Store.
    Для этого понадобится аккаунт Apple.

    ▪ Настройка Development Team

      Все iOS-приложения должны быть подписаны, даже те,
      которые в разработке. К счастью, Xcode позволяет 
      легко делать это автоматически. Для этого нужен
      лишь Apple ID.

      Откройте Xcode и идите в Xcode -> Preferences -> Accounts.
      Добавьте Apple ID, если его там нет ещё.
      Залогинившись, в списке команд появится ваша Personal Team.

    ▪ Создание симулятора iOS

      Симулятор iOS эмулирует iOS-устройства на MacOS.
      Вот официальная инструкция от Apple, как его 
      настроить:

        https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/simulator_help_topics/Chapter/Chapter.html

      В принципе, это легко. Пройдите в Window -> Devices and
      Simulators. Создайте, например, симулятор iPhone X.

  • ios-sim & ios-deploy

    ios-sim и ios-deploy, это инструменты для деплоя
    приложения в iOS-симулятор и iOS-устройства в 
    процессе разработки.

    Их можо установить глобально через npm:

      npm install -g ios-sim
      npm install -g ios-deploy

> Настройка среды для разработки под Android

  Чтобы разрабатывать под Android, надо поднастроить среду.
  В отличие от разработкипод iOS, под Android можно
  разрабатывать на Windows, MacOS и Linux.

  • Java

    Нативные приложения под Android компилируются с помощью
    Java. Скачайте JDK8 (JDK10 ещё слишком новый на 07.2018) с 
    официального сайта:

      http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

  • Gradle

    Gradle это инструмент для сборки, используемый в 
    Android-приложениях, и может быть установлен отдельно.

    См.официальный сайт с инструкцией, где описана его
    установка:

      https://gradle.org/install/

  • Android Studio

    Android Studio, это IDE для создания нативных 
    Android-приложений. Он включает Android SDK, который
    понадобится настроить для использования в командной
    строке.

    ▪ Установка Android Studio

      Качнуть Android Studio можно бесплатно с официального
      сайта:

        https://developer.android.com/studio/

    ▪ Установка Android SDK

      Откройте Android Studio. Оно само заметит, что
      требуется установить SDK. На экране SDK Components
      Setup, который сам появится, установите SDK. Обратите
      внимание на Android SDK Locatin.

      Когда SDK установитяс, закройте Android Studio.
      
      На будущее, управлять версиями Android SDK можно
      в Android Studio, в меню Configure -> SDK Manager.

    ▪ Настройка CLI

      Android SDK поставляется с полезным CLI. Но прежде, 
      чем его можно будет использовать, надо установить
      кое-какие переменные среды.

      Как это сделать на Windows, погуглите в инете.

    ▪ Создание Android Virtual Device

      Android Virtual Devices (AVDs) - образы, которые 
      эмулятор Android использует для запуска Android OS.
      Подробнее про это см.официальную документацию:

        https://developer.android.com/studio/run/managing-avds

      Вообще, это не сложно. Пройдите в Tools -> AVD Manager.
      Нажмите Create Virtual Device, и дальше всё понятно.

      Когда AVD создан, запустите его в эмуляторе.
      Во время разработки можно держать эмулятор включенным.

    ▪ Настройка Android Device

      Для разработки можно использовать не только эмулятор,
      но и настоящее устройство с Android. Но для начала
      это устройство надо подготовить. Ниже описан быстрый
      способ, но подробнее можете глянуть тут:

        https://developer.android.com/studio/run/device

      Итак, настраиваем устройство:

      1. Включить USB Debugging на устройстве

        Откройте Settings. Перейдите в Developer Options,
        и включите USB debugging.

        Саму Developer Options ещё надо включить, если она
        уже не включена:

          Настройки -> Система -> О телефоне -> 7 раз тап по "Номер сборки"

      2. Убедиться, что устройство имеет разрешение подключиться к компьютеру

        На MacOS никаких доп.усилий не требуется.
        Для Windows, установите OEM USB Drivers.

          https://developer.android.com/studio/run/oem-usb

      Затем подключите устройство к компьютеру через USB,
      и выполните команду:

        adb devices

      Будет выведен список подключенных устройств, и ваше
      должно быть в нём.


А4. Процесс разработки Ionic-приложения
--------------------------------------

  # Старт нового Ionic-приложения /Starting/

    ▪ Команда ionic start
    ▪ Типы шаблонов

  # Структура проекта и добавление ресурсов через CLI /Scaffolding/ 

    ▪ Основной код твоего приложения будет в src/
    ▪ Структура проекта (на примере проекта на angular)
    ▪ Генерирование новых фич

  # Адаптация и под браузер, и под приложения /Cross Platform/

    ▪ Кое-что надо иметь в виду при адаптации под разные платформы
    ▪ Разруливание запросов к несуществующим на текущей платформе API
      ▪ Разруливание с API в Ionic Native
      ▪ Как определить в коде, что за платформа?
      ▪ Разруливание с API в браузере
    ▪ Адаптивная разметка под десктопы и мобилки: компонент Grid
    ▪ Универсальный способ локального хранения данных: Ionic Storage
      ▪ Что такое Ionic Storage
      ▪ Список поддерживаемых Ionic Storage хранилищ
      ▪ Почему SQLite в приоритете?
      ▪ Пример использования Ionic Storage

  # Упрощённый запуск на устройствах через Ionic DevApp /Running Overview/ 

    ▪ Команда ionic serve, приложение DevApp, livereload из коробки
    ▪ Ionic DevApp доступен для iOS и Android
    ▪ Надо подключить устройство и комп к одной сети
    ▪ Инструкция, как пользоваться DevApp
    ▪ DevApp поддерживает ограниченный список плагинов

  # Как деплоить на iOS-платформу с помощью Cordova/Capacitor /Running on iOS/

    ▪ Предварительная настройка iOS-проекта
    ▪ Запуск iOS-приложения через Xcode
    ▪ Запуск iOS-приложения через Ionic CLI
    ▪ Использование Safari Web Inspector
    ▪ Просмотр нативных логов

  # Как деплоить на Android-платформу с помощью Cordova/Capacitor /Running on Android/

    ▪ Предварительная настройка Android-проекта
    ▪ Запуск Android-приложения с помощью Capacitor
    ▪ Запуск Android-приложения с помощью Cordova
    ▪ Использование Chrome DevTools для отладки
    ▪ Просмотр нативных логов

  # Организация unit-тестов в ionic/angular приложениях /testing/
  # Подробнее про Web View /Web View/

    ▪ Что такое Web View
    ▪ CORS (кросс-доменный AJAX) всегда включен в Web View
      ▪ Что такое CORS
      ▪ Нативный плагин, чтобы обойтись без CORS
      ▪ Чеклист на пригодность к CORS для сервера
      
    ▪ Конвертация запросов file:// в http:// для Cordova и Capacitor
      ▪ Что на Cordova
      ▪ Что на Capacitor

    ▪ Реализации Web View на разных платформах

  # Про Ionic Storage /Ionic Storage/
  
    ▪ Как работает Ionic Storage
      ▪ Список поддерживаемых Ionic Storage хранилищ
      ▪ Почему SQLite в приоритете?
    ▪ Использование Ionic Storage
    ▪ Настройка Ionic Storage
    ▪ API для Ionic Storage
      
      Методы
      ▪ constructor   | создать новый экземпляр хранилища
      ▪ clear         | полностью очистить хранилище
      ▪ forEach       | пробежаться по всем парам key/value в хранилище
      ▪ get           | получить значение, связанное с указанным ключом
      ▪ keys          | список всех ключей в хранилище
      ▪ length        | кол-во ключей в хранилище
      ▪ ready         | готово ли хранилище
      ▪ remove        | удаление из хранилище пары key/value по ключу

      Свойства
      ▪ driver        | получить имя используемого драйвера
  
--------------------------------------

> Старт нового Ionic-приложения /Starting/

  • Команда ionic start

    Создать новое Ionic-приложение очень просто. Это
    можно сделать из командной строки командой:

      ionic start

    которая запросит инфу об имени проекта, и какой шаблон
    использвоать.

    В принципе, можно избежать интерактивных запросов и 
    указать все параметры сразу:

      ionic start myApp tabs --type=angular

    где myApp - название, tabs - тип, angular - фреймфорк.

  • Типы шаблонов 

    ▪ tabs
    ▪ sidemenu
    ▪ blank

    Посмотреть список всех доступных шаблонов можно
    командой:

      ionic start --list

    Эти шаблоны представляют собой отличное начало для
    любого приложения, и включают все лучшие практики
    для того, чтобы было потом легко поддерживать
    и масштабировать код.
    
> Структура проекта и добавление ресурсов через CLI /Scaffolding/

  • Основной код твоего приложения будет в src/

    Создав приложение из шаблона с помощью Ionic CLI, следующим
    шагом будет работа над фичами и компонентами. Большая
    часть разработки приложения будет проходить в папке src/

  • Структура проекта (на примере проекта на angular)

    src/
      app/                    | здесь основной код приложения
        components/
        pages/
        services/
        app.component.html
        app.component.spec.ts
        app.component.ts
        app.module.ts
        app-routing.module.ts
      assets/                 | папка для всяких ресурсов, типа картинки/шрифты/итп
      environments/
      theme/
      global.scss
      index.html              | точка входа в приложение
      karma.conf.js           | конфиг Angular'овского фреймворка для тестов
      main.ts
      polyfills.ts
      test.ts
      tsconfig.app.json
      tsconfig.spec.json

  • Генерирование новых фич

    Ionic CLI, с помощью коменды ionic generate, может
    генерировать различные ресурсы в проекте.

    Чтобы посмотреть, что именно оно может генерировать,
    запустите эту команду без аргументов:

      ionic generate
      ionic g         | сокращённый вариант

    Когда вы выберете, что именно хотите сгенерировать,
    Ionic запросит у вас name. Крайне рекомендуется
    префиксить name путём относительно корня проекта,
    чтобы ресурс генерировался там, где положено
    (почему-то Ionic CLI не может это сам делать)
   
      Например:

        pages/My New Page         |
        pages/tabs/Main Tab       | любой уровень вложенности
        pages/tabs/my/Main Tab    | 
      
      вместо просто названия без префикса:

        My New Page

    Чтобы избежать интерактивных запросов, можно указать
    name и type сразу в команде:

      ionic g page "pages/User Detail"

    где page - тип ресурса, "pages/User Detail" - где его создать.
    Ionic CLI использует за кадром инструменты фреймворка,
    чтобы оставаться максимально близко к лучшим практикам.
    Для ionic/angular, под капотом используется Angular CLI.

    После создания файлов и каталогов для новой страницы,
    CLI также автоматически обновит конфигурацию роутера,
    чтобы включить туда новую страницу. Это уменьшает
    кол-во работы, которую требуется проделать вручную.

    Справку про ionic g моно посмотреть так:

      ionic g --help

> Адаптация и под браузер, и под приложения /Cross Platform/

  • Кое-что надо иметь в виду при адаптации под разные платформы

    Ionic изначально создавался таким, чтобы разработка
    была лёгкой, вне зависимости от того, для какой
    платформы предназначается приложение.

    Ionic-приложения реально кроссплатформенные: работают
    на Android, iOS, Electron и PWA, и все это один и 
    тот же код.

    Однако, есть ряд вещей, которые надо иметь в виду, 
    оптимизируя приложение для работы на раных платформах.

  • Разруливание запросов к несуществующим на текущей платформе API

    Например, в коде нативных приложений могут производиться 
    запросы к API соответствующих нативных платформ, такие 
    например, как открытие камеры или получение геолокационных
    данных. 

    Эти запросы не будут работать при выполнении на pwa, 
    например, ведь там соответствующие API отсутствуют.
    В этом пункте описано, как разруливать эту ситуацию.

    ▪ Разруливание с API в Ionic Native

      Ionic Native имеет свою внутреннюю логику, чтобы
      определять, выполняется ли он в настоящий момент
      на той или иной платформе.

      Вместо возбуждения ошибки, он просто выведет в лог
      предупреждение, если выполняется не на нативной
      платформе, и соответствующие Cordova-плагины
      недоступны.

      Приложение не сломается, и продолжит работать,
      без соответствующего нативного функционала.

    ▪ Как определить в коде, что за платформа?

      В логике приложения, при каждом запросе к нативному 
      API, рекомендуется всегда проверять, на какой
      платформе происходит выполнение (ниже пример
      для Cordova):

        this.platform.ready().then(() => {
          if (this.platform.is('cordova')) {
            // make your native API calls
          } else {
            // fallback to browser APIs
          }
        });

    ▪ Разруливание с API в браузере

      Многие нативные API недоступны в браузере. С другой
      стороны, браузерное API постоянно улучшаетя и 
      дополняется. Надо по-умному всё делать, чтобы
      если, допустим, надо выбрать какой-то файл,
      но нативное API файловой системы недоступно, 
      и дело происходит в браузере, тогда открывалось
      окно с выбором файла на компе.

  • Адаптивная разметка под десктопы и мобилки: компонент Grid

    Если вы целитесь не только на мобильные платформы
    iOS и Android, но и хотите, чтобы ваше приложение
    нормально отображалось на компьютере в браузере,
    или через Electron, где ширина экрана большая,
    вам надо особое внимание уделить адаптивному
    дизайну.

    К счастью, в Ionic есть компонент Grid. Поэтому,
    можно завернуть контент в <ion-grid>...</ion-grid>,
    и сделать сеточку. Она, по сути, клон оной из
    бутстрапа.

    Пример:

      <ion-grid>
        <ion-row>
          <ion-col>
            <ion-item>
              <ion-label>Item 1</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 2</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 3</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 4</ion-label>
            </ion-item>
          </ion-col>
          <ion-col>
            <ion-item>
              <ion-label>Item 5</ion-label>
            </ion-item>
          </ion-col>
        </ion-row>
      </ion-grid>    
    
    С помощью атрибута fixed в элементе ion-grid можно
    сделать ширину элементов фиксированной, на основе
    ширины экрана (имеется в виду использование
    приставок типа -sm, -md, -lg, xl). Это хорошо для очень широких экранов,
    когда элементы стали бы необузданно растягиваться
    в ширину без этого атрибута.

    Прописав fixed, мы можем в элементе ion-col указать
    size по умолчанию в кол-ве столбцов (всего в сетке
    Ionic 12 столбцов, => 12 - это max ширина), а также
    размеры на основе текущей ширины браузера, такие как
    size-sm, size-md, size-lg, size-xl.

    Пример:

      <ion-grid fixed>
        <ion-row>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 1</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 2</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 3</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 4</ion-label>
            </ion-item>
          </ion-col>
          <ion-col size="12" size-sm="9" size-md="6" size-lg="4" size-xl="3">
            <ion-item>
              <ion-label>Item 5</ion-label>
            </ion-item>
          </ion-col>
        </ion-row>
      </ion-grid>

  • Универсальный способ локального хранения данных: Ionic Storage

    ▪ Большинству приложений надо хранить какие-то данные локально

      Большинству приложений надо сохранять какие-то 
      данные локально. Это может быть результат XHR-запроса
      в виде JSON-строки, или аутентификационный токен,
      или что-то ещё. 

      В принципе, для приложений, работающих в нативных
      средах, можно создать полноценную базу данных на
      основе SQLite, и складывать данные туда.

      Все эти механизмы для хранения данных имеют свои
      преимущества и недостатки, но разработчикам на
      Ionic не стоит об этом волноваться.. ведь есть
      Ionic Storage.

    ▪ Библиотека Ionic Storage

      ▪ Что такое Ionic Storage

        Это простое key-value хранилище для Ionic-приложений,
        основанное на LocalForage, с поддержкой SQLite из
        коробки. 

        Оно позволяет использовать лучшее доступное хранилище
        без необходимости взаимодействовать с ним напрямую,
        а используя один и тот же API.

      ▪ Список поддерживаемых Ionic Storage хранилищ

        В настоящий момент (конец июля 2018), отсортированный 
        список поддерживаемых хранилищь от лучшего к худшему:

        ▪ SQLite
        ▪ IndexedDB
        ▪ WebSQL
        ▪ LocalStorage

      ▪ Почему SQLite в приоритете?

        Одной важной причиной, по которой SQLite в приоритете,
        является то, что многие нативные платформы (iOS, например),
        в настоящее время, периодически и непредсказуемо чистят
        Local Storage (и IndexedDB), когда устройству начинает
        не хватать памяти. Чтобы избежать потери данных, лучше
        использовать хранищище с файлами, такое как SQLite.

      ▪ Пример использования Ionic Storage

        class MyClass {
          constructor(public storage: Storage) {}

          setData(key, value) {
            this.storage.set(key, value)
            .then(res => console.log(res))
          }
          getData(key) {
            this.storage.get(key)
            .then(keyVal => console.log('Key is', keyVal))
          }
        }      

> Упрощённый запуск на устройствах через Ionic DevApp /Running Overview/ 

  • Команда ionic serve, приложение DevApp, livereload из коробки

    Ionic DevApp расширяет возможности Ionic'а, позволяя
    легко тестировать приложения прямо на устройствах.
    DevApp предлагает наблюдать изменения в реальном времени,
    с богатой библиотекой предустановленных нативных плагинов
    для тестирования нативной функциональности приложения.

    Нет необходимости устанавливать сложные нативные SDK - 
    всё проворачивается одной простой командой:

      ionic serve

    после чего приложение будет немедленно готово к тестированию
    на всех устройствах, где установлен DevApp, с работающим
    из коробки LiveReload.

  • Ionic DevApp доступен для iOS и Android

    Чтобы начать пользоваться DevApp, надо сначала его
    установить на соответствующие устройства. Он
    бесплатен, нужно только завести Ionic-аккаунт.

  • Надо подключить устройство и комп к одной сети

    Чтобы вся эта тема с DevApp работала, необходимо,
    чтобы устройство с установленным на него и запущенным
    приложением DevApp, и компьютер, на котором вы ведёте
    разработку Ionic-приложения, были в одной сети.

  • Инструкция, как пользоваться DevApp

    1. Установить DevApp на устройство, и запустить.
    2. Подключить устройство и компьютер к одной сети.
    3. На компьютере выполнить в корне проекта:

      ionic serve

    4. На устройстве в DevApp ваш компьютер должен стать
       виден, выберите его из списка.
    5. Теперь, если вы обращаетесь к какой-то нативной
       функциональности, DevApp может это обрабатывать
       и возвращать корректную нативную имплементацию.

  • DevApp поддерживает ограниченный список плагинов

    Воспользуйтесь документацией по DevApp, чтобы
    проверить, какой список плагинов оно поддерживает
    в настоящий момент:

      https://ionicframework.com/docs/pro/devapp/

> Как деплоить на iOS-платформу с помощью Cordova/Capacitor /Running on iOS/

  В этом руководстве описано, как деплоить iOS-приложения,
  написанные на Ionic, с помощью Capacitor и Cordova.

  Есть 2 способа запускать Ionic-приложения на iOS:

    ▪ Через Xcode
    ▪ Через Ionic CLI (преимущество: live-reload)

  • Предварительная настройка iOS-проекта

    Перед тем, как приложения могут быть развернуты на 
    iOS-эмуляторах и устройствах, надо сначала
    настраивать из нативные проекты.

    1. Сгенерировать нативный проект, если он ещё не существует

      ▪ Capacitor

        ionic capacitor add ios

      ▪ Cordova

        ionic cordova prepare ios
 
    2. Установка "Package ID"

      ▪ Capacitor

        Откройте файл capacitor.config.json, и измените
        свойство appId.

      ▪ Cordova

        Откройте файл config.xml и измените атрибут
        id корневого элемента <widget>.

    3. Открытие проекта в Xcode

      ▪ Capacitor

        Либо запустите Xcode и откройте в нём проект 
        самостоятельно, либо выполните эту команду:

          ionic capacitor open ios

      ▪ Cordova    

        Запустите Xcode и откройте в нём проект, который
        находится в папке platforms/ios.

    4. Сверка Package ID

      В Xcode, слева, в навигации по проекту, выделите
      корневую папку, чтобы открылся редактор проекта.
      В разделе "Identity", удостоверьтесь, что Package ID
      совпадает с оным, который вы установили в пункте 2.

    5. Проверка, что "Automatically manage signing" включено

      В том же редакторе проекта, что в пункте 4, 
      в разделе "Signing" удостоверьтесь, что
      "Automatically manage signing" включёно.

      После чего, в дропбоксе ниже выберите соответствующую
      "Development Team" (как её сделать см.в методичке
      по Capacitor). После этого, Xcode попытается автоматически
      подписать ваш код.

  • Запуск iOS-приложения через Xcode

    В этом процессе, Xcode может автоматически решать
    общие проблемы с компиляцией и подписыванием кода.

    1. Разработать Ionic-приложение и синхронизировать файлы с нативной платформой

      После любых изменений, надо пересобирать Ionic-приложение,
      и лишь затем изменения можно увидеть на эмуляторе или 
      устройстве. Полученные после сборки www-файлы должны быть
      скопированы на платформу нативного проекта, для этого
      надо выполнить команду:

      ▪ Capacitor

        ionic capacitor copy ios

      ▪ Cordova      

        ionic cordova prepare ios

    2. Запуск проекта в эмуляторе, или на девайсе

      В Xcode, выберите эмулятор или устройство,
      и нажмите кнопку Play.

  • Запуск iOS-приложения через Ionic CLI

    Ionic CLI может собирать, копировать и развёртывать
    Ionic-приложения на iOS-эмуляторах и устройствах
    одной командой. 

    Также, он может поднять dev-сервер на NodeJS с 
    функционалом live-reload из коробки.

    ▪ Capacitor

      К сожалению, на конец июля 2018, live-reload для
      Capacitor ещё не работает.

    ▪ Cordova

      Выполните следующую команду, чтобы поднять
      сервер с live-reload:

        ionic cordova run ios -l

      После этого, каждый раз, когда вы будете вносить
      изменения в исходные файлы проекта, www-файлы
      пересобираются, копируются в проект, и вы сразу
      видите изменения на эмуляторе или устройстве
      без необходимости переразворачивать приложение.

  • Использование Safari Web Inspector

    В Safari есть поддержка Web Inspector для iOS эмуляторов
    и устройств. Откройте меню "Develop" и выберите эмулятор
    или устройство, затем выберите Ionic-приложение, чтобы
    открыть Web Inspector.

    Если меню Develop скрыто, включите его в настройках:
    Safari -> Preferences -> Advanced.

  • Просмотр нативных логов

    Нативные логи можно просмотреть в Xcode в Console.
    Если Console скрыта, включите её в настройках:
    View -> Debug Area -> Activate Console.

> Как деплоить на Android-платформу с помощью Cordova/Capacitor /Running on Android/

  В этом руководстве описано, как деплоить Android-приложения,
  написанные на Ionic, с помощью Capacitor и Cordova.

  Чтобы деплоить приложения на устройство с Android и 
  отлаживать их, разработчик должен включить на устройстве
  "developer mode" и "USB debugging". Как это сделать,
  описано здесь:

    https://developer.android.com/studio/debug/dev-options#enable

  • Предварительная настройка Android-проекта

    1. Сгенерировать нативный проект, если он ещё не существует

      ▪ Capacitor

        ionic capacitor add android

      ▪ Cordova

        ionic cordova prepare android

    2. Установка "Package ID"

      ▪ Capacitor

        Откройте файл capacitor.config.json, и измените
        свойство appId.

      ▪ Cordova

        Откройте файл config.xml и измените атрибут
        id корневого элемента <widget>.

  • Запуск Android-приложения с помощью Capacitor

    Capacitor использует Android Studio для сборки
    и выполнения приложения на эмуляторе или устройстве.

    К сожалению, на конец июля 2018, live-reload для
    Capacitor ещё не работает.

    1. Разработать Ionic-приложение и синхронизировать файлы с нативной платформой

      После любых изменений, надо пересобирать Ionic-приложение,
      и лишь затем изменения можно увидеть на эмуляторе или 
      устройстве. Полученные после сборки www-файлы должны быть
      скопированы на платформу нативного проекта, для этого
      надо выполнить команду:

      ionic capacitor copy android

    2. Запуск проекта в эмуляторе, или на девайсе

      В Android Studio, выберите эмулятор или устройство,
      и нажмите кнопку Run.

  • Запуск Android-приложения с помощью Cordova

    Ionic CLI может собирать, копировать и развёртывать
    Ionic-приложения на iOS-эмуляторах и устройствах
    одной командой. 

    Также, он может поднять dev-сервер на NodeJS с 
    функционалом live-reload из коробки.

    Выполните следующую команду, чтобы поднять
    сервер с live-reload:

      ionic cordova run ios -l

    После этого, каждый раз, когда вы будете вносить
    изменения в исходные файлы проекта, www-файлы
    пересобираются, копируются в проект, и вы сразу
    видите изменения на эмуляторе или устройстве
    без необходимости переразворачивать приложение.

  • Использование Chrome DevTools для отладки

    DevTools в Chrome поддерживает эмуляторы Android и
    устройство. Откройте Chrome и идите в 

      chrome://inspect

    при подключенном устройсте или запущенном эмуляторе,
    и выберите там приложение, которое надо отладить.

  • Просмотр нативных логов

    Нативные логи можно просматривать в Android Studio,
    в Console.

> Организация unit-тестов в ionic/angular приложениях /testing/

  Когда вы генерируете ionic/angular приложение через
  Ionic CLI, в нём автоматически настраиваются юнит-тесты
  через Jasmine. Это тоже самое, что происходит при создании
  нового проекта через Angular CLI. Подробнее о тестировании
  Angular-приложений написано в официальной инструкции:

    https://angular.io/guide/testing

  *Примечание автора методички:

    Подробно я не стал расписывать эту главу, поскольку
    она целиком про Angular, а я испольщую Vue.

> Подробнее про Web View /Web View/

  Web View позволяет запускать веб-приложения на нативных
  устройствах. 

  Ionic поддерживает Web View Plugin для приложений, 
  использующих Cordova. Плагин предоставляется
  автоматически при использовании с Ionic CLI.

  Для приложений, использующих Capacitor, Web View
  автоматически предоставляется.

  • Что такое Web View

    Ionic-приложения строятся с использованием веб-технологий,
    и отрисовываются с помощью Web Views, которые являются
    полноэкранными и полнофункциональными браузерами.

    Современные Web Views предлагают много встроенных HTML5
    APIs для доступа к нативному функционалу платформ, 
    такому как камиры, сенсоры, GPS, динамики, Bluetooth.
    Но часто требуется иметь доступ к специфичным для 
    платформ API - в Ionic-приложениях такой доступ
    приложение получает через связующий слой, который
    представляет из себя нативный плагин с JS-API.

    Ionic Web View плагин заточен под современные JS-приложения.
    Для iOS и Android, файлы приложения всегда хостятся с
    использованием протокола http:// на оптимизированном
    HTTP-сервере, который запускается на локальном устройстве.

  • CORS (кросс-доменный AJAX) всегда включен в Web View

    ▪ Что такое CORS

      Существует такая вещь в браузерах, как same-origin-policy 
      ля XSS (кросс-доменных запросов), которая мешает из JS 
      на одном сайте/домене слать запросы на любые другие домены.

      Так вот, технология CORS в современных браузерах позволяет
      преодолеть same-origin-policy. Идея проста – пусть клиент 
      шлет Аякс-запрос к чужому серверу. Браузер добавит в 
      запрос особые заголовки с информацией о том, что запрос 
      с другого домена. На их основании сервер решит, как 
      обрабатывать такой запрос, и добавит особые заголовки 
      в ответ. Удобно, правда?

      Подробнее читайте:

        http://grishaev.me/cors
        https://enable-cors.org/
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

    ▪ Нативный плагин, чтобы обойтись без CORS

      Если CORS не реализован на сервере, есть нативный плагин:

        https://beta.ionicframework.com/docs/native/http/

      который выполняет HTTP-запросы в нативном слое, которым
      не требуется CORS.

    ▪ Чеклист на пригодность к CORS для сервера

      Многие веб-фреймворки могут иметь встроенную поддержку
      CORS, либо какие-то дополнения, например, как пакет
      cors для Express. Если такого нет, то надо выполнить
      следующие действия, чтобы CORS на сервере мог работать:

      1. Разрешить http://localhost:8080 в качестве origin
         (см. Access-Control-Allow-Origin)

          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin

      2. Разрешить любые необходимые HTTP-методы
         (см. Access-Control-Allow-Methods)

          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods

      3. Разрешить любые необходимые HTTP-заголовки
         (см. Access-Control-Allow-Headers)

          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers

      4. Убедитсья, что сервер может обрабатывать
         preflight requests.

          https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request

  • Конвертация запросов file:// в http:// для Cordova и Capacitor

    Приложения на Cordova или Capacitor хостятся на локальном
    HTTP-сервере и работаю на протоколе http://

    Некоторые плагины, однако, пытаются получить доступ
    к файлам устройства через протокол file://

    Чтобы избежать проблем, пути к файлам на устройстве 
    должны быть переписаны на http-протокол. Например,
    путь:

      file:///path/to/device/file

    надо переписать по такому шаблону:

      http://<host>:<port>/<prefix>/path/to/device/file

    ▪ Что на Cordova

      Для Cordova-приложений Ionic Web View Plugin предоставляет
      функцию для конвертирования файловых URL: 

        window.Ionic.WebView.convertFileSrc()

      И есть соответствующий нативный плагин:

        @ionic-native/ionic-webview.

    ▪ Что на Capacitor

      В Capacitor-приложениях, файловые URL конвертируются
      автоматически.

  • Реализации Web View на разных платформах

    ▪ WKWebView на iOS

      https://developer.apple.com/documentation/webkit/wkwebview

    ▪ Web View на Android

      https://developer.chrome.com/multidevice/webview/overview

> Про Ionic Storage /Ionic Storage/

  • Как работает Ionic Storage

    Ionic Storage позволяет легко сохранять пары key/value
    и JSON-объекты. По сути, это один API для нескольких
    реализаций хранилищ, которые оно поддерживает. В зависимости
    от платформы, оно само решает, какую реализацию хранилища
    целесообразнее всего использовать, и применяет её.

    Когда запускаешь приложение на нативной платформе, 
    Storage отдаёт предпочтение SQLite, как одной из
    наиболее широко-используемых и основанных на сохранении
    данных в файлы баз данных. 

    Если приложение работает на web или pwa, Storage будет
    пробовать использовать IndexedDB, WebSQL и Localstorage,
    именно в таком порядке.

    ▪ Список поддерживаемых Ionic Storage хранилищ

      В настоящий момент (конец июля 2018), отсортированный 
      список поддерживаемых хранилищь от лучшего к худшему:

      ▪ SQLite
      ▪ IndexedDB
      ▪ WebSQL
      ▪ LocalStorage

    ▪ Почему SQLite в приоритете?

      Одной важной причиной, по которой SQLite в приоритете,
      является то, что многие нативные платформы (iOS, например),
      в настоящее время, периодически и непредсказуемо чистят
      Local Storage (и IndexedDB), когда устройству начинает
      не хватать памяти. Чтобы избежать потери данных, лучше
      использовать хранищище с файлами, такое как SQLite.    

  • Использование Ionic Storage

    Если вы предпочитаете использовать SQLite, установите
    cordova-sqlite-storage plugin:

      ionic cordova plugin add cordova-sqlite-storage

    Затем установите соответствующий пакет (идёт по 
    умолчанию для Ionic-приложений >= V2):

      npm install --save @ionic/storage

    Затем, добавьте в список imports в вашем объявлении 
    NgModule. Например в src/app/app.module.ts:

      import { IonicStorageModule } from '@ionic/storage';

      @NgModule({
        declarations: [
          // ...
        ],
        imports: [
          BrowserModule,
          IonicModule.forRoot(MyApp),
          IonicStorageModule.forRoot()
        ],
        bootstrap: [IonicApp],
        entryComponents: [
          // ...
        ],
        providers: [
          // ...
        ]
      })
      export class AppModule {}

    Наконец, вставьте в ваше приложение:

      import { Storage } from '@ionic/storage';

      export class MyApp {
        constructor(private storage: Storage) { }

        ...

        // set a key/value
        storage.set('name', 'Max');

        // Or to get a key/value pair
        storage.get('age').then((val) => {
          console.log('Your age is', val);
        });
      }

  • Настройка Ionic Storage

    Storage Engine может быть настроен как конкретными
    свойствами движка хранилища, так и кастомными 
    опциями для передачи в LocalForge.
    Подробнее об этом:

      https://github.com/localForage/localForage#configuration

    *Примечание:

      Любые кастомные конфигурации будут смёржены с 
      дефолнтыми конфигурациями.

    import { IonicStorageModule } from '@ionic/storage';

    @NgModule({
      declarations: [...],
      imports: [
        IonicStorageModule.forRoot({
          name: '__mydb',
    driverOrder: ['indexeddb', 'sqlite', 'websql']
        })
      ],
      bootstrap: [...],
      entryComponents: [...],
       providers: [...]
    })
    export class AppModule { }

  • API для Ionic Storage

    ▪ constructor
      создать новый экземпляр хранилища

      Создать новый экземпляр хранилища. Какой драйвер будет
      использован, зависит от алгоритма этого метода, как он
      работает описано выше в пункте про хранилища. Доступные
      драйверы, в порядке приоритетности:

        ['sqlite', 'indexeddb', 'websql', 'localstorage']

    ▪ clear
      полностью очистить хранилище

      Внимание: операция тяжёлая! 
      Возвращает: промис, который разрешается, когда
                  хранилище успешно очищено.

    ▪ forEach
      пробежаться по всем парам key/value в хранилище

      Возвращает: промис, который разрешается, когда
                  итерирование завершено.

    ▪ get
      получить значение, связанное с указанным ключом

      Возвращает: промис, который разрешается, когда
                  значение успешно извлечено.

    ▪ keys
      список всех ключей в хранилище

      Возвращает: промис, который разрешается, когда 
                  список ключей успешно извлечён.


    ▪ length  
      кол-во ключей в хранилище

      Возвращает: промис, который разрешается, когда
                  кол-во ключей в хранилище пересчитано.

    ▪ ready
      готово ли хранилище

      Возвращает: промис, который разрешается, когда
                  хранилище готово к использованию.

    ▪ remove
      удаление из хранилище пары key/value по ключу

      Возвращает: промис, который разрешается, когда
                  значение удалено.
    
    ▪ driver
      получить имя используемого драйвера


А5. Компоненты Ionic'а
--------------------------------------

  # О компонентах Ionic'а
  # Список core-компонентов Ionic'а

    ▪ Action Sheet    | вылезающее снизу окошко со списом действий
    ▪ Alert           | модальное окошко с текстом, inputs, кнопками
    ▪ Badge           | бэйдж с цифрой, как правило, внутри элемента
    ▪ Button          | кастомизируемая кнопка, обычная/круглая/FAB/outline/...
    ▪ Card            | карточка с контентом
    ▪ Checkbox        | чекбокс с внершим видом: чекбокса, радиобуттона, переключателя
    ▪ DateTime        | date time picker
    ▪ Fab             | FABы (плавающие кнопки действия)
    ▪ Grid            | CSS-сеточка для формирования макате приложения (клон Bootstrap'овской)
    ▪ Infinite scroll | бесконечный скролл с триггерами от дистанции снизу/сверху документа
    ▪ Input           | обычный текстовый input
    ▪ List            | списочек, позволяет организовать разное в список
    ▪ Loading         | загрузочка, модальный экран загрузки со спинером
    ▪ Menu            | менюшечка обычная, появляется слева по кнопке или свайпу
    ▪ Modal           | модалочка полноэкранная, отображает временный UI
    ▪ Nav             | навигация между страницами приложения
    ▪ Popover         | тултипчик с расширенным функционалом
    ▪ Range           | слайдерок, для выбора значения из диапазона
    ▪ Refresher       | обновлялочка, тянешь вниз и контент обновляется
    ▪ Searchbar       | искалочка, input для поиска/фильтрации
    ▪ Select          | аналог обычного select с расширенным функционалом
    ▪ Slides          | слайдер страниц, с пролистыванием свайпами
    ▪ Spinner         | набор анимированных SVG-спинеров
    ▪ Tabs            | навигационные табы
    ▪ Toast           | тосты обыкновенные, быстро появляются и исчезают
    ▪ Virtual Scroll  | производительный скроллинг больших списков

--------------------------------------

> О компонентах Ionic'а

  Ionic-приложения разрабатываются из высокоуровневых
  блоков, которые мы занываем "компоненты".

  Компоненты позволяют вам быстро собирать интерфейсы
  ваших приложений. Ionic поставляется с набором
  core-компонентов, включая модалки, попапы и карточки.

  Ниже вы можете найти их список, краткие описания, 
  и небольшие примеры кода. Живые примеры работы
  компонентов смотрите в официальной документации
  Ionic.

  Подробные же их API можете посмотреть в главе
  Ionic API.

> Список core-компонентов Ionic'а

  • Action Sheet | вылезающее снизу окошко со списом действий 

    Action Sheet вылезает снизу-вверх через нижний край
    экрана, и выводит список доступных действий.

    Иногда, список действий можно использовать в качестве
    альтернативы для меню, хотя, использовать его для
    навигации не рекомендуется.

  • Alert | модальное окошко с текстом, inputs, кнопками

    Представляет собой нечто большее, чем классический
    алерт из браузеров.

    Алерт является прекрасным способом предложить пользователю
    выбрать конкретное действие, или список действий. Алерты
    могут содержать текст, инпуты и кнопки. Они могут помочь
    показать пользователю важную информацию, или потребовать
    от него принять одно или несколько решений.

    Алерты следует использовать только для быстрых действий,
    таких как верификация пароля, маленькое уведомление от
    приложения, или быстрый выбор опций.

  • Badge | бэйдж с цифрой, как правило, внутри элемента
    

    Компонент значок - маленький компонент, через который,
    обычно, пользователю сообщается какое-то цифровое
    значение. Чаще всего используется внутри какого-нибудь
    элемента.

    Пример использования, кол-во новых сообщений от 
    пользователей в чате. Есть список пользователей,
    где в каждом элементе списка появляется значок
    с кол-вом новых сообщений от данного пользователя.

    Пример кода:

      <!-- Default -->
      <ion-badge>99</ion-badge>

      <!-- Colors -->
      <ion-badge color="primary">11</ion-badge>
      <ion-badge color="secondary">22</ion-badge>
      <ion-badge color="tertiary">33</ion-badge>
      <ion-badge color="success">44</ion-badge>
      <ion-badge color="warning">55</ion-badge>
      <ion-badge color="danger">66</ion-badge>    

  • Button | кастомизируемая кнопка, обычная/круглая/FAB/outline/...

    Кнопки являются важным способом взаимодействовать с 
    приложением, и перемещаться по нему. Они должны
    ясно сообщать, какое действие последует после 
    нажатия на них. Компонент Button позволяет серьёзно
    кастомизировать кнопки, изменяя цвет, форму и размер.

    Поддерживаются разные кнопки:

    ▪ Круглые
    ▪ FAB
    ▪ Outline-кнопки
    ▪ ... и многие другие ...

    Пример кода:

      <ion-button shape="round" color="primary" fill="outline">Hello World</ion-button>
      <ion-button size="small">Small Button</ion-button>

  • Card | карточка с контентом

    Компонент карточка является отличным способом отображать
    важные кусочки контента, и быстро становится основным
    шаблоном проектирование приложений.

    Карточка может содержать картинки, кнопки, текст и 
    много чего ещё. 

    Можно использовать одну карточку, можно список карточек,
    а можно сетку карточек.

    Пример кода:

      <ion-card>
        <ion-img src="/assets/myImg.png"></ion-img>

        <ion-card-content>
          <ion-card-title>Hello World</ion-card-title>

          <p>The content for this card</p>
        </ion-card-content>
      </ion-card>    

  • Checkbox | чекбокс с внершим видом: чекбокса, радиобуттона, переключателя

    Чекбоксы могут быть использованы в ситуациях, когда 
    нужно дать пользователю возможность сделать бинарное
    решение. 

    Чекбокс обеспечивает четкую визуализацию выбора в 
    стиле true/false.

    ion-checkbox ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Вы моете использовать:

                        Какой внешний вид предпочитаете
    ▪ ion-checkbox    | похожий на чекбоксы
    ▪ ion-radio       | похожий на радиобуттоны
    ▪ ion-toggle      | похожий на переключатели

    Пример кода:

      <ion-checkbox color="primary" checked></ion-checkbox>
      <ion-checkbox color="secondary"></ion-checkbox>
      <ion-checkbox color="danger" checked></ion-checkbox>
      <ion-checkbox color="light"></ion-checkbox>
      <ion-checkbox color="dark" checked></ion-checkbox>

  • DateTime | date time picker

    DateTime позволяет пользователю легко выбрать дату и
    время. Будет выглядить нативно на iOS, а для прочих
    платформ будет использоваться Material Design.

    DateTime ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-label>Date</ion-label>
        <ion-datetime display-format="MM/DD/YYYY"></ion-datetime>
      </ion-item>

  • Fab | FABы (плавающие кнопки действия)

    FAB расшифровывается, как FLOATING ACTION BUTTON,
    или, плавающая кнопка действия.

    Представляет из себя круглую кнопку, которая выполняет
    главное, или наиболее часто используемое действие
    на экране.

    Она может находиться в разных местах на экране, 
    и, обычно, окрашена в отличающийся от фона цвет,
    чтобы привлекать внимание.

    Позиционирование FAB также осуществляется с помощью
    атрибутов horizontal, vertical и slot.

    Пример кода:

      <ion-fab vertical="bottom" horizontal="end" slot="fixed">
        <ion-fab-button>
          <ion-icon name="add"></ion-icon>
        </ion-fab-button>
      </ion-fab>

  • Grid | CSS-сеточка для формирования макате приложения (клон Bootstrap'овской)

    Сеточка является отличным инструментом для формирования
    макета вашего приложения. Она очень похожа на оную в 
    Bootstrap, я думаю, клон, и авторы Ionic об этом
    явно говорят в документации.

    Используйте сеточку, чтобы ваше приложение выглядело
    прекрасно как на ultra wide экране настольного 
    компьютера, так и на мелком экране 4-го айфончика.

    Пример кода:

      <ion-grid>
        <ion-row>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
        </ion-row>

        <ion-row>
          <ion-col size="6">
            ion-col [size="6"]
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
          <ion-col>
            ion-col
          </ion-col>
        </ion-row>
      </ion-grid>

  • Infinite scroll | бесконечный скролл с триггерами от дистанции снизу/сверху документа

    Бесконечный скролл позволяет вам осуществлять некое 
    действие, когда пользователь доскроллит до определенного
    расстояния снизу или сверху документа. 

    Например, можно подгружать следующие элементы списка,
    если таковые имеются, если пользователь доскроллил
    до его низа.

    Этот компонент можно кастомизировать различными поддерживаемыми
    индикаторами загрузки.

    Пример кода:

      <ion-infinite-scroll>
        <ion-infinite-scroll-content
          loadingSpinner="bubbles"
          loadingText="Loading more data...">
        </ion-infinite-scroll-content>
      </ion-infinite-scroll>    

  • Input | обычный текстовый input         

    Инпуты позволяют пользователям вводить данные.
    Чаще всего их можно увидеть в формах и диалогах.

    Input ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-input required type="text" placeholder="First Name"></ion-input>
      </ion-item>

  • List | списочек, позволяет организовать разное в список

    Компонент списочек используется для отображение строк
    с информацией. Например, списка контактов, плейлист,
    или меню.

    В списке можно выводить карточки, элементы списка,
    и много чего ещё.

    Списки также хорошо поддаются кастомизации, и совпадают
    по дизайну с нативными на Android и iOS.

    Пример кода:

      <ion-list>
        <ion-item>
          <ion-avatar slot="start">
            <img src="assets/img/avatar-finn.png"></img>
          </ion-avatar>
          <ion-label>
            <h2>Finn</h2>
            <h3>I'm a big deal</h3>
            <p>Listen, I've had a pretty messed up day...</p>
          </ion-label>
        </ion-item>
      </ion-list>    

  • Loading | загрузочка, модальный экран загрузки со спинером

    Загрузочка является модальным экраном загрузки, который
    обычно используют, когда пользователю надо заблокировать 
    на время выполения каких-то действий возможность 
    взаимодействовать с интерфейсом.

  • Menu | менюшечка обычная, появляется слева по кнопке или свайпу

    Менюшечка является общим навигационным шаблоном для
    приложений. Она может быть 3-х видов:

    ▪ Постоянно на экране
    ▪ Выезжать свайпом через левый край экрана
    ▪ Вызываться кнопкой меню

    Пример кода:

      <ion-menu side="start">
        <ion-header translucent>
          <ion-toolbar color="secondary">
            <ion-title>Menu</ion-title>
          </ion-toolbar>
        </ion-header>
      </ion-menu>

  • Modal | модалочка полноэкранная, отображает временный UI

    Модалочка полноэкранная наезжает на экран, полностью его
    перекрывая (по сути, напоминает отдельный экран в SPA),
    и представляет собой временный UI.

    Модалочки полноэкранные часто используются для страниц
    логина или регистрации, составления сообщений, и выбора
    опций.

  • Nav | навигация между страницами приложения

    Навигация позволяет пользователям перемещаться между
    страницами вашего приложения.

    Концепция анимации и навигации в Ionic следуют 
    общепринятым стандартам. 

    Навигация в Ionic также может адаптироваться к большим
    viewports, используя ion-split-pane.

    Пример кода:

      <ion-app>
        <ion-nav root="page-one"></ion-nav>
      </ion-app>

  • Popover | тултипчик с расширенным функционалом

    Тултипчик представляет из себя окошечко, которое появляется
    поверх контента, и выглядящее, как тултип с расширенным
    функционалом.

    Чаще всего тултипчик используют в следующих ситуациях:

    ▪ Показать больше информации о текущем экране
    ▪ Выбрать часто используемый инструмент или настройку
    ▪ Показать список действий для текущего экрана

  • Range | слайдерок, для выбора значения из диапазона

    Слайдерок является элементом формы, который позволяет
    пользователям выбирать значение из диапазона путём
    перемещения ползунка.

    Range ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-range>
          <ion-icon slot="start" size="small" name="sunny"></ion-icon>
          <ion-icon slot="end" name="sunny"></ion-icon>
        </ion-range>
      </ion-item>

  • Refresher | обновлялочка, тянешь вниз и контент обновляется

    Обновлялочка представляет pull-to-request функциональность
    компонента content. 

    Чаще всего используется для обновления контента страницы.
    То есть, вам надо потянуть вниз, появится спиннер, 
    после чего контент на странице обновится.

    Пример кода:

      <ion-content fullscreen>
        <ion-refresher slot="fixed">
          <ion-refresher-content></ion-refresher-content>
        </ion-refresher>
      </ion-content>

  • Searchbar | искалочка, input для поиска/фильтрации

    Искалочка используется для поиска или фильтрации
    элементов. Обычно, она используется внутри
    ion-toolbar.

    Пример кода:

      <ion-toolbar>
        <ion-searchbar></ion-searchbar>
      </ion-toolbar>

  • Select | аналог обычного select с расширенным функционалом

    Компонент ion-select похож на обычный HTML'ый элемент 
    <select>, однако, позволяет проще сортировать и выбирать
    необходимую опцию. Его внешний вид совпадает с 
    select inputs на Android и iOS.

    Select ДОЛЖЕН ВСЕГДА быть использован внутри 
    ion-item.

    Пример кода:

      <ion-item>
        <ion-label>Hair Color</ion-label>
        <ion-select value="brown" ok-text="Okay" cancel-text="Dismiss">
          <ion-select-option value="brown">Brown</ion-select-option>
          <ion-select-option value="blonde">Blonde</ion-select-option>
          <ion-select-option value="black">Black</ion-select-option>
          <ion-select-option value="red">Red</ion-select-option>
        </ion-select>
      </ion-item>

  • Slides | слайдер страниц, с пролистыванием свайпами

    Слайдер позволяет легко делать функционал, основанный
    на слайдах, такой как галереи, туториалы. А также
    приложения, в которых есть возможно пролистывать
    страницы вправо-влево (например, калькулятор калогий
    ХиКи).

    Пример кода:

      <ion-slides pager="true">
        <ion-slide>
          <h1>Slide 1</h1>
        </ion-slide>

        <ion-slide>
          <h1>Slide 2</h1>
        </ion-slide>

        <ion-slide>
          <h1>Slide 3</h1>
        </ion-slide>
      </ion-slides>

  • Spinner | набор анимированных SVG-спинеров

    Компонент ion-spinner представляет собой набор
    анимированных SVG-спинеров. 

    Вы можете применять спинер, чтобы дать пользователям
    понять, что происходит какая-то активность.

    Пример кода:

      <ion-spinner></ion-spinner>
      <ion-spinner name="lines"></ion-spinner>

  • Tabs | навигационные табы

    Этот компонент включает навигационные табы, которые
    являются стандартным навигационным шаблоном в 
    современных приложениях.

    Табы могут отображать иконку и/или надпись, чтобы 
    давать понять пользователю, куда он попадёт, если
    нажмёт.

    По умолчанию, навигационны табы расположены в нижней
    части приложения, что соответствует руководствам
    Material Design и iOS Design. Однако, если надо,
    их можно поместить и сверху.

    Пример кода:

      <ion-tabs>
        <ion-tab label="Music" icon="musical-note"></ion-tab>
        <ion-tab label="Profile" icon="person"></ion-tab>
        <ion-tab label="people" icon="people"></ion-tab>
      </ion-tabs>

  • Toast | тосты обыкновенные, быстро появляются и исчезают

    Компонент тосты позволяет уведомить пользователя 
    коротким сообщением. Они быстро появляются и исчезают.

    Тосты могут появлятсья сверху, снизу, посередине, 
    иметь кнопку закрытия тоста.

    На планшетах или больших экранах настольных компьютеров
    или ноутбуков, ширина тостов не будет 100%, и они будут
    появляться по центру.

  • Virtual Scroll | производительный скроллинг больших списков

    Элемент виртуальный скролл является виртуальным списком,
    который позволяет вам обеспечить высокую производительность
    при скролле через ГИГАНТСКИЕ списки.

    Суть его состоит в том, что он отрисовывает лишь те 
    элементы, которые в текущий момент видимы на экране.

    Вообще, это известная техника для повышения производительности
    работы с большими списками на слабомощных мобильных устройствах.


А6. Организация layout'а в Ionic-приложении
--------------------------------------

  # Примеры layout'ов

    ▪ header, content and footer
      ▪ header + content
      ▪ footer + content
      ▪ header + footer + content

    ▪ header, content, tabs
    ▪ header, content, menu
    ▪ Split pane layouts (разные layout'ы в зависимости от ширины экрана)

  # Отзывчивая сеточка (responsive grid)

    ▪ Введение про сеточку в Ionic
    ▪ Как работает сеточка в Ionic
    ▪ Размеры сеточки, брейкпоинты: xs, sm, md, lg, xl
    ▪ Атрибуты сеточки
      
      ▪ no-padding    | убрать padding ячеек
      ▪ fixed         | настроить max ширину сетки

    ▪ CRUD-настройка брейкпоинтов
    ▪ Управление шириной колонок
      ▪ По умолчанию, ширина всех колонок в row одинакова
      ▪ Изменить ширину одной колонки в row
      ▪ Основанная на контенте ширины для колонки в row

    ▪ Управление адаптивностью
      ▪ Атрибут size для изменения ширины колонки для всех устройств
      ▪ Комбинация size и size-<bp> для перехода от стека к горизонтальным колонкам в зависимости от ширины экрана

    ▪ Управление взаимным порядком колонок
      ▪ Управление отступами (offset)
        ▪ Отступы без брейкпоинтов
        ▪ Отступы с брейкпоинтами      
      ▪ Управление взаимным порядком (push, pull)
        ▪ Взаимный порядок без брейкпоинтов
        ▪ Взаимный порядок с брейкпоинтами    

    ▪ Выравнивание колонок
      ▪ Вертикальное выравнивание колонок
        ▪ Относительное выравниваниевсех cols в row
        ▪ Персональное выравнивание отдельных col в row
      ▪ Горизонтальное выравнивание колонок

    ▪ Кастомизация сеточки

      ▪ --ion-grid-columns            | [12] изменение кол-ва колонок
      
      ▪ --ion-grid-padding            | [5px] изменение padding контейнера сетки
      ▪ --ion-grid-padding-xs         | [5px] изменение padding контейнера сетки для xs
      ▪ --ion-grid-padding-sm         | [5px] изменение padding контейнера сетки для sm
      ▪ --ion-grid-padding-md         | [5px] изменение padding контейнера сетки для md
      ▪ --ion-grid-padding-lg         | [5px] изменение padding контейнера сетки для lg
      ▪ --ion-grid-padding-xl         | [5px] изменение padding контейнера сетки для xl

      ▪ --ion-grid-width-xs           | [100%]   изменение ширины сетки для xs
      ▪ --ion-grid-width-sm           | [540px]  изменение ширины сетки для sm
      ▪ --ion-grid-width-md           | [720px]  изменение ширины сетки для md
      ▪ --ion-grid-width-lg           | [960px]  изменение ширины сетки для lg
      ▪ --ion-grid-width-xl           | [1140px] изменение ширины сетки для xl

      ▪ --ion-grid-column-padding:    | [5px] изменение padding колонки
      ▪ --ion-grid-column-padding-xs  | [5px] изменение padding колонки для xs
      ▪ --ion-grid-column-padding-sm  | [5px] изменение padding колонки для sm   
      ▪ --ion-grid-column-padding-md  | [5px] изменение padding колонки для md  
      ▪ --ion-grid-column-padding-lg  | [5px] изменение padding колонки для lg  
      ▪ --ion-grid-column-padding-xl  | [5px] изменение padding колонки для xl  

  # CSS-инструменты для управления сеткой

    См. https://beta.ionicframework.com/docs/layout/css-utilities

--------------------------------------

> Примеры layout'ов

  • Header, Content and Footer

    ▪ header + content

      Самый простой возможный layout состоит из header и 
      content. Большинство страниц в приложении обычно
      имеют и то, и другое. Но заголовок не требуется
      для использования контента.

      Пример кода:

        <ion-app>
          <ion-header>
            <ion-toolbar>
              <ion-title>Header</ion-title>
            </ion-toolbar>
          </ion-header>

          <ion-content padding>
            <h1>Main Content</h1>
          </ion-content>
        </ion-app>      

    ▪ footer + content

      Как в можете увидеть выше, toolbar в header появляется
      на экране над контентом. Но иногда приложению требуется
      тулбар под контентом, для этого и используют footer.

      Пример кода:

        <ion-app>
          <ion-content padding>
            <h1>Main Content</h1>
          </ion-content>

          <ion-footer>
            <ion-toolbar>
              <ion-title>Footer</ion-title>
            </ion-toolbar>
          </ion-footer>
        </ion-content>

    ▪ header + footer + content

      Никто не мешает комбинировать header и footer
      вместе, получая toolbar'ы как над, так и под
      контентом.

      Пример кода:

        <ion-app>
          <ion-header>
            <ion-toolbar>
              <ion-title>Header</ion-title>
            </ion-toolbar>
          </ion-header>

          <ion-content padding>
            <h1>Main Content</h1>
          </ion-content>

          <ion-footer>
            <ion-toolbar>
              <ion-title>Footer</ion-title>
            </ion-toolbar>
          </ion-footer>
        </ion-content>

  • header, content, tabs

    Этот layout состоит из заголовка, контента и табов
    снизу. Каждый таб может содержать статический контент,
    или навигационный стек, используя router-outlet или
    ion-nav.

    Пример кода:

      <ion-app>
        <ion-tabs>
          <ion-tab label="Home" icon="home">
            <ion-header>
              <ion-toolbar>
                <ion-title>Home</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Home Content</h1>
            </ion-content>
          </ion-tab>

          <ion-tab label="Map" icon="map">
            <ion-header>
              <ion-toolbar>
                <ion-title>Map</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Map Content</h1>
            </ion-content>
          </ion-tab>

          <ion-tab label="Camera" icon="camera">
            <ion-header>
              <ion-toolbar>
                <ion-title>Camera</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Camera Content</h1>
            </ion-content>
          </ion-tab>
        </ion-tabs>
      </ion-app>    

  • header, content, menu

    Это стандартный layout в мобильных приложениях, в нём
    есть возможность открытия/закрытия меню нажатием на 
    кнопку, или свайпом через левый край экрана.

    Чаще всего боковые меню используются для навигации,
    но могут содержать и какой-то контент.

    Пример кода:

      <ion-app>
        <ion-menu>
          <ion-header>
            <ion-toolbar color="primary">
              <ion-title>Menu</ion-title>
            </ion-toolbar>
          </ion-header>

          <ion-content>
            <ion-list>
              <ion-list-header>
                Navigate
              </ion-list-header>
              <ion-menu-toggle auto-hide="false">
                <ion-item button>
                  <ion-icon slot="start" name='home'></ion-icon>
                  <ion-label>
                    Home
                  </ion-label>
                </ion-item>
              </ion-menu-toggle>
            </ion-list>
          </ion-content>
        </ion-menu>

        <ion-page class="ion-page" main>
          <ion-header>
            <ion-toolbar>
              <ion-buttons slot="start">
                <ion-menu-toggle>
                  <ion-button>
                    <ion-icon slot="icon-only" name="menu"></ion-icon>
                  </ion-button>
                </ion-menu-toggle>
              </ion-buttons>
              <ion-title>Header</ion-title>
            </ion-toolbar>
          </ion-header>
          <ion-content padding>
            <h1>Main Content</h1>
            <p>Click the icon in the top left to toggle the menu.</p>
          </ion-content>
        </ion-page>
      </ion-app>

      <ion-menu-controller></ion-menu-controller>

  • Split pane layouts (разные layout'ы в зависимости от ширины экрана)

    Split pane layouts имеют более сложную структуру, потому
    что они могут комбинировать все предыдущие layouts.

    По сути, они работают, как адаптивный дизайн. Если ширина
    больше определённого значения, то показывается дополнительный
    элемент (например, постоянное мнею слева). А если меньше,
    то не показывается.

    По умолчанию, триггерная точка установлена на 768px
    (md breakpoint), но это можно настраивать через св-во 
    when.

    Ниже можно увидеть код примера, в котором меню видимо
    для sm-экранов (576px) и больше.

    Важно отметить, что элемент с атрибутом main будет 
    считаться главным контентом, который всегда видим. 
    Это может быть любой элемент, включая ion-nav, 
    ion-router-outlet, или ion-tabs.

    Пример кода:

      <ion-app>
        <ion-split-pane when="sm">
          <ion-menu>
            <ion-header>
              <ion-toolbar color="primary">
                <ion-title>Menu</ion-title>
              </ion-toolbar>
            </ion-header>

            <ion-content>
              <ion-list>
                <ion-list-header>
                  Navigate
                </ion-list-header>
                <ion-menu-toggle auto-hide="false">
                  <ion-item button>
                    <ion-icon slot="start" name='home'></ion-icon>
                    <ion-label>
                      Home
                    </ion-label>
                  </ion-item>
                </ion-menu-toggle>
              </ion-list>
            </ion-content>
          </ion-menu>

          <ion-page class="ion-page" main>
            <ion-header>
              <ion-toolbar>
                <ion-buttons slot="start">
                  <ion-menu-toggle>
                    <ion-button>
                      <ion-icon slot="icon-only" name="menu"></ion-icon>
                    </ion-button>
                  </ion-menu-toggle>
                </ion-buttons>
                <ion-title>Header</ion-title>
              </ion-toolbar>
            </ion-header>
            <ion-content padding>
              <h1>Main Content</h1>
            </ion-content>
          </ion-page>

        </ion-split-pane>
      </ion-app>

> Отзывчивая сеточка (responsive grid)

  • Введение про сеточку в Ionic

    Сеточка является мощной flexbox-системой, ориентированной
    на мобильные устройства. Она позволяет организовывать
    кастомные layout'ы.

    Основными элементами сеточки являются эти трое:

    ▪ ion-grid    | сеточка
    ▪ ion-row     | строка
    ▪ ion-col     | колонка

    Колонки занимают всю строку по ширине. В одной строке
    может быть до 12 колонок. В рамках стратегии адаптивного
    дизайна, на определённых контрольных точках, зависимых
    от ширины окна браузера, кол-во колонок может становиться
    меньше или больше. Кол-во колонок можно настраивать через
    CSS.

  • Как работает сеточка в Ionic

    ▪ Пример сеточки (без атрибутов)

      <ion-grid>
        <ion-row>
          <ion-col>
            <div>
              1 of 3
            </div>
          </ion-col>
          <ion-col>
            <div>
              2 of 3
            </div>
          </ion-col>
          <ion-col>
            <div>
              3 of 3
            </div>
          </ion-col>
        </ion-row>
      </ion-grid>    

    ▪ Grid работает, как контейнер для rows и cols.
      Grid по умолчанию занимает полную ширину их 
      контейнера, но добавление атрибута fixed позволяет
      задать свою ширину для каждого из доступных размеров
      экрана (подробнее ниже).

    ▪ Rows - горизонтальные группа элементов col. 

    ▪ Контент надо класть в cols. Только cols можгут
      быть непосредственными детьми элементов rows.

    ▪ Атрибут "size-<breakpoint>" у col обозначает, сколько
      колонок заёмет данный col, учитывая, что в row 
      всего 12 колонок.

      Например, если назначить какому-то col атрибут 
      size="4", то он займёт 4 из 12 колонок, то есть,
      1/3 от ширины сетки.

    ▪ Cols без явно заданного значения для size автоматически
      получают равную ширину. Например, если в row есть 4 
      cols, то каждая col получит 25% ширины.

    ▪ Ширина cols всегда задаётся в %, поэтому они всегда
      тянутся и подстраиваются под ширину родительского
      элемента.

    ▪ У cols есть padding между ними. Но его можно удалить,
      добавив атрибут no-padding в элемент grid.

    ▪ У сетки есть 5 брейкпоинтов для различных ширин экрана:
      xs, sm, md, lg, lx. Подробнее о них ниже.

    ▪ Брейкпоинт сетки применяется к любой ширине, которая
      >= его собственной. Например, size-sm применяется
      к sm, md, lg, lx (если для md, lg, lx не указано
      иное, конечно).

    ▪ Сетку можно легко кастомизировать с помощью 
      CSS-переменных (см.ниже).

  • Размеры сеточки, брейкпоинты: xs, sm, md, lg, xl

    По умолчанию, сеточка занимает 100% ширины. Чтобы установить
    основанную на размере экрана ширину сеточки, используйте
    атрибут fixed. Ширина сеточки для каждого брейкпоинта 
    определён в CSS-переменныэ "--ion-grid-width-<breakpoint>".
    Подробнее об этом ниже.

    xs    100%      Не ставьте ширину сетки для xs экранов.
    sm    540px     Ставьте ширину сетки 540px, когда min-width: 576px
    md    720px     Ставьте ширину сетки 720px, когда min-width: 768px
    lg    960px     Ставьте ширину сетки 960px, когда min-width: 992px
    xl    1140px    Ставьте ширину сетки 1140px, когда min-width: 1200px

  • Атрибуты сеточки

    По умолчанию, сеточка занимает 100% ширины экрана, а 
    её ячейки имеют padding. С помощью нижеописанных атрибутов
    это можно менять.

    ▪ no-padding | убрать padding ячеек

      Удаляет padding из сеточки, чтобы между ячейками
      его не было.

    ▪ fixed | настроить max ширину сетки

      Позволяет настроить max ширину сетки на основе
      ширины экрана, используя xs, sm, md, lg, xl.

  • CRUD-настройка брейкпоинтов

    Брейкпоинты по умолчанию определены в CSS-переменных
    --ion-grid-breakpoints. Всё это можно легко 
    кастомизировать, задать другие значения для
    брейкпоинтов, переименовывать их, добавлять/удалять
    брейкпоинтов. Подробнее см.ниже.

                    Prefixes
                    ----------------------------------------
    Name    Value   With      Offset      Push      Pull
    --------------------------------------------------------
    xs      0       size-     offset-     push-     pull
    sm      576px   size-sm-  offset-sm-  push-sm-  pull-sm-
    md      768px   size-md-  offset-md-  push-md-  pull-md-
    lg      992px   size-lg-  offset-lg-  push-lg-  pull-lg-
    xl      1200px  size-xl-  offset-xl-  push-xl-  pull-xl-

  • Управление шириной колонок

    ▪ По умолчанию, ширина всех колонок в row одинакова

      По умолчанию, колонки в row занимают равную ширину
      для всех устройств и размеров экрана.

      |--|--|--|--|--|--|--|--|--|--|--|--|
      |-----|-----|-----|-----|-----|-----|

      Пример и код:

        |--1 из 3 --|--2 из 3 --|--3 из 3 --|
        |---- 1 из 2  ----|--- -2 из 2  ----|

        <ion-grid>
          <ion-row>
            <ion-col>
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col>
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Изменить ширину одной колонки в row

      Если установить вручную ширину для одной конкретной
      колонки, прочие колонки автоматически подстроятся,
      но их ширины останутся равными.

      Пример и код:

        |-1 из 3-|-----2 из 3-----|--3 из 3-|
        |-1 из 3---|---2 из 3---|----3 из 3-|

        <ion-grid>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size="8">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size="6">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Основанная на контенте ширины для колонки в row

      Если установить значение size-<breakpoint> в auto,
      ширина колонки будет подстраиваться под контент
      в ней. Такую колонку называют колонокой переменной
      ширины.

      Колонка, следующая сразу за колонкой переменной
      ширины, будет автоматически изменять свою ширину,
      чтобы подстроиться под последнюю.

      Пример и код:

        |--1 из 3 --|--content--|--3 из 3 --|
        |--1 из 3 --|--content 123--|-3 из 3|

        <ion-grid>
          <ion-row>
            <ion-col>
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size="auto">
              <div>
                Variable width content
              </div>
            </ion-col>
            <ion-col>
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
          <ion-row>
            <ion-col>
              <div>
                1 of 4
              </div>
            </ion-col>
            <ion-col>
              <div>
                2 of 4
              </div>
            </ion-col>
            <ion-col size="auto">
              <div>
                <ion-input placeholder="Variable width input"></ion-input>
              </div>
            </ion-col>
            <ion-col>
              <div>
                4 of 4
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

  • Управление адаптивностью

    ▪ Атрибут size для изменения ширины колонки для всех устройств

      Чтобы изменять ширину отдельных колонок, используйте
      атрибут size. Его значение может быть от 1 до 12. 
      Оно определяет, сколько колонок (из 12) данная
      колонка будет занимать.

      Пример и код:

        |---1/4----|-2/4--|--3/4-|----4/4---|

        <ion-grid>
          <ion-row>
            <ion-col size="4">
              <div>
                1 of 4
              </div>
            </ion-col>
            <ion-col size="2">
              <div>
                2 of 4
              </div>
            </ion-col>
            <ion-col size="2">
              <div>
                3 of 4
              </div>
            </ion-col>
            <ion-col size="4">
              <div>
                4 of 4
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Комбинация size и size-<bp> для перехода от стека к горизонтальным колонкам в зависимости от ширины экрана

      Используя комбинацию атрибутов size и size-<breakpoint>,
      можно организовать адаптивный эффект перехода от
      расположения колонок в виде вертикального стека
      (актуально для небольших экранов), к обачному горизонтальному
      расположению колонок в ряду, при расширении экрана.

      Пример вертикального стека (для узких экранов):

        |----1/3----|
        |----2/3----|
        |----3/3----|

      Пример горизонтального расположения тех же колонок 
      (для более широких экранов):

        |----1/3----|----2/3----|----3/3----|

      Пример кода:

      <ion-grid>
        <ion-row>
          <ion-col size="12" size-sm>
            <div>
              1 of 4
            </div>
          </ion-col>
          <ion-col size="12" size-sm>
            <div>
              2 of 4
            </div>
          </ion-col>
          <ion-col size="12" size-sm>
            <div>
              3 of 4
            </div>
          </ion-col>
          <ion-col size="12" size-sm>
            <div>
              4 of 4
            </div>
          </ion-col>
        </ion-row>
      </ion-grid>      

  • Управление взаимным порядком колонок

    ▪ Управление отступами (offset)

      С помощью атрибута offset можно управлять отступами
      колонок. Этот атрибут увеличивает margin left
      указанной колонки на указанное кол-во колонок
      n/12.

      ▪ Отступы без брейкпоинтов

        Например, в следующей сетке последняя колонка получила
        offset=3, в результате чего, находится от первой 
        колонки на расстоянии 3-х колонок.

                  offset3
        |--1/2---|        |--2/2---|

        <ion-grid>
          <ion-row>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3" offset="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

      ▪ Отступы с брейкпоинтами

        Также для offset, как и для size, можно использовать
        брейкпоинты, чтобы в зависимости от ширины экрана
        манипулировать отступами:

        <ion-grid>
          <ion-row>
            <ion-col size-md="3">
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size-md="3">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col size-md="3" offset-md="3">
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

    ▪ Управление взаимным порядком (push, pull)

      С помощью атрибутов push и pull можно управлять
      взаимным порядком колонок. Эти атрибуты смещают
      колонки вправо или влево на указанное число
      колонок n/12. 

      ▪ Взаимный порядок без брейкпоинтов

        В этом примере мы меняем местами колонки
        "1 of 2" и "2 of 2".

        <ion-grid>
          <ion-row>
            <ion-col size="9" push="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3" pull="9">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

      ▪ Взаимный порядок с брейкпоинтами

        <ion-grid>
          <ion-row>
            <ion-col size-md="6" push-md="3">
              <div>
                1 of 3
              </div>
            </ion-col>
            <ion-col size-md="3" push-md="3">
              <div>
                2 of 3
              </div>
            </ion-col>
            <ion-col size-md="3" pull-md="9">
              <div>
                3 of 3
              </div>
            </ion-col>
          </ion-row>
        </ion-grid>

  • Выравнивание колонок

    ▪ Вертикальное выравнивание колонок

      ▪ Относительное выравниваниевсех cols в row

        Все cols в row можно выровнять по 
        верхнему/нижнему краю, или по центру. Для этого
        на весь row применяют атрибуты:

        ▪ align-items-start
        ▪ align-items-center
        ▪ align-items-end

          Подробнее: 
          https://beta.ionicframework.com/docs/layout/grid/#customizing-the-grid

        Пример:justify-content-start

          <ion-grid>
            <ion-row align-items-start>
              <ion-col>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>

            <ion-row align-items-center>
              <ion-col>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>

            <ion-row align-items-end>
              <ion-col>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>
          </ion-grid>

      ▪ Персональное выравнивание отдельных col в row

        Аналогично, каждый col можно выравнивать по 
        верхнему/нижнему краю, или по центру. Для этого
        на каждом col используются атрибуты:

        ▪ align-self-start 
        ▪ align-self-center
        ▪ align-self-end

          Подробнее: 
          https://beta.ionicframework.com/docs/layout/grid/#customizing-the-grid

        Пример:

          <ion-grid>
            <ion-row>
              <ion-col align-self-start>
                <div>
                  1 of 4
                </div>
              </ion-col>
              <ion-col align-self-center>
                <div>
                  2 of 4
                </div>
              </ion-col>
              <ion-col align-self-end>
                <div>
                  3 of 4
                </div>
              </ion-col>
              <ion-col>
                <div>
                  4 of 4 <br>
                  # <br>
                  # <br>
                  #
                </div>
              </ion-col>
            </ion-row>
          </ion-grid>

    ▪ Горизонтальное выравнивание колонок

      Все cols могут горизонтально выравниваться внутри
      row, для этого можно на него применять атрибуты:

      ▪ justify-content-start
      ▪ justify-content-center
      ▪ justify-content-end
      ▪ justify-content-around
      ▪ justify-content-between

        Подробнее: 
        https://beta.ionicframework.com/docs/layout/grid/#customizing-the-grid

      Пример:

        <ion-grid>
          <ion-row justify-content-start>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-center>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-end>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-around>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>

          <ion-row justify-content-between>
            <ion-col size="3">
              <div>
                1 of 2
              </div>
            </ion-col>
            <ion-col size="3">
              <div>
                2 of 2
              </div>
            </ion-col>
          </ion-row>
        </ion-grid> 

  • Кастомизация сеточки

    С помощью CSS-переменных можно производить кастомизацию
    сеточки. В оглавлении этого пункта перечислены 
    соответствующие переменные.


А7. Тематизация
--------------------------------------
  
  # Ссылки
  # Основы тематизации в Ionic

    ▪ Цвета
    ▪ Стандарты платформы
    ▪ CSS-переменные
    ▪ Брэндинг

  # Стили платформ

    ▪ Режимы Ionic'а (modes)
    ▪ Перезапись платформо-зависимых стилей компонентов

  # CSS-переменные для кастомизации Ionic-компонентов

    ▪ Установка значений для CSS-переменных
      ▪ Глобальные переменные
      ▪ Переменные селекторов
      ▪ Установка значений через JavaScript

    ▪ Извлечение значений CSS-переменных
      ▪ Используя CSS: css-функция var()
      ▪ Используя JavaScript: функция getPropertyValue()

  # Полезный инструмент: генератор цвета
  # Продвинутая тематизация

    ▪ Язык цвета

      ▪ Многослойные цвета
      ▪ Цвета приложения
      ▪ Ступенчатые цвета
      ▪ Цветовая карта
      ▪ Многослойные цвета в цветовой карте
      ▪ Alpha-проблема

    ▪ Применение стилей
  
--------------------------------------

> Ссылки

  • Генератор цвета
      https://beta.ionicframework.com/docs/theming/color-generator

  • Ionic CSS variables
      https://beta.ionicframework.com/docs/theming/css-variables/

  • Конфиг приложения, где можно выбрать режимы для платформ
      https://beta.ionicframework.com/api/config/Config

> Основы тематизации в Ionic

  Ionic Framework построен таким образом, чтобы быть
  чистым листом, который можно легко кастомизировать
  и модифицировать под свой бренд, при этом, оставаясь
  верным стандартам на разных платформах.

  Тематизация Ionic-приложений теперь легче лёгкого.
  Ведь сам фреймворк построен на CSS, имеет
  CSS-переменные, и идёт с предваретльно обработанными
  стилями по умолчанию, которые очень легко менять.

  • Цвета

    У Ionic'а есть 9 разных цветов, которые можно использовать,
    чтобы изменить цветовую схему многих компонентов.

    По факту, каждый цвет является коллекцией многих свойств,
    включая shade и tint, используемых по всему Ionic'у.

    При изменении цвета, важно установить все связанные с
    этим свойства. Это легко можно делать с помощью 
    инструмента "генератор цвета" (см.выше в ссылках).
    Ну, или можно вручную всё прописать, но это сложнее.

    Вот именя 9 цветов, которые используются в Ionic:

    ▪ Primary
    ▪ Secondary
    ▪ Tertiary
    ▪ Success
    ▪ Warning
    ▪ Danger
    ▪ Dark
    ▪ Medium
    ▪ Light

  • Стандарты платформы

    Ionic-компоненты адаптируют свои внешний вид и поведение
    в зависимости от платформы, на которой запущено приложение.

    Разработчики Ionic называют это свойство "Platform Continuity",
    или "Непрерывность Платформы".

    Это позволяет разработчикам создавать приложения, которые
    используют один и тот же код на разных платформах, но которые
    все ещё выглядят нативно на каждой из платформ.

    У Ionic'а есть 2 РЕЖИМА, которые используются для кастомизации
    внешнего вида компонентов, в зависимости от платформы:

    ▪ ios     | apple'овский стиль
    ▪ md      | material design

    Для каждой платформы назначен режим по умолчанию. 
    Для Apple'овских платформ ios, для остальных md.
    Однако, это легко можно менять в проекте.
    Подробнее об этом ниже, в главе "Стили платформ".

  • CSS-переменные

    Стили всех Ionic-компоненты используют CSS-переменные.
    Они добавляют динамичности изначально статичному CSS.
    Чтобы оно работало, нужен CSS-препроцессор SASS.

    Внешний вид приложения можно легко менять, меняя
    значения соответствующих CSS-переменных.

  • Брэндинг

    Если у вашего бренда есть какая-то особая цветовая 
    схема, то с помощью настройки 9 переменных цветов
    Ionic (описанных выше), вы можете полностью 
    кастомизировать цветовую схему приложения.

    Подробнее об этом смотрите ниже, в пункте
    "Продвинутая тематизация"

> Стили платформ

  Ionic-компоненты адаптируют свои внешний вид и поведение
  в зависимости от платформы, на которой запущено приложение.  

  Это позволяет один раз написать приложение, которое 
  на каждой платформе выглядит и ощущается нативным.

  ▪ Режимы Ionic'а (modes)

    Ionic использует режимы (modes) для кастомизации внешнего
    вида компонентов. Для каждой платформы назначен режим
    по умолчанию, но это можно изменить для проекта. Ниже
    показано, для какой платформы какой режим по умолчанию
    стоит:

      Платформа   Режим   Описание
      ----------------------------
      ios         ios     ios-стили для iphone, ipad, ipod
      android     md      material design для android-устройств 
      core        md      material design для не-ios-android платформ

    Например, при запуске приложения на android оно получит
    режим md по умолчанию. Элемент <ion-app> будет иметь
    class="md" и все компоненты будут использовать Material
    Design:

      <ion-app class="md">

  ▪ Перезапись платформо-зависимых стилей компонентов

    Каждый Ionic-компонент имеет до 3-х файлов* со стилями.
    Вот пример файлов стилей для компонента "badge":

      badge
      ├── badge.ios.scss                  # ios mode styles
      ├── badge.ios.vars.scss             # ios mode variables
      ├── badge.md.scss                   # md mode styles
      ├── badge.md.vars.scss              # md mode variables
      ├── badge.scss                      # shared styles for the badge
      └── badge.vars.scss                 # shared variables for the badge

      *Примечание:

        Не все компоненты имеют разные стили для разных
        режимов. Как следствие, не все компоненты имеют
        именно показанный выше набор стилевых файлов,
        какие-то из них могут отсутствовать.

    Модифицировать стили любого компонента можно путём 
    добавление соответствующего класса в элемент ion-app.

    Например, хотим мы, чтобы во всех компонентах badge
    на платформе ios текст был написан большими буквами.
    Для этого создать такой класс:

      .ios .badge {
        text-transform: capitalize;
      }

    Режим также скомбинирован с именем компонента, и затем
    добавлен в качестве класса в каждый компонент. Написанное
    выше может быть упрощено, и применено только к ios-bagdes:

      .badge-ios {
        text-transform: capitalize;
      }

    Есть также много CSS-переменных, которые можно использовать
    для перезаписывания стилей. Используя тот же пример выше,
    мы можем изменить ios-badges, используя CSS-переменную
    --badge-ios-text-transform

      :root {
        --badge-ios-text-transform: capitalize;
      }

    Список всех CSS-переменных Ionic доступен по ссылке
    выше, в ссылках.

> CSS-переменные для кастомизации Ionic-компонентов

  Ionic-компоненты построены с использованием CSS-переменных,
  чтобы можно было легко кастомизировать стили приложения.

  CSS-переменные позволяют хранить значение в одном месте,
  а затем использовать его во многих других местах. 

  Также, они позволяют изменять CSS динамически, прямо во
  время выполнения приложения, что ранее требовало наличия
  препроцессора.

  С помощью CSS-переменных легче лёгкого изменять стили
  Ionic-компонентов под свои брендовые нужды.

  ▪ Установка значений для CSS-переменных

    ▪ Глобальные переменные

      Значения для CSS-переменных можно установить глобально 
      в приложении в селекторе :root

        :root {
          --ion-color-primary: #00ff00;
        }

    ▪ Переменные селекторов

      Чтобы установить значение для CSS-переменной для 
      определённого компонента, добавьте его в этот
      селектор:

        .my-fancy-button {
          --ion-color-primary: #00ff00;
        }

    ▪ Установка значений через JavaScript

      Значения CSS-переменных можно также изменять
      с помощью JavaScript, используя setProperty()

        const el = document.querySelector('.my-fancy-button');
        el.style.setProperty('--ion-color-primary', '#ff0000');

  ▪ Извлечение значений CSS-переменных

    ▪ Используя CSS: css-функция var()

      CSS-функция var() позволяет извлечь значение CSS-переменной,
      указывая сколько угодно fallback-значений (на случай, если 
      значение CSS-переменной будет отсутствовать).

      В примере выше, значением для background-color будет установлено
      значение переменной --ion-color-primary, либо #00ff00,
      в случае, если не удастся его извлечь:

        .my-fancy-button {
          background-color: var(--ion-color-primary, #00ff00);
        }

    ▪ Используя JavaScript: функция getPropertyValue()

      Значение CSS-переменной можно изслечь в JavaScript
      с помощью функции getPropertyValue():

        const el = document.querySelector('.my-fancy-button');
        const color = el.style.getPropertyValue('--ion-color-primary');

> Полезный инструмент: генератор цвета

  На сайте Ionic есть очень полезные инструмент, который
  называется "Генератор цвета". Он позволяет визуально 
  создавать цветовые палитры для UI вашего приложения,
  и генерирует набор CSS-переменных для результатов. 
  Этот код можно скопировать к себе в приложение, и 
  изменить таким образом его цветовую схему.

  См.ссылку на генератор цвета выше, в ссылках.

> Продвинутая тематизация

  Основанная на CSS тематизация позволяет быстро кастомизировать
  цвета, загрузив CSS-файл, или изменив несколько CSS-свойств.

  • Язык цвета

    В Ionic цвета можно разбить на 2 группы:

    ▪ Цвета приложения  | --ion-color-primary
    ▪ Цветовая карта    | --ion-color-secondary

    Цветовая карта - абстрактная коллекция цветов, которая
    может быть использована во всём приложении. 

    ▪ Многослойные цвета

      ▪ contrast  | видимый относительно базового цвета
      ▪ shade     | немного более тёмный цвет относительно базового
      ▪ tint      | немного более светлый цвет относительно базового
      ▪ RGB       | RGB-версия основного цвета, позволяет применить opacity

      Например, secondary-цвет использует следующие
      CSS-свойства:

        --ion-color-secondary: #0cd1e8;
        --ion-color-secondary-rgb: 12,209,232;
        --ion-color-secondary-contrast: #000000;
        --ion-color-secondary-contrast-rgb: 0,0,0;
        --ion-color-secondary-shade: #0bb8cc;
        --ion-color-secondary-tint: #0bb8cc;

      Когда secondary применяется к кнопке, используется
      не только базовый цвет, но и contrast для текста,
      shade и tint для разных состояний кнопки.

    ▪ Цвета приложения

      Имена цветов приложения обычно соответствуют сфере их
      применения в компоненте. Ниже представлен список
      top-level цветов приложения:

        --ion-backdrop-color
        --ion-overlay-background-color
        --ion-background-color
        --ion-border-color
        --ion-box-shadow-color
        --ion-text-color
        --ion-tabbar-background-color
        --ion-tabbar-border-color
        --ion-tabbar-text-color
        --ion-tabbar-text-color-active
        --ion-toolbar-background-color
        --ion-toolbar-border-color
        --ion-toolbar-color-active
        --ion-toolbar-color-inactive
        --ion-toolbar-text-color
        --ion-item-background-color
        --ion-item-background-color-active
        --ion-item-border-color
        --ion-item-text-color
        --ion-placeholder-text-color

    ▪ Ступенчатые цвета

      Исследовав множество приложений и тем для них, 
      мы (команда Ionic) обнаружили, что в большинстве
      дизайнов фон никогда не является одним цветом.
      Всегда имеются тонкие вариации, используемые для
      обозначения важности и глубины во всём дизайне.
      Чтобы применить это в Ionic, мы создали ступенчатые
      цвета.

      Есть только 2 цвета, которые используются во всех
      Ionic-компонентах:

      ▪ --ion-text-color
      ▪ --ion-background-color

      Ступенчатые цвета позволяют лучше контролировать
      то, как выглядит ваше приложение.

      Цветовой шаг - тонкая вариация цвета на пути к 
      другому цвету.

      Например, цветовые шаги для --ion-text-color сдвигают
      его по направлению к --ion-background-color.

      Ступенчатые цвета также требуют наличие RGB-списка
      для контроля над alpha. См. "Alpha-проблема" ниже.

      Простой пример для иллюстрации концепции, 
      всего с 4-мя цветовыми шагами:

        --ion-text-color: #000000;
        --ion-background-color: #ffffff;
        --ion-background-color-step-250: #bfbfbf;
        --ion-background-color-step-500: #808080;
        --ion-background-color-step-750: #404040;
        --ion-background-color-step-1000: #000000;
        --ion-text-color-step-250: #404040;
        --ion-text-color-step-500: #808080;
        --ion-text-color-step-750: #bfbfbf;
        --ion-text-color-step-1000: #ffffff;

      В этом примере вы можете видеть, как цветовые 
      шаги для --ion-background-color смещают цвет
      из белого в чёрный. И как оные для --ion-text-color
      смещают цвет из чёрного в белый.

      Ionic используют номера цветовых шагов, как проценты
      для генерации этих цветов. Например, --ion-text-color-step-250,
      это --ion-text-color, смешанный с 25% цвета --ion-background-color.

      Ionic генерирует 20 шагов для каждого цвета, получая
      в результате следующий CSS:

        --ion-background-color: #ffffff;
        --ion-background-color-step-50: #f2f2f2;
        --ion-background-color-step-100: #e6e6e6;
        --ion-background-color-step-150: #d9d9d9;
        --ion-background-color-step-200: #cccccc;
        --ion-background-color-step-250: #bfbfbf;
        --ion-background-color-step-300: #b3b3b3;
        --ion-background-color-step-350: #a6a6a6;
        --ion-background-color-step-400: #999999;
        --ion-background-color-step-450: #8c8c8c;
        --ion-background-color-step-500: #808080;
        --ion-background-color-step-550: #737373;
        --ion-background-color-step-600: #666666;
        --ion-background-color-step-650: #595959;
        --ion-background-color-step-700: #4d4d4d;
        --ion-background-color-step-750: #404040;
        --ion-background-color-step-800: #333333;
        --ion-background-color-step-850: #262626;
        --ion-background-color-step-900: #191919;
        --ion-background-color-step-950: #0d0d0d;
        --ion-background-color-step-1000: #000000;
        --ion-text-color: #000000;
        --ion-text-color-step-50: #0d0d0d;
        --ion-text-color-step-100: #1a1a1a;
        --ion-text-color-step-150: #262626;
        --ion-text-color-step-200: #333333;
        --ion-text-color-step-250: #404040;
        --ion-text-color-step-300: #4d4d4d;
        --ion-text-color-step-350: #595959;
        --ion-text-color-step-400: #666666;
        --ion-text-color-step-450: #737373;
        --ion-text-color-step-500: #808080;
        --ion-text-color-step-550: #8c8c8c;
        --ion-text-color-step-600: #999999;
        --ion-text-color-step-650: #a6a6a6;
        --ion-text-color-step-700: #b3b3b3;
        --ion-text-color-step-750: #bfbfbf;
        --ion-text-color-step-800: #cccccc;
        --ion-text-color-step-850: #d9d9d9;
        --ion-text-color-step-900: #e6e6e6;
        --ion-text-color-step-950: #f2f2f2;
        --ion-text-color-step-1000: #ffffff;

      Вообще, цветовые шаги для текста/фона являются 
      зеркальным отражением друг-друга. Дизайнеры
      могут кастомизировать отдельные шаги, если необходимо.

      Например, может для дизайна надо, чтобы цвет
      ion-text-color-step-250 был розовым, а не серым.

    ▪ Цветовая карта

      Цветовая карта - коллекция абстрактных цветов, 
      которые используются во всех компонентах. Цветам
      в этой коллекции также присваиваются CSS-классы,
      чтобы можно было легко применять их к компонентам.

      Например, чтобы применить цвет primary к компоненту,
      можно просто добавить primary в качестве значения
      атрибута color компонента:

        <ion-button color="primary">Primary</ion-button>

      Вот список всех top-level цветов в цветовой карте:

        --ion-color-primary
        --ion-color-secondary
        --ion-color-tertiary
        --ion-color-success
        --ion-color-warning
        --ion-color-danger
        --ion-color-light
        --ion-color-medium
        --ion-color-dark

    ▪ Многослойные цвета в цветовой карте

      Предполагается, что цвета в цветовой карте должны
      быть многослойными - то есть, каждый такой цвет
      НЕ является одним лишь HEX-значением.

      Когда вы применяете 'primary' к кнопке, меняется не
      только цвет фона кнопки, но и цвет текста, цвета
      кнопки для состояний hover и active. Это только один
      маленький пример того, как применяеются многослойные
      цвета.

      В общем, если вы хотите изменить многослойный цвет,
      вам надо изменить цвет для всех его слоёв. Многослойный
      цвет состоит из:

      ▪ base      | базовый цвет
      ▪ contrast  | видимый относительно базового цвета
      ▪ shade     | немного более тёмный цвет относительно базового
      ▪ tint      | немного более светлый цвет относительно базового

      Например, цвет --ion-color-primary состоит из следующих
      CSS-свойств:

        --ion-color-primary: #488aff;
        --ion-color-primary-contrast: #ffffff;
        --ion-color-primary-shade: #3f79e0;
        --ion-color-primary-tint: #5a96ff;

      Ionic использует следующий шаблон для наименования
      цветов в цветовой карте:

        --ion-color-[name]-[variation]

      Вообще, причина применения многослойных цветов в том,
      что CSS не поддерживает любой метод для модификации
      цвета (mixing colors, tint, shading, etc).

      Цвета в цветовых картах также страдают от alpha-проблемы.
      Прочитайте про неё ниже, и при изменении многослойных
      цветов проверяйте, что сгенерировали RGB-список версий
      ваших цветов, и, таким образом, он может быть использовать
      для alpha-переходов.

    ▪ Alpha-проблема

      CSS в настоящий момент (начало августа 2018) не поддерживает
      granular alpha color цвета. Конечно, команда Ionic в курсе
      про rgba(), но проблема в том, что rgba() принимает только
      RGB-список. Например, вам не удастся сделать следующее:

        rgba(#ff0000, .5)

      Это означает, что для настройки только альфа-значения
      цвета, отдельно от самого цвета, требуется, сделать
      это через RGB-список. Чтобы решить эту проблему, 
      Ionic генерирует ступенчатый RGB-список, и цветовую
      карту. Рекомендуется при изменении любого из этих
      цветов перегенерировать и RGB-список, чтобы позволить
      использовать этот цвет для alpha-переходов.

      Вот RGB-список по умолчанию:

        --ion-color-primary-rgb: 72, 138, 255;
        --ion-color-secondary-rgb: 50, 219, 100;
        --ion-color-tertiary-rgb: 244, 169, 66;
        --ion-color-success-rgb: 16, 220, 96;
        --ion-color-warning-rgb: 255, 206, 0;
        --ion-color-danger-rgb: 245, 61, 61;
        --ion-color-light-rgb: 244, 244, 244;
        --ion-color-medium-rgb: 152, 154, 162;
        --ion-color-dark-rgb: 34, 34, 34;

        --ion-background-color-rgb: 255, 255, 255;
        --ion-text-color-rgb: 0, 0, 0;

      Как вы видите, используются в точности те же самые
      значения для цветов, но теперь они могут использоваться
      в rgba(). Например, primary может теперь быть 
      использовать так:

        color: rgba(var(--ion-color-primary-rgb), 0.25);

  • Применение стилей

    Стилизация приложения - такое же простое дело, как 
    применение CSS-файла с блоком :root, или использование
    JS для изменения значений CSS-свойств.

    Полная тематизация подразумевает наличие всех 
    CSS-переменных, которые будут использоваться
    по всей коллекции Ionic-компонентов.

    В этом небольшом примере лишь показано, как цвет
    primary может быть изменён через CSS:

      :root {
        --ion-color-primary: #ff0000;
        --ion-color-primary-contrast: #ffffff;
        --ion-color-primary-shade: #ae0000;
        --ion-color-primary-tint: #ff3633;
        --ion-color-primary-rgb: 255, 0, 0;
      }

    Можно менять цвет не глобально, а персонально для 
    конкретной кнопки:

      .my-fancy-button {
        --ion-color-primary: #ff0000;
        --ion-color-primary-contrast: #ffffff;
        --ion-color-primary-shade: #ae0000;
        --ion-color-primary-tint: #ff3633;
        --ion-color-primary-rgb: 255, 0, 0;
      }

    Это также можно делать через JS, функцией setProperty:

      const el = document.querySelector('.my-fancy-button');
      el.style.setProperty('--ion-color-primary', '#ff0000');
      el.style.setProperty('--ion-color-primary-contrast', '#ffffff');
      el.style.setProperty('--ion-color-primary-shade', '#ae0000');
      el.style.setProperty('--ion-color-primary-tint', '#ff3633');
      el.style.setProperty('--ion-color-primary-rgb', '255,0,0');


А8. Публикация Ionic-приложения
--------------------------------------

  # Ссылки
  # Публикация для PWA

    ▪ Превращение приложения в PWA
    ▪ Деплой PWA-приложения

  # Публикация для iOS в App Store

    ▪ Предварительные требования для публикации iOS-приложения
    ▪ Генерация release-сборки iOS-приложения
    ▪ Генерация сертификатов для подписи iOS-приложения
    ▪ Подпись iOS-приложения через XCode
    ▪ Обновление iOS-приложения

  # Публикация для Android в Play Store

    ▪ Генерация release-сборки Android-приложения
    ▪ Подпись APK-файла Android-приложения
    ▪ Отправка Android-приложения в Google Play Store
    ▪ Обновление Android-приложения

  # Публикация для Electron

    ▪ Публикация для macOS
    ▪ Публикация для Windows

--------------------------------------

> Ссылки

  • PWA
    
    ▪ Подробнее про PWA
        https://ionicframework.com/pwa

    ▪ Про Service Worker
        https://developers.google.com/web/fundamentals/primers/service-workers/

    ▪ Про Web Manifest
        https://developers.google.com/web/fundamentals/web-app-manifest/

  • iOS

    ▪ Где оплатить Apple Developers Account
        https://developer.apple.com/programs/

    ▪ Про сертификаты и подпись приложения
        https://help.apple.com/xcode/mac/current/#/dev3a05256b8

    ▪ Apple's member center
        https://developer.apple.com/membercenter

    ▪ Itunes Connect
        https://itunesconnect.apple.com/
 
  • Android

    ▪ Google Play Console
        https://play.google.com/apps/publish/?account=5139749501163457798#

  • Electron

    ▪ Официально руководство по Electron
        https://electronjs.org/docs/tutorial/first-app
 
> Публикация для PWA

  Поскольку Ionic-приложения основаны на веб-технологиях,
  они могут работать как на PWA, так и на нативных 
  платформах.

  • Превращение приложения в PWA

    Чтобы превратить приложение в PWA, есть 2 основных
    требования:

      ▪ Service Worker
      ▪ Web Manifest

    Можно добавить их в приложение вручную, либо, если 
    вы пишете на Angular, то пакет @angular/pwa позволит
    автоматизировать процесс.

    Пакет* @angular/pwa автоматически добавит Service Worker
    и Web Manifest в приложение. Чтобы добавить этот пакет
    в приложение, выполните:

      ng add @angular/pwa

    После добавления этого пакета, выполните ionic build --prod
    для сборки приложения, и папка www будет готова к деплою
    в качестве PWA.

    *Примечание:

      По умолчанию, пакет @angular/pwa поставляется с 
      логотипом Angular для иконки приложения. Не забудьте
      обновить в манифесте имя и иконки.

    Если вы разворачиваете приложения и на других каналах,
    таких как Cordova или Electron, вы можете удалить
    флаг "serviceWorker": true из angular.json. 

    Service Worker можно сгенерировать этой командой:

      ionic build --prod --service-worker

    *Примечание: 

      Такие фичи, как Service Worker, и многие JS API 
      (такие, как геолокация), требуют, чтобы приложение
      хостилось в безопасном месте. Если вы используете
      дешёвый хостинг, имейте в виду, что потребуется
      включить HTTPS, чтобы всё работало нормально.

  • Деплой PWA-приложения

    Хостинг Firebase предоставляет много преимуществ для
    PWA, включая быстрое время отклика, благодаря CDN'ам,
    включённый по умолчанию HTTPS, поддержка HTTP2 push.

    Для начала, установите Firebase CLI:

      npm install -g firebase-tools

    Затем перейтите в папку с проектом и выполните в ней:

      firebase init

    Эта команда* создаст конфиг firebase.json, и подготовит
    приложение к деплою.
      
    *Примечание:

      Команда firebase init задаст вам несколько вопросов,
      включая вопрос про редирект URL'ов на "/index.html".
      Убедитесь, что вы ответите yes на этот вопрос, но 
      ответите no на вопрос про перезапись вашего index.html.
      Благодаря этому роутинг, hard reload, и deep linking
      будут нормально работать в приложении.

    Последнее, что нужно проверить, чтобы было правильно
    настроено кэширование заголовков. Для этого, добавьте
    следующий код в firebase.json

      "headers": [
        {
          "source": "/build/app/**",
          "headers": [
            {
              "key": "Cache-Control",
              "value": "public, max-age=31536000"
            }
          ]
        },
        {
          "source": "sw.js",
          "headers": [
            {
              "key": "Cache-Control",
              "value": "no-cache"
            }
          ]
        }
      ]    

    Теперь, можно задеплоить приложение командой:

      firebase deploy

> Публикация для iOS в App Store

    Вообще, подробнее про это лучше почитай методички
    Cordova и Capacitor. Здесь же описан лишь примерный
    процесс, для общего развития, так сказать.

  • Предварительные требования для публикации iOS-приложения

    Для публикации iOS-приложения в App Store необходимо
    следующее:

    ▪ MacOS High Sierra
    ▪ XCode
    ▪ Оплаченный Apple Developers Account ($100/год)
    ▪ Сертификаты приложения для разработки и распространения

  • Генерация release-сборки iOS-приложения

    ▪ Cordova

      Если платформа iOS ещё не добавлена, добавьте
      её:

        ionic cordova platform add ios

      Когда платформа добавлена, запустите команду 
      build с флагом --prod :

        ionic cordova build ios --prod

      Это сгенерирует минифицированный код для web-части
      приложения, и скопирует его на платформу iOS.

      Далее, откройте файл .xcworkspace в ./platforms/ios/
      для запуска XCode.

  • Генерация сертификатов для подписи iOS-приложения

    Чтобы создать необходимые сертификаты и профили,
    посетите Apple's member center и следуйте инструкциям
    из документации apple.

    Есть 2 типа сетрификатов, которые здесь важны:

      ▪ Development
      ▪ Distribution

    Первый необходим во время разработки. Он позволяет 
    подписывать приложение и деплоить на устройства,
    к которым у сертификата есть доступ.

    Второй необходим для добавления приложения в App Store.
    Когда приложение подписано этим сертификатом, оно 
    может быть установлено на любое приложение.

  • Подпись iOS-приложения через XCode

    Когда сертификаты готовы, можно работать с ними через
    XCode, или вручную. Лучше доверить это дело XCode.
    Это позволит быть уверенным, что используются верные
    Development и Distribution сертификаты, на основе
    выбранного типа сборки.

    Перейдите в Product -> Archive. Это создаст сборку
    версии приложения, которая готова к добавлению в 
    App Store. Когда архив будет создан, откроется
    XCode Organizer.

    XCode Organizer отображает список сборок текущего
    приложения. Выберите последнюю сборку и нажмите
    "Upload to App Store". Там ещё должно быть место, где
    можно выбрать команду, инфа о приложении, и кнопка
    "Upload".

    Если успешно удалось залить приложение, оно должно
    появиться в Itunes Connect в "Activities". Там 
    можно включить "TestFlight" для бета-тестирования,
    либо можно отправить приложение в Apple для
    проверки.

  • Обновление iOS-приложения

    По мере роста приложения, его, скорее всего, надо 
    будет обновлять новыми фичами, фиксить баги.

    Приложения может быть обновлено двумя способами:

      ▪ Отправить новую версию на проверку в Apple.
      ▪ Обновить приложени push'em, например, через Ionic Deploy.

    Ionic Deploy позволяет внести изменения в приложение
    напрямую в реальном времени, без ожидания, пока 
    Apple проведёт свою проверку.

    *Примечание:  

      Чтобы iOS App Store принял обновленную сборку,
      файл config.xml должен быть отредактирован, в нём
      надо инкрементировать версию, затем пересобрать
      приложение для релиза следуя вышеописанным
      инструациям.

> Публикация для Android в Play Store

    Вообще, подробнее про это лучше почитай методички
    Cordova и Capacitor. Здесь же описан лишь примерный
    процесс, для общего развития, так сказать.

  • Генерация release-сборки Android-приложения

    ▪ Cordova

      Для генерации release-сборки Android-приложения,
      выполните следующую команду:

        ionic cordova build android --prod --release

      Это сгенерирует release-сборку, основанную на
      config.xml, и положит её в папку
      platforms/android/build/outputs/apk

      Ionic-приложение имеет стандартные настройки в 
      config.xml, но их можно менять.

  • Подпись APK-файла Android-приложения

    Во-первых, неподписанный APK надо подписать.
    Если ключ для подписи уже был создан,
    пропустите эти шаги и используйте его. Если нет, то
    сгенерируйте ключ используя команду keytool,
    которая идёт вместе с Android SDK:

      keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000

    Эта команда задаст несколько вопросов, и после завершения
    своей работы, создаст файл* my-release-key.keystore в 
    текущем каталоге.

    *Внимание:

      Сохраните этот файл и держите в безопасном месте.
      Если вы его потеряете, Google Play Store не будет
      принимать обновления для этого приложения!

    Чтобы подписать неподписанный APK, запустите jarsigner,
    который также идёт вместе с Android SDK:

      jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore HelloWorld-release-unsigned.apk alias_name

    Наконец, надо запустить zipalign, чтобы оптимизировать
    APK. Эта команда находится в 
    /path/to/Android/sdk/build-tools/VERSION/zipalign

    Например, на macOS с Android Studio, команда zipalign
    лежит в ~/Library/Android/sdk/build-tools/VERSION/zipalign

    Выполняем:

      zipalign -v 4 HelloWorld-release-unsigned.apk HelloWorld.apk

    Это сгенерирует финальный релизный бинарник, с именем
    типа HelloWorld.apk, который может быть добавлен в 
    Google Play Store.

  • Отправка Android-приложения в Google Play Store

    Теперь, когда release APK готов, можно загружать его
    в Play Store.

    Для этого, откройте Google Play Store Developer Console
    и создайте там новый аккаунт (если у вас ещё нет). 
    Это будет стоить $25 (разовый платёж).

    После оплаты аккаунта, создаёте новое приложение.
    Не забудьте заполнить описание приложения, добавить
    скриншоты, и т.п. Когда всё заполните, добавьте
    подписанный APK, и опубликуйте приложение.

  • Обновление Android-приложения

    По мере разработки приложения, скорее всего его понадобится
    обновлять, добавлять новые фичи и фиксы. Приложение можно
    обновить двумя способами:

      ▪ Отправить новую версию на проверку в Google Play Store.
      ▪ Обновить приложени push'em, например, через Ionic Deploy.

    Ionic Deploy позволяет внести изменения в приложение
    напрямую в реальном времени, без ожидания, пока 
    Apple проведёт свою проверку.

    *Примечание:  

      Чтобы Google Play Store принял обновленную сборку,
      файл config.xml должен быть отредактирован, в нём
      надо инкрементировать версию, затем пересобрать
      приложение для релиза следуя вышеописанным
      инструациям.

> Публикация для Electron

  Разработка desktop-приложени на Ionic позволяет разработчикам
  на 100% переиспользовать весь их код и поставлять 
  традиционное desktop-приложение, сохраняя доступ ко всем
  нативным фичам, вроде push-уведомлений. Это руководство
  подразумевает, что вы знакомы с Electron, и не описывает,
  как разрабатывать Electron-приложения.

  • Публикация для macOS

    ▪ Требования

      ▪ Последняя версия XCode
      ▪ Активный Apple Developers Account ($100/год).

    ▪ Публикация

      В руководстве Electron есть отдельный раздел про то,
      как публиквать приложение для macOS:

        https://electronjs.org/docs/tutorial/mac-app-store-submission-guide

  • Публикация для Windows

    ▪ Требования

      ▪ Windows 10 with Anniversary Update
      ▪ The Windows 10 SDK
      ▪ NodeJS
      ▪ electron-windows-store CLI

      Установить electron-windows-store через npm:

        npm install -g electron-windows-store

    ▪ Публикация

      В руководстве Electron есть отдельный раздел про то,
      как публиквать приложение для Windows:   

        https://electronjs.org/docs/tutorial/windows-store-guide

А9. FAQ
--------------------------------------

  # Build Errors

    ▪ Забыть () на декораторе
    ▪ Cannot resolve all parameters for MyClass ...
    ▪ No provider for ParamType! (MyClass -> ParamType)
    ▪ Can't bind to 'propertyName' since it isn't a known ...
    ▪ No provider for ControlContainer! (NgControlName -> ControlContainer)
    ▪ No component factory found for

  # Runtime Errors

    ▪ Пустой белый экран, ошибок нет
    ▪ Директива не работает
    ▪ Большой лаг при обработке события click
    ▪ Cordova-плагины не работают в браузере
    ▪ Множественные экземпляры provider'а

  # Native Errors

    ▪ Проблемы с подписыванием приложения
    ▪ Xcode build error 65
    ▪ Сбой версий Google Play Services

  # Подсказки разработчикам

    ▪ Обновление зависимостей
    ▪ Редакторы
    ▪ Использование Debugger'а
    ▪ Изменение режима (mode: md / ios)
    ▪ Использование iOS-симулятора
    ▪ Использование Genymotion Android Emulator
    ▪ Удалённая отладка - iOS и Safari
    ▪ Удалённая отладка - Android и Chrome
    ▪ Удалённая отдалка - VS Code Plugin

--------------------------------------

> Build Errors

  Подробнее о них см.в документации Ionic:
  https://beta.ionicframework.com/docs/faq/build

> Runtime Errors

  • Пустой белый экран, ошибок нет

    Это может происходить по разным причинам. Если вам не 
    удаётся найти решение в интернете, на форуме, попробуйте
    это:

    ▪ Root @Component has a template or templateUrl.
    ▪ Root @Component template has an <ion-nav> with a root property:

      <ion-nav [root]="rootPage"></ion-nav>

  • Директива не работает

    Есть несколько вещей, которые вы можете 
    проверить:

    ▪ убедитесь, что включили директиву в массив directives
      в @Component, который вы хотите её использовать
      (только, если версия вашего ionic-angular ниже RC0);

    ▪ в вашем селекторе нет очепяток;

    ▪ вы правильно используете селектор, как атрибут, элемент или класс;

    ▪ у вашего селектора верный синтаксис

      ▪ [attr] для attribute-селектора
      ▪ element для element-селектора
      ▪ .class для class-селектора

    Вот пример использования attribute-селектора:

      @Directive({
        selector: '[my-dir]' // <-- [my-dir] because it is an attribute
      })                     // Could be my-dir, [my-dir], .my-dir
      class MyDir {
        constructor() {
          console.log('I'm alive!');
        }
      }

      @Component({
        // We add my-dir as an attribute to match the directive's selector
        template: `<div my-dir>Hello World</div>`,

        // Alternatively, if you were attaching the directive to an element it would be:
        // template: `<my-dir>Hello World</my-dir>`
        // and if you were attaching by class the template would be:
        // template: `<div class="my-dir">Hello World</div>`

        directives: [MyDir] // <-- Don't forget me! (only if your ionic-angular version is below RC0)
      })
      class MyPage { }

  • Большой лаг при обработке события click

    Авторы рекоменюуют использовать событие "click" только
    на элементах, на которые должны именно кликать мышкой
    (а не тапать пальцем, и т.д). Как правило, это элементы
    <button> и <a>.

    Если вы используете событие click на элементах, которые
    обычно не являются кликабельными, вы получаете задержку
    обработки события в 300мс с момента клика по элементу и
    возбуждения события. Чтобы удалить эту задержку, вы 
    можете добавить атрибут tappable вашему элементу:

      <div tappable (click)="doClick()">I am clickable!</div>

  • Cordova-плагины не работают в браузере

    В какой-то момент, при разработке, вы можете вызвать
    Cordova-плагин, и получить warning:

      [Warning] Native: tried calling StatusBar.styleDefault, but Cordova is not
      available. Make sure to include cordova.js or run in a device/simulator
      (app.bundle.js, line 83388)

    Это происходит, когда вы пытаетесь вызвать нативный плагин,
    но Cordova недоступна. К счастью, Ionic Native выводит
    Warning вместо ошибки.

    В других случаях, когда плагин не был использован через
    Ionic Native, вы можете получить менее ясный warning:

      EXCEPTION: Error: Uncaught (in promise): TypeError: undefined is not an object
      (evaluating 'navigator.camera.getPicture')

  • Множественные экземпляры provider'а

    Это Angular-специфичная проблема, меня не касается.

> Native Errors

  • Проблемы с подписыванием приложения

    Ошибка:

      "Code Signing Error: Failed to create provisioning profile. 
      The app ID “com.csform.ionic.yellow” cannot be registered 
      to your development team. Change your bundle identifier 
      to a unique string to try again. Code Signing Error: 
      No profiles for ‘com.csform.ionic.yellow’ were found: 
      Xcode couldn’t find any iOS App Development provisioning 
      profiles matching ‘com.csform.ionic.yellow’. 
      Code Signing Error: Code signing is required for product 
      type ‘Application’ in SDK ‘iOS 11.1’"

    Решение:

      Запуск приложения на iOS-устройстве требует наличия
      provisioning-профиля. Если оный ещё не был создан,
      следуйте следующим указаниям:

      1. Установите Package ID

        ▪ Capacitor

          Откройте файл capacitor.config.json и измените
          свойство appId.

        ▪ Cordova

          Откройте файл config.xml и измените атрибут
          id корневого элемента <widget>.

      2. Откройте проект в XCode

        ▪ Capacitor

          Выполните эту команду, чтобы открыть приложение
          в XCode:

            ionic capacitor open ios

        ▪ Cordova   

          Откройте XCode. Используйте File -> Open 
          и выберите приложение, которое лежит в 
          папке platforms/ios.

      3. Слева в навигации по структуре проекта, выберите
         корневую папку. В разделе Identity, убедитесь,
         что Package ID, и оный, установленный в пункте №1,
         совпадают.

      4. В том же месте, что в пункте 3, в разделе Signing,
         убедитесь, что стоит галочка "Automatically manage
         signing". Затем, выберите Development Team. Как только
         вы этот сделаете, XCode попытается автоматически
         подготовить provisioning и signing.

  • Xcode build error 65

    Ошибка:

      "Error: Error code 65 for command: xcodebuild with 
      args: -xcconfig,/Users/tdit0703/IdeaProjects/
      sc-dahenfeld/platforms/ios/cordova/build-debug.
      xcconfig,-workspace,SC Dahenfeld.xcworkspace,
      -scheme,SC Dahenfeld,-configuration,Debug,
      -sdk,iphonesimulator,-destination,platform=
      iOS Simulator,name=iPhone X,build,CONFIGURATION_BUILD_DIR=
      /Users/tdit0703/IdeaProjects/sc-dahenfeld/platforms/ios/
      build/emulator,SHARED_PRECOMPS_DIR=/Users/tdit0703/IdeaProjects
      /sc-dahenfeld/platforms/ios/build/sharedpch"   

    Решение:

      Эта ошибка является кодом ошибки из XCode, которая 
      могла быть вызвана проблемами с provisioning, или
      старыми зависимостями Cordov'ы. Чтобы исправить эту ошибку,
      сначала убедитесь, что provisioning profile был создан
      с помощью указанных выше инстуркций и попробуйте запустить
      приложение из XCode.

      Если это не поможет, запустите следующие команды,
      которые создадут новый, свежий билд для Cordova:

        rm -rf node_modules
        rm -rf platform
        npm i
        ionic cordova platform add ios
        ionic cordova prepare ios
        ionic cordova build ios --prod

  • Сбой версий Google Play Services

    Ошибка:

      "Error: more than one library with package name 
      com.google.android.gms"

    Решение:

      Эта ошибка вызывается двумя разными плагинами, которые
      пытаются использовать разные версии Google Play Services.

      Чтобы исправить её, убедитесь, что вы работаете с 
      Cordova >= 7.1.0, и cordova-android >= 6.3.0.

      Чтобы обновить Cordova, выполните:

        npm install cordova@latest

      А чтобы обновить cordova-android:

        cordova platform update android

      Зависящие от Google Play Services теперь можно обновить,
      чтобы они использовали одну и ту же версию.

      Например, если pluginA использует версию 11.0 и pluginB
      использует версию 15.0, можно им указать, чтобы они
      использовали версию 15.0 оба. Для этого в config.xml:

        <plugin name=”pluginA” spec=”npm”>
          <variable name=”PLAY_SERVICES_VERSION” value=”15.0.0" />
        </plugin>
        <plugin name=”pluginB” spec=”npm”>
          <variable name=”PLAY_SERVICES_VERSION” value=”15.0.0" />
        </plugin>

> Подсказки разработчикам

  • Обновление зависимостей

    Рекомендуется обновлять пакеты через npm.
    Чтобы обновить зависимости, выполните:

      npm install <package-name>@<version|latest> --save

    Например, чтобы обновить пакет @ionic/angular,
    выполните:

      npm install @ionic/angular@latest --save

  • Редакторы

    Есть много редакторов кода на выбор:

      ▪ VSCode
      ▪ Atom
      ▪ Webstorm
      ▪ ...

    Авторы Ionic, по всей видимости, любители VSCode,
    так как активно его рекомендуют.

  • Использование Debugger'а

    Ключевое слово "debugger" можно использовать для 
    отладки приложения. Когда большинство браузеров видят
    в коде утвеждение "debugger", работающий JS останавливается,
    и браузер загружит свой дебаггер. 

    Использовать debugger можно, чтобы проставлять брэйкпоинты
    в приложении. Например, если функция возвращает неправильное
    значение, debugger можно использовать, чтобы остановить
    её выполнение на определенном этапе, и проверить
    переменные:

      function myBrokenFunction() {
        debugger;
        // do other stuff
      }

    Во время работы приложения, вызов этой функции поставит
    его JS-код на паузу. В devtools, можно продолжить выполнение
    кода строка за строкой, и найти, где функция ломается.

  • Изменение режима (mode: md / ios)

    По умолчанию, когда приложение просматривается в браузере,
    Ionic по умолчанию применяет md (material design). Однако,
    поскольку Ionic-компоненты адаптируются к платформе, на 
    которой выполняются, было бы полезно посмотреть, а как бы
    выглядело приложение на iOS. 

    Чтобы это сделать, просто добавьте в URI приложения:

      ?ionic:mode=ios

    *Примечание:

      Однако, это не меняет то, как браузер воспринимает,
      на какой платформе сейчас работае приложение. Платформа
      определяется путём определения устройства по user-agent.

      Поэтому, чтобы изменить это, вам надо менять user-agent.
      Чтобы сделать это, откройте Chrome DevTools, и переключите
      устройство на другое (Ctrl + Shift + i).

  • Использование iOS-симулятора

    Симулятор iOS позволяет тестировать и отлаживать приложение
    без реального устройства. Для использования симулятора, надо
    установить XCode. Чтобы запустить Ionic-приложение
    на Cordova в симуляторе:

      ionic cordova emulate ios -lc

    -lc запустит livereload и log console output в терминал.

    XCode также можно использовать для запуска эмулятора и 
    отладки приложения. Откройте XCode и откройте
    ../path-to-app/platforms/ios/myApp.xcodeproj.

    После загрузки приложения, консольный вывод и логи
    устройства будут отображаться в окне вывода XCode.

  • Использование Genymotion Android Emulator

    Вообще, в Android SDK есть свой, стандартный эмулятор.
    Однако, авторы Ionic утверждают, что он может быть
    иногда медленным и тормознутым.

    Поэтому, есть альтернативный эмулятор - Genymotion.
    И он также имеет доступ к нативному функционалу,
    такому, как GPS и камера.

  • Удалённая отладка - iOS и Safari

    Safari можно использовать для отладки Ionic-приложения
    на подключенном iOS-устройстве. Сначала, включите
    Web Inspector на подключенном устройстве:

      Settings > Safari > Advanced

    Затем, в Safari на Mac включите "Show develop menu in
    menu bar" в:

      Safari > Preferences > Advanced

    После этого, подключенные устройства должны появиться
    в меню Develop. Из него, можно использовать средства
    разработки Safari для отладки приложения.

  • Удалённая отладка - Android и Chrome

    Можно использовать Chrome DevTools для отладки приложения,
    когда оно запущено в браузере через ionic serve, 
    или на эмуляторе, или на физическом устройстве.

    Для отладки приложения, в Chrome идите в:

      chrome://inspect

    *Примечание:

      На физических устройствах надо в настройках включить
      Developer Mode.

      Как это сделать описано в методичке про Capacitor.

  • Удалённая отладка - VS Code Plugin

    У VSCode есть плагин для отладки Corodva-приложений.
    (https://marketplace.visualstudio.com/items?itemName=vsmobile.cordova-tools)

    Этот плагин создаёт мост между устройством и VSCode Devtools,
    и позволяет производить отладку прямо в редакторе.


А10. Ionic API (справочник)
--------------------------------------

  ▪   свойство
  •   метод
  ►   событие
  Ⓐ  атрибут

  Component API

    # ion-action-sheet      | Fullscreen-модалка о списком действий поверх контента
      
      ▪ buttons               | Массив кнопок для Action Sheet
      ▪ cssClass              | Какие доп.классы применить. Если их > 1, надо разделять пробелами
      ▪ enableBackdropDismiss | [true] Если true, Action Sheet можно будет закрыть кликом по фону
      ▪ enterAnimation        | Анимация появления Action Sheet
      ▪ Builde                | Заголовок для Action Sheet
      ▪ header                | Заголовок для Action Sheet
      ▪ keyboardClose         | Должен ли Action Sheet закрыть клавиатуру
      ▪ leaveAnimation        | Анимация закрытия Action Sheet
      ▪ overlayId             | Уникальный ID экземпляра Action Sheet (для внутреннего использования)
      ▪ subHeader             | Подзаголовок для Action Sheet
      ▪ translucent           | [false] Включить ли полупрозрачность для Action Sheet
      ▪ willAnimate           | [true] Анимировать ли Action Sheet

      • dismiss()             | Закрыть Action Sheet
      • onDidDismiss()        | Вернуть промис, резолвящийся после закрытия Action Sheet (можно передать callback)
      • onWillDismiss()       | Вернуть промис, резолвящийся перед закрытием Action Sheet (можно передать callback)
      • present()             | Показать Action Sheet

      ► ionActionSheetDidDismiss  | Возбуждается после закрытия alert
      ► ionActionSheetDidLoad     | Возбуждается после загрузки alert
      ► ionActionSheetDidPresent  | Возбуждается после представления alert
      ► ionActionSheetDidUnload   | Возбуждается после выгрузки alert
      ► ionActionSheetWillDismiss | Возбуждается перед закрытием alert
      ► ionActionSheetWillPresent | Возбуждается перед представлением alert

    # ion-alert             | Не-fullscreen модалка с текстом и элементами формы

      ▪ buttons             | Массив кнопок для Alert
      ▪ cssClass            | Какие доп.классы применить. Если их > 1, надо разделять пробелами
      ▪ enableBackdropDismiss | [true] Если true, Action Sheet можно будет закрыть кликом по фону
      ▪ enterAnimation      | Анимация появления Action Sheet
      ▪ header              | Заголовок для Alert
      ▪ inputs              | Массив input'ов, которые показать в alert
      ▪ keyboardClose       | Должен ли Alert закрыть клавиатуру
      ▪ leaveAnimation      | Анимация закрытия Action Sheet
      ▪ message             | Главное сообщение для показа в alert
      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ overlayId           | Уникальный ID экземпляра Alert (для внутреннего использования).
      ▪ subHeader           | Подзаголовок для Action Sheet
      ▪ translucent         | [false] Включить ли полупрозрачность для Action Sheet
      ▪ willAnimate         | [true] Анимировать ли Action Sheet

      • dismiss()           | Закрыть Alert
      • onDidDismiss()      | Вернуть промис, резолвящийся после закрытия Alert (можно передать callback)
      • onWillDismiss()     | Вернуть промис, резолвящийся перед закрытием Alert (можно передать callback)
      • present()           | Показать Alert

      ► ionAlertDidDismiss  | Возбуждается после закрытия alert
      ► ionAlertDidLoad     | Возбуждается после загрузки alert
      ► ionAlertDidPresent  | Возбуждается после представления alert
      ► ionAlertDidUnload   | Возбуждается после выгрузки alert
      ► ionAlertWillDismiss | Возбуждается перед закрытием alert
      ► ionAlertWillPresent | Возбуждается перед представлением alert

    # ion-anchor            | Используется для перехода к указанной ссылке

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ href                | Содержит URL (или фрагмент), куда ведёт ссылка
      ▪ routerDirection     | При использовании роутера, указать направление анимации при переходе на др.страницу через href

    # ion-app               | Элемент-контейнер для Ionic-приложения
    # ion-avatar            | Круговой компонент, оборачивающий изображение или иконку
    # ion-back-button       | Кнопка "назад" для перехода на 1 шаг назад по истории приложения

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ defaultHref         | URL по умолчанию для навигации "назад", когда в стеке истории уже пусто
      ▪ icon                | Какую иконку (имя) использовать для back button
      ▪ mode                | Какие стили использовать, "ios" или "md"
      ▪ text                | Какой текст показывать на кнопке

    # ion-backdrop          | Fullscreen-компонент, перекрывающий другие компоненты

      ▪ stopPropagation     | [true] Останавливать ли всплытие события при тапе на backdrop?
      ▪ tappable            | [true] Возбуждать ли при клике/тапе по backdrop событие ionBackdropTap?
      ▪ visible             | [true] Видим ли backdrop?

      ► ionBackdropTap      | Возбуждается при клике/тапе по backdrop

    # ion-badge             | Inline-block элемент, который обычно возникает рядом с другим элементом

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-button            | Кликабельный элемент "кнопка"

      ▪ buttonType          | Тип кнопки: "button", "bar-button"
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения.
      ▪ disabled            | [false] Отключить ли кнопку (на неё нельзя нажать)?
      ▪ expand              | Делает кнопке block вместо inline-block, т.е. full-width: "block" (с border'ами справа/слева), "full" (без border'ов справа/слева)
      ▪ fill                | [clear] "Clear" - прозрачный фон и границы; "outline" - прозрачный фон, границы видны; "solid" - непрозрачный фон и границы.
      ▪ href                | Содержит URL (или фрагмент), куда ведёт ссылка.
      ▪ mode                | Какие стили использовать, "ios" или "md".
      ▪ routerDirection     | При использовании роутера, указать направление анимации при переходе на др.страницу через href
      ▪ shape               | Форма кнопки, возможные значения: "round"
      ▪ size                | Размер кнопки. Значения: "small", "default", "large"
      ▪ strong              | [false] Включить ли для кнопки более жирный шрифт?
      ▪ type                | [button] Тип кнопки. Значения: "submit", "reset", "button"

      ► ionBlur             | Возбуждается, когда кнопка теряет фокус
      ► ionFocus            | Возбуждается, когда кнопка получает фокус

    # ion-buttons           | Компонент-контейнер для элементов button
    # ion-card              | Карточки, стандартный элемент UI для размещения контента

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-card-content      | Дочерний для ion-card компонент для контента

      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-card-header       | Дочерний для ion-card компонент для header'а

      ▪ translucent         | [false] Включить ли полупрозрачность
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-card-subtitle     | Дочерний для ion-card компонент для подзаголовка

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"
    
    # ion-card-title        | Дочерний для ion-card компонент для заголовка

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-checkbox          | Компонент-чекбокс

      ▪ checked             | [false] Включён ли чекбокс?
      ▪ disabled            | [false] Отключить ли чекбокс (на него нельзя нажать)?
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"
      ▪ name                | Имя для чекбокса, которое отправится вместе с form data.
      ▪ value               | Значение чекбокса
 
      ► ionBlur             | Возбуждается при потере фокуса чекбоксом
      ► ionChange           | Возбуждается при переключении значения чекбокса
      ► ionFocus            | Возбуждается при получении фокуса чекбоксом
      ► ionStyle            | Возбуждается при изменении styles
    
    # ion-chip              | Сложные сущности в небольших блоках, как контакт

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-chip-button       | Inset-кнопка, которая размещается внутри chip

      ▪ disabled            | [false] Может ли пользователь взаимодействовать с chip button?
      ▪ fill                | Установить значение clear, чтобы вкл прозрачный стиль для кнопки
      ▪ href                | Содержит URL (или фрагмент), куда ведёт ссылка.
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-chip-icon         | Иконка, которая размещается внутри chip
    
      ▪ name                | Имя для элемента иконки
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ mode                | Какие стили использовать, "ios" или "md"

    # ion-grid              | CSS-сетка для создания layout'ов

      ▪ fixed               | [false] Будет ли сетка иметь fix ширину, на основе ширины экрана?

    # ion-col               | Column-компонент для размещения внутри grid, внутри row

      ▪ offset              | На какое кол-во колонок сместить текущую вправо
      ▪ offsetLg            | (для lg-экранов) На какое кол-во колонок сместить текущую вправо
      ▪ offsetMd            | (для md-экранов) На какое кол-во колонок сместить текущую вправо
      ▪ offsetSm            | (для sm-экранов) На какое кол-во колонок сместить текущую вправо
      ▪ offsetXl            | (для xl-экранов) На какое кол-во колонок сместить текущую вправо
      ▪ offsetXs            | (для xs-экранов) На какое кол-во колонок сместить текущую вправо
      ▪ pull                | На какое кол-во колонок сместить текущую влево
      ▪ pullLg              | (для lg-экранов) На какое кол-во колонок сместить текущую влево
      ▪ pullMd              | (для md-экранов) На какое кол-во колонок сместить текущую влево
      ▪ pullSm              | (для sm-экранов) На какое кол-во колонок сместить текущую влево
      ▪ pullXl              | (для xl-экранов) На какое кол-во колонок сместить текущую влево
      ▪ pullXs              | (для xs-экранов) На какое кол-во колонок сместить текущую влево
      ▪ push                | На какое кол-во колонок push'нуть текущую вправо
      ▪ pushLg              | (для lg-экранов) На какое кол-во колонок push'нуть текущую вправо
      ▪ pushMd              | (для md-экранов) На какое кол-во колонок push'нуть текущую вправо
      ▪ pushSm              | (для sm-экранов) На какое кол-во колонок push'нуть текущую вправо
      ▪ pushXl              | (для xl-экранов) На какое кол-во колонок push'нуть текущую вправо
      ▪ pushXs              | (для xs-экранов) На какое кол-во колонок push'нуть текущую вправо
      ▪ size                | Размер колонки в колонках (n/12)
      ▪ sizeLg              | (для lg-экранов) Размер колонки в колонках (n/12)
      ▪ sizeMd              | (для md-экранов) Размер колонки в колонках (n/12)
      ▪ sizeSm              | (для sm-экранов) Размер колонки в колонках (n/12)
      ▪ sizeXl              | (для xl-экранов) Размер колонки в колонках (n/12)
      ▪ sizeXs              | (для xs-экранов) Размер колонки в колонках (n/12)

      Ⓐ align-self-start      | Колонка будет выравнена во вертикали на top
      Ⓐ align-self-center     | Колонка будет выравнена во вертикали на center
      Ⓐ align-self-end        | Колонка будет выравнена во вертикали на bottom
      Ⓐ align-self-stretch    | Колонка будет растянута по вертикали, чтобы занять 100% высоты row
      Ⓐ align-self-baseline   | Колонка будет выравнена во вертикали на baseline

    # ion-row               | Row-компонент для размещения внутри grid

      Ⓐ nowrap                  | Приведение столбцов в одну строку
      Ⓐ wrap-reverse            | Реверс порядка столбцов
      Ⓐ align-items-start       | Вертикальное выравнивание столбцов на top
      Ⓐ align-items-center      | Вертикальное выравнивание столбцов на center
      Ⓐ align-items-end         | Вертикальное выравнивание столбцов на end
      Ⓐ align-items-stretch     | Растягивание всех колонок по вертикали до высоты row
      Ⓐ align-items-baseline    | Вертикальное выравнивание столбцов на baseline
      Ⓐ justify-content-start   | Горизонтальное выравнивание колонок на старт
      Ⓐ justify-content-center  | Горизонтальное выравнивание колонок на центр
      Ⓐ justify-content-end     | Горизонтальное выравнивание колонок на конец
      Ⓐ justify-content-around  | Горизонтальное выравнивание с равным расстоянием между
      Ⓐ justify-content-between | Горизонтальное выравнивание с half-size расстоянием на обоих концах

    # ion-content           | Главная зона для контента, со скроллом

      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения.
      ▪ forceOverscroll     | [false] Выключить ли bounce-эффект?
      ▪ fullscreen          | [false] Будет ли контент скроллиться за header'ом и footer'ом?
      ▪ scrollEnabled       | [true] Включить ли скролл в content через scroll?
      ▪ scrollEvents        | [false] Включить ли возбуждение событий scroll'а?

      • getScrollElement()  | Получить скролл элемента

    # ion-datetime          | Datetime-picker, который вылазит снизу экрана

      ▪ cancelText          | [Cancel] Какой текст показать на кнопке cancel
      ▪ dayNames            | Полные имена дней недели на локальном языке (english по умолчанию)
      ▪ dayShortNames       | Короткие имена дней недели на локальнмо языке (english по умолчанию)
      ▪ dayValues           | Какие даты показывать: число, массив чисел, строка с comma-sep.числами
      ▪ disabled            | [false] Отключить ли пользователю возможность взаимодействовать с datetime?
      ▪ displayFormat       | [MMM D, YYYY] Формат текстового отображения даты и времени
      ▪ doneText            | [Done] Какой текст отображать на кнопке "Done"?
      ▪ hourValues          | Какие часы показывать: число, массив чисел, строка с comma-sep.числами
      ▪ max                 | Максимальная разрешённая дата и время в формате "1996-12-19"
      ▪ min                 | Минимальная разрешённая дата и время в формате "1996-12-19"
      ▪ minuteValues        | Какие минуты показывать: число, массив чисел, строка с comma-sep.числами
      ▪ monthNames          | Полные имена месяцев на локальном языке (english по умолчанию)
      ▪ monthShortNames     | Короткие имена месяцев на локальном языке (english по умолчанию)
      ▪ monthValues         | Какие месяцы показывать: число, массив чисел, строка с comma-sep.числами
      ▪ pickerFormat        | [displayFormat] Формат колонок для date and time picker'а
      ▪ pickerOptions       | Любые доп.опции, которые интерфейс picker'а может принять
      ▪ placeholder         | Какой текст показывать, если дата ещё не выбрана
      ▪ value               | Значение компонента datetime
      ▪ yearValues          | Какие года показывать: число, массив чисел, строка с comma-sep.числами

      ► ionCancel           | Возбуждается, когда выбор datetime был отменён
      ► ionStyle            | Возбуждается при изменение styles

    # ion-fab               | Контейнерный элемент для fab-кнопок

      ▪ activated           | [false] Отобразить ли на FAB кнопках иконку close?
      ▪ edge                | Показывать fab на краю header'а (если vertical == "top") или footer'а (если vertical == "bottom")
      ▪ horizontal          | Горизонтальное позиционирование во viewport: "center", "start", "end"
      ▪ vertical            | Вертикальное позиционирование  во viewport: "top", "center", "bottom"

      • close()             | Закрыть активный FAB list

    # ion-fab-button        | Floating Action Button (FAB) для основного действия на экране

      ▪ activated           | [false] Отобразить ли на FAB кнопках иконку close?
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ href                | Содержит URL (или фрагмент), куда ведёт ссылка
      ▪ mode                | В каком режиме (md или ios) отображать компонент
      ▪ disabled            | [false] Отключить ли кнопку (на неё нельзя нажать)?
      ▪ translucent         | [false] Включить ли полупрозрачность для компонента?
      ▪ show                | Показывать ли FAB в FAB list'е?

    # ion-fab-list          | Контейнер для N FAB'ов, которые появляются при клеке на главную FAB

      ▪ activated           | [false] Отобразить ли на FAB кнопках иконку close?
      ▪ side                | [false] Отобразить ли на FAB кнопках иконку close?

    # ion-footer            | Один из трёх корневых компонентов страницы, находящийся в нижней части

      ▪ mode                | В каком режиме (md или ios) отображать компонент
      ▪ translucent         | [false] Включить ли полупрозрачность для компонента?

    # ion-header            | Один из трёх корневых компонентов страницы, находящийся в верхней части

      ▪ mode                | В каком режиме (md или ios) отображать компонент
      ▪ translucent         | [false] Включить ли полупрозрачность для компонента?

    # ion-hide-when         | Скрывает себя и свой контент, если условие равно true

      ▪ mediaQuery          | Если текущий media query совпадает с этим значением, элемент будет скрыт
      ▪ mode                | Если текущий режим отображения (ios или md) совпадает с указанной, элемент будет скрыт
      ▪ or                  | Если false, все условия д.б. true для скрытия эл-та; если true - хотя бы одно
      ▪ orientation         | Если текущая ориентация совпадает с указанной, элемент будет скрыт
      ▪ platform            | Если текущая платформа совпадает с указанной, элемент будет скрыт
      ▪ size                | Если текущая ширина экрана (xs,sm,md,lg,xl) совпадает с указанной, элемент будет скрыт

    # ion-img               | Лениво подгрузит картинку, когда она окажется во viewport

      ▪ alt                 | Альтернативный текст для описания изображения
      ▪ src                 | URL изображения, обязателен к заполнению

    # ion-infinite-scroll   |

      ▪ disabled            | Отключить бесконечный скролл (скрыть scrollbar, выключить обработчики)
      ▪ position            | [bottom] Положение элемента infinite scroll: top, bottom
      ▪ threshold           | [15%] Расстояние скролла от top/bottom страницы, на котором будут попытки подгрузить контент

      • complete()          | Его на экземпляре inf.scr. надо вызвать в конце handler'а события ioninfinite
      • waitFor()           | Вместо complete, можно передать промис, и когда он разрешится, inf.scr. посчитает загрузку завершённой

      ► ionInfinite         | Срабатывает, когда скролл достигает расстояния threshold от top/bottom (в завис.от значения position)

    # ion-infinite-scroll-content  | Дочерний компонент для демонстрации контента по умолчанию для infinite scroll

      ▪ loadingSpinner      | Анимированный SVG-спиннер, чтобы показывать во время подгрузки контента
      ▪ loadingText         | (опционально) Текст, чтобы показывать во время подгрузки

    # ion-input             | Обёртка для элемента HTML-input с кастомной стилизацией и доп.функционалом.

      ▪ accept              | Если type=="file", то в accept список принимаемых типов файлов; иначе игнорируется
      ▪ autocapitalize      | [none] Приводить ли текст автоматически к верхнему регистру?
      ▪ autocomplete        | [off] Разрешить ли браузерный автокомплит?
      ▪ autocorrect         | [off] Разрешить ли автокоррекцию ввода?
      ▪ autofocus           | [false] Дать ли input'у автофокус при загрузке страницы?
      ▪ clearInput          | [false] Показывать ли иконку "очистить ввод"?
      ▪ clearOnEdit         | [false] Включить ли очистку ввода после фокусировки при редактировании?
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ debounce            | [0] Установить значение в ms - сколько ждать перед возбуждением ionChange после каждого нажатия клавиши
      ▪ disabled            | [false] Выключить ли пользователю возможность взаимодействовать с input'ом?
      ▪ inputmode           | Подсказка браузеру, какую клавиатуру показывать
      ▪ max                 | MAX значение, не меньше min
      ▪ maxlength           | MAX число символов, которые пользователь может ввести
      ▪ min                 | MAX значение, не больше max
      ▪ minlength           | MIN число символов, которые пользователь может ввести
      ▪ mode                | Если текущий режим отображения (ios или md) совпадает с указанной, элемент будет скрыт
      ▪ multiple            | [false] Может ли пользователь ввести более 1-го значения?
      ▪ name                | Имя для элемента, которое отправится, вместе с формой
      ▪ pattern             | Регулярное выражение для проверки значения
      ▪ placeholder         | Плейсхолдер
      ▪ readonly            | [false] Сделать ли input read only?
      ▪ required            | [false] Если true, пользователь должен обязательно заполнить input перед отправкой
      ▪ results             | Нестандартный атрибут для Safary, значение полож.десятич.integer
      ▪ size                | Стартовый размер элемента, "px" - если type=text,password, иначе в символах
      ▪ spellcheck          | [false] Проверять ли грамматически написанное?
      ▪ step                | Работает с min и max для установки min инкремента: "any" или любое полож.число с плавающей точкой
      ▪ type                | Тип input'а: text, password, email, number, search, tel, url.
      ▪ value               | Значение input'а

      ► ionBlur             | Возбуждается, когда input теряет фокус
      ► ionChange           | Возбуждается, когда значение изменилсь
      ► ionFocus            | Возбуждается, когда input получает фокус
      ► ionInputDidLoad     | Возбуждается при вводе с клавиатуры
      ► ionInputDidUnload   | Возбуждается после создания input'а
      ► ionStyle            | Возбуждается при изменении стилей

    # ion-item              | Item может содержать текст, иконки, аватары, картинки, инпуты, и другие нативные/кастомные эл-ты

      ▪ button              | [false] Сделать ли из item'а кнопку?
      ▪ detail              | [false (true для ios с присут.св-вом href,onclick или button)] Включить ли иконку с правой стрелкой?
      ▪ detailIcon          | [ios-arrow-forward] Какую иконку использовать, если detail == true?
      ▪ disabled            | [false] Запретить ли пользователю взаимодействовать с item'ом?
      ▪ lines               | Как отображать нижний border item'а?
      ▪ routerDirection     | При использовании роутера, указать направление анимации при переходе на др.страницу через href
      ▪ state               | Состояние???
      ▪ type                | Тип кнопки: submit, reset, button
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ href                | Содержит URL (или фрагмент), куда ведёт ссылка
      ▪ mode                | В каком режиме (md или ios) отображать alert

    # ion-item-divider      |

      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения

    # ion-item-group        | Контейнер для группировки похожих item'ов друг с другом
    # ion-item-option       | Option-кнопка для ion-item-sliding

      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ disabled            | Отключить ли item option?
      ▪ href                | Содержит URL (или фрагмент), куда ведёт ссылка
      ▪ expandable          | [false] Позволить ли option'у занять всю имеющуюся ширину?

    # ion-item-options      | Контейнер для option buttons для ion-item-sliding

      ▪ side                | [end] С какой стороны кнопки размещается слайд?
      
      • fireSwipeEvent()    | Возбудить событие ionSwipe
      • isEndSide()         | ???
      • width()             | Получить ширину

      ► ionSwipe            | Возбуждается, когда кнопка полностью свайпнута

    # ion-item-sliding      | Содержит item, который можно перетаскивать (drag), чтобы открыть option buttons

      • close()             | Закрыть sliding item (прикрыть опции)
      • closeOpened()       | Закрыть sliding item'ы в списке (прикрыть опции)
      • getOpenAmount()     | Узнать, насколько px приоткрыт sliding item
      • getSlidingRatio()   | Получить отношение открытости sliding item к ширине опций

      ► ionDrag             | Возбуждается, когда позиция слайдинга меняется
    
    # ion-label             | Обёртка для использования с item, input, toggle и т.д.
 
      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ position            | Настроить положение label'а в item'е: inline, fixed, stacked или floating

    # ion-list              | Списки состоят из многих строк с item'ами с текстом, кнопками, иконками, переключателям и т.д.

      ▪ inset               | [false] Включить ли margin для списка и круглыми углами.
      ▪ lines               | Как показывать нижний border на всех item'ах

      • closeSlidingItems() | Закрыть все открытые sliding items
      • getOpenItem()       | Получить sliding item, которые сейчас открыт
      • setOpenItem()       | Открыть sliding item

    # ion-list-header       | Header-компонент для списка (list)

      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения

    # ion-loading           | Панель загрузки поверх контента, блокирующая интерфейс, и показывающая, что идёт какой-то процесс

      ▪ content                 | Опциональный текст для показа в индикаторе загрузки
      ▪ cssClass                | Доп.классы с кастомным CSS, через пробел
      ▪ dismissOnPageChange     | [false] Выключить индикатор загрузки при смене страницы
      ▪ duration                | Задать кол-во ms после создания для автоматического выключения
      ▪ enableBackdropDismiss   | [false] Выключить индикатор загрузки при клике по фону
      ▪ enterAnimation          | Анимация появления
      ▪ keyboardClose           | Блурить ли input'ы при загрузке, и скрывать ли клавиатуру
      ▪ leaveAnimation          | Анимация закрытия
      ▪ overlayId               | Уникальный ID экземпляра (для внутреннего использования)
      ▪ showBackdrop            | [true] Показывать ли фон позади индикатора загрузки?
      ▪ spinner                 | Название спиннера: lines / lines-small / dots / bubbles / circles / crescent.
      ▪ translucent             | [false] Сделать ли индикатор загрузки полупрозрачным?
      ▪ willAnimate             | [true] Включить ли анимацию индикатора загрузки?

      • dismiss()               | Выключить индикатор загрузки
      • onDidDismiss()          | Получить промис, который резолвится после выключения индикатора загрузки
      • onWillDismiss()         | Получить промис, который резолвится перед выключением индикатора загрузки
      • present()               | Включить индикатор загрузки после того, как он был создан

      ► ionLoadingDidDismiss    | Emitted after the loading has dismissed
      ► ionLoadingDidLoad       | Emitted after the loading has loaded
      ► ionLoadingDidPresent    | Emitted after the loading has presented
      ► ionLoadingDidUnload     | Emitted after the loading has unloaded
      ► ionLoadingWillDismiss   | Emitted before the loading has dismissed
      ► ionLoadingWillPresent   | Emitted before the loading has presented

    # ion-menu              | Навигационное меню, которое слайдится с края экрана

      ▪ contentId           | ID content'а, которое должно использовать меню
      ▪ disabled            | [false] Выключено ли меню?
      ▪ maxEdgeStart        | Максимальный размер свайпа, при привышении которого меню не вылезет
      ▪ menuId              | ID для меню
      ▪ side                | [start] На какой стороне экрана надо разместить меню
      ▪ swipeEnabled        | [true] Включить доставание меню свайпом?
      ▪ type                | Режим отображения меню. Доступные опции: "overlay", "reveal", "push"

      • close()             | Закрыть меню
      • getWidth()          | Получить ширину меню
      • isActive()          | Активно ли меню?
      • isOpen()            | Раскрыто ли меню?
      • open()              | Раскрыть меню?
      • setOpen()           | ???
      • toggle()            | Переключить меню

      ► ionClose            | Возбуждается, когда меню закрыто
      ► ionMenuChange       | Возбуждается, когда состояние меню меняется
      ► ionOpen             | Возбуждается, когда меню открыто

    # ion-menu-button       | Автосоздание кнопки-иконки для закрытия/открытия меню на странице

      ▪ mode                | В каком режиме (md или ios) отображать alert
      ▪ color               | Какой использовать цвет из палитры цветов вашего приложения
      ▪ autoHide            | Автоматически прятать кнопку меню, если соотв.меню не активно
      ▪ menu                | Опциональное св-во для связывания с меню по menuId, м.б.: left, right

    # ion-menu-toggle       | Переключатель состояниям меню (открыто/закрыто)

      ▪ menu                | Опциональное св-во для связывания с меню по menuId, м.б.: start, end
      ▪ autoHide            | [true] Автоматически прятать контент, когда соотв.меню не активно

    # ion-modal             | Диалог поверх контента (полноэкранный), который должен быть завершён для продолжения работы с приложением

      ▪ component             | Какой компонент отображать внутри модалки
      ▪ componentProps        | Какие данные передать в компонент в модалки
      ▪ cssClass              | Доп.классы с кастомным CSS, через пробел
      ▪ delegate              |
      ▪ enableBackdropDismiss | [false] Выключить модалку при клике по фону
      ▪ enterAnimation        | Анимация появления
      ▪ keyboardClose         | Блурить ли input'ы при загрузке, и скрывать ли клавиатуру
      ▪ leaveAnimation        | Анимация закрытия
      ▪ overlayId             | Уникальный ID экземпляра (для внутреннего использования)
      ▪ showBackdrop          | [true] Показывать ли фон позади модалки?
      ▪ willAnimate           | [true] Включить ли анимацию модалки?

      • dismiss()           | Удалить модалку
      • onDidDismiss()      | Возвращает промис, который резолвится после закрытия модалки; принимает callback
      • onWillDismiss()     | Возвращает промис, который резолвится перед закрытием модалки; принимает callback
      • present()           | Показать модалку после того, как она была создана

      ► ionModalDidDismiss  | Emitted after the modal has dismissed.
      ► ionModalDidLoad     | Emitted after the modal has loaded.
      ► ionModalDidPresent  | Emitted after the modal has presented.
      ► ionModalDidUnload   | Emitted after the modal has unloaded.
      ► ionModalWillDismiss | Emitted before the modal has dismissed.
      ► ionModalWillPresent | Emitted before the modal has presented.

    # ion-nav               | Отдельный компонент для загрузки произвольных компонентов и добавления в отдельный стек

      ▪ animated            | Должен ли nav анимировать компоненты, или нет?
      ▪ delegate            | 
      ▪ root                | Корневой компонент, куда грузить Nav
      ▪ rootParams          | Параметры для передачи root-компоненту
      ▪ swipeBackEnabled    | Включить ли swipe-to-go-back?

    # ion-nav-pop           |
    # ion-nav-push          |
    # ion-nav-set-root      |
    # ion-note              |
    # ion-picker            |
    # ion-picker-column     |
    # ion-popover           |
    
    # ion-radio             |
    # ion-radio-group       |
    # ion-range             |
    # ion-range-knob        |
    # ion-refresher         |
    # ion-reorder           |
    # ion-reorder-group     |
    # ion-ripple-effect     |
    # ion-route             |
    # ion-route-redirect    |
    # ion-router            |
    # ion-router-outlet     |
    # ion-scroll            |
    # ion-searchbar         |
    # ion-segment           |
    # ion-segment-button    |
    # ion-select            |
    # ion-select-option     |
    # ion-select-popover    |
    # ion-show-when         |
    # ion-skeleton-text     |
    # ion-slide             |
    # ion-slides            |
    # ion-spinner           |
    # ion-split-pane        |

    # ion-tab               |
    # ion-tab-button        |
    # ion-tabbar            |
    # ion-tabs              |

    # ion-text              |
    # ion-textarea          |
    # ion-thumbnail         |
    # ion-title             |
    # ion-toast             |
    # ion-toggle            |
    # ion-toolbar           |
    # ion-virtual-scroll    |

  Programmatic API

    # ion-action-sheet-controller   | Программный контроль над компонентом action sheet

      • create()                    | Создать Action Sheet, передав опции
      • dismiss()                   | Закрыть Action Sheet
      • getTop()                    | Получить самый недавний Action Sheet

    # ion-alert-controller          | Программный контроль над компонентом alert

      • create()                    | Создать Alert, передав опции
      • dismiss()                   | Закрыть Alert
      • getTop()                    | Получить самый недавний Alert

    # ion-animation-controller      | Используется для создания экземпляра анимации

      • create()                    | Создать экземпляр анимации

    # ion-loading-controller        | Используется для контроля над компонентом loading

      • create()                    | Создать экран загрузки, передав конфиг с опциями
      • dismiss()                   | Уничтожить экран загрузки
      • getTop()                    | Получить самый недавний экран загрузки

    # ion-menu-controller           | 

      ▪ _register()                 |
      ▪ _setActiveMenu()            |
      ▪ _setOpen()                  |
      ▪ _unregister()               |
      ▪ close()                     | Закрыть либо указанное меню, либо все открытые
      ▪ createAnimation()           |
      ▪ enable()                    | Включить меню (и выключить все прочие на этой side)
      ▪ get()                       | Получить указанное меню, или первое попавшееся, или включенное на указанной side; вернёт null если не найдено
      ▪ getMenus()                  | Получить массив всех меню
      ▪ getOpen()                   | Получить открытое меню, иначе вернёт null
      ▪ isAnimating()               | Вернёт true, если сейчас работает анимация любого из меню
      ▪ isEnabled()                 | Вернёт true, если указанное меню включено
      ▪ isOpen()                    | Вернёт true, либо если указаннное меню открыто, либо если любое меню открыто
      ▪ open()                      | Открыть меню
      ▪ registerAnimation()         |
      ▪ swipeEnable()               | Вкл/Выкл возможность открывать/закрывать меню свайпом
      ▪ toggle()                    | Переключить меню, если открыто - закрыть, и наоборот

    # ion-modal-controller          | Программно контролирует компоненты modal

      ▪ create()                    | Создать модалку, передав конфиг с опциями
      ▪ dismiss()                   | Удалить модалку
      ▪ getTop()                    | Получить последнюю открытую модалку

    # ion-picker-controller         | 
    # ion-popover-controller        | 
    # ion-refresher-content         | 
    # ion-toast-controller          | 

--------------------------------------

> ion-action-sheet

  Fullscreen-модалка о списком действий поверх контента.

  ▪ Описание

    Action Sheet является диалогом, который отображает набор
    опций. Оно появляется поверх контента приложения, и 
    должно быть закрыто вручную пользователем, прежде чем
    он сможет продолжить взаимодействие с пользователем.

    Есть несколько способов закрыть окно, в том числе кликнуть
    фон или нажать esc на desctop.

    ▪ Создание

      Action Sheet можно создать с помощью Action Sheet Controller,
      из массива buttons, в котором каждая кнопка имеет text, 
      handler и role. 

      Если обработчик возвращает false, то Action Sheet не будет
      закрыт.

      Опционально, Action Sheet может иметь title, subTitle и
      Icon.

    ▪ Особенности Buttons

      В качестве значения role для button могут быть также
      destructive или cancel. 

      Кнопки без определённого значения для role будут иметь
      вид по умолчанию для платформы.

      Кнопки с ролью cancel будут всегда отображаться в самом
      низу, вне зависимости от своего расположения в массиве.

      Все остальные кнопки, будут отображаться в том порядке,
      в котором они появляются в массиве buttons.

      Авторы рекомендуют размещать кнопку с ролью distructive
      в самом верху массива buttons.

      При закрытии Action Sheet путём тапа по фону, будет
      вызван обработчик кнопки с ролью cancel.

  ▪ Использование

    async function presentActionSheet() {
      const actionSheetController = document.querySelector('ion-action-sheet-controller');
      await actionSheetController.componentOnReady();

      const actionSheet = await actionSheetController.create({
        header: "Albums",
        buttons: [{
          text: 'Delete',
          role: 'destructive',
          icon: 'trash',
          handler: () => {
            console.log('Delete clicked');
          }
        }, {
          text: 'Share',
          icon: 'share',
          handler: () => {
            console.log('Share clicked');
          }
        }, {
          text: 'Play (open modal)',
          icon: 'arrow-dropright-circle',
          handler: () => {
            console.log('Play clicked');
          }
        }, {
          text: 'Favorite',
          icon: 'heart',
          handler: () => {
            console.log('Favorite clicked');
          }
        }, {
          text: 'Cancel',
          icon: 'close',
          role: 'cancel',
          handler: () => {
            console.log('Cancel clicked');
          }
        }]
      });
      await actionSheet.present();
    }  

  ▪ Свойства

    ▪ buttons
      - Массив кнопок для Action Sheet.
      - Атрибуты:

        ▪ buttons

      - Тип: ActionSheetButton[]

    ▪ cssClass
      - Какие доп.классы применить. Если их > 1, надо разделять пробелами.
      - Атрибуты:

        ▪ css-class

      - Тип: string

    ▪ enableBackdropDismiss
      - [true] Если true, Action Sheet можно будет закрыть кликом по фону.
      - Атрибуты:

        ▪ enable-backdrop-dismiss

      - Тип: boolean

    ▪ enterAnimation
      - Анимация появления Action Sheet.
      - Атрибуты:

        ▪ enter-animation

      - Тип: AnimationBuilder

    ▪ header
      - Заголовок для Action Sheet.
      - Атрибуты:

        ▪ header

      - Тип: string

    ▪ keyboardClose
      - Должен ли Action Sheet закрыть клавиатуру.
      - Атрибуты:

        ▪ keyboard-close

      - Тип: boolean

    ▪ leaveAnimation
      - Анимация закрытия Action Sheet.
      - Атрибуты:

        ▪ leave-animation

      - Тип: AnimationBuilder

    ▪ overlayId
      - Уникальный ID экземпляра Action Sheet (для внутреннего использования).
      - Атрибуты:

        ▪ overlay-id

      - Тип: number

    ▪ subHeader
      - Подзаголовок для Action Sheet.
      - Атрибуты:

        ▪ sub-header

      - Тип: string

    ▪ translucent
      - [false] Включить ли полупрозрачность для Action Sheet.
      - Атрибуты:

        ▪ translucent

      - Тип: boolean

    ▪ willAnimate
      - [true] Анимировать ли Action Sheet.
      - Атрибуты:

        ▪ will-animate

      - Тип: boolean

  ▪ Методы

    ▪ dismiss()       | Закрыть Action Sheet
    ▪ onDidDismiss()  | Вернуть промис, резолвящийся после закрытия Action Sheet (можно передать callback)
    ▪ onWillDismiss() | Вернуть промис, резолвящийся перед закрытием Action Sheet (можно передать callback)
    ▪ present()       | Показать Action Sheet

  ▪ События

    ▪ ionActionSheetDidDismiss  | Возбуждается после закрытия action sheet
    ▪ ionActionSheetDidLoad     | Возбуждается после загрузки action sheet
    ▪ ionActionSheetDidPresent  | Возбуждается после представления action sheet
    ▪ ionActionSheetDidUnload   | Возбуждается после выгрузки action sheet
    ▪ ionActionSheetWillDismiss | Возбуждается перед закрытием action sheet
    ▪ ionActionSheetWillPresent | Возбуждается перед представлением action sheet

> ion-alert

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

    Alert является диалогом, который предоставляет пользователью
    какую-то информацию, и/или собирает информацию у пользователя.

    Alert появляется поверх контента приложения, и должен 
    быть вручную уничтожен пользователем, прежде чем он
    сможет продолжить взаимодействие с приложение.

    Опционально, Alert может иметь title, subTitle и message.

    ▪ Создание

      Alert'ы можно создавать с помощью Alert Controller.
      Кастомизировать alert'ы можно, передавая параметры
      в метод "create" контроллера.

    ▪ Buttons

      В массиве buttons, каждая кнопка имеет свойства text,
      и (опционально) handler. 

      Если handler возвращает false, то alert НЕ закроется
      автоматически после нажатия на кнопку.

      Все кнопки будут отображаться в том же порядке, в каком
      они были добавлены в массив buttons, слева-направо.

      Самая правая (последняя) кнопка является главной.

      Опционально, кнопке можно добавить свойство role,
      значением может быть, например, cancel.

      Если role со значением cancel назначена одной из
      кнопок, то при закрытии alert путём нажания на 
      фон, будет вызван handler от этой кнопки.

    ▪ Inputs

      Alert'ы могут также включать различные input'ы, 
      через которые можно собирать различными способами
      данные у пользователя, которые передавать обратно
      в приложение.

      Radio's, checkboxes и text'овые input'ы использовать
      можно, но их нельзя смешивать в одном alert'е.
      Например, alert может состоять целиком из radio
      button'ов, или целиком из checkbox'ов, но он не
      может одновременно содержать и те, и другие.

      Однако, различные виды тестовых input'ов могут 
      быть смешаны. Например, таких как url, email,
      text, и т.д. 

      Если вам нужна сложная форма, которая не вписывается
      в ограничения alert, то рекомендуем вам собрать
      форму на modal, а не на alert.

  ▪ Использование

    async function presentAlert() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Alert',
        subHeader: 'Subtitle',
        message: 'This is an alert message.',
        buttons: ['OK']
      });
      return await alert.present();
    }

    async function presentAlertMultipleButtons() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Alert',
        subHeader: 'Subtitle',
        message: 'This is an alert message.',
        buttons: ['Cancel', 'Open Modal', 'Delete']
      });
      return await alert.present();
    }

    async function presentAlertConfirm() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Confirm!',
        message: 'Message <strong>text</strong>!!!',
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: (blah) => {
              console.log('Confirm Cancel: blah');
            }
          }, {
            text: 'Okay',
            handler: () => {
              console.log('Confirm Okay')
            }
          }
        ]
      });
      return await alert.present();
    }

    async function presentAlertPrompt() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Prompt!',
        inputs: [
          {
            placeholder: 'Placeholder 1'
          },
          {
            name: 'name2',
            id: 'name2-id',
            value: 'hello',
            placeholder: 'Placeholder 2'
          },
          {
            name: 'name3',
            value: 'http://ionicframework.com',
            type: 'url',
            placeholder: 'Favorite site ever'
          },
          // input date with min & max
          {
            name: 'name4',
            type: 'date',
            min: '2017-03-01',
            max: '2018-01-12'
          },
          // input date without min nor max
          {
            name: 'name5',
            type: 'date'
          },
          {
            name: 'name6',
            type: 'number',
            min: -5,
            max: 10
          },
          {
            name: 'name7',
            type: 'number'
          }
        ],
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {
              console.log('Confirm Cancel')
            }
          }, {
            text: 'Ok',
            handler: () => {
              console.log('Confirm Ok')
            }
          }
        ]
      });
      return await alert.present();
    }

    async function presentAlertRadio() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Radio',
        inputs: [
          {
            type: 'radio',
            label: 'Radio 1',
            value: 'value1',
            checked: true
          },
          {
            type: 'radio',
            label: 'Radio 2',
            value: 'value2'
          },
          {
            type: 'radio',
            label: 'Radio 3',
            value: 'value3'
          },
          {
            type: 'radio',
            label: 'Radio 4',
            value: 'value4'
          },
          {
            type: 'radio',
            label: 'Radio 5',
            value: 'value5'
          },
          {
            type: 'radio',
            label: 'Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 ',
            value: 'value6'
          }
        ],
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {
              console.log('Confirm Cancel')
            }
          }, {
            text: 'Ok',
            handler: () => {
              console.log('Confirm Ok')
            }
          }
        ]
      });
      return await alert.present();
    }

    async function presentAlertCheckbox() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Checkbox',
        inputs: [
          {
            type: 'checkbox',
            label: 'Checkbox 1',
            value: 'value1',
            checked: true
          },

          {
            type: 'checkbox',
            label: 'Checkbox 2',
            value: 'value2'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 3',
            value: 'value3'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 4',
            value: 'value4'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 5',
            value: 'value5'
          },

          {
            type: 'checkbox',
            label: 'Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6',
            value: 'value6'
          }
        ],
        buttons: [
          {
            text: 'Cancel',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {
              console.log('Confirm Cancel')
            }
          }, {
            text: 'Ok',
            handler: () => {
              console.log('Confirm Ok')
            }
          }
        ]
      });
      return await alert.present();
    }

  ▪ Свойства

    ▪ buttons 
      - Массив кнопок для Alert.
      - Атрибуты:

        ▪ buttons

      - Тип: (AlertButton | string)[]

    ▪ cssClass 
      - Какие доп.классы применить. Если их > 1, надо разделять пробелами.
      - Атрибуты:

        ▪ css-class

      - Тип: string
              
    ▪ enableBackdropDismiss 
      - [true] Если true, Action Sheet можно будет закрыть кликом по фону.
      - Атрибуты:  

        ▪ enable-backdrop-dismiss
              
      - Тип: boolean
 
    ▪ enterAnimation 
      - Анимация появления Action Sheet.
      - Атрибуты: 

        ▪ enter-animation
               
      - Тип: AnimationBuilder
                
    ▪ keyboardClose 
      - Включить ли блур input'ов при загрузки и скрытие клавиатуры?
      - Атрибуты: 

        ▪ keyboard-close
               
      - Тип: boolean
         
    ▪ leaveAnimation 
      - Анимация закрытия Action Sheet.
      - Атрибуты: 

        ▪ leave-animation
               
      - Тип: AnimationBuilder
        
    ▪ message 
      - Главное сообщение для показа в alert.
      - Атрибуты: 

        ▪ message
               
      - Тип: string
               
    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string
                  
    ▪ overlayId 
      - Уникальный ID экземпляра Alert (для внутреннего использования).
      - Атрибуты: 

        ▪ overlay-id
               
      - Тип: number
             
    ▪ subHeader 
      - Подзаголовок для Action Sheet.
      - Атрибуты: 

        ▪ sub-header
               
      - Тип: string
             
    ▪ translucent 
      - [false] Включить ли полупрозрачность для Action Sheet.
      - Атрибуты: 

        ▪ translucent
               
      - Тип: boolean
           
    ▪ willAnimate 
      - [true] Анимировать ли Action Sheet.
      - Атрибуты: 

        ▪ will-animate
               
      - Тип: boolean
      
  ▪ Методы

    ▪ dismiss()           | Закрыть Alert
    ▪ onDidDismiss()      | Вернуть промис, резолвящийся после закрытия Alert (можно передать callback)
    ▪ onWillDismiss()     | Вернуть промис, резолвящийся перед закрытием Alert (можно передать callback)
    ▪ present()           | Показать Alert

  ▪ События

    ▪ ionAlertDidDismiss  | Возбуждается после закрытия alert
    ▪ ionAlertDidLoad     | Возбуждается после загрузки alert
    ▪ ionAlertDidPresent  | Возбуждается после представления alert
    ▪ ionAlertDidUnload   | Возбуждается после выгрузки alert
    ▪ ionAlertWillDismiss | Возбуждается перед закрытием alert
    ▪ ionAlertWillPresent | Возбуждается перед представлением alert 

> ion-anchor     

  Используется для перехода к указанной ссылке.

  ▪ Описание

    Как и аналогичный тег в браузере, у него есть свойство
    href для передачи локации, и direction - чтобы задать
    направление анимации.

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения. 
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ href 
      - Содержит URL (или фрагмент), куда ведёт ссылка.
        Если это значение задано, anchor-тэг будет отрисован.
      - Атрибуты: 

        ▪ href
               
      - Тип: string

    ▪ routerDirection 
      - При использовании роутера, указать направление анимации при переходе на др.страницу через href.
      - Атрибуты: 

        ▪ router-direction
               
      - Тип: string            

> ion-app        

  Элемент-контейнер для Ionic-приложения.

  ▪ Описание

    Во всём проекте должен быть лишь 1-ин элемент <ion-app>.
    Внутри может быть много Ionic-компонентов, включая
    menus, headers, content, footers. Overlay-компоненты
    прикрепляются к <ion-app> при их показе.

> ion-avatar     

  Круговой компонент, оборачивающий изображение или иконку.

  ▪ Описание

    Его можно использовать, чтобы представлять человека 
    или объект.

    Avatar можно использовать как самостоятельно, так и 
    внутри другого элемента.

    При размерещиня avatar внутри <ion-chip> или <ion-item>,
    avatar подстроит свои размеры под размер родительского
    компонента.

    Чтобы отпозиционировать аватар в левой или в правой части
    item'а, установите slot на start или end соответственно
    (см.пример ниже).

  ▪ Использование

    <ion-avatar>
      <img src="https://gravatar.com/avatar/dba6bae8c566f9d4041fb9cd9ada7741?d=identicon&f=y">
    </ion-avatar>

    <ion-chip>
      <ion-avatar>
        <img src="https://gravatar.com/avatar/dba6bae8c566f9d4041fb9cd9ada7741?d=identicon&f=y">
      </ion-avatar>
      <ion-label>Chip Avatar</ion-label>
    </ion-chip>

    <ion-item>
      <ion-avatar slot="start">
        <img src="https://gravatar.com/avatar/dba6bae8c566f9d4041fb9cd9ada7741?d=identicon&f=y">
      </ion-avatar>
      <ion-label>Item Avatar</ion-label>
    </ion-item>

> ion-back-button

  Кнопка "назад" для перехода на 1 шаг назад по истории приложения.

  ▪ Описание

    Она достаточно умна, чтобы знать, что отрисовывать, 
    основываясь на mode, и когда отображаться, основываясь
    на навигационном стеке.

    Чтоби изменить надпись на back button, используйте
    свойства text и icon.

  ▪ Использование

    <!-- Default back button -->
    <ion-header>
      <ion-toolbar>
        <ion-buttons slot="start">
          <ion-back-button></ion-back-button>
        </ion-buttons>
      </ion-toolbar>
    </ion-header>

    <!-- Back button with a default href -->
    <ion-header>
      <ion-toolbar>
        <ion-buttons slot="start">
          <ion-back-button default-href="home"></ion-back-button>
        </ion-buttons>
      </ion-toolbar>
    </ion-header>

    <!-- Back button with custom text and icon -->
    <ion-header>
      <ion-toolbar>
        <ion-buttons slot="start">
          <ion-back-button text="Volver" icon="close"></ion-back-button>
        </ion-buttons>
      </ion-toolbar>
    </ion-header>

    <!-- Back button with no text and custom icon -->
    <ion-header>
      <ion-toolbar>
        <ion-buttons slot="start">
          <ion-back-button text="" icon="add"></ion-back-button>
        </ion-buttons>
      </ion-toolbar>
    </ion-header>

    <!-- Danger back button next to a menu button -->
    <ion-header>
      <ion-toolbar>
        <ion-buttons slot="start">
          <ion-menu-button></ion-menu-button>
          <ion-back-button color="danger"></ion-back-button>
        </ion-buttons>
      </ion-toolbar>
    </ion-header>

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения. 
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ defaultHref 
      - URL по умолчанию для навигации "назад", когда в стеке истории уже пусто.
      - Атрибуты: 

        ▪ default-href
               
      - Тип: string 

    ▪ icon 
      - Какую иконку (имя) использовать для back button.
      - Атрибуты: 

        ▪ icon
               
      - Тип: string 

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string 

    ▪ text 
      - Какой текст показывать на кнопке.
      - Атрибуты: 

        ▪ text
               
      - Тип: string                         

> ion-backdrop

  Fullscreen-компонент, перекрывающий другие компоненты.

  ▪ Описание

    Полезен позади компонентов, которые transition'ятся
    на передний план перед прочим контентом, и может
    быть использован для закрытия этого компонента.

  ▪ Использование

    HTML:

      <!-- Default backdrop -->
      <ion-backdrop></ion-backdrop>

      <!-- Backdrop that is not tappable -->
      <ion-backdrop tappable="false"></ion-backdrop>

      <!-- Backdrop that is not visible -->
      <ion-backdrop visible="false"></ion-backdrop>

      <!-- Backdrop with propagation -->
      <ion-backdrop stop-propagation="false"></ion-backdrop>

      <!-- Backdrop that sets dynamic properties -->
      <ion-backdrop id="customBackdrop"></ion-backdrop>

    JS:

      var backdrop = document.getElementById('customBackdrop');
      backdrop.visible = false;
      backdrop.tappable = false;
      backdrop.stopPropagation = false;

  ▪ Свойства

    ▪ stopPropagation 
      - [true] Останавливать ли всплытие события при тапе на backdrop?
      - Атрибуты: 

        ▪ stop-propagation
               
      - Тип: boolean 

    ▪ tappable 
      - [true] Возбуждать ли при клике/тапе по backdrop событие ionBackdropTap?
      - Атрибуты: 

        ▪ tappable
               
      - Тип: boolean 

    ▪ visible 
      - [true] Видим ли backdrop?
      - Атрибуты: 

        ▪ visible
               
      - Тип: boolean             

  ▪ События

    ▪ ionBackdropTap  | Возбуждается при клике/тапе по backdrop

> ion-badge 

  Inline-block элемент, который обычно возникает рядом с другим элементом.

  ▪ Описание

    Часто, badge содержит внутри какой-то текст или цифры.
    Часто badge используют в качестве уведомления о том,
    что появились дополнительные элементы, связанные с 
    элементом, и показывать, как много их появилось.

  ▪ Использование

    <!-- Default -->
    <ion-badge>99</ion-badge>

    <!-- Colors -->
    <ion-badge color="primary">11</ion-badge>
    <ion-badge color="secondary">22</ion-badge>
    <ion-badge color="tertiary">33</ion-badge>
    <ion-badge color="success">44</ion-badge>
    <ion-badge color="warning">55</ion-badge>
    <ion-badge color="danger">66</ion-badge>
    <ion-badge color="light">77</ion-badge>
    <ion-badge color="medium">88</ion-badge>
    <ion-badge color="dark">99</ion-badge>

    <!-- Item with badge on left and right -->
    <ion-item>
      <ion-badge slot="start">11</ion-badge>
      <ion-label>My Item</ion-label>
      <ion-badge slot="end">22</ion-badge>
    </ion-item>

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string    

> ion-button 

  Кликабельный элемент "кнопка"

  ▪ Описание

    Может использоваться как в формах, так и где угодно,
    где требуется простая, стандартная кнопка.

    На кнопке может быть текст, иконки, или и то, и другое.
    Стили кнопки можно изменять несколькими атрибутами (см.ниже).

    ▪ Атрибут expand

      Этот атрибут позволяет вам определять, насколько
      широкой должна быть кнопка.

      По умолчанию, кнопки являются inline-blocks, но
      установка значения для этого атрибута сделает из них
      blocks со 100% шириной.

      Возможные значения:

        ▪ block   | Full-width button с закруглёнными краями
        ▪ full    | Full-width button с квадратными краями и без border слева/справа

    ▪ Атрибут fill

      Этот атрибут определяет цвет background'а и border'а
      кнопки. По умолчанию, button имеет solid background,
      кроме случая, когда кнопка внутри toolbar'а - в этом
      случае, background прозрачный.

      Возможные значения:

        ▪ clear     | кнопка с прозрачным фоном, походит на flat-кнопку
        ▪ outline   | кнопка с прозрачным фоном и видимыми border'ами
        ▪ solid     | кнопка с непрозрачным фоном, полезно для кнопок в toolbar'ах

    ▪ Атрибут size

      Этот атрибут определяет размер кнопки. Установка этого
      атрибута изменит высоту и padding кнопки.

      Возможные значения:

        ▪ small     | мелкая кнопка, малые size и padding (по умолчанию для кнопок в item)
        ▪ default   | средняя кнопка, средние size и padding (полезно для кнопок в item)
        ▪ large     | большая кнопка, большие size и padding

  ▪ Использование

    <!-- Default -->
    <ion-button>Default</ion-button>

    <!-- Anchor -->
    <ion-button href="#">Anchor</ion-button>

    <!-- Anchor with backwards transition -->
    <ion-button href="/" go-back>Backwards Anchor</ion-button>

    <!-- Colors -->
    <ion-button color="primary">Primary</ion-button>
    <ion-button color="secondary">Secondary</ion-button>
    <ion-button color="tertiary">Tertiary</ion-button>
    <ion-button color="success">Success</ion-button>
    <ion-button color="warning">Warning</ion-button>
    <ion-button color="danger">Danger</ion-button>
    <ion-button color="light">Light</ion-button>
    <ion-button color="medium">Medium</ion-button>
    <ion-button color="dark">Dark</ion-button>

    <!-- Expand -->
    <ion-button expand="full">Full Button</ion-button>
    <ion-button expand="block">Block Button</ion-button>

    <!-- Round -->
    <ion-button round>Round Button</ion-button>

    <!-- Fill -->
    <ion-button expand="full" fill="outline">Outline + Full</ion-button>
    <ion-button expand="block" fill="outline">Outline + Block</ion-button>
    <ion-button round fill="outline">Outline + Round</ion-button>

    <!-- Icons -->
    <ion-button>
      <ion-icon slot="start" name="star"></ion-icon>
      Left Icon
    </ion-button>

    <ion-button>
      Right Icon
      <ion-icon slot="end" name="star"></ion-icon>
    </ion-button>

    <ion-button>
      <ion-icon slot="icon-only" name="star"></ion-icon>
    </ion-button>

    <!-- Sizes -->
    <ion-button size="large">Large</ion-button>
    <ion-button>Default</ion-button>
    <ion-button size="small">Small</ion-button>

  ▪ Свойства

    ▪ buttonType 
      - Тип кнопки: "button", "bar-button"
      - Атрибуты: 

        ▪ button-type
               
      - Тип: string   

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ disabled 
      - [false] Отключить ли кнопку (на неё нельзя нажать)?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean   

    ▪ expand 
      - Делает кнопке block вместо inline-block, т.е. full-width: "block" (с border'ами справа/слева), "full" (без border'ов справа/слева)
      - Атрибуты: 

        ▪ expand
               
      - Тип: string   

    ▪ fill 
      - [clear] "Clear" - прозрачный фон и границы; "outline" - прозрачный фон, границы видны; "solid" - непрозрачный фон и границы.
      - Атрибуты: 

        ▪ fill
               
      - Тип: string   

    ▪ href 
      - Содержит URL (или фрагмент), куда ведёт ссылка.
        Если это значение задано, anchor-тэг будет отрисован.
      - Атрибуты: 

        ▪ href
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string   

    ▪ routerDirection 
      - При использовании роутера, указать направление анимации при переходе на др.страницу через href.
      - Атрибуты: 

        ▪ router-direction
               
      - Тип: string     

    ▪ shape 
      - Форма кнопки, возможные значения: "round"
      - Атрибуты: 

        ▪ shape
               
      - Тип: string   

    ▪ size 
      - Размер кнопки. Значения: "small", "default", "large".
      - Атрибуты: 

        ▪ size
               
      - Тип: string

    ▪ strong 
      - [false] Включить ли для кнопки более жирный шрифт?
      - Атрибуты: 

        ▪ strong
               
      - Тип: boolean

    ▪ type 
      - [button] Тип кнопки. Значения: "submit", "reset", "button"
      - Атрибуты: 

        ▪ type
               
      - Тип: string

  ▪ События

    ▪ ionBlur   | Возбуждается, когда кнопка теряет фокус
    ▪ ionFocus  | Возбуждается, когда кнопка получает фокус

> ion-buttons     

  Компонент-контейнер для элементов button.

  ▪ Описание

    Кнопки в toolbar обязательно должны размещаться внутри
    блока <ion-buttons>.

    Элемент <ion-buttons> можно размещать внутри toolbar'а
    с помощью slot'ов. Ниже описание каждого слота:

    ▪ secondary

      Размещает элемент слева от контента в ios-mode, 
      и прям справа от контента в md-mode.

    ▪ primary

      Размещает элемент справа от контента в ios-mode,
      и далеко справа в md-mode.

    ▪ start

      Размещает элемент слева от контента в LTR,
      и справа в RTL.

    ▪ end

      Размещает элемент справа от контента в LTR,
      и слева в RTL.

  ▪ Использование

    <ion-toolbar>
      <ion-buttons slot="start">
        <ion-back-button></ion-back-button>
      </ion-buttons>
      <ion-title>Back Button</ion-title>
    </ion-toolbar>

    <ion-toolbar>
      <ion-buttons slot="secondary">
        <ion-button>
          <ion-icon slot="icon-only" name="contact"></ion-icon>
        </ion-button>
        <ion-button>
          <ion-icon slot="icon-only" name="search"></ion-icon>
        </ion-button>
      </ion-buttons>
      <ion-title>Default Buttons</ion-title>
      <ion-buttons slot="primary">
        <ion-button color="secondary">
          <ion-icon slot="icon-only" name="more"></ion-icon>
        </ion-button>
      </ion-buttons>
    </ion-toolbar>

    <ion-toolbar>
      <ion-buttons slot="primary">
        <ion-button onclick="clickedStar()">
          <ion-icon slot="icon-only" name="star"></ion-icon>
        </ion-button>
      </ion-buttons>
      <ion-title>Right side menu toggle</ion-title>
      <ion-buttons slot="end">
        <ion-menu-toggle auto-hide="false">
          <ion-button>
            <ion-icon slot="icon-only" name="menu"></ion-icon>
          </ion-button>
        </ion-menu-toggle>
      </ion-buttons>
    </ion-toolbar>  

> ion-card         

  Карточки, стандартный элемент UI для размещения контента.

  ▪ Описание

    Карточка часто содержит header, title, subtitle и content.
    <ion-card> разбита на несколько компонентов, чтобы это
    отразить. См.:

    ▪ ion-card-content
    ▪ ion-card-header
    ▪ ion-card-title
    ▪ ion-card-subtitle

  ▪ Использование

    <ion-card>
      <ion-card-header>
        <ion-card-subtitle>Card Subtitle</ion-card-subtitle>
        <ion-card-title>Card Title</ion-card-title>
      </ion-card-header>

      <ion-card-content>
        Keep close to Nature's heart... and break clear away, once in awhile,
        and climb a mountain or spend a week in the woods. Wash your spirit clean.
      </ion-card-content>
    </ion-card>

    <ion-card>
      <ion-item>
        <ion-icon name="pin" slot="start"></ion-icon>
        <ion-label>ion-item in a card, icon left, button right</ion-label>
        <ion-button fill="outline" slot="end">View</ion-button>
      </ion-item>

      <ion-card-content>
        This is content, without any paragraph or header tags,
        within an ion-card-content element.
      </ion-card-content>
    </ion-card>

    <ion-card>
      <ion-item href="#" class="activated">
        <ion-icon name="wifi" slot="start"></ion-icon>
        <ion-label>Card Link Item 1 .activated</ion-label>
      </ion-item>

      <ion-item href="#">
        <ion-icon name="wine" slot="start"></ion-icon>
        <ion-label>Card Link Item 2</ion-label>
      </ion-item>

      <ion-item class="activated">
        <ion-icon name="warning" slot="start"></ion-icon>
        <ion-label>Card Button Item 1 .activated</ion-label>
      </ion-item>

      <ion-item>
        <ion-icon name="walk" slot="start"></ion-icon>
        <ion-label>Card Button Item 2</ion-label>
      </ion-item>
    </ion-card>

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string   

> ion-card-content 

  Дочерний для ion-card компонент для контента.

  ▪ Описание

    Рекомендуется размещать в ion-card-content текстовый
    контент.

  ▪ Свойства

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string   

> ion-card-header  

  Дочерний для ion-card компонент для header'а.

  ▪ Свойства

    ▪ translucent
      - [false] Включить ли полупрозрачность.
      - Атрибуты:

        ▪ translucent

      - Тип: boolean

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string  

> ion-card-subtitle

  Дочерний для ion-card компонент для подзаголовка.

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

> ion-card-title   

  Дочерний для ion-card компонент для заголовка.

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

> ion-checkbox

  Компонент-чекбокс.

  ▪ Описание

    Чекбоксы позволяют пользователю осуществлять выбор
    одновременно нескольких опций. 

    Клик по чекбоксу приводит к переключению значения
    свойства checked. Его значение также можно изменить
    программно через одноименное свойство.

  ▪ Использование

    <!-- Default Checkbox -->
    <ion-checkbox></ion-checkbox>

    <!-- Disabled Checkbox -->
    <ion-checkbox disabled></ion-checkbox>

    <!-- Checked Checkbox -->
    <ion-checkbox checked></ion-checkbox>

    <!-- Checkbox Colors -->
    <ion-checkbox color="primary"></ion-checkbox>
    <ion-checkbox color="secondary"></ion-checkbox>
    <ion-checkbox color="danger"></ion-checkbox>
    <ion-checkbox color="light"></ion-checkbox>
    <ion-checkbox color="dark"></ion-checkbox>

    <!-- Checkboxes in a List -->
    <ion-list>
      <ion-item>
        <ion-label>Pepperoni</ion-label>
        <ion-checkbox slot="end" value="pepperoni" checked></ion-checkbox>
      </ion-item>

      <ion-item>
        <ion-label>Sausage</ion-label>
        <ion-checkbox slot="end" value="sausage" disabled></ion-checkbox>
      </ion-item>

      <ion-item>
        <ion-label>Mushrooms</ion-label>
        <ion-checkbox slot="end" value="mushrooms"></ion-checkbox>
      </ion-item>
    </ion-list>

  ▪ Свойства

    ▪ checked 
      - [false] Включён ли чекбокс?
      - Атрибуты: 

        ▪ checked
               
      - Тип: boolean  

    ▪ disabled 
      - [false] Отключить ли чекбокс (на него нельзя нажать)?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean   

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ name 
      - Имя для чекбокса, которое отправится вместе с form data.
      - Атрибуты: 

        ▪ name
               
      - Тип: string

    ▪ value 
      - Значение чекбокса.
      - Атрибуты: 

        ▪ value
               
      - Тип: string      

  ▪ События

    ▪ ionBlur     | Возбуждается при потере фокуса чекбоксом
    ▪ ionChange   | Возбуждается при переключении значения чекбокса
    ▪ ionFocus    | Возбуждается при получении фокуса чекбоксом
    ▪ ionStyle    | Возбуждается при изменении styles

> ion-chip       

  Сложные сущности в небольших блоках, как контакт.

  ▪ Описание

    Chip может содержать несколько разных элементов, 
    таких как avatar, text, buttons и icons.

  ▪ Использование

    <ion-chip>
      <ion-label>Default</ion-label>
    </ion-chip>

    <ion-chip>
      <ion-label color="secondary">Secondary Label</ion-label>
    </ion-chip>

    <ion-chip color="secondary">
      <ion-label color="dark">Secondary w/ Dark label</ion-label>
    </ion-chip>

    <ion-chip>
      <ion-icon name="pin"></ion-icon>
      <ion-label>Default</ion-label>
    </ion-chip>

    <ion-chip>
      <ion-icon name="heart" color="dark"></ion-icon>
      <ion-label>Default</ion-label>
    </ion-chip>

    <ion-chip>
      <ion-label>Button Chip</ion-label>
      <ion-chip-button fill="clear" color="light">
        <ion-icon name="close-circle"></ion-icon>
      </ion-chip-button>
    </ion-chip>

    <ion-chip>
      <ion-icon name="pin" color="primary"></ion-icon>
      <ion-label>Icon Chip</ion-label>
      <ion-chip-button>
        <ion-icon name="close"></ion-icon>
      </ion-chip-button>
    </ion-chip>

    <ion-chip>
      <ion-avatar>
        <img src="https://gravatar.com/avatar/dba6bae8c566f9d4041fb9cd9ada7741?d=identicon&f=y">
      </ion-avatar>
      <ion-label>Avatar Chip</ion-label>
      <ion-chip-button fill="clear" color="dark">
        <ion-icon name="close-circle"></ion-icon>
      </ion-chip-button>
    </ion-chip>

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

> ion-chip-button

  Inset-кнопка, которая размещается внутри chip.

  ▪ Использование

    <ion-chip>
      <ion-label>Button Chip</ion-label>
      <ion-chip-button fill="clear" color="light">
        <ion-icon name="close-circle"></ion-icon>
      </ion-chip-button>
    </ion-chip>

    <ion-chip>
      <ion-icon name="pin" color="primary"></ion-icon>
      <ion-label>Icon Chip</ion-label>
      <ion-chip-button>
        <ion-icon name="close"></ion-icon>
      </ion-chip-button>
    </ion-chip>

    <ion-chip>
      <ion-avatar>
        <img src="https://gravatar.com/avatar/dba6bae8c566f9d4041fb9cd9ada7741?d=identicon&f=y">
      </ion-avatar>
      <ion-label>Avatar Chip</ion-label>
      <ion-chip-button fill="clear" color="dark">
        <ion-icon name="close-circle"></ion-icon>
      </ion-chip-button>
    </ion-chip>

  ▪ Свойства

    ▪ disabled 
      - [false] Может ли пользователь взаимодействовать с chip button?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean

    ▪ fill 
      - Установить значение clear, чтобы вкл прозрачный стиль для кнопки
      - Атрибуты: 

        ▪ fill
               
      - Тип: string

    ▪ href 
      - Содержит URL (или фрагмент), куда ведёт ссылка.
        Если это значение задано, anchor-тэг будет отрисован.
      - Атрибуты: 

        ▪ href
               
      - Тип: string      

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

> ion-chip-icon  

  Иконка, которая размещается внутри chip.

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - Какие стили использовать, "ios" или "md".
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ name 
      - Имя для элемента иконки.
      - Атрибуты: 

        ▪ name
               
      - Тип: string      

> ion-grid

  CSS-сетка для создания layout'ов.

  ▪ Описание

    Сетка является мощной системой на flexbox'ах, 
    позволяющей создавать кастомные layout'ы.

    Сетка состоит из 3-х основных компонентов:

      ▪ grid
      ▪ row
      ▪ column

    Column будет стараться заполнить весь row по ширине.
    
    Если в row несколько columns, то последние будут
    менять размер так, чтобы все влезли в row.

    По умолчанию, в одном row может быть максимум 12 
    columns. Это можно менять через css-переменные.

    С помощью различных брейкпоинтов, основанных на ширине
    экрана, можно адаптировать layout под оную.

    Подробнее про всё это читайте в главе:
      А6. Организация layout'а в Ionic-приложении

  ▪ Использование

    <ion-grid>
      <ion-row>
        <ion-col>
          ion-col
        </ion-col>
        <ion-col>
          ion-col
        </ion-col>
        <ion-col>
          ion-col
        </ion-col>
        <ion-col>
          ion-col
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col size="6">
          ion-col [size="6"]
        </ion-col>
        <ion-col>
          ion-col
        </ion-col>
        <ion-col>
          ion-col
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col size="3">
          ion-col [size="3"]
        </ion-col>
        <ion-col>
          ion-col
        </ion-col>
        <ion-col size="3">
          ion-col [size="3"]
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col size="3">
          ion-col [size="3"]
        </ion-col>
        <ion-col size="3" offset="3">
          ion-col [size="3"] [offset="3"]
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col>
          ion-col
        </ion-col>
        <ion-col>
          ion-col
          <br>#
        </ion-col>
        <ion-col>
          ion-col
          <br>#
          <br>#
        </ion-col>
        <ion-col>
          ion-col
          <br>#
          <br>#
          <br>#
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col align-self-start>
          ion-col [start]
        </ion-col>
        <ion-col align-self-center>
          ion-col [center]
        </ion-col>
        <ion-col align-self-end>
          ion-col [end]
        </ion-col>
        <ion-col>
          ion-col
          <br>#
          <br>#
        </ion-col>
      </ion-row>

      <ion-row align-items-start>
        <ion-col>
          [start] ion-col
        </ion-col>
        <ion-col>
          [start] ion-col
        </ion-col>
        <ion-col align-self-end>
          [start] ion-col [end]
        </ion-col>
        <ion-col>
          ion-col
          <br>#
          <br>#
        </ion-col>
      </ion-row>

      <ion-row align-items-center>
        <ion-col>
          [center] ion-col
        </ion-col>
        <ion-col>
          [center] ion-col
        </ion-col>
        <ion-col>
          [center] ion-col
        </ion-col>
        <ion-col>
          ion-col
          <br>#
          <br>#
        </ion-col>
      </ion-row>

      <ion-row align-items-end>
        <ion-col>
          [end] ion-col
        </ion-col>
        <ion-col align-self-start>
          [end] ion-col [start]
        </ion-col>
        <ion-col>
          [end] ion-col
        </ion-col>
        <ion-col>
          ion-col
          <br>#
          <br>#
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col size="12" size-sm>
          ion-col [size="12"] [size-sm]
        </ion-col>
        <ion-col size="12" size-sm>
          ion-col [size="12"] [size-sm]
        </ion-col>
        <ion-col size="12" size-sm>
          ion-col [size="12"] [size-sm]
        </ion-col>
        <ion-col size="12" size-sm>
          ion-col [size="12"] [size-sm]
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col size="12" size-md>
          ion-col [size="12"] [size-md]
        </ion-col>
        <ion-col size="12" size-md>
          ion-col [size="12"] [size-md]
        </ion-col>
        <ion-col size="12" size-md>
          ion-col [size="12"] [size-md]
        </ion-col>
        <ion-col size="12" size-md>
          ion-col [size="12"] [size-md]
        </ion-col>
      </ion-row>

      <ion-row>
        <ion-col size="6" size-lg offset="3">
          ion-col [size="6"] [size-lg] [offset="3"]
        </ion-col>
        <ion-col size="3" size-lg>
          ion-col [size="3"] [size-lg]
        </ion-col>
      </ion-row>
    </ion-grid>

  ▪ Свойства

    ▪ fixed 
      - [false] Будет ли сетка иметь fix ширину, на основе ширины экрана?
      - Атрибуты: 

        ▪ fixed
               
      - Тип: boolean  
 
  ▪ Методы

  ▪ События

> ion-col 

  Column-компонент для размещения внутри grid, внутри row.

  ▪ Описание

    Column будет стараться заполнить весь row по ширине.
    
    Если в row несколько columns, то последние будут
    менять размер так, чтобы все влезли в row.

    Подробнее про всё это читайте в главе:
      А6. Организация layout'а в Ionic-приложении

  ▪ Атрибуты

    ▪ align-self-start

      Добавляет: align-self: flex-start
      Колонка будет выравнена во вертикали на top.

    ▪ align-self-center

      Добавляет: align-self: flex-center
      Колонка будет выравнена во вертикали на center.

    ▪ align-self-end

      Добавляет: align-self: flex-end
      Колонка будет выравнена во вертикали на bottom.

    ▪ align-self-stretch

      Добавляет: align-self: stretch
      Колонка будет растянута по вертикали, чтобы занять 100% высоты row.

    ▪ align-self-baseline

      Добавляет: align-self: baseline
      Колонка будет выравнена во вертикали на baseline.

  ▪ Свойства

    ▪ offset
      - На какое кол-во колонок сместить текущую вправо.
      - Атрибуты: 

        ▪ offset
               
      - Тип: string

    ▪ offsetLg
      - (для lg-экранов) На какое кол-во колонок сместить текущую вправо.
      - Атрибуты: 

        ▪ offset-lg
               
      - Тип: string

    ▪ offsetMd
      - (для md-экранов) На какое кол-во колонок сместить текущую вправо.
      - Атрибуты: 

        ▪ offset-md
               
      - Тип: string

    ▪ offsetSm
      - (для sm-экранов) На какое кол-во колонок сместить текущую вправо.
      - Атрибуты: 

        ▪ offset-sm
               
      - Тип: string

    ▪ offsetXl
      - (для xl-экранов) На какое кол-во колонок сместить текущую вправо.
      - Атрибуты: 

        ▪ offset-xl
               
      - Тип: string

    ▪ offsetXs
      - (для xs-экранов) На какое кол-во колонок сместить текущую вправо.
      - Атрибуты: 

        ▪ offset-xs
               
      - Тип: string

    ▪ pull
      - На какое кол-во колонок сместить текущую влево.
      - Атрибуты: 

        ▪ pull
               
      - Тип: string

    ▪ pullLg
      - (для lg-экранов) На какое кол-во колонок сместить текущую влево.
      - Атрибуты: 

        ▪ pull-lg
               
      - Тип: string

    ▪ pullMd
      - (для md-экранов) На какое кол-во колонок сместить текущую влево.
      - Атрибуты: 

        ▪ pull-md
               
      - Тип: string

    ▪ pullSm
      - (для sm-экранов) На какое кол-во колонок сместить текущую влево.
      - Атрибуты: 

        ▪ pull-sm
               
      - Тип: string

    ▪ pullXl
      - (для xl-экранов) На какое кол-во колонок сместить текущую влево.
      - Атрибуты: 

        ▪ pull-xl
               
      - Тип: string

    ▪ pullXs
      - (для xs-экранов) На какое кол-во колонок сместить текущую влево.
      - Атрибуты: 

        ▪ pull-xs
               
      - Тип: string

    ▪ push
      - На какое кол-во колонок push'нуть текущую вправо.
      - Атрибуты: 

        ▪ push
               
      - Тип: string     

    ▪ pushLg
      - (для lg-экранов) На какое кол-во колонок push'нуть текущую вправо.
      - Атрибуты: 

        ▪ push-lg
               
      - Тип: string

    ▪ pushMd
      - (для md-экранов) На какое кол-во колонок push'нуть текущую вправо.
      - Атрибуты: 

        ▪ push-md
               
      - Тип: string

    ▪ pushSm
      - (для sm-экранов) На какое кол-во колонок push'нуть текущую вправо.
      - Атрибуты: 

        ▪ push-sm
               
      - Тип: string

    ▪ pushXl
      - (для xl-экранов) На какое кол-во колонок push'нуть текущую вправо.
      - Атрибуты: 

        ▪ push-xl
               
      - Тип: string

    ▪ pushXs
      - (для xs-экранов) На какое кол-во колонок push'нуть текущую вправо.
      - Атрибуты: 

        ▪ push-xs
               
      - Тип: string

    ▪ size
      - Размер колонки в колонках (n/12).
      - Атрибуты: 

        ▪ size
               
      - Тип: string

    ▪ sizeLg
      - (для lg-экранов) Размер колонки в колонках (n/12).
      - Атрибуты: 

        ▪ size-lg
               
      - Тип: string

    ▪ sizeMd
      - (для md-экранов) Размер колонки в колонках (n/12).
      - Атрибуты: 

        ▪ size-md
               
      - Тип: string

    ▪ sizeSm
      - (для sm-экранов) Размер колонки в колонках (n/12).
      - Атрибуты: 

        ▪ size-sm
               
      - Тип: string

    ▪ sizeXl
      - (для xl-экранов) Размер колонки в колонках (n/12).
      - Атрибуты: 

        ▪ size-xl
               
      - Тип: string

    ▪ sizeXs
      - (для xs-экранов) Размер колонки в колонках (n/12).
      - Атрибуты: 

        ▪ size-xs
               
      - Тип: string
  
> ion-row 

  Row-компонент для размещения внутри grid

  ▪ Описание

    Может содержать различное количество col-компонентов.

    Подробнее про всё это читайте в главе:
      А6. Организация layout'а в Ionic-приложении    

  ▪ Атрибуты

    ▪ nowrap

      Добавляет flex-wrap: nowrap.
      Приведение столбцов в одну строку

    ▪ wrap-reverse

      Добавляет flex-wrap: wrap-reverse
      Реверс порядка столбцов.

    ▪ align-items-start

      Добавляет align-items: flex-start
      Вертикальное выравнивание столбцов на top,
      игнорирование их собственных настроек выравнивания.

    ▪ align-items-center

      Добавляет align-items: flex-center
      Вертикальное выравнивание столбцов на center,
      игнорирование их собственных настроек выравнивания.

    ▪ align-items-end

      Добавляет align-items: flex-end
      Вертикальное выравнивание столбцов на end,
      игнорирование их собственных настроек выравнивания.

    ▪ align-items-stretch

      Добавляет align-items: stretch
      Растягивание всех колонок по вертикали до высоты row,
      игнорирование их собственных настроек выравнивания.

    ▪ align-items-baseline

      Добавляет align-items: baseline
      Вертикальное выравнивание столбцов на baseline,
      игнорирование их собственных настроек выравнивания.

    ▪ justify-content-start

      Добавляет justify-content: start
      Горизонтальное выравнивание колонок на старт.

    ▪ justify-content-center

      Добавляет justify-content: center
      Горизонтальное выравнивание колонок на центр.

    ▪ justify-content-end

      Добавляет justify-content: end
      Горизонтальное выравнивание колонок на конец.

    ▪ justify-content-around

      Добавляет justify-content: space-around
      Горизонтальное выравнивание с равным расстоянием между.

    ▪ justify-content-between

      Добавляет justify-content: space-between
      Горизонтальное выравнивание с half-size расстоянием
      на обоих концах.

> ion-content 

  Главная зона для контента, со скроллом.

  ▪ Описание

    Должен быть лишь 1 content в single view component.

  ▪ Использование

    HTML:

      <ion-content></ion-content>

    JS:

      var content = document.querySelector('ion-content');
      content.scrollEvents = true;
      content.addEventListener('ionScrollStart', () => console.log('scroll start'));
      content.addEventListener('ionScroll', (ev) => console.log('scroll', ev.detail));
      content.addEventListener('ionScrollEnd', () => console.log('scroll end'));    

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ forceOverscroll
      - [false] Выключить ли bounce-эффект?
        Если true, и контент не вызывает overflow scroll,
        скроллинг к началу/концу контента будет вызывать 
        bounce-эффект (подпрыгивание).
        Если контент достигает краёв ionContent, ничего
        не изменится. Имейте в виду, что оно не отключает
        системный bounce-эффект на iOS (это эффект на 
        уровне системы iOS)

      - Атрибуты: 

        ▪ force-overscroll
               
      - Тип: boolean

    ▪ fullscreen
      - [false] Будет ли контент скроллиться за header'ом и footer'ом?
      - Атрибуты: 

        ▪ fullscreen
               
      - Тип: boolean 

    ▪ scrollEnabled
      - [true] Включить ли скролл в content через scroll?
      - Атрибуты: 

        ▪ scroll-enabled
               
      - Тип: boolean

    ▪ scrollEvents
      - [false] Включить ли возбуждение событий scroll'а?
        Они отключены по умолчанию по соображениям производительности.
      - Атрибуты: 

        ▪ scroll-events
               
      - Тип: boolean

  ▪ Методы

    ▪ getScrollElement()  | Получить скролл элемента

> ion-datetime

  Datetime-picker, который вылазит снизу экрана.

  ▪ Описание

    Datetime представляет собой интерфейс, позволяющий
    пользователю выбирать дату и время, и вылезающий
    снизу экрана.

    Отображает прокручиваемые колонки, которые могут
    быть использованы для индивидуального выбора
    года, месяца, даты, часа, минуты. 

    Datetime аналогичен нативному элементу input типа
    datetime-local. Однако, компонент datetime Ionic'а 
    позволяет легко отображать дату и время в предпочитаемом
    формате, и управлять значениями datetime.

    Подробнее о работе этого компонента см.официальную
    документацию:

      https://beta.ionicframework.com/docs/api/datetime

  ▪ Использование

    HTML: 

      <ion-item>
        <ion-label>MMMM</ion-label>
        <ion-datetime display-format="MMMM" value="2012-12-15T13:47:20.789"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>MM DD YY</ion-label>
        <ion-datetime display-format="MM DD YY" placeholder="Select Date"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>Disabled</ion-label>
        <ion-datetime id="dynamicDisabled" display-format="MM DD YY" disabled value="1994-12-15"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>YYYY</ion-label>
        <ion-datetime id="customPickerOptions" placeholder="Custom Options" display-format="YYYY" min="1981" max="2002"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label position="stacked">MMMM YY</ion-label>
        <ion-datetime display-format="MMMM YY" min="1989-06-04" max="2004-08-23" value="1994-12-15T13:47:20.789"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label position="floating">MM/DD/YYYY</ion-label>
        <ion-datetime display-format="MM/DD/YYYY" min="1994-03-14" max="2012-12-09" value="2002-09-23T15:03:46.789"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label position="floating">MM/DD/YYYY</ion-label>
        <ion-datetime display-format="MM/DD/YYYY" min="1994-03-14" max="2012-12-09"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>DDD. MMM DD, YY (custom locale)</ion-label>
        <ion-datetime id="customDayShortNames" value="1995-04-15" min="1990-02" max="2000"
          display-format="DDD. MMM DD, YY"
          month-short-names="jan, feb, mar, apr, mai, jun, jul, aug, sep, okt, nov, des"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>D MMM YYYY H:mm</ion-label>
        <ion-datetime display-format="D MMM YYYY H:mm" min="1997" max="2010" value="2005-06-17T11:06Z"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>DDDD MMM D, YYYY</ion-label>
        <ion-datetime display-format="DDDD MMM D, YYYY" min="2005" max="2016" value="2008-09-02"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>HH:mm</ion-label>
        <ion-datetime display-format="HH:mm"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>h:mm a</ion-label>
        <ion-datetime display-format="h:mm a"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>hh:mm A (15 min steps)</ion-label>
        <ion-datetime display-format="h:mm A" minute-values="0,15,30,45"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>Leap years, summer months</ion-label>
        <ion-datetime id="customYearValues" display-format="MM/YYYY" picker-format="MMMM YYYY" month-values="6,7,8"></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label>Specific days/months/years</ion-label>
        <ion-datetime month-values="6,7,8" year-values="2014,2015" day-values="01,02,03,04,05,06,08,09,10, 11, 12, 13, 14" display-format="DD/MMM/YYYY"></ion-datetime>
      </ion-item>

    JS: 

      var yearValuesArray = [2020, 2016, 2008, 2004, 2000, 1996];
      var customYearValues = document.getElementById('customYearValues');
      customYearValues.yearValues = yearValuesArray;

      var dayShortNamesArray = [
        's\u00f8n',
        'man',
        'tir',
        'ons',
        'tor',
        'fre',
        'l\u00f8r'
      ];
      var customDayShortNames = document.getElementById('customDayShortNames');
      customDayShortNames.dayShortNames = dayShortNamesArray;

      var customPickerButtons = {
        buttons: [{
          text: 'Save',
          handler: () => console.log('Clicked Save!')
        }, {
          text: 'Log',
          handler: () => {
            console.log('Clicked Log. Do not Dismiss.');
            return false;
          }
        }]
      }
      var customPickerOptions = document.getElementById('customPickerOptions');
      customPickerOptions.pickerOptions = customPickerButtons;    

  ▪ Свойства

    ▪ cancelText
      - [Cancel] Какой текст показать на кнопке cancel.
      - Атрибуты: 

        ▪ cancel-text
               
      - Тип: string

    ▪ dayNames
      - Полные имена дней недели на локальном языке (english по умолчанию).
      - Атрибуты: 

        ▪ day-names
               
      - Тип: string

    ▪ dayShortNames
      - Короткие имена дней недели на локальнмо языке (english по умолчанию).
      - Атрибуты: 

        ▪ day-short-names
               
      - Тип: string

    ▪ dayValues
      - Какие даты показывать: число, массив чисел, строка с comma-sep.числами.
        По умолчанию показываются даты для выбранного месяца.
        Не показывает даты, которых не может быть в выбранном месяце.
      - Атрибуты: 

        ▪ day-values
               
      - Тип: any

    ▪ disabled
      - [false] Отключить ли пользователю возможность взаимодействовать с datetime?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean

    ▪ displayFormat
      - [MMM D, YYYY] Формат текстового отображения даты и времени.
      - Атрибуты: 

        ▪ display-format
               
      - Тип: string

    ▪ doneText
      - [Done] Какой текст отображать на кнопке "Done"?
      - Атрибуты: 

        ▪ done-text
               
      - Тип: string

    ▪ hourValues
      - Какие часы показывать: число, массив чисел, строка с comma-sep.числами.
        По умолчанию с 0 до 23 для 24-часового времени, 
        и с 1 по 12 для 12-часового времени.
        Не показывает часы, которых не может быть. Например, 25.
      - Атрибуты: 

        ▪ hour-values
               
      - Тип: any

    ▪ max
      - Максимальная разрешённая дата и время в формате "1996-12-19"
        Можно указать, например, только год: "1994".
        По умолчанию, до конца текущего года.
      - Атрибуты: 

        ▪ max
               
      - Тип: string

    ▪ min
      - Минимальная разрешённая дата и время в формате "1996-12-19".
        Можно указать, например, только год: "1994".
        По умолчанию, начало года, 100 лет назад от текущего момента.      
      - Атрибуты: 

        ▪ min
               
      - Тип: string

    ▪ minuteValues
      - Какие минуты показывать: число, массив чисел, строка с comma-sep.числами.
        По умолчанию с 0 до 59.
        и с 1 по 12 для 12-часового времени.
        Например, только каждую 15 минуту: minuteValues="0,15,30,45".
        Не показывает минуты, которых не может быть. Например, 61.
      - Атрибуты: 

        ▪ minute-values
               
      - Тип: any

    ▪ monthNames
      - Полные имена месяцев на локальном языке (english по умолчанию).
      - Атрибуты: 

        ▪ month-names
               
      - Тип: string

    ▪ monthShortNames
      - Короткие имена месяцев на локальном языке (english по умолчанию).
      - Атрибуты: 

        ▪ month-short-names
               
      - Тип: string

    ▪ monthValues
      - Какие месяцы показывать: число, массив чисел, строка с comma-sep.числами.
        По умолчанию с 1 до 12.
        и с 1 по 12 для 12-часового времени.
        Например, только с 6 по 8: monthValues="6,7,8".
        Не показывает месяцы, которых не может быть. Например, 13.
      - Атрибуты: 

        ▪ month-values
               
      - Тип: any

    ▪ pickerFormat
      - [displayFormat] Формат колонок для date and time picker'а.
        Подробнее см.оф.доки для этого компонента.
      - Атрибуты: 

        ▪ picker-format
               
      - Тип: string

    ▪ pickerOptions
      - Любые доп.опции, которые интерфейс picker'а может принять.
        См.Picker API docs: https://beta.ionicframework.com/picker/Picker
      - Атрибуты: 

        ▪ picker-options
               
      - Тип: PickerOptions

    ▪ placeholder
      - Какой текст показывать, если дата ещё не выбрана.
        Использует lowercase.
      - Атрибуты: 

        ▪ placeholder
               
      - Тип: string

    ▪ value
      - Значение компонента datetime.
      - Атрибуты: 

        ▪ value
               
      - Тип: string

    ▪ yearValues
      - Какие года показывать: число, массив чисел, строка с comma-sep.числами.
        По умолчанию с min до max.
        Например, только високосные года: yearValues="2024,2020,2016,2012,2008".
      - Атрибуты: 

        ▪ year-values
               
      - Тип: any

  ▪ События

    ▪ ionCancel   | Возбуждается, когда выбор datetime был отменён
    ▪ ionStyle    | Возбуждается при изменение styles

> ion-fab       

  Контейнерный элемент для fab-кнопок.

  ▪ Описание

    Его требуется размещать с fixed position, чтобы он не
    прокручивался скроллом вместе с контентом.

    У fab должна быть одна главная fab button.

    Fab может также содержать fab lists, которые содержат
    доп.кнопки, которые показываются при нажатии на 
    главную fab button.

    Один и тот же fab-контейнер может содержать несколько
    fab lists, с различными параметрами side (вроде, есть
    4 варианта).

  ▪ Использование

    <ion-content>
      <!-- fab placed to the top end -->
      <ion-fab vertical="top" horizontal="end" slot="fixed">
        <ion-fab-button>
          <ion-icon name="add"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the bottom end -->
      <ion-fab vertical="bottom" horizontal="end" slot="fixed">
        <ion-fab-button>
          <ion-icon name="arrow-dropleft"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the top start -->
      <ion-fab vertical="top" horizontal="start" slot="fixed">
        <ion-fab-button>
          <ion-icon name="arrow-dropright"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the bottom start -->
      <ion-fab vertical="bottom" horizontal="start" slot="fixed">
        <ion-fab-button>
          <ion-icon name="arrow-dropup"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the (vertical) center and start -->
      <ion-fab vertical="center" horizontal="start" slot="fixed">
        <ion-fab-button>
          <ion-icon name="share"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the (vertical) center and end -->
      <ion-fab vertical="center" horizontal="end" slot="fixed">
        <ion-fab-button>
          <ion-icon name="add"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the top and end and on the top edge of the content overlapping header -->
      <ion-fab vertical="top" horizontal="end" edge slot="fixed">
        <ion-fab-button>
          <ion-icon name="person"></ion-icon>
        </ion-fab-button>
      </ion-fab>

      <!-- fab placed to the bottom and start and on the bottom edge of the content overlapping footer with a list to the right -->
      <ion-fab vertical="bottom" horizontal="start" edge slot="fixed">
        <ion-fab-button>
          <ion-icon name="settings"></ion-icon>
        </ion-fab-button>
        <ion-fab-list side="end">
          <ion-fab-button><ion-icon name="logo-vimeo"></ion-icon></ion-fab-button>
        </ion-fab-list>
      </ion-fab>

      <!-- fab placed in the center of the content with a list on each side -->
      <ion-fab vertical="center" horizontal="center" slot="fixed">
        <ion-fab-button>
          <ion-icon name="share"></ion-icon>
        </ion-fab-button>
        <ion-fab-list side="top">
          <ion-fab-button><ion-icon name="logo-vimeo"></ion-icon></ion-fab-button>
        </ion-fab-list>
        <ion-fab-list side="bottom">
          <ion-fab-button><ion-icon name="logo-facebook"></ion-icon></ion-fab-button>
        </ion-fab-list>
        <ion-fab-list side="start">
          <ion-fab-button><ion-icon name="logo-googleplus"></ion-icon></ion-fab-button>
        </ion-fab-list>
        <ion-fab-list side="end">
          <ion-fab-button><ion-icon name="logo-twitter"></ion-icon></ion-fab-button>
        </ion-fab-list>
      </ion-fab>
    </ion-content>

  ▪ Свойства

    ▪ activated
      - [false] Отобразить ли на FAB кнопках иконку close?
      - Атрибуты: 

        ▪ activated
               
      - Тип: boolean

    ▪ edge
      - Показывать fab на краю header'а (если vertical == "top") или footer'а (если vertical == "bottom")
      - Атрибуты: 

        ▪ edge
               
      - Тип: boolean

    ▪ horizontal
      - Горизонтальное позиционирование во viewport: "center", "start", "end"
      - Атрибуты: 

        ▪ horizontal
               
      - Тип: string

    ▪ vertical
      - Вертикальное позиционирование  во viewport: "top", "center", "bottom"
      - Атрибуты: 

        ▪ vertical
               
      - Тип: string

  ▪ Методы

    ▪ close()   | Закрыть активный FAB list

> ion-fab-button

  Floating Action Button (FAB) для основного действия на экране.

  ▪ Описание

    На одном экране может не только одино, но и 
    несколько FAB'ов, представляющих главные действия
    на этом экране. Но, обычно, FAB один.

    По умолчанию, FAB имеет круглую форму.

    При нажатии на FAB, если с ним связан FAB list,
    сбоку от неё появится список возможных действий.

    Как следует из названия, FAB имеет fixed position,
    и располагается над контентом. Это не достигается
    только лишь <ion-fab-button>FAB</ion-fab-button>.
    FAB'ы обязательно должны быть завёрнуты в 
    <ion-fab>, чтобы получить position fixed и быть над
    контентом.
    Если FAB не завёрнута в <ion-fab>, то она будет
    скроллиться вместе с контентом.

    FAB может быть разных размеров и цветов.

  ▪ Использование

    <ion-content>

      <!-- Fixed Floating Action Button that does not scroll with the content -->
      <ion-fab>
        <ion-fab-button>Button</ion-fab-button>
      </ion-fab>

      <!-- Default Floating Action Button that scrolls with the content.-->
      <ion-fab-button>Default</ion-fab-button>

      <!-- Mini -->
      <ion-fab-button mini>Mini</ion-fab-button>

      <!-- Colors -->
      <ion-fab-button color="primary">Primary</ion-fab-button>
      <ion-fab-button color="secondary">Secondary</ion-fab-button>
      <ion-fab-button color="danger">Danger</ion-fab-button>
      <ion-fab-button color="light">Light</ion-fab-button>
      <ion-fab-button color="dark">Dark</ion-fab-button>

    </ion-content>

  ▪ Свойства

    ▪ activated
      - [false] Отобразить ли на FAB кнопках иконку close?
      - Атрибуты: 

        ▪ activated
               
      - Тип: boolean

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения. 
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ href 
      - Содержит URL (или фрагмент), куда ведёт ссылка.
        Если это значение задано, anchor-тэг будет отрисован.
      - Атрибуты: 

        ▪ href
               
      - Тип: string

    ▪ mode 
      - В каком режиме (md или ios) отображать компонент.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string   

    ▪ disabled 
      - [false] Отключить ли кнопку (на неё нельзя нажать)?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean   

    ▪ translucent
      - [false] Включить ли полупрозрачность для компонента?
      - Атрибуты:

        ▪ translucent

      - Тип: boolean

    ▪ show
      - Показывать ли FAB в FAB list'е?
      - Атрибуты:

        ▪ show

      - Тип: boolean      

> ion-fab-list  

  Контейнер для N FAB'ов, которые появляются при клеке на главную FAB.

  ▪ Описание

    Чтобы настроить, с какой стороны от главной кнопки
    они должны появляться, используется свойства side:
    "start", "end", "top", "bottom".

  ▪ Использование

    <ion-fab vertical="bottom" horizontal="end">
      <ion-fab-button>Share</ion-fab-button>

      <ion-fab-list side="top">
        <ion-fab-button>Facebook</ion-fab-button>
        <ion-fab-button>Twitter</ion-fab-button>
        <ion-fab-button>Youtube</ion-fab-button>
      </ion-fab-list>

      <ion-fab-list side="start">
        <ion-fab-button>Vimeo</ion-fab-button>
      </ion-fab-list>

    </ion-fab>

  ▪ Свойства

    ▪ activated
      - [false] Отобразить ли на FAB кнопках иконку close?
      - Атрибуты: 

        ▪ activated
               
      - Тип: boolean

    ▪ side
      - [false] Отобразить ли на FAB кнопках иконку close?
      - Атрибуты: 

        ▪ side
               
      - Тип: string

> ion-footer   

  Один из трёх корневых компонентов страницы, находящийся в нижней части.

  ▪ Описание

    Footer может быть обёрткой для ion-toolbar, что позволяет
    убедиться в том, что content-зона имеет верные размеры.

  ▪ Использование

    <ion-content></ion-content>

    <ion-footer>
      <ion-toolbar>
        <ion-title>Footer</ion-title>
      </ion-toolbar>
    </ion-footer>

  ▪ Свойства

    ▪ mode 
      - В каком режиме (md или ios) отображать компонент.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string   

    ▪ translucent
      - [false] Включить ли полупрозрачность для компонента?
      - Атрибуты:

        ▪ translucent

      - Тип: boolean

> ion-header   

  Один из трёх корневых компонентов страницы, находящийся в верхней части

  ▪ Описание

    Чаще всего в header размещают компонент toolbar.

  ▪ Использование

    <ion-header>
      <ion-navbar>
        <ion-title>Page1</ion-title>
      </ion-navbar>

      <ion-toolbar>
        <ion-title>Subheader</ion-title>
      </ion-toolbar>
    </ion-header>

    <ion-content></ion-content>

  ▪ Свойства

    ▪ mode 
      - В каком режиме (md или ios) отображать компонент.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string   

    ▪ translucent
      - [false] Включить ли полупрозрачность для компонента?
      - Атрибуты:

        ▪ translucent

      - Тип: boolean

> ion-hide-when

  Скрывает себя и свой контент, если условие равно true.

  ▪ Использование

    <ion-content padding>

      <h2>Mode Tests</h2>
      <ion-hide-when mode="md, ios">
        <div>Hides on MD, iOS</div>
      </ion-hide-when>

      <ion-hide-when mode="md">
        <div>Hides on MD only</div>
      </ion-hide-when>

      <ion-hide-when mode="ios">
        <div>Hides on iOS only</div>
      </ion-hide-when>

      <h2>Orientation Tests</h2>
      <ion-hide-when orientation="portrait">
        <div>Hides on portrait orientation</div>
      </ion-hide-when>

      <ion-hide-when orientation="landscape">
        <div>Hides on landscape orientation</div>
      </ion-hide-when>

      <h2>Platform Tests</h2>

      <ion-hide-when platform="android,ios">
        <div>Hides on Android and iOS</div>
      </ion-hide-when>

      <ion-hide-when platform="ios">
        <div>Only hide on iOS</div>
      </ion-hide-when>

      <ion-hide-when platform="android">
        <div>Only hide on Android</div>
      </ion-hide-when>

      <ion-hide-when platform="ipad">
        <div>Only hide on ipad</div>
      </ion-hide-when>

      <ion-hide-when platform="phablet">
        <div>Only hide on phablet</div>
      </ion-hide-when>

      <ion-hide-when platform="iphone">
        <div>Only hide on phone</div>
      </ion-hide-when>

      <h2>Size Tests</h2>
      <ion-hide-when size="xs">
        <div>Only hide on xs</div>
      </ion-hide-when>

      <ion-hide-when size="sm">
        <div>Only hide on sm</div>
      </ion-hide-when>

      <ion-hide-when size="md">
        <div>Only hide on md</div>
      </ion-hide-when>

      <ion-hide-when size="lg">
        <div>Only hide on lg</div>
      </ion-hide-when>

      <ion-hide-when size="xl">
        <div>Only hide on xl</div>
      </ion-hide-when>

      <ion-hide-when size="xs, m">
        <div>Only hide on XS or m</div>
      </ion-hide-when>

    </ion-content>

  ▪ Свойства

    ▪ mediaQuery
      - Если текущий media query совпадает с этим значением, элемент будет скрыт.
      - Атрибуты: 

        ▪ media-query
               
      - Тип: string

    ▪ mode 
      - Если текущий режим отображения (ios или md) совпадает с указанной, элемент будет скрыт.
        Принимает comma separated list.
        Не путать платформу с mode (режимом отображения).
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ or
      - Если false, все условия д.б. true для скрытия эл-та; если true - хотя бы одно.
      - Атрибуты: 

        ▪ or
               
      - Тип: boolean

    ▪ orientation
      - Если текущая ориентация совпадает с указанной, элемент будет скрыт.
      - Атрибуты: 

        ▪ orientation
               
      - Тип: string

    ▪ platform
      - Если текущая платформа совпадает с указанной, элемент будет скрыт.
        Принимает comma separated list.
        Не путать платформу с mode (режимом отображения).
      - Атрибуты: 

        ▪ platform
               
      - Тип: string

    ▪ size
      - Если текущая ширина экрана (xs,sm,md,lg,xl) совпадает с указанной, элемент будет скрыт.
      - Атрибуты: 

        ▪ size
               
      - Тип: string

> ion-img      

  Лениво подгрузит картинку, когда она окажется во viewport.

  ▪ Описание

    Это особенно полезно на страницах с длинными списками
    картинок, поскольку картинки подгружаются лишь тогда,
    когда они фактически попадают во viewport.

    Компонент использует Intersection Observer 
    (https://caniuse.com/#feat=intersectionobserver),
    который поддерживается в большинстве современных
    браузерах. А если не поддерживается, тогда вместо него 
    компонент начинает пользовать старым добрым setTimeout.

  ▪ Использование

    *Примечание: пример для Angular (другого не было в доках)

    <ion-list>
      <ion-item *ngFor="let item of items">
        <ion-thumbnail slot="start">
          <ion-img [src]="item.src"></ion-img>
        </ion-thumbnail>
        <ion-label>{{item.text}}</ion-label>
      </ion-item>
    </ion-list>  

  ▪ Свойства

    ▪ alt
      - Альтернативный текст для описания изображения.
        Пользователи увидят его, если URL битый, если
        неверный формат у картинки, или если изображение
        ещё не скачалось.
      - Атрибуты: 

        ▪ alt
               
      - Тип: string

    ▪ src
      - URL изображения, обязателен к заполнению.
      - Атрибуты: 

        ▪ src
               
      - Тип: string      

> ion-infinite-scroll

  Организация бесконечной проктурки, вызывает callback на дистанции скролла X от верха/низа страницы.

  ▪ Описание

    Выражение, назначенное событию ionInfinite, вызывается,
    когда скролл достигает указанной дистанции (threshold).

    Когда выражение закончит свою работу, необходимо вызывать
    метод complete() на экземпляре infinit scroll.

    ▪ Infinite Scroll Content

      Компонент ion-infinite-scroll имеет логику для организации
      бесконечного скролла. Ему необходим дочерний компонент
      для демонстрации контента. 

      Ionic использует для этого ion-infinite-scroll-content 
      по умолчанию. Этот компонент отображает бесконечный
      скроллбар и изменяет свой внешний вид в зависимости
      от состояния infinite scroll. 

      При подгрузке, он отображате спиннер, внешний вид 
      которого соответствует режиму отображения плтформы.

      Однако, спиннер по умолчанию, как и текст для него, 
      можно изменить в свойствах компонента 
      ion-infinite-scroll-content.

    ▪ Custom Content

      Отделение компонента ion-infinite-scroll от 
      ion-infinite-scroll-content позволяет разработчикам
      создавать свой собственный компонент для контента,
      если они хотят. Этот контент может содержать что угодно,
      начиная от SVG-элементов, и кончая уникальными
      CSS-анимациями.

  ▪ Использование

    HTML:

      <ion-content>
        <ion-button onclick="toggleInfiniteScroll()" expand="block">
          Toggle Infinite Scroll
        </ion-button>

        <ion-list></ion-list>

        <ion-infinite-scroll threshold="100px" id="infinite-scroll">
          <ion-infinite-scroll-content
            loading-spinner="bubbles"
            loading-text="Loading more data...">
          </ion-infinite-scroll-content>
        </ion-infinite-scroll>
      </ion-content>

    JS:

      const infiniteScroll = document.getElementById('infinite-scroll');

      infiniteScroll.addEventListener('ionInfinite', function(event) {
        setTimeout(function() {
          console.log('Done');
          event.target.complete();

          // App logic to determine if all data is loaded
          // and disable the infinite scroll
          if (data.length == 1000) {
            event.target.disabled = true;
          }
        }, 500);
      });

      function toggleInfiniteScroll() {
        infiniteScroll.disabled = !infiniteScroll.disabled;
      }          

  ▪ Свойства

    ▪ disabled
      - Отключить бесконечный скролл (скрыть scrollbar, выключить обработчики).
        Это полезно, когда известно, что новые данные уже не подгрузить,
        и позволяет остановить попытки сделать это.
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean

    ▪ position
      - [bottom] Положение элемента infinite scroll: top, bottom
      - Атрибуты: 

        ▪ position
               
      - Тип: boolean

    ▪ threshold
      - [15%] Расстояние скролла от top/bottom страницы, на котором будут попытки подгрузить контент.
        Будет возбуждаться событие ionInfinite, и выполняться обработчик.
        Например: 10%, 100px
      - Атрибуты: 

        ▪ threshold
               
      - Тип: boolean            

  ▪ Методы

    ▪ complete() 

      Его на экземпляре inf.scr. надо вызвать в конце handler'а события ioninfinite.
      Это уберёт спиннер подгрузки, и сообщит inf.scroll'у, что подгрузка
      завершена.

    ▪ waitFor()   | Вместо complete, можно передать промис, и когда он разрешится, inf.scr. посчитает загрузку завершённой.

  ▪ События

    ▪ ionInfinite   | Срабатывает, когда скролл достигает расстояния threshold от top/bottom (в завис.от значения position)

> ion-infinite-scroll-content

  Дочерний компонент для демонстрации контента по умолчанию для infinite scroll.

  ▪ Описание

    Этот компонент отображает бесконечный
    скроллбар и изменяет свой внешний вид в зависимости
    от состояния infinite scroll. 

    При подгрузке, он отображате спиннер, внешний вид 
    которого соответствует режиму отображения плтформы.

  ▪ Использование

    <ion-content>
      <ion-infinite-scroll>
        <ion-infinite-scroll-content
          loading-spinner="bubbles"
          loading-text="Loading more data…">
        </ion-infinite-scroll-content>
      </ion-infinite-scroll>
    </ion-content>

  ▪ Свойства

    ▪ loadingSpinner
      - Анимированный SVG-спиннер, чтобы показывать во время подгрузки контента.
      - Атрибуты: 

        ▪ loading-spinner
               
      - Тип: string

    ▪ loadingText
      - (опционально) Текст, чтобы показывать во время подгрузки.
      - Атрибуты: 

        ▪ loading-text
               
      - Тип: string

> ion-input       

  Обёртка для элемента HTML-input с кастомной стилизацией и доп.функционалом.

  ▪ Описание

    Компонент принимает большую часть тех же параметров,
    что и HTML-input, но работает прекрасно на desctop-
    устройствах, и интегрирован с клавиатурой на
    мобильных устройствах.

    Обёртка предназначена лишь для input'ов со следующими type:
    "text", "password", "email", "number", "search", "tel", "url".

    Он поддерживает все стандартные события текстовых input'ов,
    включая keyup, keydown, keypress и прочие.

  ▪ Использование

    <!-- Default Input -->
    <ion-input></ion-input>

    <!-- Input with value -->
    <ion-input value="custom"></ion-input>

    <!-- Input with placeholder -->
    <ion-input placeholder="Enter Input"></ion-input>

    <!-- Input with clear button when there is a value -->
    <ion-input clear-input value="clear me"></ion-input>

    <!-- Number type input -->
    <ion-input type="number" value="333"></ion-input>

    <!-- Disabled input -->
    <ion-input value="Disabled" disabled></ion-input>

    <!-- Readonly input -->
    <ion-input value="Readonly" readonly></ion-input>

    <!-- Inputs with labels -->
    <ion-item>
      <ion-label>Default Label</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label position="floating">Floating Label</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label position="fixed">Fixed Label</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label position="stacked">Stacked Label</ion-label>
      <ion-input></ion-input>
    </ion-item>

  ▪ Свойства

    ▪ accept
      - Если type=="file", то в accept список принимаемых типов файлов; иначе игнорируется
        Принимает comma-separated list типов файлов.
      - Атрибуты: 

        ▪ accept
               
      - Тип: string

    ▪ autocapitalize
      - [none] Приводить ли текст автоматически к верхнему регистру?
      - Атрибуты: 

        ▪ autocapitalize
               
      - Тип: string     

    ▪ autocomplete
      - [off] Разрешить ли браузерный автокомплит?
      - Атрибуты: 

        ▪ autocomplete
               
      - Тип: string

    ▪ autocorrect
      - [off] Разрешить ли автокоррекцию ввода?
      - Атрибуты: 

        ▪ autocorrect
               
      - Тип: string

    ▪ autofocus
      - [false] Дать ли input'у автофокус при загрузке страницы?
      - Атрибуты: 

        ▪ autofocus
               
      - Тип: boolean

    ▪ clearInput
      - [false] Показывать ли иконку "очистить ввод"?
      - Атрибуты: 

        ▪ clear-input
               
      - Тип: boolean

    ▪ clearOnEdit
      - [false] Включить ли очистку ввода после фокусировки при редактировании?
      - Атрибуты: 

        ▪ clear-on-edit
               
      - Тип: boolean

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения. 
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ debounce
      - [0] Установить значение в ms - сколько ждать перед возбуждением ionChange после каждого нажатия клавиши.
      - Атрибуты: 

        ▪ debounce
               
      - Тип: number

    ▪ disabled
      - [false] Выключить ли пользователю возможность взаимодействовать с input'ом?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean

    ▪ inputmode
      - Подсказка браузеру, какую клавиатуру показывать.
        Применяется, лишь если type равен "text", "password", 
        "email", "url".
        Возможные значения: "verbatim", "latin", "latin-name", 
        "latin-prose", "full-width-latin", "kana", "katakana", 
        "numeric", "tel", "email", "url".
      - Атрибуты: 

        ▪ inputmode
               
      - Тип: string

    ▪ max
      - MAX значение, не меньше min.
      - Атрибуты: 

        ▪ max
               
      - Тип: string

    ▪ maxlength
      - MAX число символов, которые пользователь может ввести.
        Действует, только если type равен: text, email, search, 
        password, tel, url.
      - Атрибуты: 

        ▪ maxlength
               
      - Тип: number

    ▪ min
      - MAX значение, не больше max.
      - Атрибуты: 

        ▪ min
               
      - Тип: string

    ▪ minlength
      - MIN число символов, которые пользователь может ввести.
        Действует, только если type равен: text, email, search, 
        password, tel, url.
      - Атрибуты: 

        ▪ minlength
               
      - Тип: number

    ▪ mode 
      - Если текущий режим отображения (ios или md) совпадает с указанной, элемент будет скрыт.
        Принимает comma separated list.
        Не путать платформу с mode (режимом отображения).
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ multiple
      - [false] Может ли пользователь ввести более 1-го значения?
        Действует, только если type равен: email, file.
      - Атрибуты: 

        ▪ multiple
               
      - Тип: boolean

    ▪ name 
      - Имя для элемента, которое отправится, вместе с формой.
      - Атрибуты: 

        ▪ name
               
      - Тип: string 

    ▪ pattern
      - Регулярное выражение для проверки значения.
        Паттерн должен совпадать со всем значением, а не частью.
        Используйте атрибут title, чтобы описать паттернд для пользователя.
        Действует, если type равен "text", "search", "tel", "url", 
        "email", "password".
      - Атрибуты: 

        ▪ pattern
               
      - Тип: string

    ▪ placeholder
      - Плейсхолдер.
      - Атрибуты: 

        ▪ placeholder
               
      - Тип: string

    ▪ readonly
      - [false] Сделать ли input read only?
      - Атрибуты: 

        ▪ readonly
               
      - Тип: boolean

    ▪ required
      - [false] Если true, пользователь должен обязательно заполнить input перед отправкой.
      - Атрибуты: 

        ▪ required
               
      - Тип: boolean

    ▪ results
      - Нестандартный атрибут для Safary, значение полож.десятич.integer.
        Действует, только если type равен "search".
      - Атрибуты: 

        ▪ results
               
      - Тип: number

    ▪ size
      - Стартовый размер элемента, "px" - если type=text,password, иначе в символах.
        Действует, только если type равен: "text", "search", "tel", 
        "url", "email", "password".
      - Атрибуты: 

        ▪ size
               
      - Тип: number

    ▪ spellcheck
      - [false] Проверять ли грамматически написанное?
      - Атрибуты: 

        ▪ spellcheck
               
      - Тип: boolean

    ▪ step
      - Работает с min и max для установки min инкремента: "any" или любое полож.число с плавающей точкой.
      - Атрибуты: 

        ▪ step
               
      - Тип: string

    ▪ type
      - Тип input'а: text, password, email, number, search, tel, url.
      - Атрибуты: 

        ▪ type
               
      - Тип: string

    ▪ value
      - Значение input'а.
      - Атрибуты: 

        ▪ value
               
      - Тип: string

  ▪ События

    ▪ ionBlur             | Возбуждается, когда input теряет фокус
    ▪ ionChange           | Возбуждается, когда значение изменилсь
    ▪ ionFocus            | Возбуждается, когда input получает фокус
    ▪ ionInputDidLoad     | Возбуждается при вводе с клавиатуры
    ▪ ionInputDidUnload   | Возбуждается после создания input'а
    ▪ ionStyle            | Возбуждается при изменении стилей

> ion-item

  Item может содержать текст, иконки, аватары, картинки, инпуты, и другие нативные/кастомные эл-ты.

  ▪ Описание

    Обычно, item'ы размещаются списками. 

    Item'ы можно свайпать, удалять, менять местами,
    редактировать и так далее.

    ▪ Detail Arrows в ios mode

      По умолчанию, кликабельные item'ы будут отображать
      иконку с правой стрелкой в ios mode. Чтобы спрятать
      эту стрелку, установите свойство detail в false.

      Чтобы показать эту стрелку на элементе, который не
      отображает её по умолчанию, установите его
      detail в true.

    ▪ Позиционирование элементов

      Item'ы использую именованные слоты для позиционирования
      контента. Это позволяет писать сложные item'ы с простой,
      легко понимаемой разметкой, не волнуясь по поводу
      стилей и позиционирования элементов.

      Ниже дана информация о слотах item'ов, и где они 
      размещают элементы внутри item'а:

        start   | Размещает слева от остального контента в LTR, и справа в RTL.
        end     | Размещает справа от остального контента в LTR, и справа в RTL.
        none    | Размещает внутри обёртки input.

    ▪ Выравнивание текста

      Item'ы делают left align тексту, и добавляют ellipsis,
      если текст шире, чем item. Смотрите по ссылке ниже
      атрибуты, которые можно добавить в <ion-item>, чтобы
      трансформировать текст:

        https://beta.ionicframework.com/docs/layout/css-utilities/

  ▪ Использование

    БАЗОВОЕ ИСПОЛЬЗОВАНИЕ:

      <!-- Default Item -->
      <ion-item>
        <ion-label>
          Item
        </ion-label>
      </ion-item>

      <!-- Item as a Button -->
      <ion-item onclick="buttonClick()">
        <ion-label>
          Button Item
        </ion-label>
      </ion-item>

      <!-- Item as an Anchor -->
      <ion-item href="https://www.ionicframework.com">
        <ion-label>
          Anchor Item
        </ion-label>
      </ion-item>

      <ion-item color="secondary">
        <ion-label>
          Secondary Color Item
        </ion-label>
      </ion-item>

    DETAIL ARROW:

      <ion-item detail>
        <ion-label>
          Standard Item with Detail Arrow
        </ion-label>
      </ion-item>

      <ion-item onclick="buttonClick()">
        <ion-label>
          Button Item with Detail Arrow
        </ion-label>
      </ion-item>

      <ion-item detail="false" href="https://www.ionicframework.com">
        <ion-label>
          Anchor Item with no Detail Arrow
        </ion-label>
      </ion-item>

    СПИСОК ЭЛЕМЕНТОВ:

      <ion-list>
        <ion-item>
          <ion-label>
            Item
          </ion-label>
        </ion-item>

        <ion-item lines="none">
          <ion-label>
            No Lines Item
          </ion-label>
        </ion-item>

        <ion-item>
          <ion-label text-wrap>
          Multiline text that should wrap when it is too long
          to fit on one line in the item.
          </ion-label>
        </ion-item>

        <ion-item>
          <ion-label text-wrap>
            <ion-text color="primary">
              <h3>H3 Primary Title</h3>
            </ion-text>
            <p>Paragraph line 1</p>
            <ion-text color="secondary">
              <p>Paragraph line 2 secondary</p>
            </ion-text>
          </ion-label>
        </ion-item>

        <ion-item lines="full">
          <ion-label>
            Item with Full Lines
          </ion-label>
        </ion-item>

      </ion-list>

    ▪ ITEM LINES
       
      <!-- Item Inset Lines -->
      <ion-item lines="inset">
        <ion-label>Item Lines Inset</ion-label>
      </ion-item>

      <!-- Item Full Lines -->
      <ion-item lines="full">
        <ion-label>Item Lines Full</ion-label>
      </ion-item>

      <!-- Item None Lines -->
      <ion-item lines="none">
        <ion-label>Item Lines None</ion-label>
      </ion-item>

      <!-- List Full Lines -->
      <ion-list lines="full">
        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>

        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>
      </ion-list>

      <!-- List Inset Lines -->
      <ion-list lines="inset">
        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>

        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>
      </ion-list>

      <!-- List No Lines -->
      <ion-list lines="none">
        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>

        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>
      </ion-list>

    ▪ MEDIA ITEMS

      <ion-item onclick="testClick()">
        <ion-avatar slot="start">
          <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==">
        </ion-avatar>
        <ion-label>
          Avatar Start, Button Item
        </ion-label>
      </ion-item>

      <ion-item href="#">
        <ion-label>
          Thumbnail End, Anchor Item
        </ion-label>
        <ion-thumbnail slot="end">
          <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==">
        </ion-thumbnail>
      </ion-item>

      <ion-item>
        <ion-thumbnail slot="start">
          <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==">
        </ion-thumbnail>
        <ion-label>
          <h2>H2 Title Text</h2>
          <p>Button on right</p>
        </ion-label>
        <ion-button fill="outline" slot="end">View</ion-button>
      </ion-item>

      <ion-item onclick="testClick()">
        <ion-thumbnail slot="start">
          <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==">
        </ion-thumbnail>
        <ion-label>
          <h3>H3 Title Text</h3>
          <p>Icon on right</p>
        </ion-label>
        <ion-icon name="close-circle" slot="end"></ion-icon>
      </ion-item>

    ▪ КНОПКИ В ITEM'ах

      <ion-item>
        <ion-button slot="start">
          Start
        </ion-button>
        <ion-label>Button Start/End</ion-label>
        <ion-button slot="end">
          End
        </ion-button>
      </ion-item>

      <ion-item>
        <ion-button slot="start">
          Start Icon
          <ion-icon name="home" slot="end"></ion-icon>
        </ion-button>
        <ion-label>Buttons with Icons</ion-label>
        <ion-button slot="end">
          <ion-icon name="star" slot="end"></ion-icon>
          End Icon
        </ion-button>
      </ion-item>

      <ion-item>
        <ion-button slot="start">
          <ion-icon slot="icon-only" name="navigate"></ion-icon>
        </ion-button>
        <ion-label>Icon only Buttons</ion-label>
        <ion-button slot="end">
          <ion-icon slot="icon-only" name="star"></ion-icon>
        </ion-button>
      </ion-item>    

    ▪ ИКОНКИ В ITEM'АХ

      <ion-item>
        <ion-label>
          Icon End
        </ion-label>
        <ion-icon name="information-circle" slot="end"></ion-icon>
      </ion-item>

      <ion-item>
        <ion-label>
          Large Icon End
        </ion-label>
        <ion-icon name="information-circle" size="large" slot="end"></ion-icon>
      </ion-item>

      <ion-item>
        <ion-label>
          Small Icon End
        </ion-label>
        <ion-icon name="information-circle" size="small" slot="end"></ion-icon>
      </ion-item>

      <ion-item>
        <ion-icon name="star" slot="start"></ion-icon>
        <ion-label>
          Icon Start
        </ion-label>
      </ion-item>

      <ion-item>
        <ion-label>
          Two Icons End
        </ion-label>
        <ion-icon name="checkmark-circle" slot="end"></ion-icon>
        <ion-icon name="shuffle" slot="end"></ion-icon>
      </ion-item>

    ▪ INPUT'Ы В ITEM'АХ

      <ion-item>
        <ion-label position="floating">Datetime</ion-label>
        <ion-datetime></ion-datetime>
      </ion-item>

      <ion-item>
        <ion-label position="floating">Select</ion-label>
        <ion-select>
          <ion-select-option value="">No Game Console</ion-select-option>
          <ion-select-option value="nes">NES</ion-select-option>
          <ion-select-option value="n64" selected>Nintendo64</ion-select-option>
          <ion-select-option value="ps">PlayStation</ion-select-option>
          <ion-select-option value="genesis">Sega Genesis</ion-select-option>
          <ion-select-option value="saturn">Sega Saturn</ion-select-option>
          <ion-select-option value="snes">SNES</ion-select-option>
        </ion-select>
      </ion-item>

      <ion-item>
        <ion-label>Toggle</ion-label>
        <ion-toggle slot="end"></ion-toggle>
      </ion-item>

      <ion-item>
        <ion-label position="floating">Floating Input</ion-label>
        <ion-input></ion-input>
      </ion-item>

      <ion-item>
        <ion-label>Input (placeholder)</ion-label>
        <ion-input placeholder="Placeholder"></ion-input>
      </ion-item>

      <ion-item>
        <ion-label>Checkbox</ion-label>
        <ion-checkbox slot="start"></ion-checkbox>
      </ion-item>

      <ion-item>
        <ion-label>Range</ion-label>
        <ion-range></ion-range>
      </ion-item>    
 
  ▪ Свойства

    ▪ button
      - [false] Сделать ли из item'а кнопку?
      - Атрибуты: 

        ▪ button
               
      - Тип: boolean

    ▪ detail
      - [false (true для ios с присут.св-вом href,onclick или button)] Включить ли иконку с правой стрелкой?
      - Атрибуты: 

        ▪ detail
               
      - Тип: boolean

    ▪ detailIcon
      - [ios-arrow-forward] Какую иконку использовать, если detail == true?
      - Атрибуты: 

        ▪ detail-icon
               
      - Тип: string

    ▪ disabled 
      - [false] Запретить ли пользователю взаимодействовать с item'ом?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean   

    ▪ lines
      - Как отображать нижний border item'а?
      - Атрибуты: 

        ▪ lines
               
      - Тип: string

    ▪ routerDirection 
      - При использовании роутера, указать направление анимации при переходе на др.страницу через href.
      - Атрибуты: 

        ▪ router-direction
               
      - Тип: string   

    ▪ state
      - Состояние???
      - Атрибуты: 

        ▪ state
               
      - Тип: string

    ▪ type
      - Тип кнопки: submit, reset, button.
        Используется, лишь если св-ва onclick или button присутствуют.
      - Атрибуты: 

        ▪ state
               
      - Тип: string      

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ href 
      - Содержит URL (или фрагмент), куда ведёт ссылка.
        Если это значение задано, anchor-тэг будет отрисован.
      - Атрибуты: 

        ▪ href
               
      - Тип: string

    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

> ion-item-divider

  Блочный элемент для отделения item'ов друг от друга в списке.

  ▪ Использование

    <ion-item-divider>
      <ion-label>
        Basic Item Divider
      </ion-label>
    </ion-item-divider>

    <ion-item-divider color="secondary">
      <ion-label>
        Secondary Item Divider
      </ion-label>
    </ion-item-divider>

    <!-- Item Dividers in a List -->
    <ion-list>
      <ion-item-divider>
        <ion-label>
          Section A
        </ion-label>
      </ion-item-divider>

      <ion-item><ion-label>A1</ion-label></ion-item>
      <ion-item><ion-label>A2</ion-label></ion-item>
      <ion-item><ion-label>A3</ion-label></ion-item>
      <ion-item><ion-label>A4</ion-label></ion-item>
      <ion-item><ion-label>A5</ion-label></ion-item>

      <ion-item-divider>
        <ion-label>
          Section B
        </ion-label>
      </ion-item-divider>

      <ion-item><ion-label>B1</ion-label></ion-item>
      <ion-item><ion-label>B2</ion-label></ion-item>
      <ion-item><ion-label>B3</ion-label></ion-item>
      <ion-item><ion-label>B4</ion-label></ion-item>
      <ion-item><ion-label>B5</ion-label></ion-item>
    </ion-list>

  ▪ Свойства

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

> ion-item-group  

  Контейнер для группировки похожих item'ов друг с другом.

  ▪ Описание

    Он может содержать в том чесле item dividers.

  ▪ Использование

    <ion-item-group>
      <ion-item-divider>
        <ion-label>A</ion-label>
      </ion-item-divider>

      <ion-item>
        <ion-label>Angola</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Argentina</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Armenia</ion-label>
      </ion-item>
    </ion-item-group>

    <ion-item-group>
      <ion-item-divider>
        <ion-label>B</ion-label>
      </ion-item-divider>

      <ion-item>
        <ion-label>Bangladesh</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Belarus</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Belgium</ion-label>
      </ion-item>
    </ion-item-group>


    <!-- They can also be used to group sliding items -->
    <ion-item-group>
      <ion-item-divider>
        <ion-label>
          Fruits
        </ion-label>
      </ion-item-divider>

      <ion-item-sliding>
        <ion-item>
          <ion-label>
            <h3>Grapes</h3>
          </ion-label>
        </ion-item>
        <ion-item-options>
          <ion-item-option>
            Favorite
          </ion-item-option>
        </ion-item-options>
      </ion-item-sliding>

      <ion-item-sliding>
        <ion-item>
          <ion-label>
            <h3>Apples</h3>
          </ion-label>
        </ion-item>
        <ion-item-options>
          <ion-item-option>
            Favorite
          </ion-item-option>
        </ion-item-options>
      </ion-item-sliding>
    </ion-item-group>

    <ion-item-group>
      <ion-item-divider>
        <ion-label>
          Vegetables
        </ion-label>
      </ion-item-divider>

      <ion-item-sliding>
        <ion-item>
          <ion-label>
            <h3>Carrots</h3>
          </ion-label>
        </ion-item>
        <ion-item-options>
          <ion-item-option>
            Favorite
          </ion-item-option>
        </ion-item-options>
      </ion-item-sliding>

      <ion-item-sliding>
        <ion-item>
          <ion-label>
            <h3>Celery</h3>
          </ion-label>
        </ion-item>
        <ion-item-options>
          <ion-item-option>
            Favorite
          </ion-item-option>
        </ion-item-options>
      </ion-item-sliding>
    </ion-item-group>

> ion-item-option 

  Option-кнопка для ion-item-sliding.

  ▪ Описание

    Должна размещаться внутри <ion-item-options>.

    Вы можете комбинировать событие ionSwite и 
    директиву expandable для создания full swipe
    action для item'а.

  ▪ Свойства

    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ disabled 
      - [false] Отключить ли item option?
      - Атрибуты: 

        ▪ disabled
               
      - Тип: boolean

    ▪ href 
      - Содержит URL (или фрагмент), куда ведёт ссылка.
        Если это значение задано, anchor-тэг будет отрисован.
      - Атрибуты: 

        ▪ href
               
      - Тип: string

    ▪ expandable 
      - [false] Позволить ли option'у занять всю имеющуюся ширину?
      - Атрибуты: 

        ▪ href
               
      - Тип: string         

> ion-item-options

  Контейнер для option buttons для ion-item-sliding.

  ▪ Описание

    Эти кнопки должны размещаться в слоте start или end.

    Вы можете скомбинировать событие ionSwipe с директивой
    expandable для создания full swipe action для item'а.

    ▪ Side description

      ▪ start   

        Позиция
          Слева от контента в LTR, и справа в RTL.

        Направление свайпа
          Слева-направо в LTR, и наоборот в RTL.

      ▪ end     

        Позиция
          Справа от контента в LTR, и справа в RTL.

        Направление свайпа
          Справа-налево в LTR, и наоборот в RTL.      

  ▪ Свойства

    ▪ side 
      - [end] С какой стороны кнопки размещается слайд?
        Если у вас много ion-item-options, side надо указать для каждой.
      - Атрибуты: 

        ▪ href
               
      - Тип: string  

  ▪ Методы

    fireSwipeEvent()  | Возбудить событие ionSwipe
    isEndSide()       | ???
    width()           | Получить ширину

  ▪ События

    ionSwipe    | Возбуждается, когда кнопка полностью свайпнута.

> ion-item-sliding

  Содержит item, который можно перетаскивать (drag), чтобы открыть option buttons.

  ▪ Описание

    Требует наличия дочернего компонента item.

    Все опции, которые требуется открыть, должны
    размещаться в элементе item options.

    ▪ Направление свайпа

      По умолчанию, кнопки размещаются на стороне (side)
      end. Это означает, что опции открываются, когда
      пользователь свайпает от end к start, т.е. 
      справа-налево в LTR, и наоборот в RTL.

      Чтобы изменить всё наоборот, надо для элемента
      ion-item-options изменить значение свойства side
      на "start".

    ▪ Layout для опций

      По умолчанию, если иконка размещена вместе с текстом
      в item option, то он будет отображать иконку поверх
      текста. 

      Но слот иконки можно изменить на любой из следующих,
      чтобы позиционировать её в опции:

        start         | Слева от контента в LTR, наоборот в RTL
        top           | Сверху от текста
        icon-only     | Иконка, это единственный контекст кнопки
        bottom        | Снизу от текста
        end           | Справа от контента в LTR, наоборот в RTL

    ▪ Полностью раскрываемые опции

      Опции можно раскрыть так, чтобы они занимали всю
      ширину item'а, если вы досвайпаете до определенного
      момента. Это можно комбинировать с событием ionSwipe,
      чтобы вызывать методы на классе.

  ▪ Использование

    <ion-list>
      <ion-item-sliding>
        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>
        <ion-item-options side="start">
          <ion-item-option onClick="favorite(item)">Favorite</ion-item-option>
          <ion-item-option color="danger" onClick="share(item)">Share</ion-item-option>
        </ion-item-options>

        <ion-item-options side="end">
          <ion-item-option onClick="unread(item)">Unread</ion-item-option>
        </ion-item-options>
      </ion-item-sliding>
    </ion-list>

  ▪ Свойства

  ▪ Методы

    ▪ close()           | Закрыть sliding item (прикрыть опции).
    ▪ closeOpened()     | Закрыть sliding item'ы в списке (прикрыть опции).
    ▪ getOpenAmount()   | Узнать, насколько px приоткрыт sliding item.
    ▪ getSlidingRatio() | Получить отношение открытости sliding item к ширине опций.
                          - Если оно +, то опции на правой стороне открыты.
                          - Если оно -, то опции на левой стороне открыты.
                          - Если абсолютное значение > 1, то sliding item раскрыт более, чем на ширину опций.

  ▪ События

    ▪ ionDrag   | Возбуждается, когда позиция слайдинга меняется

> ion-label      

  Обёртка для использования с item, input, toggle и т.д.

  ▪ Описание

    Положение label'а внутри item'а может быть
    inline, fixed, stacked или floating.

  ▪ Использование

    <!-- Default Label -->
    <ion-label>Label</ion-label>

    <!-- Label Colors -->
    <ion-label color="primary">Primary Label</ion-label>
    <ion-label color="secondary">Secondary Label</ion-label>
    <ion-label color="danger">Danger Label</ion-label>
    <ion-label color="light">Light Label</ion-label>
    <ion-label color="dark">Dark Label</ion-label>

    <!-- Item Labels -->
    <ion-item>
      <ion-label>Default Item</ion-label>
    </ion-item>

    <ion-item text-wrap>
      <ion-label>
        Multi-line text that should wrap when it is too long
        to fit on one line in the item.
      </ion-label>
    </ion-item>

    <!-- Input Labels -->
    <ion-item>
      <ion-label>Default Input</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label position="fixed">Fixed</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label position="floating">Floating</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label position="stacked">Stacked</ion-label>
      <ion-input></ion-input>
    </ion-item>

    <ion-item>
      <ion-label>Toggle</ion-label>
      <ion-toggle slot="end" checked></ion-toggle>
    </ion-item>

    <ion-item>
      <ion-checkbox slot="start" checked></ion-checkbox>
      <ion-label>Checkbox</ion-label>
    </ion-item>

  ▪ Свойства

    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ position 
      - Настроить положение label'а в item'е: inline, fixed, stacked или floating
      - Атрибуты: 

        ▪ color
               
      - Тип: string      

> ion-list       

  Списки состоят из многих строк с item'ами с текстом, кнопками, иконками, переключателям и т.д.

  ▪ Описание

    Обычно в списки группируют похожие item'ы с похожим
    контентом, таким как картинки и текст.

    Списки поддерживают несколько взаимодействий, включая
    свайпинг item'ов для открытия опций, перетаскивание
    для изменения парядка item'ов в списке, и их удаление.

  ▪ Использование

    <!-- List of Text Items -->
    <ion-list>
      <ion-item>
        <ion-label>Pokémon Yellow</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Mega Man X</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>The Legend of Zelda</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Pac-Man</ion-label>
      </ion-item>
      <ion-item>
        <ion-label>Super Mario World</ion-label>
      </ion-item>
    </ion-list>

    <!-- List of Input Items -->
    <ion-list>
      <ion-item>
        <ion-label>Input</ion-label>
        <ion-input></ion-input>
      </ion-item>
      <ion-item>
        <ion-label>Toggle</ion-label>
        <ion-toggle slot="end"></ion-toggle>
      </ion-item>
      <ion-item>
        <ion-label>Radio</ion-label>
        <ion-radio slot="end"></ion-radio>
      </ion-item>
      <ion-item>
        <ion-label>Checkbox</ion-label>
        <ion-checkbox slot="start"></ion-checkbox>
      </ion-item>
    </ion-list>

    <!-- List of Sliding Items -->
    <ion-list>
      <ion-item-sliding>
        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>
        <ion-item-options side="end">
          <ion-item-option onClick="unread(item)">Unread</ion-item-option>
        </ion-item-options>
      </ion-item-sliding>

      <ion-item-sliding>
        <ion-item>
          <ion-label>Item</ion-label>
        </ion-item>
        <ion-item-options side="end">
          <ion-item-option onClick="unread(item)">Unread</ion-item-option>
        </ion-item-options>
      </ion-item-sliding>
    </ion-list>

  ▪ Свойства

    ▪ inset 
      - [false] Включить ли margin для списка и круглыми углами.
      - Атрибуты: 

        ▪ inset
               
      - Тип: boolean

    ▪ lines 
      - Как показывать нижний border на всех item'ах.
      - Атрибуты: 

        ▪ lines
               
      - Тип: string       

  ▪ Методы

    ▪ closeSlidingItems()   | Закрыть все открытые sliding items
    ▪ getOpenItem()         | Получить sliding item, которые сейчас открыт
    ▪ setOpenItem()         | Открыть sliding item

> ion-list-header

  Header-компонент для списка (list).

  ▪ Описание

    В отличие от ItemDivider, ListHeaders стилизованы так, 
    чтобы быть отдельно от остальных элементов списка.

  ▪ Использование

    <ion-list>
      <ion-list-header>
        <ion-label>Items</ion-label>
      </ion-list-header>
      <ion-item>Item 1</ion-item>
      <ion-item>Item 2</ion-item>
      <ion-item>Item 3</ion-item>
      <ion-item>Item 4</ion-item>
      <ion-item>Item 5</ion-item>
    </ion-list>

  ▪ Свойства

    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

> ion-loading    

  Панель загрузки поверх контента, блокирующая интерфейс, и показывающая, что идёт какой-то процесс.

  ▪ Описание

    Индикатор загрузки возникает поверх контента приложения,
    и может быть выключен, чтобы пользователь
    мог продолжить взаимодействие с приложением.

    Он включает опциональный фон, который может быть
    выключен установкой свойства showBackdrop в false
    при создании компонента.

    ▪ Создание

      Индикаторы загрузки можно создать с помощью
      Loading Controller. Их легко кастомизировать,
      передавая методу create Loading Controller'а 
      конфиг с параметрами.

      Имя спиннера необходимо передавать в свойстве
      с ключом spinner.

      Любой опциональный html может быть передан
      в свойстве с ключом content.

      Если значение в spinner не передано, индикатор
      загрузки будет использовать стандартной для
      текущей платформы спиннер.

    ▪ Выключение

      Индикатор загрузки может быть выключен автоматически
      через определённое кол-во ms после создания, переданное
      через параметр duration.

      По умолчани, индикатор загрузки будет продолжать
      отображаться даже, если страница будет переключена
      на другую. Но это можно изменить, установив 
      dismissOnPageChange в true.

      Чтобы выключить индикатор загрузки после создания, 
      вызовите метод dismiss() на экземпляре loading.

      Можно вызвать функцию onDidDismiss, она назначит 
      обработчик события выключения индикатора загрузки,
      и позволит выполнить какие-то завершающие действия.

  ▪ Использование

    async function presentLoading() {
      const loadingController = document.querySelector('ion-loading-controller');
      await loadingController.componentOnReady();

      const loading = await loadingController.create({
        content: 'Hellooo',
        duration: 2000
      });
      return await loading.present();
    }

    async function presentLoadingWithOptions() {
      const loadingController = document.querySelector('ion-loading-controller');
      await loadingController.componentOnReady();

      const loading = await loadingController.create({
        spinner: 'hide',
        duration: 5000,
        content: 'Please wait...',
        translucent: true,
        cssClass: 'custom-class custom-loading'
      });
      return await loading.present();
    }

  ▪ Свойства

    ▪ content
      - Опциональный текст для показа в индикаторе загрузки.
      - Атрибуты: 

        ▪ content
               
      - Тип: string

    ▪ cssClass
      - Доп.классы с кастомным CSS, через пробел.
      - Атрибуты: 

        ▪ css-class
               
      - Тип: string

    ▪ dismissOnPageChange
      - [false] Выключить индикатор загрузки при смене страницы.
      - Атрибуты: 

        ▪ dismiss-on-page-change
               
      - Тип: boolean

    ▪ duration
      - Задать кол-во ms после создания для автоматического выключения.
      - Атрибуты: 

        ▪ duration
               
      - Тип: number

    ▪ enableBackdropDismiss
      - [false] Выключить индикатор загрузки при клике по фону.
      - Атрибуты: 

        ▪ enable-backdrop-dismiss
               
      - Тип: boolean

    ▪ enterAnimation
      - Анимация появления.
      - Атрибуты: 

        ▪ enter-animation
               
      - Тип: AnimationBuilder

    ▪ keyboardClose
      - Блурить ли input'ы при загрузке, и скрывать ли клавиатуру
      - Атрибуты: 

        ▪ keyboard-close
               
      - Тип: boolean

    ▪ leaveAnimation
      - Анимация закрытия.
      - Атрибуты:

        ▪ leave-animation

      - Тип: AnimationBuilder

    ▪ overlayId
      - Уникальный ID экземпляра (для внутреннего использования).
      - Атрибуты:

        ▪ overlay-id

      - Тип: number

    ▪ showBackdrop
      - [true] Показывать ли фон позади индикатора загрузки?
      - Атрибуты: 

        ▪ show-backdrop
               
      - Тип: boolean

    ▪ spinner
      - Название спиннера: lines / lines-small / dots / bubbles / circles / crescent.
      - Атрибуты: 

        ▪ spinner
               
      - Тип: string

    ▪ translucent
      - [false] Сделать ли индикатор загрузки полупрозрачным?
      - Атрибуты: 

        ▪ translucent
               
      - Тип: boolean

    ▪ willAnimate
      - [true] Включить ли анимацию индикатора загрузки?
      - Атрибуты: 

        ▪ will-animate
               
      - Тип: boolean

  ▪ Методы

    ▪ dismiss()       | Выключить индикатор загрузки
    ▪ onDidDismiss()  | Получить промис, который резолвится после выключения индикатора загрузки
    ▪ onWillDismiss() | Получить промис, который резолвится перед выключением индикатора загрузки
    ▪ present()       | Включить индикатор загрузки после того, как он был создан

  ▪ События

    ▪ ionLoadingDidDismiss    | Emitted after the loading has dismissed.
    ▪ ionLoadingDidLoad       | Emitted after the loading has loaded.
    ▪ ionLoadingDidPresent    | Emitted after the loading has presented.
    ▪ ionLoadingDidUnload     | Emitted after the loading has unloaded.
    ▪ ionLoadingWillDismiss   | Emitted before the loading has dismissed.
    ▪ ionLoadingWillPresent   | Emitted before the loading has presented.

> ion-menu       

  Навигационное меню, которое слайдится с края экрана.

  ▪ Описание

    По умолчанию, меню выезжает слева. Но это можно
    изменить.

    Меню будет отображатсья по-разному, в зависиости
    от режима отображения (mode - ios, md). Но для 
    каждого меню режим отображения можно задать и вручную.

    Элемент меню должен лежать рядом с корневым элементом
    контента, на том же уровне.

    Можно добавить любое кол-во меню.
    Меню можно контролировать программно с помощью
    MenuController.

  ▪ Использование

    <ion-app>
      <ion-menu side="start">
        <ion-header>
          <ion-toolbar color="secondary">
            <ion-title>Left Menu</ion-title>
          </ion-toolbar>
        </ion-header>
      </ion-menu>

      <ion-menu side="end">
        <ion-header>
          <ion-toolbar>
            <ion-title>Hola</ion-title>
          </ion-toolbar>
        </ion-header>

        <ion-content padding>
          hola macho
        </ion-content>
      </ion-menu>

      <div class="ion-page" main>
        <ion-header>
          <ion-toolbar>
            <ion-title>Menu - Basic</ion-title>
          </ion-toolbar>
        </ion-header>
      </div>

    </ion-app>
    <ion-menu-controller></ion-menu-controller>

  ▪ Свойства

    ▪ contentId
      - ID content'а, которое должно использовать меню.
      - Атрибуты: 

        ▪ content-id
               
      - Тип: string

    ▪ disabled
      - [false] Выключено ли меню?
      - Атрибуты: 

        ▪ max-edge-start
               
      - Тип: number

    ▪ maxEdgeStart
      - Максимальный размер свайпа, при привышении которого меню не вылезет.
      - Атрибуты: 

        ▪ max-edge-start
               
      - Тип: number

    ▪ menuId
      - ID для меню.
      - Атрибуты: 

        ▪ menu-id
               
      - Тип: string

    ▪ side
      - [start] На какой стороне экрана надо разместить меню.
      - Атрибуты: 

        ▪ side
               
      - Тип: string

    ▪ swipeEnabled
      - [true] Включить доставание меню свайпом?
      - Атрибуты: 

        ▪ swipe-enabled
               
      - Тип: boolean

    ▪ type
      - Режим отображения меню. Доступные опции: "overlay", "reveal", "push".
      - Атрибуты: 

        ▪ type
               
      - Тип: string

  ▪ Методы

    ▪ close()     | Закрыть меню
    ▪ getWidth()  | Получить ширину меню
    ▪ isActive()  | Активно ли меню?
    ▪ isOpen()    | Раскрыто ли меню?
    ▪ open()      | Раскрыть меню?
    ▪ setOpen()   | ???
    ▪ toggle()    | Переключить меню

  ▪ События

    ▪ ionClose        | Возбуждается, когда меню закрыто
    ▪ ionMenuChange   | Возбуждается, когда состояние меню меняется
    ▪ ionOpen         | Возбуждается, когда меню открыто

> ion-menu-button

  Автосоздание кнопки-иконки для закрытия/открытия меню на странице.

  ▪ Свойства

    ▪ mode 
      - В каком режиме (md или ios) отображать alert.
      - Атрибуты: 

        ▪ mode
               
      - Тип: string

    ▪ color 
      - Какой использовать цвет из палитры цветов вашего приложения.
        Опции по умолчанию: "primary", "secondary", "tertiary", 
        "success", "warning", "danger", "light", "medium", "dark".
      - Атрибуты: 

        ▪ color
               
      - Тип: string

    ▪ autoHide
      - Автоматически прятать кнопку меню, если соотв.меню не активно.
      - Атрибуты: 

        ▪ auto-hide
               
      - Тип: boolean

    ▪ menu
      - Опциональное св-во для связывания с меню по menuId, м.б.: left, right
        Используется, чтобы найти правильное меню для переключения.
      - Атрибуты: 

        ▪ menu
               
      - Тип: string

> ion-menu-toggle

  Переключатель состояниям меню (открыто/закрыто)

  ▪ Описание

    По умолчанию, видим только тогда, когда выбранное
    меню активно. 

    А меню считается активным, когда оно может быть
    открыто и закрыто.

    Когда меню disabled, или представлено в качестве
    split-pane, меню помечается, как неактивное,
    и ion-menu-toggle прячет сам себя.

    В случае, если требуется оставлять ion-menu-toggle
    видимым всегда, можно установить свойство autoHide
    в false.

  ▪ Свойства

    ▪ menu
      - Опциональное св-во для связывания с меню по menuId, м.б.: start, end
        Используется, чтобы найти правильное меню для переключения.
      - Атрибуты: 

        ▪ menu
               
      - Тип: string

    ▪ autoHide
      - [true] Автоматически прятать контент, когда соотв.меню не активно.
      - Атрибуты: 

        ▪ menu
               
      - Тип: string      

> ion-modal           

  Диалог поверх контента (полноэкранный), который должен быть завершён для продолжения работы с приложением.

  ▪ Описание

    Бывает полезен во многих случаях. Например, как 
    select-компонент, когда есть много опций, из которых
    надо выбирать, или при фильтрации элементов списка,
    и во многих других случаях.

    ▪ Создание

      Модальные окна могут создаваться с помощью
      Modal Controller. Их можно кастомизировать
      передавая конфиг с опциями в метод create
      данного контроллера.

  ▪ Использование

    async function presentModal() {
      // initialize controller
      const modalController = document.querySelector('ion-modal-controller');
      await modalController.componentOnReady();

      // create component to open
      const element = document.createElement('div');
      element.innerHTML = `
      <ion-header>
        <ion-toolbar>
          <ion-title>Super Modal</ion-title>
        </ion-toolbar>
      </ion-header>
      <ion-content>
        <h1>Content of doom</h1>
        <div>Here's some more content</div>
        <ion-button class="dismiss">Dismiss Modal</ion-button>
      </ion-content>
      `;

      // listen for close event
      const button = element.querySelector('ion-button');
      button.addEventListener('click', () => {
        modalController.dismiss();
      });

      // present the modal
      const modalElement = await modalController.create({
        component: element
      });
      modalElement.present();
    }

  ▪ Свойства

    ▪ component
      - Какой компонент отображать внутри модалки.
      - Атрибуты: 

        ▪ component
               
      - Тип: string

    ▪ componentProps
      - Какие данные передать в компонент в модалки.
      - Атрибуты: 

        ▪ component-props
               
      - Тип: ComponentProps

    ▪ cssClass
      - Доп.классы с кастомным CSS, через пробел.
      - Атрибуты: 

        ▪ css-class
               
      - Тип: string

    ▪ delegate
      - 
      - Атрибуты: 

        ▪ delegate
               
      - Тип: FrameworkDelegate

    ▪ enableBackdropDismiss
      - [false] Выключить модалку при клике по фону.
      - Атрибуты: 

        ▪ enable-backdrop-dismiss
               
      - Тип: boolean

    ▪ enterAnimation
      - Анимация появления.
      - Атрибуты: 

        ▪ enter-animation
               
      - Тип: AnimationBuilder

    ▪ keyboardClose
      - Блурить ли input'ы при загрузке, и скрывать ли клавиатуру
      - Атрибуты: 

        ▪ keyboard-close
               
      - Тип: boolean

    ▪ leaveAnimation
      - Анимация закрытия.
      - Атрибуты:

        ▪ leave-animation

      - Тип: AnimationBuilder

    ▪ overlayId
      - Уникальный ID экземпляра (для внутреннего использования).
      - Атрибуты:

        ▪ overlay-id

      - Тип: number

    ▪ showBackdrop
      - [true] Показывать ли фон позади модалки?
      - Атрибуты: 

        ▪ show-backdrop
               
      - Тип: boolean

    ▪ willAnimate
      - [true] Включить ли анимацию модалки?
      - Атрибуты: 

        ▪ will-animate
               
      - Тип: boolean

  ▪ Методы

    • dismiss()         | Удалить модалку
    • onDidDismiss()    | Возвращает промис, который резолвится после закрытия модалки; принимает callback
    • onWillDismiss()   | Возвращает промис, который резолвится перед закрытием модалки; принимает callback
    • present()         | Показать модалку после того, как она была создана

  ▪ События

    ▪ ionModalDidDismiss   | Emitted after the modal has dismissed.
    ▪ ionModalDidLoad      | Emitted after the modal has loaded.
    ▪ ionModalDidPresent   | Emitted after the modal has presented.
    ▪ ionModalDidUnload    | Emitted after the modal has unloaded.
    ▪ ionModalWillDismiss  | Emitted before the modal has dismissed.
    ▪ ionModalWillPresent  | Emitted before the modal has presented.

> ion-nav             

  Отдельный компонент для загрузки произвольных компонентов и добавления в отдельный стек.

  ▪ Описание

    В отличие от RouterOutlet, Nav не связан с конкретным
    роутером. При загрузке компонента Nav, и добавления
    какого-либо компонента в стек, это никак не изменит
    роутеры приложения.

    Это полезно, например, когда у вас есть модалка, 
    для которой требуется сделать отдельную навигацию,
    не связанную с основной навигацией приложения.

  ▪ Свойства

    ▪ animated
      - Должен ли nav анимировать компоненты, или нет?
      - Атрибуты: 

        ▪ animated
               
      - Тип: boolean

    ▪ delegate
      - 
      - Атрибуты: 

        ▪ delegate
               
      - Тип: FrameworkDelegate

    ▪ root
      - Корневой компонент, куда грузить Nav.
      - Атрибуты: 

        ▪ root
               
      - Тип: string

    ▪ rootParams
      - Параметры для передачи root-компоненту.
      - Атрибуты: 

        ▪ root-params
               
      - Тип: ComponentProps

    ▪ swipeBackEnabled
      - Включить ли swipe-to-go-back?
      - Атрибуты: 

        ▪ swipe-back-enabled
               
      - Тип: boolean

  ▪ Методы

    ▪ canGoBack()     | 
    ▪ getActive()     | 
    ▪ getByIndex()    | 
    ▪ getLength()     | 
    ▪ getPrevious()   | 
    ▪ getRouteId()    | 
    ▪ insert()        | 
    ▪ insertPages()   | 
    ▪ isAnimating()   | 
    ▪ pop()           | 
    ▪ popTo()         | 
    ▪ popToRoot()     | 
    ▪ push()          | 
    ▪ removeIndex()   | 
    ▪ setPages()      | 
    ▪ setRoot()       | 
    ▪ setRouteId()    | 

  ▪ События

    ▪ ionNavDidChange   | Event fired when the nav has changed components
    ▪ ionNavWillChange  | Event fired when the nav will components
    ▪ ionNavWillLoad    | Event fired when Nav will load a component

> ion-nav-pop         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-nav-push        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-nav-set-root    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-note            

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-picker          

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-picker-column   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-popover         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-radio         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-radio-group   

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-range         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-range-knob    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-refresher     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-reorder       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-reorder-group 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-ripple-effect 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-route         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-route-redirect

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-router        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-router-outlet 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-scroll        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-searchbar     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-segment       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-segment-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-select        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-select-option 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-select-popover

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-show-when     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-skeleton-text 

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-slide         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-slides        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-spinner       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-split-pane    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tab       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tab-button

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tabbar    

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-tabs      

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-text          

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-textarea      

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-thumbnail     

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-title         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-toast         

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-toggle        

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-toolbar       

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

> ion-virtual-scroll

  Не-fullscreen модалка с текстом и элементами формы

  ▪ Описание

  ▪ Использование

  ▪ Свойства

  ▪ Методы

  ▪ События

  
  
> ion-action-sheet-controller 

  Программный контроль над компонентом action sheet.

  ▪ Описание

    Action Sheet можно создать или закрыть с помощью
    этого контроллера.

  ▪ Методы

    ▪ create()  | Создать Action Sheet, передав опции
    ▪ dismiss() | Закрыть Action Sheet
    ▪ getTop()  | Получить самый недавний Action Sheet

> ion-alert-controller

  Программный контроль над компонентом alert.

  ▪ Описание

    Alert'ы можно создавать и убирать с помощью этого
    контроллера.

  ▪ Использование

    async function presentAlert() {
      const alertController = document.querySelector('ion-alert-controller');
      await alertController.componentOnReady();

      const alert = await alertController.create({
        header: 'Alert',
        subHeader: 'Subtitle',
        message: 'This is an alert message.',
        buttons: ['OK']
      });
      return await alert.present();
    }


  ▪ Методы

    ▪ create()  | Создать Alert, передав опции в create
    ▪ dismiss() | Закрыть открытый Alert
    ▪ getTop()  | Получить самый недавний Alert

> ion-animation-controller

  Используется для создания экземпляра анимации.

  ▪ Методы

    ▪ create()  | Создать экземпляр анимации

> ion-loading-controller 

  Используется для контроля над компонентом loading.

  ▪ Описание

    Компоненты loading могут быть созданы и уничтожены
    с помощью loading controller'а.

  ▪ Использование

    async function presentLoading() {
      const loadingController = document.querySelector('ion-loading-controller');
      await loadingController.componentOnReady();

      const loadingElement = await loadingController.create({
        content: 'Please wait...',
        spinner: 'crescent',
        duration: 2000
      });
      return await loadingElement.present();
    }

  ▪ Методы

    ▪ create()  | Создать экран загрузки, передав конфиг с опциями
    ▪ dismiss() | Уничтожить экран загрузки
    ▪ getTop()  | Получить самый недавний экран загрузки

> ion-menu-controller

  Используется для контроля над Menu.

  ▪ Описание

    Его методы могут быть использованы для отображения меню,
    включения меню, переключения меню, и так далее.

    Контроллен может получить ссылку на меню по его side,
    id, либо он возьмёт первое по списку меню.

  ▪ Методы

    ▪ _register()         | 
    ▪ _setActiveMenu()    | 
    ▪ _setOpen()          | 
    ▪ _unregister()       | 
    ▪ close()             | Закрыть либо указанное меню, либо все открытые   
    ▪ createAnimation()   | 
    ▪ enable()            | Включить меню (и выключить все прочие на этой side)
    ▪ get()               | Получить указанное меню, или первое попавшееся, или включенное на указанной side; вернёт null если не найдено
    ▪ getMenus()          | Получить массив всех меню
    ▪ getOpen()           | Получить открытое меню, иначе вернёт null
    ▪ isAnimating()       | Вернёт true, если сейчас работает анимация любого из меню
    ▪ isEnabled()         | Вернёт true, если указанное меню включено
    ▪ isOpen()            | Вернёт true, либо если указаннное меню открыто, либо если любое меню открыто
    ▪ open()              | Открыть меню
    ▪ registerAnimation() | 
    ▪ swipeEnable()       | Вкл/Выкл возможность открывать/закрывать меню свайпом
    ▪ toggle()            | Переключить меню, если открыто - закрыть, и наоборот

> ion-menu-controller

  Программно контролирует компоненты modal.

  ▪ Описание

    Позволяет создавать и удалять модалки.

  ▪ Методы

    ▪ create()    | Создать модалку, передав конфиг с опциями
    ▪ dismiss()   | Удалить модалку
    ▪ getTop()    | Получить последнюю открытую модалку
    



А11. Ionic CLI (справочник)
--------------------------------------

  #

--------------------------------------

>


Это про командную строку.


А12. Ionic Native (справочник)
--------------------------------------

  #

--------------------------------------

>


Это про доступ к нативному функционалу,
типа камеры, файловой системе, и прочему.






