////=================================================////
////                                                 ////
////                     Capacitor                   ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  # Cordova

    • Сайт
      
        https://capacitor.ionicframework.com/

    • Документация

        https://capacitor.ionicframework.com/docs/

    • Исходный код

        https://github.com/ionic-team/capacitor

    • Форум, чат

        https://forum.getcapacitor.com/
        https://getcapacitor.herokuapp.com/

    • Демонстрация (android, ios, osx, windows app за 5 минут)

        https://www.youtube.com/watch?v=x2jRs7Qqai8
        

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы Capacitor

    А1. Введение в Capacitor
    А2. Основы Capacitor
    А3. Разработка под iOS
    А4. Разработка под Android
    А5. Разработка под Web (Progressive Web Apps)
    А6. Разработка под Electron
    А7. Плагины Capacitor'а
    А8. Capacitor APIs

  # X.  Практика и наработки

    X1. 


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Введение в Capacitor
--------------------------------------
Подоглавление:

  # Capacitor: Native Progressive Web Apps

    ▪ Одно приложение для всех основных платформ
    ▪ Кроссплатформенная среда для выполнения веб-приложений
    ▪ Native Progressive Web Apps: следующий шаг эволюции гибридов
    ▪ WEB API для доступа к нативным фичам платформ
    ▪ Добавление нативной функциональности через плагины
    ▪ Духовный наследник Cordova
    ▪ Можно добавить в любой JS-проект
    ▪ Capacitor поставляется без какого-либо UI

  # Что нужно Capacitor'у для разработки под каждую платформу

    ▪ Общие зависимости
    ▪ Зависимости для разработки под iOS
    ▪ Зависимости для разработки под Android
    ▪ Зависимости для разработки PWA
    ▪ Зависимости для разработки под Electron

  # Установка Capacitor

    ▪ Два способа установить Capacitor
    ▪ Настоятельно рекомендуется использовать мобильный frontend-фреймворк
    ▪ Перед установкой установи все зависимости для необходимых платформ
    ▪ Добавление Capacitor'а в существующее веб-приложение
    ▪ Испольозвание Capacitor Starter с Ionic Framework
    ▪ Старт нового проекта с Capacitor

  # Использование Capacitor вместе с Ionic

    ▪ Создание проекта на Ionic
    ▪ Сборка ionic-проекта для создания www
    ▪ Установка Capacitor
    ▪ Удаление плагина Cordova Splash
    ▪ Инициация Capacitor'а инфой о проекте
    ▪ Добавление необходимых платформ
    ▪ Открытие IDE'шек для сборки под добавленные платформы
    ▪ Синхронизация приложения с Capacitor
    ▪ Использование Ionic Native

--------------------------------------

> Capacitor: Native Progressive Web Apps

  • Одно приложение для всех основных платформ

    Главная идея Capacitor в том, что вы пишете одно
    веб-приложение, которое сможет выполняться на
    всех основных платформах.

    Разумеется, для каждой из платформ в приложениях
    необходимо предусмотреть сооветствующие различия.

    Но представьте, какие колоссальные выгоды дает
    эта технология. Больше не нужно отдельно разрабатывать
    сайт, приложения для iOS/Android, приложения для 
    OSX/Windows. Какая колоссальная экономия времени!

    Отлично подходит для стартапов.

  • Кроссплатформенная среда для выполнения веб-приложений

    Capacitor, это кроссплатформенная среда для выполнения
    приложений, позволяющая делать сборки из веб-приложений,
    которые могут нативно выполняться на iOS, Android, 
    Electron и в Web.

  • Native Progressive Web Apps: следующий шаг эволюции гибридов

    Разработчики Capacitor говорят о нём, как о следующим витке 
    эволюции после гибридных приложений, и называют эту
    технологию "Native Progressive Web Apps" - нативные
    прогрессивные веб-приложения.

  • WEB API для доступа к нативным фичам платформ

    Capacitor предоставляет сфокусированный на web API, который,
    с одной стороны, позволяет приложению оставаться настолько
    близко к стандартам web'а, насколько это возможно, а с другой
    стороны, даёт доступ к нативной функциональности устройств
    на перечисленных выше платформах.

  • Добавление нативной функциональности через плагины

    В Capacitor можно легко добавлять нативной функциональности
    через простой Plugin API for Swift на iOS, Java на Android,
    и JavaScript для Web.

  • Духовный наследник Cordova

    Capacitor является духовным наследником Apache Cordova и 
    Adobe PhoneGap, вдохновлённым другими популярными 
    кроссплатформенными инструментами, такими как React Native
    и Turbolinks. 

    Но Capacitor полностью сфокусирован на задаче позволить
    легко и эффективно запускать современные веб-приложения
    на всех основных платформах.

    Capacitor имеет обратную совместимость для многих
    Cordova-плагинов.

  • Можно добавить в любой JS-проект

    Начать работать с Capacitor легко - его можно прость добавить
    в любой существующий JS-проект, и всё.

  • Capacitor поставляется без какого-либо UI

    Capacitor, это кроссплатформенная среда для выполнения
    приложений. Он заточен именно под это. Никакого UI
    с ним не поставляется.

> Что нужно Capacitor'у для разработки под каждую платформу

  • Общие зависимости

    ▪ NodeJS >= 8.6.0
    ▪ NPM >= 5.6.0

  • Зависимости для разработки под iOS

    ▪ Mac with Xcode >= 9
    ▪ CocoaPods
    ▪ Xcode Command Line Tools

    Как правило, последняя версия Capacitor всегда поддерживает
    две последние версии iOS.

    Разработчики Capacitor обещают, что скоро можно будет
    использовать Ionic Pro для сборки проектов для iOS
    (это нужно тем, кто сидит на винде).

  • Зависимости для разработки под Android

    ▪ Java 8 JDK (Java 9 не поддерживается пока)
    ▪ Android SDK
    ▪ Android Studio (не обязателен, но рекомендуется)
    
    Capacitor поддерживает API level 21 или выше,
    иначе говоря, Android >= 5.
    На январь 2018, Android >= 5 установлен на 75% устройств,
    и этот процент продолжает быстро расти, поскольку 
    Android 4 считается на данный момент сильно устаревшим.

    Также Capacitor требует наличие Android WebView с 
    Chrome версии >= 50.

  • Зависимости для разработки PWA

    Для разработки прогрессивных веб-приложений Capacitor'у
    нужен JS-проект с системой загрузки модулей, например,
    webpack.

  • Зависимости для разработки под Electron

    Coming soon.
    На данный момент, поддержка Eletron ещё не готова.

> Установка Capacitor

  • Два способа установить Capacitor

    Capacitor был изначально спроектирован именно для 
    добавления в существующий frontend-проект. Но 
    поставляется с простым стартовым шаблоном проекта,
    с которого можно начать.

    Короче, есть два способа установить Capacitor:

      ▪ Добавить Capacitor в существующие frontend-проект (рекомендуется).
      ▪ Начать новый проект.

  • Настоятельно рекомендуется использовать мобильный frontend-фреймворк

    Разработчики Capacitor настоятельно рекомендуют использовать
    его вместе с любым мобильным frontend-фреймворком, например,
    с Ionic. 

    Ведь Capacitor идёт без какого-либо UI, и самому пилить
    этот UI (изобратеть велосипед) не стоит, лучше использовать
    готовый фреймворк.

  • Перед установкой установи все зависимости для необходимых платформ

    Перед установкой Capacitor надо убедиться, что установлены
    все зависимости для всех необходимых платформ.

    Особенно важно проследить, что CocoaPods для iOS обновлён
    командой pod repo update (если у вас Mac).

  • Добавление Capacitor'а в существующее веб-приложение

    Capacitor изначально был спроектирован именно для того,
    чтобы его добавляли в существующие веб-приложения.

    Сначала устанавливаем в проект сам Capacitor:

      cd <папка с приложением>
      npm install --save @capacitor/core @capacitor/cli

    Потом инициируем Capacitor инфой о проекте.
    Эта команда также установит нативные платформы по умолчанию:

      npx cap init

      Команда попросит ввести имя приложения,
      id приложения (который используется в основном для android),
      и путь к каталогу с приложением.

    *Примечание:

      npx - это новая утилита, доступная в npm >= 5, которая
      позволяет выполнять локальные бинарники/скрипты,
      избегая глобальных установок.

  • Испольозвание Capacitor Starter с Ionic Framework

    Разработчики Capacitor обещают, что скоро Capacitor Starter
    будет интегрирован в Ionic CLI.

    А пока что, создайте новое ionic-приложение, используя
    ionic start, а затем просто следуйте описанным выше 
    шагам и добавьте в это приложение Capacitor.

  • Старт нового проекта с Capacitor

    Вместе с Capacitor поставляется какой-то шаблон 
    для веб-приложения, с которым и можно начать проект
    (но не рекомендуется).

    Эта команда создаст очень простое стартовое приложение
    без UI библиотеки:

      npx @capacitor/cli create

> Использование Capacitor вместе с Ionic

  • Создание проекта на Ionic

    ionic start myApp tabs
    cd myApp

    Когда попросит добавить Cordova, выбрать no.

  • Сборка ionic-проекта для создания www

    Выполнить build хотя бы разок, чтобы папка
    www была создана.

    npm run build

  • Установка Capacitor

    Далее установить Capacitor в свой 
    проект:

      npm install --save @capacitor/cli @capacitor/core

  • Удаление плагина Cordova Splash

    Capacitor конфликтует с плагином Cordova Splashscreen.
    Поэтому, его надо выпилить:

      npm uninstall --save cordova-plugin-splashscreen

  • Инициация Capacitor'а инфой о проекте

    npx cap init [appName] [appId]

    ▪ appName - имя приложения
    ▪ appId - реверс домен + имя приложения (напр.: com.example.app)

  • Добавление необходимых платформ

    npx cap add ios
    npx cap add android

  • Открытие IDE'шек для сборки под добавленные платформы

    Если ты на винде, то IDE для ios ты не откровешь.
    А если ты на Mac, то откроешь обе, если установлены.

      npx cap open ios
      npx cap open android    

  • Синхронизация приложения с Capacitor

    Каждый раз после выполнения npm run build, которая 
    изменяет веб-директорию проекта (www), тебе необходимо
    копировать эти изменения далее в папки с платформами,
    для этого:

      npx cap copy

  • Использование Ionic Native

    Capasitor поддерживает Ionic Native. В настоящий момент,
    последний содержит только Cordova-плагины. Так что, 
    каждый раз, как ты будешь находить обёртку Ionic Native,
    которую хотел бы использовать, устанавливай её, а затем
    устанавливай соответствующий Cordova-плагин:

      npm install your-cordova-plugin
      npx cap update

    Подробнее это описано в этой методичке, в главе:
    "Использование плагинов от Cordova".


А2. Основы Capacitor
--------------------------------------
Подоглавление:

  # Описание процесса разработки

    ▪ Разработка и сборка приложения
    ▪ Копирование web-ресурсов
    ▪ Запуск нативной IDE
    ▪ Периодическое обновление Capacitor-приложения и плагинов
 
  # Запуск нативных IDE из командной строки
  # Сборка приложения

    ▪ Три этапа: сборка веб-кода, копирование, сборка Capacitor-приложения
    ▪ Сборка веб-кода
    ▪ Копирование собранного веб-кода на платформы
    ▪ Сборка Capacitor-приложения для каждой платформы

  # Запуск приложения

    ▪ Запуск под iOS
    ▪ Запуск под Android
    ▪ Запуск Progressive Web App
    ▪ Запуск под electron

  # Использование плагинов от Cordova

    ▪ Полная совместимость
    ▪ Установка плагинов от Cordova
    ▪ Настройка плагинов от Cordova
    ▪ Проблемы совместимости

  # Настройка приложения

    ▪ Концепция: "один код, много настроек"
    ▪ Всё же есть некоторые общие для всех платформ настройки
    ▪ Как настроить платформы iOS и Android (ссылки)

  # Прогрессивные веб-приложения

    ▪ Capacitor поддерживает PWA
    ▪ Что такое Progressive Web Apps (PWA)
    ▪ Capacitor и PWA
    ▪ Добавление поддержки PWA в ваше Capacitor-приложение
      ▪ Манифест PWA
      ▪ Service Workers
    ▪ Производительность PWA
    ▪ Работа нативно и в web

--------------------------------------

> Описание процесса разработки

  • Разработка и сборка приложения

    Capacitor превращает ваше веб-приложение в бинарники
    нативных приложний для каждойплатформы. Таким образом,
    большая часть вашей работы будет состоять в разработке
    и сборке нацеленного для работы на смартфонах веб-
    приложения.

    Ваше приложение будет взаимодействовать с нативным
    функционалом соответствующих платформ (например, камерой) 
    либо через Capacitor API, либо через уже существующие
    Cordova-плагины, совместимые с Capacitor.

    В процессе, и на финальном этапе, вам понадобится собрать
    ваше приложение с помощью команды:

      npm run build

    Если вы используете фреймворк, то следуйте инструкциям
    по сборке вашего фреймворка. Например, если это Ionic, то:

      ionic build

  • Копирование web-ресурсов

    Когда вы будете готовы запустить ваше приложение на 
    устройстве или симуляторе, скопируйте ваши, уже собранные
    веб-ресурсы в соответствующие платформы:

      npx cap copy

  • Запуск нативной IDE

    Capacitor использует нативные IDE для сборки, симуляции
    и запуска вашего приложения. Чтобы открыть их:

      npx cap open

  • Периодическое обновление Capacitor-приложения и плагинов

    Периодически необходимо обновлять зависимоси и плагины
    вашего Capacitor-приложения.

    Чтобы обновить зависимости приложения:

      npx cap update

    Чтобы установить новые плагины (включая плагины от Cordova):

      npm install really-cool-plugin
      npx cap update

> Запуск нативных IDE из командной строки

  Capacitor использует нативную IDE для каждой платформы,
  чтобы обеспечивать необходимую настройку, сборку,
  тестирование и деплой приложений.

  Для разработки под iOS, вам необходим Xcode >= 9.
  А для Android вам нужен Android Studio >= 3.

  Обе IDE можно открыть вручную, а можно командой:

    npx cap open

  Нюанс заключается в том, что Xcode нельзя установить
  на Windows. Поэтому, обе IDE можно открыть только
  в OSX на Mac. А на Windows можно открыть только
  Android Studio.

  Можно с помощью этих команд открывать конкретные IDE:

    npx cap open ios
    npx cap open android

> Сборка приложения

  • Три этапа: сборка веб-кода, копирование, сборка Capacitor-приложения

    Сборка Capacitor-приложения включает 3 этапа.

    На первом этапе надо собрать frontend приложения с помощью
    системы сборки webpack:

      npm run build

    На втором этапе надо скопировать собранный фронт в папки
    поддерживаемых приложением платформ:

      npx cap copy          | скопировать на все платформы
      npx cap copy android  | скопировать на платформу android
      npx cap copy ios      | скопировать на платформу iox

    На третьем этапе надо открыть нативную IDE каждой платформы
    и в ней выполнить сборку Capacitor-приложения для соотв.
    платформы. IDE можно открыть вручную или командами:

      npx cap open ios
      npx cap open android

  • Сборка веб-кода

    Capacitor из коробки не предоставляет средств для сборки
    веб-кода. Поэтому, если вы используете какой-
    нибудь фреймворк (например, Ionic), следуйте его 
    инструкциям по сборке кода.

    Чтобы упростить себе жизнь, можно добавить в package.json
    вашего проекта скрипт "build", где прописать команду,
    которая будет собирать ваш фронт. Примерно так это
    выглядит:

      {
        "scripts": {
          "build": "command-to-build (ex: webpack, tsc, babel, etc.)"
        }
      } 

    Сделав это, для сборки фронта можно будет просто
    выполнять команду:

      npm run build   

  • Копирование собранного веб-кода на платформы

    Когда вы собрали фронт, результаты необходимо скопировать
    на все поддерживаемые вашим проектом платформы командой:

      npx cap copy

    Делать это надо каждый раз после сборки веб-кода.
    Проще всего добавить эту команду конец скрипта build в 
    package.json.

  • Сборка Capacitor-приложения для каждой платформы

    ▪ iOS

      Включаем MacOS, запускаем Xcode, и собираем 
      Capacitor-приложение для iOS обычным для Xcode образом.

    ▪ Android

      Запускаем Android Studio, и собираем Capacitor-приложение
      для android обычным для Android Studio образом.

> Запуск приложения

  • Запуск под iOS

    Включаем MacOS, запускаем Xcode.
    В нём можно собирать приложение, смотрть в эмуляторе, 
    запускать на устройстве, обычным для Xcode образом.

  • Запуск под Android

    Запускаем Android Studio.
    В нём можно собирать приложение, смотрть в эмуляторе, 
    запускать на устройстве, обычным для Xcode образом.

  • Запуск Progressive Web App

    Вместе с Capacitor идёт минималистичный веб-сервер,
    через который можно смотреть своё веб-приложение.
    Запустить его можно так:

      npx cap serve

  • Запуск под electron

    (Coming soon)

> Использование плагинов от Cordova

  • Полная совместимость

    Capacitor полностью совместим с плагинами от Cordova.
    Использовать их в нём легко.

  • Установка плагинов от Cordova

    npm install <плагин>  | установка плагина через npm
    npx cap sync          | синхронизация проекта

  • Настройка плагинов от Cordova

    Capacitor не поддерживает установку переменных плагина
    при установке, авто-настройку плагина или хуки, 
    как это делает Cordova.

    В соответствии со своей философией Capacitor даёт 
    вам полный контроль над нативным кодом ваших приложений
    на установленных платформах (команда Capacitor считает,
    что в связи с этим, такие вещи, как хуки, не нужны).

    Если вашему плагину требуется установить какие-то
    переменные, или нужна какая-то настройка, вам придётся
    вручную произвести эту настройку через маппинг между
    plugin.xml и настройками iOS и Android.

    Подробнее об этом см.главы:
    "Настройка iOS"
    "Настройка Android"

  • Проблемы совместимости

    Плагины из следующего списка не совместимы с Capacitor,
    и для них у него имеются альтернативы. Эти плагины
    должны быть удалены из приложения:

      ▪ cordova-plugin-splashscreen

    Авторы Capacitor утверждают, что они протестировали 
    с оным многие, но не все плагины от Cordova. Поэтому,
    есть вероятность, что какие-то плагины могут не работать
    как надо.

> Настройка приложения

  • Концепция: "один код, много настроек"

    Capacitor проповедует идею: "один код, много настроек".
    Это значит, что каждую установленную платформу нужно
    настраивать отдельно. В отличие от Cordova, где на 
    все платформы в корне проекта был один абстрактный
    config.xml.

    Это важная вещь, потому что это значит, что Capacitor 
    требует, чтобы вы были больше вовлечены в настройку 
    нативных проектов, чем Cordova. Однако, команда
    Capacitor считает это правильным подходом, потому
    что так проще следовать уже существующим инструкциям
    для iOS/Android, получать помощь на Stack Overflow,
    и гибче и тоньше настраивать каждую из платформ,
    получая над ними больший контроль.

    Кроме того, поскольку настройка платформ в Capacitor
    не особо то отличается от оной при нативной разработке,
    существующие команды, занимающиеся нативной разработкой
    могут легко работать совместно с веб-разработчиками,
    при этом каждая команда будет использовать те инструменты
    и SDK, к которым они привыкли.

    Команда Capacitor верит, что веб-разработчики могут
    самостоятельно справиться с нативной настройкой платформ.
    А чтобы им помочь, в документации Capacitor есть отдельные
    главы, посвященные этой тематике.

  • Всё же есть некоторые общие для всех платформ настройки

    У Capacitor есть немного высокоуровневых настроек, 
    которые можно задать в capacitor.config.json
    В общем, они не затрагивают нативный функционал, 
    а лишь настраивают инструменты самого Capacitor.

    В настоящий момент, вот, что можно настраивать:

    {

      // Sets the directory of your built web assets. This is the directory that will be
      // used to run your app in a native environment
      "webDir": "public",

      // Whether to use capacitor.js as a bundle that is copied to your web code,
      // or require it to be bundled/imported through a typical
      // typescript/babel/webpack/rollup workflow.
      //
      // The starter project sets this to true, but if you're using Ionic or another framework,
      // you'll probably want this to be false (default is false)
      "bundledWebRuntime": false,

      // On Windows, we aren't able to automatically open Android Studio
      // without knowing the full path. The default is set to the default
      // Android Studio install path, but you may change it manually.
      "windowsAndroidStudioPath": 'C:\\Program Files\\Android\\Android Studio\\bin\\studio64.exe',

      // On Android, Capacitor loads your local assets using https
      // Chrome by default prevents loading files from a different scheme (i.e. from http)
      // This setting allows to mix content from different schemes
      "allowMixedContent": true

    }    


  • Как настроить платформы iOS и Android (ссылки)

    Подробнее об этом см.главы:
    "Настройка iOS"
    "Настройка Android"

> Прогрессивные веб-приложения

  ▪ Capacitor поддерживает PWA

    Capacitor имеет первоклассную поддержку прогрессивных
    веб-приложений, и делает простым делом сборку приложения,
    которое не только нативно запускается на iOS и Android,
    но и в качестве мобильной версии на web'е.

  ▪ Что такое Progressive Web Apps (PWA)

    Если говорить просто, то PWA - веб приложение, которое
    использует современные возможности, чтобы предоставлять
    пользователям схожий с использованием нативных приложений 
    опыт.

    Эти приложения деплоятся на традиционные веб-сервера,
    доступны по URL в браузере, и могут быть проиндексированы
    поисковыми машинами.

    Короче говоря, PWS - это просто ещё один термин для
    сайта, который был оптимизирован для использования
    с моибльных устройств, и который использует новые
    современные Web API, чтобы обеспечить функционал, схожий
    с оным в нативных приложениях, такой как пуш-уведомления
    и оффлайн-хранилище.

  ▪ Capacitor и PWA

    Capacitor имеет первоклассную поддержку прогрессивных
    веб-приложений, и нативных приложений. Это значит
    plugin bridge Capacitor'а поддерживает запуск как 
    в нативном контексте, так и в вебе, с большим кол-вом
    core-плагинов, доступных в обоих контекстах с абсолютно
    точно таким же API.

    Это значит, что вам нужно использовать @capacitor/core 
    в качестве зависимости как для нативных приложений, 
    так и для PWA, и Capacitor бесшовно когда надо вызывает 
    web-код, а когда надо нативный код.

    В дополнение, Capacitor предлагает набор возможностей
    и утилит для кастомизации приложения под ту или иную 
    платформу.

  ▪ Добавление поддержки PWA в ваше Capacitor-приложение

    Добавление поддержки PWA в любой существующий 
    фронтенд-проект, это просто. Просто добавьте
    файл с App Manifest и настройте Service Worker:

    ▪ Манифест PWA

      Во-первых, вам понадобится файл manifest.json, который
      должен быть в той же папке, что и index.html. В нём
      метаданные о вашем приложении, такие как название,
      цвета для темы, иконки. Эта информация будет 
      использоваться, например, когда ваше приложение 
      будет установлено на главном экране.

    ▪ Service Workers

      Далее, чтобы отправлять push-уведомления и хранить
      данные оффлайн, вам понадобится Service Worker. Он
      будет проксировать входящие/исходящие запросы
      вашего приложения и выполнять различные фоновые задачи
      для обработки и синхронизации данных.

      Service Workers классные штуки, но сложные. Писать их
      самостоятельно не рекомендуется. Вместо этого, взгляните
      на инструменты вроде Workbox, которые позволяют легко
      настроить и интегрировать в проект готовое решение.

      Подробнее про Service Workers можно почитать на MDN:
      https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers

  ▪ Производительность PWA

    PWA оцениваются по нескольким стандартам производительности,
    включая "Time to Interactive" и "First Meaningful Paint".

    Пробейте ваше приложение по PWA-чеклисту прежде, чем
    давать ему зелёныйсвет, и потестируйте его производительность
    в Lighthouse.

    Если вы хотите, чтобы веб-приложение на вашем текущем
    фронтенд-стеке соответствовало стандартам производительности,
    взгляните на Ionic Framework ~4.* 
    Он обладает библиотекой веб-компонентов, которые работают
    с несколькими популярными фронтенд-фреймворками, а не только
    с Angular.

  ▪ Работа нативно и в web

    Одна из ключевых фич Capacitor'а в возможности собирать
    одно приложение, которое работает как нативно (в app stores),
    так и на веб. Capacitor реализует это, организуя средний
    слой между сооветствующей платформой и APIs/плагинами,
    которые вы бы хотели использовать.

    Если ваше приложение делает запрос к нативному плагину, 
    который не имеет заменителя на web (например, SplashScreen.show()),
    приложение переварит такой запрос без каких-либо ошибок.
    Просто, вернётся промис с ошибкой, который надо будет все равно
    обработать.

    В дополнение, Capacitor JS API имеет функционал, позволяющий
    программно проверять доступность того или иного API.

    Например, если вашему приложению требуется камера, то перед
    тем, как её запрашивать, можно просто проверить, доступен
    ли API камеры. Если нет, то можно просто попросить пользователя
    загрузить файл:

    import { Capacitor } from '@capacitor/core';

    const isAvailable = Capacitor.isPluginAvailable('Camera');

    if (!isAvailable) {
      // Have the user upload a file instead
    } else {
      // Otherwise, make the call:
      Camera.getPhoto()
    }


А3. Разработка под iOS
--------------------------------------

  # Обзор процесса разработки под iOS

    ▪ Взаимодействие между JS и нативным кодом
    ▪ Нужен OSX, Xcode и CocoaPods
    ▪ Подготовка к началу разработки на iOS
    ▪ Создание iOS-приложения
    ▪ Открытие iOS-проекта в Xcode
    ▪ Запуск iOS-приложения
    ▪ Дальнейшие шаги

  # Настройка iOS

    ▪ Файл Info.plist, как главный конфиг iOS приложения
    ▪ Управление правами доступа
    ▪ Настройка entitlements
  
  # Обновление вашего Capacitor-проекта под iOS

    ▪ Обновления библиотеки Capacitor
    ▪ Обновление iOS-проекта
    
  # Кастомный нативный iOS-код
  
    ▪ Доступный из WebView нативный код
    ▪ Недоступный из WebView нативный код
  
  # Руководство по устранению неполадок в iOS приложениях

    ▪ Инструментарий для разработки под iOS
      ▪ Google
      ▪ Clean / Rebuild
      ▪ Удаление производных данных

    ▪ Error: Unable to export required Bridge JavaScript
    ▪ Error: Sandbox not in sync with the Podfile.lock
    ▪ Бесконечное индексирование
    ▪ CocoaPods: Failed to connect to GitHub

--------------------------------------

> Обзор процесса разработки под iOS

  • Взаимодействие между JS и нативным кодом

    Capacitor предоставляет нативную iOS-среду, которая позволяет
    разработчикам организовывать коммуникации между JS с одной,
    и кодом на Swift/Objective-C с другой.

  • Нужен OSX, Xcode и CocoaPods

    Capacitor-приложения на платформе iOS настраиваются и 
    управляются с помощью Xcode, а зависимости для них
    управляются менеджером CocoaPods.

  • Подготовка к началу разработки на iOS

    Сборка Capacitor-приложений на платформе iOS требует
    определённой среды разработки - OSX, Xcode >= 9,
    и Xcode command line tools.

    *Примечание: 

      Есть возможность разрабатывать и собирать
      Capacitor-приложения на iOS без мака - например, 
      использовать сервис Package из Ionic Pro. Подробнее
      надо читать документацию Ionic Pro.

      В принципе, можно работать через виртуальную машину.
      Поставить OSX >= 10.13.4, Xcode и всё остальное.
      Пробросить туда папку с проектом и работать.

  • Создание iOS-приложения

    Платформа для iOS устанавливается в любом новом 
    Capacitor-проекте по умолчанию.

    Если же вы добавляете Capacitor в существующий проект,
    вы можете вручную добавить платформу iOS этой командой:

      npx cap add ios
      npx cap sync      | обновляет зависимости, копирует www на ios-платформу

    Вместо sync можно выполнить copy. Она не выполняет обновление
    зависимостей, а лишь копирует www на ios-платформу:

      npx cap copy
  
  • Открытие iOS-проекта в Xcode

    Можно просто открыть Xcode, а в нём проект вручную.
    А можно сделать это из команднной строки:

      npx cap open ios

  • Запуск iOS-приложения

    Запустив Xcode и открыв в нём проект, просто нажмите
    кнопку "Play", чтобы запустить ваше приложение
    на симуляторе или устройстве.

  • Дальнейшие шаги

    Если ваше приложение нормально запустилось и работает,
    у вас есть все, чтобы продолжать его разработку.

    Используйте различные доступные API, плагины от
    Capacitor и Cordova, или кастомный нативный код,
    чтобы построить остальную часть вашего приложения.

> Настройка iOS

  • Файл Info.plist, как главный конфиг iOS приложения

    При разработке под iOS вам нужно привыкнуто к файлу
    Info.plist, который является главным конфигом для
    iOS-приложения. Файд будет часто обновляться:

      ▪ Новыми настройками, которые могут понадобиться
        Capacitor'у.

      ▪ Дополнительными настройками вашего приложения.

      ▪ Дополнительными настройками для разрешений,
        которые могут понадобиться вашему приложению.

    Наиболее простой способ отредактировать этот файл,
    это открыть ваш проект в Xcode (npx cap open ios),
    и отредактировать файл через список свойств прямо
    в Xcode.

    Каждая настройка в Info.plist имеет low-level имя
    параметра, и high-level имя. По умолчанию, редактро
    свойств в Xcode показывает high-level имена, но
    часто полезно изменить это, чтобы он показывал
    low-level имена. Чтобы это сделать, кликните правой
    кнопкой мыши где-нибудь в редакторе свойств и 
    переключите "Show Raw Keys/Values".

    Под капотом, Info.plist является обычным XML-файлом
    и может быть отредактирован вручную в любом текстовом
    редакторе. В этом случае, убедитесь, что используете
    low-level имена параметров в XML для значений <key>.

    Некоторые плагины и SDK будут показывать настройки,
    используя low-level ключи, другие же будут использовать
    high-level ключи. Привыкните ориентироваться в этом.

    Вот этот список ключей для Cocoa показывает многие
    возможные настройки, которые могут быть установлены
    в Info.plist:

      https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html

  • Управление правами доступа

    В отличие от Android, права доступа в iOS не должны быть
    определены заранее. Вместо этого, они запрашиваются в 
    момент использования определённого плагина или SDK.

    Однако, многие права доступа в iOS требуют наличия
    описаний (usage descriptions), определённых как раз
    в Info.plist. Это человеко-понятные описания каждого
    права доступа, которое может запрашивать ваше приложение.

    Посмотрите на Info.plust от Cocoa, найдите там ключи
    в формате "...UsageDescription", чтобы посмотреть, 
    как это всё выглядит на практике.

    Подробнее всё это описано в инструкции от apple:
    https://developer.apple.com/library/archive/qa/qa1937/_index.html

  • Настройка entitlements

    Entitlements - это флаги, которые становятся частью
    вашего подписанного приложения. Они позволяют вашему
    приложению получать доступ к разничным фичам, таким
    как APNS, iCloud, Siri, Apple Pay и так далее.

    Entitlements, это способ вашему приложению сказать: 
    "Эй! Я хочу использовать фичу X!", где X может быть 
    Apple Pay. И ваш provision profile должен соответствовать
    и говорить: "Это приложение может использовать фичу X.".

    Что такое provision profile? На iOS можно устанавливать
    только приложения, подписанные Apple. Но как быть 
    разработчикам? Помогает provision profile - это связь
    между устройством и аккаунтом разработчика. Во время
    разработки вы выбираете, какой девайс может запускать
    ваше приложение, и к каким сервисам оно может иметь
    доступ.

    В отличие от некоторых параметров или usege descriptions,
    entitlements настраиваются в специальном месте в Xcode,
    а не в Info.plist.

    Если плагину требуются определённые entitlements, 
    откройте ваше приложение в Xcode, кликните на имя
    вашего проекта в левой проектном меню, и выберите
    "Capabilities" в tab bar'е.

> Обновление вашего Capacitor-проекта под iOS

  Периодически, вам нужно будет обновять ваше iOS-приложение,
  включая версию Capacitor, используемую в вашем приложении,
  или использовать новые способы взаимодействия с Capacitor
  внутри кода вашего iOS-приложения (например, с новыми
  изменениями в iOS API). 

  • Обновления библиотеки Capacitor

    Чтобы обновить версию Capacitor в вашем приложении,
    просто выполните:

      npx cap update ios

    Это обновить iOS-платформу, включая core-библиотеки
    Capacitor и все используемые плагины.

  • Обновление iOS-проекта

    Чтобы обновить базовую структуру вашего Xcode-проекта,
    смотрите на шаблон приложения для iOS в репозитории
    Capacitor'а на github (последний стабильный релиз):

      https://github.com/ionic-team/capacitor/tree/master/ios-template

    Это позволит наглядно увидеть, что изменилось в структуре
    проекта в новой версии.

    В частности, необходимо регулярно проверять AppDelegate.swift:

      https://github.com/ionic-team/capacitor/blob/master/ios-template/App/App/AppDelegate.swift

    на изменения в событиях iOS.

> Кастомный нативный iOS-код

  Многие могут захотеть добавить в приложение какой-то
  Swift (или Objective-C) код, чтобы реализовать какие-то
  нативные фичи, при этом не утруждая себя созданием
  и публикацией соответствующего Capacitor-плагина.

  Авторы Capacitor настойчиво рекомендуют использовать
  Swift для создания Capacitor-плагинов, поскольку 
  экосистема iOS завязана на Swift, и легче будет
  найти помощь, поддержку и разработчиков. Но, в общем,
  Objective-C тоже сойдёт.

  Есть 2 способа добавить кастомный код в проект, в 
  зависимости от того, нужно ли вам иметь к нему 
  доступ из WebView.

  • Доступный из WebView нативный код

    Самый простой способ создать кастомный нативный код,
    к которому вам нужен доступ из WebView, это создать
    локальный Capacitor-плагин для него. В этом случае,
    создание плагина является таким же простым делом,
    как создание нового класса и регистрация его в 
    Capacitor.

      MyPlugin.swift
      -------
        @objc(MyPlugin)
        public class MyPlugin: CAPPlugin {
          @objc func echo(_ call: CAPPluginCall) {
            let value = call.getString("value") ?? ""
            call.success([
                "value": value
            ])
          }
        }

    Декораторы @objc нужны для того, чтобы убедиться, что
    среда выполнения Capacitor'а (которая должна использовать
    Objective-C для поддержки динамических плагинов) увидит его.

    Далее, вам понадобится создать новый Objective-C файл
    (с расширением .m, а не .h !), соответствующий вашему
    плагину. Например: MyPlugin.m

      * Важно! Для создания файла вы обязательно должны использовать
      диалог "New File" в Xcode. В процессе Xcode спросит у вас,
      нужно ли создать Bridging Header, и вы должны согласиться.

    Наконец, зарегистрируйте плагин, добавив необходимый 
    макрос для Capacitor-плагинов в ваш новый .m файл:

      #import <Capacitor/Capacitor.h>

      CAP_PLUGIN(MyPlugin, "MyPlugin",
        CAP_PLUGIN_METHOD(echo, CAPPluginReturnPromise);
      )

    Это делает ваш новый Capacitor-плагин MyPlugin, и метод
    echo из него, доступными в вашем веб-приложении.

  • Недоступный из WebView нативный код

    Если вам не надо, чтобы ваш код был доступен из WebView,
    тогда можете упростить процесс, и просто добавить его
    там, где вам надо.

    С Capacitor вы имеете полный контроль над нативным проектом,
    и можете его изменять, как захотите, и этим изменениям 
    ничего не угрожает, они не затрутся, как в Cordova по умолчанию.

    Например, нужно вам добавить новый обработчик события
    AppDelegate? Просто сделайте это! Capacitor не тронет
    ваш код.

> Руководство по устранению неполадок в iOS приложениях

  Создание на 100% идеального инструмента управления 
  нативным кодом практически невозможно, и рано или поздно
  вы столкнетесь с различными проблемами в каких-то частях
  процесса разработки под iOS.

  В этом руководстве авторы Capacitor попробовали задокументировать
  общие возможные проблемы с iOS/Xcode, и их решения.

  • Инструментарий для разработки под iOS

    Каждый iOS-разработчик изучает несколько общих техник
    для отладки багов, и вам тоже нужно их взять на вооружение

    ▪ Google

      Всегда, когда вы сталкиваетесь с проблемой с iOS или
      Xcode, вашем первым шагом должно быть копирование
      ошибки в Google и поиск.

      Capacitor использует стандартный набор инструментов
      iOS. Поэтому, если вы столкнётесь с ошибкой, велики
      шансы на то, что многие другие iOS-разработчики уже
      сталкивались с ней, и в интернете есть ответы.

      Решением могут быть такие простые вещи, как обновление
      зависимостей, запуск очистки, или удаление производных
      данных.

    ▪ Clean / Rebuild
    
      Очистка и пересборка могут помочь справиться со многими
      багами. Перейдите в "Product -> Clean" в меню Xcode,
      чтобы очистить вашу текущую сборку.

    ▪ Удаление производных данных

      Иногда Xcode цепляется за старые артефакты сборки.
      Чтобы справиться с этим, надо удалить любые
      "Derived Data" (производные данные) на диске.

      Чтобы сделать это, откройте Xcode Preferences, 
      выберите таб "Locations", и нажмите на маленькую
      стрелочку сразу после пути к вашим "Derived Data".

      Это откроет окно Finder'а и в нём папку с временными
      файлами Xcode с Derived Data.

      Выделите всё содержимое папки DerivedData и удалите
      его.

      И, наконец, пересоберите проект в Xcode.

  • Error: Unable to export required Bridge JavaScript

    Эта ошибка возникает, когда файл Capacitor'а 
    native-bridge.js не был скопирован в нативный проект.

    Чтобы исправить, запустите следующую команду, которая
    скопирует туда этот файл:

      npx cap copy ios

  • Error: Sandbox not in sync with the Podfile.lock

    Эта ошибка может случиться, если CocoaPods не может
    запуститься, чтобы обновить зависимости.

    Запустите эту команду, чтобы обновить ваши pod'ы:

      npx cap update ios

    Затем, пересоберите проект.

  • Бесконечное индексирование

    Иногда Xcode застрявает в бесконечном индексировании.
    Единственное решение, грохнуть его (используя Activity
    Monitor), и перезапустить.

  • CocoaPods: Failed to connect to GitHub

    Эта ошибка бывает на Mac'ах со старой версией openssl
    или ruby, поскольку GitHub ограничивает набор допустимых
    криптографических протоколов для доступа к репозиториям.

    Решением является обновление openssl и Ruby:

      brew install openssl
      brew upgrade openssl
      brew install ruby
      brew link --overwrite ruby

    Наконец, убедитесь, что ваша переменная среды PATH
    содержит /usr/local/bin не после $PATH, а до!

А4. Разработка под Android
--------------------------------------

  # Обзор процесса разработки под Android

    ▪ Взаимодействие между JS и нативным кодом
    ▪ Нужен Android Studio
    ▪ Подготовка к началу разработки на Android
    ▪ Создание Android-приложения
    ▪ Открытие Android-проекта в Android Studio
    ▪ Запуск Android-приложения
    ▪ Запуск Android-приложения
    ▪ Дальнейшие шаги

  # Настройка Android

    ▪ Файл AndroidManifest.xml
    ▪ Изменение App ID
    ▪ Изменение App Name
    ▪ Изменение Custom URL
    ▪ Настройка прав доступа
    ▪ О правах доступа по умолчанию

  # Обновление вашего Capacitor-проекта на Android

    ▪ Обновления библиотеки Capacitor
    ▪ Обновление Android-проекта

  # Кастомный нативный Android-код

    ▪ Доступный из WebView нативный код
    ▪ Недоступный из WebView нативный код

  # Руководство по устранению неполадок в Android приложениях

    ▪ Инструментарий для разработки под Android
      ▪ Google
      ▪ Clean / Rebuild
      ▪ Очистка кэша / рестарт
    ▪ Error: "Unable to load native-bridge.js. Capacitor will not function!"
    ▪ Error: "Please select Android SDK"
    ▪ Error: "APK Can't be installed"
    ▪ Пересоздание вашего проекта

--------------------------------------

> Обзор процесса разработки под Android

  • Взаимодействие между JS и нативным кодом

    Capacitor предоставляет нативную Android-среду, которая позволяет
    разработчикам организовывать коммуникации между JS с одной,
    и кодом на Swift/Objective-C с другой.

  • Нужен Android Studio

    Capacitor-приложения под Android настраиваются и 
    разрабатываются преимущественном через Android Studio.

  • Подготовка к началу разработки на Android

    Чтобы вести разработку Android-приложений, потребуется
    установить кое-какие Android SDK зависимости. Убедитесь,
    что Android SDK >= 26.0.1 установлен, и версия
    Android SDK Platforms >= 21.

    Вы можете легко всё это установить, открыв Android Studio,
    и отправившись там по адресу Tools -> Android -> SDK Manager
    из главного меню сверху.

  • Создание Android-приложения

    Платформа для Android устанавливается в любом новом 
    Capacitor-проекте по умолчанию.

    Если же вы добавляете Capacitor в существующий проект,
    вы можете вручную добавить платформу Android этой командой:

      npx cap add android
      npx cap sync      | обновляет зависимости, копирует www на ios-платформу

    Вместо sync можно выполнить copy. Она не выполняет обновление
    зависимостей, а лишь копирует www на android-платформу:

      npx cap copy

  • Открытие Android-проекта в Android Studio

    Можно просто открыть Android Studio, а в нём проект вручную.
    А можно сделать это из команднной строки:

      npx cap open android

  • Запуск Android-приложения

    Запустив Android Studio и открыв в нём проект, нажмите
    Run в главном меню сверху, и выберите "Run 'app'" или
    "Debug 'app'".

    *Примечание:

      В настоящий момент, чтобы использовать Android Emulator,
      вам понадобится использовать образ с Android >= 7.0
      (API >= 24). Это связано с тем, что версия WebView в 
      системе не может быть обновлена в эмуляторах. Физические
      устройства должны работать нормально с Android >= 5.1.

  • Дальнейшие шаги

    Если ваше приложение нормально запустилось и работает,
    у вас есть все, чтобы продолжать его разработку.

    Используйте различные доступные API, плагины от
    Capacitor и Cordova, или кастомный нативный код,
    чтобы построить остальную часть вашего приложения.

> Настройка Android

  • Файл AndroidManifest.xml

    В Android-приложениях управлять правами доступа, фичами
    устройства, и другими настройками, можно через файл
    AndroidManifest.xml

    Этот файл ссылается на значения из других файлов 
    в res/values, чтобы проще было обновлять их
    отдельно, включая styles.xml и strings.xml.

    Подробно файл AndroidManifest.xml описано в официальной
    документации для Android-разработчиков:

      https://developer.android.com/guide/topics/manifest/manifest-intro

  • Изменение App ID

    Чтобы изменить bundle/app id вашего приложения, отредактируйте
    верхнюю строку с <manifest> в файле AndroidManifest.xml:

      <manifest 
      package="com.getcapacitor.myapp">

  • Изменение App Name

    Чтобы изменить имя вашего приложения, измените значение
    для app_name в strings.xml:

      <string name="app_name">MyApp</string>

  • Изменение Custom URL

    Ваше приложение может отвечат на кастомные URL, делая
    возможным разруливание deeplinks and app interactions.

    Чтобы изменить URL, найдите и модифицируйте следующую
    строку в strings.xml. Рекомендуется установить его же
    в качестве bundle/app id.

      <string name="custom_url_scheme">com.getcapacitor.myapp</string>    

    В этом примере, приложение будет отвечать на URL со
    схемой:

      com.getcapacitor.myapp://

  • Настройка прав доступа

    В Android, права доступа, которые могут понадобиться
    вашему приложению, задаются в файле AndroidManifest.xml
    внутри тега <manifest>, чаще всего в конце файла.

    Например, вот как добавить права доступа Network:

      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.getcapacitor.myapp">
          <activity>
            <!-- other stuff -->
          </activity>

          <!-- More stuff -->

          <!-- Your permissions -->

          <!-- Network API -->
          <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
      </manifest> 

    Как правило, когда вы начинаете использовать какой-то плагин,
    вам потребуется проставить для него права доступа в этом
    файле.

  • О правах доступа по умолчанию

    По умолчанию, полный список прав доступа, необходимых
    для последней версии Capacitor со стандартными плагинами
    можно найти в его репозитории на GitHub, в шаблоне
    файла AndroidManifest.xml:

      https://github.com/ionic-team/capacitor/blob/master/android-template/app/src/main/AndroidManifest.xml

> Обновление вашего Capacitor-проекта на Android

  Периодически, вам нужно будет обновять ваше Android-приложение,
  включая версию Capacitor, используемую в вашем приложении,
  или использовать новые способы взаимодействия с Capacitor
  внутри кода вашего iOS-приложения (например, с новыми
  изменениями в Android API). 

  • Обновления библиотеки Capacitor

    Чтобы обновить версию Capacitor в вашем приложении,
    откройте файл build.gradle для вашего Module: app
    (доступно в android/app/build.gradle), и обновите
    строку:

      implementation 'ionic-team:capacitor-android:0.0.+

    чтобы использовать ту версию Capacitor Android, которая
    вам нужна.

  • Обновление Android-проекта

    Чтобы обновить базовую структуру вашего Android-проекта,
    смотрите на шаблон приложения для Android в репозитории
    Capacitor'а на github (последний стабильный релиз):

      https://github.com/ionic-team/capacitor/tree/master/android-template

    Это позволит наглядно увидеть, что изменилось в структуре
    проекта в новой версии.

> Кастомный нативный Android-код

  Многие могут захотеть добавить в приложение какой-то
  Java код, чтобы реализовать какие-то
  нативные фичи, при этом не утруждая себя созданием
  и публикацией соответствующего Capacitor-плагина.

  Есть 2 способа добавить кастомный код в проект, в 
  зависимости от того, нужно ли вам иметь к нему 
  доступ из WebView.

  • Доступный из WebView нативный код

    Самый простой способ создать кастомный нативный код,
    к которому вам нужен доступ из WebView, это создать
    локальный Capacitor-плагин для него. В этом случае,
    создание плагина является таким же простым делом,
    как создание нового класса, который наследует от
    com.getcapacitor.Plugin и использует аннотации
    @NativePlugin() и @PluginMethod().

      com/example/myapp/CustomNativePlugin.java:
      -------

        package com.example.myapp;

        import com.getcapacitor.NativePlugin;
        import com.getcapacitor.Plugin;
        import com.getcapacitor.PluginCall;
        import com.getcapacitor.PluginMethod;

        @NativePlugin()
        public class CustomNativePlugin extends Plugin {

          @PluginMethod()
          public void customCall(PluginCall call) {
            String message = call.getString("message");
            call.success();
          }
        }

    Наконец, зарегистрируйте планин в вашем Activity:

      // Other imports...
      import com.example.myapp.CustomNativePlugin;

      public class MainActivity extends BridgeActivity {
        @Override
        public void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);

          // Initializes the Bridge
          this.init(savedInstanceState, new ArrayList<Class<? extends Plugin>>() {{
            // Additional plugins you've installed go here
            // Ex: add(TotallyAwesomePlugin.class);
            add(CustomNativePlugin.class);
          }});
        }
      }

  • Недоступный из WebView нативный код

    Если вам не надо, чтобы ваш код был доступен из WebView,
    тогда можете упростить процесс, и просто добавить его
    там, где вам надо.

    С Capacitor вы имеете полный контроль над нативным проектом,
    и можете его изменять, как захотите, и этим изменениям 
    ничего не угрожает, они не затрутся, как в Cordova по умолчанию.

    Например, нужно вам добавить новый обработчик события
    в ваше Activity? Просто обновите MainActivity, и всё. 
    Просто сделайте это! Capacitor не тронет ваш код.

> Руководство по устранению неполадок в Android приложениях

  Создание на 100% идеального инструмента управления 
  нативным кодом практически невозможно, и рано или поздно
  вы столкнетесь с различными проблемами в каких-то частях
  процесса разработки под Android.

  В этом руководстве авторы Capacitor попробовали задокументировать
  общие возможные проблемы с Android, и их решения.

  ▪ Инструментарий для разработки под Android

    Каждый iOS-разработчик изучает несколько общих техник
    для отладки багов, и вам тоже нужно их взять на вооружение
  
    ▪ Google

      Всегда, когда вы сталкиваетесь с проблемой с Android, 
      или Gradle, или Emulators, вашем первым шагом должно 
      быть копирование ошибки в Google и поиск.

      Capacitor использует стандартный набор инструментов
      Android. Поэтому, если вы столкнётесь с ошибкой, велики
      шансы на то, что многие другие Android-разработчики уже
      сталкивались с ней, и в интернете есть ответы.

      Решением могут быть такие простые вещи, как обновление
      зависимостей, запуск синхронизации Gradle, или очистка
      кэша.

    ▪ Clean / Rebuild
    
      Очистка и пересборка могут помочь справиться со многими
      багами. Перейдите в "Build -> Clean Project" в меню 
      Android Studio, чтобы очистить вашу текущую сборку.      

    ▪ Очистка кэша / рестарт

      Если вы уверены, что исправили ошибку, но Android Studio
      или Gradle не согласен с этим, часто решением является
      заставить Android Studio очистить кэш и перезапустить
      программу.

      Чтобы сбросить кэш, перейдите в верхнем меню в
      "File -> Invalidate Caches / Restart"

  ▪ Error: "Unable to load native-bridge.js. Capacitor will not function!"

    Эта ошибка возникает, когда файл Capacitor'а 
    native-bridge.js не был скопирован в нативный проект.

    Чтобы исправить, запустите следующую команду, которая
    скопирует туда этот файл:

      npx cap copy android

  ▪ Error: "Please select Android SDK"

    Эта ошибка часто возникает из-за того, что требуется
    синхронизировать Gradle. Это надо делать периодически
    после обновления зависимостей и изменения настроек
    проекта.

    Чтобы инициировать синхронизацию Gradle, в главном меню
    перейдите в "Tools -> Android -> Sync Project with Gradle Files".

  ▪ Error: "APK Can't be installed"

    APK не устанавливается в Emulator или на устройство. 
    Чаще всего это происходит из-за того, что он или оно
    уже имеет существующее приложение с тем же именем
    пакета.

    Решением является удаление старых приложений. Нужно
    убедиться, что имя вашего приложения обновлено в 
    AndroidManifest.xml и не конфликтурт с другими
    приложениями, которые вы разрабатываете.

    Наконец, сделайте clean/rebuild, на всякий случай.

  ▪ Пересоздание вашего проекта

    Capacitor позволяет вам управлять вашим собственным
    Android-проектом. Бывает, что дела пошли не так, как
    ожидалось, и всё рассинхронизировалось, и ремонту
    не подлежит. И единственное решение, это пересобрать
    проект заново.

    Чтобы сделать это:

    1. Скопируйте весь исходный код, который вы создали, 
    такой как:

      ▪ Java-файлы в app/android/src
      ▪ Файлы манифестов
      ▪ Файлы ресурсов

    в безопасное место вне app/android.

    2. Далее, убедитесь, что вы сейчас работаете с последней
    версией Capacitor CLI. Для этого выполните:

      npm install @capacitor/cli@latest

    3. Удалите папку с платформой android:

      rm -rf android/

    4. Пересоздайте Android-приложение с помощью Capacitor:

      npx cap add android

    5. Верните ваш исходный код, которые вы на 1-м шаге
    сохранили в безопасное место, в Android-проект.


А5. Разработка под Web (Progressive Web Apps)
--------------------------------------

  # О прогрессивных веб-приложениях
  # Ядро Capacitor, это JS-библиотека, работает везде
  # Использование Capacitor с системой сборки (webpack, например)
  # Разработка Capacitor-приложения под web
  # Деплой Capacitor-приложения под web

--------------------------------------

> О прогрессивных веб-приложениях

  Прогрессивные веб-приложения (PWA's) представляют собой
  следующий виток эволюции стандартных веб-приложиний. 
  Если вы не знакомы с PWA, ничего страшного! Думайте
  о них, как о браузерных приложениях, которые используют
  некоторые современные Web API, чтобы выглядеть более
  похожими на приложения на смартфонах.

  Capacitor поддерживает PWA. Это значит, что он поддерживает
  любые веб-приложения, вне зависимости, используют ли
  они эти новомодные Web API, или нет.

> Ядро Capacitor, это JS-библиотека, работает везде

  Capacitor Core является JS-библиотекой, которая работает
  на всех платформах, которые поддерживает Capacitor.
  В том числе, на web.

> Использование Capacitor с системой сборки (webpack, например)

  Чаще всего, приложения будут использовать какой-нибудь
  фреймворк вместе с какой-нибудь системой сборки, типа
  webpack, которая поддерживает импорт JS-модулей.

  В этом случае, просто импортируйте Capacitor в самом
  верху приложения, и готово:

    import { Capacitor } from '@capacitor/core';

  Чтобы можно было использовать плагины, импортируйте
  Plugins. Обратите внимание, что лишь плагины с поддержкой
  платформы web обеспечивают на оной полезную функциональность.

    import { Plugins } from '@capacitor/core';
    const position = await Plugins.Geolocation.getCurrentPosition();

> Использование Capacitor без системы сборки

  Чтобы использовать Capacitor Core в веб-приложении, которое
  не использует систему сборки или bundler/module loader,
  вам нужно установить bundleWebRuntime в true в файле
  capacitor.config.json, скопировать необходимую версию
  Capacitor Core в ваш проект, и потом импортировать
  capacitor.js в ваш index.html:

    {
      "bundleWebRuntime": true
    }

  Скопировать в ваш проект:

    npx cap copy web

  в index.html, импортировать capacitor.js перед вашим
  JS-приложением:

    <script src="capacitor.js"></script>
    <script src="your/app.js"></script>

> Разработка Capacitor-приложения под web

  Скорее всего, вы используете фреймворк вроде Ionic для
  UI-компонент и сборки. Чтобы разработать ваше Capacitor-
  приложение, просто используйте ваш фреймворк!

  Если вы не используете фреймворк, Capacitor поставляется
  вместе с небольшим веб-сервером на NodeJS, который 
  вы можете использовать:

    npx cap serve

> Деплой Capacitor-приложения под web

  Когда ваше прогрессивное веб-приложение готово к публикации,
  и вы хотите поделиться им с миром, просто залейте содержимое
  вашей веб-папочки (по умолчанию: public/). Там лежит всё 
  необходимое для работы вашего прогрессивного приложения!


А6. Разработка под Electron
--------------------------------------

  # Capacitor имеет предварительную поддержку Electron
  # Подготовка к началу разработки на Electron
  # Подготовка вашего Capacitor-приложения на Electron
  # Запуск вашего приложения
  # Поддержка плагинов

--------------------------------------

> Capacitor имеет предварительную поддержку Electron

  Capacitor имеет предварительную поддержку Electron, 
  популярного инструмента для сборки десктопных
  приложений с помощью html, css, js.

  С Electron, Capacitor-приложения могут нативно запускаться
  на Windows, Mac и Linux!

  *Примечание:

    Статус поддержки Capacitor'ом Electron'а - preview.
    Команда Capacitora утверждает, что для них сейчас
    важнее web, iOS и Android, а приоритет на допил
    поддержки Electron ниже.

> Подготовка к началу разработки на Electron

  После создания нового Capacitor-приложения, добавьте
  платформу electron:

    npx cap add electron

  Это сгенерирует новый проект на Electron в папке electron/
  в корне вашего приложения.

> Подготовка вашего Capacitor-приложения на Electron

  Как и на других платформах Capacitor'а, необходимо
  периодически запускать команду copy, чтобы синхронизировать
  веб-контент с платформой Electron:

    npx cap copy

  Делать это надо каждый раз после внесения изменений
  в ваше веб-приложение.

> Запуск вашего приложения

  Чтобы запустить ваше приложение, перейдите в папку с ним,
  и используйте npm-скрипт, предоставленный Capacitor'ом:

    cd electron/
    npm run electron:start

  Это запустит экземпляр Electron с вашим приложением.
  
> Поддержка плагинов

  Electron поддерживает любой плагин, который имеет
  исполнение для Web. А также ряд плагинов, имеющих
  исполнение для Electron (таких, как Filesystem).

  Информация о том, как делать плагины для Electron,
  появится скоро - обещают разработчики Capacitor.


А7. Плагины Capacitor'а
--------------------------------------

  # О плагинах Capacitor'а

    ▪ Зачем нужны плагины
      ▪ Плагины дают доступ через JS к нативному функционалу
      ▪ Плагины позволяют работать вместе веб- и нативным-разработчикам
      ▪ Capacitor сам генерирует JS-хуки для плагинов

    ▪ Подготовка к началу разработки плагина
    ▪ Интерфейс на TypeScript
    ▪ Публикация плагина

  # Руководство по плагинам для iOS

    ▪ Потребуется писать код на Swift или Objective-C
    ▪ Подготовка к началу разработки плагина для iOS
    ▪ Создание плагина на Swift
    ▪ Простой пример плагина для iOS
    ▪ Доступ ко входящим параметрам плагина (Called Data)
    ▪ Возвращаемые плагином данные
    ▪ Предоставление нативных экранов
    ▪ Возбуждение событий
      ▪ Возбуждение событий приложения (App events)
      ▪ Возбуждение событий плагина (Plugin events)
    ▪ Экспорт класса Swift -> Objective-C, регистрация в Capacitor

  # Руководство по плагинам для Android

    ▪ Потребуется писать код Java
    ▪ Подготовка к началу разработки плагина для Android
    ▪ Создание плагина на Java
    ▪ Простой пример плагина для Android
    ▪ Доступ ко входящим параметрам плагина (Called Data)
    ▪ Возвращаемые плагином данные
    ▪ Предоставление нативных экранов
      ▪ Intents без желания получить результат
      ▪ Intents с желанием получить результат
    ▪ Возбуждение событий
      ▪ Возбуждение событий приложения (App events)
      ▪ Возбуждение событий плагина (Plugin events)
    ▪ Запрос прав доступа для плагинов с помощью инструментов Capacitor'а
    ▪ Регистрация плагина в Capacitor

  # Руководство по плагинам для Web/PWA

    ▪ Плагин может работать как на Web/PWA, так на iOS/Android и пр.платформах
    ▪ Подготовка к началу разработки плагина для Web/PWA
    ▪ Пример плагина для Web/PWA

  # Руководство по плагинам для JS

    ▪ Большинствов Capacitor-плагинов не требует писать JS-кода
    ▪ Подготовка к добавлению кастомного JS-кода Capacitor-плагину
    ▪ Публикация плагина
    ▪ Использование плагина

--------------------------------------

> О плагинах Capacitor'а

  • Зачем нужны плагины

    ▪ Плагины дают доступ через JS к нативному функционалу

      Плагины позволяют через JS-интерфейс прямо взаимодействовать
      с API нативных платформ.

      С плагинами, веб-приложение имеет доступ к полной
      мощи нативных API, и могут делать всё то же самое,
      что могут нативные приложения.

      Плагины особенно хороши для заворачивания в них общих
      нативных операций, которые могут использовать очень
      разные API на разных платформах. Получается очень
      удобно иметь для них один простой и понятный API
      на JS.

    ▪ Плагины позволяют работать вместе веб- и нативным-разработчикам

      Плагины Capacitor'а дают возможность организовать
      эффективное взаимодействие между веб-разработчиками
      и нативными разработчиками. Нативные могут писать
      плагины, а веб-разработчики писать приложение,
      используя JS API от этих плагинов.

    ▪ Capacitor сам генерирует JS-хуки для плагинов

      Capacitor автоматически генерирует JS-хуки на клиенте,
      та что для большинства плагинов не надо ничего писать
      на JS, а надо только нативную часть на Swift/Obj-C 
      для iOS и/или Java на Android.

      Конечно, возможность добавлять кастомный JS для плагина
      есть. Это похоже на создание кастомного npm-пакета.

  • Подготовка к началу разработки плагина

    Capacitor поставляется с генератором плагинов, который
    позволяет бысто создавать оные:

      npx @capacitor/cli plugin:generate

    Это запускает wizard, который задаст несколько вопросов,
    создаст плагин, и заполнит начальный package.json. 
    Например:

      max@Maxs-iMac:~ $ npx @capacitor/cli plugin:generate
      ✏️  Creating new Capacitor plugin
      ? Plugin NPM name (snake-case): my-plugin
      ? Plugin id (domain-style syntax. ex: com.example.plugin) com.ionicframework.myplugin
      ? Plugin class name (ex: AwesomePlugin) MyPlugin
      ? description:
      ? git repository:
      ? author:
      ? license: MIT
      ? package.json will be created, do you want to continue? (Y/n)

      ▪ Plugin NPM nam

        Это название для NPM-пакета, должно быть в формате
        snake-case.

      ▪ Plugin ID

        Уникальный идентификатор, преимущественно нужен для
        android. Его формат, это реверс-домен + название плагина.
        Например: com.example.plugin

      ▪ Plugin Class Name

        Имя класса для плагина в Java и Swift.

      ▪ description

        Описание плагина.

      ▪ git repository

        Git-репозиторий для плагина, где его исходный код
        будет храниться. 

  • Интерфейс на TypeScript

    Каждый плагин идёт с кое-какими typescript-файлами, 
    которые просто экспортируют TypeScript-интерфейсы.

    Эти интерфейсы могут обеспечить типизацию? потребителям
    вашего плагина, которые любят TypeScript.

    Начало с TypeScript-интерфейса может быть хорошим путём
    построить API вашего плагина. Например, вот интерфейс
    по умолчанию для нашего плагина:

      declare global {
        interface PluginRegistry {
          Echo?: EchoPlugin;
        }
      }

      export interface EchoPlugin {
        echo(options: { value: string }): Promise<{value: string}>;
      }

  • Публикация плагина

    Когда вы готовы и хотите опубликовать плагин, просто 
    воспользуйтесь этой командой:

      npm publish

    Это соберёт JS-часть вашего плагина и опубликует остальное
    в NPM.

    После этого ваш пакет можно буедт установить в любое
    Capacitor-приложение через NPM:

      npm install <имя плагина>

> Руководство по плагинам для iOS

  • Потребуется писать код на Swift или Objective-C

    При сздании плагинов для Capacitor потребуется
    писать код на Swift или Objective-C.

    Capacitor поощряет использование стандартных инструментов
    для разрботки под iOS для создания плагинов. Команда
    Capacitor верит, что использование Swift (или Objective-C)
    напрямую сделает легче поиск решений на Stack Overflow,
    привлечение к разработке нативных разработчиков, а также
    использование новейших фич платформы

  • Подготовка к началу разработки плагина для iOS

    Для начала, сгенерируйте плагин, как было описано
    выше.

    Затем, в Xcode откройте:
    your-plugin/ios/Plugin/Plugin.xcworkspace

  • Создание плагина на Swift

    Capacitor-плагин для iOS представляет собой простой
    Swift-класс, который наследует от CAPPlugin и 
    экспортирует кое-какие методы, которые можно
    вызывать из JS.

    Когда плагин сгенерирован, вы можете начать его
    использовать, открывая Plugin.swift

  • Простой пример плагина для iOS

    В генерируемом примере находится простой плагин 
    с функцией echo, которая просто возвращает
    переданное значение.

    Этот пример демонстрирует несколько core-компонентов
    плагинов Capacitor'а: получение входящих данных 
    из Plugin Call, возвращение данных обратно тому,
    кто плагин вызывал:

    Plugin.swift
    ------------

      import Capacitor

      @objc(MyPlugin)
      public class MyPlugin: CAPPlugin {
        @objc func echo(_ call: CAPPluginCall) {
          let value = call.getString("value") ?? ""
          call.resolve([
              "value": value
          ])
        }
      }    

  • Доступ ко входящим параметрам плагина (Called Data)

    Каждый метод плагина получает экземпляр CAPPluginCall,
    содержащий всю информацию, переданную клиентом при
    вызове плагина.

    Клиент может отправлять любые данные, сериализуя их
    в JSON. Эти данные доступны через поле options
    вызываемого экземпляра, или через удобные методы,
    такие как getString или getObject.

    Например, вот как вы можете получить данные, переданные
    в ваш метод:

      @objc func storeContact(_ call: CAPPluginCall) {
        let name = call.getString("yourName") ?? "default name"
        let address = call.getObject("address") ?? [:]
        let isAwesome = call.getBoolean("isAwesome") ?? false

        guard let id = call.options["id"] as? String else {
          call.reject("Must provide an id")
          return
        }

        // ...

        call.resolve()
      }

    Обратите внимание, что данные можно извлечь из CAPPluginCall
    разными путями. А с помощью guard можно требовать валидировать
    входящие даннные, требуя, например наличие определённых
    ключей со значениями определённых типов.

  • Возвращаемые плагином данные

    Вызов плагина может завершиться успехом или неудачей.
    Чаще всего, плагины вызываются через промисы. Поэтому,
    вызов resolve свидетельствует об успехе, а reject - 
    о неудаче.

    Для тех, кто использует коллбэки, вызов success-колбэка
    будет свидетельствовать об успехе, а вызов error-колбэка
    - о неудаче.

    Метод resolve принимает массив и поддерживает сериализуемые
    в JSON типы данных. Вот пример того, что может возвращаться
    обратно клиенту:

      call.resolve([
        "added": true,
        "info": [
          "id": id
        ]
      ])

    Неудачи, или вызов reject, вызывает call.reject, передаёт
    строку с ошибкой и (опционально) экземпляр Error, и доп.
    данные:

      call.reject(error.localizedDescription, error, [
        "item1": true
      ])

  • Предоставление нативных экранов

    Чтобы предоставить нативный экран поверх экрана Capacitor'а,
    нам необохимо получить доступ к View-контроллеру Capacitor'а.
    Для этого надо использовать объект CAPBridge, доступный
    в классе CAPPlugin.

    Мы можем использовать UIViewController, чтобы предоставить
    Native View Controllers над ним, вот так:

      self.bridge.viewController.present(ourCustomViewController, animated: true, completion: nil)

    На iPad вы также можете предоставить UIPopovers, чтобы 
    это делать, есть функция-хелпер, позволяющая показывать
    его по центру:

      self.setCenteredPopover(ourCustomViewController)
      self.bridge.viewController.present(ourCustomViewController, animated: true, completion: nil)

  • Возбуждение событий

    Плагины Capacitor'а могут возбуждать события приложения (App events),
    и события плагинов (Plugin events)

    • Возбуждение событий приложения (App events)

      События приложения являются обычными JS-событиями,
      как window или document.

      Capacitor предоставляет все эти функции для 
      возбуждения событий:

        //If you want to provide the target
        self.bridge.triggerJSEvent(eventName: "myCustomEvent", target: "window")
        self.bridge.triggerJSEvent(eventName: "myCustomEvent", target: "document", data: "my custom data")

        // Window Events
        self.bridge.triggerWindowJSEvent(eventName: "myCustomEvent")
        self.bridge.triggerWindowJSEvent(eventName: "myCustomEvent", data: "my custom data")

        // Document events
        self.bridge.triggerDocumentJSEvent(eventName: "myCustomEvent")
        self.bridge.triggerDocumentJSEvent(eventName: "myCustomEvent", data: "my custom data")

      Вешать на эти события обработчики можно точно так же,
      как вы это делаете обычно в JS:

        window.addEventListener("myCustomEvent", function() {
          console.log("myCustomEvent was fired")
        });

    • Возбуждение событий плагина (Plugin events)

      Плагины могут возбуждать их собственные события,
      которые вы можете слушать, подключая обработчики
      событий к объекту плагина, вот так:

        Plugins.MyPlugin.addListener('myPluginEvent', (info: any) => {
          console.log('myPluginEvent was fired');
        });

      Возбудить событие из класса Swift-плагина вы можете
      вот так:

        self.notifyListeners("myPluginEvent", data: [:])

  • Экспорт класса Swift -> Objective-C, регистрация в Capacitor

    Чтобы убедитсья в том, что Capacitor видит ваш плагин,
    вам надо сделать 2 вещи:

      ▪ Экспортировать ваш Swift-класс в Objective-C.
      ▪ Зарегистрировать последний, используя предоставляемый
        Capacitor'ом Objective-C-макрос.

    Чтобы экспортировать ваш Swift-класс в Objective-C, 
    убедитесь, что вы добавили @objc(YourPluginClass) над
    вашем Swift-классом, и добавили @objc перед каждым
    методом плагина, как показано в примерах выше.

    Далее, вам понадобится создать новый Objective-C файл
    (с расширением .m, а не .h !), соответствующий вашему
    плагину. Например: MyPlugin.m

      * Важно! Для создания файла вы обязательно должны использовать
      диалог "New File" в Xcode. В процессе Xcode спросит у вас,
      нужно ли создать Bridging Header, и вы должны согласиться.

    Наконец, зарегистрируйте плагин, добавив необходимый 
    макрос для Capacitor-плагинов в ваш новый .m файл:

      #import <Capacitor/Capacitor.h>

      CAP_PLUGIN(MyPlugin, "MyPlugin",
        CAP_PLUGIN_METHOD(echo, CAPPluginReturnPromise);
      )

    Это делает ваш новый Capacitor-плагин MyPlugin, и метод
    echo из него, доступными в вашем веб-приложении.

> Руководство по плагинам для Android

  • Потребуется писать код Java

    При сздании плагинов для Capacitor потребуется
    писать код на Java.

    Capacitor поощряет использование стандартных инструментов
    для разрботки под Android для создания плагинов. Команда
    Capacitor верит, что использование Java
    напрямую сделает легче поиск решений на Stack Overflow,
    привлечение к разработке нативных разработчиков, а также
    использование новейших фич платформы

  • Подготовка к началу разработки плагина для Android

    Для начала, сгенерируйте плагин, как было описано
    выше.

    Затем, в Android Studio откройте:
    your-plugin/android/your-plugin

  • Создание плагина на Java

    Capacitor-плагин для Android представляет собой простой
    Java-класс, который наследует от com.getcapacitor.Plugin и 
    имеет аннотацию @NativePlugin. Он имеет кое-какие методы
    с аннотацией @PluginMethod(), которые доступны для
    вызовов из JS.

    Когда плагин сгенерирован, вы можете начать его
    редактировать, открыв файл, имя которого совпадает
    с именем плагина, которое вы указали в генераторе.

  • Простой пример плагина для Android

    В генерируемом примере находится простой плагин 
    с функцией echo, которая просто возвращает
    переданное значение.

    Этот пример демонстрирует несколько core-компонентов
    плагинов Capacitor'а: получение входящих данных 
    из Plugin Call, возвращение данных обратно тому,
    кто плагин вызывал:

    EchoPlugin.java
    ---------------

      package android.plugin.test;

      import com.getcapacitor.JSObject;
      import com.getcapacitor.NativePlugin;
      import com.getcapacitor.Plugin;
      import com.getcapacitor.PluginCall;
      import com.getcapacitor.PluginMethod;

      @NativePlugin()
      public class EchoPlugin extends Plugin {

          @PluginMethod()
          public void echo(PluginCall call) {
              String value = call.getString("value");

              JSObject ret = new JSObject();
              ret.put("value", value);
              call.success(ret);
          }
      }

  • Доступ ко входящим параметрам плагина (Called Data)

    Каждый метод плагина получает экземпляр com.getcapacitor.PluginCall,
    содержащий всю информацию, переданную клиентом при
    вызове плагина.

    Клиент может отправлять любые данные, сериализуя их
    в JSON. Эти данные доступны через поле getData 
    вызываемого экземпляра, или через удобные методы,
    такие как getString или getObject.

    Например, вот как вы можете получить данные, переданные
    в ваш метод:

      @PluginMethod()
      public void storeContact(PluginCall call) {
        String name = call.getString("yourName", "default name");
        JSObject address = call.getObject("address", new JSObject());
        boolean isAwesome = call.getBoolean("isAwesome", false);

        if (!call.getData().has("id")) {
          call.reject("Must provide an id");
          return;
        }
        // ...

        call.resolve();
      }

    Обратите внимание, что данные можно извлечь из PluginCall
    разными путями. А с помощью метода has можно требовать валидировать
    входящие даннные, требуя, например наличие определённых
    ключей со значениями определённых типов.

  • Возвращаемые плагином данные

    Вызов плагина может завершиться успехом или неудачей.
    Чаще всего, плагины вызываются через промисы. Поэтому,
    вызов resolve свидетельствует об успехе, а reject - 
    о неудаче.

    Для тех, кто использует коллбэки, вызов success-колбэка
    будет свидетельствовать об успехе, а вызов error-колбэка
    - о неудаче.

    Метод resolve, принадлежащий PluginCall, принимает массив 
    и поддерживает сериализуемые в JSON типы данных. Вот 
    пример того, что может возвращаться обратно клиенту:

      JSObject ret = new JSObject();
      ret.put("added", true);
      JSObject info = new JSObject();
      info.put("id", "unique-id-1234");
      ret.put("info", info);
      call.resolve(ret);

    Неудачи, или вызов reject, вызывает call.reject, передаёт
    строку с ошибкой и (опционально) экземпляр Exception:

      call.reject(exception.getLocalizedMessage(), exception);

  • Предоставление нативных экранов

    Чтобы предоставить нативный экран поверх экрана Capacitor'а,
    нам необохимо получить использовать Android's Intents:

      https://developer.android.com/guide/components/intents-filters

    Intents позволяют вам запустить активность из вашего,
    или другого приложения.

    • Intents без желания получить результат

      В большинстве случаев вы лишь хотите представить
      нативную Activity:

        Intent intent = new Intent(Intent.ACTION_VIEW);
        getActivity().startActivity(intent);

    • Intents с желанием получить результат

      Иногда, когда вы запускаете Intent, вы ожидаете получить
      некий результат назад. В этом случае, надо использовать
      startActivityForResult:

        static final int REQUEST_IMAGE_PICK = 12345;
        Intent intent = new Intent(Intent.ACTION_PICK);
        intent.setType("image/*");
        startActivityForResult(call, intent, REQUEST_IMAGE_PICK);

      Чтобы получить результат, надо перезаписать 
      handleOnActivityResult:

        @Override
        protected void handleOnActivityResult(int requestCode, int resultCode, Intent data) {
          super.handleOnActivityResult(requestCode, resultCode, data);

          PluginCall savedCall = getSavedCall();

          if (savedCall == null) {
            return;
          }
          if (requestCode == REQUEST_IMAGE_PICK) {
            // Do something with the data
          }
        }

      Чтобы получить доступ к View-контроллеру Capacitor'а,
      нам надо использовать объект CAPBridge в классе
      CAPPlugin.

      Мы можем использовать UIViewController, чтобы предоставить
      Native View Controllers над ним, вот так:

        self.bridge.viewController.present(ourCustomViewController, animated: true, completion: nil)

      На iPad вы также можете предоставить UIPopovers, чтобы 
      это делать, есть функция-хелпер, позволяющая показывать
      его по центру:

        self.setCenteredPopover(ourCustomViewController)
        self.bridge.viewController.present(ourCustomViewController, animated: true, completion: nil)

  • Возбуждение событий

    Плагины Capacitor'а могут возбуждать события приложения (App events),
    и события плагинов (Plugin events)

    • Возбуждение событий приложения (App events)

      События приложения являются обычными JS-событиями,
      как window или document.

      Capacitor предоставляет все эти функции для 
      возбуждения событий:

        //If you want to provide the target
        bridge.triggerJSEvent("myCustomEvent", "window");
        bridge.triggerJSEvent("myCustomEvent", "document", "my custom data");

        // Window Events
        bridge.triggerWindowJSEvent("myCustomEvent");
        bridge.triggerWindowJSEvent("myCustomEvent", "my custom data");

        // Document events
        bridge.triggerDocumentJSEvent("myCustomEvent");
        bridge.triggerDocumentJSEvent("myCustomEvent", "my custom data");

      Вешать на эти события обработчики можно точно так же,
      как вы это делаете обычно в JS:

        window.addEventListener("myCustomEvent", function() {
          console.log("myCustomEvent was fired")
        });

    • Возбуждение событий плагина (Plugin events)

      Плагины могут возбуждать их собственные события,
      которые вы можете слушать, подключая обработчики
      событий к объекту плагина, вот так:

        Plugins.MyPlugin.addListener("myPluginEvent", (info: any) => {
          console.log("myPluginEvent was fired");
        });

      Возбудить событие из класса плагина вы можете
      вот так:

        JSObject ret = new JSObject();
        ret.put("value", "some value");
        notifyListeners("myPluginEvent", ret);      

  • Запрос прав доступа для плагинов с помощью инструментов Capacitor'а

    Некоторым плагинам потребуется, чтобы вы запросили кое-какие
    права для их работы. Capacitor предоставляет хелперы
    для этого.

    Во-первых, задекларируйте необходимые вашему плагину
    права в аннотации @NativePlugin:

      @NativePlugin(
        permissions={
          Manifest.permission.ACCESS_NETWORK_STATE
        }
      )

    Вы можете проверить, все ли необходимые права доступа
    были предоставлены с помощью: 

      hasRequiredPermissions().

    Вы можете запросить все необходимые права доступа
    с помощью: 

      pluginRequestAllPermissions().

    Вы можете запросить конкретное разрешение вот
    таким образом:

      pluginRequestPermission(Manifest.permission.CAMERA, 12345)

    Или, вы можете запросить сразу группу прав доступа
    с помощью:

      static final int REQUEST_IMAGE_CAPTURE = 12345;
      pluginRequestPermissions(new String[] {
        Manifest.permission.CAMERA,
        Manifest.permission.WRITE_EXTERNAL_STORAGE,
        Manifest.permission.READ_EXTERNAL_STORAGE
      }, REQUEST_IMAGE_CAPTURE);

    Чтобы обработать запрос прав доступа, вам необходимо
    перезаписать handleRequestPermissionsResult:

      @Override
      protected void handleRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        super.handleRequestPermissionsResult(requestCode, permissions, grantResults);

        log("handling request perms result");
        PluginCall savedCall = getSavedCall();
        if (savedCall == null) {
          log("No stored plugin call for permissions request result");
          return;
        }

        for(int result : grantResults) {
          if (result == PackageManager.PERMISSION_DENIED) {
            savedCall.error("User denied permission");
            return;
          }
        }

        if (requestCode == REQUEST_IMAGE_CAPTURE) {
          // We got the permission
        }
      }

  • Регистрация плагина в Capacitor

    Используя аннотации @NativePlugin и @PluginMethod()
    в ваших плагинах, вы делаете их доступными для
    Capacitor. Но вам нужно делать ещё одну вещь,
    вам надо регистрировать класс вашего плагина в 
    вашей Activity, чтобы Capacitor знал о нём:

      // Other imports...
      import com.example.myapp.EchoPlugin;

      public class MainActivity extends BridgeActivity {
        @Override
        public void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);

          // Initializes the Bridge
          this.init(savedInstanceState, new ArrayList<Class<? extends Plugin>>() {{
            // Additional plugins you've installed go here
            // Ex: add(TotallyAwesomePlugin.class);
            add(EchoPlugin.class);
          }});
        }
      }

> Руководство по плагинам для Web/PWA

  • Плагин может работать как на Web/PWA, так на iOS/Android и пр.платформах

    Capacitor использует слой совместимости Web <-> Native,
    делая простым делом создание плагинов, которые могут
    функционировать как нативно, так и на Web/PWA.

  • Подготовка к началу разработки плагина для Web/PWA

    Для начала, сгенерируйте плагин, как было описано
    выше.

    Затем, в Android Studio откройте:
    your-plugin/src/web.ts

  • Пример плагина для Web/PWA

    Базовая структура Web-плагина выглядит вот так,
    всё подробнее описано в комментах:

      import { WebPlugin } from '@capacitor/core';

      export class MyPluginWeb extends WebPlugin {
        constructor() {
          // Call super with the name of our plugin (this should match the native name),
          // along with the platforms this plugin will activate on. For example, it's possible
          // to use a web plugin for Android and iOS by adding them to the platforms list (lowercased)
          super({
            name: 'MyPlugin',
            platforms: ['web']
          });
        }

        async echo(options: { value: string }) {
          console.log('ECHO', options);
          return Promise.resolve();
        }
      }

      // Instantiate the plugin
      const MyPlugin = new MyPluginWeb();

      // Export the plugin
      export { MyPlugin };

    Наконец, убедитесь, что в вашем src/index.ts есть
    эта строка:

      export * from './web';

> Руководство по плагинам для JS

  • Большинствов Capacitor-плагинов не требует писать JS-кода

    Все методы плагинов Capacitor'а становятся автоматически
    доступными в среде выполнения JS. Поэтому, большинство
    этих плагинов не требует писать какого-то дополнительного
    JS-кода.

    Однако, если вашему плагину нужен какой-то кастомный
    JS, вы можете легко добавить JS-фронтенд к вашему
    Capacitor-плагину.

  • Подготовка к добавлению кастомного JS-кода Capacitor-плагину

    Чтобы создать кастомный JS-фронтенд для Capacitor-плагина,
    во первых, создайте плагин, как описано в:

      "О плагинах Capacitor'а" -> "Подготовка к началу разработки плагина"

    Затем, создайте свой плагин. Сгенерированный шаблон плагина
    содержит TypeScript. Вы можете адаптировать (рекомендуется),
    либо удалить эти файлы, и начать с нуля. Как закончите,
    просто соберите всё.

    Вы сможете получить доступ к своему плагину сразу
    после импорта из @capacitor/core:

      import { Plugins } from '@capacitor/core';
      const { SuperGreatPlugin } = Plugins;
      export class CustomSuperPlugin {
        constructor() {
        }
        customAwesomeness() {
          SuperGreatPlugin.awesome();
        }
      }

  • Публикация плагина

    Чтобы опубликовать ваш плагин, просто выполните:

      npm publish

  • Использование плагина

    Одно из отличий плагинов с кастомным JS состоит в том,
    как разработчики могут их использовать. Вместо того,
    чтобы получать доступ к ним в Plugins.SuperGreatPlugin,
    разработчики импортируют их напрямую из npm-пакета:

      import { CustomSuperPlugin } from 'super-great-plugin';

      const plugin = new CustomSuperPlugin();
      plugin.customAwesomeness();


А8. Capacitor APIs
--------------------------------------

  # Введение в APIs Capacitor'а
  # Capacitor APIs
  
    ▪ Accessibility                 | взаимодействие со screen reader'ом устройства
                                    | ios / android
      ▪ isScreenReaderEnabled       | - проверить, включен ли screen reader на устройстве
      ▪ speak                       | - произнести указанный текст через screen reader
      ▪ addListener                 | - отслеживать изменения состояния screen reader'а

    ▪ App                                 | управление высокоуровневым состоянием приложения и событиями
                                          | pwa / ios / android / electron
      ▪ canOpenUrl                        | - проверить, можно ли открыть приложение через указанный URL
      ▪ exitApp                           | - force'ировать выход из приложения
      ▪ getLaunchUrl                      | - получить URL, через который приложение было запущено
      ▪ openUrl                           | - открыть приложение по указанному URL
      ▪ addListener('appStateChange')     | - отслеживать, в foreground приложение, или в background
      ▪ addListener('appUrlOpen')         | - отслеживать событие открытия приложения через URL
      ▪ addListener('appRestoredResult')  | - возвращает данные, с которыми было запущено приложение
      ▪ addListener('backButton')         | - отслеживать хардварную кнопку "назад" (только Android)

    ▪ Background Task                   | управление фоновыми задачами
                                        | ios / android
      ▪ beforeExit                      | - запустить короткоживущую фоновую задачу при переходе приложения в фон
      ▪ finish                          | - уведомить OS, что задача фсё, и OS может продолжить класть приложение в фон

    ▪ Browser                           | открытие внут.браузера приложения, обработка аутентификации, и пр.
                                        | pwa / ios / android / electron
      ▪ close                           | - закрыть браузер (только в iOS)
      ▪ open                            | - открыть страницу с указанным URL во внут.браузере
      ▪ prefetch                        | - намекнуть браузеру, что укзазанные URLs будут открыты (чтобы улучшить время загрузки для клиента)
      ▪ addListener('browserFinished')  | - браузер закончил
      ▪ addListener('browserPageLoaded')| - страница браузера загружена
                                        
    ▪ Camera                            | доступ к камере и фотоальбому
                                          pwa / ios / android / electron
      ▪ getPhoto                        | просит пользователя взять фотку из альбома, или снять камерой

    ▪ Clipboard                         | управляет copy/paste в/из clipboard
                                        | pwa / ios / android / electron
      ▪ read                            | - прочитать значение из clipboard (paste action)
      ▪ write                           | - записать значение в clipboard (copy action)
                                        
    ▪ Console                           | через console.log отправлять msg не только в web, но и логи нативных платформ
                                        | pwa / ios / android / electron
      ▪ console.log                     | - отправить сообщение в логи всех платформ

    ▪ Device                            | содержит инфу об устройстве, ОС, платформе, пользователе
                                        | pwa / ios / android / electron
      getInfo                           | - получить инфу об устройстве, ОС, платформе, пользователе

    ▪ Filesystem                        | NodeJS-подобное API для работы с файлами на устройстве
                                        | pwa / ios / android / electron
      ▪ appendFile                      | - добавить в конец файла на диске в указанной локации на устройстве
      ▪ deleteFile                      | - удалить файл с диска
      ▪ getUri                          | - получить полный URI файла для пути и каталога
      ▪ mkdir                           | - создать папку
      ▪ readFile                        | - считать файл с диска
      ▪ readdir                         | - вернуть (не рекурсивно) список файлов в папке
      ▪ rmdir                           | - удалить папку
      ▪ stat                            | - вернуть инфу о файле
      ▪ writeFile                       | - записать файл на диск в указанное место на устройстве

    ▪ Geolocation                       | 
    ▪ Haptics                           | 
    ▪ Keyboard                          | 
    ▪ Modals                            | 
    ▪ Motion                            | 
    ▪ Network                           | 
    ▪ Share                             | 
    ▪ Splash Screen                     | 
    ▪ Status Bar                        | 
    ▪ Storage                           | 
    ▪ Toast                             | 

--------------------------------------

> Введение в APIs Capacitor'а

  У Capacitor'а есть набор нативных API, которые доступны
  для использования на всех его платформах. 

  Можете думать об этих API, как о core-плагинах 
  Capacitor'а. Они позволяют легко получать доступ
  к наиболее часто используемому функционалу на
  каждой платформе.

  Для тех, кто пришёл с Cordov'ы. Capacitor APIs покрывают
  большую часть плагинов Cordov'ы, и даже содержит
  немного новых.

> Capacitor APIs

  • Accessibility API

    ▪ Поддерживаемые платформы

      - ios
      - android

    ▪ Описание

      взаимодействие со screen reader'ом устройства

      Screen reader, это функционал для слепых, который
      читает то, что находится на экране, и до чего 
      слепой дотрагивается пальцем.

      Accessibility API позволяет проверять, включён ли
      screen reader на устройстве, и позволяет взаимодействовать
      с ним - приказывать ему зачитывать какой-то текст
      при каких-то условиях.

    ▪ API

      ▪ isScreenReaderEnabled(): Promise<ScreenReaderEnabledResult>
        проверить, включен ли screen reader на устройстве

      ▪ speak(options: AccessibilitySpeakOptions): Promise<void>
        произнести указанный текст через screen reader

      ▪ addListener(eventName: "accessibilityScreenReaderStateChange", listenerFunc: ScreenReaderStateChangeCallback): PluginListenerHandle
        отслеживать изменения состояния screen reader'а

    ▪ Примеры

      import { Plugins } from '@capacitor/core';

      const { Accessibility, Modals } = Plugins;

      Accessibility.addListener('accessibilityScreenReaderStateChange', (state) => {
        console.log(state.value);
      });

      async isVoiceOverEnabled() {
        var vo = await Accessibility.isScreenReaderEnabled();
        alert('Voice over enabled? ' + vo.value);
      }

      async speak() {
        var value = await Modals.prompt({
          title: "Value to speak",
          message: "Enter the value to speak"
        });

        Accessibility.speak({value: value.value});
      }

    ▪ Интерфейсы

      interface AccessibilitySpeakOptions {
      
        // The language to speak the string in, as its [ISO 639-1 Code](https://www.loc.gov/standards/iso639-2/php/code_list.php) (ex: "en"). Currently only supported on Android.
        language ?: string
        
        // The string to speak
        value : string

      }

      type alias ScreenReaderStateChangeCallback {

      }

  • App Api

    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron

    ▪ Описание

      управление высокоуровневым состоянием приложения и событиями

      Например:

        ▪ это API возбуждает события, когда приложение
          входит или покидает foreground;
        ▪ управляет глубинными ссылками (deep links);
        ▪ открывает другие приложения;
        ▪ управляет состояниями присутствующих плагинов.

      Глубинные ссылки позволяют через URL открывать не 
      сайт в браезере, а мобильное приложение. Для этого
      само мобильное приложение должно быть запрограммировано
      так, чтобы оно обрабатывало такие запросы.

    ▪ API

      ▪ canOpenUrl(options: { url: string }): Promise<{ value: boolean }>
        проверить, можно ли открыть приложение через указанный URL

        Чтобы использовать canOpenUrl, вам надо установить
        схемы URL, по которым ваше приложение может быть
        запрошено, в LSApplicationQueriesSchemes в Info.plist

        Подробнее:
        https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW14
        https://capacitor.ionicframework.com/docs/ios/configuration/

      ▪ exitApp(): never
        force'ировать выход из приложения

        Это надо использовать только в сочетании с обработчиком
        события нажатия на кнопку 'backButton' в Android,
        чтобы выйти из приложения, когда назад уже некуда.

      ▪ getLaunchUrl(): Promise<AppLaunchUrl>
        получить URL, через который приложение было запущено

      ▪ openUrl(options: { url: string }): Promise<{ completed: boolean }>
        открыть приложение по указанному URL

      ▪ addListener(eventName: "appStateChange", listenerFunc: (state: AppState) => void): PluginListenerHandle
        отслеживать, в foreground приложение, или в background

      ▪ addListener(eventName: "appUrlOpen", listenerFunc: (data: AppUrlOpen) => void): PluginListenerHandle
        отслеживать событие открытия приложения через URL

        Этот обработчик обрабатывает оба случая, и ссылки с
        кастомной URL-схемой, и ссылки с URL-схемами, которые
        обрабатывает ваше приложение (Universal Links на iOS
        и App links на Android).

      ▪ addListener(eventName: "appRestoredResult", listenerFunc: (data: AppRestoreResult) => void): PluginListenerHandle
        возвращает данные, с которыми было запущено приложение

        Если приложение было запущено с ранее присутствующими
        данными плагина, например, как на Android, если 
        активность возвращается к приложению, которое было
        закрыто, этот вызов вернёт любые данные, с которыми
        было запущено приложение, сконвертированными в 
        форму результата от вызова плагина. 

      ▪ addListener(eventName: "backButton", listenerFunc: (data: AppUrlOpen) => void): PluginListenerHandle
        отслеживать хардварную кнопку "назад" (только Android)

        Если вы хотите закрыть приложение, вызовите App.exitApp().

    ▪ Примеры

      import { Plugins, AppState } from '@capacitor/core';

      const { App } = Plugins;

      App.addListener('appStateChange', (state: AppState) => {
        // state.isActive contains the active state
        console.log('App state changed. Is active?', state.isActive);
      });

      // Listen for serious plugin errors
      App.addListener('pluginError', (info: any) => {
        console.error('There was a serious error with a plugin', err, info);
      });

      var ret = await App.canOpenUrl({ url: 'com.getcapacitor.myapp' });
      console.log('Can open url: ', ret.value);

      ret = await App.openUrl({ url: 'com.getcapacitor.myapp://page?id=ionicframework' });
      console.log('Open url response: ', ret);

      ret = await App.getLaunchUrl();
      if(ret && ret.url) {
        console.log('App opened with URL: ' + ret.url);
      }
      console.log('Launch url: ', ret);

      App.addListener('appUrlOpen', (data: any) => {
        console.log('App opened with URL: ' +  data.url);
      });

      App.addListener('appRestoredResult', (data: any) => {
        console.log('Restored state:', data);
      });

    ▪ Интерфейсы

      -

  • Background Task API

    ▪ Поддерживаемые платформы

      - ios
      - android

    ▪ Описание

      Background Task API позволяет легко запускать фоновые
      задачи. В настоящий момент этот плагин поддерживает
      запуск фоновых задач, когда приложение само находится
      в фоне, и скоро будет поддерживать periodic background
      fetch operation.

      Мобильные операционные системы имеют строгие, и часто
      меняющиеся методические рекомендации для задач, 
      выполняющихся в фоне. Только пиложениям, выполняющим
      следующие операции, разрешено бесконечно висеть в
      фоновом режиме:

        ▪ проигрывать аудио;
        ▪ поддерживать VoIP-соединения;
        ▪ отслеживать геолокацию в навигационных целях;
        ▪ ...и ограниченный список других задач...

      Все прочие приложения могут лишь выполнять периодические,
      короткие задачи в фоне, такие, как:

        ▪ завершение загрузки файла, когда приложение отправляется в фон;
        ▪ периодическая синхронизация данных.

      Плагины, которые претендуют на то, что они будут 
      выполнять бесконечные фоновые операции, которые 
      не укладываются в перечисленный выше небольшой
      списочек, не пройдут модерацию в Store'ах! Это
      ограничение не только для тех, кто использует
      Capacitor, а вообще для всех мобильных разработчиков.

      В общем, Android менее строк по отношению к фоновым
      задачам, но в любом случае, вы должны разрабатывать
      ваше приложение, ориентируюсь на наиболее строгие
      ограничения, чтобы оно прошло на всех платформах.

    ▪ API

      ▪ beforeExit(cb: Function): CallbackID
        запустить короткоживущую фоновую задачу при переходе приложения в фон

        Это позволит убедиться, что ваше приложение завершит
        любую работу, которую должно доделать (например,
        завершение загрузки файла, или сетевого запроса).

        Это особенно важно на iOS, поскольку любые операции
        обычно приостанавливаются без инициации фоновой
        задачи.

        cb: Function
        Это задача, которая должна запуститься, когда приложение
        перейдёт в фон, но перед его уничтожением.

      ▪ finish(options: { taskId: CallbackID}): void
        уведомить OS, что задача фсё, и OS может продолжить класть приложение в фон

    ▪ Примеры

      import { Plugins } from '@capacitor/core';

      const { App, BackgroundTask } = Plugins;

      App.addEventListener('appStateChange', (state) => {

        if (!state.isActive) {
          // The app has become inactive. We should check if we have some work left to do, and, if so,
          // execute a background task that will allow us to finish that work before the OS
          // suspends or terminates our app:

          let taskId = BackgroundTask.beforeExit(async () => {
            // In this function We might finish an upload, let a network request
            // finish, persist some data, or perform some other task

            // Example
            setTimeout(() => {
              // Must call in order to end our task otherwise
              // we risk our app being terminated, and possibly
              // being labled as impacting battery life
              BackgroundTask.finish({
                taskId
              });
            }, 30000); // Set a long timeout as an example
          });
        }
      })

    ▪ Интерфейсы

      type alias CallbackID {
      
      }

  • Browser APi
  
    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron

    ▪ Описание

      открытие внут.браузера приложения, обработка аутентификации, и пр.

      На iOS этот плагин использует SFSafariViewController 
      и соответствует ведущим требованиям oAuth в 
      приложениях для браузера.

    ▪ API

      ▪ close(): Promise<void>
        закрыть браузер (только в iOS)

      ▪ open(options: BrowserOpenOptions): Promise<void>
        открыть страницу с указанным URL во внут.браузере

      ▪ prefetch(options: BrowserPrefetchOptions): Promise<void>
        намекнуть браузеру, что укзазанные URLs будут открыты (чтобы улучшить время загрузки для клиента)

      ▪ addListener(eventName: "browserFinished", listenerFunc: (info: any) => void): PluginListenerHandle
        браузер закончил

      ▪ addListener(eventName: "browserPageLoaded", listenerFunc: (info: any) => void): PluginListenerHandle
        страница браузера загружена

    ▪ Примеры

      import { Plugins } from '@capacitor/core';

      const { Browser } = Plugins;

      await Browser.open('http://capacitor.ionicframework.com/');

    ▪ Интерфейсы

      interface BrowserOpenOptions {
        // A hex color to set the toolbar color to.
        toolbarColor ?: string
        // The URL to open the browser to
        url : string
        // Web only: Optional target for browser open. Follows the `target` property for window.open. Defaults to _blank
        windowName ?: string
      }

      interface BrowserPrefetchOptions {
        urls : any
      }

  • Camera API
  
    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron

    ▪ Описание

      доступ к камере и фотоальбому

      На iOS, этот плагин использует UIImagePickerController,
      а на Android шлёт intent (намерение), которое будет
      обработано по умолчанию core-приложением камеры.

      ▪ Замечания на iOS

        iOS требует, чтобы для вашего приложения в Info.plist
        были добавлены следующие ключ-значение:

        Ключ: Privacy - Camera Usage Description
        Значение: NSCameraUsageDescription

        Почитайте по поводу добавление прав доступа в iOS 
        (https://capacitor.ionicframework.com/docs/apis/ios/permissions/)
        в руководстве по iOS (https://capacitor.ionicframework.com/docs/apis/ios/).

      ▪ Замечания на Android

        Этот API требует, чтобы следующие права доступа были
        добавлены в AndroidManifest.xml:

          <uses-permission android:name="android.permission.CAMERA" />
          <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
          <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

        Доступ к камере, доступы к хранилищу (чтение/запись).

        Почитайте подробнее по поводу добавления прав доступа
        в Android (https://capacitor.ionicframework.com/docs/apis/android/permissions/)
        в руководстве по Android (https://capacitor.ionicframework.com/docs/apis/android/).

        Дополнительно, поскольку Camera API запускает дополнительную
        Activity для обработки взятых фото, вам понадобится
        слушать событие appRestoredResult в плагине App для
        обработки любых данных, которые были отправлены в 
        случае, когда ваше приложение было уничтожено
        операционной системой в то время, пока Activity 
        ещё работала.

    ▪ API

      ▪ getPhoto(options: CameraOptions): Promise<CameraPhoto>
        просит пользователя взять фотку из альбома, или снять камерой

    ▪ Примеры

      import { Plugins, CameraResultType } from '@capacitor/core';

      const { Camera } = Plugins;

      async takePicture() {
        const image = await Camera.getPhoto({
          quality: 90,
          allowEditing: true,
          resultType: CameraResultType.Uri
        });
        // image.webPath will contain a path that can be set as an image src. You can access
        // the original file using image.path, which can be passed to the Filesystem API to
        // read the raw data of the image, if desired (or pass resultType: CameraResultType.Base64 to getPhoto)
        var imageUrl = image.webPath;
        // can be set to the src of an image now
        imageElement.src = imageUrl;
      }

    ▪ Интерфейсы

      interface CameraOptions {

        // Whether to allow the user to crop or make small edits (platform specific)
        allowEditing ?: boolean
        // Whether to automatically rotate the image "up" to correct for orientation in portrait mode Default: true
        correctOrientation ?: boolean
        // The height of the saved image
        height ?: number
        // The quality of image to return as JPEG, from 0-100
        quality ?: number
        // How the data should be returned. Currently, only 'base64' or 'uri' is supported
        resultType : 
        // Whether to save the photo to the gallery/photostream
        saveToGallery ?: boolean
        // The source to get the photo from. By default this prompts the user to select either the photo album or take a photo. Default: CameraSource.Prompt
        source ?: 
        // The width of the saved image
        width ?: number

      }

      interface CameraPhoto {

        // The base64 encoded data of the image, if using CameraResultType.Base64.
        base64Data ?: string
        // Exif data, if any, retrieved from the image
        exif ?: any
        // The format of the image. Currently, only "jpeg" is supported.
        format : string
        // If using CameraResultType.Uri, the path will contain a full, platform-specific file URL that can be read later using the Filsystem API.
        path ?: string
        // webPath returns a path that can be used to set the src attribute of an image for efficient loading and rendering.
        webPath ?: string
        
      }

  • Clipboard API
  
    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron

    ▪ Описание

      управляет copy/paste в/из clipboard

      На iOS этот API также позволяет копировать изображения 
      и URL.

    ▪ API

      ▪ read(options: ClipboardRead): Promise<ClipboardReadResult>
        прочитать значение из clipboard (paste action)

      ▪ write(options: ClipboardWrite): Promise<void>
        записать значение в clipboard (copy action)

    ▪ Примеры

      import { Plugins } from '@capacitor/core';

      const { Clipboard } = Plugins;

      Clipboard.write({
        string: "Hello, Moto"
      });

      let str = await Clipboard.read({
        type: "string"
      });
      console.log('Got string from clipboard:', str.value);    

    ▪ Интерфейсы

      interface ClipboardRead {
        type : any
      }

      interface ClipboardReadResult {
        value : string
      }

      interface ClipboardWrite {
        image ?: string
        label ?: string
        string ?: string
        url ?: string
      }

  • Console API
  
    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron
    
    ▪ Описание

      через console.log отправлять msg не только в web, но и логи нативных платформ

      В настоящий момент эту фичу нельзя отключить.
      Но разработчики Capacitor обещают, что будет можно.

    ▪ API

      ▪ console.log

        Это просто обычный console.log, который мы пишем
        в JS-коде. Capacitor делает так, что он отправляет
        сообщение не только в web, но и в логи нативных
        платформ.

    ▪ Примеры

      console.log('I really enjoy Avocado Toast, and I\'m not ashamed to admit it');

      Это сообщение будет выведено, в том числе, 
      в логи Xcode и Android Studio.

  • Device API
  
    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron

    ▪ Описание

      содержит инфу об устройстве, ОС, платформе, пользователе

    ▪ API

      ▪ getInfo(): Promise<DeviceInfo>
        получить инфу об устройстве, ОС, платформе, пользователе

  • Filesystem API
  
    ▪ Поддерживаемые платформы

      - pwa
      - ios
      - android
      - electron

    ▪ Описание

      NodeJS-подобное API для работы с файлами на устройстве

      ▪ Про специальные директории

        На iOS и Android есть дополнительный слой разделения
        между файлами - специальные директории.

        Например, есть специальные директории, которые
        бэкапятся в облако. А есть оные для хранения
        документов.

        Это API предлагает простой способ указывать, 
        к какой специальной директории относится 
        запрашиваемая операция.

      ▪ Параметр directory

        В дополнение, это API поддерживает использование
        полных путей к файлам в формате "file://",
        или чтение "content://" файлов на Android. 
        Просто оставьте параметр directory, чтобы
        использовать полный путь к файлу. 

    ▪ API

      ▪ appendFile(options: FileAppendOptions): Promise<FileAppendResult>
        добавить в конец файла на диске в указанной локации на устройстве

      ▪ deleteFile(options: FileDeleteOptions): Promise<FileDeleteResult>
        удалить файл с диска

      ▪ getUri(options: GetUriOptions): Promise<GetUriResult>
        получить полный URI файла для пути и каталога

      ▪ mkdir(options: MkdirOptions): Promise<MkdirResult>
        создать папку

      ▪ readFile(options: FileReadOptions): Promise<FileReadResult>
        считать файл с диска

      ▪ readdir(options: ReaddirOptions): Promise<ReaddirResult>
        вернуть (не рекурсивно) список файлов в папке

      ▪ rmdir(options: RmdirOptions): Promise<RmdirResult>
        удалить папку

      ▪ stat(options: StatOptions): Promise<StatResult>
        вернуть инфу о файле

      ▪ writeFile(options: FileWriteOptions): Promise<FileWriteResult>
        - записать файл на диск в указанное место на устройстве

    ▪ Примеры

      import { Plugins, FilesystemDirectory, FilesystemEncoding } from '@capacitor/core';

      const { Filesystem } = Plugins;

      fileWrite() {
        try {
          Filesystem.writeFile({
            path: 'secrets/text.txt',
            data: "This is a test",
            directory: FilesystemDirectory.Documents,
            encoding: FilesystemEncoding.UTF8
          })
        } catch(e) {
          console.error('Unable to write file', e);
        }
      }

      async fileRead() {
        let contents = await Filesystem.readFile({
          path: 'secrets/text.txt',
          directory: FilesystemDirectory.Documents,
          encoding: FilesystemEncoding.UTF8
        });
        console.log(contents);
      }

      async fileAppend() {
        await Filesystem.appendFile({
          path: 'secrets/text.txt',
          data: "MORE TESTS",
          directory: FilesystemDirectory.Documents,
          encoding: FilesystemEncoding.UTF8
        });
      }

      async fileDelete() {
        await Filesystem.deleteFile({
          path: 'secrets/text.txt',
          directory: FilesystemDirectory.Documents
        });
      }

      async mkdir() {
        try {
          let ret = await Filesystem.mkdir({
            path: 'secrets',
            directory: FilesystemDirectory.Documents,
            createIntermediateDirectories: false // like mkdir -p
          });
        } catch(e) {
          console.error('Unable to make directory', e);
        }
      }

      async rmdir() {
        try {
          let ret = await Filesystem.rmdir({
            path: 'secrets',
            directory: FilesystemDirectory.Documents
          });
        } catch(e) {
          console.error('Unable to remove directory', e);
        }
      }

      async readdir() {
        try {
          let ret = await Filesystem.readdir({
            path: 'secrets',
            directory: FilesystemDirectory.Documents
          });
        } catch(e) {
          console.error('Unable to read dir', e);
        }
      }

      async stat() {
        try {
          let ret = await Filesystem.stat({
            path: 'secrets/text.txt',
            directory: FilesystemDirectory.Documents
          });
        } catch(e) {
          console.error('Unable to stat file', e);
        }
      }

      async readFilePath() {
        // Here's an example of reading a file with a full file path. Use this to
        // read binary data (base64 encoded) from plugins that return File URIs, such as
        // the Camera.
        try {
          let data = await Filesystem.readFile({
            path: 'file:///var/mobile/Containers/Data/Application/22A433FD-D82D-4989-8BE6-9FC49DEA20BB/Documents/text.txt'
          })
        }
      }

    ▪ Интерфейсы

      interface FileAppendOptions {
        // The data to write
        data : string
        // The FilesystemDirectory to store the file in
        directory ?: 
        // The encoding to write the file in (defautls to utf8)
        encoding ?: 
        // the filename to write
        path : string
      }

      interface FileAppendResult {
      }

      interface FileDeleteOptions {
        // The FilesystemDirectory to delete the file from
        directory ?: 
        // the filename to delete
        path : string
      }

      interface FileDeleteResult {
      }

      interface GetUriOptions {
        // The FilesystemDirectory to get the file under
        directory : 
        // The path of the file to get the URI for
        path : string
      }

      interface GetUriResult {
        uri : string
      }

      interface MkdirOptions {
        // Whether to create any missing parent directories as well
        createIntermediateDirectories : boolean
        // The FilesystemDirectory to make the new directory in
        directory ?: 
        // The path of the new directory
        path : string
      }

      interface MkdirResult {
      }

      interface FileReadOptions {
        // The FilesystemDirectory to read the file from
        directory ?: 
        // The encoding to read the file in, if not provided, data is read as binary and returned as base64 encoded data.
        encoding ?: 
        // the filename to read
        path : string
      }

      interface FileReadResult {
        data : string
      }

      interface ReaddirOptions {
        // The FilesystemDirectory to remove the directory from
        directory ?: 
        // The path of the directory to remove
        path : string
      }

      interface ReaddirResult {
        files : any
      }

      interface RmdirOptions {
        // The FilesystemDirectory to remove the directory from
        directory ?: 
        // The path of the directory to remove
        path : string
      }

      interface RmdirResult {
      }

      interface StatOptions {
        // The FilesystemDirectory to remove the directory from
        directory ?: 
        // The path of the directory to remove
        path : string
      }

      interface StatResult {
        ctime : number
        mtime : number
        size : number
        type : string
        uri : string
      }

      interface FileWriteOptions {
        // The data to write
        data : string
        // The FilesystemDirectory to store the file in
        directory ?: 
        // The encoding to write the file in (defautls to utf8)
        encoding ?: 
        // the filename to write
        path : string
      }

      interface FileWriteResult {
      }

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы

  • 
  
    ▪ Поддерживаемые платформы
    ▪ Описание
    ▪ API
    ▪ Примеры
    ▪ Интерфейсы







