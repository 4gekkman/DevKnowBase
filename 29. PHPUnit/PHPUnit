////=================================================////
////                                                 ////
////                     PHPUnit                     ////
////                                                 ////
////=================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////

  // Официальные ресурсы //
  //---------------------//

    # Сайт PHPUnit (en)
        https://phpunit.de

    # Руководство v6.2 (en)
        phpunit.de/manual/6.2/en/writing-tests-for-phpunit.html

  // Неофициальные ресурсы //
  //-----------------------//

    # Юнит-тестирование в разработке (YouTube, 50 мин.)
        https://www.youtube.com/watch?v=KAny2OSYY3Y

    # Unit-тестирование и метрики покрытия кода тестами (YouTube, 70 мин.)
        https://www.youtube.com/watch?v=u-mehgfQYsY


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  Теоретические основы

    А1. Зачем нужны тесты в проекте?
    А2. Установка PHPUnit
    А3. Обзор возможностей PHPUnit
    
  # Б.  Практика и наработки

    Б1. 



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Зачем нужны тесты в проекте?

  Я давно хотел добавить PHPUnit в свой стек, но мне было
  непонятно, какую пользу это может принести, потому что
  я разрабатывал в одиночку.

  Теперь, когда мы поставили задачу разрабатывать проекты 
  с привлечением большого количества посторонних 
  разработчиков, стало ясно, зачем нужно покрывать код 
  юнит-тестами.

  В крупном проекте могут задействованы десятки специалистов. 
  Он может состоять из десятков разработанных или разрабатываемых 
  модулей и слотов. Такая ситуация коренным образом отличается 
  от той, когда весь проект пишет один разработчик. 

  В последнем случае у него в голове есть вся картина, и 
  если что-то перестанет работать, он быстро сообразит, 
  что пошло не так. А в первом случае, разработчиков целая 
  куча, и если что-то перестанет работать, никто точно не 
  сможет сказать, что пошло не так. Поэтому, весь бэкенд 
  должен быть на 100% покрыт тестами, и в случае, если 
  что-то пошло не так, автоматическое тестирование существенно 
  облегчить поиск решения.

  Когда главный или старший разработчик решает поручить 
  разработку модуля или слота какому-либо специалисту, 
  он в первую очередь пишет тесты. Такую технику разработки 
  называют TDD - Test-Driven Development.


А2. Установка PHPUnit

--------------------------------------
Подоглавление:

  # Ссылки
  # Требования
  # Установка через Composer

--------------------------------------

> Ссылки

    # [оф.документация] Installing PHPUnit
        https://phpunit.de/manual/6.2/en/installation.html#installation.requirements

> Требования

  ▪ PHP7
  ▪ Дополнения:

    ▪ dom
    ▪ json
    ▪ pcre
    ▪ reflection
    ▪ spl
    ▪ Xdebug (для функции code coverage)
    ▪ tokenizer (для функции code coverage) 
    ▪ xmlwriter (для генерирования xml-докладов)

> Установка через Composer

  ▪ Основной пакет

      composer require --dev phpunit/phpunit ^6.2

  ▪ Дополнительные пакеты

    ▪ PHP_Invoker
      - Чтобы назначать тестам таймауты.
      - Установка:

        composer require --dev phpunit/php-invoker

    ▪ DbUnit
      - Это порт DbUnit для PHPUnit.
      - Для взаимодействия с базой данных во время тестирования.
      - Установка:

        composer require --dev phpunit/dbunit


А3. Обзор возможностей PHPUnit

--------------------------------------
Подоглавление:

  # Ссылки
  # Концепция unit-тестирования
  # Введение

    ▪ Базовые соглашения
      ▪ Имя класса с тестами: ClassTest для класса Class
      ▪ Класс с тестами наследует от TestCase
      ▪ Тесты размещаются в public-методах
      ▪ Assertion-методы внутри методов-тестов

    ▪ Простой пример unit-теста

  # Data Providers: скормить тесту N наборов данных

    ▪ Что такое Data Providers
    ▪ Примеры использования Data Provider
      ▪ 
      ▪ 
      ▪ 


    ▪

--------------------------------------

> Ссылки

  # [оф.документация] Writing Tests for PHPUnit 
      https://phpunit.de/manual/6.2/en/writing-tests-for-phpunit.html

> Концепция unit-тестирования
  
    В современном мире и бизнесе скорость разработки зачастую
    играет ключевую роль в вопросе, будет ли получена прибыль
    от разрабатываемого продукта, или нет. 

    А обеспечить высокую скорость разработки можно лишь вливая 
    в неё средства, и привлекая большое количество разработчиков, 
    чтобы они параллельно работали над различными частями проекта. 

    Один (может, единственный?) разумный путь в таких обстоятельствах,
    в том, чтобы сначала команда руководителя проекта разработала
    MVP интерфейсов и тестов для каждой из частей проекта, и на основе
    этих данных назначила ответственных за ту или иную часть из
    рядовых разработчиков. Они также смогут использовать эти данные
    для построения взаимодействия между разрабатываемой ими частью,
    и другими частями, поскольку все интерфейсы заранее известны.

    Тесты также облегчают поиск неисправностей. Когда проект состоит
    из большого числа кусочков, а над каждым из них трудились в разное
    время по несколько разработчиков, даже руководителю проекта
    может быть трудно найти причину возникающих ошибок, если нет тестов.
    Наличие же тестов делает эту задачу проще.

    Тесты позволяют не бояться вносить изменения в существующий код.
    Ведь если изменение что-то сломает, то мы об этом узнаем,
    ведь соответствующие тесты не будут пройдены.

    Тесты можно запускать все скопом. Это должен делать каждый
    разработчик перед тем, как отправлязть pull request в 
    удалённый репозиторий. Осуществляется это с помощью CLI PHPUnit.

> Введение

  • Базовые соглашения

    ▪ Имя класса с тестами: ClassTest для класса Class
      - Тесты для Class размещаются в классе ClassTest.
      - Примеры: 

        ▪ Для класса User тесты кладём в UserClass.
        ▪ Для класса Group тесты кладём в GroupClass.

    ▪ Класс с тестами наследует от TestCase
      - От \PHPUnit\Framework\TestCase.
      - Обычно наследует, видимо, иногда не наследует.

    ▪ Тесты размещаются в public-методах
      - Класса с тестами.
      - Или можно использовать @test в docblock к методу.

    ▪ Assertion-методы внутри методов-тестов
      - Есть множество различных assertion-методов в PHPUnit.
      - В переводе на русский assertion означает "утверждение".
      - Тестирование и состоит в проверке этих самых утверждений.
      - Assertion-методы применяются внутри методов-классов.

  • Простой пример unit-теста
    - В этом примере мы пишем тест для класса Stack.
    - Поэтому класс с тестами называется StackTest.
    - Тестируем лишь 1 метод класса Stack - pushAndPop - 
      поэтому метод-тест в StackTest называется testPushAndPop.
    - Для простоты, применяем лишь 1 assert-метод assertEquals,
      который просто сравнивает 2 переданных аргумента.
    - Код:

      <?php
      use PHPUnit\Framework\TestCase;

      class StackTest extends TestCase
      {
          public function testPushAndPop()
          {
              $stack = [];
              $this->assertEquals(0, count($stack));

              array_push($stack, 'foo');
              $this->assertEquals('foo', $stack[count($stack)-1]);
              $this->assertEquals(1, count($stack));

              $this->assertEquals('foo', array_pop($stack));
              $this->assertEquals(0, count($stack));
          }
      }
      ?>

> Data Providers: скормить тесту N наборов данных
  
  • Что такое Data Providers
    - Допустим, есть у нас метод-тест.
    - Но мы хотим его применить на нескольких наборах данных.
    - Протестировать различные крайние случаи, и т.п.
    - Не писать же для этого кучу лишних методов-тестов,
      отличающихся только используемыми наборами данных?
    - Решение есть, это Data Provider - метод, который должен
      возвращать массив массивов наборов данных.
    - Какой Data Provider использовать методу-тесту можно
      указать в его docblock с помощью @dataProvider (см.примеры ниже).

  • Примеры использования Data Provider

    ▪ Простой пример; цифровые ключи
      - В возвращаемом DP массиве используются цифровые ключи.
      - То есть: 0,1,2 и т.д. 
      - В случае наличия ошибки, она будет выглядеть примерно так:

          DataTest::testAdd with data set #3 (1, 1, 3)

      - Код теста:

        <?php
        use PHPUnit\Framework\TestCase;

        class DataTest extends TestCase
        {
            /**
             * @dataProvider additionProvider
             */
            public function testAdd($a, $b, $expected)
            {
                $this->assertEquals($expected, $a + $b);
            }

            public function additionProvider()
            {
                return [
                    [0, 0, 0],
                    [0, 1, 1],
                    [1, 0, 1],
                    [1, 1, 3]
                ];
            }
        }
        ?>

    ▪ Простой пример; строковые ключи
      - Отличие от примера выше толко в строковых ключах.
      - Это облегчает чтение отчёта об ошибках, т.к. более описательно:

          DataTest::testAdd with data set "one plus one" (1, 1, 3)

      - Код теста:

        <?php
        use PHPUnit\Framework\TestCase;

        class DataTest extends TestCase
        {
            /**
             * @dataProvider additionProvider
             */
            public function testAdd($a, $b, $expected)
            {
                $this->assertEquals($expected, $a + $b);
            }

            public function additionProvider()
            {
                return [
                    'adding zeros'  => [0, 0, 0],
                    'zero plus one' => [0, 1, 1],
                    'one plus zero' => [1, 0, 1],
                    'one plus one'  => [1, 1, 3]
                ];
            }
        }
        ?>

    ▪ Передача в тест содержимого csv-файла
      - Каждая строка из файла выступает, как набор для теста.
      - Код теста:

          <?php
          use PHPUnit\Framework\TestCase;

          require 'CsvFileIterator.php';

          class DataTest extends TestCase
          {
              /**
               * @dataProvider additionProvider
               */
              public function testAdd($a, $b, $expected)
              {
                  $this->assertEquals($expected, $a + $b);
              }

              public function additionProvider()
              {
                  return new CsvFileIterator('data.csv');
              }
          }
          ?>      

      - Используется вспомогательный класс:

          <?php
          use PHPUnit\Framework\TestCase;

          class CsvFileIterator implements Iterator {
              protected $file;
              protected $key = 0;
              protected $current;

              public function __construct($file) {
                  $this->file = fopen($file, 'r');
              }

              public function __destruct() {
                  fclose($this->file);
              }

              public function rewind() {
                  rewind($this->file);
                  $this->current = fgetcsv($this->file);
                  $this->key = 0;
              }

              public function valid() {
                  return !feof($this->file);
              }

              public function key() {
                  return $this->key;
              }

              public function current() {
                  return $this->current;
              }

              public function next() {
                  $this->current = fgetcsv($this->file);
                  $this->key++;
              }
          }
          ?>      





