////====================================================////
////                                                    ////
////               Docker + Swarm + Infinit             ////
////                                                    ////
////====================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Docker //
  //--------//

    # Официальный сайт Docker
        https://www.docker.com/

    # Официальный репозиторий Docker-образов
        https://hub.docker.com/

    # Полное практическое руководство по Docker: с нуля до кластера на AWS
        https://habrahabr.ru/post/310460/#awsecs


  // Docker Swarm //
  //--------------//

    # Официальная документация Docker Swarm
        https://docs.docker.com/engine/swarm/


  // Infinit //
  //---------//

    # Официальный сайт Infinit
        http://infinit.sh/

    # Persistent Storage for Docker
        https://infinit.sh/docker

    # Docker Volume Plugin
        https://infinit.sh/documentation/docker/volume-plugin

    # Examples of Deployments
        https://infinit.sh/documentation/deployments

    # Playing with Infinit & Docker
        https://media-glass.es/playing-with-infinit-docker-651236e68cf


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А. Общая теоретическая часть #
  # ---------------------------- #

    А1. Задачи руководства, технологии и терминология
    А2. Соответствующая требованиям структура проекта
    А3. Работа с git subtree


  # Б. Docker Swarm #
  # --------------- #

    Б1.


  # В. Infinit Storage Engine #
  # ------------------------- #

    В1.


  # X. Практика и наработки #
  # ----------------------- #

    X1.



////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////

А1. Задачи руководства, технологии и терминология

  --------------------------------------
  Подоглавление:

    # Задачи данного руководства
    # Технологии и терминология

      ▪ Docker и Compose
      ▪ Stateless/Stateful приложения
      ▪ Docker Swarm
      ▪ Infinit Storage Engine
      ▪ VPS/VDS/Дроплет

  --------------------------------------

  > Задачи данного руководства
    - Описать структуру проекта, отвечающую заданным требованиям.
    - Дать практические инструкции для реализаии такого проекта.

  > Технологии и терминология

    • Docker и Compose

      ▪ Что такое Docker
        - Docker позволяет запускать почти любое приложение в контейнере.
        - При этом приложение надёжно изолировано от других контейнеров.
        - Изоляция и безопасность позволяют запускать N контейнеров на 1 хосте.
        - Контейнеры же очень легковесны, ведь они не отягощены гипервизорами.
        - Легковесность контейнеров позволяют получать больше от серверного железа.

      ▪ Docker engine
        - Клиент-серверное приложение.
        - Состоит из Docker-сервера (демона);
          REST API интерфейса для взаимодействия с ним;
          и Docker-клиента (CLI), который взаимодействует с сервером
          через REST API-слой.

      ▪ Docker Hub
        - Docker Hub, это публичный репозиторий от создателей Docker.
        - В нём хранятся образы, которые можно скачивать и использовать.
        - Публичные репозитории бесплатны, приватные платны. Как на github.
        - Образ на Docker Hub связан с соотв.репозиторием на github,
          и при любых изменениях в последнем, срабатывает веб хук,
          и образ на Docker Hub автоматически пересобирается.

      ▪ Docker Compose
        - Это отдельное консольное приложение.
        - Для настройки и запуска много многоконтейнерных приложений.
        - Всё необходимое для этого описывается в 1-ом compose-файле.
        - Compose-файл имеет формат yml.

    • Stateless/Stateful приложения

      ▪ Stateless приложения
        - Это приложения, не имеющие состояния.
        - После выключения никаких данных не сохраняется.
        - Перезагрузка сбрасывает состояние такого приложения к исходному.
        - Например, такое приложение может использовать в качестве хранилища
          данных Redis, но у которого отключено постоянное хранение данных.
        - А вот, например, MySQL такое приложение использовать не может,
          ведь для него надо постоянно хранить данные, которые должны
          сохраняться даже после выключения и перезагрузки приложения.

      ▪ Stateful приложения
        - Это приложения, имеющие и сохраняющие состояние.
        - Его можно включать/выключать/перезагружать, и при очередном
          включении приложение будет находиться в том же состоянии,
          что перед предыдущим выключением.
        - Чтобы приложение было stateful, у него должна быть возможность
          где-то хранить данные о своём состоянии на постоянной основе.
        - Например, используя MySQL. Состояние приложения будет храниться
          в базах данных, которые никуда не исчезают даже после выключения
          приложения.

    • Docker Swarm

      ▪ Общая информация
        - Система объединения экземпляров docker engine в кластер.
        - Сами docker engine могут находиться на разных машинах.
        - Система позволяет осуществлять мониторинг и управление кластером.

      ▪ Менеджер и воркеры
        - Каждому узлу кластера может быть назначена одна из двух ролей.
        - Менеджеры могут управлять кластером, и хранять информацию о нём.
        - Воркеры служат для запуска на них какого-то кода, и работают на кластер.

      ▪ Подробнее
        - Читай в разделе "Б. Docker Swarm".

    • Infinit Storage Engine

      ▪ Бесплатен и open-source
        - На данный момент (03.05.2017) Infinit является open-source проектом.
        - И пользоваться и можно невозбранно и бесплатно.

      ▪ Децентрализованное хранилище
        - Infinit, это софт для организации децентрализованного хранилища данных.
        - Из коробки в community edition поддерживает 3 интерфейса:

          ▪ [block] NBD (Network Block Device)
          ▪ [object] Amazon S3
          ▪ [file] FUSE & Dokan

      ▪ Интеграция с Docker
        - На данный момент (03.05.2017) есть Docker Volume Plugin.
        - Он позволяет docker'у ведить infinit volume, убедиться можно,
          введя команду: docker volume ls.

      ▪ Подробнее
        - Читай в разделе "В. Infinit Storage Engine".

    • VPS/VDS/Дроплет
      - Все термины обозначают в данном руководстве одно и тоже.
      - Виртуальный выделенный сервер, запущенный на базе физического.
      - Некоторые сервисы придумывают свои названия, как, например,
        Digital Ocean называет их "дроплеты".


А2. Соответствующая требованиям структура проекта

  --------------------------------------
  Подоглавление:

    # Требования к структуре проекта
    # Список главных действующих лиц
    # Отделяем stateless-части приложения от stateful-частей
    # Описываем старую структуру, чтобы понять, как превратить её в новую
    # Описываем, как должна выглядеть новая структура проекта

      ▪ Структура файлов и папок
      ▪ Локальная разработка
      ▪ Запуск копий проекта на воркерах

  --------------------------------------

  > Требования к структуре проекта

    • Полное отделение stateful- от stateless-части приложения.
    • Полная интеграция stateless-частей приложения в docker-образы.
    • Хранение stateful-частей всех приложений в одном месте.
    • Мониторинг и управление всеми экземплярами приложения из единого центра.
    • Центр, экземпляры, каждый из них должен располагаться на отдельном vps.
    • Возможность комфортно вести отладку и разработку локально.
    • Docker-образы становятся персонализированными, связанными с конкретным проектом.

  > Список главных действующих лиц
    - CLI-приложение
    - Конфиги
    - Данные MySQL/Redis
    - Логи
    - Всякое прочее
    - Nodejs-приложение
    - Laravel-приложение
    - Папка storage laravel-приложения
    - Docker-образы: server, redis, mysql, nodejs.
    - Github-репозитории: docker-образов, пакетов проекта, самого проекта.

  > Отделяем stateless-части приложения от stateful-частей

    • Stateless
      - Laravel-приложение
      - Nodejs-приложение
      - Docker-образы: server, redis, mysql, nodejs.
      - Github-репозитории: docker-образов, пакетов проекта, самого проекта.
      - CLI-приложение

    • Stateful
      - Данные MySQL/Redis
      - Логи
      - Папка storage laravel-приложения
      - Конфиги
      - Всякое прочее

  > Описываем старую структуру, чтобы понять, как превратить её в новую

    /Github-репозитории: docker-образов
    /Github-репозитории: самого проекта
      .git
      /Конфиги
      /Данные MySQL/Redis
      /Логи
      /CLI-приложение
      /Всякое прочее
      /Nodejs-приложение
      /Laravel-приложение
        /Папка storage laravel-приложения
        /Github-репозитории: пакетов проекта

  > Описываем, как должна выглядеть новая структура проекта

    • Структура файлов и папок

      /app                          | Корневой каталог проекта
        /.git                       | - git-файлы проекта
        /stateless                  | - stateless-часть проекта, компоненты добавляются в прокет, как поддеревья
          /nodejs                   | -- docker-образ, stateless-код
          /mysql                    | -- docker-образ, stateless-код
          /redis                    | -- docker-образ, stateless-код
          /nginx                    | -- docker-образ, stateless-код
            /data                   | --- код, файлы для интеграции в образ с помощью COPY (для этого образа aka project без stateful-составляющей)
              /vendor/4gekkman/[p]  | ---- пакеты вендора 4gekkman, добавляются в проект, как поддеревья
                ...data...          | ----- данные пакета
            DockerFile              | --- описание образа
            readme.md               | --- readme
            .dockerignore           | --- какие файлы не должны попасть на docker-hub
        /stateful                   | - stateful-часть проекта (экземпляры)
          /local                    | -- локальный экземпляр
          /instance1                | -- экземпляр №1
          /instance2                | -- экземпляр №2
          /instance3                | -- экземпляр №3
          /instance4                | -- экземпляр №4
            /mysql                  | --- данные mysql
            /redis                  | --- данные redis
            /logs                   | --- логи
            /configs                | --- скомпилированные конфиги
            /storage                | --- папка storage из laravel
            /other                  | --- прочие stateful-данные
        /cli                        | - cli для управления экземплярами на локалке и воркерах
        /configs                    | - группы исходников конфигов
          /dev                      | -- применяются для локальной разработки
          /prod                     | -- применяются для деплоня на воркеты в кластер
        /other                      | - всякий хлам, который может относиться к приложению
        app                         | - точка входа для cli приложения
        autosave2github.ps1         | - powershell-скрипт для push-а во все внешние репы (главный, stateless-образы, пакеты вендора 4gekkman)
        .gitignore                  | - какие файлы не должны попасть в удалённый git-репозиторий;

    • Что содержит .gitignore (stateful-часть приложения)

      /stateful/*

    • Локальная разработка
      - Проект запускается на локальной машине.
      - При этом применяется фаервол.
      - Используются исходники конфигов из папки /dev.
      - CLI-скрипт UP компилирует docker-compose.yml,
        а также прочие конфиги, запускает приложение
        с помощью docker-compose, и настраивает фаервол.
      - Используются stateful-данные из локальной папки local,
        а не пробрасываются из Infinit-volume.
      - Папки со stateless-кодом в контейнерах подменяются
        с помощью volume оными из соотв.папок в stateless.
        Так, что можно разрабатывать код в режиме realtime.

    • Работа на менеджере
      - Для провижн на менеджере используется sh-скрипт,
        но без фаервола.
      - Проект просто-напросто клонируется сюда с github,
        и можно работать.

    • Запуск копий проекта на воркерах
      - Для провижн воркеров используется sh-скрипт,
        но без фаервола.
      - Используются исходники конфигов из папки /prod.
      - CLI-скрипт UP компилирует docker-compose.yml,
        а также прочие конфиги, запускает приложение на воркере
        с помощью docker deploy.
      - Никакого фаервола не применяется, безопасность обеспечивается
        тем, что из контейнеров на хост пробрасываются только те
        порты, которые должны быть общедоступны. А с базами работа
        идёт с локалки, подключив их с менеджера через Infinit.
      - Используются stateful-данные из папки <id воркера>,
        они пробрасываются из Infinit-volume.
      - Самое интересное, что на воркерах вообще не будет
        папки с проектом. Там будут запущены контейнеры,
        как описано в docker-compose, а stateless-часть
        приложения будет интегрирована в контейнеры.
        Но к воркеру будет с помощью infinit подключён volume
        со stateful-данными приложения, которые будут проброшены
        часть в один контейнер, часть в другой.


А3. Работа с git subtree

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Общие сведения о git subtree

      ▪ Это CLI-команда
      ▪ Её создал Avery Pennarun
      ▪ Позволяет добавлять в подкаталоги подпроекты
      ▪ Не подмодули

    # Справочник по subtree cli

      ▪ git subtree           | показать справку
      ▪ git subtree add       | создать поддерево (импорта из репо), сделать коммит в проект
      ▪ git subtree pull      | делает pull из поддерева из удалённого репозитория
      ▪ git subtree push      | делает push в поддерево удалённого репозитория

      ▪ git subtree split     | извлекает историю поддерева по его <prefix>
      ▪ git subtree merge     |

    # Туториал и практическое руководство

  --------------------------------------

  > Ссылки

    # Официальная документация git subtree
        https://github.com/git/git/tree/master/contrib/subtree

    # The power of Git subtree
        https://developer.atlassian.com/blog/2015/05/the-power-of-git-subtree/

    # Git: submodules vs. subtrees
        https://andrey.nering.com.br/2016/git-submodules-vs-subtrees/

    # git subtrees: a tutorial
        https://medium.com/@v/git-subtrees-a-tutorial-6ff568381844

  > Введение
    - Часто нужно один git-репозиторий включить в другой.
    - Раньше я использовал подмодули, но они меня разочаровали.
    - С ними очень много проблем, поэтому я решил перейти на subtree.
    - В этой главе будет описана практика работы с subtree.

  > Общие сведения о git subtree

    • Это CLI-команда
      - Она дополняет git cli.

    • Её создал Avery Pennarun
      - apenwarr@gmail.com

    • Позволяет добавлять в подкаталоги подпроекты
      - Включая или не включая их полную историю последних.
      - Например, есть проект, в который нужно добавить библиотеку.
      - Вот её как раз и можно добавить в подкаталог проекта, как subtree.

    • Не подмодули
      - Не надо подать subtree с submodule.
      - Хоть у них и одинаковые задачи, но решения это разные.
      - В отличие от подмодулей, поддеревья:

        ▪ Не требуют наличия в репозитории конструкций типа .gitmodule или gitlinks.
        ▪ Конечному пользователю не нужно что-то знать о поддеревьях.
        ▪ Содержимое каталогов-поддеревьев содержится на github-репозитории проекта,
          и при клонировании проекта с github также клонируется.

  > Справочник по subtree cli

    •••••••••••••••••••••
    •• git subtree add ••
    •••••••••••••••••••••

      ▪ Параметры

        --prefix=<prefix> <commit>
        --prefix=<prefix> <repository> <ref>

      ▪ Описание
        - Создать поддерево <prefix>.
        - Импортировав содержимое из <repository>, ветки <ref>.
        - Новый коммит в основной проект будет создан автоматом.

      ▪ Опции

        --squash  | импортировать только 1 коммит из подпроекта, а не всю историю

      ▪ Примеры
        - Допустим, надо добавить в проект app подпроект git-subtree.
        - Делаем cd в каталог app.
        - И выполняем:

          git subtree add --prefix=git-subtree --squash git://github.com/apenwarr/git-subtree.git master

    ••••••••••••••••••••••
    •• git subtree pull ••
    ••••••••••••••••••••••

      ▪ Параметры

        --prefix=<prefix> <repository> <ref>

      ▪ Описание
        - Извлекает свежие данные в поддерево <prefix>.
        - Из ветки <ref> удалённого <repository>

      ▪ Опции

        --squash  | импортировать только 1 коммит из подпроекта, а не всю историю

      ▪ Примеры

        git subtree pull --prefix=gitweb git@github.com:whatever/gitweb.git master


    ••••••••••••••••••••••
    •• git subtree push ••
    ••••••••••••••••••••••

      ▪ Параметры

        --prefix=<prefix> <repository> <ref>

      ▪ Описание
        - Выполняет split, используя <prefix> (извлекает его историю).
        - Делает git push в ветку <ref> удалённого <repository>.

      ▪ Опции

        --squash  | импортировать только 1 коммит из подпроекта, а не всю историю

      ▪ Примеры

        git push git@github.com:whatever/gitweb.git gitweb-latest:master

    •••••••••••••••••••••••
    •• git subtree split ••
    •••••••••••••••••••••••

      - TODO: Описать по запросу.

    •••••••••••••••••••••••
    •• git subtree merge ••
    •••••••••••••••••••••••

      - TODO: Описать по запросу.

  > Туториал и практическое руководство

    1. Создадим локальный и удалённый репозитории parent
      - Будем использовать его, как основной проект.
      - Создай папку parent, в ней readme.md и file2,
        добавь в них какой-нибудь текст.
      - Сделай git init в этой папке.
      - Создай удалённый репозиторий parent на github.
      - Сделай свяжи локальный репозиторий с удалённым:

          git remote add parent git@github.com:4gekkman/parent.git

      - Выполни первый push в него (из linux, у которого есть доступ к репозиторию):

          git add .
          git add -u .
          git commit -m test
          git push parent master:master

    2. Создадим локальный и удалённый репозитории my-subproject
      - Локально он должен находиться вне папки с parent.
      - Его мы будем подключать в parent, как subtree.
      - Создай папку my-subproject, в ней readme.md и file1,
        добавь в них какой-нибудь текст.
      - Сделай git init в этой папке.
      - Создай удалённый репозиторий my-subproject на github.
      - Сделай свяжи локальный репозиторий с удалённым:

          git remote add my-subproject git@github.com:4gekkman/my-subproject.git

      - Выполни первый push в него (из linux, у которого есть доступ к репозиторию):

          git add .
          git add -u .
          git commit -m test
          git push my-subproject master:master

    3. Добавим my-subproject, как поддерево в parent
      - Делаем cd в parent.
      - И добавляем my-subproject в parent, как поддерево,
        в папку my-subproject/ (в неё будет скопировано содержимое,
        не забудь / в конце; ниже ссылка для анонимного скачивания без ключа):

          git subtree add --prefix=my-subproject/ git://github.com/4gekkman/my-subproject.git master

      - Коммит уже автоматически сделался в parent.
      - Так что, теперь просто делаем push:

          git push parent master:master

      - Заходим на github, и убеждаемся, что там появилась папка my-subproject:
        https://github.com/4gekkman/parent
      - При всём при этом, папка my-subproject не содержит папки .git.
        То есть, она, по сути, часть .git всего проекта.

    4. Меняем локально my-subproject и parent, но делаем push только в parent
      - Мы можем как угодно менять my-subproject и parent.
      - И делать commit и push в parent прямо из my-subproject.
      - Но при этом my-subproject на github никак меняться не будет,
        а все изменения будут поступать только в parent.
      - Для примера:

        ▪ В parent изменим текст в file2.
        ▪ В my-subproject добавим file3.

      - Теперь сделаем commit и выполним push в parent:

        git add .
        git add -u .
        git commit -m test
        git push parent master:master

      - После этого открываем github-репозитории parent и
        my-subproject. В первом изменения видны, а вот
        последний не изменился.
        https://github.com/4gekkman/parent/tree/master/my-subproject
        https://github.com/4gekkman/my-subproject

    5. Внесённые локально изменения push'им в my-subproject
      - В п.4 мы в т.ч. внесли локальные изменения в поддерево my-subproject.
      - Теперь мы хотим сделать push этих изменений в my-subproject на github.
      - Для этого:

        git add .
        git add -u .
        git commit -m test
        git subtree push --prefix=my-subproject git@github.com:4gekkman/my-subproject.git master

      - После этого открываем github-репозиторий my-subproject.
        И видим, что изменения были внесены.











































- Будет один менеджер, и много воркеров.
- У всех будет установлен Docker, Compose, Infinit.
- На менеджере будет папочка с проектом, которая
  будет иметь отдельный github-репозиторий.
- Менеджер будет использовать CLI-команды для запуска проекта на воркерах.
- На менеджере будет папка для постоянных данных приложений,
  запущенных на воркерах.
- При формировании compose-файла при запуске очередного приложения на воркере,
  туда будет пробрасываться соотв.папка с постоянными данными.
  Внутри docker-контейнеров эта папка всегда будет называться одинаково.
- Stateless же части приложения будут интегрированы в docker-образы
  с помощью COPY.
- На локалке вместо docker deploy будет применяться docker compose,
  локальные конфиги, и пробрасываться будут данные из локальной
  папки, а не из удалённой.
- Кроме того, на локалке будут лежать локальные .git репозитории
  всех docker-образов. И при локальной отладке, в docker-compose
  в контейнеры будет пробрасываться соотв.код из этих образов,
  что позволит отлаживать всё в реалтайм, как в старой версии проекта.






    • Stateless/Stateful приложения

      ▪ Stateless приложения
        - Это приложения, не имеющие состояния.
        - После выключения никаких данных не сохраняется.
        - Перезагрузка сбрасывает состояние такого приложения к исходному.
        - Например, такое приложение может использовать в качестве хранилища
          данных Redis, но у которого отключено постоянное хранение данных.
        - А вот, например, MySQL такое приложение использовать не может,
          ведь для него надо постоянно хранить данные, которые должны
          сохраняться даже после выключения и перезагрузки приложения.

      ▪ Stateful приложения
        - Это приложения, имеющие и сохраняющие состояние.
        - Его можно включать/выключать/перезагружать, и при очередном
          включении приложение будет находиться в том же состоянии,
          что перед предыдущим выключением.
        - Чтобы приложение было stateful, у него должна быть возможность
          где-то хранить данные о своём состоянии на постоянной основе.
        - Например, используя MySQL. Состояние приложения будет храниться
          в базах данных, которые никуда не исчезают даже после выключения
          приложения.

    • ECS vs VPS

      ▪ Управление большим количеством приложений на docker
        - Если у вас лишь 1-но приложение, то обычный VPS вполней сойдёт.
        - Вы его настроите 1 раз, запустите приложение, будете за ним следить.
        - Но что, если вам надо контролировать 10/100/1000-чи docker-приложений?
        - Задача на обычных VPS становится невыполнимой с ростом числа приложений.
        - Тут на помощь приходит Amazon EC2 Container Service.
        - Он берёт на себя настройку, масштабирование, мониторинг.
        - И предоставляет API для управления всем этим делом.
        - Так что, можно написать себе центр управления, и управлять через API.

      ▪ Об Amazon EC2 Container Service (ECS)

        Amazon EC2 Container Service – это высокопроизводительный сервис
        управления контейнерами с высокими возможностями масштабирования.
        Он поддерживает контейнеры Docker и позволяет с легкостью запускать
        приложения в автоматически управляемом кластере инстансов Amazon EC2.
        C Amazon ECS вам не нужно будет самостоятельно устанавливать,
        масштабировать и обслуживать инфраструктуру управления кластерами.
        С помощью простых вызовов API вы сможете запускать и останавливать
        контейнерные приложения Docker, получать данные о состоянии всего
        кластера и пользоваться многими привычными возможностями, например
        группами безопасности, Elastic Load Balancing, томами EBS и ролями IAM.
        Используя сервис Amazon ECS, можно запланировать размещение контейнеров
        в вашем кластере с учетом потребности в ресурсах и требований к
        доступности. Вы также можете интегрировать собственный планировщик
        или планировщики сторонних разработчиков с учетом конкретных
        требований, связанных с вашим бизнесом или приложениями.

      ▪ Stateful-приложения без Infinit (или аналога) на ECS не запустить
        - При запуске приложения на VPS, вы пробрасываете данные в контейнеры.
        - Но ECS просто запускает контейнеры, данные пробрасывать неоткуда.
        - Поэтому, без использования Infinit, stateful-приложения на ECS в пролёте.

    • Упаковка приложения в docker-образ

      ▪ Упаковка stateless-приложения
        - Упаковать оное в docker-образ легко.
        - Просто кладём код с приложением в папку образа, рядом с DockerFile.
        - А в DockerFile копируем код приложения с помощью COPY в котейнер.
        - Для запуска такого приложения достаточно просто запустить котейнер из образа.
        - Это можно сделать, в том числе, и на Amazon Container Service.

      ▪ Упаковка stateful-приложения
        - Ранее это было либо невозможной, либо очень сложной задачей.
        - Ведь контейнеры не могут хранить никакую постоянную информацию.
        - При запуске приложения контейнер создаётся, а при остановке уничтожается,
          вместе со всей накопленной внутри него за время работы информацией.
        - Но теперь Infinit даёт возможность использовать внешнее хранилище,
          которое находится на удалённом сервера, например, в Amazon S3,
          либо на каком-нибудь VPS.
        - Мы упаковываем stateless-часть приложения в docker-образы,
          а данные от stateful-части храним в удалённом хранилище.
        - При запуске контейнера, через плагин Infinit для docker,
          мы пробрасываем каталог из удалённого хранилища в контейнер,
          и получаем stateful-приложение.

  > Задача данного руководства

      Разработать и реализовать на практике архитектуру stateful-приложения,
      в качестве хостинга использующее Amazon EC2 Container Service,
      stateless-часть которого полностью упакована в docker-образы,
      данные stateful-части которого хранятся в Amazon S3,
      и копии которого можно создавать за несколько минут.


А2. Infinit Storage Platform

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Вводная информация об Infinit Storage Platform

      ▪ Open-source, бесплатно
      ▪ Децентрализованное хранилище
      ▪ Особенности Infinit
        ▪ Это софт
        ▪ CLI и API
        ▪ Масштабируемость
        ▪ Самоорганизация
        ▪ Многозадачность
        ▪ Современность
      ▪ Интеграция с Docker

    #



  --------------------------------------

  > Ссылки
    - См.ссылки в начале данного руководства.

  > Вводная информация об Infinit Storage Platform

    • Open-source, бесплатно
      - На данный момент (03.05.2017) Infinit является open-source проектом.
      - И пользоваться и можно невозбранно и бесплатно.
      - Однако, планируется плантая Enterprise-версия с доп.функционалом.
      - Но для целей нашего руководства должно хватить и бесплатной версии.

    • Децентрализованное хранилище
      - Infinit, это софт для организации децентрализованного хранилища данных.
      - Из коробки в community edition поддерживает 3 интерфейса:

        ▪ [block] NBD (Network Block Device)
        ▪ [object] Amazon S3
        ▪ [file] FUSE & Dokan

    • Особенности Infinit

      ▪ Это софт
        - Infinit, это софт, его можно развернуть где угодно.
        - На железке, виртуалке, в контейнере, и т.д.

      ▪ CLI и API
        - Работать с Infinit можно через CLI и API.

      ▪ Масштабируемость
        - Infinit может объединять сколько угодно узлов.
        - И таким образом, можно быстро масштабировать хранилище.

      ▪ Самоорганизация
        - В Infinit действует механизм отказоустойчивости.

      ▪ Много интерфейсов
        - Доступ к данным в Infinit можно получить через много интерфейсов.
        - В community-версии доступны описанные выше интерфейсы.

      ▪ Современность
        - В Infinit встроено много дополнительной полезной функциональности.
        - Такой, как: шифрование, распределённое кэширование, многоузловое резервирование,
          hyper-convergence и multi-tiering.

    • Интеграция с Docker
      - В начале 2017-го Docker купил Infinit.
      - И, поэтому, активно интегрирует его в себя.
      - Подробнее о текущих возможностях в одной из глав ниже.


А3. Amazon EC2 Container Service (ECS)

  --------------------------------------
  Подоглавление:

    # Ссылки
    #



  --------------------------------------

  > Ссылки









Запрос в google: "Amazon Container Service s3 volume"
Amazon Elastic File System
Using Amazon EFS to Persist Data from Amazon ECS Containers
  https://aws.amazon.com/ru/blogs/compute/using-amazon-efs-to-persist-data-from-amazon-ecs-containers/


AWS CloudFormation
https://aws.amazon.com/ru/cloudformation/aws-cloudformation-templates/





Какова должна быть структура приложения?

  • Stateless-часть должна быть чётко отделена от Stateful-части.
  • Stateless-часть должна быть интегрирована в соотв.контейнеры.
  • Stateful-часть должна лежать

Что должно входить в stateless-часть

  • Весь код приложения должен быть частью docker-образов
    - Чтобы не было больше проблем с обновлением.
    - Просто обновил docker-образ и всё.

Что должно входить в stateful-часть

  • Базы данных redis и mysql.
  •




Что мы имеем сейчас
    -






Короче говоря

  • Что касается постоянного хранения данных

    1. Infinit позволяет подключить S3 в папочку на VDS.
    2. В этой папочке можно хранить всю stateful-часть приложения.
    3. Папочку можно пробрасывать в контейнеры.

  • Как быстро и автоматически создать клон сервиса

    - Создаём в Amazon S3 bucket папку для нового экземпляра приложения,
      и заливаем туда шаблон stateful-части приложения.
    - Работаем с digital ocean.
    - Через API создаём новый дроплет.
    - Одновременно передаём туда SSH-ключи.
    - Подключаемся к нему, заливаем провижн-скрипт.
    - Последний устанавливает docker, docker-compose,
      Infinit, подключает S3-хранилище из amazon,
      выполняет другие задачи.
    - Подключаем созданный дроплет к рою через мастера.
    - Мастером отдаём приказ запустить конкретно на
      этом узле docker-compose приложение.

  • GUI для управления docker swarm

    1. http://portainer.io/
    2. https://shipyard-project.com/



Как запускать compose-приложения в определённом ноде swarm'а


Использование docker-compose вместе со swarm
http://docs.master.dockerproject.org/compose/swarm/
http://blog.terranillius.com/post/composev3_swarm/



Я хочу

  1. Создать дроплет.
  2. Выполнить провижн-скрипт.
  3. Пробросить в дроплет папочку из S3.
  4. Подключить дроплет к своему Swarm.
  5. Запустить на дроплете compose-приложение.
  ???
  PROFIT

Как такое приложение будет разрабатываться на локалке

  1. На linux с установленными docker, compose.



Что нужно, чтобы я мог за 5 минут деплоить клоны приложения,
отслеживать статус, легко обновлять, легко разрабатывать на локалке?

  1. Возможность запускать приложение командой
     docker deploy --compose-file docker-compose.yml myapp
    - Придётся избавиться от up и cli на воркерах вообще.
    - Поскольку через docker swarm никакой cli не выполнить.

  2.






План таков
- Будет один менеджер, и много воркеров.
- У всех будет установлен Docker, Compose, Infinit.
- На менеджере будет папочка с проектом, которая
  будет иметь отдельный github-репозиторий.
- Менеджер будет использовать CLI-команды для запуска проекта на воркерах.
- На менеджере будет папка для постоянных данных приложений,
  запущенных на воркерах.
- При формировании compose-файла при запуске очередного приложения на воркере,
  туда будет пробрасываться соотв.папка с постоянными данными.
  Внутри docker-контейнеров эта папка всегда будет называться одинаково.
- Stateless же части приложения будут интегрированы в docker-образы
  с помощью COPY.
- На локалке вместо docker deploy будет применяться docker compose,
  локальные конфиги, и пробрасываться будут данные из локальной
  папки, а не из удалённой.
- Кроме того, на локалке будут лежать локальные .git репозитории
  всех docker-образов. И при локальной отладке, в docker-compose
  в контейнеры будет пробрасываться соотв.код из этих образов,
  что позволит отлаживать всё в реалтайм, как в старой версии проекта.

В конечном счёте
- Надо будет купить дроплет для менеджера,
  выполнить в нём провижн-скрипт менеджера,
  склонировать туда проект, купить домен
  steam-solutions.com, поднять лендос,
  админку, наделать в админке интерфейсов,
  в т.ч. возможность создать клон проекта
  нажатием одной кнопки.
- При поступлении заказа на клон проекта,
  надо будет купить дроплет для воркера,
  выполнить в нём провинжн-скрипт воркера,
  указав токен для подключения к рою менеджера,
  убедиться в наличии Infinit volume с менеджера,
  на менеджере выполнить . app up приложения на воркере,
  убедиться, что приложение запустилось и работает.



