/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
5. Storage engines и подробно об INNODB

> Узнать, какие движки хранилищ поддерживает запущенный сервер MySQL
> Создать несколько таблиц, использующих разные движки
> Конвертировать таблицу на движке MEMORY в таблицу на движке INNODB









-------------------------------------------------- */


-- Узнать, какие движки хранилищ поддерживает запущенный сервер MySQL
SHOW ENGINES;

-- Создать несколько таблиц, использующих разные движки

  -- Указать используемую по умолчанию базу данных
  USE test;

  -- Создать таблицы:

    -- INNODB (обычно идет по умолчанию, указывать не обязательно)
    CREATE TABLE t1 (i INT) ENGINE = INNODB;

    -- CSV
    CREATE TABLE t2 (i INT) ENGINE = CSV;

    -- MEMORY
    CREATE TABLE t3 (i INT) ENGINE = MEMORY;

-- Конвертировать таблицу на движке MEMORY в таблицу на движке INNODB
ALTER TABLE t3 ENGINE = InnoDB;






/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальная справка обо всех storage engines сервера MySQL 5.6
      http://dev.mysql.com/doc/refman/5.6/en/storage-engines.html

  > Все опции и переменные движка INNODB:
      http://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html


*****************************************************

Оглавление:



    > Общая информация о движках хранилищ MySQL 5.6

    > Общая информацию о движке хранилищ INNODB
      > Движок INNODB подходит в подавляющем большинстве случаев
      > Ключевые преимущества INNODB
      > Особенности движка INNODB
      > "Best Practice" для INNODB
      > Настройка конфигурации INNODB

    > Администрирование INNODB
      > Основные задачи администрирования INNODB
      > В каком момент создается system tablespace?
      > Изменение размера файлов Redo Log, и файлов system tablespace.
        > Изменение количества и размера файлов Redo Log
        > Изменение размера файлов system tablespace
      > Резервное копирование и восстановление из копии БД на INNODB
        > Осуществление резервного копирования - есть 4 способа
        > Восстановление базы данных INNODB из бэкапа
      > Перемещение или копирование таблиц INNODB на другую машину

    > Поиск и устранение неисправностей при работе с INNODB
      > Общие рекомендации

    > Опции и системные переменные движка INNODB
      > Общая информация
      > Справочник опций и системных переменных движка INNODB (в конце).

    > Ограничения таблиц INNODB
      > Предупреждения
      > Максимумы и минимумы
      > Типы индексов
      > Ограничения для INNODB-таблиц
      > Ограничения для блокирования (locking) и транзакций

    > Обзор механизмов, обеспечивающих выполнение модели ACID в MySQL
      > Общая информация о модели ACID
      > Как в MySQL реазилован каждый из 4-х главных принципов ACID
        > Atomicity
        > Consistency
        > Isolation
        > Durability

    > Memcached + MySQL = NoSQL database
      > Что такое база данных NoSQL, и зачем она нужна?
      > В чем преимущество возможности работать с одной и той же таблицой, используя
      > Общие сведения о memcached в MySQL

    > Справочник опций и системных переменных движка INNODB


*****************************************************



Общая информация о движках хранилищ MySQL 5.6
> Движки хранилища - storage engines - это компоненты сервера MySQL, которые
  управлеют SQL-операциями для разных типов таблиц.
> Движки в MySQL имеют "подключаемую" архитектуру - их можно подключать и отключать
  прямо на работающем сервере MySQL.
> Установить движок по умолчанию сервера MySQL можно, подключившись к нему с опцией
  --default-storage-engine, или добавить к конфигурационный файл my.ini
  сервера опцию default-storage-engine.
  > Для MySQL > 5.6.3 для временных таблиц (TEMPORARY TABLES) можно
    устновить другой движок по умолчанию, не такой, как для постоянных.
    Для этого можно использовать опцию default_tmp_storage_engine.
> Если при попытке использовать CREATE TABLE или ALTER TABLE был
  указан движок, который по какой-то причине не доступен, то:
  > будет использован движок, указанный по умолчанию - если режим
    работы сервера NO_ENGINE_SUBSTITUTION отключен.
  > будет ошибка, если режим работы сервера NO_ENGINE_SUBSTITUTION включен.
> Для новых таблиц MySQL всегда создает .frm файлы, которые содержат
  информацию о структуре таблиц и колонок.
> Не обязательно, например, в одной базе данных, или одном приложении, для
  всех таблиц использовать 1-ин и тот же движок. Ведь его можно указывать
  любой для каждой таблицы отдельно. Поэтому одни таблицы могут быть на одном
  движке, а другие - на других.


Общая информацию о движке хранилищ INNODB

> Движок INNODB подходит в подавляющем большинстве случаев. Oracle советует
  использовать имеено его всегда, кроме как в особых случаях.
  > INNODB используется в MySQL по умолчанию. Выражение CREATE TABLE по умолчанию
    создает таблицу на INNODB.

> Ключевые преимущества INNODB:
  > DML операции следуют модели ACID - с транзакциями, commit, rallback и
    crush-recovery.
    > DML - Data Manipulation Language. DML операциями считаются SQL выражения
      INSERT, UPDATE и DELETE, а также SELECT ... FOR UPDATE (в таком сочетании).
    > ACID - это описание требований к транзакционной системе, которые были
      сформулированы в конце 70-х годов Джимом Греем.
      > A    - Atomicity (Атомарность)
               > Гарантирует, что никакая транзакция не будет зафиксирована в системе частично.
                 Либо транзакция выполнена полностью, либо не выполнена вообще.
      > C    - Consistency (Согласованность)
               > Завершающаяся транзакция должна фиксировать только допустимые результаты.
                 Перед фиксацией результат должен быть согласован с остальными частями
                 системы, бизнес правилами и так далее. Фиксация результатов транзакции
                 происходит только после согласования, что хранит согласованность всей системы.
      > I    - Isolation (Изолированность)
               > Во время выполнения транзакции, параллельные транзакции не должны
                 оказывать влияния на ее результат.
      > D    - Durability (Надежность)
               > Независимо от проблем на нижних уровнях (например, обесточивание
                 системы), успешно завершенные транзакции должны быть зафиксированы.
                 Если пользователь увидел подтверждение об успешно завершенной транзакции,
                 то так и должно быть - железобетонно.
    > Commit - SQL-выражение, фиксирующее результаты транзакции. Является противоположностью
      выражения rollback.
    > Rollback - SQL-выражение, отменяющее все результаты транзакции. Является
      противоположностью выражения commit.
    > Crash Recovery - процесс, который запускается после запуска сервера MySQL,
      работа которого в прошлый раз была завершена крахом. Для таблиц INNODB
      происходит примерно следующее.
      > Данные о не завершенных транзакциях хранятся в redo log. Сервер заглядывает
        туда, и:
        > Завершенные перед крушением транзакций, которые сервер не успел записать
          в файлы данных, он реконструирует из doublewrite buffer'a, и записывет в
          файлы данных.
        > Для не завершенных перед крушением транзакций сервер отменяет все изменения,
          произведенные ими.
  > Блокирование на уровне строк и согласованное чтение в стиле Oracle, что в совокупности
    повышает удобство одновременной работы с ДБ нескольких пользователей.
    > Блокировка на уровне строк.
      > Выполнение принципа изоляции (Isolation) транзакции. Строки, задействованные
        в транзакции, блокируются - данные в них защищаются от просмотра или изменения
        другими транзакциями.
    > Согласованное чтение в стиле Oracle.
      > Этот механизм позволяет транзакции Х читать данные из строк, которые
        заблокировала транзакция Y - но используется копия этих данных, сделанная
        перед началом транзакции Y - в которой изменения, произведенные ей, не отражены.
        Этот механизм позволяет уменьшит трения, которые возникают из-за реализации
        требований ACID, а именно - требования об изоляции.
  > INNODB организует данные на диске, чтобы оптимизировать запросы, использующие
    FOREIGN KEY.
  > Для поддержки ссылочной целостности БД, INNODB поддерживает ограничения типа
    FOREIGN KEY. Операции с выражениями INSERT, UPDATE и DELETE всегда проводятся
    с оглядкой на установленные с помощью FOREIGN KEY связей между колонками разных
    таблиц, и гарантировано защищены от проблем, связанных с этим. Например, изменение
    колонке с такой связью повлечет автоматические изменения во всех связанных колонках.
    > Техника поддержки ссылочной целостности БД является частью философии ACID.
      > Ее суть в том, что целостность базы данных поддерживается благодаря
        связям-ограничениями типа FOREIGN KEY, действие которых описано выше.
        > Также эта техника включает механизм unique constrant, который позволяет
          избежать insert'a дублированных значений по ошибки.
        > Также эта техника включает NOT NULL constraint, которые предотвращают
          insert пустых значений по ошибке.
  > Можно свободно смешивать таблицы на INNODB с таблицами на других движках MySQL.
    Даже в пределах одного выражения, можно использовать оператор JOIN для комбинации
    данных из INNODB таблицы и, например, MEMORY таблицы.
  > INNODB был спроектирован для максимальной производительности при работе с
    большими объемами данных.
  > INNODB поддерживает свой собственный буфер памяти (buffer pool) для кэширования
    данных и индексов в main памяти.
    > Если опция innodb_file_per_table движка INNODB включена, то каждая новая таблица
      и ассоциированные с ней индексы хранятся в отдельном файле.
    > Если опция innodb_file_per_table выключена, то данные и индексы всех таблиц
      всей базы данных хранятся в одном или нескольких общих файлах.

> Особенности движка INNODB
  ----------------------------------------------------------
    С В О Й С Т В О                  |     З Н А Ч Е Н И Е
  --------------------------------
  1. MAX объем данных                   > 64TB.
  --------------------------------
  2. MVCC - управление конкурентным
     рентным доступом с помощью
     многоверсионности                  > Да
  --------------------------------
  3. B-tree indexes - использование
     для поиска структуры данных
     Б-дерево                           > Да
  --------------------------------
  4. Полнотекстовый (Full-text)
     поисковый индекс (MySQL > 5.6.4)   > Да
  --------------------------------
  5. Index caches                       > Да
  --------------------------------
  6. Cluster database support - нет,
     для этого есть
     MySQL Cluster NDB 7.3              > Нет
  --------------------------------
  7. point-in-time recovery / backup
     - возможность восстановить
     состояние БД в указанной
     точке даты и времени.              > Да
  --------------------------------
  8. Транзакционность                   > Да
  --------------------------------
  9. Поддержка геопространственных
     типов данных                       > Да
  --------------------------------
  10. T-tree indexes                    > Нет
  --------------------------------
  11. Clustered indexes - используется
      таблицами на движке INNODB        > Да
  --------------------------------
  12. Compressed data                   > Да
  --------------------------------
  13. Поддержка репликации
      (Replication support)             > Да
  --------------------------------
  14. Query cache support -
      поддержка кэширования запросов    > Да
  --------------------------------
  15. Уровень транзакционной
      блокировки                        > Строка
  --------------------------------
  16. Поддержка индекса гео-
      пространственных типов данных     > Нет
  --------------------------------
  17. Hash indexes                      > Да
  --------------------------------
  18. Data caches                       > Да
  --------------------------------
  19. Encrypted data                    > Да
  --------------------------------
  20. Foreign key support               > Да
  --------------------------------
  21. Update statistics for data
      dictionary                        > Да
  ----------------------------------------------------------

> "Best Practice" для INNODB
  > Использовать primary key во всех таблицах для наиболее часто запрашиваемого
    столбца или столбцов. Либо для столбца с автоинкриментом, если других столбцов
    - кандидатов на присвоение primary key нет.
  > Использование идеи JOIN'ов - извлечение данных из нескольких таблиц, основанное
    на одинаковых значениях ID в колонках, используемых для JOIN. Краткое руководство:
    1. Определить foreign keys на колонках, используемых для JOIN.
    2. Колонки, используемые для JOIN, должны быть объявлены с полностью идентичным
       типом данных во всех используемых для JOIN таблицах.
    3. Foreign keys также распространяют действие выражений DELETE и UPDATE на
       все связанные таблицы автоматически, и предотвращают вставку данных в
       дочернюю таблицу, если соответствующего ID нет в родительской таблице.
  > Выключить autocommit. INNODB начинает работать медленно, если происходит
    много commit'ов. Лучше собрать все выражения в единый пакет, затем
    сделать "commit" для всего пакета сразу. Так будет работать намного быстрее.
  > Как описано выше, группировать связанные DML операции в транзакции. Для этого
    перед этими операциями использовать выражение START TRANSACTION, и после них
    выражение COMMIT, которое отправляет всю группу операций на сервер единой
    транзакцией.
  > Не использовать выражение LOCK TABLE. Потому что INNODB позволяет одновременно
    для одного и того же значения проводить запись и чтение данных, и управлеят
    lock'om на уровне строк автоматически.
     Чтобы получить эксклюзивные права на запись в конкретную строку или строки,
     использовать синтаксис SELECT ... FOR UPDATE.
  > Включить опцию движка INNODB - innodb_file_per_table - для записи данных и индексов
    для каждой таблицы в отдельный файл, вместо их записи в один гигантский общий для
    всех таблиц файл. Это необходимо для работы некоторой доп. функциональности.
  > Присмотреться к возможности сжатия (compression) таблиц и индексов без потери
    возможности записи/чтения.
  > Запускать сервер MySQL с опцией --sql_mode=NO_ENGINE_SUBSTITUTION.
    > Ее отсутствие означает, означает, что в случае отсутствия возможности использовать
      указанный ENGINE, сервер автоматически использует тот, что указан по умолчанию.
    > Ее присутствие означает в такой ситуации, что сервер выдаст ошибку.

> Настройка конфигурации INNODB
  > Описана здесь: http://dev.mysql.com/doc/refman/5.6/en/innodb-configuration.html
  > Может быть произведена 2-мя способами:
    > Опции INNODB и их значения записываются в конфигурационный файл my.ini сервера
      MySQL.
    > ... либо, если требуется настроить конфигурацию INNODB только для этого подключения,
      опции и их значения указываются прямо в командной строке инструмента mysql shell.
  > Настройка способа хранения данных движком INNODB
    > Есть 3 места, где INNODB хранит вообще все данные, которыми он управляет:
      1. System tablespace
         > Это файлы с именами ibdata1, ibdata2, ... , в папке "data" сервера MySQL.
           Эти файлы и образуют хранилище данных под названием system tablespace.
         > Это хранилище является автоматически саморасширяемым.
         > В нем хранятся следующие данные:
           - Data dictionary    - метаданные о таблицах INNODB, индексах и колонках.
           - Undo log           - здесь хранятся копии данных (до модификации), которые в настоящий
                                  момент модифицируются какой-то транзакцией. Если другой транзакции
                                  потребуются эти данные - сервер берет их отсюда.
           - Doublewrite buffer - INNODB использует безопасный способ записи данных, сначала все данные
                                  записываются в этот буфер, и только после этого в тот файл данных,
                                  куда было приказано их записать. Это гарантирует, что в файле данных
                                  не появится обрывочных данных, например, при отключении питания в процессе записи.
           - Сhange buffer      - специальная структура данных, которая записывает изменения в pages во вторичные индексы.
                                  Ее работа правоцирутся выражениями INSERT, UPDATE и DELETE.
                                  Изменения записываются в Сhange buffer временно, пока соответсвующая
                                  page из вторичного индекса не в buffer pool'e. А когда она там появляется,
                                  то данные в ней как раз и обновляются из Сhange buffer.
                                  > Buffer Pool - область в памяти, которая содержит кэш
                                    данных для таблиц и индексов у движка INNODB. Для наибольшей
                                    эффективности операций запись/чтение buffer pool разделен на
                                    страницы (pages), которые могут содержать много строк.
                                    > Для эффективного управления кэшем, buffer pool реализован как
                                      список связанных страниц. Редко используемые данные автоматичеки
                                      удаляются из кэша, для этого используется модифицированный LRU алгоритм.
           - Данные из таблиц   - содержимое таблиц по умолчанию хранилось в System tablespace в
                                  MySQL < 5.6.7
      2. Файлы отдельных таблиц .ibd
         > В MySQL >= 5.6.7 данные из таблиц и связанные с ними индексы по умолчанию хранятся в
           отдельных файлах с расширением .idb
           > Где хранятся данные - в отдельных файлах или в system tablespace - контролирует опция
             движка INNODB - innodb_file_per_table. Если она была OFF, а затем ее изменить на ON,
             то новые таблицы будут создаваться и их индексы в отдельных .idb файлах. А старые так
             и останутся в system tablespace.
      3. Лог-файлы.
         > Логи пишутся в файлы ib_logfile0, ib_logfile1, ... в папку "data" сервера MySQL.
         > Redo log - структура данных на диске, которая используется для восстановления
                      после краха (процесс crush recovery), чтобы отменить изменения, сделанные
                      не завершенной транзакцией.
                      > Группа файлов ib_logfileN и составляют Redo Log. Обычно это 2 файла
                        ib_logfile0 и ib_logfile1
                      > Скорость работы Redo Log зависит от Log Buffer - область в памяти,
                        которая содержит данные, предназначенные для записи в log files.
                        Управляет размером Log Buffer'a опция innodb_log_buffer_size.
                      > Для управления Redo Log'ом используют следующие опции:
                        innodb_log_file_size, innodb_log_group_home_dir и innodb_log_files_in_group.
  > Настройка расположения и размера system tablespace файлов.
    > Для настроки system tablespace файлов в INNODB использовать опцию  innodb_data_file_path
      в конфигурационно файле сервера MySQl my.ini, в группе [mysqld].
  > Пример настройки опций движка INNODB в конфигурационном файле my.ini в группе [mysqld] см. по ссылке:
    http://dev.mysql.com/doc/refman/5.6/en/innodb-configuration.html


Администрирование INNODB
> Основные задачи администрирования INNODB
  > В задачи администрирования INNODB в основном входят следующие аспекты:
  1. Управление файлами с данными (data files)
     > ... которые представляет system tablespace, файлы таблиц INNODB (если включена
       опция innodb_file_per_table, и их индексы.
  2. Управление файлами Redo Log, которые используются в процессе crash recovery.
     Можно указывать размеры этих файлов.
     > Про Redo Log см. выше.
  3. Следить за тем, чтобы INNODB использовался для таблиц, предназнаенных для него,
     а не для других механизмов хранения.
  4. Задачи, связанные с управлением производительностью.
     > Производительность можно отслеживать с помощью мониторов производительности,
       и получая обратную связь таким образом, улучшать.

> В каком момент создается system tablespace?
  > INNODB system tablespace - создается при первом старте сервера MySQL. Если запустить
    сервер просто из mysqld.exe, а не как службу windows, то в консоли можно получить
    подробную информацию о том, что происходит.


> Изменение размера файлов Redo Log, и файлов system tablespace.

  > Изменение количества и размера файлов Redo Log
    > Руководство для MySQL >= 5.6.8
      1. Остановить MySQL сервер.
         > Здесь в принципе можно сохранить бэкап старых логов, если нужен.
      2. Редактировать конфигурационный файл my.ini и внести изменения в опции Redo Log'a:
         > innodb_log_file_size         - изменение размера каждого файла
                                          > MAX совокупный размер == 512GB
         > innodb_log_files_in_group    - изменение количества файлов
                                          > Рекомендуемое значение по умолчанию: 2
      3. Запустить сервер MySQL
     *Результат: MySQL увидит, что опции изменились, удалит старые файлы голов и создаст
                 новые.

  > Изменение размера файлов system tablespace.
    > Самый простой способ решить все вопросы с размером system tablespace, это
      в конфигурационном файле my.ini сразу обозначить файлы system tablespace,
      как autoextend - автоматически расширяемые. Например:
      > innodb_data_file_path = /ibdata/ibdata1:10M:autoextend
      > Автоматическое расширение производится в тот момент, когда файл становится
        переполненным, и производится порциями по 8 мегабайт (по умолчанию).
        > Размер порции можно настроить с помощью опции: innodb_autoextend_increment
    > Как расширить system tablespace еще одним файлом? Например, первый файл
      у нас вырос до большого размера в 988 мегабайт, и мы хотим, чтобы
      дальше информацию писалась в другой файл, вообще на другом диске, например.
      Вот руководство, как это сделать:
      1. Остановить MySQL сервер.
      2. В конфигурационном файле my.ini для файла system tablespace убрать
         опцию autoextend, и установить ему фиксированный размер в MB - его
         текущий фактический размер + еще немного.
      3. Добавить в строку-значения опции innodb_data_file_path путь к новому файлу,
         указать его начальное значение и сделать его autoextended.
         *Примечание: autoextended может быть только последний файл в строке-значении.
      4. Запустить сервер MySQL
     *Например (для пунктов 3 и 4):
       innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
    > Как уменьшить размер system tablespace?
      > Основной принцип такой. С помощью mysqldump сделать дамп базы. Снести старые файлы,
        создать новые, уже меньшего размера, и импортировать туда старые данны из дампа.
        Подробнее по ссылке: http://dev.mysql.com/doc/refman/5.6/en/innodb-data-log-reconfiguration.html


> Резервное копирование и восстановление из копии БД на INNODB

  > Осуществление резервного копирования - есть 4 способа
    > Ключом к безопасности всех данных в БД является ежедневное резервное копирование (бэкап)
      в удаленное хранилище. Ответом на вопрос, когда был сделан последний бэкап,
      должно быть "Вчера!".
    > Для MySQL и INNODB есть 4 способа сделать бэкап, их можно использовать все вместе,
      либо по отдельности:
      1. Hot backup.            | > Бэкап работающей базы (без ее отключения). Умный бэкап.
                                  > Приложение, которое делает hot backups, называется
                                    MySQL Enterprise Backup и является частью платной
                                    версии сервера - MySQL Enterprise. Подробности по ссылке:
                                    http://dev.mysql.com/doc/refman/5.6/en/mysql-enterprise-backup.html
                                      > А вообще, есть много сторонних программ для бэкапа и рекавера.
                                    > Работает для таблиц INNODB и MyISAM.
      2. Cold backup.           | > Бэкап выключенной базы.
                                  > Краткое руководство по холодному бэкапу:
                                    1. Выключить сервер MySQL.
                                    2. Скопировать все INNODB data files (ibdata и .ibd)
                                       в безопасное место.
                                    3. Скопировать .frm файлы таблиц на INNODB в безопасное
                                       место (в MySQL любая таблица на INNODB представлена 2-мя
                                       файлами - с расширениями .ibd и .frm).
                                    4. Скопировать INNODB log files (ib_logfileN) в безопасное место.
                                    5. Скопировать конфигурационный файл my.ini сервера MySQL
                                       в безопасное место.
      3. Logical backup.        | > Бэкап с помощью идущего в комплекте с MySQL бесплатного
                                    консольного приложения mysqldump. Он сохраняет бэкап
                                    1-й или нескольких указанных БД:
                                    > Либо на другой SQL-сервер.
                                    > Либо в файл в формате .csv, .txt, .xml.

  > Восстановление базы данных INNODB из бэкапа.
    > Для максимальной безопасности данных периодически надо проводить проверку возможности
      восстановления базы данных из систематически производящихся бэкапов. Это поможет избежать
      ситуации, в которой бэкапы делаются, а при наступлении краха сервера оказывается, что
      они, например, делались неправильно, и восстановить базу данных не получится.
    > Краткое описание восстановления базы в разных ситуациях:
      > Чтобы восстановить БД на INNODB, начиная с точки в прошлом, в которой был взят
        бэкап, до настоящего момента, использовать point-in-time recovery. При этом
        binary logging должен быть включен до той точки во времени, с которой требуется восстановитсья.
        Поднобности по ссылке: http://dev.mysql.com/doc/refman/5.6/en/point-in-time-recovery.html
        > Этот тип бэкапа делается с помощью бесплатной консольной утилиты mysqlbinlog,
          идущей в комплекте с сервером MySQL
      > Для восстановления после краха сервера MySQL, требуется просто перезапустить
        его. Так как INNODB - транзакционный движок - он автоматически сам все подчистит.
      > Восстановление в случае, если файлы базы данных повреждены:
        1. Найти неповрежденный бэкап и восстановиться из него.
        2. Использовать восстановление point-in-time из файлов binary log,
           используя утилиту mysqlbinlog - для восстановления изменений в
           восстанавливаемой БД, произошедших с момента снятия используемого
           в п.1 бэкапа по момент повреждения файлов базы данных.


> Перемещение или копирование таблиц INNODB на другую машину
  > В каких ситуациях это можно применять (примеры):
    > Перенос или копирование таблиц INNODB на другой сервер.
    > Перенос или копирование образа всего MySQL целиком вместе с данными.
    > Клонирование образа всего MySQL вместе с данными на replication slave server.
    > Копирование выбранных INNODB таблиц на другой сервер для разработки и
      тестирования приложения.
  > Особенности переноса таблиц между UNIX и Windows
    > Чтобы после переноса все работало нормально, имена баз данных и таблиц должны
      быть в нижнем регистре полностью. Чтобы решить этот вопрос и не вспоминать о нем,
      можно добавить следующую опцию в конф. файл my.ini в группу [mysqld]:
        lower_case_table_names=1
  > Способы переноса и копирования таблиц INNODB:
    1. Воспользоваться приложением MySQL Enterprise Backup.
       С его помощью снять бэкап, а затем, например, на другом сервера, восстановиться из него.
       Он также позволяет копировать и восстанавливать отдельные таблицы и базы данных.
    2. Просто скопировать файлы, которые указаны выше в Cold backup.
       У этой операции есть свои особенности, описанные по ссылке ниже.
       http://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html




Поиск и устранение неисправностей при работе с INNODB
> Общие рекомендации
  1. Когда операция не сработала и есть подозрения на баг, заглянуть в error log.
     Подробнее о error log здесь: http://dev.mysql.com/doc/refman/5.6/en/error-log.html
  2. Бывает, что операция не может завершиться из-за возникновения deadlock'a.
     > Deadlock - ситуация, когда 2 или более транзакций не могут продолжиться из-за того,
       что другая транзакция заблокировала (lock) данные, нужные этой, и наоборот.
       > Рекомендуется в конфигурационный файл my.ini прописать опцию innodb_print_all_deadlocks,
         благодаря которой информация обо всех deadlock'ах будет попадать в error log.
  3. Проблемы, связанные с INNODB data dictionary (system tablespace). Сюда относятся:
     > Не удавшиеся операции CREATE TABLE
     > Невозможность открыть .InnoDB файлы
     > И ошибки типа: "system cannot find the path specified"
    *Подробнее об этих проблемах здесь: http://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting-datadict.html
  4. Вообще если возникает какая-то проблема, то лучше всего запустить сервер MySQL
     из командной строки (а не как службу windows или через mysqld_safe). В этом случае
     он будет печатать в консоли больше информации о том, что происходит, и легче будет
     понять, в чем состоит неисправность.
     > В windows для старта сервера в рекомендуемом выше режиме ввести в консоли команду:
         mysqld --console
  5. Если есть подозрения, что таблица повреждена, можно использовать CHECK TABLE,
     чтобы это проверить. Хотя, эта операция может не найти некоторые типы повреждений.
  6. Чтобы получить больше информации, можно использовать INNODB Monitors. Подробнее здесь:
     http://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html


Опции и системные переменные движка INNODB

> Общая информация
  > Здесь описаны опции и системные переменные сервера MySQL, относящиеся к движку INNODB.
  > Настроить значения этих опций и системных переменных можно как обычно, 2-мя способами:
    > Указать в консоли при подключении к серверу MySQL. Тогда указанные опции будут
      работать до тех пор, пока существует это подключение.
    > Указать опции в конфигурационном файле my.ini сервера MySQL в группе [mysqld].
      Тогда эти опции будут применятсья постоянно при каждом подключении.
  > Как обращаться с булевыми системными переменными:
    > Если она TRUE, то просто написать ее имя в конф. файле.
    > Если она FALSE, то написать ее имя в конф. файле с приставкой skip-
      (или если это команда в консоли, то --skip-)
    > Например:
      > Для командной строки:
        > Применить переменную:  --innodb_checksums
        > Отменить переменную:   --skip-innodb_checksums
      > Для конфигурационного файла:
        > Применить переменную:    innodb_checksums
        > Отменить переменную:     skip-innodb_checksums
  > Как обращатсья с числовыми системными переменными:
    > Должно быть указано их значение.
    > Например:
      > Для командной строки:
          --var_name=value
      > Для конфигурационного файла:
          var_name=value
  > Не все опции/переменные доступны для настройки из командной строки,
    уточнение по этому поводу см. в справочнике (см. ссылку ниже).
  > Группа опций по управлению расположением data files of INNODB:
      http://dev.mysql.com/doc/refman/5.6/en/innodb-configuration.html
  > Группа опция для настройки производительности работы с INNODB таблицами:
      http://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb.html
     *Примечание: с помощью этой группы настроек, а также информации, полученных
                  во время тестирования производительности базы данных с помощью
                  специальных приложений, можно находить "узкие места" и устранять их,
                  повышая тем самым производительность базы данных.

> Справочник опций и системных переменных движка INNODB.
  > Содержит все опции и переменные с кратким описанием их предназначения.
  > Справочник с подробным описанием для каждой опции/переменной доступен здесь:
      http://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html
  > Справочник: см. в конце ИНФОРМАЦИОННОГО БЛОКА



Ограничения таблиц INNODB
> Предупреждения
  > Не конвертируй движок таблиц MySQL system tables из MyISAM в INNODB.
    Эта операция не поддерживается. Если сделать это, то сервер MySQL
    не запустится, пока замененные system tables не будут восстановлены
    из бэкапа.
  > Не настраивай INNODB так, чтобы он для data и log файлов использовал
    сетевую файловую систему NFS volumes. Иначе файлы могут быть заблокированы
    другими процессами, и стать недоступными для сервера MySQL.

> Максимумы и минимумы
  > Таблица может содержать максимум 1017 колонок.
  > MAX размер index key для каждой колонки <= 767 байт.
  > MAX internal INNODB key <= 3072 bytes.
  > Если уменьшить page size движка INNODB с помощью опции innodb_page_size,
    MAX длина index key уменьшится пропорционально. Например, если уменьшить
    со стандартных 16KB на 8KB, то уменьшится в 2 раза.
  > MAX row length (кроме variable-length колонок: VARBINARY, VARCHAR, BLOB и TEXT)
    немного меньше, чем database page. Под row length здесь, по-видимому, имеется в виду ячейка.
    Так что MAX размер ячейки 8000 bytes для дефолтного page size == 16KB.
  > MAX размер строки (сумма по всем колонкам) <= 65,535 bytes
  > MAX размер любого файла < 2GB - это ограничение некоторых операционных систем.
  > Совокупный размер log files для INNODB <= 512GB
  > Ограничения на размер system tablespace файлов.  MIN > 10MB,  MAX < 64TB.
  > Дефолтный page size == 16KB. Его можно уменьшить до 8KB и 4KB c помощью опции innodb_page_size.

> Типы индексов
  > INNODB поддерживают полнотекстовые индексы (FULLTEXT indexes) для MySQL >= 5.6.4
  > INNODB поддерживет пространственные (spatial) типы данных, но не идексы для них.

> Ограничения для INNODB-таблиц
  > Выражение ANALYZE TABLE позволяет оценить "мощность - cardinality" колонки - количество строк
    в этой колонке с разными значениями. Cardinality отображается в выводе в ответ на
    выражение SHOW INDEX. Ограничение состоит в том, что расчет cardinality производится
    приблизительно, и если выполнить команду несколько раз, результат может несколько различаться.
    Чтобы получить более точный результат, можно собрать статистику и взять среднее.
  > Выражение SHOW TABLE STATUS не дает точную статистику для INNODB-таблиц, кроме
    физического размера таблицы.
  > INNODB не хранит значение количества строк в таблице, потому что конкурентные транзакции
    могут "видеть" разные значения кол-ва строк. Для выполнения операций вроде
    SELECT COUNT(*) FROM t, INNODB сканирует индекс таблицы и считает строки. Это занимает
    много времени, если индекс не полностью в buffer pool'е. Чтобы это ускорить:
    > Можно самостоятельно создать таблицу, в которой будет заранее подсчитанное кол-во строк
      для всех таблиц.
    > Либо, если приблизительное значение кол-ва строк устраивает, можно использовать
      данные из SHOW TABLE STATUS.
  > В ОС Windows INNODB внутри себя сохраняет имена таблиц и БД в нижнем регистре.
    Поэтому во имя избежания проблем переноса между UNIX и Windows, рекомендуется
    всегда делать названия таблицы и БД в нижнем регистре.
  > Во время работы с таблицей, в которой есть колонка с автоинкриментом, при отправке
    на сервер выражения, задействующего как-то автоинкримент, вся таблица блокируется
    в специальном режиме AUTO-INC до конца выполнения этого выражения (не всей транзакции).
  > Когда в колонке типа INT с автоинкриментом, автоинкримент достигает MAX возможного
    значения, то следующая INSERT операция выдаст duplicate-key error.
  > В настоящее время каскадные действия с foreign keys не вызывают активацию триггеров.
  > Нельзя создать таблицу с именем колонки, совпадаютим с каким-нибудь внутренним
    именем колонки INNODB (включаяincluding DB_ROW_ID, DB_TRX_ID, DB_ROLL_PTR, and DB_MIX_ID).
    Иначе сервер выдает ошибку 1005 и ссылается на ошибку -1 в сообщении об ошибке.
    Это ограничение применятся только к именам в верхнем регистре. Так что лучше всегода
    использовать нижний регистр.

> Ограничения для блокирования (locking) и транзакций
  > Блокировка в INNODB-таблицах спадает после того, как транзакция подтверждена или отменена.
  > Нельзя заблокировать еще дополнительно другие таблицы в середени транзакции
    с помощью LOCK TABLE - потому что это выражение неявно вызовет COMMTI и UNLOCK TABLES.
  > Ограничение для конкурентных запросов, модифицирующих данные, было изменено с 1023 на
    128 * 1023, то есть увеличено в 128 раз. То есть можно не ограничивать себя в
    количестве коммитов.


Обзор механизмов, обеспечивающих выполнение модели ACID в MySQL
> Общая информация о модели ACID
  > Модель ACID - это набор принципов работы базы данных, который акцентирует внимание
    на надежности, которая очень важна для, например, бизнес-данных.
  > MySQL влючает движок хранилища INNODB, который близко придерживается модели ACID,
    так что данные не повреждаются, а результаты не искажаются даже в исключительных
    обстоятельствах, таких как крах сервера или поломка оборудования.
  > Если полагаться на придерживающиеся модели ACID решения, то нет необходимости
    заново изобретать механизмы проверки целостности или восстановления после краха.
    Конечно, если у вас есть супер надежный софт и мега надежное оборудование,
    то можно отключить часть ACID функционала, и увеличить таким образом произоводительность.
  > ACID - это описание требований к транзакционной системе, которые были
    сформулированы в конце 70-х годов Джимом Греем.
    > A    - Atomicity (Атомарность)
             > Гарантирует, что никакая транзакция не будет зафиксирована в системе частично.
               Либо транзакция выполнена полностью, либо не выполнена вообще.
    > C    - Consistency (Согласованность)
             > Завершающаяся транзакция должна фиксировать только допустимые результаты.
               Перед фиксацией результат должен быть согласован с остальными частями
               системы, бизнес правилами и так далее. Фиксация результатов транзакции
               происходит только после согласования, что хранит согласованность всей системы.
    > I    - Isolation (Изолированность)
             > Во время выполнения транзакции, параллельные транзакции не должны
               оказывать влияния на ее результат.
    > D    - Durability (Надежность и долговечность)
             > Независимо от проблем на нижних уровнях (например, обесточивание
               системы), успешно завершенные транзакции должны быть зафиксированы.
               Если пользователь увидел подтверждение об успешно завершенной транзакции,
               то так и должно быть - железобетонно.
> Как в MySQL реализован каждый из 4-х главных принципов ACID
  > Atomicity              | Атомарность реализована по большей части
                             за счет механизма транзакций.
    > Опция autocommit
    > Выражение COMMIT
    > Выражение ROLLBACK
    > Операционные данные из таблиц INFORMATION_SCHEMA.

  > Consistency            | Целостность включает в основном внутренние процессы INNODB,
                             цель которых - защитить данные от краха.
    > Буфер INNODB doublewrite buffer.
    > Процесс INNODB crash recovery.

  > Isolation              | Изоляция реализована в INNODB виде механизма транзакций, в частности
                             уровень изоляции (isolation level), который применяется к каждой транзакции

    > Опция autocommit
    > Выражение SET ISOLATION LEVEL
    > Блокирование в INNODB на низком уровне (на уровне ячеек).

  > Durability             | Надежность и долговечность - зависит очень от многих факторов,
                             и задействует много разных механизмов.
    > Буфер INNODB doublewrite buffer.
    > Опция innodb_flush_log_at_trx_commit.
    > Опция sync_binlog.
    > Опция innodb_file_per_table.
    > Запись буфера на диск.
    > Устройство бесперебойного питания (UPS)
    > Ежедневные бэкапы

Memcached + MySQL = NoSQL database
> Что такое база данных NoSQL, и зачем она нужна?
  > Все возрастающие запросы к скорости работы веб-приложений порождают определенный
    интерес к упрощенным методам доступа к данным, максимизирующим производительность.
    Эти методы обозначают словом "NoSQL" - потому что основной фишкой этих методов
    является доступ к данным в обход парсера SQL, за счет чего и получают выигрыш в скорости.
  > Подробно работа с таблицами INNODB через memcached описана здесь:
      http://dev.mysql.com/doc/refman/5.6/en/innodb-memcached.html
> В чем преимущество возможности работать с одной и той же таблицой, используя
  стандартный SQL-интерфейс, и используя упрощенный скоростной memcached-интерфейс?
  > Memcached-интерфейс по сравнению с SQL-интерфейсом очень упрощен и урезан.
    Так что если нужны скоростные операции, можно пользоваться memcached-интерфейсом,
    а если нужна функциональность, которой в нем нет, можно пользоваться SQL-интерфейсом.
  > Комбинация простоты и скорости memcached и надежности INNODB обеспечивают пользователям
    лучшее из обоих - SQL и NoSQL - областей.
> Общие сведения о memcached в MySQL
  > Сервер MySQL влючает NoSQL интерфейс, используя встроенный демон memcached,
    который может автоматически хранить, сохранять и извлекать данные из таблиц INNODB,
    превращая MySQL сервер в быстрое "key-value" хранилище для однострочных операций
    INSERT, UPDATE или DELETE.
  > В то же время, можно работать с той же таблицей с помощью SQL таблицы для удобства,
    сложных запросов, не single-row операций, совместимости внутри конкретных приложений,
    и других преимуществ работы через SQL.
  > С NoSQL интерфейсом memcached, вы используете знакомый memcached API, позволяя
    движку INNODB управлять кэшированием памяти (memory caching) используя механизм
    buffer pool.
  > Данные, изменяемые с помощью memcached операций, таких как ADD, SET, INCR -
    сохраняются на диск, используя знакомые INNODB-механизмы, такие как change buffer,
    doublewrite buffer и crash recovery.





******************************************** Справочник опций и системных переменных движка INNODB

Опции для настройки работы с memcached
> daemon_memcached_enable_binlog           | см. 14.2.9. InnoDB Integration with memcached
> daemon_memcached_engine_lib_name         | --//--
> daemon_memcached_engine_lib_path         | --//--
> daemon_memcached_option                  | --//--
> daemon_memcached_r_batch_size            | --//--
> daemon_memcached_w_batch_size            | --//--

> foreign_key_checks                       | = 1 / 0     - вкл/выкл проверку foreign keys
> have_innodb                              | (устарела)
> ignore-builtin-innodb                    | (устарела)
> - Variable: ignore_builtin_innodb	       | --//--
> innodb                                   | = [value]   - загружать или нет движок innodb

> innodb_adaptive_flushing                 | см. 8.5.7. Optimizing InnoDB Disk I/O
> innodb_adaptive_flushing_lwm             | см. 8.5.7. Optimizing InnoDB Disk I/O
> innodb_adaptive_hash_index               | см. 8.5.7. Optimizing InnoDB Disk I/O
> innodb_adaptive_max_sleep_delay          | см. 8.5.7. Optimizing InnoDB Disk I/O

> innodb_additional_mem_pool_size	         | память в байтах для memory pool, который INNODB
                                             использует для хранения data dictionary.

> innodb_api_bk_commit_interval	           | См. 14.2.9. InnoDB Integration with memcached
> innodb_api_disable_rowlock               | --//--
> innodb_api_enable_binlog	               | --//--
> innodb_api_enable_mdl	                   | --//--
> innodb_api_trx_level	                   | --//--

> innodb_autoextend_increment              | размер в MB, на который увеличивается размер файла
                                             system tablespace, объявленного с autoextend опцией (см. подробне выше)
> innodb_autoinc_lock_mode	               | См. Section 5.4.4, “AUTO_INCREMENT Handling in InnoDB”,
> Innodb_available_undo_logs	             | Общее количество доступных undo logs

Опции для настройки буфера buffer pool
> Innodb_buffer_pool_bytes_data	           | число байт в innodb buffer pool
> Innodb_buffer_pool_bytes_dirty	         | число байт в innodb buffer pool (dirty pages)
> innodb_buffer_pool_dump_at_shutdown	     | записывать ли кэшированные страницы в buffer pool при выключении сервера
> innodb_buffer_pool_dump_now              | Immediately records the pages cached in the InnoDB buffer pool
> Innodb_buffer_pool_dump_status	         | The progress of an operation to record the pages held in the InnoDB buffer pool
> innodb_buffer_pool_filename	             | Specifies the file that holds the list of page numbers produced by innodb_buffer_pool_dump_at_shutdown or innodb_buffer_pool_dump_now.
> innodb_buffer_pool_instances	           | The number of regions that the InnoDB buffer pool is divided into
> innodb_buffer_pool_load_abort	           | Interrupts the process of restoring InnoDB buffer pool contents triggered by innodb_buffer_pool_load_at_startup or innodb_buffer_pool_load_now.
> innodb_buffer_pool_load_at_startup	     | указать, что во время старта сервера MySQL автоматически запускается процесс warm up
> innodb_buffer_pool_load_now	             | Immediately warms up the InnoDB buffer pool by loading a set of data pages, without waiting for a server restart.
> Innodb_buffer_pool_load_status	         | The progress of an operation to warm up the InnoDB buffer pool
> Innodb_buffer_pool_pages_data	 	         | The number of pages in the InnoDB buffer pool containing data. The number includes both dirty and clean pages.
> Innodb_buffer_pool_pages_dirty	 	 	     | The current number of dirty pages in the InnoDB buffer pool.
> Innodb_buffer_pool_pages_flushed	 	     | The number of requests to flush pages from the InnoDB buffer pool.
> Innodb_buffer_pool_pages_free	 	 	       | The number of free pages in the InnoDB buffer pool.
> Innodb_buffer_pool_pages_latched	 	     | The number of latched pages in the InnoDB buffer pool
> Innodb_buffer_pool_pages_misc	 	 	 	     | The number of pages in the InnoDB buffer pool that are busy because they have been allocated for administrative overhead, such as row locks or the adaptive hash index
> Innodb_buffer_pool_pages_total	 	 	     | The total size of the InnoDB buffer pool, in pages.
> Innodb_buffer_pool_read_ahead	 	         | The number of pages read into the InnoDB buffer pool by the read-ahead background thread.
> Innodb_buffer_pool_read_ahead_evicted	   | The number of pages read into the InnoDB buffer pool by the read-ahead background thread that were subsequently evicted without having been accessed by queries
> Innodb_buffer_pool_read_requests	 	 	   | The number of logical read requests made to the InnoDB buffer pool.
> Innodb_buffer_pool_reads	 	 	           | The number of logical reads that InnoDB could not satisfy from the buffer pool,
> innodb_buffer_pool_size	                 | The size in bytes of the buffer pool, the memory area where InnoDB caches table and index data.
> Innodb_buffer_pool_wait_free	 	         | Normally, writes to the InnoDB buffer pool happen in the background.
> Innodb_buffer_pool_write_requests	 	     | The number of writes done to the InnoDB buffer pool.

Опции для настройки буфера change buffer
> innodb_change_buffer_max_size	           | MAX размер для change buffer, как процен от размера buffer pool.
> innodb_change_buffering	                 | Режим работы буфера change buffering

Опции для настроки работы с checksum
> innodb_checksum_algorithm	               | Specifies how to generate and verify the checksum stored in each disk block of each InnoDB tablespace.
> innodb_checksums	                       | Вкл/выкл механизм checksum validation

> innodb_cmp_per_index_enabled	           | Enables per-index compression-related statistics in the INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX table
> innodb_commit_concurrency	               | The number of threads that can commit at the same time

Опции по управлению сжатием
> innodb_compression_failure_threshold_pct | Sets the cutoff point at which MySQL begins adding padding within compressed pages to avoid expensive compression failures.
> innodb_compression_level	               | Specifies the level of zlib compression to use for InnoDB compressed tables and indexes.
> innodb_compression_pad_pct_max	         | Specifies the maximum percentage that can be reserved as free space within each compressed page

> innodb_concurrency_tickets	             | Determines the number of threads that can enter InnoDB concurrently

Опции и переменные по работе с данными INNODB
> innodb_data_file_path	                   | The paths to individual InnoDB data files and their sizes.
> Innodb_data_fsyncs	 	                   | The number of fsync() operations so far.
> innodb_data_home_dir	                   | The common part of the directory path for all InnoDB data files in the system tablespace
> Innodb_data_pending_fsyncs	             | The current number of pending fsync() operations
> Innodb_data_pending_reads	 	 	           | The current number of pending reads.
> Innodb_data_pending_writes	 	 	         | The current number of pending writes.
> Innodb_data_read	 	 	 	                 | The amount of data read since the server was started.
> Innodb_data_reads	 	 	                   | The total number of data reads.
> Innodb_data_writes	 	 	                 | The total number of data writes.
> Innodb_data_written	 	                   | The amount of data written so far, in bytes.

> Innodb_dblwr_pages_written	 	 	         | The number of pages that have been written to the doublewrite buffer. См. Section 5.3.1, “InnoDB Disk I/O”.
> Innodb_dblwr_writes	 	 	                 | The number of doublewrite operations that have been performed. See Section 5.3.1, “InnoDB Disk I/O”.

> innodb_disable_sort_file_cache           | If enabled, this variable disables the operating system file system cache for merge-sort temporary files.
> innodb_doublewrite	                     | If this variable is enabled (the default), InnoDB stores all data twice, first to the doublewrite buffer, then to the actual data files
> innodb_fast_shutdown	                   | The InnoDB shutdown mode

> innodb_file_format	                     | The file format to use for new InnoDB tables. Currently, Antelope and Barracuda are supported.
> innodb_file_format_check	               | This variable can be set to 1 or 0 at server startup to enable or disable whether InnoDB checks the file format tag in the system tablespace (for example, Antelope or Barracuda).
> innodb_file_format_max	                 | At server startup, InnoDB sets the value of this variable to the file format tag in the system tablespace (for example, Antelope or Barracuda).
> innodb_file_per_table	                   | When innodb_file_per_table is enabled (the default in 5.6.6 and higher), InnoDB stores the data and indexes for each newly created table in a separate .ibd file, rather than in the system tablespace.


> innodb_flush_log_at_timeout	 	           | Write and flush the logs every N seconds.
> innodb_flush_log_at_trx_commit	         | Controls the balance between strict ACID compliance for commit operations, and higher performance that is possible when commit-related I/O operations are rearranged and done in batches.
> innodb_flush_method	                     | Controls the system calls used to flush data to the InnoDB data files and log files, which can influence I/O throughput.
> innodb_flush_neighbors                   | Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent.
> innodb_flushing_avg_loops                | Number of iterations for which InnoDB keeps the previously calculated snapshot of the flushing state, controlling how quickly adaptive flushing responds to changing workloads

Опции для проблемных ситуаций
> innodb_force_load_corrupted	             | Lets InnoDB load tables at startup that are marked as corrupted.
> innodb_force_recovery                    | The crash recovery mode, typically only changed in serious troubleshooting situations

Опции для настройки FULLTEXT INDEX
> innodb_ft_aux_table	                     | Specifies the qualified name of an InnoDB table containing a FULLTEXT index
> innodb_ft_cache_size	                   | Size of the cache that holds a parsed document in memory while creating an InnoDB FULLTEXT index.
> innodb_ft_enable_diag_print              | Whether to enable additional full-text search diagnostic output.
> innodb_ft_enable_stopword	               | Specifies that a set of stopwords is associated with an InnoDB FULLTEXT index at the time the index is created.
> innodb_ft_max_token_size	               | Maximum length of words that are stored in an InnoDB FULLTEXT index.
> innodb_ft_min_token_size                 | Minimum length of words that are stored in an InnoDB FULLTEXT index.
> innodb_ft_num_word_optimize              | Number of words to process during each OPTIMIZE TABLE operation on an InnoDB FULLTEXT index.
> innodb_ft_server_stopword_table          | Name of the table containing a list of words to ignore when creating an InnoDB FULLTEXT index, in the format db_name/table_name.
> innodb_ft_sort_pll_degree	               | Number of threads used in parallel to index and tokenize text in an InnoDB FULLTEXT index, when building a search index for a large table
> innodb_ft_user_stopword_table	           | Name of the table containing a list of words to ignore when creating an InnoDB FULLTEXT index, in the format db_name/table_name.

> Innodb_have_atomic_builtins	 	           | Indicates whether the server was built with atomic instructions.

> innodb_io_capacity	                     | The innodb_io_capacity parameter sets an upper limit on the I/O activity performed by the InnoDB background tasks, such as flushing pages from the buffer pool and merging data from the insert buffer
> innodb_io_capacity_max	                 | The limit up to which InnoDB is allowed to extend the innodb_io_capacity setting in case of emergency.

> innodb_large_prefix	                     | Enable this option to allow index key prefixes longer than 767 bytes (up to 3072 bytes), for InnoDB tables that use the DYNAMIC and COMPRESSED row formats.
> innodb_lock_wait_timeout	               | The timeout in seconds an InnoDB transaction waits for a row lock before giving up
> innodb_locks_unsafe_for_binlog	         | This variable affects how InnoDB uses gap locking for searches and index scans.

Опции для настройки Redo Log
> innodb_log_buffer_size	                 | The size in bytes of the buffer that InnoDB uses to write to the log files on disk
> innodb_log_compressed_pages	             | Specifies whether images of re-compressed pages are stored in InnoDB redo logs.
> innodb_log_file_size                     | The size in bytes of each log file in a log group.
> innodb_log_files_in_group                | The number of log files in the log group
> innodb_log_group_home_dir	               | The directory path to the InnoDB redo log files, whose number is specified by innodb_log_files_in_group.
> Innodb_log_waits	 	 	                   | The number of times that the log buffer was too small and a wait was required for it to be flushed before continuing.
> Innodb_log_write_requests	 	             | The number of write requests for the InnoDB redo log.
> Innodb_log_writes	 	                     | The number of physical writes to the InnoDB redo log file.

> innodb_lru_scan_depth	                   | A parameter that influences the algorithms and heuristics for the flush operation for the InnoDB buffer pool.

> innodb_max_dirty_pages_pct               | InnoDB tries to flush data from the buffer pool so that the percentage of dirty pages does not exceed this value
> innodb_max_dirty_pages_pct_lwm	         | Low water mark representing percentage of dirty pages where preflushing is enabled to control the dirty page ratio.
> innodb_max_purge_lag	                   | This variable controls how to delay INSERT, UPDATE, and DELETE operations when purge operations are lagging (see Section 14.2.3.11, “InnoDB Multi-Versioning”).
> innodb_max_purge_lag_delay	             | Specifies the maximum delay in milliseconds for the delay imposed by the innodb_max_purge_lag configuration option.

> innodb_mirrored_log_groups               | (устарела)

Управление счетчиками в INFORMATION_SCHEMA.INNODB_METRICS
> innodb_monitor_disable	                 | Turns off one or more counters in the INFORMATION_SCHEMA.INNODB_METRICS table
> innodb_monitor_enable                    | Turns on one or more counters in the INFORMATION_SCHEMA.INNODB_METRICS table
> innodb_monitor_reset	                   | Resets to zero the count value for one or more counters in the INFORMATION_SCHEMA.INNODB_METRICS table.
> innodb_monitor_reset_all	               | Resets all values (minimum, maximum, and so on) for one or more counters in the INFORMATION_SCHEMA.INNODB_METRICS table.

> Innodb_num_open_files	 	 	               | The number of files InnoDB currently holds open.

> innodb_old_blocks_pct	                   | Specifies the approximate percentage of the InnoDB buffer pool used for the old block sublist.
> innodb_old_blocks_time	                 | Non-zero values protect against the buffer pool being filled up by data that is referenced only for a brief period, such as during a full table scan

> innodb_online_alter_log_max_size         | Specifies an upper limit on the size of the temporary log files used during online DDL operations for InnoDB tables
> innodb_open_files                        | This variable is relevant only if you use multiple InnoDB tablespaces. It specifies the maximum number of .ibd files that MySQL can keep open at one time
> innodb_optimize_fulltext_only	           | Changes the way the OPTIMIZE TABLE statement operates on InnoDB tables. Intended to be enabled temporarily, during maintenance operations for InnoDB tables with FULLTEXT indexes.

> Innodb_os_log_fsyncs	 	 	               | The number of fsync() writes done to the InnoDB redo log files.
> Innodb_os_log_pending_fsyncs	 	         | The number of pending fsync() operations for the InnoDB redo log files.
> Innodb_os_log_pending_writes	 	 	       | The number of pending writes to the InnoDB redo log files.
> Innodb_os_log_written	 	                 | The number of bytes written to the InnoDB redo log files.

> innodb_page_size	                       | Specifies the page size for all InnoDB tablespaces in a MySQL instance.
> Innodb_page_size	 	 	                   | (индикатор) The compiled-in InnoDB page size (default 16KB).

> Innodb_pages_created	 	 	               | The number of pages created by operations on InnoDB tables.
> Innodb_pages_read	 	 	                   | The number of pages read by operations on InnoDB tables.
> Innodb_pages_written	 	 	               | The number of pages written by operations on InnoDB tables.

> innodb_print_all_deadlocks	             | When this option is enabled, information about all deadlocks in InnoDB user transactions is recorded in the mysqld error log.
> innodb_purge_batch_size	                 | The granularity of changes, expressed in units of redo log records, that trigger a purge operation, flushing the changed buffer pool blocks to disk.
> innodb_purge_threads	                   | The number of background threads devoted to the InnoDB purge operation.
> innodb_random_read_ahead                 | Enables the random read-ahead technique for optimizing InnoDB I/O.

> innodb_read_ahead_threshold	             | Controls the sensitivity of linear read-ahead that InnoDB uses to prefetch pages into the buffer pool.
> innodb_read_io_threads	                 | The number of I/O threads for read operations in InnoDB.
> innodb_read_only	                       | Starts the server in read-only mode.

> innodb_replication_delay                 | The replication thread delay (in ms) on a slave server if innodb_thread_concurrency is reached.

> innodb_rollback_on_timeout	             | In MySQL 5.6, InnoDB rolls back only the last statement on a transaction timeout by default. If --innodb_rollback_on_timeout is specified, a transaction timeout causes InnoDB to abort and roll back the entire transaction (the same behavior as in MySQL 4.1).
> innodb_rollback_segments	               | Defines how many of the rollback segments in the system tablespace that InnoDB uses within a transaction.

Переменные для мониторинга показателей row lock
> Innodb_row_lock_current_waits	 	 	       | The number of row locks currently being waited for by operations on InnoDB tables.
> Innodb_row_lock_time	 	 	               | The total time spent in acquiring row locks for InnoDB tables, in milliseconds.
> Innodb_row_lock_time_avg	 	 	           | The average time to acquire a row lock for InnoDB tables, in milliseconds.
> Innodb_row_lock_time_max	 	             | The maximum time to acquire a row lock for InnoDB tables, in milliseconds.
> Innodb_row_lock_waits	 	 	               | The number of times operations on InnoDB tables had to wait for a row lock.

Переменные для мониторинга показателей строк
> Innodb_rows_deleted	 	 	                 | The number of rows deleted from InnoDB tables.
> Innodb_rows_inserted	 	                 | The number of rows inserted into InnoDB tables.
> Innodb_rows_read	 	                     | The number of rows read from InnoDB tables.
> Innodb_rows_updated	 	 	                 | The number of rows updated in InnoDB tables.

> innodb_sort_buffer_size	                 | Specifies the size of sort buffers used for sorting data during creation of an InnoDB index
> innodb_spin_wait_delay	                 | The maximum delay between polls for a spin lock

> innodb_stats_auto_recalc                 | Causes InnoDB to automatically recalculate persistent statistics after the data in a table is changed substantially
> innodb_stats_method	                     | How the server treats NULL values when collecting statistics about the distribution of index values for InnoDB tables.
> innodb_stats_on_metadata	               | When this variable is enabled, InnoDB updates statistics during metadata statements such as SHOW TABLE STATUS or SHOW INDEX, or when accessing the INFORMATION_SCHEMA tables TABLES or STATISTICS.
> innodb_stats_persistent	                 | Specifies whether the InnoDB index statistics produced by the ANALYZE TABLE command are stored on disk, remaining consistent until a subsequent ANALYZE TABLE.
> innodb_stats_persistent_sample_pages	   | The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
> innodb_stats_sample_pages	Yes	Yes	Yes	   | (устарело)
> innodb_stats_transient_sample_pages	     | The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.

> innodb-status-file	                     | Controls whether InnoDB creates a file named innodb_status.pid in the MySQL data directory
> innodb_strict_mode	                     | Whether InnoDB returns errors rather than warnings for certain conditions.
> innodb_support_xa	                       | Enables InnoDB support for two-phase commit in XA transactions, causing an extra disk flush for transaction preparation.

> innodb_sync_array_size	                 | Splits an internal data structure used to coordinate threads, for higher concurrency in workloads with large numbers of waiting threads.
> innodb_sync_spin_loops	                 | The number of times a thread waits for an InnoDB mutex to be freed before the thread is suspended

> innodb_table_locks	                     | If autocommit = 0, InnoDB honors LOCK TABLES; MySQL does not return from LOCK TABLES ... WRITE until all other threads have released all their locks to the table.

> innodb_thread_concurrency	               | InnoDB tries to keep the number of operating system threads concurrently inside InnoDB less than or equal to the limit given by this variable.
> innodb_thread_sleep_delay	               | How long InnoDB threads sleep before joining the InnoDB queue, in microseconds.

> Innodb_truncated_status_writes	 	       | The number of times output from the SHOW ENGINE INNODB STATUS statement has been truncated

> innodb_undo_directory	                   | The relative or absolute directory path where InnoDB creates separate tablespaces for the undo logs
> innodb_undo_logs                         | Defines how many of the rollback segments in the system tablespace that InnoDB uses within a transaction.
> innodb_undo_tablespaces	                 | The number of tablespace files that the undo logs are divided between, when you use a non-zero innodb_undo_logs setting.
> innodb_use_native_aio                    | Specifies whether to use the Linux asynchronous I/O subsystem.
> innodb_use_sys_malloc	                   | Whether InnoDB uses the operating system memory allocator (ON) or its own (OFF).
> innodb_version	 	                       | The InnoDB version number.
> innodb_write_io_threads                  | The number of I/O threads for write operations in InnoDB.
> timed_mutexes                            | This variable controls whether InnoDB mutexes are timed.
> unique_checks                            | If set to 1 (the default), uniqueness checks for secondary indexes in InnoDB tables are performed.



******************************************** Конец справочника






-------------------------------------------------- */













