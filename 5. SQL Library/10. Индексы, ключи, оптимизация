/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
10. Индексы, ключи, оптимизация

>


-------------------------------------------------- */










/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальное руководство по оптимизации и индексам:
      http://dev.mysql.com/doc/refman/5.6/en/optimization-indexes.html


*****************************************************
Оглавление:


  > Общая информация об индексах и оптимизации
    > Брифинг
    > Как MySQL использует индексы
      > Индексы и скорость поиска
      > Структура данных B-TREE и индексы
      > В каких случаях и для чего используются индексы
  > Использование первичных ключей (Primary Keys)
  > Использование внешних ключей (Foreign Keys)
  > Одно-столбцовый индекс, типы индексов
    > Как работают подавляющее большинство индексов
    > Префиксные индексы для символьных столбцов
    > Полнотекстовые индексы (FULLTEXT)
    > Пространственные индексы (spatial indexes)
  > Много-столбцовый индекс



*****************************************************



> Общая информация об индексах и оптимизации

  > Брифинг
    > Лучший способ улучшить производительность на SELECT-операциях - создать индексы
      на 1-й или более колонках. Индексы работают как указатели на строки таблицы, которые
      позволяют быстро находить совпадения в WHERE-выражении.
    > Все типы данных в MySQL могут быть проиндексированы.
    > Хотя может быть заманчиво создавать индексы повсюду, однако излишние индексы тратят
      место на диске и время сервера MySQL - на определение, какой индекс использовать.
      Поэтому опримальный для производительности вариант - соблюдать некий баланс.
    > Индексы практически бесполезны в маленьких таблицах, или в таблицах, в которых
      обычно результатом запроса бывает количество строк, близкой к кол-ву строк в таблице.
    > Может произойти такая ситуация, когда я думаю, что мои запросы используют индекс, а
      на самом деле это не так.
      > Поэтому всегда рекомендуется проверять, а использовал ли запрос индекс. Сделать
        это можно с помощью выражения EXPLAIN.

  > Как MySQL использует индексы

    > Индексы и скорость поиска
      > Индексы в колонках используются для быстрого поиска строк с указанными значениями.
      > Без индексов MySQL тупо просматривает все строки, с 1-й по последнюю, чтобы найти
        указанные значения. Это жрет много ресурсов.
      > Если у столбца есть индекс, то MySQL уже не должен просматривать все строки, его
        ореол поиска сокращается. Например, для столбца с 1000 строк, скорость поиска
        увеличивается примерно в 100 раз.

    > Структура данных B-TREE и индексы
      > Большинство индексов в MySQL - PRIMARY KEY, UNIQUE, INDEX и FULLTEXT - сохраняются
        в виде структуры данных B-TREE.
      > Кроме индексов для пространственных (spatial) данных - они используют R-TREE.
      > И таблицы на движке MEMORY также поддерживают hash indexes.

    > В каких случаях и для чего используются индексы:
      > Для быстрого поиска строк, соответствующих запросу в атрибуте WHERE.
      > Для устранения строк из рассмотрения - если возникает выбор между 2-мя или более
        индексами, MySQL использует тот, который нашел меньше строк (the most selective index)
      > Для извлечения строк из других таблиц в JOIN выражениях.
        > MySQL может использовать индексы на колонках более эффективно, если тип и там,
          и там объявлен с тем же размером. Например, VARCHAR(10) и VARCHAR(10).
        > Сравнение колонок разных типов может не использовать индекс, исли сравнение
          невозможно без приведения типов.
      > Для поиска MIN() и MAX() значений в индексированной колонке.
      > Для сортировки или группировки таблицы
      > В некоторых ситуациях, запрос может быть оптимизирован извлечением значения
        без обращения к данным строк таблицы вообще - когда вся необходимая информация
        есть в индексе. Такой индекс называют - covering index.

  > Использование первичных ключей (Primary Keys)
    > Первичный ключ для таблицы ставят на стоблец или группу столбцов, которые
      используются в наиболее важных запросов.
    > В таблицах на движке INNODB данные физически организованы для ултра-быстрого
      поиска и сортировки с использованием колонки или колонок с первичным ключем.
    > Скорость выполнение запросов выигрывает от NOT NULL оптимизации (атрибут столбца).
    > Если твоя таблица большая и важная, но трудно в ней выбрать столбец, который
      можно наделить первичным ключем, то можно создать еще один столбец с AUTO_INCREMENT,
      и наделить первичным ключем его.
      > Эти уникальные ID могут служить указателями на соответствующие строки в других
        таблицах, когда ты объединяешь таблицы с помощью внешнего ключа.

  > Использование внешних ключей (Foreign Keys)
    > Когда в таблице много колонок, и часто запрашиваются разные комбинации этих
      колонок, то может быть эффективно разбить эту таблицу на несколько отдельных
      таблиц, в каждой из ник создать столбец с AUTO_INCREMENT, и наделить его внешним
      ключем. Таким образом, строки всех этих таблиц связаны между собой этими столбцами
      с AUTO_INCREMENT.
      > Это увеличивает производительность, потому что у каждой мелкой таблицы есть
        такой столбец с индексом, и мы запрашивает только данные из той таблицы, из которой
        они нужны, и поиск происходит бысро.

  > Одно-столбцовый индекс, типы индексов

    > Как работают подавляющее большинство индексов
      > Наиболее распространенный тип индексов работает так. Он включает один столбец,
        и сохраняет копии строк из его значений в специальной структуре данных
        (например, B-TREE), которая позволяет осуществлять быстрый поиск заданных значений,
        или диапазонов значений, используя для этого такие операторы в значении выражения
        WHERE, как  = > < BETWEEN IN  и так далее.
      > Максимальный размер индексов на 1 таблицу и на 1 БД определяется используемым
        движком хранилища (см. 5. Storage engines and INNODB).

    > Префиксные индексы для символьных столбцов
      > Используя синтаксис col_name(N) в символьных столбцах с индексом, можно указать,
        что индексировать требуется только первые N символов в строке.
      > Благодаря этой технике можно сделать размер индекса намного меньше, чем он
        мог бы быть при полном индексировании. Особенно при работе со столбцами типа
        TEXT или BLOB (при работе с ними синтаксис вообще требует исползьзования этой техники).
        > Пример:
            CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
      > В INNODB MAX длинна префиксных индексов == 767 байт.

    > Полнотекстовые индексы (FULLTEXT)
      > Используются для осуществления полнотекстового поиска.
      > Работают только в INNODB и MyISAM.
      > Работают только для колонок типа CHAR, VARCHAR и TEXT.
      > Использование полнотекстового индекса исключает использование префиксного индекса
        на этой колонке.
      > Есть ряд оптимизаций, которые можно применить в запросах, осуществляющих поиск
        по колонкам с полнотекстовыми индексами, делающие эти запросы особенно эффективными:
        > Запросы, которые возвращают только ID документа, или ID документа и
          search rank.
        > Запросы, сортирующие совпавшие строки в убывающем порядке по их score, и применяющий
          атрибут LIMIT для ограничения результата N строками. Чтобы эта оптимизация сработала,
          не должно быть атрибута WHERE, и должен быть только 1 атрибут ORDER BY с атрибутом DESC.
        > Запрос, запрашивающий только COUNT(*), без атрибута WHERE. Вместо него использовать
          WHERE MATCH(text) AGAINST ('other_text'), без каких либо сравнительных операторов,
          вроде > 0

    > Пространственные индексы (spatial indexes)
      > MyISAM поддерживает R-TREE для этого типа индексов.
      > Остальные движки поддерживают B-TREE
      > Движок ARCHIVE вообще не поддерживает пространственные индексы.

  > Много-столбцовый индекс
    > MySQL может создавать композитные индексы (много-столбцовые).
    > Много-стобцвовый индекс может охватывать MAX 16 столбцов.
    > В много-столбцовом индексе могут участвовать и префиксные индексы.
    > Много-столбцовый индекс можно считать сортированным массивом, ячейки которого
      содержат значения, созданные объединением значений индексированных колонок.
    > Применять запросы, использующие много-столбцовые индексы, можно по следующим правилам
      (иначе много-столбцовый индекс не сработает):
      > Можно запрашивать либо значения по всем столбцам из композитного индекса.
      > ... либо только по первому, либо только по первому и второму, либо ... и т.д.





-------------------------------------------------- */





















