/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
6. Типы данных в MySQL

> Назначение DEFAULT'ных значений для столбца

> Числа
  > Демонстрация превышения допустимого диапазона
  > Демонстрация использования атрибута display width с атрибутом ZEROFILL
  > Тестирование атрибута AUTO_INCREMENT

> Дата и время
  > Тест десятичных секунд
  > Явное приведение типов       | CAST
  > Автоматическая инициализация и обновление типов TIMESTAMP и DATETIME

> Строки
  > Настройка character set и collation на разных уровнях
  > Работа с типом ENUM




-------------------------------------------------- */

-- Выбрать тестовую базу данных
USE test;


-- Назначение DEFAULT'ных значений для столбца

  -- Создать таблицу с DEFAULT'ными значениями некоторых колонок
  CREATE TABLE deftest (
    id INT(11) default NULL auto_increment,
    s char(60) default NULL,
    abc VARCHAR(10),
    PRIMARY KEY (id)
  );

  -- Посмотреть, у каких столбцов есть DEFAULT'ное значение, а у каких нет
  SHOW CREATE TABLE deftest;



-- Числа

  -- Демонстрация превышения допустимого диапазона

    -- Создать таблицу со столбцом типа TINYINT UNSIGNED
    CREATE TABLE out_of_range(number TINYINT UNSIGNED);

    -- Попробовать записать значение 256
    INSERT INTO out_of_range
        VALUES(256);                -- ERROR 1264: Out of range value for column 'number' at row 1

  -- Демонстрация использования атрибута display width с атрибутом ZEROFILL

    -- Создать таблицу со столбцом типа TINYINT(2) UNSIGNED
    CREATE TABLE test2(number INT(3) UNSIGNED ZEROFILL);

    -- Попробовать записать в нее значение 200
    INSERT INTO test2 VALUES(20);

    -- Попробовать прочитать записанное значение
    SELECT * FROM test2;  -- получилось, результат 020

    -- Вывести описание структуры таблицы
    DESCRIBE test2;

  -- Тестирование атрибута AUTO_INCREMENT

    -- Создать таблицу со стоблцом ID с атрибутом AUTO_INCREMENT
    CREATE TABLE test3(ID INT UNSIGNED AUTO_INCREMENT, PRIMARY KEY (id) );

    -- Добавить NULL значение 3 раза
    INSERT INTO test3 VALUES(NULL);
    INSERT INTO test3 VALUES(NULL);
    INSERT INTO test3 VALUES(NULL);

    -- Посмотреть, что теперь в таблице
    SELECT * FROM test3;   -- результат - 3 строки со значениями - 1,2,3


-- Дата и время

  -- Тест десятичных секунд

    -- Создать таблицу со столбцом типа TIME(6)
    CREATE TABLE test4(t TIME(6));

    -- Вставить в таблицу значение с десятичными секундами
    INSERT INTO test4 VALUES('10:59:59.123456');

    -- Посмотреть, что теперь в таблице
    SELECT * FROM test4;         -- 10:59:59.123456

  -- Явное приведение типов       | CAST

      -- Создать таблицу со столбцом типа DATETIME
      CREATE TABLE test5(t DATETIME);

      -- Вставить в таблицу значение
      INSERT INTO test5 VALUES('2013-09-24 10:59:59');

      -- Выполнить явное приведение этого значения к типу DATE и вывести результат
      SELECT CAST(t AS DATE) FROM test5 LIMIT 1;  -- 2013-09-24

  -- Автоматическая инициализация и обновление типов TIMESTAMP и DATETIME

    -- Здесь использованы и DEFAULT CURRENT_TIMESTAMP, и ON UPDATE CURRENT_TIMESTAMP.
    -- Значение колонки - автообновляемый теукщий timestamp, как значение по умолчанию.
    CREATE TABLE t1 (
      ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
      dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    );

    -- Здесь использован только DEFAULT CURRENT_TIMESTAMP, без ON UPDATE.

      -- Назначить в качестве дефолтного значения timestamp. Добавляется в момент вставки
      -- строки в таблицу (если не указано значения для этой колонки), и дальше не меняется.
      CREATE TABLE t1 (
        ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        dt DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Назначить в качестве дефолтного значения константу. Добавляется в момент вставки
      -- строки в таблицу (если не указано значения для этой колонки), и дальше не меняется.
      CREATE TABLE t1 (
        ts TIMESTAMP DEFAULT 0,
        dt DATETIME DEFAULT 0
      );

    -- Здесь использована констанда для DEFAULT, и UPDATE CURRENT_TIMESTAMP
      -- То есть дефолтное значение при инициализации - константа, а при обновлении
      -- она превращается в значение timestamp во время обновления.
    CREATE TABLE t1 (
      ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
      dt DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
    );

    -- UPDATE CURRENT_TIMESTAMP, но нет DEFAULT значения
      -- По умолчанию DATETIME и TIMESTAMP (если та опция == TRUE) имеют значение NULL.
      -- А при обнавлении будут получать текущее значение timestamp
      CREATE TABLE t1 (
        ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,     -- default 0
        ts2 TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL
      );
      CREATE TABLE t1 (
        dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- default NULL
        dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- default 0
      );


-- Строки

  -- Настройка character set и collation на разных уровнях

    -- Вывести список всех доступных для сервера character set
    SHOW CHARACTER SET;

    -- Вывести список всех доступных для сервера collation
    SHOW COLLATION;

    -- Посмотреть, какие character set установлены на разных уровнях (вводить в консоль)
      -- SHOW variables like 'char%';

    -- Посмотреть, какие collation установлены на разных уровнях (вводить в консоль)
      -- SHOW variables like 'coll%';

    -- Настройка на уровне базы данных
    CREATE DATABASE d1
      DEFAULT CHARACTER SET latin2 COLLATE latin2_czech_ci;

    -- Настройка на уровне таблицы
    CREATE TABLE t1
    (
      c1 CHAR(10)
    ) DEFAULT CHARACTER SET latin1 COLLATE latin1_danish_ci;

    -- Настройка на уровне колонки
    CREATE TABLE t1
    (
      c1 CHAR(10)
    ) DEFAULT CHARACTER SET latin2 COLLATE latin2_bin;

  -- Работа с типом ENUM

    -- Создание и использование типа ENUM

      -- Создать таблицу с колонкой типа ENUM
      CREATE TABLE shirts (
        name VARCHAR(40),
        size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
      );

      -- Вставить несколько значений
      INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),
      ('polo shirt','small');

      -- Посмотреть теперь содержимое таблицы
      SELECT * FROM shirts;

    -- Специально вставить error-значение, и найти его с помощью описанно техники

      -- Вставить в таблицу shirts error-значение ''
      INSERT INTO shirts VALUES('error shirt','abc');  -- error, если включен strict mode,

      -- Найти все error-значения в таблице
      SELECT * FROM shirts WHERE size=0;

/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальное руководство по типам данных MySQL:
        http://dev.mysql.com/doc/refman/5.6/en/data-types.html



*****************************************************
Оглавление:


    > Общая информация о поддерживаеых сервером MySQL типах данных
    > Используемые в описании термины
    > Техника выбора оптимального типа данных для колонки
    > Назначение DEFAULT'ных значений для колонок
    > Описания типов
      > Числа
        > Особенности SIGNED и UNSIGNED чисел
        > Управление поведением сервера при пересечении значением числа границ типа
        > Атрибуты числовых типов
        > Обзор сигнатур всех числовых типов в MySQL
        > Описание каждого числового типа и его особенностей
          > BIT[(M)]
          > TINYINT[(M)] [UNSIGNED] [ZEROFILL]
          > BOOL, BOOLEAN
          > SMALLINT[(M)] [UNSIGNED] [ZEROFILL]
          > MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]
          > INT[(M)] [UNSIGNED] [ZEROFILL]
          > INTEGER[(M)] [UNSIGNED] [ZEROFILL]
          > BIGINT [(M)] [UNSIGNED] [ZEROFILL]
          > DECIMAL, DEC, NUMERIC, FIXED [(M[,D]) [UNSIGNED] [ZEROFILL]
          > FLOAT [(M,D)] [UNSIGNED] [ZEROFILL]
          > DOUBLE, DOUBLE PRECISION, REAL [(M,D)] [UNSIGNED] [ZEROFILL]

      > Дата и время
        > Общая информация
        > Что нужно иметь в виду при работе с дата-временными типами
        > Обзор сигнатур всех дата-временных типов в MySQL
        > Описание каждого дата-временного типа и его особенностей
          > DATE
          > DATETIME[(fsp)]
          > TIMESTAMP[(fsp)]
          > TIME([fsp])
          > YEAR[(4)]
        > Автоматическая инициализация и обновление типов TIMESTAMP и DATETIME
        > Преобразование междту дата-временными типами
        > Дробные секунды во временных типах

      > Строки
        > Общая информация
        > Character set и collation
          > Что такое Character Set и Collation
          > Общая информация
          > Настройка character set и collation на 4-х уровнях
            > 4 уровня
            > Настройка на уровне сервера
            > Настройка на уровне базы данных
            > Настройка на уровне таблицы
            > Настройка на уровне колонки
        > Обзор сигнатур всех строковых типов в MySQL
        > Описание каждого строкового типа и его особенностей
          > [NATIONAL] CHAR[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]
          > [NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE collation_name]
          > BINARY(M)
          > VARBINARY(M)
          > TINYBLOB
          > TINYTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
          > BLOB[(M)]
          > TEXT[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]
          > MEDIUMBLOB
          > MEDIUMTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
          > LONGBLOB
          > LONGTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
          > ENUM('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]
          > SET('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]


*****************************************************






Общая информация о поддерживаеых сервером MySQL типах данных
> MySQL поддерживает ряд SQL-типов данных в следующих категориях:
  > Числа
  > Дата и время
  > Строки (символ и байт)
> MySQL также поддерживает дополнения для управления пространственными данными.
  (spatial extensions). Подробнее здесь: http://dev.mysql.com/doc/refman/5.6/en/spatial-extensions.html


Используемые в описании термины
> Квадратные скобки [] обозначают не обязательную опциональную часть определения.
> Буква 'M' означает:
  > Для integer                         | MAX размер в количестве цифр
  > Для floating-point и fixed-point    | Число зарезервированных для значения цифр (precision)
  > Для string:                         | MAX длина строки в байтах
   *Примечание: смысл M зависит от типа данных.
> Буква 'D' применяется к типам floating-point и fixed-point, и означает:
  > Количество цифр после де (scale).
> Сочетание 'fsp' применяется к типам TIME, DATETIME и TIMESTAMP, и представляет
  дробные секунды - количество цифр, выделенных под дробные части секунды.
  Значение: целое от 0 до 6. По умолчанию - 0.


Техника выбора оптимального типа данных для колонки
> Основные показатели при выборе типа данных для колонки:
  1. Выбранный тип данных должен в настоящем и в будущем обеспечивать поддержку
     100% всех значений, для которых он предназначен.
     > Например, в столбец X планируется записывать числа со значениями в диапазоне
       от 1 до 250. Тогда оптимальным будет тип UNSIGNED TINYINT (0 - 255).
       Однако, если есть хотя бы малая возможность того, что потребуется записать
       числа > 255, то лучше выбрать тип с запасом - UNSIGNED SMALLINT (0 - 65535).
  2. Выбирая тип, следует принимать во внимание экономию дискового пространства.
     Чем больше MAX значение, которое можно записать в тип, тем больше места он
     занимает. Следует выбирать тип с минимальным MAX значением, но чтобы этот тип
     удовлетворял п.1. См. пример выше.
> Все математические операции ( + - * \ ) с десятичными (10-тичная система счисления)
  цифрами проводятся с точнстью (precision) до 65 десятичных цифр.
  > Если точность вычислений не особенно важна, то DOUBLE подойдет.
  > Если точность вычислений важна, то для высокой точности можно конвертировать
    числа в fixed point значения -  BIGINT (64 bit), проводить все нужные операции,
    а затем конвертировать обратно во floating point.
> Еще можно провести анализ целевой колонки в автоматическом режиме и получить
  предложения по назначению типа данных для этой колонки. Для этого можно восопльзоваться
  выражением PROCEDURE ANALYSE.

Назначение DEFAULT'ных значений для колонок
> Назначить значение по умолчанию для колонки можно с помощью атритуба DEFAULT.
  Делается это во время определения таблицы и ее колонок.
> DEFAULT'ное значение должно быть константой. Оно не может быть результатом
  работы выражения.
  > Но есть 1 исключение -  CURRENT_TIMESTAMP (см. описание датавременных типов).
> У колонок типа BLOB и TEXT не может быть значения по умолчанию.
> Если при определении таблицы не было назначено явного DEFAULT'ного значения, то:
  > Если колонка может принимать значение NULL, то она автоматически получает
    атрибуты DEFAULT NULL.
  > Если она НЕ может принимать NULL значения, MySQL определяет колонку без
    DEFAULT'ного значения.
    > За 1-м исключением. Если колонка определена, как часть of PRIMARY KEY, но
      не определена явно, как NOT NULL, то MySQL автоматически присваивает ей
      атрибут NOT NULL, потому что колонка с PRIMARY KEY должна быть таковой.
      И при этом еще колонка автоматически получает в качестве DEFAULT'ного
      значения значение по умолчанию для типа этой колонки.
      > Чтобы автоназначения DEFAULT'ного значения не произошло, требуется
        явно определить колонку, как NOT NULL.
> Если попробовать вставить значение в колонку без DEFAULT'ного значения, то:
  > Если strict mode включен: будет ошибка.
  > Если strict mode выключен: будет вставлено неявное значение для типа колонки.
> Чтобы посмотреть, у какого столбца есть, а у какого нет DEFAULT'ного значения,
  можно использовать выражение SHOW CREATE TABLE (см. пример выше)
> Неявные DEFAULT'ные значения типов выглядят следующим образом:
  > Для числовых типов значение по умолчанию == 0.
    > Кроме столбцов с атрибутом AUTO_INCREMENT.
  > Для всех дата-временных типов, кроме TIMESTAMP, значение по умолчанию -
    это zero-value этого типа.
    > Для TIMESTAMP:
      > Если explicit_defaults_for_timestamp == TRUE, то тоже zero-value.
      > Если explicit_defaults_for_timestamp == FALSE, то значение по умолчанию -
        текущая дата и время.
  > Для строковых типов (кроме ENUM) значение по умолчанию - пустая строка ''.
    > Для ENUM значение по умолчанию - первое значение в перечислении.

Описания типов
> Числа
  > Особенности SIGNED и UNSIGNED чисел
    > UNSIGNED - это атрибут числового типа в MySQL указывающий на то,
      что числа этого типа не имеют отрицательных значений. Все доступное
      место в этом случае выделяется под положительные значения.
      > UNSIGNED-число - это либо 0, либо положительное число.
      > Диапазон UNSIGNED-чисел:  [0 - +MAX]
        > MAX для UNSIGNED-числа в 2 раза больше, чем MAX для SIGNED-числа.
      > Пример: UNSIGNED TINYINT [0 - 255]
    > SIGNED - это атрибут числового типа в MySQL указывающий на то,
      что все доступное место в ячейке этого типа распределяется поровну
      между положительными и отрицательными значениями.
      > Все числовые типы в MySQL по умолчанию SIGNED.
      > SIGNED-число может быть как +, так и -.
      > Диапазон SIGNED-чисел:  [-MIN - +MAX]
      > Пример: SIGNED TINYINT [-127 - +127]
    > При вычитании между 2-мя INT числами, одно из которых UNSIGNED INT,
      результат тоже будет типа UNSIGNED INT.
      > ... но только, если не включен режим работы сервера NO_UNSIGNED_SUBTRACTION.
    > Если добавить столбцу атрибут ZEROFILL, то сервер автоматически дополняет значение
      в ячейках нулями '0' - до максимального размера.
      > Использование атрибута ZEROFILL автоматически делает тип столбца UNSIGNED.
    > Все числовые типы, которым можно добавить атрибут UNSIGNED, можно добавить вместо
      него и атрибут SIGNED. Однако, в этом нет смысла, потому что все числовые типы
      SIGNED по умолчанию.

  > Управление поведением сервера при пересечении значением числа границ типа
    > Когда MySQL пытается в колонку с числовым типом сохранить число, значение
      которого бьет допустимые для типа этой колонки границы, то результат
      зависит от текущего режима SQL:
      > Если для SQL включен strict mode, то такое значение не сохранится, а сервер
        выдаст ошибку.
      > Если strict mode выключен, то сервер обрежет значение до соответствующего
        ближайшему граничному значению допустимого диапазона для типа этого столбца,
        и сохранит это значение.
        > Например, если попытаться сохранить 256 в столбец типа UNSIGNED TINYINT,
          то сохранится число 255.
        > Если обрезание произошло в результате работы операций ALTER TABLE, LOAD DATA INFILE,
          UPDATE, INSERT - то факт обрезается помечается, как предупреждение.
        > В MySQL 5.6 по умолчанию установлен strict mode, так что при переполнении
          значения сервер вернет ошибку.

  > Атрибуты числовых типов
    > Атрибут display width.
      > Этот атрибут нужен для использования в тех ситуациях (например, в приложениях),
        где требуется, чтобы все числа содержали одинаковое количество символов.
        То есть display width - позволяет указать отображаемую ширину числа.
        Все недостающие символы заполняются слева пробелами.
      > Это не обязательный атрибут.
      > Значение display width указывается в круглых скобках после определения
        типа. Например: INT(4).
      > Атрибут display width никак не влияет на диапазон возможных значений,
        определенный типом столбца. Даже если тип объявлен, как INT(3), то в него
        все равно, например, можно записать число 5555 с 4-мя цифрами.
      > Смысл использовать этот атрибут есто только, если количество цифр в
        целевых значениямх меньше, чем указано в атрибуте. Иначе, никакого эффекта
        будет незаметно.
      > Чтобы увидеть этот атрибут в работе, можно объявить тип столбца также
        с атрибутом ZEROFILL, которые заполнит пустые места не невидимыми пробелами,
        а видимыми нулями. См. пример выше.
    > Атрибут ZEROFILL.
      > Заполняет символами '0' пустые места в значении, которые обычно
        (по умолчанию) заполняются пробелами.
        > Атрибут ZEROFILL игнорируется, когда колонка вовлечена в операции с UNION.
        > Если хранить значения, содержащие больше символов, чем определено атрибутом
          display width, в столбце с атрибутом ZEROFILL, то можно нарваться на какие-то
          проблемы при использовании этих значений в сложных JOIN-операциях. Потому что
          MySQL предполагает, что количество символов в этих значениях меньше или равно
          указанному в display width.
      > В комплекте с этим атрибутом автоматически добавляется атрибут UNSIGNED.
    > Атрибуты SIGNED и UNSIGNED.
      > Описаны выше. Могут быть применены как к integer-типам, так и к типам
        floating-point и fixed-point.
    > Атрибут AUTO_INCREMENT
      > Может применяться к колонкам типов integer и floating-point.
      > Когда в такой столбец добавляется NULL значение (рекомендуется), то
        в ячейку на этой строке записывается значение, равное MAX + 1, где MAX -
        максимальное значение в столбце.
      > Начиная с MySQL 5.6.9, отрицательные значения для AUTO_INCREMENT столбцов
        не поддерживаются.
      > Цепочки автоинкримента начинаются с числа 1.

  > Обзор сигнатур всех числовых типов в MySQL
    > BIT[(M)]
    > TINYINT[(M)] [UNSIGNED] [ZEROFILL]
    > BOOL, BOOLEAN
    > SMALLINT[(M)] [UNSIGNED] [ZEROFILL]
    > MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]
    > INT[(M)] [UNSIGNED] [ZEROFILL]
    > INTEGER[(M)] [UNSIGNED] [ZEROFILL]
    > BIGINT [(M)] [UNSIGNED] [ZEROFILL]
    > DECIMAL, DEC, NUMERIC, FIXED [(M[,D]) [UNSIGNED] [ZEROFILL]
    > FLOAT [(M,D)] [UNSIGNED] [ZEROFILL]
    > DOUBLE, DOUBLE PRECISION, REAL [(M,D)] [UNSIGNED] [ZEROFILL]

  > Описание каждого числового типа и его особенностей
    > BIT[(M)]
      > Нужен для хранения битовых значений - состоящих из 0 и 1.
      > Диапазон параметра M: [1 - 64]
      > Значение этого типа записывается так: b'value'
        > value - это 2-ичное число, состоящее из 0 и 1.
          Например, b'111' - это 7, b'10000000' - это 128.
      > Если указать значение (value) для типа BIT(M), которое состоит из меньшего,
        чем указано в M, количества символов, то свободные места слева заполняются 0-лями.
    > TINYINT[(M)] [UNSIGNED] [ZEROFILL]
      > Очень маленький integer.
      > SIGNED: [-128 - 128], UNSIGNED: [0 - 255]
    > BOOL, BOOLEAN
      > Это синонимы типа TINYINT(1).
      > FALSE - это псевдоним для 0. TRUE - это псевдоним для 1.
      > TRUE - псевдоним ТОЛЬКО для 1. Например, 2 не равно TRUE.
    > SMALLINT[(M)] [UNSIGNED] [ZEROFILL]
      > Маленький integer.
      > SIGNED: [-32768 - 32767], UNSIGNED: [0 - 65535]
    > MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]
      > Среднего размера integer.
      > SIGNED: [-8,388,608 - 8,388,607], UNSIGNED: [0 - 16,777,215]
    > INT, INTEGER[(M)] [UNSIGNED] [ZEROFILL]
      > Нормального размера integer.
      > SIGNED: [-2,147,483,648  - 2,147,483,647], UNSIGNED: [0 - 4,294,967,295]
    > BIGINT [(M)] [UNSIGNED] [ZEROFILL]
      > Большой integer.
      > SIGNED: [-9,223,372,036,854,775,808   - 9,223,372,036,854,775,807]
      > UNSIGNED: [0 - 18,446,744,073,709,551,615]
      > Тип SERIAL - это псевдоним для:
          BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UMIQUE
      > Что нужно иметь ввиду при работе с колонками типа BIGINT:
        > При совершении арифметических операций с BIGINT значениями, вычисления проводятся
          с использованием SIGNED значений вне зависимости от того, был ли указан атрибут
          UNSIGNED при создании колонки. Отсюда вывод: нельзя совершать арифметические
          операции с числами, по модулю выходящими за границы SIGNED BIGINT
          |9,223,372,036,854,775,807|. Иначе последние цифры результата могут быть потеряны.
        > Можно хранить точное integer-значения в колонке типа BIGINT, записывая их туда
          как строчные значения. Тогда MySQL проводит преобразование строки в число, прямо
          в BIGINT, избегая промежуточного double-значения.
    > DECIMAL, DEC, NUMERIC, FIXED [(M[,D]) [UNSIGNED] [ZEROFILL]
      > M - количество цифр во всем числе.
        > MAX M = 65. Не считая символа запятой',', и символа минус '-'.
        > Если M не указан в определении, то он считается == 10.
      > D - это вес младшего разряда (см. пример ниже).
        > MAX D = 30.
        > Если D не указан в определении, то он считается == 0.
        > D не может быть указан без M.
      > Число с фиксированной запятой - формат представления вещественного числа в
        виде целого числа. При этом само число X и его целочисленное представление Y
        связаны формулой:  X = Y * Z, где Z - вес младшего разряда.
        > Пример 1. Надо представить 12 рублей 34 копейки в виде числа с фиксированной запятой:
          Y = 1234;  Z = 1/D*10;  D = 2.   Здесь D - это вес младшего разряда.
        > Пример 2. Тип DECIMAL(5,2), где 5 - количество цифр, зарезервированных для
          всего числа;  2 - кол-во цифр, которые могут быть сохранены после запятой.
          Такой тип подходит для любого числа, состоящего из 5 цифр, и 2-х цифр после запятой.
          Для любого числа из этого диапазона: [-999.99 - 999.99]
      > Таким образом, этот тип хранит точные значения чисел без погрешностей. Его можно
        использовать, например, для хранения финансовой информации, не терпящей погрешностей.
      > MySQL >= 5.6 хранит DECIMAL в бинарном формате.
      > ru.wikipedia.org/wiki/Число_с_фиксированной_запятой
    > FLOAT [(M,D)] [UNSIGNED] [ZEROFILL]
      > Подробно о числах с плавающей запятой написано здесь: http://habrahabr.ru/post/112953/
      > Число с плавающей запятой - это представление чисел с ограниченной точностью.
        Оно состоит из набора бит, условно разделенных на 3 части: знак S, порядок E и
        мантиссу M. Формула этого числа:
        F = (-1)^s * 1.M * 2^E.
      > Внимание! Так как точность ограничена, нельзя использовать этот тип, например, для
        работы с деньгами.
      > Числа с плавающей запятой являются компромиссом между точностью и диапазоном значений.
        Да, они позволяют существенно увеличить диапазон, несколько пожертвовав точностью.
      > В MySQL бывают числа с плавающей запятой одинарной (FLOAT) и двойной (DOUBLE)
        точности:
        > FLOAT: занимает 4 байта.
          > 1 бит занимает знак числа.
          > 8 бит занимает порядок.
          > До 23 бит занимает мантисса.
        > DOUBLE: занимает 8 байт.
          > 1 бит занимает знак числа
          > 8 бит занимает порядок.
          > От 24 до 53 бит занимает мантисса.
      > Диапазоны: [-3.402823466 в +38 степени  -  -1.175494351 в -38 степени]
                   [1.175494351 в -38 степени  -  3.402823466 в + 38 степени]
      > M - количество цифр во всем числе.
        > Является точным для чисел, с M = 7 (приблизительно).
        > Если M и D не указаны, значение ограничены только возможностями машины (hardware).
      > D - количество цифр после запятой.
      > Использование FLOAT в MySQL может вызывать ряд всяких проблем, потому что
        в MySQL все числа с плавающей точкой хранятся, как DOUBLE.
        > Подробнее об этих возможных проблемах здесь: http://dev.mysql.com/doc/refman/5.6/en/no-matching-rows.html
    > DOUBLE, DOUBLE PRECISION, REAL [(M,D)] [UNSIGNED] [ZEROFILL]
      > Тоже самое, что FLOAT, только имеет двойную точность.
      > ru.wikipedia.org/wiki/Число_с_плавающей_запятой

> Дата и время
  > Общая информация
    > Для MySQL <= 5.6.4 для значений типов TIME, DATETIME и TIMESTAMP поддерживаются
      дробные доли секунд, до 6 знаков после запятой (по умолчанию == 0).
      > Пример синтаксиса: TIME(6) - тип, в котором секунды содержат 6 знаков после запятой.
    > Тип YEAR(2) устарел, и вместо него надо использовать тип YEAR(4).

  > Что нужно иметь в виду при работе с дата-временными типами
    > MySQL имеет "расслабленную" политику относительно значений в строках.
      Опасность в том, что значение типа "XX:YY:ZZ" очень похоже на время, но
      в контексте, где ожидается дата, оно может быть воспринято как дата "YY-MM-DD",
      не смотря на то, что в качестве разделителей использовано двоеточие, а не дефис.
    > Как MySQL воспринимает значения дат с ошибками зависит от режима работы сервера:
      > Если strict mode включен: сервер выдает ошибку.
        > Как сделать проверку дат "не строго", чтобы проверялось только, что месяц
          в диапазоне от 1 до 12, а дата от 1 до 31, см. здесь:
          http://dev.mysql.com/doc/refman/5.6/en/server-sql-mode.html#sqlmode_allow_invalid_dates
        > Как выключить strict mode: см. здесь http://dev.mysql.com/doc/refman/5.6/en/server-sql-mode.html
      > Если strict mode выключен: ошибочные значения типов DATE, DATETIME и TIMESTAMP
        конвертируются в "нулевые" значения: '0000-00-00' или '0000-00-00 00:00:00'
    > Тип TIMESTAMP не принимает значения, у которых в колонках месяца или года нулевое значение,
      либо ошибочное значение. За исключением специального "нулевого" значения 0000-00-00 00:00:00.
    > Даты, в которых значение YEAR состоит из 2-х цифр двусмысленны, потому что
      MySQL не знает, к какому веку они относятся. Он определяет век по следующим правилам:
      > Если значение года в диапазоне 00-69, то сервер понимает это, как 2000-2069
      > Если значение года в диапазоне 70-99, то сервер понимает это, как 1970-1999
    > Если MySQL запущен с включенным SQL-режимом MAXDB, то тип TIMESTAMP воспринимается,
      как тип DATETIME. И автоматическая инициализация и обновление не работают.

  > Обзор сигнатур всех дата-временных типов в MySQL
    > DATE
    > DATETIME[(fsp)]
    > TIMESTAMP[(fsp)]
    > TIME([fsp])
    > YEAR[(4)]

  > Описание каждого дата-временного типа и его особенностей
    > DATE
      > Этот тип для значений, содержащих дату (без времени).
      > MySQL отображает значение типа DATE в формате: 'YYYY-MM-DD'
      > Поддерживаемый диапазон дат: ['1000-01-01' - '9999-12-31']
      > Типы DATE, DATETIME и TIMESTAMP связыны между собой.
      > Ошибочные значения типов DATE, DATETIME и TIMESTAMP конвертируются
        в "нулевые" значения: '0000-00-00' или '0000-00-00 00:00:00'
      > MySQL принимает следующие форматы для значений типа DATE:
        > В виде строки в форматах: 'YYYY-MM-DD', 'YY-MM-DD'. Причем в качестве
          символов-разделителе могут быть любые. Например: 'YYYY*MM*DD'.
        > Как строка без разделителей, но которая имеет смысл, как дата:
          'YYYYMMDD', 'YYMMDD'. Например, '20101112' сервер воспримет, как '2012-11-12'.
          А вот '20105512' сервер не воспримет, как '2012-55-12', потому что есть всего
          12 месяцев, результатом будет ошибка.
        > Как числовое значение без разделителей. Условия те же, что для предыдущего
          пункта. Например, число 20101112 воспринимается, как '2012-11-12'.

    > DATETIME[(fsp)]
      > Этот тип для значений, содержащих дату и время.
      > Поддерживаемый диапазон: от '1000-01-01 00:00:00.000000'
                                 до '9999-12-31 23:59:59.000000'
      > Начиная с MySQL >= 5.6.4 для типов DATETIME и TIMESTAMP поддерживаются
        дробные доли секунды - до 6 знаков после запятой.
        > Пример синтаксиса: DATETIME(6) - тип, в котором секунды содержат 6 знаков после запятой.
      > Начиная с MySQL >= 5.6.5 Для типов DATETIME и TIMESTAMP есть возможность настроить
        автоматическую инициализацию и обновление до текущих даты и времени.
        См. http://dev.mysql.com/doc/refman/5.6/en/timestamp-initialization.html
      > Ошибочные значения типов DATE, DATETIME и TIMESTAMP конвертируются
        в "нулевые" значения: '0000-00-00' или '0000-00-00 00:00:00'
      > MySQL принимает следующие форматы для значений типа DATETIME и TIMESTAMP:
        > Как строку в формате: 'YYYY-MM-DD HH:MM:SS', 'YY-MM-DD HH:MM:SS'.
          Пунктуация может быть любая.
        > Как строку без разделителей в формате 'YYYYMMDDHHMMSS',  'YYMMDDHHMMSS'.
          Но дата и время должны иметь смысл (не быть ошибочными).
        > Как числовое значение без разделителей.
          Но дата и время должны иметь смысл (не быть ошибочными).

    > TIMESTAMP[(fsp)]
      > Время в секундах, прошедшее с начала эпохи UNIX.
      > Диапазон возможных значений:  от '1970-01-01 00:00:01.000000' UTC
                                      до '2038-01-19 03:14:07.999999' UTC
      > Значение '1970-01-01 00:00:01.000000' зарезервировано под "нулевое значение"
        '0000-00-00 00:00:00'. Так что его нельзя использовать как отражение написанных
        в значении даты и времени.
      > MySQL конвертирует значения TIMESTAMP из текущей из текуще временной зоны в UTC
        для хранения, и конвертирует их обратно при извлечении (это происходит только для TIMESTAMP).
        > Здесь есть опасность! По умолчанию в качестве временной зоны используется
          время сервера. Опасность в том, что если поменяется временная зона соединения,
          то вернется уже другое значение timestamp, отличное от того, что было в прежней
          временной зоне.
        > Про настройку временных зон для сервера MySQL можно почитать здесь:
          http://dev.mysql.com/doc/refman/5.6/en/time-zone-support.html
      > Начиная с MySQL >= 5.6.5 Для типов DATETIME и TIMESTAMP есть возможность настроить
        автоматическую инициализацию и обновление до текущих даты и времени.
        См. http://dev.mysql.com/doc/refman/5.6/en/timestamp-initialization.html
      > Ошибочные значения типов DATE, DATETIME и TIMESTAMP конвертируются
        в "нулевые" значения: '0000-00-00' или '0000-00-00 00:00:00'
      > Поведение сервера по отношению к значениям типа TIMESTAMP, зависиот от
        значения системной переменной explicit_defaults_for_timestamp == (TRUE / FALSE).
        По умолчанию её значение: FALSE.
        > Значение по умолчанию (FALSE), начиная с MySQL 5.6.6 является устаревшим.
          Рекомендуется использовать значение TRUE.
        > Если FALSE:
          > Колонки с типом TIMESTAMP по умолчанию получают атрибут NOT NULL.
            В отличие от колонок других типов, у которых по умолчанию NULL.
          > Первая колонка с типом TIMESTAMP в таблице, если объявлена без атрибута NULL,
            и без DEFAULT или ON UPDATE, автоматически получает атрибуты
            DEFAULT CURRENT_TIMESTAMP и ON UPDATE CURRENT_TIMESTAMP.
          > Не первые колонки с типом TIMESTAMP в таблице, если объявлены без атрибута NULL,
            или DEFAULT (дефолтного значения), получают в качесве дефолтно гозначения
            DEFAULT '0000-00-00 00:00:00' (нулевой timestamp). При вставке строк, если
            значение для колонки не назначено, она получает нулевой timestamp.
        > Если TRUE:
          > В отличие от FALSE варианта, колонка TIMESTAMP получает по умолчанию атрибут
            NULL.
          > В отличие от FALSE варианта, никакие колонки с типом TIMESTAMP не получают
            автоматически атрибуты DEFAULT CURRENT_TIMESTAMP и ON UPDATE CURRENT_TIMESTAMP.
            Если они нужны, их требуется назначить явно.
          > Колонки с типом TIMESTAMP объявленные с атрибутом NOT NULL и без DEFAULT
            (без дефолтного значения) рассматриваются, как не имеющие дефолтного значения.
            В случае вставки строки без указаня значения для этого столбца, результат
            зависит от актуальных SQL-режимов работы сервера. Причем также сервер
            обрабатывает и другие дата-временные типы, такие как DATETIME.
            > Если strict mode включен - будет ошибка.
            > Если выключен, то запишется нулевой timestamp ('0000-00-00 00:00:00').
        > Причем, переменная explicit_defaults_for_timestamp и сама является устаревшей,
          потому что в одном из ближайших релизов сервера уберут нестандартное 'FALSE'
          поведение сервера вообще, и тогда сама эта переменная станет не нужна.

    > TIME([fsp])
      > В основном используется для:
        > Представления временного интервала между двумя собятиями.
        > Отображения времени суток.
      > Диапазон значений: от '-838:59:59.000000' до '838:59:59.000000'
      > MySQL отображает значения типа TIME по следующему шаблону:
        'HH:MM:SS[.fraction]'
      > Начиная с MySQL >= 5.6.4 для типов DATETIME и TIMESTAMP поддерживаются
        дробные доли секунды - до 6 знаков после запятой.
        > Пример синтаксиса: DATETIME(6) - тип, в котором секунды содержат 6 знаков после запятой.
      > MySQL принимает следующие форматы для значений типа TIME:
        > 'D HH:MM:SS', 'HH:MM:SS', 'HH:MM', 'D HH:MM', 'D HH', 'SS'.
          Где D - количество дней, в диапазоне от 0 до 34.
        > Строка без разделителей, но при условии, что она имеет смысл, как время.
          Например: '101112' воспринимается, как '10:11:12'. А вот строка '101195'
          не может быть воспринята, как '10:11:95', потому что в минуте 60 секунд,
          и результатом будет ошибка.
        > Как числовое значение без разделителей. Условия те же, что для предыдущего
          пункта. Например, число 101112 воспринимается, как '10:11:12'.
        > Дробные доли секунды воспринимаются сервером в следующих форматах:
          'D HH:MM:SS.fraction', 'HH:MM:SS.fraction', 'HHMMSS.fraction',  HHMMSS.fraction.
      > Для часов, минут и секунд в значениях типа TIME необходимо всегда писать
        2 цифры, а не 1-ну. Например: 01:02:03, не 1:2:3.
      > Не рекомендуется использовать не полные форматы значений TIME, такие как
        '11:12', потому что можно запутаться. То ли это 11 часов 12 минут, то ли
        11 минут 12 секунд.
      > По умолчанию значения, которые вышли за рамки разрешенных диапазонов,
        обрезаются до ближайшего разрешенного значения. Например, '850:10:10' будет
        обрезано до '838:59:59.000000'.

    > YEAR[(4)]
      > Вообще то есть 2-х и 4-х знаковый формат типа YEAR, но 2-х знаковый формат
        использовать не рекомендуется из-за его неоднозначности. Поэтому он не рассматривается.
      > Диапазон значений: от 1901 до 2155.
      > Функции SUM() и AVG() не работают с временными типами. Для работы с ними требуется
        конвертировать в число, провести операцию, затем конвертировать обратно во
        временной тип.

  > Автоматическая инициализация и обновление типов TIMESTAMP и DATETIME
    > См. выше про поведение сервера при explicit_defaults_for_timestamp == (TRUE / FALSE).
    > Для любого столбца типа TIMESTAMP и DATETIME можно установить текущий timestamp
      в качестве дефолтного значения и/или следать его автообновляемым.
      > Авто-инициализация. Устанавливает текущий timestamp в ячейку при добавлении
        строки, если значение для столбца с авто-инициализацией не указано.
        > Атрибуты для установки авто-инициализации столбца:
             DEFAULT CURRENT_TIMESTAMP
      > Авто-обновление. Автоматически обновляет timestamp в ячейке с авто-обновлением,
        когда любое значение из строки этой ячейки строки меняется.
        > Атрибуты для установки авто-обновления значений столбца на текущие:
            UPDATE CURRENT_TIMESTAMP
        > Авто-обновление даже без каких-либо изменений в других колонках строки
          ячейки с авто-обновлением. Для этого нужно для этой ячейки установить значение
          по умолчанию (DEFAULT), равное CURRENT_TIMESTAMP.
        > Чтобы предотвратить автообновление значения в ячейке, когда изменяются значения
          других колонок строки этой ячейки, требуется явно установить значение по
          умолчанию (DEFAULT) для этой ячейки.
      > CURRENT_TIMESTAMP и его синонимы.
        > Возвращает текущие дату и время.
        > Имеет много синонимов: CURRENT_TIMESTAMP(), NOW(), LOCALTIME, LOCALTIME(),
          LOCALTIMESTAMP, LOCALTIMESTAMP().
    > Смотри примеры различных ситуация объявления столбцов с разными комбинациями
      значений атрибутов DEFAULT и ON UPDATE, с использованием и без использования
      CURRENT_TIMESTAMP.
      См. эти примеры выше, в разделе примеров этого файла.

  > Преобразование междту дата-временными типами
    > В некоторой степени можно преобразовать одно дата-временное значение в
      другое. Но может быть потеряна часть информации.
    > Во всех случаях подобных преобразований, главная тема, требующая внимания,
      попадет ли результат этого преобразовани в допустимый диапазон того типа,
      в который происходит преобразование.
    > Особенности приведения дата-временных типов друг в друга:
      > DATE ->
        -> DATETIME & TIMESTAMP
           > К значению типа DATE прибавляется "временная" часть в виде '00:00:00'.
        -> TIME
           > Такое преобразование бесполезно, результат будет '00:00:00'.
      > DATETIME & TIMESTAMP ->
        -> DATE
           > Это преобразование стирает временную часть значения DATETIME, так что остается
             только DATE-часть.
        -> TIME
           > Это преобразование стирает "датовую" часть значения DATETIME, так что остается
             только TIME-часть.
      > TIME ->
        -> DATETIME & TIMESTAMP
           > В этом случае недостающая дата берется из функции CURRENT_DATE(). Это текущее
             серверное время.
           > К этой текущей дате прибавляется значение типа TIME, как интервал времени,
             и результат - итоговые дата и время.
           > Например, текущая дата: '2013.09.24'. Преобразуем следующие TIME-значения
             в DATETIME-значение: '12:00:00', '24:00:00', и '-12:00:00'. Результат, соответственно:
             '2013.09.24 12:00:00', '2013.09.25 00:00:00' и '2013.09.23 12:00:00'
        -> DATE
           > Также, как в DATETIME, только отбрасывается временная часть.
    > При сравнении значений типов DATE и DATETIME, а также TIME и DATETIME между собой,
      значения типов DATE и TIME автоматически приводятся к DATETIME. Чтобы изменить
      это поведение, можно воспользоваться их явным приведением типов с помощью
      функции CAST (см. пример выше)
    > TIME(N) и DATETIME(N) неявно преобразуются в integer, когда N == 0;
      и в DECIMAL, когда N > 0.


  > Дробные секунды во временных типах
    > Дробные секунды можно использовать в типах TIME, DATETIME и TIMESTAMP.
    > Синтаксис следующий: TIME(x), DATETIME(x), TIMESTAMP(x) - где диапазон
      x - от 0 до 6, и x - это количество цифр в дробной части секунды.
      > Например: значение '10:59:59.123456' для типа TIME(6).
    > Функции, принимающие временные аргументы, также принимают и дробные секунды в них.


> Строки
  > Общая информация
    > В некоторых случаях MySQL может тихо и без предупреждения изменять конфигурацию
      столбца, явно указанную во время последней операции CREATE TABLE или ALTER TABLE.
      > Он может изменить тип со строкового на дата-временной.
      > Он может изменять атрибуты, связанные с дата-временным типом или индексами.
      > Подробнее о том, что и в каких случаях может изменяться:
        > Колонки, которые являются частью PRIMARY KEY автоматически получают атрибут
          NOT NULL.
        > Лишние пробелы автоматически удаляются из ENUM и SET значений при создании таблицы.
        > Если включить атрибут USING для указания index type, который не разрешен для
          используемого движка хранилища, но есть другой index type, который разрешен, то
          MySQL автоматически использует его.
        > Если strict SQL-mode выключен (а если включен - то ошибка), то:
          > Тип VARCHAR с длиной > 65535 конвертируется в TEXT.
          > Тип VARBINARY с длиной > 65535 конуертируется в BLOB.
        > Если указать атрибут CHARACTER SET binary для столбца, в качестве типа которого
          указан CHAR, VARCHAR или TEXT, то этот тип автоматически преобразуется в аналогичный
          бинарный тип, соответственно: BINARY, VARBINARY и BLOB.
    > MySQL интерпретирует атрибуты длины в символьных типах, как размер в символах.
      Это относится к типам CHAR, VARCHAR и TEXT.
    > Атрибут ASCII - это синоним CHARACTER SET latin1.
    > Атрибут UNICODE - это синоним CHARACTER SET ucs2.
    > Атрибут BINARY - указывает на binary collation.

  > Character set и collation

    > Что такое Character Set и Collation:
      > Character set (набор символов) - это таблица, задающая кодировку конечного
        множества символов алфавита. Такая таблица (применительно к компьютеру)
        сопоставляет каждому символу последовательность длиной в 1 или несколько
        других символов (в компьютере - нулей и единиц).
      > Collation - это набор правил, которые использует колонка для сравнения
        символов между собой (чтобы понимать, какой символ или набор символов
        больше указанного, а какой меньше). Используется, например, при сортировке.

    > Общая информация
      > Официальная справка о поддержке и настройке character set и collation в MySQL здесь:
          http://dev.mysql.com/doc/refman/5.6/en/charset.html
      > Списоки доступных в MySQL сервере character set и collation доступны по здесь:
          http://dev.mysql.com/doc/refman/5.6/en/charset-mysql.html
      > Настройки Character Set и Collation влияют не только на то, в каком виде
        хранятся данные, но и на взаимодействия между сервером MySQL и его клиентскими
        программами.
      > В MySQL настройка Character Set и Collation для следующих движков хранилищ:
        INNODB, MyISAM и MEMORY.
      > У каждого character set есть >= 1 collation.
      > 2 разных character set не могут иметь 1 и тот же collation.
      > У каждого character set есть 1 collation по умолчанию.
      > Для имен для collation есть соглашение, согласно которому они начинаются
        с имени character set'a, для которого они предназначены.

    > Настройка character set и collation на 4-х уровнях

      > 4 уровня
        > Настроить значения по умолчанию для Character Set и Collation можно на
          4-х уровнях. Настройка нижнего уровня перекрывает настройки верхних уровней.
          Итак, вот эти 4 уровня:
          > На уровне сервера.
          > На уровне базы данных.
          > На уровне таблицы.
          > На уровне колонки.

      > Настройка на уровне сервера:
        > Настройку на уровне сервера можно провести 2-мя способами:
          1. В конфигурационном файле сервера (группа [mysqld]) на постоянной основе.
             > --character-set-server   | для настройки character set
             > --collation-server       | для настройки collation
          2. В командной строке только для текущего соединения.

      > Настройка на уровне базы данных:
        > Производится во время применения операций CREATE DATABASE и ALTER DATABASE
          с помощью следующих атрибутов:
          > CHARACTER SET [charset_name]
          > COLLATE [collation name]
        > MySQL следующим образом расценивает комбинации этих настроек:
          > Если указан CHARACTER SET X и COLLATE Y, то сервер и использует
            character set X и collation Y.
          > Если указан только CHARACTER SET X (без COLLATE), то сервер использует
            character set X с его collation по умолчанию.
          > Если указан только COLLATE Y (без CHARACTER SET), то сервер использует
            character set, для которого создан этот collation, и collation Y.
          > Если не указан ни CHARACTER SET, ни COLLATE, то сервер использует
            указанные на уровне сервера character set и collation.

      > Настройка на уровне таблицы:
        > Производится во время применения операций CREATE TABLE и ALTER TABLE
          с помощью следующих атрибутов:
          > CHARACTER SET [charset_name]
          > COLLATE [collation name]
        > MySQL следующим образом расценивает комбинации этих настроек:
          > Если указан CHARACTER SET X и COLLATE Y, то сервер и использует
            character set X и collation Y.
          > Если указан только CHARACTER SET X (без COLLATE), то сервер использует
            character set X с его collation по умолчанию.
          > Если указан только COLLATE Y (без CHARACTER SET), то сервер использует
            character set, для которого создан этот collation, и collation Y.
          > Если не указан ни CHARACTER SET, ни COLLATE, то сервер использует
            указанные на уровне базы данных character set и collation.

      > Настройка на уровне колонки:
        > У каждой символьной колонки (типы CHAR, VARCHAR и TEXT) есть character set
          и collation.
        > Производится во время применения операций CREATE TABLE и ALTER TABLE
          с помощью следующих атрибутов:
          > CHARACTER SET [charset_name]
          > COLLATE [collation name]
        > MySQL следующим образом расценивает комбинации этих настроек:
          > Если указан CHARACTER SET X и COLLATE Y, то сервер и использует
            character set X и collation Y.
          > Если указан только CHARACTER SET X (без COLLATE), то сервер использует
            character set X с его collation по умолчанию.
          > Если указан только COLLATE Y (без CHARACTER SET), то сервер использует
            character set, для которого создан этот collation, и collation Y.
          > Если не указан ни CHARACTER SET, ни COLLATE, то сервер использует
            указанные на уровне таблицы character set и collation.

  > Обзор сигнатур всех строковых типов в MySQL
    > [NATIONAL] CHAR[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]
    > [NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE collation_name]
    > BINARY(M)
    > VARBINARY(M)
    > TINYBLOB
    > TINYTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
    > BLOB[(M)]
    > TEXT[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]
    > MEDIUMBLOB
    > MEDIUMTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
    > LONGBLOB
    > LONGTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
    > ENUM('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]
    > SET('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]

  > Описание каждого строкового типа и его особенностей

    > [NATIONAL] CHAR, CHARACTER[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]
      > Строка фиксированной длины.
      > Нулевые байты и trailing spaces
        > При записи, даже если значение меньше по размеру, чем указанное M,
          то пустые места все равно заполняются справа пробелами (traling spaces),
          и значение занимает ровно (фиксированно) M байт + 1 служебный байт.
          > Например: CHAR(10) 'abc' занимает 10 байт.
        > При извлечении значения типа CHAR, пробелы справа и слева обрезаются.
          > Это поведение можно изменить, если настроить SQL-режим работы
            PAD_CHAR_TO_FULL_LENGTH.
        > Если колонка этого типа содержит индекс, то значения, отличающиеся только
          количеством trailing spaces, вызовут ошибку duplicate-key error.
          > Например, 'a' и 'a ' будут расценены, как одинаковые значения.
      > Диапазон M: [0 - 255] символов.
        > Однако, эффективный размер значения в символах может быть иной:
          > Он зависит от 2-х вещей:
            > От того, сколько байт занимает 1 символ в указанной кодировке.
            > От того, сколькью байтами ограничен MAX размер колонки в MySQL
              (см. 7. Лимиты в MySQL).
          > Он рассчитывается по следующей формуле:
            MAX размер колонки [байт] / размер 1 символа [байт]
          > Например, предположим, что MAX размер колонки 65535 байт, а 1 символ
            занимает 3 байта (у кодировки utf8), и в таблице у нас 1 колонка.
            Тогда MAX количество символов, которое в нее можно записать,
            = 65535 / 3 = 21845 символов.
      > Если M не указан, то по умолчанию он == 1.
      > Еще можно указать M == 0. Это можно сделать с целью:
        > Для совместимости. Если такая колонка должна быть, но в ней ничего
          не планируется хранить.
        > Если планируется хранить только одно из 2-х значений: NULL или ''.
          Преимущество в том, что такое значение занимает всего 1 байт.
      > Поведение сервера в случае попытки записать в колонку значение, размер
        которого превышает указанный максимальный размер, сервер ведет себя
        в зависимости от того, включен ли strict mode работы сервера:
        > Если strict mode влючен: выдаст ошибку.
        > Если strict mode выключен: обрежет записываемое значение до ближайшего
          допустимого, и запишет значение.
      > Все collations в MySQL относятся к типу PADSPACE. Это значит, что
        все значения типа CHAR, VARCHAR и TEXT сравниваются без учета пробелов
        по краям (traling spaces).
        * Это утвержднение не относится к оператору LIKE.

    > [NATIONAL] VARCHAR,  CHARACTER VARYING(M) [CHARACTER SET charset_name] [COLLATE collation_name]
      > Строка переменной длины. M - это максимальный размер значения в байтах.
      > Диапазон M: [0 - 65535] символов.
        > Однако, эффективный размер значения в символах может быть иной:
          > Он зависит от 2-х вещей:
            > От того, сколько байт занимает 1 символ в указанной кодировке.
            > От того, сколькью байтами ограничен MAX размер колонки в MySQL
              (см. 7. Лимиты в MySQL).
          > Он рассчитывается по следующей формуле:
            MAX размер колонки [байт] / размер 1 символа [байт]
          > Например, предположим, что MAX размер колонки 65535 байт, а 1 символ
            занимает 3 байта (у кодировки utf8), и в таблице у нас 1 колонка.
            Тогда MAX количество символов, которое в нее можно записать,
            = 65535 / 3 = 21845 символов.
      > У значения типа VARCHAR есть служебный символ - length prefix. Он содержит кол-во
        байт, которое занимает значение.
        > Он занимает:
          > 1 байт - если M <= 255 байт.
          > 2 байта - если M > 255 байт.
        > Например:
          VARCHAR(10) 'abc' занимает 4 байта.
      > Нулевые байты и trailing spaces
        > При записи никаких нулевых байтов или traling spaces не добавляется
        > Пробелы при извлечении VARCHAR значения НЕ обрезаются (в отличие от CHAR-значений).
        > Если колонка этого типа содержит индекс, то значения, отличающиеся только
          количеством trailing spaces, вызовут ошибку duplicate-key error.
          > Например, 'a' и 'a ' будут расценены, как одинаковые значения.
      > Поведение сервера в случае попытки записать в колонку значение, размер
        которого превышает указанный максимальный размер, сервер ведет себя
        в зависимости от того, включен ли strict mode работы сервера:
        > Если strict mode влючен: выдаст ошибку.
        > Если strict mode выключен: обрежет записываемое значение до ближайшего
          допустимого, и запишет значение.
      > Все collations в MySQL относятся к типу PADSPACE. Это значит, что
        все значения типа CHAR, VARCHAR и TEXT сравниваются без учета пробелов
        по краям (traling spaces).
        * Это утвержднение не относится к оператору LIKE.

    > BINARY, CHAR BYTE(M)
      > Тип BINARY - аналог типа CHAR, но хранит данные в строках в двоичном коде.
      > M - длина строки в байтах.
      > Не имеет character set и collation. Сравнивается по числовым значениям байтов.
      > Диапазон M: [0 - 255] байт.
      > Тип BINARY - не одно и тоже, что тип CHAR с атрибутом BINARY. Последний указывает
        на то, что в этом столбце используется binary collation.
      > Поведение сервера в случае попытки записать в колонку значение, размер
        которого превышает указанный максимальный размер, сервер ведет себя
        в зависимости от того, включен ли strict mode работы сервера:
        > Если strict mode влючен: выдаст ошибку.
        > Если strict mode выключен: обрежет записываемое значение до ближайшего
          допустимого, и запишет значение.
      > Нулевые байты и trailing spaces
        > При записи значения типа BINARY, если оно не заняло весь допустимый размер,
          то справа оно заполняется символами-заполнителями под завязку. У типа CHAR
          это были пробелы. А у VARBINARY - это нулевые байты (zero bytes 0x00).
          > Пример для колонки BINARY(4):
            При сохранении значения 'a ', сохранится 'a \0\0'.
        > При извлечении значения операцией SELECT нулевые байты НЕ обрезаются.
          > Если рассматривать предыдущий пример, то при извлечении мы получим
            'a \0\0'
        > Если колонка этого типа содержит индекс, то значения, отличающиеся только
          количеством trailing spaces, вызовут ошибку duplicate-key error.
          > Например, 'a' и 'a\0' будут расценены, как одинаковые значения.
      > В отличие от CHAR, при сравнении также учитываются и нулевые байты.
        Причем 0x00 < space. В том числе и в операциях с ORDER BY и DISTINCT.

    > VARBINARY(M)
      > Тип VARBINARY - аналог типа VARCHAR, но хранит данные в строках в двоичном коде.
      > M - длина строки в байтах.
      > Не имеет character set и collation. Сравнивается по числовым значениям байтов.
      > Диапазон M: [0 - 65535] байт
      > Тип VARBINARY - не одно и тоже, что тип VARCHAR с атрибутом BINARY. Последний
        указывает на то, что в этом столбце используется binary collation.
      > Поведение сервера в случае попытки записать в колонку значение, размер
        которого превышает указанный максимальный размер, сервер ведет себя
        в зависимости от того, включен ли strict mode работы сервера:
        > Если strict mode влючен: выдаст ошибку.
        > Если strict mode выключен: обрежет записываемое значение до ближайшего
          допустимого, и запишет значение.
      > Нулевые байты и trailing spaces
        > При записи нулевый байты не добавляются.
        > При извлечение никакие байты не обрезаются.
        > Если колонка этого типа содержит индекс, то значения, отличающиеся только
          количеством trailing spaces, вызовут ошибку duplicate-key error.
          > Например, 'a' и 'a\0' будут расценены, как одинаковые значения.
      > В отличие от VARCHAR, при сравнении также учитываются и нулевые байты.
        Причем 0x00 < space. В том числе и в операциях с ORDER BY и DISTINCT.

    > TINYBLOB
      > Тоже, что и BLOB, но с максимальной длиной 255 байт (2^8 - 1).
      > У значения типа TINYBLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 1 байт.
      > Не имеет character set и collation. Сравнивается по числовым значениям байтов.

    > TINYTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
      > Тоже, что и TEXT, но с максимальной длиной 255 символов.
        > Однако, эффективный размер значения в символах может быть иной:
          > Он зависит от 2-х вещей:
            > От того, сколько байт занимает 1 символ в указанной кодировке.
            > От того, сколькью байтами ограничен MAX размер колонки в MySQL
              (см. 7. Лимиты в MySQL).
          > Он рассчитывается по следующей формуле:
            MAX размер колонки [байт] / размер 1 символа [байт]
          > Например, предположим, что MAX размер колонки 65535 байт, а 1 символ
            занимает 3 байта (у кодировки utf8), и в таблице у нас 1 колонка.
            Тогда MAX количество символов, которое в нее можно записать,
            = 65535 / 3 = 21845 символов.
      > У значения типа TINYBLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 1 байт.

    > BLOB[(M)]
      > BLOB - Binary Large OBject. Может содержать различные массивы информации
        в двоичном коде. Например, текст или картинку.
      > Во многих отношениях, можно рассматривать тип BLOB, как тип VARBINARY,
        но который может быть настолько большим, насколько это потребуется.
        BLOB отличается от VARBINARY в следующих отношениях:
        > В колонках типа BLOB обязательно требуется указать index prefix length.
          В то время, как в VARBINARY-колонках это опция.
        > Колонка типа BLOB не может иметь значения по умолчанию (DEFAULT).
      > Плюсы и минусы использования BLOB для хранения файлов:
        > Плюсы
          + Файлы будут быстрее сохраняться и извлекаться при работе с базой данных
            и BLOB, чем при работе с файловой системой. Положительно на скорость
            также будут влиять кэширование данных.
          + Плюс к безопасности.
        > Минусы
          - Дольше будут сохраняться бэкапы базы данных, ведь в ней будут
            бОльшие объемы информации.
          - Производительность базы будет ниже из-за возросшей нагрузки, складывающейся
            из закачки/выгрузки файлов.
      > Есть 4 вида BLOB типов, отличающиеся MAX размером, который они могут хранить,
        а также размером length prefix'a:
        > TINYBLOB
        > BLOB
        > MEDIUMBLOB
        > LONGBLOB
      > Нулевые байты и trailing spaces
        > При записи значения в BLOB, если оно меньше максимального, никаких нулевых байтов
          или trailing spaces не добавляется, в отличие от типов CHAR и BINARY.
        > При извлечении ничего не обрезается.
      > M - длина BLOB-значения в байтах.
      > MAX M = 65,535 байт.
      > У значения типа BLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 2 байта.
      > Не имеет character set и collation. Сравнивается по числовым значениям байтов.
      > Поведение сервера в случае попытки записать в колонку значение, размер
        которого превышает указанный максимальный размер, сервер ведет себя
        в зависимости от того, включен ли strict mode работы сервера:
        > Если strict mode влючен: выдаст ошибку.
        > Если strict mode выключен: обрежет записываемое значение до ближайшего
          допустимого, и запишет значение.
      > MySQL Connector/ODBC определяет значения типа BLOB, как LONGVARBINARY.
      > Поскольку BLOB значение может быть экстримально большим, можно столкнуться
        с некоторыми ограничениями в связи с этим:
        > Только первые max_sort_length байт используются при сортировке.
          Дефолтное значение max_sort_length == 1024.
          > Можно указать другое значение:
            > На постоянной основе в конфигурационном файле сервера.
            > Только для текущего соединение в виде команды в консоли.
          > Доступный диапазон значений [4 - 8388608] байт.
        > Сервер при обработке запросов, использующих временные таблицы, результатом
          которых становится таблица с типами BLOB или TEXT, заставляет сервер
          сохранять эту таблицу на диск, а не в память, потому что движок хранилища
          MEMORY не поддерживает эти типы данных.
        > Максимальный размер объектов типа BLOB или TEXT определен самими типами,
          однако самое большое значение, которое реальном может быть передано
          между клиентом и сервером определяется количеством доступной памяти
          и размером коммуникационных буферов.
          > Можно изменить размер message buffer size, изменив опцию
            max_allowed_packet. По умолчанию оно == 4194304 байт == 4MB.
            Доступный диапазон: [1024 - 1073741824] или [1KB - 1GB]
            > На постоянной основе в конфигурационном файле сервера.
            > Только для текущего соединение в виде команды в консоли.


    > TEXT[(M)] [CHARACTER SET charset_name] [COLLATE collation_name]
      > Может содержать символьную строку.
      > Во многих отношениях, можно рассматривать тип TEXT, как тип VARCHAR.
        TEXT отличается от VARCHAR в следующих отношениях:
        > В колонках типа TEXT обязательно требуется указать index prefix length.
          В то время, как в VARCHAR-колонках это опция.
        > Колонка типа TEXT не может иметь значения по умолчанию (DEFAULT).
      > Есть 4 вида TEXT типов, отличающиеся MAX размером, который они могут хранить,
        а также размером length prefix'a:
        > TINYTEXT
        > TEXT
        > MEDIUMTEXT
        > LONGTEXT
      > Нулевые байты и trailing spaces
        > При записи лишние trailing spaces обрезаются, что сопровождается warning'ом.
        > При извлечении ничего не обрезается.
        > Если колонка этого типа содержит индекс, то значения, отличающиеся только
          количеством trailing spaces, вызовут ошибку duplicate-key error.
          > Например, 'a' и 'a ' будут расценены, как одинаковые значения.
      > M - длина TEXT-значения в символах.
        > Однако, эффективный размер значения в символах может быть иной:
          > Он зависит от 2-х вещей:
            > От того, сколько байт занимает 1 символ в указанной кодировке.
            > От того, сколькью байтами ограничен MAX размер колонки в MySQL
              (см. 7. Лимиты в MySQL).
          > Он рассчитывается по следующей формуле:
            MAX размер колонки [байт] / размер 1 символа [байт]
          > Например, предположим, что MAX размер колонки 65535 байт, а 1 символ
            занимает 3 байта (у кодировки utf8), и в таблице у нас 1 колонка.
            Тогда MAX количество символов, которое в нее можно записать,
            = 65535 / 3 = 21845 символов.
      > MAX M = 65,535 символов.
      > Поведение сервера в случае попытки записать в колонку значение, размер
        которого превышает указанный максимальный размер, сервер ведет себя
        в зависимости от того, включен ли strict mode работы сервера:
        > Если strict mode влючен: выдаст ошибку.
        > Если strict mode выключен: обрежет записываемое значение до ближайшего
          допустимого, и запишет значение.
      > При использовании атрибута BINARY в колонках типа TEXT, этой колонке
        назначается binary collation.
      > MySQL Connector/ODBC определяет значения типа TEXT, как LONGVARCHAR.

    > MEDIUMBLOB
      > Тоже, что и BLOB, но с максимальной длиной 16,777,215 байт (2^24 - 1).
      > У значения типа TINYBLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 3 байта.
      > Не имеет character set и collation. Сравнивается по числовым значениям байтов.

    > MEDIUMTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
      > Тоже, что и TEXT, но с максимальной длиной 16,777,215 символов.
        > Однако, эффективный размер значения в символах может быть иной:
          > Он зависит от 2-х вещей:
            > От того, сколько байт занимает 1 символ в указанной кодировке.
            > От того, сколькью байтами ограничен MAX размер колонки в MySQL
              (см. 7. Лимиты в MySQL).
          > Он рассчитывается по следующей формуле:
            MAX размер колонки [байт] / размер 1 символа [байт]
          > Например, предположим, что MAX размер колонки 65535 байт, а 1 символ
            занимает 3 байта (у кодировки utf8), и в таблице у нас 1 колонка.
            Тогда MAX количество символов, которое в нее можно записать,
            = 65535 / 3 = 21845 символов.
      > У значения типа TINYBLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 3 байт.
      > LONG и LONG VARCHAR сопоставляются с типом MEDIUMTEXT.

    > LONGBLOB
      > Тоже, что и BLOB, но с максимальной длиной 4,294,967,295 байт или 4GB (2^32 - 1).
      > Однако, эффективный размер колонки LONGBLOB зависит от настроенного максимального
        packet size в клиент/серверном протоколе и доступной памяти.
      > У значения типа TINYBLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 4 байта.
      > Не имеет character set и collation. Сравнивается по числовым значениям байтов.

    > LONGTEXT [CHARACTER SET charset_name] [COLLATE collation_name]
      > Тоже, что и TEXT, но с максимальной длиной 4,294,967,295 байт или 4GB символов.
        > Однако, эффективный размер значения в символах может быть иной:
          > Он зависит от 2-х вещей:
            > От того, сколько байт занимает 1 символ в указанной кодировке.
            > От того, сколькью байтами ограничен MAX размер колонки в MySQL
              (см. 7. Лимиты в MySQL).
          > Он рассчитывается по следующей формуле:
            MAX размер колонки [байт] / размер 1 символа [байт]
          > Например, предположим, что MAX размер колонки 65535 байт, а 1 символ
            занимает 3 байта (у кодировки utf8), и в таблице у нас 1 колонка.
            Тогда MAX количество символов, которое в нее можно записать,
            = 65535 / 3 = 21845 символов.
        > Эффективный размер колонки LONGBLOB также зависит от настроенного максимального
          packet size в клиент/серверном протоколе и доступной памяти.
      > У значения типа TINYBLOB есть служебный символ - length prefix. Он содержит
        кол-во байт, которое занимает значение, и имеет размер 3 байт.

    > ENUM('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]
      > Перечисление. Строковый объект, который может иметь только значение, выбранное
        из списка значений 'value1', 'value2' ... NULL, или специальное значение '',
        обозначающее ошибку.
        > Значения из списка определяют явно при определении колонки во время
          создания таблицы.
      > Если попробовать вставить в столбец ENUM значение, которого нет в списке
        допустимых значений, то:
        > Если strict SQL-mode влючен: будет ошибка
        > Если выключен: вставится error-значение в виде пустой строки ''
          > Найти все такие ошибочные значения в таблице можно выражением:
            SELECT * FROM tbl_name WHERE enum_col=0;
      > Преимущества и недостатки типа ENUM:
        > Преимущества:
          > Компактное хранение информации в случаях, когда список возможных значений
            ограничен. Строки, которые определяются в качестве значений, автоматически
            кодируются, как числа.
            > Ячейка типа ENUM занимает всего 1 байт.
          > Удобочитаемые запросы и выводы. Числа переводятся обратно в строки в
            результатах запроса.
        > Недостатки:
          > Не рекомендуется в качестве значений для типов ENUM использовать цифры,
            даже если они заключены в кавычки. Вот по каким соображениям:
            > Если хранить в ENUM-типах значения, похожие на числа, то легко перепутать
              литеральные значения с их внутренними числовыми индексами.
              > Но! Что самое опасное, это то, как сервер обрабатывает значения-числа
                при попытке их записи в ENUM-столбец:
                > Он проверяет, нет ли в столбце строки, в которой в целевом ENUM-столбце
                  индекс совпадает с цифрой-значением, которую хотят вставить.
                  > Если есть, то в качестве значения вставляется литеральное значение
                    из ячейки, соответствующей найденному индексу. А вовсе не цифру,
                    которую предполагалось вставить.
                    Даже если заключить ее в кавычки.
                  > Если нет, то в качестве значения вставляется само это число.
          > Использование типов ENUM в выражениях с ORDER BY требует быть особенно
            осторожным.
      > Внутренне, значения типа ENUM представлены, как перечисления.
      > ENUM может иметь MAX 65353 отдельных элемента (на практике менее 3000).
      > В таблице может быть не более 255 стоблцов типов ENUM и SET (в совокупности).
      > Создание и использование ENUM-колонок
        > См. пример выше.
        > Значения типа ENUM должны быть заключенными в кавычки литералами.
      > У каждого значения типа ENUM есть свой уникальный индекс:
        > Термин "индекс" здесь обозначает позицию в списке допустимых значений
          колонки ENUM. Не путать с табличными индексами.
        > Каждому элементу из списка, заданного при определении колонки типа ENUM,
          присваивается уникальный индекс в порядке возрастания, начиная с 1.
        > Ячейки, в которых находится error-значение типа ENUM, имеют индекс 0.
          Зная это, можно найти такие ячейки в таблице (см. пример выше).
        > Индекс значения NULL - это NULL.
      > Если запросить значение типа ENUM в числовом контексте, то вернется
        его индекс в виде числа, а не литеральное представление.
        > Например, в функциях SUM() или AVG().
      > Колонки типа ENUM могут иметь атрибуты CHARACTER SET и COLLATE.
      > Как сервер обрабатывает литералы при определении колонки типа ENUM:
        > Trailing spaces автоматичеки удаляются из строк, представляющих
          допустимые значения ENUM.
        > При извлечении литерального представления, сервер возвращает их в том же
          регистре, в котором они были определены.
        > Не рекомендуется в качестве значений для типов ENUM использовать цифры,
          даже если они заключены в кавычки. Поробности немного выше.
      > Значения в столбцах типа ENUM сортируются по их индексам. А индексы назначаются
        по возрастанию, с шагом в 1, начиная с 1.
        > Чтобы избежать непредсказуемых результатов:
          > Записывать значения при объявлении ENUM-стобца в алфавитном порядке.
          > Убедиться, что колонка отсортирована лексически, а не по номеру,
            с помощью выражений типа ORDER BY CAST(col AS CHAR) или ORDER BY CONCAT(col).
      > Значение типа ENUM не может быть выражением. Никаким. Даже тем, которое возвращает
        строку.


    > SET('value1','value2',...) [CHARACTER SET charset_name] [COLLATE collation_name]
      > Набор. Строковый объект, который может иметь 0 или более значений, каждое из
        которых должно быть выбрано из определенного при создании списка значений
        'value1', 'value2', ....
      > В отличие от ENUM, SET может выдавать не только 1 значение за раз,
        а любую комбинацию своих значений в строку через запятую.
        > Пример: SET('один', 'два') может иметь следующие значения:
          1) ''   2) 'один'  3) 'два'  4) 'один,два'
        > Поэтому любое значение SET не должно содержать в себе запятую ','
      > Внутреннее представление SET-типов - такое же, как и у ENUM - это числа.
        MySQL сохраняет SET-значения в виде чисел, с младшим битом сохраненного
        значения, соответствующего первому члену сета.
      > Колонка SET-типа может иметь до 64 отдельных элементов.
      > В таблице может быть не более 255 стоблцов типов ENUM и SET (в совокупности).
      > Если попробовать при определении столбца типа SET указать дублирующие
        значения, то:
        > Если strict mode влючен: будет ошибка.
        > Если выключен, будет предупреждение.
      > Trailing spaces автоматически удаляются при определении SET-значений.
      > При извлечении литерального представления, сервер возвращает их в том же
        регистре, в котором они были определены.
      > Колонки типа ENUM могут иметь атрибуты CHARACTER SET и COLLATE.
      > Если попытаться извлечь SET-значение в числовом контексте, результирующее
        значение будет иметь сет бит, отвечающий сету значений, составляющему значение
        в ячейке.
      > Если в колонку типа SET сохранено число, то сервер определяет двоичное
        представление этого числа, и записывает его.
      > Порядок вставки сетов в SET-столбец не важен. Также не важно,
        сколько раз в каждом сете повторяется одно и тоже сет-значение.
        Потому что когда значение запрашивается позже, каждыое сет-значение
        возвращается только 1 раз, с элементами, возникающими в том же порядке,
        в котором они были введены при определении колонки типа SET.
      > Если попробовать вставить в SET-колонку не поддерживаемое значение,
        то оно будет проигнорировано, и будет выдано предупреждение. Либо ошибка,
        если включен strict mode.
      > Если запросить SET-значение в числовом контексте, то используется его
        числовое представление. Например, функциями SUM() или AVG().
      > Для поиска в SET-столбце используют функцию FIND_IN_SET() или оператор LIKE.






-------------------------------------------------- */
















