/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
9. Сохраняемые программы и представления


  > Определение и использование сохраняемой процедуры
    > Создать сохраняемую процедуру
    > Выполнить сохраняемую процедуру
    > Посмотреть теперь содержимое переменной @x
  > Метаданные скрипта
    > Посмотреть все метаданные          | INFORMATION_SCHEMA.ROUTINES
    > Посмотреть определение скрипта     | SHOW CREATE (PROCEDURE | FUNCTION) [name]
    > Посмотреть характеристики скрипта  | SHOW (PROCEDURE | FUNCTION) STATUS

  > Создание, использование, удаление триггера
    > Создать тренировочную таблицу
    > Создать BEFORE-триггер, реагирующий на INSERT
    > Провести 3 операции INSERT в эту таблицу
    > Посмотреть теперь значение переменной @sum
    > Удалить триггер

  > Метаданные триггера
    > Посмотреть все метаданные          | INFORMATION_SCHEMA.TRIGGERS
    > Посмотреть определение триггера    | SHOW CREATE TRIGGER [trg_name]
    > Посмотреть список триггеров в БД   | SHOW TRIGGERS

  > Метаданные события
    > Посмотреть все метаданные          | INFORMATION_SCHEMA.EVENTS
    > Посмотреть еще метаданные          | mysql.event
    > Посмотреть определение события     | SHOW CREATE EVENT [event_name]
    > Посмотреть список событий в БД     | SHOW EVENTS

  > Создание и использование представления  | CREATE VIEW
    > Создать таблицу, из которой потом будем создавать представление
    > Записать в нее значения
    > Создать представление
    > Обратиться к представлению и получить содержимое этой виртуальной таблицы

  > Метаданные представления
    > Таблица VIEWS базы данных INFORMATION_SCHEMA
    > Операция  SHOW CREATE VIEW [view_name]



-------------------------------------------------- */

USE test;



-- Определение и использование сохраняемой процедуры

  -- Создать сохраняемую процедуру
  -- (перед выполнением в mysql shell поменять delimiter на другой)
  CREATE PROCEDURE dorepeat(p1 INT)
  BEGIN
    SET @x = 0;
    REPEAT SET @x = @x + 1; UNTIL @x > p1 END REPEAT;
  END;

  -- Выполнить сохраняемую процедуру
  CALL dorepeat(1000);

  -- Посмотреть теперь содержимое переменной @x
  SELECT @x;    -- 1001


-- Метаданные скрипта

  -- Посмотреть все метаданные
  SELECT * FROM INFORMATION_SCHEMA.ROUTINES;

  -- Посмотреть определение скрипта
  SHOW CREATE PROCEDURE dorepeat;
  SHOW CREATE FUNCTION somefunc;

  -- Посмотреть характеристики скрипта
  SHOW PROCEDURE STATUS;
  SHOW FUNCTION STATUS;


-- Создание, использование, удаление триггера

  -- Создать тренировочную таблицу
  CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));

  -- Создать BEFORE-триггер, реагирующий на INSERT
  -- В теле выражение, суммирующие значения из столбца amount при каждой вставке
  CREATE TRIGGER ins_sum BEFORE INSERT ON account
  FOR EACH ROW SET @sum = @sum + NEW.amount;

  -- Провести 3 операции INSERT в эту таблицу
  SET @sum = 0;         -- определить переменную
  INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);

  -- Посмотреть теперь значение переменной @sum
  SELECT @sum;

  -- Удалить триггер
  DROP TRIGGER test.ins_sum;


-- Метаданные триггера

  -- Посмотреть все метаданные
  SELECT * FROM INFORMATION_SCHEMA.TRIGGERS;

  -- Посмотреть определение триггера
  SHOW CREATE TRIGGER test.ins_sum;

  -- Посмотреть все триггеры указанной БД (по умолчанию - БД по умолчанию)
  SHOW TRIGGERS;


-- Метаданные события
  -- Посмотреть все метаданные          | INFORMATION_SCHEMA.EVENTS
  SELECT * FROM INFORMATION_SCHEMA.EVENTS;

  -- Посмотреть еще метаданные          | mysql.event
  SELECT * FROM mysql.event;

  -- Посмотреть определение события     | SHOW CREATE EVENT [event_name]
  SHOW CREATE TRIGGER some_event;

  -- Посмотреть список событий в БД     | SHOW EVENTS
  SHOW EVENTS;


-- Создание и использование представления  | CREATE VIEW

  -- Создать таблицу, из которой потом будем создавать представление
  CREATE TABLE t (qty INT, price INT);

  -- Записать в нее значения
  INSERT INTO t VALUES(3, 50), (5, 60);

  -- Создать представление
  CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;

  -- Обратиться к представлению и получить содержимое этой виртуальной таблицы
  SELECT * FROM v WHERE qty = 5;

-- Метаданные представления

  -- Таблица VIEWS базы данных INFORMATION_SCHEMA.
  SELECT * FROM INFORMATION_SCHEMA.VIEWS;

  -- Операция  SHOW CREATE VIEW [view_name].
  SHOW CREATE VIEW someview;


/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальное руководство по сохраняемым программам и представлениям
        http://dev.mysql.com/doc/refman/5.6/en/sql-syntax.html


*****************************************************
Оглавление:


> Общая информация
  > Что такое сохраняемые программы и представления?
  > Есть 4 вида сохраняемых программ
  > Общая информация о каждом из видов сохраняемых программ
    > Процедуры
    > Функции
    > Триггеры
    > События
  > Представления (views, вьюхи)
> Определение сохраняемых программ
> Использование сохраняемых программ (процедур и функций)
  > Общая информация
  > Синтаксис сохраняемых скриптов
  > Метаданные сохраняемых скриптов
  > Особенности работы LAST_INSERT_ID() в сохраняемых процедурах, функциях, триггерах.
> Использование триггеров
  > Общая информация
  > Синтаксис триггеров
  > Метаданные триггеров
> Использование событий
  > Общая информация
  > Настройка планировщика событий
  > Синтаксис событий
  > Метаданные событий
  > Как планировщик событий работает с датами и временем
> Использование представлений (view, вьюхи)
  > Общая информация
  > Синтатксис представлений
  > Алгоритмы обработки представлений
  > Обновляемые и не обновляемые представления
  > Метаданные представлений



*****************************************************


> Общая информация

  > Что такое сохраняемые программы и представления?
    > Сохраняемые программы и представления - объекты базы данных, определенные с помощью
      SQL-кода, которые сохраняют на сервере для выполнения в дальнейшем.
    > Сохраняемые программы делятся на 2 вида: сохраняемые процедуры и сохраняемые функции.
    > Вызываются с помощью выражения CALL.

  > Есть 4 вида сохраняемых программ:
    > Сохраняемые процедуры.
    > Сохраняемые функции.
    > Триггеры
    > События

  > Общая информация о каждом из видов сохраняемых программ:

    > Процедуры:
      > Процедуры, в отличие от функций, не возвращают значения. Но могут изменять
        внутри себя внешние переменные.
      > Также процедуры формируют группу результатов для отправки программе-клиенту.

    > Функции:
      > Работают практически также, как и встроенные фукнции.
      > Функцию вызывают в каком-нибудь выражении, и она возвращает значение в это
        выражение в месте вызова.

    > Триггеры:
      > Триггер - это именованный объект базы данных, связанный с конкретной табицей.
        Содержит SQL-код для выполнения. Активируется, когда с этой таблицей проводят
        определенные операции, такие как INSERT или UPDATE.

    > События:
      > Это практически тоже самое, что и триггеры, только активируются при наступлении
        определенных даты и времени.

  > Представления (views, вьюхи)
    > Представление - виртуальная таблица. С ней можно работать также, как с обычной.
    > Ее называеют виртуальной, потому что она не хранится на жестком диске, как
      обычная таблица. Вместо этого, в базе данных хранится SQL-запрос. При обращении
      к представлению из этого запроса в оперативной памяти формируется результат
      в виде виртуальной таблицы.

> Определение сохраняемых программ
  > Тело сохраняемой программы
    > У каждой сохраняемой программы есть тело (body), содержащее SQL-выражение.
    > Это SQL-выражение может содержать сколько угодно SQL-выражений, разделенных
      точкой с запятой ';'.
      > Для этого требуется заключить все эти SQL-выражения в блок
        BEGIN ... END.
      > При выполнении такого выражения в клиенте mysql shell, есть одна проблема.
        Символ ';' в ней считается символом конца выражения. Поэтому, перед
        выполнением такого выражения требуется изменить delimiter клиента mysql shell
        на другой. А после выполнения, поменять обратно на ;.
        > Чтобы изменить delimiter на, например, символ #, используй следующую команду:
          \d ;
          (см. пример выше).

> Использование сохраняемых программ (процедур и функций)
  > Общая информация
    > Сохраняемые процедуры и функции поддерживаются в MySQL 5.6.
    > Сохраняемые скрипты для своей работы требуют таблицу proc в БД mysql.
    > Сохраняемые скрипты могут быть особенно полезны в следующих ситуациях:
      > Когда с базой работают много приложений, написанных на разных ЯП. И всем им требуется
        выполнять один и тот же скрипт по работе с базой. Тогда этот скрипт разумно
        сохранять в виде SQL-выражения в базе.
      > Когда безопасность стоит на 1-м месте. Например, банки используют сохраняемые скрипты
        для всех общих операций. При этом приложения и пользователи не имеют прямого доступа к
        таблицам базы данных, а могут выполнять только скрипт из фиксированного набора.
    > Производительность при использовании сохраняемых процедур может как пострадать,
      так и выиграть - все зависит от конкретной ситуации.
      > С одной стороны, производительность возрастает, потому что меньше информации
        посылается между сервером и клиентом.
      > С другой стороны падает производительность сервера базы данных, потому что
        он выполняет больше работы. Особенно, если одна база данных обслуживает
        много веб-серверов.
    > Благодаря сохраняемым скриптам, также можно организовать на сервере базы данных
      библиотеку функций, с которой можгут работать приложения, написанные на любом ЯП.

  > Синтаксис сохраняемых скриптов
    > Несколько основных выражений по работе с сохраняемыми скриптами:
      > CALL - для выполнения скрипта.
      > Сохраняемые процедуры:
        > CREATE PROCEDURE   - создать процедуру
        > ALTER PROCEDURE    - изменить процедуру
        > DROP PROCEDURE     - удалить процедуру
      > Сохраняемые функции:
        > CREATE FUNCTION    - создать функцию
        > ALTER FUNCTION     - изменить функцию
        > DROP FUNCTION      - удалить функцию
    > Конкретный сохраняемый скрипт (процедуру или функцию) прикрепляют к 1-й конкретной
      базе данных. Это имеет следующие последствия:
      > При запуске скрипта неявно вызывается выражение USE db_name. А при завершении
        его работы, неявно возвращается прежняя БД по умолчанию.
        Использование выражения USE в теле скрипта запрещено.
      > При обращении к скрипту, можно через точку квалифицировать его имя названием БД,
        в которой он находится, чтобы получить к нему доступ, если он находится не в
        текущей БД по умолчанию.
        Синтаксис такой:  [название_БД].[название_скрипта];
      > При удалении базы данных, все прикрепленные к ней скрипты удаляются тоже.
    > Рекурсия в сохраняемых скриптах
      > Разрешена, но отключена по умолчанию.
      > Ее статус управляется системной переменной max_sp_recursion_depth сервера MySQL.
      > Использование рекурсии предъявляет повышенное требование к размеру стека для
        каждого потока, который управляется системной переменной thread_stack сервера MySQL.
    > В MySQL можно использовать обычны выражения SELECT в теле сохраняемых скриптов,
      и тогда в ответ на выполнение такого скрипта клиенту просто посылается набор
      результатов (множественные результаты).
      > Чтобы клиент мог это обработать, у него должна быть включена опция CLIENT_MULTI_RESULTS.

  > Метаданные сохраняемых скриптов
    > Они хранятся в следующих местах:
      > Таблица ROUTINES в базе данных INFORMATION_SCHEMA.
        INFORMATION_SCHEMA.ROUTINES
      > Выражение SHOW CREATE (PROCEDURE | FUNCTION) [name];  - посмотреть определение скрипта.
      > Выражение SHOW (PROCEDURE | FUNCTION) STATUS - посмотреть характеристика скрипта.

  > Особенности работы LAST_INSERT_ID() в сохраняемых процедурах, функциях, триггерах.
    > Встроенная функция LAST_INSERT_ID() ищет среди таблиц с атрибутом AUTO_INCREMENT
      ту, для которой была выполнена самая последняя команда INSERT, и возвращает этот
      самый ID из колонки с автоинкрементом.
    > Так вот, эта функцию работает по разному с разными типами сохраняемых программ:
      > С сохраняемыми процедурами.
        > Если сохраняемая процедура использует выражения, которые изменяют значение
          LAST_INSERT_ID() - то есть передат в функцию аргумент - то внесенные изменения
          видны выражениями, которые следуют после процедуры.
      > С сохраняемыми функциями и триггерами.
        > Не видны (в описанной выше ситуации).

> Использование триггеров
  > Общая информация
    > Триггер - это именованный объект базы данных, прикрепленный к 1-й конкретной таблице.
      Он активируется когда определенное событие происходит с этой таблицей. Его можно
      исползовать, например, для проверки или изменения значения, непосредственно перед
      его вставкой в таблицу (BEFORE INSERT-триггер)
    > Активация триггера
      > Триггер может быть активирован в ответ на следующие операции с его таблицей:
        > INSERT
        > UPDATE
        > DELETE
      > Например, при выполнении операции LOAD DATA, INSERT-триггер будет активироваться
          при вставке каждой строки.
      > Внимание! Триггер активируется только от изменений, внесенных в таблийу SQL-выражениями.
        Он не активируется при изменениях в представлении (view), или изменениях, сделанных
        не через SQL-выражения, передающиеся серверу MySQL. Это также влечет:
        > Триггеры не активируются изменениями в таблицах INFORMATION_SCHEMA или
          performance_schema, потому что эти таблицы являются представлениями (view).
        > Триггеры не активируются изменениями, сделанными через NDB-API.
    > Триггер может отработать как до, так и после операции. Это можно настроит.
      > Атрибут BEFORE - указывает, что до. Это BEFORE-триггер
      > Атрибут AFTER - указывает, что после. Это AFTER-триггер.

  > Синтаксис триггеров
    > Для создания триггера используют операцию CREATE TRIGGER.
    > Для удаления триггера используют операцию DROP TRIGGER.
    > Для настроки, когда отработает триггер, до или после активировавшей его операции,
      используют, соответственн, атрибуты BEFORE и AFTER.
    > Для указания при определении триггера, при каких событиях с его таблицей он
      будет срабатывать, используют атрибуты INSERT, UPDATE, DELETE. Не перепутай
      эти атрибуты с соответстующими операциями!
    > Выражение, следующее за FOR EACH ROW обозначает тело триггера. Есть 3 варианта,
      каким образом можно организовать тело триггера:
      1 Использовать в качестве тела 1 SQL-выражение, без точек с запятой. Его можно
        записать прямо при определении триггера. Минус в том, что оно только 1-но.
      2 Все тело триггера заключить в блок BEGIN ... END. В этом блоке может находиться
        сколько угодно SQL-выражений, разделенных между собой точкой с запятой. Не забыть
        сменить delimiter на другой при определении такого триггера в клиенте mysql shell.
      3 Отдельно от триггера определить сохраняемую процедуру. И указать ее при
        определения триггера в ее теле. Этот вариант лучше, чем 2-й, потому что ту же
        самую процедуру возможно будет использовать и при определении других триггеров.
    > Имена триггеров находятся в пространстве имен базы данных. Поэтому все они должны
      быть уникальны в этом пространстве имен.
    > У одной таблицы не может быть 2-х одинаковых триггеров. Например, 2-х триггеров
      с атрибутами BEFORE и INSERT.
    > Ключевые слова NEW и OLD позволяют в теле триггера получить доступ к столбцам
      в строках, затронутых триггером.
      > Ограничения по использованию NEW и OLD в разных типах триггеров:
        > В INSERT-триггере может быть использовано только NEW, потому что OLD-строки нет.
        > В DELETE-триггере может быть использовано только OLD, потому что NEw-строки не будет.
        > В UPDATE-триггере могут быть использованы и NEW, и OLD.
      > Ограничения на чтение/запись значений при разных сочетаниях NEW/OLD и типов триггеров:
        > OLD + любой тип триггера: только чтение. Требуются права на SELECT.
        > NEW + любой тиа триггера: доступно чтение. Требуются права на SELECT.
        > NEW + BEFORE-триггер: доступна запись. То есть можно перед вставкой
          значения в таблицу как-то его обработать. Требуются права на UPDATE.
          > Синтаксист SQL-выражения такой: SET NEW.col_name = value
      > В BEFORE-триггере значения, полученные через NEW для колонки с AUTO_INCREMENT
        равны 0, а не 1 - потому что 1-ца сгенерируется автоматом только после фактической
        записи строки.
    > Есть ограничение на то, что может быть в теле триггера в SQL-выражениях:
      > В теле триггере нельзя использовать операцию CALL для вызова сохраняемой процедуры,
        которая возвращает (например, операцией SELECT) данные клиенту.
        > Вместо этого сохраняемые процедуры могут обмениваться данными с триггером
          посредством параметров OUT и INOUT.
      > В теле триггера не могут быть использованы операции, которые явно или не явно
        начинают или заканчивают транзакцию. Такие, как TRANSACTION, COMMIT или ROLLBACK.
    > MySQL обрабатывает ошибки во время выполнения триггера следующим образом:
      > Если BEFORE-триггер потерпел неудачу, то операция с соответствующей строкой не проводится.
      > BEFORE-триггер активируется попыткой вставить или изменить строку. Активация
        происходит вне зависимости от того, потерпит ли эта попытка неудачу или успех впоследствии.
      > AFTER-триггер активируется только в случае успеха BEFORE-триггера (если был) и
        операции на строке.
      > Неудача AFTER-триггера и/или BEFORE-триггера приводит к неудаче всего выражения,
        которое активировало этот триггер.
      > Если выражение, активировавшее триггер потерпело неудачу, то в транзакционных
        таблицах происходит ROLLBACK.

  > Метаданные триггеров
    > Они хранятся в следующих местах:
      > В таблице TRIGGERS базы данных INFORMATION_SCHEMA.
        INFORMATION_SCHEMA.TRIGGERS
      > SHOW CREATE TRIGGER [trg_name];   - посмотреть определение триггера trg_name
      > SHOW TRIGGERS                     - посмотреть триггеры в указанной БД.

> Использование событий
  > Общая информация
    > Планировщик собыний MySQL - управляет планированием и выполнением событий.
    > Событие - именованый объект базы данных, который, как и триггер, имеет тело
      с 1-м или несколькими SQL-выражениями, и который выполняется по расписанию
      в планировщике событий (и никак не прикреплен ни к какой таблице, в отличие от триггера)
    > Сохраняемые скрипты требуют наличия таблицы event в базе данных mysql.
      > Эта таблица создается автоматически при установке сервера MySQL 5.6.
    > Событие может выполняться с заданным периодом, начиная с заданной даты и времени,
      и заканчивая заданной датой и временем.
    > В MySQL 5.6 событие может быть однозначно идентифицировано по его имени и
      базе данных, к которому оно прикреплено.
    > У события есть тело (body), в котором содержится 1-но или более SQL-выражений.
      Тело выполняется при активации события.
      Есть 3 варианта, каким образом можно организовать тело события:
      1 Использовать в качестве тела 1 SQL-выражение, без точек с запятой. Его можно
        записать прямо при определении триггера. Минус в том, что оно только 1-но.
      2 Все тело триггера заключить в блок BEGIN ... END. В этом блоке может находиться
        сколько угодно SQL-выражений, разделенных между собой точкой с запятой. Не забыть
        сменить delimiter на другой при определении такого триггера в клиенте mysql shell.
      3 Отдельно от триггера определить сохраняемую процедуру. И указать ее при
        определения триггера в ее теле. Этот вариант лучше, чем 2-й, потому что ту же
        самую процедуру возможно будет использовать и при определении других триггеров.
    > У события есть свойство повторяемости. Событие может быть:
      > Одноразовым - активируется 1 раз, в указанные дату и время.
      > Многоразовым.
        > Требуется указать:
          > Период - с каким периодом в пределах указанных дат и времен активации и
            дезактивации будет запускаться тело события. По умолчанию, оно запускается
            в момент активации и работает, пока не будет дезактивировано или удалено.
        > Можно указать:
          > Дату и время начала - когда механизм активируется.
          > Дату и время конца - когда механизм дезактивируется.
    > Ряд значений свойств события могут быть изменены с помощью SQL-выражений:
      > имя           | имя события
      > время         | временные насройки (см. выше)
      > постоянство   | сохраняется ли событие после деактивации
      > статус        | активировано / деактивировано
      > действие      | скрипт события
      > база данных   | к какой БД прикреплено
    > У события есть свойство DEFINER - содержащее информацию о том, кто определил
      это событие. По умолчанию - это тот, кто его создал, либо тот, кото в последний
      раз изменял его (с помощью операции ALTER).
    > Событие может быть изменено пользователем, у которого есть EVENT-права на БД.

> Настройка планировщика событий
  > События выполняются специальным потоком планировщика событий. Так что под
    "планировщиком событий" имеется в виду его поток.
  > Поток планировщика событий видят пользователи, у которых есть PROCESS-право,
    выполнив команду SHOW PROCESSLIST.
  > Состояние планировщика событий определяется системной переменной event_scheduler
    сервера MySQL.
    > У него есть 3 состояния:
      > ON
      > OFF
      > DISABLED
    > Состояние ON
      > Планировщик событий работает - активирует и выполняет все запланированные события.
        Когда планировщик событий в состоянии ON, он отображается в результатах выполнения
        операции SHOW PROCESSLIST, как фоновый процесс.
    > Состояние OFF (по умолчанию)
      > Планировщик событий остановлен. Его поток не показывается в результатах выполнения
        операции SHOW PROCESSLIST. Никакие запланированные события не выполняются.
    > Состояние DISABLED
      > Тоже самое, что OFF. Но при этом уже не получится с помощью операции SET
        на системную переменную event_scheduler переключить состояние планировщика.
  > Состояние планировщика событий можно переклчить с помощью операции SET.
    > Воспользоваться операцией SET для переключения состояния планировщика событий
      можно только, если его текущее состояние не DISABLED.
    > Использовать ON или 1 в качестве "включен", и OFF или 0 в качестве "выключен"
      - не принципиально.
    > Вот 4 варианта синтаксиса такой операции:
      > SET GLOBAL event_scheduler = (ON | OFF);
      > SET @@global.event_scheduler = (ON | OFF);
      > SET GLOBAL event_scheduler = (1 | 0);
      > SET @@global.event_scheduler = (1 | 0);
  > Особенности состояния DISABLED
    > Для переключения планировщика событий между DISABLED и НЕ DISABLED
      состояниями требуются SUPER-права.
    > Как переключить планировщик событий в состояние DISABLED:
      > На постоянной основе - прописать значение event_scheduler=DISABLED в
        конфигурационном файле сервера my.ini в группе [mysqld].
      > Только для текущего соединения - при подключении к серверу указать команду
        --event-scheduler=DISABLED
    > Как отключить режим DISABLED у планировщика событий:
      > Запустить сервер без вышеуказанных опций.
    > В состоянии DISABLED можно отправлять серверу команды по работе с событиями,
      но выполняться они не будут..
      > Никаких предупреждений или ошибок при этом возникать не будет.
      > Но когда планировщик событий перестанет быть DISABLED, все отправленные ему
        в состоянии DISABLED команды будут выполнены.
    > У MySQL есть баг - при запуске сервера с опцией --skip-grant-tables, опция
      event_scheduler намертво становится DISABLED, и вывести ее из этого состояния
      не может ничто, кроме как если убрать --skip-grant-tables.

> Синтаксис событий
  > Новое событие можно создать операцией CREATE EVENT.
  > Определение существующего события может быть изменено операцией ALTER EVENT.
  > Удалить событие можно операцией DELETE EVENT.
    > Событие может быть удалено пользователем с EVENT-правом.

> Метаданные событий
  > Они хранятся в следующих местах:
    > Таблица event базы данных mysql.
    > Таблица EVENTS базы данных INFORMATION_SCHEMA.
    > Операция SHOW CREATE EVENT [event_name] - посмотреть определение события
    > Операция SHOW EVENTS - покажет события указанной базы данных (по умолчанию -
      база данных по умолчанию).

> Как планировщик событий работает с датами и временем
  > При каждом подключении к серверу MySQL инициализируется переменная сервера
    time_zone. Ее можно изменить для уже существующего подключения.
  > Значение из системной переменной time_zone используется во время выполнения
    операций CREATE EVENT или ALTER EVENT для того, чтобы перевести заданные
    дата-временные значения в UTC и сохранить их в таком виде.
    > В UTC перевоятся дата-временные значения из таблицы mysql.event:
      > execute_at
      > starts
      > ends
    > Также в UTC сохраняется значение свойства last_executed.
    > Все данные сохраняются в UTC, а не в той же временной зоне, в которой они были
      заданы для того, чтобы сделать сохраненные значения независимыми от временной
      зоны клиента, которая может измениться. Фиксация временной зоны, в которой
      сохраняются значения, делают их независимыми от значения time_zone у клиента.
    > При извлечении сохраненных дата-временных значений, они переводятся во
      временную зону клиента с использованием значения из системной переменной time_zone.

> Использование представлений (view, вьюхи)
  > Общая информация
    > Представляения (включая обновляемые представления) доступны в MySQL 5.6.
    > Представление - это хранимый запрос, который при обращении к нему формирует
      результирующую таблицу.
    > Представления по сути являются виртуальными таблицами.
    > Пример реальной ситуации, в которой могут пригодиться представления:
      1. Написали сайт, куча кода, база данных.
      2. Вдруг понадобилось изменить структуру базы данных
      3. Создаем новую базу данных, а в старой БД на месте таблиц
         создаем вьюхи, ссылающиеся на таблицы новой БД.
         Вуаля. В приложении код менять не надо.

  > Синтатксис представлений
    > Создать представление можно операцией CREATE VIEW.
    > Изменить существующее представление - операция ALTER VIEW.
    > Представления могут быть созданы как из реальных таблиц, так и из других
      представлений, в любых сочетаниях.
    > Для создания представлений можно использовать JOIN's, UNION'ы и подзапросы.

  > Алгоритмы обработки представлений
    > Алгоритм обработки представлений - это дополнение MySQL к SQL. Он определяет, как
      MySQL обрабатывает представления.
    > Он определяется, как значение атрибута ALGORITHM для выражений CREATE VIEW или
      ALTER VIEW.
    > Всего есть 3 варианта алгоритмов:
      > UNDEFINED (по умолчанию)
      > MERGE
      > TEMPTABLE
    > UNDEFINED
      > MySQL сам выбирает, какой алгоритм использовать.
      > UNDEFINED может быть выбран в 3-х случаях:
        > Атрибут ALGORITHM не указан в определении представления.
        > Атрибут ALGORITHM указан, и == UNDEFINED.
        > Атрибут ALGORITHM указан, и == MERGE для представления, которое может быть
          обработано только с помощью временной таблицы.
    > MERGE
      > Текст выражения, которое ссылается на представление, и определение представления
        сливаются.
      > Не может быть использован, если представление содержит хотя бы одну из
        следующих конструкций:
        > Агрегирующие функции: SUM(), MIN(), MAX(), COUNT() и т.д.
        > DISTINCT
        > GROUP BY
        > HAVING
        > LIMIT
        > UNION или UNION ALL
        > Подзапрос в списке select
        > Ссылается только на литеральные значения (в этом случае нет таблиц, которые требуется обновлять)
    > TEMPTABLE
      > Результаты представления извлекаются во временную таблицу, которая потом и
        используется для выполнения выражения.
      > Преимущество этого алгоритма над MERGE в том, что с таблиц, которые участвуют
        в формировании представления - быстрее снимается блок, чем при алгоритме
        MERGE.

  > Обновляемые и не обновляемые представления
    > Представления бывают обновляемые и не обновляемые.
    > Обновляемые представление - которые можно использовать в операциях UPDATE, DELETE
      или INSERT для обновления содержимого таблиц, которые лежат в основе этого
      представления.
    > При создании или обновлении определения представления, MySQL ставит в таблицу
      метаданных для этого представления флаг, который содержит информацию о том,
      является ли представление обновляемым. Эта информация содержится в колонке
      IS_UPDATABLE таблицы VIEWS базы данных INFORMATION_SCHEMA.
    > Чтобы представление было обновляемым, нужно:
      > there must be a one-to-one relationship between the rows in the view and
        the rows in the underlying table
      > Условия для того, чтобы представление было DELETEble и UPDATEable:
        Представление не является таковым, если содержит хотя бы одну из
        следующих конструкций:
        > Агрегирующие функции: SUM(), MIN(), MAX(), COUNT() и т.д.
        > DISTINCT
        > GROUP BY
        > HAVING
        > UNION или UNION ALL
        > Подзапрос в списке select
        > Определенные JOINs.
        > Не обновляемое представление в атрибуте FROM
        > Подзапрос в атрибуте WHERE, который ссылается на наблицу из атрибута FROM
        > Ссылается только на литеральные значения (в этом случае нет таблиц, которые требуется обновлять)
        > Использует ALGORITHM = TEMPTABLE (использование временных таблиц всегда делает
          представление необновляемым)
        > Множественные ссылки на любую колонку лежащих в основе таблиц.
      > Если представление является DELETEble и UPDATEable, то для того, чтобы оно было
        еще и INSERTable, должны быть выполнены следующие доп. условия:
        > В представлении не должно быть колонок с одинаковыми именами.
        > Все колонки, которые используются в представлении, в своих не виртуальных таблицах
          не должны иметь явных DEFAULT-значений.
        > Колонки в представлении должны быть простыми, а не результатом какого-либо выражения.
          > Сложные колонки в представлении не могут участвовать в операциях INSERT,
            UPDATE или DELETE.
      > Для многотабличного обновляемого представления:
        > INSERT может работать при вставке в 1-ну таблицу.
        > DELETE не поддерживается.
      > Если представление состоит из нескольких таблиц, и в одной из них есть столбец
        с автоинкриментом, и это представление явлется вставляемым (insertable), то
        вставка строки через это представление в таблицу без автоинкримента не приведет
        к изменению LAST_INSERT_ID().
      > Атрибут WITH CHECK OPTION может быть использован в обновляемых представлениях,
        чтобы избежать встаки или обновления строк, кроме тех, для которых атрибут
        WHERE в select_statement является true.
      > У атрибута WITH CHECK OPTION есть ключевые слова:
        > LOCAL (по умолчанию)
          > Проверка только указанного представления
        > CASCADED
          > Проверка и всех вложенных представлений.

  > Метаданные представлений
    > Они хранятся в следующих местах:
      > Таблица VIEWS базы данных INFORMATION_SCHEMA.
      > Операция  SHOW CREATE VIEW [view_name].




-------------------------------------------------- */




























