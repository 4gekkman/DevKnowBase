/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
12. Синтаксис SQL - транзакции, составные выражения


  >




-------------------------------------------------- */












/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:
> Официальное руководство по SQL-синтаксису транзакций
      http://dev.mysql.com/doc/refman/5.6/en/sql-syntax-transactions.html

> Официальное руководство по SQL-синтаксису составных выражений
      http://dev.mysql.com/doc/refman/5.6/en/sql-syntax-compound-statements.html


*****************************************************
Оглавление:

Транзакции
  > Общая информация
  > Синтаксис для START TRANSACTION, COMMIT и ROLLBACK.
  > Выражения, которые не могут быть rolled back.
  > Выражения, которые вызывают неявный COMMIT
  > Синтаксис для SAVEPOINT, ROLLBACK TO SAVEPOINT, и RELEASE SAVEPOINT

Составные выражения
  > Общая информация
  > Синтаксис составного выражения BEGIN ... END
  > Использование меток (Labels) в составных выражениях
  > Синтаксис для DECLARE
  > Переменные в сохраняемых программах
  > Выражения для управления потоком (циклы, условия и т.д.)
    > Общая информация
    > CASE                 | аналог switch в PHP
    > IF                   | аналог if в PHP
    > ITERATE              | аналог continue в PHP
    > LEAVE                | анало break в PHP
    > LOOP                 | цикл, который можно прекратить с помощью LEAVE или RETURN.
    > REPEAT ... UNTIL     | аналог do ... while в PHP.
    > RETURN               | завершает работу сохраняемой функции и возвращает указанное значение.
    > WHILE                | аналог while в PHP


*****************************************************


##########
Транзакции

> Общая информация
  > MySQL поддерживает локальные транзакции (в пределах данной клиентской сессии) с помощью
    следующих операций:
      SET autocommit, START TRANSACTION, COMMIT и ROLLBACK.

> Синтаксис для START TRANSACTION, COMMIT и ROLLBACK.
  > Следующие операции используются для работы с транзакциями:
    > START TRANSACTION или BEGIN    | начать новую транзакцию
    > COMMIT                         | завершить транзакцию, сделать ее изменения постоянными
    > ROLLBACK                       | отменить все изменения, сделанные в текущей транзакции
    > SET autocommit                 | вкл/выкл режим автозавершения транзакций (включен по умолчанию)
  > SET autocommit
    > Это выражение позволяет вкл/выкл режим автозавершения транзакций.
    > Отключить autocommit для этой сессии: SET autocommit=0;  Включить: SET autocommit=1;
      > Чтобы отключить autocommit на постоянной основе, требуется изменить соответствующую
        сессионную переменную в конфигурационном файле сервера my.ini.
    > Если autocommit отключен, то для применения внесенных изменений требуется ввести COMMIT,
      а для их отмены - ROLLBACK.
    > По умолчанию autocommit включен. Это значит, что как только исполняется выражение,
      которое изменяет таблицу, MySQL сразу сохраняет эти измеения на постоянной основе.
      Т.Е. автоматически делает commit. И после этого изменения нельзя откатить назад (сделать rollback).
    > Неявно отключить autocommit для определенной последовательности выражений можно с помощью
      START TRANSACTION.
      > Например. Для выражений из примера ниже, заключенных между START TRANSACTION и COMMIT,
                  autocommit неявно отключен.
          START TRANSACTION;
            SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
            UPDATE table2 SET summary=@A WHERE type=1;
          COMMIT;

  > START TRANSACTION
    > Это выражение одновременно делает 3 вещи:
      > Отключает autocommit до следующего выражения COMMIT.
      > Начинает новую транзакцию.
      > Делает COMMIT для текущей незавершенной транзакции (если есть).
    > Допускает ряд атрибутов, управляющих некоторыми свойствами транзакции:
      > WITH CONSISTENT SNAPSHOT
        > Только для INNODB.
        > Этот атрибут говорит, что в этой временной точке INNODB делает снепшот базы данных,
          и обращающиеся к ней запросы читают данные из этого снепшота до окончания транзакции.
        > Не меняет уровень изоляции. Поддерживает только уровень изоляции REPEATABLE READ.
      > Режим работы транзакции:
        > Можно выбрать только один из них.
        > Доступны 2 режима:
          > READ ONLY
            > Запрещает транзакции менять таблицы, которые видны другим транзакциям.
              При этом транзакция может изменять или блокировать временные таблицы.
          > READ WRITE (по умолчанию)
            > Если системная переменная read_only включена, то явный запуск транзакции
              с помощью START TRANSACTION READ WRITE требует SUPER-права.
  > Синтаксис:
            START TRANSACTION
                [transaction_characteristic [, transaction_characteristic] ...]

            transaction_characteristic:
                WITH CONSISTENT SNAPSHOT
              | READ WRITE
              | READ ONLY

            BEGIN [WORK]
            COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
            ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
            SET autocommit = {0 | 1}

> Выражения, которые не могут быть rolled back.
  > Для некоторых выражений нельзя совершить откат (ROLLBACK). Это DDL-выражения - CREATE, ALTER, DROP.
    Поэтому надо так проектировать транзакции, чтобы они не включали таких выражений. Потому что
    нельзя будет совершить полноценный откат транзакции для последовательности операций,
    содержащих указанные выше.

> Выражения, которые вызывают неявный COMMIT
  > Полный список см. по ссылке:
      http://dev.mysql.com/doc/refman/5.6/en/implicit-commit.html

> Синтаксис для SAVEPOINT, ROLLBACK TO SAVEPOINT, и RELEASE SAVEPOINT
  > SAVEPOINT identifier
    > Создать новую безопасную точку транзакции, имеющую имя identifier. Если уже есть безопасная
      точка с таким именем, то старая удаляется, и заменяется новой.
    > Используется во время проведения транзакции.
  > ROLLBACK TO [SAVEPOINT] identifier
    > Откатывает (rollback) состояние текущей транзакции к состоянию, сохраненному в
      безопасной точке с именем identifier.
    > При этом текущая транзакция не уничтожается, а продолжается.
    > Безопасные точки, созданные после безопасной точки identifier - удаляются.
  > RELEASE SAVEPOINT identifier
    > Удаляет безопасную точку с именем identifier.
    > Все безопасные точки текущей транзакции удаляются после завершения транзакции
      операцией COMMIT, или после операции ROLLBACK без каких либо атрибутов.
  > Синтаксис:
        SAVEPOINT identifier
        ROLLBACK [WORK] TO [SAVEPOINT] identifier
        RELEASE SAVEPOINT identifier


###################
Составные выражения

> Общая информация
  > Здесь будет описан синтаксис составного выражения BEGIN ... END, а также других выражений,
    которые могут бить использованы в теле сохраняемых программ - процедур, функций, триггеров
    и событий.
  > Составное выражение - это блок, который может содержать другие блоки, переменные,
    обработчики событий, курсоры, циклы, условия.

> Синтаксис составного выражения BEGIN ... END
  > Синтаксис BEGIN ... END используется для написания составного выражения, которое может
    быть использовано в сохраняемых программах (процедурах, функциях, триггерах и событиях).
  > Составное выражение может содержать много выражений, заключенных между ключевыми словами
    BEGIN ... END.
  > statement_list
    > Представляет собой список из 1-го или более выражений, разделенных между собой
      точкой с запятой ;
      > Использование такого разделителя вызывает проблемы при исполнении такого составного
        выражения в клиентских программах вроде mysql shell, где точка с запятой ; используется
        в качестве знака завершения выражения и отправки его на сервер для исполнения. В таких
        клиентах перед выполнением составного выражения требуется сменить delimiter на другой.
        Например, в mysql shell, чтобы сменить delimiter на символ @, надо написать:  \d @
    > Может быть пустым.
    > Может быть помечен (labeled).
  > Синтаксис:
        [begin_label:] BEGIN
            [statement_list]
        END [end_label]

> Использование меток (Labels) в составных выражениях
  > Метки можно использовать в следующих выражениях:
      BEGIN ... END, LOOP, REPEAT, WHILE.
  > Использование меток должно подчиняться следующим правилам:
    > После begin_label обязательно должно быть двоеточие :
    > begin_label не обязательно должен сопровождаться end_label. Но если все же end_label
      присутствует, то она должна быть той же, что и begin_label.
    > Не может быть end_label без begin_label.
    > Метки на одном и том же уровне вложенности должны быть уникальны.
    > MAX длина метки 16 символов.
  > ITERATE, LEAVE
    > Для ссылки на метки в пределах помеченной конструкции, использовать
      выражения ITERATE или LEAVE.
    > Пример, в котором ITERATE или LEAVE используются для продолжения итерирования в цикле,
      и для выхода из цикла:
          CREATE PROCEDURE doiterate(p1 INT)
          BEGIN
            label1: LOOP
              SET p1 = p1 + 1;
              IF p1 < 10 THEN ITERATE label1; END IF;
              LEAVE label1;
            END LOOP label1;
          END;
  > Синтаксис:
        [begin_label:] BEGIN
            [statement_list]
        END [end_label]

        [begin_label:] LOOP
            statement_list
        END LOOP [end_label]

        [begin_label:] REPEAT
            statement_list
        UNTIL search_condition
        END REPEAT [end_label]

        [begin_label:] WHILE search_condition DO
            statement_list
        END WHILE [end_label]

> Синтаксис для DECLARE
  > DECLARE используют для определения локальных переменных, условий, обработчиков и курсоров.
  > Его разрешено использовать только внутри составного выражения BEGIN ... END.
  > Все DECLARE должны быть в начале составного выражения, до других выражений.
  > DECLARE должны идти в определенном порядке:
    > Объявление локальных переменных и условий должны идти первыми, до объявления
      курсоров и обработчиков.
    > Курсоры должны идти до обработчиков.

> Переменные в сохраняемых программах
  > Общая информация
    > В сохраняемых программах, как и во вне их, можно использовать системные переменные, и
      переменные, определенные пользователем.
    > Кроме того, сохраняемые программы могут использовать DECLARE для определения локальных
      переменных.
    > Значения переменных могут быть заданы с помощью операции SET.
    > Результаты запросов могут быть сохранены в локальных переменных, используя синтаксис
      SELECT ... INTO var_list. Или с использованием курсоров и синтаксиса FETCH ... INTO var_list.
    > Запрещено присваивать значение DEFAULT локальным переменным или параметрам сохраняемых
      процедур и функций.
  > Синтаксис DECLARE для локальных переменных
    > Синтаксис:
        DECLARE var_name [, var_name] ... type [DEFAULT value]
    > Это выражение определяет локальные переменные с сохраняемых программах.
    > Атрибут DEFAULT
      > Чтобы назначить DEFAULT в качестве значения переменной, использовать атрибут DEFAULT.
      > Если атрибут DEFAULT не присутствует, то свежесозданной локальной переменной присваивается
        значение NULL.
    > Значение может быть определено, как выражение, а не обязательно как литерал.
    > Имена локальных переменных регистронезависимы.
    > Область видимости локальных переменных - это блок BEGIN ... END, в котором они определены.
      > На них также можно ссылаться из блоков, находящихся внутри этого блока. Кроме тех блоков,
        где определены свои локальные переменные с теми же именами.
  > Область видимости и разрешение локальных переменных
    > Область видимости локальных переменных - это блок BEGIN ... END, в котором они определены.
      > На них также можно ссылаться из блоков, находящихся внутри этого блока. Кроме тех блоков,
        где определены свои локальные переменные с теми же именами.
    > Ссылаться на локальные переменные запрещено из подготовленных выражений, поскольку они
      существуют только во время выполнения соответствующей сохраняемой программы.
    > Локальная переменная не должна иметь имя, совпадающее с именем какой-нибудь колонки.

> Выражения для управления потоком (циклы, условия и т.д.)
  > Общая информация:
    > MySQL поддерживает следующие конструкции для управления потоком в сохраняемых программах:
      IF, CASE, ITERATE, LEAVE, LOOP, WHILE, REPEAT и RETURN (в сохраняемых функциях).
    > Многие из этих конструкций могут быть вложены друг в друга (как обычно).
    > MySQL не поддерживает циклы FOR.

  > CASE
    > case_value
      > Это выражение.
      > Оно сравнивается с каждым when_value в каждом WHEN.
      > Когда сравнение возвращает TRUE, выполняется statement_list из THEN.
      > Если все сравнения дали FALSE, выполняется statement_list из ELSE.
    > CASE не может быть использован для тестирования на равенство значению NULL,
      потому что NULL = NULL это FALSE.
    > Для второго синтаксиса, проверяется на true/false каждое search_condition.
      > Если TRUE, то выполняется statement_list из THEN.
      > Если все FALSE, то выполняется statement_list из ELSE.
    > Если везде FALSE, и выражение не содержит блока ELSE, то будет error.
    > Пример:
          CREATE PROCEDURE p()
            BEGIN
              DECLARE v INT DEFAULT 1;

              CASE v
                WHEN 2 THEN SELECT v;
                WHEN 3 THEN SELECT 0;
                ELSE
                  BEGIN
                  END;
              END CASE;
            END;
    > Синтаксис:
          CASE case_value
              WHEN when_value THEN statement_list
              [WHEN when_value THEN statement_list] ...
              [ELSE statement_list]
          END CASE
      Or:
          CASE
              WHEN search_condition THEN statement_list
              [WHEN search_condition THEN statement_list] ...
              [ELSE statement_list]
          END CASE

  > IF
    > Еще есть функция IF(), которая представляет не одно и то же, что IF.
    > Выражение IF может иметь атрибуты:
        THEN, ELSE, ELSEIF, и заканчивается END IF.
    > search_condition
      > Выражение, сравнивается с TRUE.
    > statement_list
      > Если search_condition = TRUE, то выполняются выражения из statement_list.
    > Пример:
          CREATE FUNCTION SimpleCompare(n INT, m INT)
            RETURNS VARCHAR(20)

            BEGIN
              DECLARE s VARCHAR(20);

              IF n > m THEN SET s = '>';
              ELSEIF n = m THEN SET s = '=';
              ELSE SET s = '<';
              END IF;

              SET s = CONCAT(n, ' ', s, ' ', m);

              RETURN s;
            END;
    > Синтаксис:
          IF search_condition THEN statement_list
              [ELSEIF search_condition THEN statement_list] ...
              [ELSE statement_list]
          END IF

  > ITERATE
    > Может возникать только в выражениях LOOP, REPEAT и WHILE.
    > Означает буквально: "запустить цикл снова".
    > Пример см. выше в пункте "Использование меток (Labels) в составных выражениях".
    > Синтаксис:
        ITERATE label

  > LEAVE
    > Может быть использован в BEGIN ... END, либо в конструкциях цикла: LOOP, REPEAT, WHILE.
    > Используется для выхода из меченой конструкции.
    > Если используется для выхода из самого внешнего блока BEGIN ... END сохраняемой программы,
      то происходит выход из программы.
    > Пример см. выше в пункте "Использование меток (Labels) в составных выражениях".
    > Синтаксис:
        LEAVE label

  > LOOP
    > Представляет простую конструкцию для организации цикла, позволяющую сделать повторное
      выполнение составного выражения, которое состоит из 1-го или нескольких выражений,
      разделенных точкой с запятой ; . Выражение в цикле повторяются до тех пор, пока
      цикл не будет прекращен.
      > Прекратить цикл можно:
        > С помощью LEAVE.
        > В сохраняемых функциях, с помощью RETURN.
      > Если цикл не прекратить, то будет бесконечный цикл.
    > Пример:
          CREATE PROCEDURE doiterate(p1 INT)
          BEGIN
            label1: LOOP
              SET p1 = p1 + 1;
              IF p1 < 10 THEN
                ITERATE label1;
              END IF;
              LEAVE label1;
            END LOOP label1;
            SET @x = p1;
          END;
    > Синтаксис:
        [begin_label:] LOOP
            statement_list
        END LOOP [end_label]

  > REPEAT ... UNTIL
    > Составное выражение statement_list повторяется до тех пор, пока search_condition = TRUE
    > Это аналог do ... while в PHP.
    > Всегда выполнятся минимум 1 раз.
    > Пример:
          CREATE PROCEDURE dorepeat(p1 INT)
               BEGIN
                 SET @x = 0;
                 REPEAT
                   SET @x = @x + 1;
                 UNTIL @x > p1 END REPEAT;
               END;
    > Синтаксис:
        [begin_label:] REPEAT
            statement_list
        UNTIL search_condition
        END REPEAT [end_label]

  > RETURN
    > Это выражение для завершения выполнения сохраняемой фунции.
    > Оно возвращает результат выражения expr тому, кто вызвал данную функцию.
    > У сохраняемой функции должен быть минимум 1 RETURN.
    > Не используется в сохраняемых процедурах, триггерах или событиях. Для них есть
      выражение LEAVE.
    > Синтаксис:
        RETURN expr

  > WHILE
    > Этот цикл повторяет выполнение составного выражения statement_list до тех пор, пока
      statement_list = TRUE.
    > В отличие от REPEAT, может ни разу не сработать, если условие будет = FALSE.
    > Пример:
          CREATE PROCEDURE dowhile()
          BEGIN
            DECLARE v1 INT DEFAULT 5;

            WHILE v1 > 0 DO
              ...
              SET v1 = v1 - 1;
            END WHILE;
          END;
    > Синтаксис:
        [begin_label:] WHILE search_condition DO
            statement_list
        END WHILE [end_label]



-------------------------------------------------- */

















