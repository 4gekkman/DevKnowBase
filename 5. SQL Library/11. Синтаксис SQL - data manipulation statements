/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
11. Синтаксис SQL - data manipulation statements

Выражения для манипулирования данными
  > CALL                    | выполняет сохраняемую процедуру
  > DELETE                  | удаляет строки из таблицы
  > DO                      | аналог SELECT, только не возвращает результат
  > HANDLER                 | обеспечивает прямой доступ к интерфейсу движка, только INNODB и MyISAM
  > INSERT                  | вставляет строки в таблицу
  > LOAD DATE INFILE        | записывает строки из файла в таблицу
  > LOAD XML                | записывает строки из XML файла в таблицу
  > REPLACE                 | аналог INSERT, только заменяет совпавшие по первичному или уникальному ключу строки
  > SELECT                  | извлекает строки из 1-й или нескольких таблиц
  > UPDATE                  | обновляет значения указанных столбцов
  > Синтаксис подзапросов   | здесь описан синтаксис подзапросов




-------------------------------------------------- */



-- CALL                    | выполняет сохраняемую процедуру
                    /*
                            CALL sp_name([parameter[,...]])
                            CALL sp_name[()]
                     */

  -- Пример работы с CALL и OUT/INOUT параметрами
    # Сначала создать процедуру c OUT/INOUT параметрами (не забыть сменить delimiter)
      CREATE PROCEDURE procedur (OUT ver_param VARCHAR(25), INOUT incr_param INT)
        BEGIN
        # Установить значение OUT-параметра
          SELECT VERSION() INTO ver_param;
        # Увеличить значение INOUT-параметра на 1
          SET incr_param = incr_param + 1;
        END;
    # Объявить пользовательский параметр (который передадим в кач-ве INOUT параметра в процедуру)
      SET @increment = 10;
    # Выполнить процедуру, посмотреть значения параметров
      CALL procedur(@version, @increment);
      SELECT @version, @increment;

-- DELETE                  | удаляет строки из таблицы
                      /*
                          # Синтаксис для удаления из 1-й таблицы
                            DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name
                                [PARTITION (partition_name,...)]
                                [WHERE where_condition]
                                [ORDER BY ...]
                                [LIMIT row_count]
                          # Синтаксис для удаления из нескольких таблиц
                            DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
                                tbl_name[.*] [, tbl_name[.*]] ...
                                (FROM table_references  |  USING table_references)
                                [WHERE where_condition]
                       */

  -- Демонстрация удаления строки c MAX значением в столбце с AUTO_INCREMENT
  -- (при вставке следующего значения, удаленное значение из AUTO_INCREMENT пропускается)
    # Создать таблицу со столбцом с AUTO_INCREMENT
      CREATE TABLE IF NOT EXISTS table100 (col1 INT AUTO_INCREMENT KEY, col2 INT);
    # Вставить в таблицу 3 строки
      INSERT INTO table100 VALUES
        (NULL,100),(NULL,200),(NULL,300);
    # Удалить строку с col1 == 3
      DELETE FROM table100 WHERE col1 = 3;
    # Добавить еще одну строку в конец
      INSERT INTO table100 VALUE (NULL,400);
    # Посмотреть результат
      SELECT * FROM table100;  -- Значения в столбце col1:   1, 2, 4

  -- Удаление строк с использованием DELETE, WHERE, ORDER BY и LIMIT
    # Создать таблицу с 2-мя строками
      CREATE TABLE IF NOT EXISTS table101 (col1 VARCHAR(50), col2 INT);
    # Вставить в таблицу 5 строк
      INSERT INTO table101 VALUES
      ('Иван',100),('Петр',200),('Иван',300),('Петр',400),('Иван',500);
    # Найти строки, в которых col1 = 'Иван', и удалить последние 2 из них (т.е. те, в которых 300 и 500).
      DELETE FROM table101 WHERE col1 = 'Иван' ORDER BY col2 DESC LIMIT 2;
    # Посмотреть результат
      SELECT * FROM table101;  -- Остались строки с col2:  100, 200, 400

  -- Удаление из многих таблиц в одной DELETE-операции
    # Создать 3 таблицы
      CREATE TABLE IF NOT EXISTS table102 (col1 VARCHAR(30), col2 INT);
      CREATE TABLE IF NOT EXISTS table103 (col1 VARCHAR(30), col2 INT);
      CREATE TABLE IF NOT EXISTS table104 (col1 VARCHAR(30), col2 INT);
    # Загрузить в эти 2 таблицы по 3 строки данных
      INSERT INTO table102 VALUES ('Иван',1),('Петр',2),('Гриша',3);
      INSERT INTO table103 VALUES ('Иван',10),('Петр',20),('Гриша',30);
      INSERT INTO table104 VALUES ('Иван',100),('Петр',200),('Гриша',300);
    # Искать во всех 3-х таблицах "Иванов" и "Гриш", но удалить их только из table102 и table103.
      #?


-- DO                      | аналог SELECT, только не возвращает результат
                          /*
                          DO expr [, expr] ...
                           */


-- HANDLER                 | обеспечивает прямой доступ к интерфейсу движка, только INNODB и MyISAM
                          /*
                          HANDLER tbl_name OPEN [ [AS] alias]

                          HANDLER tbl_name READ index_name { = | <= | >= | < | > } (value1,value2,...)
                              [ WHERE where_condition ] [LIMIT ... ]
                          HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }
                              [ WHERE where_condition ] [LIMIT ... ]
                          HANDLER tbl_name READ { FIRST | NEXT }
                              [ WHERE where_condition ] [LIMIT ... ]

                          HANDLER tbl_name CLOSE
                           */

-- INSERT                  | вставляет строки в таблицу
                          /*
                                INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
                                    [INTO] tbl_name
                                    [PARTITION (partition_name,...)]
                                    [(col_name,...)]
                                    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
                                    [ ON DUPLICATE KEY UPDATE
                                      col_name=expr
                                        [, col_name=expr] ... ]
                            ...или...
                                INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
                                    [INTO] tbl_name
                                    [PARTITION (partition_name,...)]
                                    SET col_name={expr | DEFAULT}, ...
                                    [ ON DUPLICATE KEY UPDATE
                                      col_name=expr
                                        [, col_name=expr] ... ]
                            ...или...
                                INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
                                    [INTO] tbl_name
                                    [PARTITION (partition_name,...)]
                                    [(col_name,...)]
                                    SELECT ...
                                    [ ON DUPLICATE KEY UPDATE
                                      col_name=expr
                                        [, col_name=expr] ... ]
                           */








-- LOAD DATE INFILE        | записывает строки из файла в таблицу
                          /*
                          LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name'
                              [REPLACE | IGNORE]
                              INTO TABLE tbl_name
                              [PARTITION (partition_name,...)]
                              [CHARACTER SET charset_name]
                              [{FIELDS | COLUMNS}
                                  [TERMINATED BY 'string']
                                  [[OPTIONALLY] ENCLOSED BY 'char']
                                  [ESCAPED BY 'char']
                              ]
                              [LINES
                                  [STARTING BY 'string']
                                  [TERMINATED BY 'string']
                              ]
                              [IGNORE number {LINES | ROWS}]
                              [(col_name_or_user_var,...)]
                              [SET col_name = expr,...]
                           */

-- LOAD XML                | записывает строки из XML файла в таблицу


-- REPLACE                 | аналог INSERT, только заменяет совпавшие по первичному или уникальному ключу строки
/*
                            REPLACE [LOW_PRIORITY | DELAYED]
                                [INTO] tbl_name
                                [PARTITION (partition_name,...)]
                                [(col_name,...)]
                                {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
                            Or:

                            REPLACE [LOW_PRIORITY | DELAYED]
                                [INTO] tbl_name
                                [PARTITION (partition_name,...)]
                                SET col_name={expr | DEFAULT}, ...
                            Or:

                            REPLACE [LOW_PRIORITY | DELAYED]
                                [INTO] tbl_name
                                [PARTITION (partition_name,...)]
                                [(col_name,...)]
                                SELECT ...
 */

-- SELECT                  | извлекает строки из 1-й или нескольких таблиц
                          /*
                              SELECT
                                  [ALL | DISTINCT | DISTINCTROW ]
                                    [HIGH_PRIORITY]
                                    [STRAIGHT_JOIN]
                                    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
                                    [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
                                  select_expr [, select_expr ...]
                                  [FROM table_references
                                    [PARTITION partition_list]
                                  [WHERE where_condition]
                                  [GROUP BY {col_name | expr | position}
                                    [ASC | DESC], ... [WITH ROLLUP]]
                                  [HAVING where_condition]
                                  [ORDER BY {col_name | expr | position}
                                    [ASC | DESC], ...]
                                  [LIMIT {[offset,] row_count | row_count OFFSET offset}]
                                  [PROCEDURE procedure_name(argument_list)]
                                  [INTO OUTFILE 'file_name'
                                      [CHARACTER SET charset_name]
                                      export_options
                                    | INTO DUMPFILE 'file_name'
                                    | INTO var_name [, var_name]]
                                  [FOR UPDATE | LOCK IN SHARE MODE]]
                           */

-- UPDATE                  | обновляет значения указанных столбцов
/*
                          Single-table syntax:
                            UPDATE [LOW_PRIORITY] [IGNORE] table_reference
                                SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
                                [WHERE where_condition]
                                [ORDER BY ...]
                                [LIMIT row_count]
                          Multiple-table syntax:
                            UPDATE [LOW_PRIORITY] [IGNORE] table_references
                              SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
                              [WHERE where_condition]
 */



-- Синтаксис подзапросов   | здесь описан синтаксис подзапросов









/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальное руководство по синтаксису SQL-выражений - Data Manipulation Statement:
        http://dev.mysql.com/doc/refman/5.6/en/sql-syntax.html


*****************************************************
Оглавление:

Выражения для манипулирования данными
  > CALL                    | выполняет сохраняемую процедуру
  > DELETE                  | удаляет строки из таблицы
  > DO                      | аналог SELECT, только не возвращает результат
  > HANDLER                 | обеспечивает прямой доступ к интерфейсу движка, только INNODB и MyISAM
  > INSERT                  | вставляет строки в таблицу
  > LOAD DATE INFILE        | записывает строки из файла в таблицу
  > LOAD XML                | записывает строки из XML файла в таблицу
  > REPLACE                 | аналог INSERT, только заменяет совпавшие по первичному или уникальному ключу строки
  > SELECT                  | извлекает строки из 1-й или нескольких таблиц
  > UPDATE                  | обновляет значения указанных столбцов
  > Синтаксис подзапросов   | здесь описан синтаксис подзапросов


*****************************************************


> CALL                    | выполняет сохраняемую процедуру
  > Общая информация
    > Выражение CALL выполняет сохраняемую процедуру, которая была определена ранее выражением
      CREATE PROCEDURE.
    > Сохраняемая процедура у которой нет аргументов, не требует наличия скобок после своего имени.
      > Синтаксис для сохраняемой процедуры с параметрами:    CALL p()
      > Синтаксис для сохраняемой процедуры без параметров:   CALL p
    > Чтобы процедура в конце передала клиентской программе число затронутых ей строк, требуется
      в конце тела процедуры добавить функцию ROW_COUNT().
  > Права на использование
    >
  > Атрибуты и опции
    > sp_name
      > Имя вызываемой процедуры.
    > OUT и INOUT
      > Параметры, которые позволяет передавать в процедуру аргументы и изменять их в ней.
        > IN
          > Запускает параметр в процедуру. Внутри он может быть изменен, но снаружи
            никаких изменений видно не будет. Тоже самое, что передача по значению.
        > OUT
          > Передает параметр из процедуры. Его начальное значение == NULL.
        > INOUT
          > Тоже самое, что IN, только внесенные в этот параметр в процедуре изменения
            видны снаружи. Тоже самое, что передача по ссылке.
          > В процедуру передается пользовательская переменная (а если процедура вызывается из
            другой сохраненной процедуры, то можно передать её параметр или локальную переменную
            этого скрипта).
            > В случае передачи пользовательской переменной нужно сначала инициализировать ее
              операцией SET.
  > Сигнатура:
        CALL sp_name([parameter[,...]])
        CALL sp_name[()]

> DELETE                  | удаляет строки из таблицы
  > Общая информация
    > Это выражение удаляет строки из таблицы tbl_name, и возвращает кол-во удаленных строк.
    > Внимание! Если никаких условий в where_condition не задано, будут удалены ВСЕ строки!
    > Если требуется очистить всю таблицу и не требуется знать количество удаленных строк,
      то TRUNCATE TABLE - сработает быстрее. Но у него есть ряд ограничений (см. "8. Синтаксис SQL - DDS")
    > При удалении строки, содержащей MAX значение для столбца с AUTO_INCREMENT, это значение
      при добавлении следующей строки не используется (для INNODB и MyISAM).
    > При удалении большого количества строк из большой таблицы на движке INNODB, может быть
      превышено MAX доступное время блокировки. Чтобы решить эту проблему надо уменьшить время,
      в течение которого таблица заблокирована. Можно использовать следующий трюк:
      1. Извлечь строки, которые НЕ должны быть удалены, и поместить в другую пустую таблицу со
         структурой идентичной той, из которой надо было удалять строки.
          INSERT INTO t_copy SELECT * FROM t WHERE ... ;
      2. Использовать RENAME TABLE чтобы махнуть оригинал и копию именами.
          RENAME TABLE t TO t_old, t_copy TO t;
      3. Удалить оригинальную таблицу:
          DROP TABLE t_old;
    > Об удалении одновременно из нескольких таблиц:
      > Через запятую можно указать несколко имен таблиц tbl_name в выражении DELETE. В этом случае
        сервер будет искать строки в укзанных таблицах, совпадающие с выражением в атрибуте WHERE,
        и удалять их.
      > Нельзя использовать ORDER BY или LIMIT.
      > Отличие 1-го (без USING) и 2-го (с USING) синтаксиса:
        > Для синтаксиса без USING, удаляются совпадающие строки только из тех таблиц, которые
          перечислены перед FROM.
        > Для синтаксиса с USING, удаляются совпадающие строки только из тех таблиц, которые
          перечислены ПОСЛЕ FROM (входят в его значение).
      > Если попытаться удалить из нескольких таблиц, связанных родительско/дочерними связями
        индекса FOREIGN KEY, будет error. Вместо этого надо удалять только из 1-й таблицы, и
        положитсья на ON DELETE.
  > Права на использование
    > Требуются права DELETE и SELECT
  > Атрибуты и опции
    > WHERE where_condition
      > Условия в атрибуте WHERE указывают, какие именно строки удалять. Если никаких условий нет,
        то из таблицы будут удалены все строки.
      > Подробное описание where_condition смотри в описании SELECT'а.
    > ORDER BY
      > Этот атрибут обычно используют в связке с LIMIT, чтобы удалить "последние N строк" или
        "первые N строк". N указывают с помощью LIMIT, а порядок - с помощью ORDER BY.
      > ORDER BY указывает 2 вещи:
        > По какой строке производить сортировку.
        > Сортировать в возрастающем (ASC) или убывающем (DESC) порядке.
    > LIMIT row_count
      > Накладывает ограничение на кол-во строк, которые могут быть удалены.
      > Применяется к удалению из 1-й таблицы, а не на все таблицы сразу при удалении из многих.
    > LOW_PRIORITY
      > Если присутствует, то сервер откладывает выполнение DELETE-запроса до того момента, когда
        ни один другой клиент не будет считывать из этой таблицы. Это влияет только на таблицы,
        движки которых блокируют на уровне таблиц (MyISAM, MEMORY, MERGE).
    > IGNORE
      > Заставляет MySQL игнорировать ошибки, возникающие во время выполнения удаления строк
        (сюда не входит ошибки парсинга). Вместо ошибок возвращаются warning's.
  > Сигнатура: см. в примерах
      # Синтаксис для удаления из 1-й таблицы
        DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name
            [PARTITION (partition_name,...)]
            [WHERE where_condition]
            [ORDER BY ...]
            [LIMIT row_count]
      # Синтаксис для удаления из нескольких таблиц
        DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
            tbl_name[.*] [, tbl_name[.*]] ...
            (FROM table_references  |  USING table_references)
            [WHERE where_condition]

> DO                      | аналог SELECT, только не возвращает результат
  > Общая информация
    > Выполняет выражение, но не возвращает никаких результатов.
    > По сути, это практически полный аналог SELECT.
    > DO быстрее, чем SELECT.
    > DO полезен для использования преимущественно с функциями, имеющими сторонний эффект,
      такими как RELEASE_LOCK().
  > Права на использование
    >
  > Атрибуты и опции
    >
  > Сигнатура: см. в примерах
        DO expr [, expr] ...

> HANDLER                 | обеспечивает прямой доступ к интерфейсу движка, только INNODB и MyISAM
  > Общая информация
    > Только для INNODB и MyISAM.
    > Обеспечивает прямой доступ к интерфейсу движка.
    > Чтобы использовать HANDLER для ссылки на столбец таблицы с PRIMARY KEY, можно использовать
      имя 'PRIMARY' (обязательно в кавычках).
    > Есть несколько причин использовать интерфейс HANDLER вместо обычного SELECT:
      > HANDLER быстрее, чем SELECT.
      > HANDLER позволяет прочесывать базу данных так, как сложно (или даже невозможно) было
        бы сделать с помощью SELECT.
  > Права на использование
    >
  > Атрибуты и опции
    > HANDLER ... OPEN
      > Открывает таблицу, что делает ее доступной с помощью подзапросов HANDLER ... READ.
      > Не бедает снепшот таблицы, и не блокирует таблицу.
      > Этот табличный объект не доступен для других сессий, и не закрывается до тех пор,
        пока не будет вызван HANDLER ... CLOSE.
      > Если открыть таблицу, используя ее псевдоним, то для работой с ней в других HANDLER-выражениях
        надо использовать тоже пседоним.
    > HANDLER ... READ
      > 1-й синтаксис:
        > Извлекает строки, для которых указанный индек соответствует заданному (ым) значению
          (с помощью мат. знаков = | <= | >= | < | > ) и условиям из WHERE.
          > Если используется много-столбцовый индекс, то нужно указать значения value через запятую.
            > Можно указать значения либо для всех столбцов, составляющих индекс, либо для выбранного
              количества столбцов слева (нельзя пропускать столбцы с индексом, должны идти сплошняком).
      > 2-й синтаксис:
        > Извлекает строки из таблицы в порядке индекса у совпадающие с условиями из WHERE.
      > 3-й синтаксис:
        > Извлекает строки из таблицы в их натуральном порядке, и которые совпадают с условиями из WHERE.
        > Это рабоатет быстрее, чем HANDLER tbl_name READ index_name, когда требуется просканировать
          всю таблицу.
    > HANDLER ... CLOSE
      > Закрывает таблицу, которая была открыта с помощью HANDLER ... OPEN.
      >
      >

  > Сигнатура: см. в примерах
        HANDLER tbl_name OPEN [ [AS] alias]

   1    HANDLER tbl_name READ index_name { = | <= | >= | < | > } (value1,value2,...)
            [ WHERE where_condition ] [LIMIT ... ]
   2    HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }
            [ WHERE where_condition ] [LIMIT ... ]
   3    HANDLER tbl_name READ { FIRST | NEXT }
            [ WHERE where_condition ] [LIMIT ... ]

        HANDLER tbl_name CLOSE

> INSERT                  | вставляет строки в таблицу
  > Общая информация
    > Вставляет новые строки в существующую таблицу.
    > Несколько видов синтаксиса:
      > INSERT ... VALUES   | вставляет явно указанные в операции INSERT значения
      > INSERT ... SET      | вставляет явно указанные в операции INSERT значения
      > INSERT ... SELECT   | вставляет значения, выбранные из другой таблицы или таблиц
    > Вместо INSERT можно использовать REPLACE - чтобы перезаписать старые значения в столбцах
      с уникальным ключем новыми, если они дублируют друг друга.
      > INSERT - это двойник INSERT IGNORE.
    > Количество вставленных с помощью INSERT столбцов может быть получено с помощью функции  ROW_COUNT().
    > При использование синтаксиса INSERT ... VALUES с множественными списками значений в круглых скобках
      (а не с 1-м), или синтаксис INSERT ... SELECT, то выражение вернет информационную строку в след. формате:
        Records: 100 Duplicates: 0 Warnings: 0
      > Records
        > Кол-во строк, обработанных выражением. Это не обязательно количество строк, действительно
          вставленных, потому что Duplicates может не быть == 0.
      > Duplicates
        > Количество строк, которые не удалось вставить, потому что какие-то значения в них дублируют
          уже существующие в таблице значения в колонке с уникальным ключем.
      > Warnings
        > Указывает количество попыток вставить строку, которые по какой-то причине вызвали предупреждение.
        > Предупреждения могут возникать по следующим причинам:
          > Попытка вставить значение NULL в столбец, в определении которого есть атрибут NOT NULL.
            > При многострочной вставке:
              > Для синтаксисов INSERT ... VALUES или INSERT INTO ... SELECT, значение такой колонки будет
                установлено в неявное значение по умолчанию. Для числовых колонок это 0. Для строковых
                - это пустая строка '', для дата-временных колонок - это zero-value.
            > При однострочной вставке:
              > Просто возникает error.
          > Попытка вставить числовое значение, выходящее за диапазон типа этой колонки.
            Обрезается до ближайшего допустимого.
          > Попытка вставить значение типа '10.34 a' в числовой столбец.
            Записывается 10.34. Парсер сканирует значение слева направо до тех пор, пока упирается
            в нечисловое значение (точки не в счет). Число, которое он отсканировал, и записывается.
            > А для значения, например, 'f 10.34' будет вставлено число 0, потому что это значение
              начинается не с числа, и парсер на букве f и заканчивает сканирование.
          > Попытка вставить в столбец строкового типа строку, размер которой превышает максимально
            допустимый дли типа этого столбца.
            Строка будет обрезана справа до ближайшего допустимого размера.
          > Попытка вставить в столбец типа DATE или TIME значение, которое не допустимо для этого
            типа.
            Будет вставлено zero-value.
  > Права на использование
    > Требует INSERT-права.
    > Если используется атрибут ON DUPLICATE KEY UPDATE, то требует еще UPDATE-права.
    > Также требует SELECT-права для колонок, которые просто считываются.
  > Атрибуты и опции
    > IGNORE
      > Двойник REPLACE (см. описание выше)
    > tbl_name
      > Имя таблицы, в которую должны быть вставлены новые строки.
    > [(col_name,...)]
      > Список имен столбцов через запятую, в которые надо вставить значения.
      > Список можно опустить, но тогда значения надо будет вставлять во все столбцы.
        > Чтобы узнать порядок столбцов в таблице, можно воспользоваться выражением
          DESCRIBE tbl_name.
    > {VALUES | VALUE} ({expr | DEFAULT},...),(...),..
      > Значения для вставки могут быть даны несколькими способами:
        > Неявная установка DEFAULT-значения.
          > Если strict mode включен:
            > Для столбцов, которым явно не присваивается никакое значение, ставится
              их DEFAULT-значение.
              > Например, если в [(col_name,...)] указать не все столбцы таблицы, то не указанным
                столбцам будут присвоены при вставке значения по умолчанию.
          > Если strict mode включен:
            > То будет error.
        > Явная установка DEFAULT-значения:
          > С помощью ключевого слова DEFAULT можно явно установить значение колонки по умолчанию.
          > Это облегчает вставку строк - можно в те столбцы, в которые не требуется вставлять
            какие-то специфические значения, вставлять ключевое слово DEFAULT.
            Если бы такой возможности небыло, то пришлось бы выписывать и использовать список
            имен колонок, в которые требутеся вставить значение, а в остальные колонки значения
            по умолчанию бы вставились не явно (как описано в пункте выше).
        > Неявная установка DEFAULT-значения в случае, когда список колонок и список значений пусты.
          > Если список колонок и список значений пусты, то сервер создает строку, в которой каждой
            колонке присваивается её DEFAULT-значение. Пример синтаксиса:
              INSERT INTO tbl_name () VALUES();
            > Если strict mode в системной переменной sql_mode включен, и какой-нибудь из столбцов
              не имеет DEFAULT-значения, то будет error.
        > Установка выражения expr в качестве значения колонки.
          > В качестве значения колонки можно установить выражения expr.
          > Если тип результата expr не совпадает с типом колонки, то тип результата будет приведен
            к типу колонки.
            > Однако, в зависимости от типа колонки, результат приведения результата может оказаться
              разным. Например, произойдет следующее приведение строки '1999.0e-2' при её вставке
              в колонки типов INT, FLOAT, DECIMAL(10,6), YEAR соответственно:
                1999,  19.9921,  19.992100,  1999.
          > Выражение expr может ссылаться на значения колонок, установленные в списке значений
            колонок до (слева) вот этой данной колонки, значение которой устанавливается как expr.
            > В этом примере значение для колонки col2 устанавливается равным значению колонки
              col1, умноженному на 2:
                INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);
            > Но! При установке значения колонке с помощью expr, оно не может ссылаться на занчения
              колонок, устанавливаемые в этом же списке значений, которые находятся справа от нее.
              Например, следующее выражение не верно, и вызовает error:
                INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);
            > Кроме того, есть исключение, касающееся колонок с AUTO_INCREMENT.
              > Значение в такую колонку автоматически генерируется после того, как всем остальным
                колонкам присвоено значение. Поэтому если сослаться на такую колонку, то значение
                всегда будет 0.
      > Использование INSERT с атрибутом VALUES позволяет вставить не 1-ну (как при использование
        атрибута VALUE), а несколько строк.
        > Например:     INSERT INTO tbl_name (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9);
        > Значения для каждой строки должны быть разделены запятыми, и окружены круглыми скобками.
        > Количество значений внутри скобок должно совпадать с количеством перечесленных после
          tbl_name столбцов.
    > DELAYED
      > Если используется, сервер кладет строки, которые требуется вставить, в буфер,
        и клиент, который выполнил операцию INSERT DELAYED может продолжать работу
        мгновенно (а не ждать, пока вставятся все строки). Когда таблица освободилась,
        сервер начинает вставлять в нее эти строки, поглядывая периодически, не занята
        ли снова таблица. Если занята, то вставка приостанавливается, пока таблица не
        освободится.
      > Атрибут DELAYED игнорируется:
        > При использовании с синтаксисом
            INSERT ... SELECT или INSERT ... ON DUPLICATE KEY UPDATE.
        > При использовании INSERT DELAYED либо внутри тела функции или триггера, либо
          при использовании функций или триггеров внутри выражения INSERT.
    > LOW_PRIORITY
      > Только для движков MEMORY и MERGE. Плюс ограниченно в MyISAM.
      > Если используется, то выполнение операции INSERT откладывается до тех пор, пока
        другие клиенты читают из этой таблиы.
      > Опасный атрибут, потому что в высоконагруженной среде исполнение этого выражения может
        быть отложено на очень длительный период, вплоть до бесконечности.
    > IGNORE
      > См. описание выше в общей информации.
    > ON DUPLICATE KEY UPDATE
      > Это противоположность IGNORE. Если при вставке новой строки какое-нибудь ее значение
        дублирует значение столбца с уникальным ключем, то старое значение перезаписывается новым.
  > Подробнее о синтаксисе INSERT ... SELECT
    > Этот синтаксис позволяет вставить в таблице строки из 1-й или нескольких других таблиц.
    > Атрибут DELAYED игноритуется.
    > Таблица, из которой надо взять строки для вставки, вместе с условиями, может быть
      записана в выражении FROM ... WHERE, которое идет после SELECT. Например:
        INSERT INTO tbl_temp2 (fld_id)
          SELECT tbl_temp1.fld_order_id
          FROM tbl_temp1 WHERE tbl_temp1.fld_order_id > 100;
      > Внимание! Нельзя брать строки из таблицы и вставлять их в эту же таблицу в подзапросе.
    > Колонка с AUTO_INCREMENT работает как обычно.
    > Запрещены одновременные (конкурентные) вставки с помощью операции INSERT ... SELECT.
    > Чтобы избежать двусмысленности при операциях SELECT и INSERT на одной и той же таблице,
      используйте для имен таблиц и столбцов псевдонимы.
    > Синтаксисы INSERT ... SELECT ON DUPLICATE KEY UPDATE и INSERT IGNORE ... SELECT помечены,
      как не безопасные для основанной на выражениях репликации.
  > Сигнатура: см. в примерах
                    INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
                        [INTO] tbl_name
                        [PARTITION (partition_name,...)]
                        [(col_name,...)]
                        {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
                        [ ON DUPLICATE KEY UPDATE
                          col_name=expr
                            [, col_name=expr] ... ]
                ...или...
                    INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
                        [INTO] tbl_name
                        [PARTITION (partition_name,...)]
                        SET col_name={expr | DEFAULT}, ...
                        [ ON DUPLICATE KEY UPDATE
                          col_name=expr
                            [, col_name=expr] ... ]
                ...или...
                    INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
                        [INTO] tbl_name
                        [PARTITION (partition_name,...)]
                        [(col_name,...)]
                        SELECT ...
                        [ ON DUPLICATE KEY UPDATE
                          col_name=expr
                            [, col_name=expr] ... ]


> LOAD DATE INFILE        | записывает строки из файла в таблицу
  > Общая информация
    > Выражение читает строки из текстового файла, и записывает их в таблицу.
      > В противоположность, синтаксис SELECT ... INTO OUTFILE делает противоположное -
        читает строки из таблицы из аписывает из в текстовый файл (см. раздел о SELECT).
      > Синтаксис атрибутов FIELDS и LINES одинаковый и для передачи строк "файл -> таблица",
        и для передачи "таблица -> файл".
  > Права на использование
    > Требуются FILE-права.
  > Атрибуты и опции
    > file_name
      > Имя файла, из которого производится закачка строк в таблицу. Это должен быть простой литерал,
        а не результат какого-то выражения.
    > CHARACTER SET
      > В операции LOAD DATE INFILE ко входящей из файла информации применяется character set
        базы данных (см. системную переменную character_set_database ) таблицы, в которую
        закачиваются строки из файла.
        > Атрибут SET NAMES и character set клиентской программы (см. character_set_client)
          никак не влияют на интерпретацию входящей информации.
        > Если character set данных в файле отличается от character set базы данных, то следует
          в атрибуте CHARACTER SET явно указать кодировку данных в файле, чтобы сервер мог корректно
          выполнить преобразование.
        > Невозможно загрузить информацию из файлов, использующих кодировки ucs2, utf16, utf16le, utf32.
    > LOW_PRIORITY
      > Только для движков MEMORY и MERGE. Плюс ограниченно в MyISAM.
      > Если используется, то выполнение операции INSERT откладывается до тех пор, пока
        другие клиенты читают из этой таблиы.
      > Опасный атрибут, потому что в высоконагруженной среде исполнение этого выражения может
        быть отложено на очень длительный период, вплоть до бесконечности.
    > CONCURRENT
      > Для таблиц на движке MyISAM.
      > Другие потоки могут извлекать данные из таблицы, в которую закачиваются строки из файла
        с помощью выражения LOAD DATA (одновременно).
    > LOCAL
      > Работает, если на сервере разрешено его использование (см. опцию  --local-infile)
      > Использование LOCAL - немного медленнее, чем его НЕ использование. Ведь с LOCAL файл
        считывается клиентом, и должен пройти через соединение между ним и сервером. А без LOCAL
        файл сразу считывается сервером.
      > LOCAL влияет на то, где сервер ожидает найти файл с данными:
        > Если LOCAL указан:
          > Файл должен находится на машине, с которой запущен клиент. Он читает файл, и отправляет
            на сервер. Адрес файла может быть как абсолютным, так и относительным адресом
            на локальной машине. Если адрес относительный, то он интерпретируется относительно
            папки, из которой запущен клиент.
          > При выполнении LOAD DATA с атрибутом LOCAL копия файла создается во временной директории
            операционнйо системы (для windows: C:\WINDOWS\TEMP). Если для этого не хватит места,
            то выражение может потерпеть неудачу.
        > Если LOCAL не указан:
          > Файл должен находитсья на машине, на которой запущен сервер MySQL:
            > Если указан абсолютный путь к файлу, сервер использует его как есть.
            > Если указан относительный путь к файлу, состоящий из нескольких компонент,
              то поиск происходит относительно папки с данными - "data" - сервера.
              > Например: "folder1/file.txt"
            > Если указан относительный путь из 1-й компоненты, то сервер ищет файл в директории
              базы данных, установленной на данный момент по умолчанию.
              > Например: "file.txt"
      > LOCAL также влияет на обработку ошибок:
        > В выражении LOAD DATA INFILE (без LOCAL) ошибки типа "data-interpretation" и
          "duplicate-key" прекращают операцию.
        > В выражении LOAD DATA LOCAL INFILE (с LOCAL) вышеуказанные ошибки вызывают warning,
          но операция продолжается, потому что сервер не может остановить передачу в середине операции.
          Для ошибок типа "duplicate-key" это тоже самое, как если бы был указан атрибут IGNORE.
    > IGNORE и REPLACE
      > Управляет ситуацией, в которой вставляеая строка имеет в одном из своих столбцов значение,
        дублирующее существующее значение в соответствующем столбце таблицы, в которую проводится
        вставка новых строк, имеющем ограничение на уникальность ключа UNIQUE KEY (PRIMARY KEY тоже
        является одновременно и UNIQUE KEY'ем).
      > Если указано IGNORE, или если INGORE не указано, но указано LOCAL:
        > То если новое и старое значения вступают в конфликт, старое остается, а новое отбрасывается.
      > Если указано RELPLACE, или если REPLACE не указано, и LOCAL тоже не указано:
        > То если новое и старое значения вступают в конфликт, старое значение заменяется новым.
      > Чтобы игнорировать и ограничения, связанные с FOREIGN KEY во время операции LOAD INFILE,
        требуется установить значение системной переменной foreign_key_checks == 0.
    > FIELDS и LINES
      > Необязательные атрибуты.
      > FIELDS должен идти до LINES.
      > Синтаксис атрибутов FIELDS и LINES одиноковый и для операции LOAD DATA INFILE, и для
        операции SELECT ... INTO OUTFILE.
      > О FIELDS подробнее:
        > Если атрибут FIELDS указан, то синтаксис трубует указать хотя бы 1 из его под-атрибутов.
        > Если атрибут FIELDS явно не указан, то он указывается сервером неявно в следующем виде:
            FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
          > Это буквально означает следующее:
            > В файле в строке значение каждой строки НЕ заключено между какими-либо символами,
              значения отделены друг от друга символом табуляции \t, а для экранирования спец. символов
              используется одинарный обратный слэш \
      > О LINES подробнее:
        > Если атрибут LINES явно не указан, то он указывается сервером неявно в следующем виде:
            LINES TERMINATED BY '\n' STARTING BY ''
          > Это буквально означает следующее:
            > В файле символом конца строки является символ \n
          > Такое значение по умолчанию подходит для UNIX систем, а если операция производится в
            Windows, где символом конца строки текстового файля является \r\n, то потребуется изменить
            поведение по умолчанию, я вно указать атрибут LINES в следующей конфигурации:
              LINES TERMINATED BY '\r\n'
          > Если все строки в файле имеют некий одинаковый префикс, который требуется проигнорировать,
            то можно использовать под-атритрибут STARTING BY атрибута LINES. Игнорируется также все,
            что находится слева от этого префикса.
            > Например:
              > Есть файл, который содержит 3 строки:
                  xxx"abc",1
                  something xxx"def",2
                  "ghi",3
              > Используем следующую операцию:
                LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test FIELDS TERMINATED BY ','
                  LINES STARTING BY 'xxx';
              > В результате будут прочитаны следующие 2 строки:
                  "abc",1
                  "def",2
    > IGNORE number {LINES | ROWS}
      > Позволяет указать, что первые number строк (LINES) или полей (ROWS) должны быть
        проигнорированы.
  > Сигнатура: см. в примерах
            LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name'
                [REPLACE | IGNORE]
                INTO TABLE tbl_name
                [PARTITION (partition_name,...)]
                [CHARACTER SET charset_name]
                [{FIELDS | COLUMNS}
                    [TERMINATED BY 'string']
                    [[OPTIONALLY] ENCLOSED BY 'char']
                    [ESCAPED BY 'char']
                ]
                [LINES
                    [STARTING BY 'string']
                    [TERMINATED BY 'string']
                ]
                [IGNORE number {LINES | ROWS}]
                [(col_name_or_user_var,...)]
                [SET col_name = expr,...]


> LOAD XML                | записывает строки из XML файла в таблицу
  > Общая информация
    >
  > Права на использование
    >
  > Атрибуты и опции
    >
  > Сигнатура: см. в примерах
    >

> REPLACE                 | аналог INSERT, только заменяет совпавшие по первичному или уникальному ключу строки
  > Общая информация
    > Работает точно также, как INSERT, за исключением того, что если в таблице уже существует строка,
      имеющая такое же, как втавляющееся значение в столбце с индексами PRIMARY KEY или UNIQUE KEY,
      то старая строка удаляется, и новая строка вставляется.
    > Нет смысла использовать REPLACE, если в таблице, в которую надо вставить строки, нет
      столбцов с PRIMARY KEY или UNIQUE KEY.
    > Выражение REPLACE возвращает количество задействованных строк - которое представляет собой
      сумму количества удаленных, и количества вставленных строк.
  > Права на использование
    > Требуются права на INSERT и DELETE.
  > Атрибуты и опции
    > Тоже самое, что у INSERT.
  > Сигнатура: см. в примерах
                    REPLACE [LOW_PRIORITY | DELAYED]
                        [INTO] tbl_name
                        [PARTITION (partition_name,...)]
                        [(col_name,...)]
                        {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
                    Or:

                    REPLACE [LOW_PRIORITY | DELAYED]
                        [INTO] tbl_name
                        [PARTITION (partition_name,...)]
                        SET col_name={expr | DEFAULT}, ...
                    Or:

                    REPLACE [LOW_PRIORITY | DELAYED]
                        [INTO] tbl_name
                        [PARTITION (partition_name,...)]
                        [(col_name,...)]
                        SELECT ...

> SELECT                  | извлекает строки из 1-й или нескольких таблиц
  > Общая информация
    > Операция SELECT используется для извлечения полей из одной или более таблиц.
    > В рамках операции могут применяться UNION-выражения и подзапросы.
    > Операция SELECT может быть также использована для извлечения полей, никак не связанных
      ни с какими таблицами. Например:
      > SELECT 1 + 1;       | возвращает:  -> 2
    > Используемые атрибуты операции SELECT должны иметь ту же очередность, что представлена
      в сигнатуре операции.
    > Синтаксис SELECT ... INTO используется для того, чтобы извлечь поля из таблиц, и записать
      их в файл или сохраняемые переменные.
  > Права на использование
    >
  > Атрибуты и опции
    > select_expr
      > Указывает колонку, с которой будет работать операция SELECT.
      > Минимум требуется указать 1 колонку. Можно указать несколько колонок через запятую.
      > Если select_expr == * (звездочке) - значит требуется извлечь все столбцы указанных таблиц.
        > Пример 1. Извлечь все столбцы из 1-й таблицы:
            SELECT * FROM tbl_name;
        > Пример 2. Извлечь все столбцы из всех указанных таблиц:
            SELECT * FROM t1 INNER JOIN t2 ...
        > Пример 3. Квалификация звездочки именеа таблицы - tbl_name.* :
            SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ...
      > Каждой извлекаемой колонке может быть дан псевдоним с помощью синтаксиса
        col_name AS alias_name. Например:
          SELECT col1 AS "ID клиента" FROM tbl_name;
        > В атрибуте WHERE ссылаться на псевдоним колонки запрещено.
      > Квалификация имени колонки:
        > Квалификация не требуется до тех пор, пока выражение не становится двусмысленным,
          и без квалификации сервер не может принять решение, какой из смыслов использовать.
        > Имя колонки может быть указано на 1-м из 3-х уровней квалификации:
          > col_name
          > tbl_name.col_name
          > db_name.tbl_name.col_name
      > select_expr допускает наличие колонок с одинаковыми именами (см. пример ниже). Однако,
        чтобы, например, при использовании GROUP BY или ORDER BY быть на 100% уверенным в том,
        что группировка/сортировка проводится по задуманной колонке, лучше использовать разные имена.
          SELECT 12 AS a, a FROM t GROUP BY a;
    > FROM table_references
      > Указывает таблицу, с которой будет работать операция SELECT.
      > Можно указать несколько таблиц, воспользовавшись JOIN-синтаксисом.
      > Каждой указанной таблице может быть дан псевдоним с помощью синтаксиса
        tbl_name [[AS] alias]. Например:
          SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
            WHERE t1.name = t2.name;
      > Если tbl_name не квалифицировано именем базы данных, то используется БД по умолчанию.
        Либо можно квалифицировать вот так:  db_name.tbl_name
    > WHERE where_condition
      > Позволяет указать условие, и извлекаться будут только те поля, которые удовлетворяют
        этому условию.
      > Если атрибут WHERE отсутствует, то выражение SELECT извлекает все поля из указанных столбцов
        указанных таблиц.
      > В атрибуте WHERE можно использовать любые функции и операторы MySQL, кроме агрегирующих
        ( таких, например, как SUM() )
    > ORDER BY
      > Используется для сортировки вывода.
      > Сортировка может производиться в 2-х направлениях:
        > ASC  - по возрастанию  (по умолчанию)
        > DESC - по убыванию
      > Указать колонки, по которым будет проводиться сортировка, можно 3-мя способами:
        > Указав их имена. Например:
            SELECT college, region, seed FROM tournament ORDER BY region, seed;
        > Указав их псевдонимы. Например:
            SELECT college, region AS r, seed AS s FROM tournament ORDER BY r, s;
        > Указав их номера (устарело). Например:
            SELECT college, region, seed FROM tournament ORDER BY 2, 3;
      > Если ORDER BY появляется в запросе, и одновременно в подзапросе, то внешний ORDER BY
        имеет приоритет. Например:
          (SELECT ... ORDER BY a) ORDER BY a DESC;
      > Если для сортировки указана не 1 колонка, а, например, 2, то сортировка происходит
        следующим образом. Сначала сервер сортирует по первой указанной колонкой (слева).
        Затем он сортирует по второй, но лишь в пределах сортировки по первой.
      > Если в атрибуте ORDER BY указаны имена колонок, не квалифицированные именами таблиц,
        то сервер MySQL производит поиск этих колонок в следующем порядке:
        1. Сначала он ищет среди значений select_expr.
        2. Затем среди столбцов таблиц, указанных в атрибуте FROM.
    > GROUP BY
      > Отличие от ORDER BY:
        > ORDER BY всего лишь сортирует по возрастанию или убыванию.
        > GROUP BY берет все поля в столбце с одинаковыми значениями, и объединяет их в одно
          поле. Таким образом, например, можно подсчитать кол-во активных и не активных пользователей:
            SELECT IsActive, COUNT(*) FROM Customers GROUP BY IsActive
      > Можно также указать порядок сортировки сгруппированных строк.
        > Есть 2 варианта:
          > ASC  - по возрастанию  (по умолчанию)
          > DESC - по убыванию
        > Например:
            SELECT a, COUNT(b) FROM test_table GROUP BY a DESC;
      > Если в атрибуте GROUP BY указаны имена колонок, не квалифицированные именами таблиц,
        то сервер MySQL производит поиск этих колонок в следующем порядке:
        1. Сначала он ищет среди столбцов таблиц, указанных в атрибутах FROM и HAVING.
        2. А затем среди значений select_expr.
    > HAVING where_condition
      > Может ссылаться на колонки, указанные в GROUP BY, SELECT и подзапросах. А вообще то в
        оригинальном SQL, HAVING может ссылаться только на колонки из GROUP BY.
        > Например:
            SELECT col_name FROM tbl_name GROUP BY col_name HAVING Count(ID) > 1
      > Не надо использовать HAVING вместо WHERE.
      > В отличие от WHERE, в HAVING можно ссылаться на агрегирующие функции.
        > Например:
            SELECT user, MAX(salary) FROM users GROUP BY user HAVING MAX(salary) > 10;
    > LIMIT ( x,y  |  y )
      > Позволяет ограничить колчество строк, возвращаемых операцией SELECT.
      > Принимает 1 или 2 аргумента. Это должны быть константы, не отрицательные целые числа.
        > В сохраняемых программах вместо константы может быть использована локальная переменная,
          или параметр этой сохраняемой программы.
        > x - смещение в строках.
        > y - ограничение на MAX количество возвращаемых операцией SELECT строк.
      > Если LIMIT встречается в выражении, и одновременно в подвыражении, то у внешнего
        лимита приоритет. Например:
          (SELECT ... LIMIT 1) LIMIT 2;
      > Примеры:
        > Пример 1. Простой LIMIT с 1 аргументом:
            SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows
        > Пример 2. LIMIT со смещением:
            SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15
        > Пример 3. LIMIT с извлечением всех строк после смещения. Использование большого y:
            SELECT * FROM tbl LIMIT 95, 99999999999999999999;
    > PROCEDURE procedure_name(argument_list)
      > Этот атрибут указывает список процедур, которые должны обработать результат данного
        запроса SELECT.
    > Атрибуты атрибута SELECT:
      > [ALL | DISTINCT | DISTINCTROW ]
        > Позволяет указать, возвращать ли дублирующиеся строки.
        > Возможные варианты:
          > ALL (по умолчанию)
            > Возвращать все строки, включая дублирующиеся.
          > DISTINCT (синоним DISTINCTROW)
            > Дублирующиеся строки не возвращать, только оригиналы.
      > HIGH_PRIORITY
        > Только для движков с блокировкой на уровне таблицы (MyISAM, MERGE, MEMORY).
        > Дает операции SELECT больший приоритет, чем операции, изменяющей значение в таблице.
      > STRAIGHT_JOIN
        > Указывает оптимизатору проводить операции JOIN на таблицах в том порядке, в котором
          они указаны в атрибуте FROM. Используется для ускорения запроса в тех случаех, когда
          оптимизатор производит операции JOIN в неоптимальном порядке.
      > SQL_BIG_RESULT или SQL_SMALL_RESULT
        > Используются вместе с GROUP BY или DISTINCT.
        > Чтобы сказать оптимизатору, что результат очень большой / маленький.
      > SQL_BUFFER_RESULT
        > Приказывает серверу MySQL положить результат выражения SELECT во временную таблицу.
        > Это позволяет быстро снять блок с таблицы и ее полей.
        > Полезно использовать в тех случаях, когда отправка результата от сервера к клиенту
          может занять много времени.
      > SQL_CALC_FOUND_ROWS
        > Приказывает MySQL посчитать, как много полей будет в результате работы операции SELECT,
          без учета атрибута LIMIT. Количество полей можно будет получить с помощью операции
          SELECT FOUND_ROWS().
      > SQL_CACHE и SQL_NO_CACHE
        > Указывают, кэшировать ли результат запроса, или нет.
  > Подробнее о синтаксисе SELECT ... INTO
    > Позволяет записывать результат запроса SELECT в файл или переменную:
      > SELECT ... INTO var_list  | сохранение в переменных
          > Можно указать список из переменных.
          > Это могут быть определенные пользователем переменные, параметры сохраняемой процедуры
            или функции, или их локальные переменные.
          > Количество переменных должно совпадать с количеством столбцов.
          > Чтобы можно было сохранять запрос в переменные, он должен возвращать только одну строку.
            Если он вернет 0 или более 1-й строки, то будет ошибка.
            > Т.Е. лучше вообще использовать в этом случае атрибут LIMIT 1. Например:
                SELECT id, data INTO @x, @y FROM test.t1 LIMIT 1;
      > SELECT ... INTO OUTFILE   | сохранение в файл
          > В основном это выражение предназначено для быстрого сохранения таблицы в файл
            на сервере.
          > Эта операция - противоположность для LOAD DATA INFILE. Последняя загружает данные
            из файла в таблицу, а первая наоборот.
          > Требуются FILE-права.
          > Системная переменная character_set_filesystem отвечает за интерпретацию кодировки
            имени файла.
          > Синтаксис для опций export_options (включая LINES и FIELDS) такой же, как для
            LOAD DATA INFILE (см. выше).
          > Пример закачки данных из таблицы в файл в формате .csv:
                  SELECT a,b,a+b INTO OUTFILE '/tmp/result.txt'
                    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
                    LINES TERMINATED BY '\n'
                    FROM test_table;
      > SELECT ... INTO DUMPFILE  | сохранение в файл 1-й строкой без форматирования
    > Этот синтаксис не должен использоваться во вложенных выражениях SELECT, потому что
      такие выражения должны возвращать результат внешнему контексту, а не в файл или переменную.

  > Подробнее о JOIN-синтаксисе
    > Доступно с примерами про JOIN в MySQL:
        http://www.anton-pribora.ru/articles/mysql/mysql-join
    > Что такое JOIN
      > JOIN - оператор языка SQL, который является реализазцией операции соединения реляционной
        алгебры. Входит в раздел FROM операторов SELECT, UPDATE и DELETE.
      > Операция соединения, как и другие бинерные операции, презназначена для обеспечения
        выборки данных из двух таблиц и включения этих данных в один результирующий набор.
      > Отличительной особенностью операции JOIN является:
        > В схему таблицы-результата входят столбцы обеих исходных таблиц, т.е. схема результата
          является "сцеплением" схем операндов.
        > Каждая строка таблицы-результата является "сцеплением" строки из одной таблицы-операнда
          со строкой второй таблицы-операнда.
      > При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется
        несколько раз (последовательно).
    > Виды JOIN-операторов:
      > INNER JOIN (CROSS JOIN, JOIN)
          > Выводит только удовлетворяющие условию результаты
          > Наиболее часто используемый.
      > LEFT [OUTER] JOIN
          > Выводит все значения левой таблицы.
          > Только удовлетворяющие условию значения правой таблицы.
            > А вместо не удовлетворяющих условию значений выводит NULL.
            > Т.Е. выводится строка, содержащая все столбцы правой колонки,
              все значения которых == NULL.
      > RIGHT [OUTER] JOIN
          > Выводит все значения правой таблицы.
          > Только удовлетворяющие условию значения левой таблицы.
            > А вместо не удовлетворяющих условию значений выводит NULL.
            > Т.Е. выводится строка, содержащая все столбцы левой колонки,
              все значения которых == NULL.
    > Общая информация
      > table_references из синтаксиса выражения SELECT также известен, как join expression. Потому
        что в основном состоит из JOIN-операций по горизонтальному объединению таблиц.
      > В MySQL выражения JOIN, CROSS JOIN и INNER JOIN эквивалентны. А в оригинальном SQL они
        не эквивалентны - INNER JOIN используется с атрибутом ON, а CROSS JOIN без него.
      > Круглые скобки могут быть опущены в выражениях с JOIN, содержащих только операции INNER JOIN.
      > MySQL поддерживает вложенные JOIN'ы.
    > Следующие пункты описывают основные факторы, которые надо принять во внимание
      при работе с JOIN:
      > Именам таблиц можно дать псевдонимы с помощью следующего синтаксиса:
          tbl_name AS alias_name
        > Например:
              SELECT t1.name, t2.salary
                FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name;
      > table_subquery
        > Также известен, как запрос в атрибуте FROM. Такие подзапросы должны содержать псевдонимы,
          чтобы дать результату запроса (таблице) имя.
          > Например:
              SELECT * FROM (SELECT 1, 2, 3) AS t1;
      > Запятая и INNER JOIN - эквиваленты в JOIN-выражении
        > Однако, INNER JOIN и прочие словесные обозначения имеют приоритет над запятой.
          Так что если мешать запятые и словесные определения, то могут быть проблемы.
      > ON conditional_expr
        > Это любое условное выражение, которое может быть использовано в атрибуте WHERE.
        > В общем атрибут ON требуется использовать для того, чтобы указать условия того,
          как таблицы объединяются, а атрибут WHERE - чтобы указать, какие строки желанны
          в результирующей таблице.
      > Если в выражении LEFT JOIN у атрибута ON / USING нет совпадающих по условию полей
        для правой таблицы, то для нее используется строка со всеми колонками, значения которых == NULL.
        > Используя этот факт можно легко в одной таблице найти строки, у которых нет двойников
          во второй таблице. Пример, который выводит только строки без двойников:
              SELECT left_tbl.*
                FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id
                WHERE right_tbl.id IS NULL;
      > USING(column_list)
        > Этот атрибут указывает список имен колонок, которые должны присутствовать в обоих таблицах.
          Если в обоих таблицах есть все указанные столбцы, то выражение производит сравнение
          соответствующих столбцов двух таблиц. Например:
              a LEFT JOIN b USING (c1,c2,c3)
        > Т.Е. мы указываем оператору USING значения каких столбцов сравнивать, и он их сравнивает.
          Если они равны, то в правой таблице он их выводит. А если не равны, то в правой таблице
          он выводит строку с NULL'ами.
      > NATURAL [LEFT] JOIN
        > Это эквивалент для INNER JOIN, или для LEFT JOIN с атрибутом USING, который охватывает
          все столбцы, которые существуют в обеих таблицах.
      > RIGHT JOIN работает также, как LEFT JOIN (отличия см. выше в разделе "Виды JOIN-операторов").
        Однако, рекомендуется везде использовать LEFT JOIN, потому что большинство используют его,
        и код будет легче портироваться.
      > { OJ table_reference }
        > Присутствует в сигнатуре только для совместимости с ODBC
      > STRAIGHT_JOIN
        > Тоже самое, что JOIN, за одним исключением: левая таблица читается всегда перед правой.
        > Может быть использован в тех нескольких случаях, для которых join-optimizer располагает
          таблицы в неправильном порядке.
    > Несколько реальных примеров синтаксиса SELECT-операций с JOIN:
      > SELECT * FROM table1, table2;
      > SELECT * FROM table1 INNER JOIN table2 ON table1.id=table2.id;
      > SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;
      > SELECT * FROM table1 LEFT JOIN table2 USING (id);
      > SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id
          LEFT JOIN table3 ON table2.id=table3.id;
    > MySQL поддерживает следующий JOIN-синтаксис для table_references из синтаксиса для SELECT:
                          table_references:
                              escaped_table_reference [, escaped_table_reference] ...

                          escaped_table_reference:
                              table_reference
                            | { OJ table_reference }

                          table_reference:
                              table_factor
                            | join_table

                          table_factor:
                              tbl_name [PARTITION (partition_names)]
                                  [[AS] alias] [index_hint_list]
                            | table_subquery [AS] alias
                            | ( table_references )

                          join_table:
                              table_reference [INNER | CROSS] JOIN table_factor [join_condition]
                            | table_reference STRAIGHT_JOIN table_factor
                            | table_reference STRAIGHT_JOIN table_factor ON conditional_expr
                            | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_condition
                            | table_reference NATURAL [{LEFT|RIGHT} [OUTER]] JOIN table_factor

                          join_condition:
                              ON conditional_expr
                            | USING (column_list)

                          index_hint_list:
                              index_hint [, index_hint] ...

                          index_hint:
                              USE {INDEX|KEY}
                                [FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])
                            | IGNORE {INDEX|KEY}
                                [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)
                            | FORCE {INDEX|KEY}
                                [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)

                          index_list:
                              index_name [, index_name] ...
  > Подробнее о UNION-синтаксисе
    > Синтаксис:
              SELECT ...
              UNION [ALL | DISTINCT] SELECT ...
              [UNION [ALL | DISTINCT] SELECT ...]
    > UNION-синтаксис используется для совмещения результатов от нескольких выражений SELECT
      в одной результирующей таблице.
    > То есть суть в том, что UNION позволяет к одной таблице с результатами добавить снизу
      еще результатов из другой таблицы, но для этого они должны состоять из одинакового
      количество столбцов, расположенных в одинаковом порядке, с одинаковыми типами друг под другом.
      > Пример. SELECT a,b FROM t1 UNION SELECT c,d FROM t2;
        > Определения и данные в таблицах:
          > CREATE TABLE t1 (a INT, b string).
            1, ИВАН
            2, ПЕТР
          > CREATE TABLE t2 (a INT, b string).
            3, Василий
            4, Илья
        > Результат выражения:
            1, ИВАН
            2, ПЕТР
            3, Василий
            4, Илья
    > Только последний SELECT (самый правый) в выражении с UNION'ами может использовать
      атрибут INTO OUTFILE. Однако, в файл будет записан весь объединенный UNION'ами результат.
    > [ALL | DISTINCT ]
      > Позволяет указать, возвращать ли дублирующиеся строки.
      > Возможные варианты:
        > ALL (по умолчанию)
          > Возвращать все строки, включая дублирующиеся.
        > DISTINCT (синоним DISTINCTROW)
          > Дублирующиеся строки не возвращать, только оригиналы.
    > Использование ORDER BY или LIMIT вместе с UNION
      > Чтобы применить ORDER BY или LIMIT к определенному выражению SELECT, можно заключить это
        выражение целиком в круглые скобки. Например:
              (SELECT a FROM t1 WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
              UNION
              (SELECT a FROM t2 WHERE a=11 AND B=2 ORDER BY a LIMIT 10);
      > Чтобы применить ORDER BY или LIMIT ко всему выражению, нужно написать их в конце вне всяких
        круглых скобок. Например:
              (SELECT a FROM t1 WHERE a=10 AND B=1)
              UNION
              (SELECT a FROM t2 WHERE a=11 AND B=2)
              ORDER BY a LIMIT 10;
        > Этот вид ORDER BY не может использовать ссылки на колонки вида tbl_name.col_name.
          Вместо этого в первом SELECT-выражении требуется определить для колонок псевдонимы,
          и использовать их в этом ORDER BY.
          > Причем, если колонка, которая будет использована в ORDER BY, уже получила псевдоним,
            то в ORDER BY должен быть использован именно псевдоним, а не имя колонки. Иначе error.
  > Сигнатура: см. в примерах
        SELECT
            [ALL | DISTINCT | DISTINCTROW ]
              [HIGH_PRIORITY]
              [STRAIGHT_JOIN]
              [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
              [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
            select_expr [, select_expr ...]
            [FROM table_references
              [PARTITION partition_list]
            [WHERE where_condition]
            [GROUP BY {col_name | expr | position}
              [ASC | DESC], ... [WITH ROLLUP]]
            [HAVING where_condition]
            [ORDER BY {col_name | expr | position}
              [ASC | DESC], ...]
            [LIMIT {[offset,] row_count | row_count OFFSET offset}]
            [PROCEDURE procedure_name(argument_list)]
            [INTO OUTFILE 'file_name'
                [CHARACTER SET charset_name]
                export_options
              | INTO DUMPFILE 'file_name'
              | INTO var_name [, var_name]]
            [FOR UPDATE | LOCK IN SHARE MODE]]

> UPDATE                  | обновляет значения указанных столбцов
  > Общая информация
    > Операция UPDATE позволяет в указанной таблице, в указанных колонках, изменить значения
      строк на удовлетворяющие указанным условиям.
    > Одной операцией UPDATE можно либо с 1-й таблицей (и использовать синтаксис для 1-й таблицы),
      либо более чем с 1-й таблицей (и использовать синтаксис для нескольких таблиц).
    > Если обратиться к значению колонки таблицы, на которую воздействуют операцией UPDATE из этой
      самой операции, то получишь текущее значение строки этой колонки.
      > Например, следующее выражение увеличивает все значения колонки col1 на единицу:
        UPDATE t1 SET col1 = col1 + 1;
      > Еще пример, вторая операция в следующем выражении устанавливает значения строк колонки
        col2, равными новым значениям строк колонки col1 (к которым уже прибавили 1), а не старым:
          UPDATE t1 SET col1 = col1 + 1, col2 = col1;
    > Откуда и куда протекает процесс изменения значения:
      > В однотабличном синтаксисе процесс течет слева направо, см. примеры выше.
      > В многотабличном синтаксисе он течет в неизвестных направлениях.
    > Если попытаться изменить значение в колонке с атрибутом NOT NULL на NULL, то:
      > Если strict mode включен, то будет error.
      > Если strict mode выключен, то будет warning, а значение установится на неявное DEFAULT-значение
        для этого типа. Для числовых типов это 0, для строковых это '', для датавременных это zero-value.
    > Возвращает количество строк, которые были действительно изменены.
    > Не рекомендуется использовать многостолбцовый синтаксис для изменения значений в таблицах,
      связанных между собой с помощью внешнего ключа. Вместо этого, лучше воспользоваться
      синтаксисом для одной таблицы, для воздействия на родительскую таблицу.
    > Нельзя пользоваться UPDATE в подзапросе. Также, там нельзя с помощью SELECT извлекать
      данные из этой же таблицы.
  > Права на использование
    >
  > Атрибуты и опции
    > table_reference
      > Имя таблицы, значения которой требуется изменить.
    > table_references
      > Имена таблиц (синтаксис для многих таблиц), значения которых требуется изменить.
      > Для указания нескольких таблиц используют JOIN-синтаксис (см. раздел о SELECT).
    > SET
      > Содержит через запятую имена столбцов, значения которых требуется изменить.
      > Для каждого столбца содержит также значение, на которое требуется изменить.
        Возможны 2 варианта:
        > DEFAULT    | значение этого столбца по умолчанию
        > expr       | выражение
    > WHERE
      > Содержит условия, указывающие на то, значения каких строк требуется изменить.
    > LIMIT row_count
      > Не используется в многотабличном синтаксисе.
      > Указывает MAX число строк, которое может заменить эта операция.
    > ORDER BY
      > Не используется в многотабличном синтаксисе.
      > Этот атрибут обычно используют в связке с LIMIT, чтобы удалить "последние N строк" или
        "первые N строк". N указывают с помощью LIMIT, а порядок - с помощью ORDER BY.
      > Также он приносит существенную пользу при изменении столбца с уникальным ключем,
        первичным ключем, автоинкрементом.
        Ведь если начать изменять значения не в том порядке, будет ошибка дублирования первичного
        ключа.
      > ORDER BY указывает 2 вещи:
        > По какой строке производить сортировку.
        > Сортировать в возрастающем (ASC) или убывающем (DESC) порядке.
    > IGNORE
      > IGNORE можно использовать чтобы перезаписать старые значения в столбцах
        с уникальным ключем новыми, если они дублируют друг друга.
  > Сигнатура: см. в примерах
                Single-table syntax:
                  UPDATE [LOW_PRIORITY] [IGNORE] table_reference
                      SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
                      [WHERE where_condition]
                      [ORDER BY ...]
                      [LIMIT row_count]
                Multiple-table syntax:
                  UPDATE [LOW_PRIORITY] [IGNORE] table_references
                    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
                    [WHERE where_condition]

> Синтаксис подзапросов   | здесь описан синтаксис подзапросов

  > Общая информация
    > Поздапрос - это операция SELECT внутри другого запроса.
    > Простой пример подзапроса ниже. В этом примере "SELECT * FROM t1 ..." - это внешний
      запрос, и "(SELECT column1 FROM t2)" - это подзапрос.
        SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
    > Какую основную пользу приносят подзапросы:
      > Благодаря подзапросам появляется альтернативный способ составлять запросы, без которого
        запрос бы состаял из сложной смеси JOIN'ов и UNION'ов.
      > Многие люди считают выражения с подзапросами - более читаемыми, чем те же выражения,
        написанные с помощью JOIN'ов и UNION'ов.
      > Поззапросы позволяют изолировать разные части выражения друг от друга.
    > Что может возвращать подзапрос.
      > Он может возвращать:
        > Скаляр (одно значение).
        > Одну строку.
        > Один столбуц.
        > Одну таблицу.
      > Каждый подзапрос, который возвращает любой из этих видов результатов, может использоваться
        только в соответствующем контексте, который может принять и обратотать такой вид результата.
    > Ограничения при работе с подзапросами:
      > Для подзапроса:
        > Подзапросы могут содержать многие ключевые слова и атрибуты, которые может обычный SELECT:
            DISTINCT, GROUP BY, ORDER BY, LIMIT, JOINs, INDEXes, UNIONs, COMMENTs, функции и так далее.
      > Для внешнего запроса подзапроса:
        > Это может быть любая из следующих операций:
            SELECT, INSERT, UPDATE, DELETE, SET, DO.
      > Запрет на одновременную модификацию и извлечение данных из таблицы подзапросом:
        > В MySQL запрещено в одном выражении модифицировать определенную таблицу, и извлекать
          из нее данные с помощью подзапроса.
        > Это касается следующих операций:
            DELETE, INSERT, REPLACE, UPDATE и (потому что в ней есть SET) LOAD DATA INFILE.
    > Пример подзапроса:
                  DELETE FROM t1
                  WHERE s11 > ANY
                   (SELECT COUNT(*) FROM t2
                    WHERE NOT EXISTS
                     (SELECT * FROM t3
                      WHERE ROW(5*t2.s1,77)=
                      (SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM
                       (SELECT * FROM t5) AS t5)));

  > Подзапрос, как скалярный (scalar) операнд
    > Как описано выше, подзапрос может возвращать скаляр (1 из 4 вариантов) - одно значение.
    > Использовать можно везде, где требуется одно значение. Но, например, если использовать
      в качестве значения для строки колонки, то тип должен совпадать. Т.Е. надо учитывать
      всякие ограничения.
    > Есть контекст, в котором нельзя использовать этот тип подзапроса:
      > Если контекст требует, чтобы значение было литералом, а не результатом другого выражения,
        включая подзапросы. Например, такие значения требует операция LIMIT x,y .
    > Скалярный подзапрос может быть частью выражения.
      > Но он ВСЕГДА должен быть в круглых скобках, без исключения.
      > Например: SELECT UPPER((SELECT s1 FROM t1)) FROM t2;
    > Пример работы скалярного подзапроса:
        CREATE TABLE t1 (s1 INT);
        INSERT INTO t1 VALUES (1);
        CREATE TABLE t2 (s1 INT);
        INSERT INTO t2 VALUES (2);
          SELECT (SELECT s1 FROM t2 LIMIT 1)   -- этот подзапрос возвращает 2
            FROM t1;                           -- ... в результате внешний подзапрос имеет вид
                                               -- SELECT 2 FROM t1;  FROM отбрасывается за ненадобносью, и результат: 2
  > Сравнение с помощью подзапросов
    > Часто подзапросы используют в выражениях сравнения, по следующей схеме:
        [операнд_не_подзапрос] оператор_сравнения [подзапрос]
      > Где оператором сравнения могут быть:
          =  >  <  >=  <=  <>  !=  <=>
    > Также доступна следующая конструкция:
        [операнд_не_подзапрос] LIKE [подзапрос]
    > При сравнении, подзапрос должен возвращать результат того типа, который от него ожидает контекст:
      > При сравнение скаляра с подзапросом, он должен возвращать скаляр.
      > При сравнении строки с подзапросом, подзапрос должен возвращать строку с таким же определением.
        ... и т.д.
    > Пример 1. Абстрактный пример использования подзапроса в выражении с сравнением:
        SELECT c2 FROM t2 WHERE c2 > (SELECT column1 FROM t1);
    > Пример 2. Делает то, что с помощью JOIN'ов сделать невозможно, потому что содержит
        агрегирующую функцию (запрещена в JOIN'ах). Находит все строки в таблице t1, для которых
        значение из column1 равно MAX значению column2 из таблицы t2.
            SELECT * FROM t1
              WHERE column1 = (SELECT MAX(column2) FROM t2);
    > Пример 3. Делает то, что с помощью JOIN'ов сделать невозможно, потому что содержит
        агрегирующую функцию (запрещена в JOIN'ах). Находит все строки в таблице t1, значение
        столбца ID которых встречается в этой таблице дважды.
            SELECT * FROM t1 AS t
              WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);

  > Подзапросы с атрибутами ANY, IN или SOME
    > Синтаксис:
        operand comparison_operator ANY (subquery)
        operand IN (subquery)
        operand comparison_operator SOME (subquery)
      > Где comparison_operator это один из:
          =  >  <  >=  <=  <>  !=
    > ANY
      > Значит буквально следующее: вернуть TRUE, если если сравнение является TRUE
        для любого (ANY) из значений в колонке, которую возвращает подзапрос.
      > Пример. Требуется найти в столбце s1 таблицы t1 все строки, которые больше любой строки
                в столбце s1 таблицы t2:
                  SELECT s1 FROM t1 WHERE s1 > ANY (SELECT s1 FROM t2);
      > <> ANY - противоположность для ANY.
    > IN
      > IN является псевдонимом для  = ANY  , но только если в выражени используются подзапросы.
      > Следующие 2 выражения идентичны:
          SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
          SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);
      > Не путать. NOT IN не является псевдонимом для <> ANY, а является для <> ALL.
    > SOME (устаревшее)
      > Это псевдоним для ANY.
      > Следующие 2 выражения идентичны:
          SELECT s1 FROM t1 WHERE s1 <> ANY  (SELECT s1 FROM t2);
          SELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);

  > Подзапросы с атрибутом ALL
    > Синтаксис:
        operand comparison_operator ALL (subquery)
    > Значит буквально следующее: вернуть TRUE если сравнение верно для всех (ALL)
      значений из колонки, которую возвращает подзапрос.
    > <> ALL является противоположностью для ALL.
      > NOT IN - псевдоним для <> ALL.
        > Следующие выражения эквивалентны:
            SELECT s1 FROM t1 WHERE s1 <> ALL (SELECT s1 FROM t2);
            SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);
    > Пример 1. Выражение возвращает все строки из столбца s1 таблицы t1, каждое значение
                которых больше всех и каждого значения из столбца s1 таблицы t2.
           SELECT s1 FROM t1 WHERE s1 > ALL (SELECT s1 FROM t2);
    > Крайние случаи:
      > Если в таблицах присутствуют NULL-значения, или какая-нибудь из таблиц пуста.
      > Нужно всегда принимать во внимание возможность появления таких случаев.
      > Примеры:
        > Следующее выражение вернет TRUE, если t2 пуста:
            SELECT * FROM t1 WHERE 1 > ALL (SELECT s1 FROM t2);
        > Следующиее выражение вернет NULL, если t2 пуста:
            SELECT * FROM t1 WHERE 1 > (SELECT s1 FROM t2);
        > Следующее выражение также вернет NULL, если t2 пуста:
            SELECT * FROM t1 WHERE 1 > ALL (SELECT MAX(s1) FROM t2);

  > Строковые подзапросы.
    > Которые в качестве результата возвращают строку.
    > Разрешенные операторы для строковых подзапросов:
        =  >  <  >=  <=  <>  !=  <=>
    > Вот 2 примера строковых подзапросов:
          SELECT * FROM t1
            WHERE (col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
          SELECT * FROM t1
            WHERE ROW(col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
      > В этих примерах подзапрос должен возвращать 1-ну строку.
        > Если подзапрос не возвращает ни одной строки, то выражение вернет NULL.
        > Если подзапрос возвращает более 1-й строки, то будет ERROR.
      > Далее эта строка сравнивается со всеми строками из столбцов col1, col2 таблицы t1.
        > Т.Е. col1 сравнивается с col3, а col2 сравнивается с col4.
      > Если результат сравнения - TRUE, то соответствующая строка из таблицы t1 попадает
        в результирующую таблицу, а если FALSE - не попадает.
    > Конструктор строки (row constructor)
      > Выражения (1,2) и ROW(1,2) иногда называют конструктором строки (row constructor).
      > Выражения (1,2) и ROW(1,2) эквивалентны.
      > Конструктор строки используют в сравенниях с подзапросами, которые возвращают
        2 и более столбцов.
        > Если же подзапрос возвращает 1 столбец, то он рассматривается, как скалярный
          подзапрос, а не строковой. И конструктор строки в этом случае не нужен.
          > Например, следующее выражение вызовет error:
              SELECT * FROM t1 WHERE ROW(1) = (SELECT column1 FROM t2)
      > Конструктор строки также можно использовать и не в контексте подзапроса.
        > Пример 1. Следующие 2 запроса эквивалентны:
            SELECT * FROM t1 WHERE (column1,column2) = (1,1);
            SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
        > Пример 2. Найти все строки в таблице t1, которые также присутствуют в таблице t2:
            SELECT column1,column2,column3
              FROM t1
              WHERE (column1,column2,column3) IN
                     (SELECT column1,column2,column3 FROM t2);

  > Подзапросы с атрибутами EXISTS или NOT EXISTS
    > Синтаксис:
        ... WHERE [NOT] EXISTS (подзапрос);
    > EXISTS
      > Возвращает TRUE для всех возвращаемых подзапросом полей, даже если они состоят из NULL-начений.
    > NOT EXISTS
      > Возвращает FALSE для всех возвращаемых подзапросом полей, даже если они состоят из NULL-начений.
    > Пример 1. В выражении ниже подзапрос не содержит корреляций с column1, и так как
                используется EXISTS, то выражение в атрибуте WHERE возвращает TRUE для каждой
                строки из колонки column1, и она попадает в результирующую таблицу.
        SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);
    > Пример 2. Какой тип магазинов присутствует в одном или более городах (без повторов).
                DISTINCT - в вывод попадут типы, удовлетворяющие условиям, без повторов.
                Т.К. в подзапросе использован EXISTS, то все store_type, для которых подзапрос
                вернет строки, попадут в результирующую таблицу.
        SELECT DISTINCT store_type FROM stores
          WHERE EXISTS (SELECT * FROM cities_stores
                        WHERE cities_stores.store_type = stores.store_type);
    > Пример 3. Какой тип магазинов не присутствует ни в одном из магазинов (без повторов).
                DISTINCT - в вывод попадут типы, удовлетворяющие условиям, без повторов.
                Т.К. в подзапросе использован NOT EXISTS, то все store_type, для которых подзапрос
                НЕ вернет строки, попадут в результирующую таблицу.
        SELECT DISTINCT store_type FROM stores
          WHERE NOT EXISTS (SELECT * FROM cities_stores
                            WHERE cities_stores.store_type = stores.store_type);
    > Пример 4. Какой тип магазинов присутствует во всех городах?
                Здесь используется NOT EXISTS с подзапросом, вложенные в подзапрос внешнего
                NOT EXISTS. s1 - это псевдоним для stores.
        SELECT DISTINCT store_type FROM stores s1
          WHERE NOT EXISTS (
            SELECT * FROM cities WHERE NOT EXISTS (
              SELECT * FROM cities_stores
               WHERE cities_stores.city = cities.city
               AND cities_stores.store_type = stores.store_type));

  > Коррелирующие подзапросы
    > Которые содержат ссылку на таблицу, которая фигурирует во внешнем запросе.
    > Пример. В выражении ниже в подзапросе содержится ссылка на t1, хотя в атрибуте
              FROM t1 не присутствует. В таком случае MySQL ищет t1 во внешнем запросе.
              Вот такие подзапросы, как этот, и называются коррелирующими.
        SELECT * FROM t1
          WHERE column1 = ANY (SELECT column1 FROM t2
                               WHERE t2.column2 = t1.column2);
    > Scoping rule - правило поиска MySQL
      > MySQL ищет по направлению изнутри наружу.
      > Пример. В выражении ниже x.column2 - это колонка таблицы t2, а не t1, потому что
        если искать изнутри наружу, то первой MySQL найдет запись SELECT column1 FROM t2 AS x,
        где t2 получает псевдоним.
          SELECT column1 FROM t1 AS x
            WHERE x.column1 = (SELECT column1 FROM t2 AS x
              WHERE x.column1 = (SELECT column1 FROM t3
                WHERE x.column2 = t3.column1));

  > Подзапросы в атрибуте FROM
    > Синтакс:
        SELECT ... FROM (subquery) [AS] name ...
      > Причем [AS] name - указывать обязательно, потому что каждая таблица в атрибуте FROM
        должна иметь имя.
      > Любые колонки в подзапросе subquery должны иметь уникальные имена.
    > Пример:
        SELECT sb1,sb2,sb3
          FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb
          WHERE sb1 > 1;












-------------------------------------------------- */























