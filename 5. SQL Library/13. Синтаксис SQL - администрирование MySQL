/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
13. Синтаксис SQL - администрирование MySQL


  >




-------------------------------------------------- */







/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальное руководство по SQL-синтаксису для администрирования БД
        http://dev.mysql.com/doc/refman/5.6/en/sql-syntax-server-administration.html
  
  > Официальное руководство по SQL-синтаксису утилит MySQL
        http://dev.mysql.com/doc/refman/5.6/en/sql-syntax-utility.html


*****************************************************
Оглавление:

Администрирование базы данных
  > Управление аккаунтами
    > ALTER USER           | изменить аккаунт MySQL
    > CREATE USER          | создать новый MySQL аккаунт
    > DROP USER            | удалить 1 или более аккаунтов MySQL
    > GRANT                | дать права аккаунту MySQL
    > RENAME USER          | переименовать существующий аккаунт MySQL
    > REVOKE               | аннулировать права аккаунту MySQL
    > SET PASSWORD         | задать пароль для аккаунта MySQL

  > Обслуживание таблиц
    > ANALYZE TABLE        | собрать статистику по запросам в таблице для их оптимизации
                             > если опция innodb_stats_persistent, то статистика собирается автоматом
    > CHECK TABLE          | проверить таблицу на наличие ошибок.
    > CHECKSUM TABLE       | получить контрольную сумму для содержимого таблицы
    > OPTIMIZE TABLE       | реорганизует физич. хранение данных в таблице для уменьшения их размера и ускорения доступа
    > REPAIR TABLE         | отремонтировать поврежденную таблицу
  > Создание-удаление пользовательских функций
  > Синтаксис операции SET - пользовательские переменные @x
  > Синтаксис операций SHOW

      SHOW AUTHORS           | (удалено в MySQL > 5.6.8) Отображает информацию о разработчиках сервера MySQL.
      SHOW LOGS              | Показывает список binary logs на сервере.
      SHOW BINLOG EVENTS     | Показывает события в binary log.
      SHOW CHARACTER SET     | Показывает все character set и их collation по умолчанию.
      SHOW COLLATION         | Показывает список collation, поддерживаемых сервером.
      SHOW COLUMNS           | Показывает информацию о колонках в выбранной таблице.
      SHOW CONTRIBUTORS      | Отображает информацию о тех, кто способствовал написанию кода MySQL.
      SHOW CREATE DATABASE   | Показывает выражение CREATE DATABASE, с помощью которого была создана указанная база данных.
      SHOW CREATE EVENT      | Показывает выражение CREATE EVENT, с помощью которого было создано событие, и можно его пересоздать.
      SHOW CREATE FUNCTION   | Показывает выражение CREATE FUNCTION, с помощью которого была создана функция, и можно её пересоздать.
      SHOW CREATE PROCEDURE  | Показывает выражение CREATE PROCEDURE, с помощью которого была создана процедура, и можно её пересоздать.
      SHOW CREATE TABLE      | Показывает выражение CREATE TABLE, которое было использовано для создания указанной таблицы.
      SHOW DATABASES         | Показывает список всех баз данных на этом сервере MySQL.
      SHOW ENGINE            | Показывает информацию о выбранном движке хранилища информации.
      SHOW ENGINES           | Показывает список из информационных блоков о каждом движке, который поддерживается сервером.
      SHOW ERRORS            | Показывает информацию о возникших ошибках.
      SHOW COUNT(*) ERRORS   | Показывает количество возникших ошибок.
      SHOW EVENTS            | Отображает информацию о событиях в планировщике событий.
      SHOW FUNCTION CODE     | Показывает код в теле сохраняемой функции.
      SHOW FUNCTION STATUS   | Возвращают свойства функции - имя, даты создания/модификации, кто DEFINER, кодировки, collations и пр.
      SHOW GRANTS FOR user   | Показывает список выражений GRANT, которые были использованы для назазначения привилегий указанному пользователю
      SHOW INDEX             | Возвращает информацию об индексе таблицы.
      SHOW MASTER STATUS     | Показывает информацию о состоянии файлов binary log.
      SHOW OPEN TABLES       | Показывает список не временных таблиц, которые в настоящий момент откркты
      SHOW PLUGINS           | Показывает список установленных на сервер плагинов и информацию о них.
      SHOW PROCEDURE CODE proc_name  | Показывает код в теле сохраняемой процедуры.
      SHOW PROCEDURE STATUS  | Возвращают свойства процедуры - имя, даты создания/модификации, кто DEFINER, кодировки, collations и пр.
      SHOW PRIVILEGES        | Показывает список привилегий, которые поддерживает сервер, и их описание.
      SHOW PROCESSLIST       | Показывает работающие потоки.
      SHOW PROFILE           | Показывает количество указанного типа type ресурсов, которые были израсходованы выполненными в течение этой сессии выражениями.
      SHOW PROFILES          | Тоже самое, что SHOW PROFILE, только для всех типов ресурсов.
      SHOW RELAYLOG EVENTS   | Показывает события в relay log of a replication slave
      SHOW SLAVE HOSTS       | Показывает список репликационных slave'ов, зарегистрированных в настоящее время на master'e.
      SHOW SLAVE STATUS      | Показывает информацию о состоянии по основным свойствам потоков slave'a.
      SHOW STATUS            | Показывает информацию о состоянии сервера.
      SHOW TABLE STATUS      | Показывает информацию о не временной таблице, более подробную, чем SHOW TABLES.
      SHOW TABLES            | Показывает список не временных таблиц из указанной БД и информацию о них.
      SHOW TRIGGERS          | Показывает список триггеров, определенных в настоящее время для таблиц в указанной БД.
      SHOW VARIABLES         | Показывает значение системных переменных MySQL.
      SHOW WARNINGS          | Показывает информацию о возникших предупреждениях.

  > Прочие административные операции

Утилиты MySQL
  > DESCRIBE         | (синоним EXPLAIN)
  > EXPLAIN          | получить информацию о структуре таблицы или плане выполнения запроса
  > HELP             | ищет информацию в online справки сервера MySQL по указанной строке поиска
  > USE              | позволяет выбрать базу данных по умолчанию


*****************************************************


#############################
Администрирование базы данных

> Управление аккаунтами
  > ALTER USER           | изменить аккаунт MySQL
    > Это выражение изменяет указанный пользовательский аккаунт на сервере MySQL.
    > Требуются глобальные права CREATE USER, или право INSERT для БД mysql (где хранится
      информация об аккаунтах).
    > Применение ALTER USER к любому аккаунту устанавливает статус его пароля, как истекший.
      > А именно, в таблице mysql.user, где хранятся данные об аккаунтах, в колонке password_expired
        соответствующего аккаунта устанавливается значение 'Y' - что оздачает ДА, пароль истек.
      > Если пароль аккаунта помечен как истекший, то все попытки провести любую операцию от
        имени этого аккаунта будут заканчиваться ошибкой error с сообщением:
          "You must SET PASSWORD before executing this statement".
        > Чтобы назначить новый пароль, можно использовать операцию SET PASSWORD.
          > Новый пароль может в точности дублировать старый. Но это не безопасно.
        > После смены пароля пользователю, ему требуется переподключиться, чтобы для него
          все операции заработали как обычно.
      > Например:
          ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE;
    > Формат имени аккаунта
      > Используется формат, как в этом примере:
          ALTER USER 'jeffrey'@'localhost'
      > Имя и хост по отдельности могут быть заключены в кавычки.
    >
    > Синтаксис:
        ALTER USER user_specification
            [, user_specification] ...

        user_specification:
            user PASSWORD EXPIRE

  > CREATE USER          | создать новый MySQL аккаунт
    > Общая информация
      > Выражение CREATE USER создает новый аккаунт на сервере MySQL.
      > Требуются глабальные права CREATE USER, либо INSERT-права для БД mysql.
      > Для каждого аккаунта, операция CREATE USER создает новую строку в таблице mysql.user
        > При создании аккаунт не получает никаких прав.
        > Если аккаунт с таким именем уже существует, будет error.
    > Атрибуты:
      > Формат имени аккаунта
        > Используется формат, как в этом примере:
            CREATE USER 'jeffrey'@'localhost'
        > Имя и хост по отдельности могут быть заключены в кавычки.
        > Если хост не указан, то по умолчанию вместо него будет вставлена строка '%'.
      > user_specification
        > Этот раздел настраивает то, как требуется проверять подлинность пользователя (аутентифицировать).
        > Атрибуты IDENTIFIED BY и IDENTIFIED WITH являются взаимоисключающими.
        > IDENTIFIED WITH auth_plugin
          > Если не указан, то MySQL ассоциирует аккаунт со стандартным плагином для аутентификации
            по умолчанию, который настраивается опцией сервера default-authentication-plugin
          > auth_plugin - имя кастомного плагина для аутентификации.
        > IDENTIFIED BY
          > Чтобы позволить пользователю подключаться к серверу без пароля, нужно НЕ использовать
            этот атрибут:
                  CREATE USER 'jeffrey'@'localhost';
          > Чтобы позволить пользователю подключаться к серверу только с паролем, нужно использовать
            этот атрибут:
                  CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypassword';
            > Для увеличение безопасности, можно вместо того, чтобы написать пароль 'mypassword'
              в виде простого текста, вставить вместо него хэш этого пароля, который можно получить
              с помощью функции PASSWORD():
                  CREATE USER 'jeffrey'@'localhost'
                    IDENTIFIED BY PASSWORD '*90E462C37378CED12064BB3388827D2BA3A9B689';
    > Синтаксис:
                        CREATE USER user_specification
                            [, user_specification] ...

                        user_specification:
                            user
                            [
                                IDENTIFIED BY [PASSWORD] 'password'
                              | IDENTIFIED WITH auth_plugin [AS 'auth_string']
                            ]

  > DROP USER            | удалить 1 или более аккаунтов MySQL
    > Удаляет 1 или более аккаунтов MySQL вместе с их правами.
      > Удаляются строки, описывающие права аккаунта, из всех grant tables.
    > Требуются глабальные права CREATE USER, либо DELETE-права для БД mysql.
    > Формат имени аккаунта
      > Используется формат, как в этом примере:
          DROP USER 'jeffrey'@'localhost';
      > Имя и хост по отдельности могут быть заключены в кавычки.
      > Если хост не указан, то по умолчанию вместо него будет вставлена строка '%'.
    > Если выполнить операцию DROP USER для аккаунта пользователя, который в этот момент
      подключен к серверу, то удаление произойдет только после того, как пользователь
      отключится от сервера.
    > Синтаксис:
        DROP USER user [, user] ...

  > GRANT                | дать права аккаунту MySQL
    > Общая информация
      > Выражение GRANT присваивает права пользовательскому аккаунту MySQL.
        > Кроме того, с помощью GRANT можно настроить другие свойства аккаунта, такие как
          безобасность соединения и ограничения на доступ к ресурсам сервера.
        > В противоположность, выражение REVOKE отнимает права у аккаунта (подробнее
          о REVOKE см. ниже в отдельном пункте о нем).
        > Посмотреть, какие права имеет пользовательский аккаунт, можно воспользовавшись выражением
            SHOW GRANTS [FOR user]
      > Для использованяи GRANT, требуются права GRANT OPTION, а также те права, которые
        вы собираетесь присваивать.
      > При обновлении версии MySQL иногда меняется структура grant-таблиц. Поэтому при выполнении
        обновления до новой версии, необходимо проследить и за тем, чтобы grant-таблицы были
        обновлены тоже.
          см. http://dev.mysql.com/doc/refman/5.6/en/mysql-upgrade.html
      > Обычно, администратор базы данных сначала создает аккаунт пользователя с помощью
        CREATE USER, затем присваивает ему требуемые права и настраивает свойства с помощью GRANT.
        > Например:
              CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';
              GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
              GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';
              GRANT USAGE ON *.* TO 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;
      > Автоматическое создание аккаунта при выполнении GRANT операции:
        > В зависимости от того, существует ли аккаунт, которому делается попытка присвоить права:
          > Существует
            > Права присваиваются.
          > Не существует
            > В зависимости от того, включен ли в системной переменной sql_mode режим
              NO_AUTO_CREATE_USER:
              > Включен
                > error
              > Выключен
                > Создается новый аккаунт.
                > Атрибут IDENTIFIED WITH запрещен к использованию.
                > Рекомендуется использовать IDENTIFIED BY для назначения пароля (иначе будет не безопасно).
      > Если пользователь имеет определенную привилегию на более высоком уровне, то он имеет
        ее и на всех уровнях ниже этого.
        > Например
            Если у пользователя есть привилегия SELECT на глобальном уровне, то он автоматически
            получает эту привилегию и на уровне баз данных, таблиц, колонок ... .
      > В MySQL можно назначать привилегии для баз данных и таблиц, которые еще не существуют.
        Это позволяет администраторам подготовить привилегии заранее.

    > Безопасность
      > О привилегии GRANT OPTION
        > Разрешает этому пользователю управлять привилегиями других пользователей
          на указанном уровне.
        > Имея привилегию GRANT OPTION, невозможно дать другому пользователю привилегию,
          которой у тебя нет.
        > Нужно очень осторожно раздавать эту привилегию. Ведь несколько пользователей,
          имеющие её, а также имеющие каждый свой набор привилегий, могут объединиться, и в сумме
          они будут иметь гораздо больше привилегий, чем им, возможно, запланировано было
          предоставить.

      > О привилегии ALTER
        > Не рекомендуется давать пользователю привилегию ALTER на глобальном уровне.
          Либо давать ее для базы данных mysql.
            Потому что в этом случае пользователь может разрушить систему привилегий этого
            сервера, сделав что-нибудь с таблицами из БД mysql. Например, просто переименовать их.

    > Атрибуты и свойства
      > Уровни, ни которых могут быть присвоены привилегии:

        > Глобальный уровень
          > Это уровень для администраторов.
          > Права на этом уровне применяются ко всем базам данных на данном сервере.
          > MySQL сохраняет информацию о глобальных правах в таблице mysql.user
          > Для назначения привилегий на этом уровне использовать синтаксис ON *.*
            > Например:
                GRANT ALL ON *.* TO 'someuser'@'somehost';
                GRANT SELECT, INSERT ON *.* TO 'someuser'@'somehost';
          > Следующие права могут быть присвоены только на глобальном уровне:
            > CREATE TABLESPACE, CREATE USER, FILE, PROCESS, RELOAD, REPLICATION CLIENT,
              REPLICATION SLAVE, SHOW DATABASES, SHUTDOWN, SUPER
            > Прочие права могут быть присвоены как глобально, так и на более мелких уровнях.

        > Уровень базы данных
          > Права на этом уровне применяются ко всем объектам в данной базе данных.
          > MySQL хранит информацию о привилегиях на уровне БД в таблице базы данных mysql.db.
          > Для назначений привилегий на этом уровне использовать синтаксис  ON db_name.*
            > Например:
                GRANT ALL ON mydb.* TO 'someuser'@'somehost';
                GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost';
            > Причем, если использовать синтаксис ON * (а не ON *.*), и при этом выбрана
              (с помощью USE) база данных по умолчанию, то это будет присвоение привилегий
              на уровне базы данных, а не на глобальном уровне. А если БД по умолчанию нет,
              то будет error.
          > На уровне БД могут быть присвоены следующие права:
            CREATE, DROP, EVENT, GRANT OPTION, LOCK TABLES
            > Также на уровне БД могут быть присвоены те же права, что на уровнях
              таблицы или скрипта, и в этом случае они будут применяться ко всем таблицам
              и скриптам в базе данных.

        > Уровень таблицы
          > Права на этом уровне применяются ко всем столбцам данной таблицы.
          > MySQL хранит информацию о привилегиях на уровне таблицы в таблице mysql.tables_priv
          > Для назначения привилегий на этом уровне использовать синтаксис ON db_name.tbl_name
            > Например:
                GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
                GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';
            > Если указать tbl_name, не квалифицируя его именем БД db_name, то будет использована
              выбранная по умолчанию база данных. А если её нет, то будет error.
          > На уровне таблицы могут быть присвоены следующие права:
            ALTER, CREATE VIEW, CREATE, DELETE, DROP, GRANT OPTION, INDEX, INSERT,
            SELECT, SHOW VIEW, TRIGGER, UPDATE.

        > Уровень колонки
          > Права на этом уровне применяются к одной колонке в данной таблице.
          > MySQL хранит информацию о привилегиях на уровне колонки в таблице mysql.columns_priv
          > Каждая назначаемая привилегия должна сопровождаться круглыми скобками, в которых
            через запятую перечислены имена колонок, которым она назначается.
            > Например:
                GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost';
          > На уровне колонки могут быть присвоены следующие права:
              INSERT, SELECT, UPDATE

        > Уровень скрипта
          > Следующие права могут применяться для работы с сохраняемыми скриптами:
              ALTER ROUTINE, CREATE ROUTINE, EXECUTE, GRANT OPTION
          > Они могут быть применены на глобальном уровне, и на уровне БД.
            > Все эти права (кроме CREATE ROUTINE) могут быть присвоены на уровне одного скрипта.
            > Например:
                GRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';
                GRANT EXECUTE ON PROCEDURE mydb.myproc TO 'someuser'@'somehost';
          > MySQL хранит информацию о привилегиях на уровне скрипта в таблице mysql.procs_priv

        > Уровень Proxy User (доверенный пользователь)
          > Привилегия PROXY позволяет одному пользователю стать доверенным лицом для другого
            пользователя.
            > Пример:
                GRANT PROXY ON 'localuser'@'localhost' TO 'externaluser'@'somehost';
          > PROXY должна быть единственной привилегией, которая фигурирует в операции GRANT.
            Атрибут REQUIRE не допускается, и единственное значение атрибута WITH - это
            WITH GRANT OPTION.
          > MySQL хранит информацию о привилегиях на уровне proxy в таблице mysql.proxies_priv

      > При назначении "всех" привилегий с помощью операции GRANT ALL, назначаются только
        те привилегии, которые могут быть назначены для указанного уровня.
        > Эта операция не назначает следующие привилегии: PROXY, GRANT OPTION

      > object_type
        > Можно (по желанию) указать тип объекта, для которого назначаются привилегии.
          Доступные варианты:
          > TABLE
          > FUNCTION
          > PROCEDURE

      > Имена и пароли аккаунтов
        > user
          > Обозначает аккаунт MySQL, которому присваиваются привилегии.
          > Аккаунт MySQL должен быть написан в следующей форме:
              'user_name'@'host_name'
            > Кавычки обязательно требуются, если строки содержат специальные символы,
              или если host_name содержит специальный символ-шаблон (такой, как '%').
              Например:
                'test-user'@'%.com'
            > Шаблоны
              > Для user_name MySQL шаблоны не поддерживает.
              > Для host_name можно определять различные шаблоны
                > Например:
                  > user_name@'%.example.com'
                  > user_name@'192.168.1.%'
          > Создание анонимного пользователя
            > Создать анонимного пользователя можно с помощью операции GRANT, передав в качестве
              user_name пустую строку. Например:
                GRANT ALL ON test.* TO ''@'localhost' ...
            > Любой, кто попробует подключиться с этого хоста, как анонимный пользователь,
              и укажет верный пароль, сможет подключиться с этого аккаунта.
            > Внимание! Если имеется аккаунт для анонимного юзера на хосте localhost, то
              аккаунты для не анонимных юзеров тоже должны быть созданы для этого хоста, например,
              user_name@localhost, иначе при попытке подключиться с не анонимного аккаунта с хоста
              localhost подключение произойдет с анонимного аккаунта.
              > Чтобы избежать этой проблемы, можно удалить пользователя-анонимуса на хосте localhost:
                  SELECT Host, User FROM mysql.user WHERE User='';
                  DROP USER ''@'localhost';
        > Атрибуты IDENTIFIED BY и IDENTIFIED WITH
          > Определяют, как пользователь должен быть аутентифицирован при подключении к серверу.
          > Синтаксис тот же самый, что для CREATE TABLE

      > Прочие свойства аккаунта
        > Атрибут WITH
          > У него несколько предназначений:
            > Разрешить этому пользователю управлять привилегиями других пользователей.
            > Указать ограничения на ресурсы для этого пользователя.
            > Указать, может ли (и как) пользователь использовать безопасные соединение на этом сервере.
          > WITH GRANT OPTION
            > Разрешает этому пользователю управлять привилегиями других пользователей
              на указанном уровне.
            > Имея привилегию GRANT OPTION, невозможно дать другому пользователю привилегию,
              которой у тебя нет.
            > Нужно очень осторожно раздавать эту привилегию. Ведь несколько пользователей,
              имеющие её, а также имеющие каждый свой набор привилегий, могут объединиться, и в сумме
              они будут иметь гораздо больше привилегий, чем им, возможно, запланировано было
              предоставить.
          > MAX_QUERIES_PER_HOUR count
            > Это податрибут атрибута WITH
            > Устанавливает MAX число запросов к серверу с этого аккаунта в час.
          > MAX_UPDATES_PER_HOUR count
            > Это податрибут атрибута WITH
            > Устанавливает MAX число изменений данных на этом сервере с этого аккаунта в час.
          > MAX_CONNECTIONS_PER_HOUR count
            > Это податрибут атрибута WITH
            > Устанавливает MAX число соединений с сервером с этого аккаунта в час.
          > MAX_USER_CONNECTIONS count
            > Это податрибут атрибута WITH
            > Устанавливает MAX число одновременных соединений с сервером с использованием
              этого аккаунта.
            > Если не установлено, или == 0, то сервер берет значение из глобальной системной
              переменной max_user_connections.
          > GRANT USAGE
            > Чтобы изменить лимиты на ресурсы, которые может использовать аккаунт, без изменения
              привилегий аккаунта, можно использовать GRANT USAGE на глобальном уровне.
              Указать надо только те лимиты, которые требуется изменить.
            > Например:
                GRANT USAGE ON *.* TO ...
                  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;
        >
        >
        >

    > Таблица прав, которые можно присвоить.
  Более подробное описание для каждого типа привилегии можно посмотреть по ссылке:
                    http://dev.mysql.com/doc/refman/5.6/en/grant.html#grant-database-privileges
      > ALL                     | присвоить все права на заданном уровне, кроме GRANT OPTION
      > ALTER                   | разрешить использовать операцию ALTER TABLE
      > ALTER ROUTINE           | разрешить изменять и удалять сохраняемые скрипты
      > CREATE                  | разрешать создавать БД и таблицы
      > CREATE ROUTINE          | разрешить создавать сохраняемые скрипты
      > CREATE TABLESPACE       | разрешить создавать, изменять, удалять tablespaces и log file groups
      > CREATE TEMPORARY TABLES | разрешить использовать операцию CREATE TEMPORARY TABLE
      > CREATE USER             | разрешить использоватть CREATE USER, DROP USER, RENAME USER, REVOKE ALL PRIVILEGES
      > CREATE VIEW             | разрешить создавать и изменять представления
      > DELETE                  | разрешить использовать операцию DELETE
      > DROP                    | разрешить удалять базы данных, таблицы и представления
      > EVENT                   | разрешить использование событий в Планировщике Событий
      > EXECUTE                 | разрешить исполнение сохраняемых скриптов
      > FILE                    | разрешить пользователю заставлять сервер читать/записывать файлы
      > GRANT OPTION            | разрешить пользователю присваивать/отбирать права у других аккаунтов
      > INDEX                   | разрешить создавать и удалять индексы
      > INSERT                  | разрешить использьвание INSERT
      > LOCK TABLES             | разрешить использовать LOCK TABLES для таблиц, для которых есть SELECT-права
      > PROCESS                 | разрешить просматривать процессы выражением SHOW PROCESSLIST
      > PROXY                   | разрешить user proxying
      > REFERENCES              | [не реализовано]
      > RELOAD                  | разрешить использование FLUSH-операций
      > REPLICATION CLIENT      | разрешить использование операций SHOW MASTER STATUS и SHOW SLAVE STATUS
      > REPLICATION SLAVE       | разрешить скопированным рабам читать события из бинарного лога хозяина
      > SELECT                  | разрешить использование SELECT
      > SHOW DATABASES          | разрешить использование SHOW DATABASES для просмотра всех БД
      > SHOW VIEW               | разрешить использование SHOW CREATE VIEW
      > SHUTDOWN                | разрешить использование mysqladmin shutdown
      > SUPER                   | разрешить использование прочих административных операций, таких как
                                  CHANGE MASTER TO, KILL, PURGE BINARY LOGS, SET GLOBAL и команды mysqladmin debug.
      > TRIGGER                 | разрешить операции по работе с триггерами
      > UPDATE                  | разрешить использование операции UPDATE
      > USAGE                   | синоним для "без привелегий".

    > Синтаксис:
                          GRANT
                              priv_type [(column_list)]
                                [, priv_type [(column_list)]] ...
                              ON [object_type] priv_level
                              TO user_specification [, user_specification] ...
                              [REQUIRE {NONE | ssl_option [[AND] ssl_option] ...}]
                              [WITH with_option ...]

                          GRANT PROXY ON user_specification
                              TO user_specification [, user_specification] ...
                              [WITH GRANT OPTION]

                          object_type:
                              TABLE
                            | FUNCTION
                            | PROCEDURE

                          priv_level:
                              *
                            | *.*
                            | db_name.*
                            | db_name.tbl_name
                            | tbl_name
                            | db_name.routine_name

                          user_specification:
                              user
                              [
                                  IDENTIFIED BY [PASSWORD] 'password'
                                | IDENTIFIED WITH auth_plugin [AS 'auth_string']
                              ]

                          ssl_option:
                              SSL
                            | X509
                            | CIPHER 'cipher'
                            | ISSUER 'issuer'
                            | SUBJECT 'subject'

                          with_option:
                              GRANT OPTION
                            | MAX_QUERIES_PER_HOUR count
                            | MAX_UPDATES_PER_HOUR count
                            | MAX_CONNECTIONS_PER_HOUR count
                            | MAX_USER_CONNECTIONS count

  > RENAME USER          | переименовать существующий аккаунт MySQL
    > Это выражение переименовывает существующий MySQL аккаунт.
    > Требуются глобальные права CREATE USER, или права UPDATE для базы данных mysql.
    > Можно одним выражением переименовать сразу несколько аккаунтов.
      > Ошибка будет в случае:
        > Если какой-нибудь из старых аккаунтов, который пытаются переименовать, не существует.
        > Если для нового аккаунта задано имя уже существующего аккаунта.
    > Привелегии
      > При переименовании передаются от старого аккаунта к новому аккаунтау.
      > Но есть проблема!
        > Сохраняемые программы и представления имеют в качестве значения атрибута DEFINER
          старого пользователя!
    > Пример:
        RENAME USER 'jeffrey'@'localhost' TO 'jeff'@'127.0.0.1';
      > Если имя хоста опускается, то вместо него автоматически используется строка '%'.
    > Синтаксис:
          RENAME USER old_user TO new_user
              [, old_user TO new_user] ...

  > REVOKE               | аннулировать права аккаунту MySQL
    > Это выражение позволяет отбирать права у аккаунтов MySQL. Противоположность GRANT,
      которое позволяет наоборот - наделять правами.
    > 1-й синтаксис
      > Пример:
          REVOKE INSERT ON *.* FROM 'jeffrey'@'localhost';
        > Если имя хоста опускается, то вместо него автоматически используется строка '%'.
      > priv_type и priv_level
        > Позволяют указать привилегии (priv_type) и уровень (priv_level) этих привилегий, которые
          требуется отобрать.
      > Для использования первого синтаксиса REVOKE, требуются права GRANT OPTION, а также
        использующий REVOKE должен сам иметь те привилегии, которые он хочет отобрать.
    > 2-й синтаксис
      > Используют, чтобы отобрать все привилегии у пользователя на всех уровнях: на глобальном,
        на уровне БД, на уровне таблицы, а также на уровне скрипта.
      > Для этого требуются права CREATE USER на глобальном уровне, или права UPDATE для
        базы данных mysql.
    > 3-й синтаксис
      > Отнять привилегию PROXY у пользователя.
    > Синтаксис:
                REVOKE
                    priv_type [(column_list)]
                      [, priv_type [(column_list)]] ...
                    ON [object_type] priv_level
                    FROM user [, user] ...

                REVOKE ALL PRIVILEGES, GRANT OPTION
                    FROM user [, user] ...

                REVOKE PROXY ON user
                    FROM user [, user] ...

  > SET PASSWORD         | задать пароль для аккаунта MySQL
    > Это выражение назначает проль для существующего указанного аккаунта сервера MySQL.
    > Если системная переменная read_only == ON (по умолчанию - OFF), то для выполнения
      SET PASSWORD понадобятся SUPER-права.
    > [FOR user]
      > Если [FOR user] не указан - т.е. не уточнен пользователь, которому назначить пароль,
        то пароль назначается тому, кто выполняет эту операцию - туда автоматически подставляется
        CURRENT_USER().
        > Любой не анонимный пользователь, который подключился к серверу, может сменить пароль
          на том аккаунте, с которого он подключился.
      > Если [FOR user] указан, и это не исполнитель выражения:
        > Требуются права UPDATE для таблицы mysql, чтобы выполнить такое выражение.
        > user
          > Должен быть дан в стандартном формате для пользователей MySQL:
             'user_name'@'host_name'
        > Пример:
            SET PASSWORD FOR 'bob'@'%.example.org' = PASSWORD('cleartext password');
          > Это выражение эквивалентно следующему выражению:
              UPDATE mysql.user SET Password=PASSWORD('cleartext password')
                WHERE User='bob' AND Host='%.example.org';
              FLUSH PRIVILEGES;
          > И еще один способ назначить пароль - это использовать GRANT:
              GRANT USAGE ON *.* TO 'bob'@'%.example.org' IDENTIFIED BY 'cleartext password';
    > В каком виде предоставить пароль:
      > Есть 3 варианта:
         > PASSWORD('Сюда вписать пароль (простой текст)');
           > Пример:
                   SET PASSWORD = PASSWORD('abcde');
         > OLD_PASSWORD('Сюда вписать пароль (простой текст)');
           > Пример:
                   SET PASSWORD = OLD_PASSWORD('abcde');
         > 'Сюда в писать готовый хэш пароля, полученный из хэш-функции PASSWORD()'
           > Пример:
                   SET PASSWORD = 'sdfgzdfghai4thaegiaergaeht';    -- это хэш пароля
    PASSWORD('cleartext password')
      > Использование этой хэш-функции
      > Пароль в виде обычного текста записывается на место cleartext password, и хэш-функция
        PASSWORD сохраняет хэш пароля.
    > Безопасность:
      > Если выполненные выражения SET PASSWORD записаны в логи сервера, или в файл с историей,
        такой как ~/.mysql_history, то это значит, что кто угодно может туда зайти и посмотреть
        все назначенные пароли в открытом тексте.
    > Синтаксис:
            SET PASSWORD [FOR user] =
                {
                    PASSWORD('cleartext password')
                  | OLD_PASSWORD('cleartext password')
                  | 'encrypted password'
                }

> Обслуживание таблиц
  > ANALYZE TABLE        | собрать статистику по запросам в таблице для их оптимизации
                           > если опция innodb_stats_persistent, то статистика собирается автоматом
    > Выражение позволяет собрать статистику по запросам, выполняемым по отношению к таблице/
      Собранная статистика позволяет оптимизатору находить наиболее оптимальный план
      выполнения для каждого запроса.
      > innodb_stats_persistent
        > Для движка INNODB, если эта системная переменная == ON, выражение ANALYZE TABLE
          автоматически запускается, как только содержимое таблицы притерпевает значетительные
          изменения (более, чем на 10%).
        > По умолчанию ON.
    > Работает с движками InnoDB, MyISAM, NDB.
    > Синтаксис:
          ANALYZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE
              tbl_name [, tbl_name] ...

  > CHECK TABLE          | проверить таблицу на наличие ошибок.
    > Проверяет таблицу (ы) на ошибки.
      > Также может обнаружить и ошибки для представлений. Такие как, например, что образующие
        представление таблицы больше не существуют.
    > Работает для таблиц на движках INNODB, MyISAM, ARCHIVE и CSV.
    > В каком виде возвращаются результаты проверки:
      > В виде 4-х колонок:
        > Table       | Имя таблицы
        > Op          | Всегда check
        > Msg_type    | status, error, info, note, or warning
        > Msg_text    | Информационное сообщение
    > option
      > FOR UPGRADE
        > Если указать, то проверяет, совместимы ли проверяемые таблицы с установленной
          версией MySQL.
      > QUICK
        > Если указать, не сканирует строки для проверки некорректных ссылок.
        > Работает для таблиц на движках INNODB и MyISAM, а также представлений.
      > FAST
        > Проверять только таблицы, которые не были правильно закрыты.
        > Работает для таблиц на движках MyISAM, а также представлений. Для INNODB - этот атрибут игнорируется.
      > CHANGED
        > Проверять только таблицы, которые изменились с момента прошлой проверки.
        > Для INNODB - игнорируется. Только для MyISAM.
      > MEDIUM
        > Сканирует строки, чтобы убедиться, что удаленные ссылки действительны. Также рассчитывает
          контрольные суммы для строк, и сравнивает их с уже рассчитанными контрольными суммами
          ключей.
        > Для INNODB - игнорируется. Только для MyISAM.
      > EXTENDED
        > Производит полный поиск ключа для всех ключей для каждой строки. Это позволяет убедиться
          в 100%-й целостности, но занимает много времени.
        > Для INNODB - игнорируется. Только для MyISAM.
    > Замечания для использования с INNODB:
      > Если CHECK TABLE нашел проблему в таблице на INNODB, сервер может вырубиться, чтобы
        предотвратить дальнейшее распространение проблемы. Инфа об этом попадет в error log.
      > Если CHECK TABLE находит повреждение или ошибку в таблице на INNODB или индексе,
        он докладывае об ошибке. Он не выключает сервер. Начиная с MySQL 5.5, CHECK TABLE
        обычно помечает индекс, и иногда помечает таблицу, как поврежденную, предотвращая
        дальнейшее использование этого индекса или таблицы.
      > Если CHECK TABLE найдет неправильное число записей во вторичном индексе, он сообщит
        об ошибке, но не выключит сервер, и не запретит доступ к файлу.
      > Сначала CHECK TABLE обследует структуру индекса страницы, затем каждую запись.
      > Когда таблица INNODB сохранена в своем собственном .ibd файле (опция innodb_file_per_table
        включена), первые 3 страницы файла .ibd содержат заголовочную информацию, а не данные
        таблицы. CHECK TABLE не обнаруживает проблемы, которые касаются только этой заголовочной
        информации. Чтобы обнаруживать и эти проблемы, использовать команду innochecksum.
      > Если запустить CHECK TABLE на большой INNODB-таблице, другие потоки могут быть заблокированы
        во время выполнения этой команды. Чтобы избежать таймаута, для операции CHECK TABLE
        он расширен со стандартный 600 секунд до 7200 секунд (2 часов).
        > После того, как INNODB увидит, что прошло уже 240 секунд или больше, он начинает
          отправлять данные в error log
    > Синтаксис:
            CHECK TABLE tbl_name [, tbl_name] ... [option] ...

            option = {FOR UPGRADE | QUICK | FAST | MEDIUM | EXTENDED | CHANGED}

  > CHECKSUM TABLE       | получить контрольную сумму для содержимого таблицы
    > Выражение вычисляет контрольную сумму контента таблицы. Её можно использовать для того,
      чтобы убедиться в том, что контент тот же, до и после бэкапа, ролбэка, или других
      операций, предназначенных для помещения блока данных в известное состояние.
    > Требует SELECT-права для выполнения.
    >
    > Синтаксис:
        CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]

  > OPTIMIZE TABLE       | реорганизует физич. хранение данных в таблице для уменьшения их размера и ускорения доступа
    > Выражение реорганизует физическое хранение данных в таблице и связанных с ней индексов,
      чтобы уменьшить занимаемое данными дисковое пространство у улучшить I/0 эффективность
      при работе с ними. Конкретные производимые изменения зависят от движка таблицы.
    >
    > Синтаксис:
              OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE
                  tbl_name [, tbl_name] ...

  > REPAIR TABLE         | отремонтировать поврежденную таблицу
    > Чинит поврежденную таблицу
    > Применяется только к таблицам на движках MyISAM, ARCHIVE и CSV.
    > Синтаксис:
        REPAIR [NO_WRITE_TO_BINLOG | LOCAL] TABLE
            tbl_name [, tbl_name] ...
            [QUICK] [EXTENDED] [USE_FRM]

> Создание-удаление пользовательских функций
  > CREATE FUNCTION
    > Общая информация
      > Определенные пользователем функции (UDF - user-defined functions) - способ дополнить MySQL
        новыми функциями, которые работают также, как встроенные MySQL функции, такие как
        ABS() или CONCAT().
      > UDF пишутся на языке C или C++.
      > Для создания фукнции необходимы права INSERT для базы данных mysql.
        > При выполнении выражения CREATE FUNCTION в таблицу mysql.func добавляется запись,
          содержащая имя функции, тип и путь к файлу с реализацией.
      > Активная функция - которая была создана выражением CREATE FUNCTION, и не была удалена
        выражением DROP FUNCTION. Все активные функции перезагружаются после каждого перезапуска
        сервера.
    > function_name
      > Имя функции, которое должно будет использоваться для вызова этой функции.
    > Атрибут RETURNS
      > Указывает тип значения, которое возвращает функция.
      > В настоящее время DECIMAL - это псевдоним для STRING.
    > shared_library_name
      > Путь к файлу, который содержит код, который реализует функцию.
      > Файл должен находиться в директории для plugin'ов, путь к которой можно посмотреть
        в системной переменной plugin_dir.
      >
    > Синтаксис:
            CREATE [AGGREGATE] FUNCTION function_name RETURNS {STRING|INTEGER|REAL|DECIMAL}
              SONAME shared_library_name

  > DROP FUNCTION
    > Удаляет функцию UDF.
    > Для выполнения требуются права DELETE для базы данных mysql.
    > Синтаксис:
          DROP FUNCTION function_name

> Синтаксис операции SET - пользовательские переменные @x
  > Выражение SET устанавливает значения разным типам переменных, которые касаются работы
    сервера или твоего клиента.
  > SET может быть использован для присвоения значений следующим типам переменных:
    > Системные переменные.
    > Определенные пользователем переменные.
    > Параметры сохраняемых процедур и функций, а также локальные переменныех сохраняемых программ.
    > SET CHARACTER SET и SET NAMES назначает значения для character set и collation текущего
      соединения с сервером.
    > SET PASSWORD - назначает пароль для аккаунта MySQL.
    > SET TRANSACTION ISOLATION LEVEL - назначает уровень изоляции для транзакций.
  > Пользовательские переменные:
    > В имени пользовательской переменной используется символ @ - он должен стоять перед
      именем, например @var_name.
    > Синтаксис объявления пользовательской переменной:
        SET @var_name = expr;
    > Виды пользовательских переменных:
      > Глобальные                 | GLOBAL
        > Например: SET GLOBAL @var_namr = expr;
      > Локальные                  | LOCAL
        > Например: SET LOCAL @var_namr = expr;
      > Сессионные (по умолчанию)  | SESSION
        > SET SESSION @var_namr = expr;
    > На пользовательские переменные можно ссылаться в выражениях, квалифицируя их с помощью
      @@global или @@session, что указывает на их вид. Например:
        SELECT @@global.sql_mode, @@session.sql_mode, @@sql_mode;
    > Некоторые переменные, которые отображаются выражением SHOW VARIABLES, могут быть не доступны
      для использования в выражении вроде SELECT @@var_name, будет возникать ошибка
      Unknown system variable. В таком случае надо использовать другой синтаксис:
      SHOW VARIABLES LIKE 'var_name'.
    > Динамические пользовательские переменные:
      > Многие системные переменные - динамические, и могут быть назначены с помощью операции SET
        во время работы сервера.
      > Подробнее о динамических переменных и их список здесь:
          http://dev.mysql.com/doc/refman/5.6/en/dynamic-system-variables.html
    > 1 операция SET может содержать много определений переменных, разделенные между
      собой запятыми.
    > Как сохраняются изменения переменных:
      > Если изменить с помощью SET сессионную системную переменную, то измененное значение
        у нее будет оставаться лишь до конца сессии.
      > Если изменить с помощью SET глобальную системную переменную, значение сохраняется и
        используется для всех новых соединений до тех пор, пока сервер не будет перезапущен.
        > А чтобы сделать такое изменение системной переменной постоянным, требуется прописать
          её и её значение в конфигурационном файле my.ini.
      > Чтобы предотвратить неправильное использование, MySQL выдает ошибку, если использовать
        SET GLOBAL для переменных, для которых можно использовать только SET SESSION.
    > Примеры определения пользовательских переменных:
          SET sort_buffer_size=10000;
          SET @@local.sort_buffer_size=10000;
          SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;
          SET @@sort_buffer_size=1000000;
          SET @@global.sort_buffer_size=1000000, @@local.sort_buffer_size=1000000;

  > Синтаксис:
            SET variable_assignment [, variable_assignment] ...

            variable_assignment:
                  user_var_name = expr
                | [GLOBAL | SESSION] system_var_name = expr
                | [@@global. | @@session. | @@]system_var_name = expr

> Синтаксис операций SHOW
  > Общая информация:
    > SHOW является дополнением СУБД MySQL.
    > У операции SHOW есть много форм. Эта операция может показать информацию о базах данных,
      таблицах, столбцах, информацию о состоянии сервера.
    > В тех синтаксисах операции SHOW, где встречается LIKE 'pattern', pattern - это строка,
      которая может содержать шаблонные SQL-символы '%' и '_'. Такое паттерн палезен для
      ограничения возвращаемой информации соответствующей паттерну.
    > Некоторые из синтаксисов SHOW также поддерживают атрибут WHERE, которые позволяет указать
      желанные для вывода строки.
    > Многие API к MySQL требуют относиться к полученной из SHOW информации так, как будто
      она получена с помощью SELECT. А таким API относится и PHP.
  > Описание всех возможных синтаксисов операции SHOW:
    > SHOW AUTHORS (удалено, начиная с MySQL > 5.6.8.)
      > Отображает информацию о разработчиках сервера MySQL.
    > SHOW {BINARY | MASTER} LOGS
      > Показывает список binary logs на сервере. Атрибуты BINARY и MASTER эквивалентны.
    > SHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
      > Показывает события в binary log. Если не указать log_name, то показывает первый binary log.
      > Атрибут LIMIT - имеет то же значение, что для SELECT.
    > SHOW CHARACTER SET [LIKE 'pattern' | WHERE expr]
      > Показывает все character set и их collation по умолчанию.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW COLLATION [like_or_where]
      > Показывает список collation, поддерживаемых сервером.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW [FULL] COLUMNS {FROM | IN} tbl_name [{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr]
      > Показывает информацию о колонках в выбранной таблице. Также работает для представлений.
      > Атрибут LIKE указывает, какие колонки выбрать.
    > SHOW CONTRIBUTORS (удалено, начиная с MySQ> 5.6.8.)
      > Отображает информацию о тех, кто способствовал написанию кода MySQL.
    > SHOW CREATE DATABASE [IF NOT EXISTS] db_name
      > Показывает выражение CREATE DATABASE, с помощью которого была создана указанная база данных.
      > Если включить атрибут IF NOT EXISTS, то вывод тоже будет его иметь.
    > SHOW CREATE EVENT event_name
      > Показывает выражение CREATE EVENT, с помощью которого было создано событие, и можно его пересоздать.
      > Требуются права EVENT для базы данных, к которой прикреплено событие.
    > SHOW CREATE FUNCTION func_name
      > Показывает выражение CREATE FUNCTION, с помощью которого была создана функция, и можно её пересоздать.
      > Требуется быть DEFINER'ом этой функции, или иметь права SELECT на таблицу mysql.proc.
    > SHOW CREATE PROCEDURE proc_name
      > Показывает выражение CREATE PROCEDURE, с помощью которого была создана процедура, и можно её пересоздать.
      > Требуется быть DEFINER'ом этой процедуры, или иметь права SELECT на таблицу mysql.proc.
    > SHOW CREATE TABLE tbl_name
      > Показывает выражение CREATE TABLE, которое было использовано для создания указанной таблицы.
        Также работает с представлениями. Чтобы воспользоваться, надо иметь какие-нибудь права для этой таблицы.
    > SHOW CREATE TRIGGER trigger_name
      > Показывает выражение CREATE TRIGGER, которое было использовано для создания указанного триггера.
    > SHOW CREATE VIEW view_name
      > Показывает выражение CREATE VIEW, которое было использовано для создания указанного представления.
      > Требует права SELECT для этого представления, а также права SHOW VIEW.
    > SHOW DATABASES [LIKE 'pattern' | WHERE expr]
      > Показывает список всех баз данных на этом сервере MySQL.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW ENGINE engine_name {STATUS | MUTEX}
      > Показывает информацию о выбранном движке хранилища информации.
      > В настоящий момент поддерживаются следующие выражения:
          SHOW ENGINE INNODB STATUS
          SHOW ENGINE INNODB MUTEX
          SHOW ENGINE {NDB | NDBCLUSTER} STATUS
          SHOW ENGINE PERFORMANCE_SCHEMA STATUS
    > SHOW [STORAGE] ENGINES
      > Показывает список из информационных блоков о каждом движке, который поддерживается сервером.
      > Полезно для того, чтобы определить, поддерживается ли конкретный движок сервером, и какой движок
        установлен по умолчанию.
    > SHOW ERRORS [LIMIT [offset,] row_count]
      > Показывает информацию о возникших ошибках.
      > У атрибута LIMIT то же значение, что и для выражения SELECT.
    > SHOW COUNT(*) ERRORS
      > Показывает количество возникших ошибок.
    > SHOW EVENTS [{FROM | IN} schema_name] [LIKE 'pattern' | WHERE expr]
      > Отображает информацию о событиях в планировщике событий.
      > Требуются EVENT-права для баз данных, события которых будут отображены.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW FUNCTION CODE func_name
      > Показывает код в теле сохраняемой функции.
    > SHOW FUNCTION STATUS [LIKE 'pattern' | WHERE expr]
      > Возвращают свойства функции - имя, даты создания/модификации, кто DEFINER, кодировки, collations и пр.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW GRANTS FOR user
      > Показывает список выражений GRANT, которые были использованы для назазначения привилегий
        указанному пользователю, и могут быть использованы для повторного их назначения.
      > Чтобы выполняющий выражения мог посмотреть свои привилегии, он может использовать это выражение:
          SHOW GRANTS FOR CURRENT_USER();
      > Требует права SELECT для базы данных mysql, кроме случая, когда пользователь смотри свои привилегии.
    > SHOW INDEX  {INDEX | INDEXES | KEYS} {FROM | IN} tbl_name [{FROM | IN} db_name] [WHERE expr]
      > Возвращает информацию об индексе таблицы.
      > WHERE позволяет отфильтровать результаты.
    > SHOW MASTER STATUS
      > Показывает информацию о состоянии файлов binary log.
      > Требует права SUPER или REPLICATION CLIENT.
    > SHOW OPEN TABLES [{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr]
      > Показывает список не временных таблиц, которые в настоящий момент откркты
        в табличном кэше. См. http://dev.mysql.com/doc/refman/5.6/en/table-cache.html
    > SHOW PLUGINS
      > Показывает список установленных на сервер плагинов и информацию о них.
    > SHOW PROCEDURE CODE proc_name
      > Показывает код в теле сохраняемой процедуры.
    > SHOW PROCEDURE STATUS [like_or_where]
      > Возвращают свойства процедуры - имя, даты создания/модификации, кто DEFINER, кодировки, collations и пр.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW PRIVILEGES
      > Показывает список привилегий, которые поддерживает сервер, и их описание.
    > SHOW [FULL] PROCESSLIST
      > Показывает работающие потоки.
      > Если есть привилегия PROCESS, то можно увидеть всепотоки. В противном случае - только свои.
      > Если атрибут FULL не использован, то будут показаны только первые 100 символов от каждого
        выражения в столбце Info.
      > Очень полезно для определения причины ошибки "too many connections" - так можно обнаружить,
        в чем проблема.
      > Поток может быть убит с помощью выражения KILL.
    > SHOW PROFILE [type [, type] ... ] [FOR QUERY n] [LIMIT row_count [OFFSET offset]]
      > Показывает количество указанного типа type ресурсов, которые были израсходованы
        выполненными в течение этой сессии выражениями.
      > Возможные типы type:
        ALL | BLOCK IO | CONTEXT SWITCHES | CPU | IPC | MEMORY | PAGE FAULTS | SOURCE | SWAPS
    > SHOW PROFILES
      > Тоже самое, что SHOW PROFILE, только для всех типов ресурсов.
    > SHOW RELAYLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
      > Показывает события в relay log of a replication slave
    > SHOW SLAVE HOSTS
      > Показывает список репликационных slave'ов, зарегистрированных в настоящее время на master'e.
    > SHOW SLAVE STATUS
      > Показывает информацию о состоянии по основным свойствам потоков slave'a.
      > Требует права: SUPER или REPLICATION CLIENT.
    > SHOW [GLOBAL | SESSION] STATUS [LIKE 'pattern' | WHERE expr]
      > Показывает информацию о состоянии сервера.
      > С атрибутом GLOBAL - показывает значения свойств для всех подключений к MySQL.
      > С атрибутом SESSION - показывает значения свойств только для текущего подключения.
      > LIKE и WHERE позволяют отфильтровать результат.
    > SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern' | WHERE expr]
      > Показывает информацию о не временной таблице, более подробную, чем SHOW TABLES.
    > SHOW [FULL] TABLES [FROM db_name] [like_or_where]
      > Показывает список не временных таблиц из указанной БД и информацию о них.
      > Если атрибут FULL указан, то выдает более полную информацию.
    > SHOW TRIGGERS [FROM db_name] [LIKE 'pattern' | WHERE expr]
      > Показывает список триггеров, определенных в настоящее время для таблиц в указанной БД.
      > Возвращает результат только для тех БД и таблиц, для которых есть привиления TRIGGER.
    > SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]
      > Показывает значение системных переменных MySQL.
      > С атрибутом GLOBAL - показывает значения, которые применяются к каждому новому подключению к MySQL.
      > С атриубтом SESSION ( по умолчанию) - показывает значения, которые действуют только на текущее подключение.
    > SHOW WARNINGS [LIMIT [offset,] row_count]
      > Показывает информацию о возникших предупреждениях.
      > У атрибута LIMIT то же значение, что и для выражения SELECT.

> Прочие административные операции
  > BINLOG 'str'            | для внутреннего использования в программе mysqlbinlog
    > -
  > CACHE INDEX             | (только MyISAM) назначает индексу таблицы указанный key кэш.
    > -
  > FLUSH [NO_WRITE_TO_BINLOG | LOCAL] flush_option [, flush_option] ...
    > Чистит и перезагружает некие внутренние кэши, чистит таблицу, приобретает блоки.
    > Для выполнения требуются привилегия RELOAD. Для использования некоторых атрибутов
      могут потребоваться доп. привилегии.
  > KILL [CONNECTION | QUERY] thread_id
    > Закрывает соединение или текущий выполняемый запрос.
    > Каждое подключение к mysqld работает, как отдельный поток. Все работающие потоки можно
      посмотреть с помощью выражения SHOW PROCESSLIST.
    > KILL CONNECTION (по умолчанию) - закрывает поток thread_id.
    > KILL QUERY - завершает запрос, который исполняется в настоящий момент, но оставляет соединение.
    > Когда выражение KILL применяется к потоку, то поток помечается спецециальным флагом, что
      он должен быть уничтожен. Но уничтожение может произойти не сразу, потому что фгал проверяется
      сервером только в следующих случаях.
  > LOAD INDEX INTO CACHE   | (только MyISAM)
    > Заренее загружает индекс таблицы в key кэш, который был назначен явным выполнением
      выражения CACHE INDEX, или в key кэш по умолчанию (если не был назначен).
  > RESET reset_option [, reset_option] ...
    > Используется, чтобы очистить состояние разных операций сервера.
    > Требуется привилегия RESET для использования этого выражения.
    > Оно работает, как более сильная версия FLUSH.
    > Вызывает неявный COMMIT.
    > reset_option
      > MASTER
        > Удаляет все бинарные логи, перечисленные в файле index, очищает и делает пустым сам
          index файл бинарного лога, и создает новый файл бинарного лога.
      > QUERY CACHE
        > Удаляет все результаты запросов из кэша запросов (query cache).
      > SLAVE
        > Заставляет slave забыть его позицию репликации в бинарных логах мастера. Также,
          сбрасывает ralay log, удаляя все существующие файлы этого лога и создавая новый.



#############
Утилиты MySQL

> DESCRIBE         | (синоним EXPLAIN)
> EXPLAIN          | получить информацию о структуре таблицы или плане выполнения запроса
  > Чаще всего используется для того, чтобы получить информацию о структуре таблицы.
    Также может быть использовано для получения плана выполнения запроса.
  > Работает также для представлений.
  > [col_name | wild]
    > По умолчанию выражение отображает информацию обо всех колонках.
    > Однако, можно задать либо конкретную колонку, либо шаблон aka LIKE для поиска по именам колонок.
  > Синтаксис:
              {EXPLAIN | DESCRIBE | DESC}
                  tbl_name [col_name | wild]

              {EXPLAIN | DESCRIBE | DESC}
                  [explain_type]
                  explainable_stmt

              explain_type: {
                  EXTENDED
                | PARTITIONS
                | FORMAT = format_name
              }

              format_name: {
                  TRADITIONAL
                | JSON
              }

              explainable_stmt: {
                  SELECT statement
                | DELETE statement
                | INSERT statement
                | REPLACE statement
                | UPDATE statement
              }

> HELP 'search_string'     | ищет информацию в online справки сервера MySQL по указанной строке поиска
  > Выражение HELP ищет таблицы из руководства, отвечающие заданной строке поиска search_string,
    и отображает результат на экране. Строка поиска регистронезависима.
  > Строка поиска может содержать шаблонные символы "%" и "_". Они имеют то же значение, что
    при работе с атрибутом LIKE.
    > Например, 'rep%' возвращает список тем, начинающихся на 'rep'.
  > Выражение HELP принимает несколько спец. команд:
    > HELP 'contents'
      > Выводит оглавление руководства самого высокого уровня.
    > HELP 'data types'
      > Чтобы вывести информацию из конкретного пункта справочного руководства, нужно
        ввести название этого пункта.
        > Например, выражение HELP 'contents' выводит среди прочих и пункт 'data types',
          и чтобы вывести содержимое этого пункта, надо ввести выржение HELP 'data types'
    > HELP 'ascii', HELP 'create table'
      > Аналогично

> USE db_name      | позволяет выбрать базу данных по умолчанию
  > Выбранная по умолчанию база данных остается таковой до конца сессии, или пока она
    не будет изменена выполнением другого выражения USE.
  > Выбор базы данных по умолчанию означает, что в любом выражении имена таблиц и других
    сущностей, которые могут требовать квалификации именем базы данных, по умолчанию квалифицированны
    именем базы данных по умолчанию.
    > Однако, если требуется выбрать таблицу из БД не по умолчанию, то можно квалифицировать
      эту таблицу именем этой БД, и то, что ранее было использовано USE - никак этому не мешает.



-------------------------------------------------- */















