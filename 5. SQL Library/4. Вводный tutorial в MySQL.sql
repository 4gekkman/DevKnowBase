/* --------------------------------------------------
---------------- О Г Л А В Л Е Н И Е ----------------
4. Вводный tutorial в MySQL


> Примеры ввода запросов
  > Запросить вывод версии и текущей даты
  > Запросить вывод версии и текущей даты (запрос разбит на несколько строк)
  > Пример математ. вычислений на SQL
  > Пример математ. вычислений на SQL (ввод 2-х запросов в 1 строку через ; )


> Создание/удаление баз данных и таблиц; получение информации о структуре таблиц
  > Показать какие БД уже есть на сервере           | SHOW DATABASES;
  > Указать, какую БД использовать по умолчанию     | USE [db_name];
  > Создать новую базу данных                       | CREATE DATABASE [db_name];
  > Вывести все таблицы выбранной базы данных       | SHOW TABLES;
  > Создать таблицу                                 | CREATE TABLE
  > Удалить таблицу                                 | DROP TABLE [tbl_name];
  > Вывести информацию о макете таблицы             | DESCRIBE [tbl_name];
  > Загрузить в таблицу данные из файла             | LOAD DATA
  > Вставить данные в таблицу                       | INSERT


> Извлечение/изменения данных из/в таблиц(ах)
  > Извлечь все данные из таблицы                   | SELECT *
  > Исправить сущесвующую в запись в таблице        | UPDATE

  > Извлечь определенные строки (удовл-ие условиям) | SELECT * WHERE ...
    > Извлечь все строки, в которых species='cat'
    > Извлечь все строки, в которых species='dog' и sex='m'
    > Извлечь все строки, в которых (и задаём условие для 2-х наборов строк):
      - (species='cat' и sex='f')    | это будет один набор строк
      - species='bird'               | это будет другой набор строк
    > Извлечь строку о животном, которого зовут Bowser (name='Bowser')
    > Извлечь все строки о животных, родившихся после 01.01.1990 (birth > '1990-01-01')

  > Извлечь определенные столбцы                    | SELECT [column_names]
    > Извлечь 2 столбца (owner, species) из таблицы
    > Извлечь столбец без повторений значений       | DISTINCT
    > Извлечь определенные столбцы, и из них строки, отвечающие условиям

  > Сортировка извлеченных данных                   | ORDER BY
    > Сортировка по дате
    > Сортировка в возрастающем и убывающем порядке | ASC, DESC
    > Сортировка с зависимостью от регистра и без неё (для символьных значений)   | ORDER BY BINARY
    > Сортировка одновременно по нескольким колонкам


> Работа с датами
  > Получить текущую дату                           | CURDATE()
  > Назначить псевдоним для имени колонки           | SELECT [clm_name] AS здесь_псевдоним
  > Получить разницу между 2-мя датами в указанных единицах  | TIMESTAMPDIFF()
  > Метод сравнения NULL с другими значениями       | IS NOT NULL
  > Извлечь из даты год, месяц и число              | YEAR(), MONTH(), DAYOFMONTH()
  > Проблема перехода между 12-ым и 1-ым месяцами
    > Добавить к указанной дате указанный интервал времени функцией DATE_ADD
    > Добавить к указанной дате указанный интервал времени с использованием оператора MOD


> Работа с типом NULL
  > Проверить, является ли значение NULL'ом         | [some_value] IS NULL
  > Проверить, является ли значение НЕ NULL'ом      | [some_value] IS NOT NULL


> Извлечение данных с использованием фильтров: LIKE и RegExp
  > Использование оператора LIKE (паттернов MySQL)  | LIKE, NOT LIKE
    > Извлечь все строки, в которых name начинается с буквы 'b'
    > Извлечь все строки, в которых name заканчивается буквами 'fy'
    > Извлечь все строки, в которых name содержит букву 'w'
    > Извлечь все строки, в которых name имеет длину ровно 5 символов

  > Использование регулярных выражений POSIX        | REGEXP, NOT REGEXP
    > Извлечь все строки, в которых name начинается с буквы 'b' (регистронезависимо)
    > Извлечь все строки, в которых name начинается с маленькой буквы 'b' (регистрозависимо)
    > Извлечь все строки, в которых name заканчивается на fy
    > Извлечь все строки, в которых name содержит w
    > Извлечь все строки, в которых name состоит ровно из 5 любых символов


> Подсчет строк с группировкой по указанному признаку
  > Вывести количество строк в таблице              | COUNT(*)
  > Совместное использование COUNT и GROUP BY       | COUNT(*) ... GROUP BY
    > Сколько животных у каждого хозяина (GROUP BY owner)
    > Сколько животных каждого вида (GROUP BY species)
    > Сколько животных каждого пола (GROUP BY sex)
    > Сколько животных каждой комбинации вида и пола (GROUP BY species, sex)
    > Сколько котов и собак каждой комбинации вида и пола
    > Сколько животных с известным полом (не NULL) каждой комбинации вида и пола


> Извлечение данных одновременно из нескольких таблиц
  > Извлечение данных из 2-х разных таблиц          | INNER JOIN ... ON
    > Вернуть 5 самых правых символов в строке      | RIGHT()
    > Узнать, в каком возрасте каждый питомец обзавелся потомством
  > Извлечение данных из нескольких одинаковых таблиц (JOIN) таблицы с самой собой
    > Найти подходящие по виду и полу пары для размножения


> Примеры типовых запросов и наиболее общих проблем при работе с MySQL
  > Создание учебной базы данных для демонстрации примеров
    > Создание базы
    > Выбор это базы данных для использования по умолчанию
    > Создание таблицы
    > Загрузка данных в таблицу
    > Посмотреть, успешно ли удалось создать таблицу с даннными?

  > Примеры
    > Найти максимальное значений в колонке
    > Вернуть строку, содержащую MAX значение для указанной колонки
    > Максимальные значения колонки для каждой из групп
    > Все строки для каждой из групп, содержащие MAX значения указанной колонки
    > Найти 2 строки с MIN и MAX значениями цены с помощью пользовательских переменных
    > Использование автоинкримента









-------------------------------------------------- */


-- Примеры ввода запросов

  -- Запросить вывод версии и текущей даты
    SELECT VERSION(), CURRENT_DATE();

    -- Запросить вывод версии и текущей даты (запрос разбит на несколько строк)
    SELECT
      VERSION(),
      CURRENT_DATE();

    -- Пример математ. вычислений на SQL
    SELECT SIN(PI()/4), (4+1)*5;

    -- Пример математ. вычислений на SQL (ввод 2-х запросов в 1 строку через ; )
    SELECT SIN(PI()/4); SELECT (4+1)*5;


-- Создание/удаление баз данных и таблиц; получение информации о структуре таблиц

  -- Показать какие БД уже есть на сервере
  SHOW DATABASES;

  -- Указать, какую БД использовать по умолчанию
  USE test;

  -- Создать новую базу данных
  CREATE DATABASE menagerie;

  -- Вывести все таблицы выбранной базы данных
  SHOW TABLES;

  -- Создать таблицу pet с колонками name, owner, species, sex, birth, and death.
  CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);

  -- Удалить таблицу pet
  DROP TABLE pet;

  -- Вывести информацию о макете таблицы
  DESCRIBE pet;

  -- Загрузить в таблицу данные из файла
  LOAD DATA LOCAL INFILE "C:/Users/Administrator/Desktop/Practice/4. SQL Library/Вспомогательные данные/data_to_load_in_table"
    INTO TABLE pet COLUMNS TERMINATED BY ';';

  -- Вставить данные в таблицу
  INSERT INTO pet
      VALUES('Whistler','Gwen',	'bird', NULL,	'1997-12-09', NULL);


-- Извлечение/изменения данных из/в таблиц(ах)

  -- Извлечь все данные из таблицы
  SELECT * FROM pet;

  -- Исправить сущесвующую в запись в таблице
  UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';

  -- Извлечь определенные строки (удовлетворяющие условиям)

    -- Извлечь все строки, в которых species='cat'
    SELECT * FROM pet WHERE species='cat';

    -- Извлечь все строки, в которых species='dog' и sex='m'
    SELECT * FROM pet WHERE species='dog' AND sex='m';

    -- Извлечь все строки, в которых (и задаём условие для 2-х наборов строк):
    -- - (species='cat' и sex='f')    | это будет один набор строк
    -- - species='bird'               | это будет другой набор строк
    SELECT * FROM pet WHERE (species='cat' AND sex='f') OR species='bird';

    -- Извлечь строку о животном, которого зовут Bowser (name='Bowser')
    SELECT * FROM pet WHERE name='Bowser';

    -- Извлесь все строки о животных, родившихся после 01.01.1990 (birth > '1990-01-01')
    SELECT * FROM pet WHERE birth > '1990-01-01';


  -- Извлечь определенные столбцы

    -- Извлечь 2 столбца (owner, species) из таблицы
    SELECT owner, species FROM pet;

    -- Извлечь столбец без повторений значений
    SELECT DISTINCT owner FROM pet;

    -- Извлечь определенные столбцы, и из них строки, отвечающие условиям
    SELECT name, species, birth FROM pet
      WHERE species='cat' OR species='dog';


  -- Сортировка извлеченных данных

    -- Сортировка по дате
    SELECT name, birth FROM pet ORDER BY birth;

    -- Сортировка в возрастающем и убывающем порядке

      -- В возрастающем (по умолчанию) - сверху меньше, чем снизу
      SELECT * FROM pet ORDER BY birth ASC;   -- ASC можно не писать, оно есть по умолчанию

      -- В убывающем - сверху больше, чем снизу
      SELECT * FROM pet ORDER BY birth DESC;

    -- Сортировка с зависимостью от регистра и без неё (для символьных значений)

      -- С зависимостью от регистра
      SELECT * FROM pet ORDER BY BINARY name;

      -- Без зависимости от регистра от регистра
      SELECT * FROM pet ORDER BY name;

    -- Сортировка одновременно по нескольким колонкам (см. информацию снизу)
    SELECT name, species, birth FROM pet
                                       ORDER BY species, birth DESC;


-- Работа с датами

  -- Получить текущую дату
  SELECT CURDATE();

  -- Назначить псевдоним для имени колонки
  SELECT CURDATE() AS 'Текущая дата';

  -- Получить разницу между 2-мя датами в указанных единицах
  SELECT name, birth,
    CURDATE() AS 'Текущая дата',
    TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS 'Возраст'
      FROM pet;

  -- Метод сравнения NULL с другими значениями
  SELECT name, birth, death,
    TIMESTAMPDIFF(YEAR,birth,death) AS Возраст
    FROM pet WHERE death IS NOT NULL ORDER BY Возраст;

  -- Извлечь из даты год, месяц и число
  SELECT name, birth,
    YEAR(birth) AS Год,
    MONTH(birth) AS Месяц,
    DAYOFMONTH(birth) AS День
  FROM pet;

  -- Проблема перехода между 12-ым и 1-ым месяцами

    -- Добавить к указанной дате указанный интервал времени функцией DATE_ADD
       -- (и найти всех животных, у которых ДР в следующем месяце)
    SELECT name, birth FROM pet
      WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(), INTERVAL 1 MONTH));

    -- Добавить к указанной дате указанный интервал времени с использованием оператора MOD
    SELECT name, birth FROM pet
      WHERE MONTH(birth) = MOD(MONTH(CURDATE()),12) + 1;


-- Работа с типом NULL

  -- Проверить, является ли значение NULL'ом
  SELECT 1 IS NULL;                          -- если да, то вернет 1; иначе 0.

  -- Проверить, является ли значение НЕ NULL'ом
  SELECT 1 IS NOT NULL;                      -- если да, то вернет 1; иначе 0.


-- Извлечение данных с использованием фильтров: LIKE и RegExp

  -- Использование оператора LIKE (паттернов MySQL)

    -- Извлечь все строки, в которых name начинается с буквы 'b'
    SELECT * FROM pet WHERE name LIKE 'b%';

    -- Извлечь все строки, в которых name заканчивается буквами 'fy'
    SELECT * FROM pet WHERE name LIKE '%fy';

    -- Извлечь все строки, в которых name содержит букву 'w'
    SELECT * FROM pet WHERE name LIKE '%w%';

    -- Извлечь все строки, в которых name имеет длину ровно 5 символов
    SELECT * FROM pet WHERE name LIKE '_____';


  -- Использование регулярных выражений POSIX

    -- Извлечь все строки, в которых name начинается с буквы 'b' (регистронезависимо)
    SELECT * FROM pet WHERE name REGEXP '^b';

    -- Извлечь все строки, в которых name начинается с маленькой буквы 'b' (регистрозависимо)
    SELECT * FROM pet WHERE name REGEXP BINARY '^b';

    -- Извлечь все строки, в которых name заканчивается на fy
    SELECT * FROM pet WHERE name REGEXP 'fy$';

    -- Извлечь все строки, в которых name содержит w
    SELECT * FROM pet WHERE name REGEXP 'w';

    -- Извлечь все строки, в которых name состоит ровно из 5 любых символов
    SELECT * FROM pet WHERE name REGEXP '^.....$';
    SELECT * FROM pet WHERE name REGEXP '^.{5}$';


-- Подсчет строк с группировкой по указанному признаку

  -- Вывести количество строк в таблице
  SELECT COUNT(*) from pet;

  -- Совместное использование COUNT и GROUP BY

    -- Сколько животных у каждого хозяина (GROUP BY owner)
    SELECT owner, COUNT(*) FROM pet GROUP BY owner;

    -- Сколько животных каждого вида (GROUP BY species)
    SELECT species, COUNT(*) FROM pet GROUP BY species;

    -- Сколько животных каждого пола (GROUP BY sex)
    SELECT sex, COUNT(*) FROM pet GROUP BY sex;

    -- Сколько животных каждой комбинации вида и пола (GROUP BY species, sex)
    SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;

    -- Сколько котов и собак каждой комбинации вида и пола
    SELECT species, sex, COUNT(*) FROM pet
      WHERE species='dog' OR species='cat'
      GROUP BY species, sex;

    -- Сколько животных с известным полом (не NULL) каждой комбинации вида и пола
    SELECT species, sex, COUNT(*) FROM pet
      WHERE sex IS NOT NULL
      GROUP BY species, sex;


-- Извлечение данных одновременно из нескольких таблиц

  -- Создать еще одну таблицу для экспериментов

    -- Создать таблицу
    CREATE TABLE event (name VARCHAR(20), date DATE,
      type VARCHAR(15), remark VARCHAR(255));

    -- Загрузить в нее данные
    LOAD DATA LOCAL INFILE "C:/Users/Administrator/Desktop/Practice/4. SQL Library/Вспомогательные данные/data_to_load_in_table 2"
      INTO TABLE event COLUMNS TERMINATED BY ';';

  -- Извлечение данных из 2-х разных таблиц

    -- Вернуть 5 самых правых символов в строке
    SELECT RIGHT('Вселенная',5);

    -- Узнать, в каком возрасте каждый питомец обзавелся потомством
    SELECT pet.name,
        (YEAR(date)-YEAR(birth)) - (RIGHT(date,5)<RIGHT(birth,5)) AS age,
        remark
        FROM pet INNER JOIN event
        ON pet.name = event.name
        WHERE event.type = 'litter';

  -- Извлечение данных из нескольких одинаковых таблиц
  --   (join таблицы с самой собой)

    -- Найти подходящие по виду и полу пары для размножения
    SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    FROM pet AS p1 INNER JOIN pet AS p2
    ON p1.species = p2.species AND p1.sex = 'f' AND p2.sex = 'm';


-- Примеры типовых запросов и наиболее общих проблем при работе с MySQL

  -- Создание учебной базы данных для демонстрации примеров

    -- Создание базы
    CREATE DATABASE articles;

    -- Выбор это базы данных для использования по умолчанию
    USE articles;

    -- Создание таблицы
    CREATE TABLE shop (
      article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
      dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
      price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
      PRIMARY KEY(article, dealer));

    -- Загрузка данных в таблицу
    INSERT INTO shop VALUES
    (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
    (3,'C',1.69),(3,'D',1.25),(4,'D',19.95);

    -- Посмотреть, успешно ли удалось создать таблицу с даннными?
    SELECT * FROM shop;

  -- Примеры

    -- Найти максимальное значений в колонке
        SELECT MAX(article) FROM shop;

    -- Вернуть строку, содержащую MAX значение для указанной колонки
    -- (найти номер, диллера и цену самой дорогой статьи из всех)

      -- Решение 1 - воспользоваться подзапросом
      SELECT article, dealer, price
      FROM shop
      WHERE price=(SELECT MAX(price) FROM shop);

      -- Решение 2 - использовать LEFT JOIN (я не понимаю, как это работает)
      SELECT s1.article, s1.dealer, s1.price
      FROM shop s1
        LEFT JOIN shop s2 ON s1.price < s2.price
      WHERE s2.article IS NULL;

      -- Решение 3 - отсортировать по убыванию и взять первую строку с помощью LIMIT.
      SELECT article, dealer, price
      FROM shop
      ORDER BY price DESC
      LIMIT 1;


    -- Максимальные значения колонки для каждой из групп
    -- (найти самую высокую цену для каждой статьи)
    SELECT article, MAX(price)
    FROM shop
    GROUP BY article;

    -- Все строки для каждой из групп, содержащие MAX значения указанной колонки
    -- (для каждой статьи найти диллера или диллеров с самой дорогой ценой)
    -- (отличается от примера выше тем, что может вернуть несколько диллеров с одинаковой ценой)

      -- Способ 1. С помощью correlated subquery.
      SELECT article, dealer, price
      FROM   shop s1
      WHERE  price=(SELECT MAX(s2.price)
                    FROM shop s2
                    WHERE s1.article = s2.article);

      -- Способ 2. С помощью Uncorrelated subquery.
      SELECT s1.article, dealer, s1.price
      FROM shop s1
        JOIN (
               SELECT article, MAX(price) AS price
               FROM shop
               GROUP BY article) AS s2
          ON s1.article = s2.article AND s1.price = s2.price;

      -- Способ 3. С помощью LEFT JOIN.
      SELECT s1.article, s1.dealer, s1.price
      FROM shop s1
        LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price < s2.price
      WHERE s2.article IS NULL;

    -- Найти 2 строки с MIN и MAX значениями цены с помощью пользовательских переменных

      -- Сначала найти MIN и MAX значения цены и сохранить их в пользовательских переменных
      SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;

      -- Теперь, используя найденные выше переменные, запросить соответствующие строки
      SELECT * FROM shop WHERE price=@min_price OR price=@max_price;

    -- Об использовании внешних ключей: FOREIGN KEYS (в движках INNODB) и
    -- REFERENCES (в движках НЕ INNODB).

      -- Использование REFERENCES

        -- Создать и выбрать по умолчанию учебную базу данных clothes
        CREATE DATABASE clothes;
        USE clothes;

        -- Создать одну таблицу. Здесь колонка id - имеет PRIMARY KEY.
        CREATE TABLE person (
          id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
          name CHAR(60) NOT NULL,
          PRIMARY KEY (id)
        );

        -- Создать другую таблицу с колонкой owner, помеченной как REFERENCES
        -- (связанной) с колонкой id таблицы person. Столбец id помечен, как авто-инкриментный.
        CREATE TABLE shirt (
          id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
          style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
          color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
          owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
          PRIMARY KEY (id)
        );

        -- Вставить в таблицу person значение. PRIMARY KEY назначится автоматически.
        INSERT INTO person VALUES (NULL, 'Antonio Paz');

        -- Записать в переменную @last номер последного автоматически сгенерированного ID
        SELECT @last := LAST_INSERT_ID();

        -- Вставить данные в таблицу shirt. Здесь 4-й столбей owner как раз связан со
        -- столбцом id таблицы person.
        INSERT INTO shirt VALUES
        (NULL, 'polo', 'blue', @last),
        (NULL, 'dress', 'white', @last),
        (NULL, 't-shirt', 'blue', @last);

        -- Вставить в таблицу person еще одно значение. PRIMARY KEY назначится автоматически.
        INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');

        -- Записать в переменную @last номер последного автоматически сгенерированного ID
        SELECT @last := LAST_INSERT_ID();

        -- Вставить еще данные в таблицу shirt. Здесь 4-й столбей owner как раз связан со
        -- столбцом id таблицы person.
        INSERT INTO shirt VALUES
        (NULL, 'dress', 'orange', @last),
        (NULL, 'polo', 'red', @last),
        (NULL, 'dress', 'blue', @last),
        (NULL, 't-shirt', 'white', @last);

        -- Посмотреть содержимое таблиц person и shirt
        SELECT * FROM person;
        SELECT * FROM shirt;

    -- Использование автоинкримента

      -- Создать таблицу с автоинкриментным столбцом id (в ДБ TEST)
      CREATE TABLE animals (
        id MEDIUMINT NOT NULL AUTO_INCREMENT,
        name CHAR(30) NOT NULL,
        PRIMARY KEY (id)
      );

      -- Вставить в таблицу 6 значений
      INSERT INTO animals (name) VALUES
      ('dog'),('cat'),('penguin'),
      ('lax'),('whale'),('ostrich');

      -- Вывести содержимое таблицы и увидеть, как каждому значению в столбце
      -- id был автоматически назначен инкримент
      SELECT * FROM animals;


/* --------------------------------------------------
---------------- И Н Ф О Р М А Ц И Я ----------------


Ссылки:

  > Официальный вводный tutorial в MySQL:
         http://dev.mysql.com/doc/refman/5.6/en/tutorial.html

  > Репозиторий доп. функций для MySQL. Также содержит готовую к импорту
    в MySQL библиотеку PCRE регулярных выражений:
         http://www.mysqludf.org/



*****************************************************
Оглавление:


  > 4.1. Соединение/отключение c/от сервером(а)
  > 4.2. В)вод запросов
    > Общая информация об SQL-запросах
    > Где можно вводить SQL-запросы
    > Возможные состояния строки prompt программы mysql shell, и их значения
  > 4.3. Создание и использование баз данных
  > 4.4. Извлечение данных из таблиц
  > 4.4.5. Работа с датами
  > 4.4.6. Работа с NULL значениями
  > 4.4.7. Извлечение данных с использованием RegExp в качестве фильтра
  > 4.4.8. Подсчет строк с группировкой по указанному признаку
  > 4.4.9. Извлечение данных одновременно из нескольких таблиц
  > 4.5. Есть 2 режима работы с MySQL: интерактивный и пакетный
    > Интерактивный режим
    > Пакетный режим
      > Что такое пакетный режим
      > Чем полезны SQL-скрипты?
      > Как выполнить SQL-скрипт из файла
  > 4.6. Об использовании внешних ключей



*****************************************************



Вводный tutorial в MySQL

4.1. Соединение/отключение c/от сервером(а)
> Подключиться к серверу MySQL можно с помощью какой-нибудь клиентской программы.
  Например, можно использовать идущую в комплекте mysql shell (см. 2. Работа с mysql shell)
> Для подключения понадобятся данные, требуемые для аутентификации. Это:
  user, password и host (если сервер находится на удаленной машине). Эти
  данным можно вводить разными способами:
  > Способ 1. Добавить соответствующие опции в конфигурационный файл my.ini
              в группу [mysql]. (см. 2. Работа с mysql shell)
  > Способ 2. Запустить mysql shell с соответствующими опциями. (см. 2. Работа с mysql shell)
  > Способ 3. Использовать зашифрованный файл .mylogin.ini, содержащий данные
              для аутентификации (см. 3. Работа с утилитой mysql_config_editor)

4.2. Ввод запросов
> Общая информация об SQL-запросах
  > Запрос обычно состоит из SQL выражения и точки с запятой в конце.
    Если ; отсутствует в конце запроса (кроме некоторых исключений), и нажать
    ENTER, то mysql shell не отправляет написанное на сервер, а ожидает дальнейшего
    ввода этого запроса, который в итоге должен закончитсья точкой с запятой.
    > Если mysql shell ожидает дальнейшего продолжения ввода этого запроса, то
      его строка prompt выглядит так: "->", а не как обычно (по умочанию): "mysql>".
    > Если нужно отменить ввод всего текущего запроса, то можно
      воспользоваться одной из команд mysql shell:
        clear  или  \c  или нажать  CTRL + C
  > После отправки запроса на сервер MySQL, он выводит результат, затем выводит
    строку prompt (по умолчанию: "mysql>"), что символизирует о его готовности принять
    новую команду (такая prompt строка есть у mysql shell).
  > mysql shell выводит результат запроса в виде таблицы.
    > Обычно, заголовками колонок служат заголовки колонок таблицы,
      из которой делается выборка данных.
    > Но если запрос извлекает значение из выражения (как в примере
      "Запросить вывод версии и текущей даты"), а не из таблицы, то
      заголовки колонок в таблице вывода - это эти выражения.
  > mysql shell после результата выводит также доп. информацию:
    > Сколько строк было возвращено в качестве результата.
    > Как долго выполнялся запрос
      > Эта информация поможет судить о быстродействии работы сервера.
  > Ключевые слова SQL не чувствительны к регистру. Однако принято писать
    их большими буквами.
> Где можно вводить SQL-запросы
  > Вводить запросы можно в любом клиенте, подключенным к серверу MySQL. Например:
  > В mysql shell
  > В Workbench
  > В PHPStorm
    > Как подключиться к серверу MySQL из PHPStorm описано в
      "1. Установка, настройка, обновление сервера MySQL".
    > После успешного подключения нужно открыть консоль базы данных, для
      этого требуется открыть вкладку Database справа, и нажать сверху кнопочку
      Console (либо просто нажать CTRL + SHIFT + F10).
      > Консоль появится в виде одной из вкладок сверху. Имя вкладки будет совпадать
        со значением, заданным в свойстве Data Source Name в настройках этого
        подключения.
      > В нижней части всего окна также есть вкладка Database Console - там будет отображаться
        вывод, а также доступна история запросов и ряд других параметров.
    > Чтобы послать запрос из открытой в предыдущем пункте консоли, требуется:
      1. Ввести 1 или более запросов.
      2. Выбрать, какой запрос или запросы требуется выполнить:
         > Если нужно выполнить 1 запрос, требуется установить на него курсор.
         > Если нужно выполнить несколько запросов, требуется выделить их курсором мыши.
      3. нажать на зеленый треугольничек слева сверху (либо CTRL + ENTER)
> Возможные состояния строки prompt программы mysql shell, и их значения
  >   mysql>   | готов к вводу новой команды
                 > надпись mysql - идет по умолчанию, ее  можно поменять на другую строку
                   определенного формата командой prompt (см. 2. Работа с mysql shell).
  >       ->   | жду следующую строку многострочной команды
  >       '>   |  жду следующую строку многострочной команды - жду закрытия строки, которая
                  началась с одиночной кавычки
  >       ">   | жду следующую строку многострочной команды - жду закрытия строки, которая
                  началась с двойной кавычки
  >       `>   | жду следующую строку многострочной команды - жду закрытия идентификатора,
                  который начался с символа backtick `
  >      /*>   | жду следующую строку многострочной команды - жду закрытия комментария,
                  который начался с /*

4.3. Создание и использование баз данных
> Этот пункт показывает, как совершать следующие операции:
  > Создать базу данных
    > CREATE DATABASE [db_name];  | создать БД
    > SHOW DATABASES;             | вывести список доступных БД
  > Создать таблицу
    > CREATE TABLE [tbl_name];    | создать таблицу в выбранной БД
    > SHOW TABLES;                | вывести список всех таблиц выбранной БД
    > DESCRIBE [tbl_name];        | вывести структуру таблицы
  > Загрузить данные в таблицу
    > LOAD DATA
    > INSERT
  > Извлечь данные из таблицы разными способами
  > Использоать несколько таблиц
> В UNIX названия баз данных регистрочувствительны. "Mybase" и "mybase" - разные базы.
> Если при попытке совершить операцию, например - создать базу данных - в ответ
  возвращается ошибка ERROR 1044 (42000), значит у учетной записи, с которой
  осуществлено подключение, нет достаточных прав для этой операции.
  > Чтобы получить права администратора на сервере MySQL, и иметь возможность манипулировать
    базами данных, можно авторизоваться с помощью логина "root":
      mysql -uroot

4.4. Извлечение данных из таблиц
> Результат извлечения данных из таблиц - тоже таблица.
> Для извлечения данных используется оператор SELECT:
  > Общий синтаксис следующий:
      SELECT what_to_select
      FROM which_table
      WHERE conditions_to_satisfy;
    Где:
    > what_to_select         | список колонок или * (все колонки)
    > which_table            | таблица, из которой требуется извлечь данные
    > conditions_to_satisfy  | условия, которым должна удовлетворять каждая строка, чтобы она попала в вывод
> Извлеченный результат можно отсортировать с помощью оператора ORDER BY
  > Сортировка символьных значений регистронезависимая по умолчанию.
    > Но можно сделать ее регистрозависимой, если к ORDER BY добавить BINARY. То есть:
      ORDER BY BINARY
  > По умолчанию сортировка произоводится по возрастанию (ASCENDING).
    > Но можно добавить команду DESC после имени столбца, и тогда сортировка
      будет производиться по убыванию.
  > Сортировку в одной таблице - результате запроса - можно производить одновременно
    по нескольким столбцам. Происходит это так:
    1. Сначала сортировка производится по первому из указанных столбцов.
    2. Затем по второму, но так, чтобы результат не противоречил первой сортировки.
    3. Затем по третьему, и так далее.

4.4.5. Работа с датами
> При работе с датами есть типичная проблема при переходе от 12-ого к 1-му месяцу.
  Ее можно решить 2-мя способами:
  > Добавлять к выбранной дате интервал времени с помощью функции DATE_ADD().
  > Использовать оператор MOD
    > MOD(что-то,12) возвращает число от 0 до 11. Поэтому после MOD требуется добавлять
      1, ведь номера месяцев с 1 по 12. MONTH() возвращает число с 1 до 12.
      MOD(MONTH(),12) + 1 возвращает число с 1 до 12.

4.4.6. Работа с NULL значениями
> NULL - это специальный тип, который может вести себя неожиданно, если не знать,
  как с ним работать. Концептуально, NULL - отсутствующее неизвестное значение.
  NULL рассматривается, как нечто отличное от остальных типов значений.
> Как сравнивать NULL значения с другими?
  > Нельзя использовать для этого арифметические операторы, такие как =, <, <> ...
    Поскольку результатом любого выражения сравнения с NULL будет NULL.
  > Для проверки значения на NULL используют операторы IF NULL и IF NOT NULL (см. примеры выше).
> Булева логика в MySQL следующая:
  > TRUE           | это все, что не FALSE (по умолчанию TRUE-значение - это 1)
  > FALSE          | это NULL и 0
> NULL значения в GROUP BY рассматриваются, как равные.
> Если делать сортировку значений ASC, то все NULL значения идут первыми;
  а если сортировка DESC, то NULL значения идут последними.
> Общая ошибка при работе с NULL значениями состоит в том, чтобы считать невозможным
  вставить 0 или '' в колонку, обозначенную как NOT NULL. На самом деле их можно
  туда вставить. Ведь NULL - означает буквально "не имеет значения". А 0 и '' -
  это есть значения.

4.4.7. Извлечение данных с использованием RegExp в качестве фильтра
> MySQL поддерживает 2 вида регулярных выражений:
  > Встроенные в MySQL паттерны. У него есть всего несколько элементов, по сути
    это довольно ущербный инструмент.
    > Для использования этой возможности можно воспользоваться операторами
      LIKE и NOT LIKE.
    > Паттерны регистронезависимы.
    > Нельзя использовать = или <>, если используются SQL паттерны.
    >  _  | совпадает с любым 1-м символом
    >  %  | совпадает с любым количеством любых символов
  > Регулярные выражения POSIX.
    > Однако, RegExp'ы POSIX уже устарели, сейчас в тренде PCRE. Возникает вопрос,
      как использовать PCRE в MySQL, если он их изначально не поддерживает?
      > Ответ - скачать библиотеку PCRE отсюда:
          http://www.mysqludf.org/
    > Для использования POSIX regexp'ов, можно воспользоваться операторами
      REGEXP и NOT REGEXP.
    > Регулярные выражения POSIX в MySQL регистронезависимы.
      > Если нужно произвести извлечение данных через фильтр этих регулярных
        выражений, и требуется сделать их регистрозависимыми, то можно использовать
        ключевое слово BINARY.

4.4.8. Подсчет строк с группировкой по указанному признаку
> Часто требуется ответить на вопросы, сколько строк всего в таблице,
  или, например, сколькью животными владеет каждый хозяин? Сделать это
  помогает оператор COUNT.
  > Совместное использование COUNT и GROUP BY позволяет для каждого элемента
    из столбца, указанного в GROUP BY подсчитать, в скольки строках,
    подсчитанных с помощью COUNT, есть этот элемент.
    > В этом случае, если в выражении указываются имена колонок, из котрых требуется
      извлечь информацию, они же должны быть указаны после ORDER BY. Иначе:
      > Если режим ONLY_FULL_GROUP_BY включен, то следующее выражение вызовет ошибку:
          SELECT col_a, col_b, COUNT(*) FROM table;
        Чтобы ошибки не возникло, оно должно выглядеть так:
          SELECT col_a, col_b, COUNT(*) FROM table ORDER BY col_a, col_b;
      > Если режим ONLY_FULL_GROUP_BY выключен, то оба выражения выше не вызовут ошибки.

4.4.9. Извлечение данных одновременно из нескольких таблиц
> Часто приходится извлекать информацию и формировать результирующую таблицу
  из 2-х и более таблиц. Для этого:
  > В операторе FROM используют INNER JOIN, чтобы позволить строкам из
    таблицы Y появиться в таблице X. Например: ... FROM x INNER JOIN y ...
  > После INNER JOIN [tbl_name] используют оператор ON, который позволяет
    указать, что значения из стобца X1 таблицы X должна совпадать со значениями
    из столбца X2 таблицы Y. По сути, это использование КЛЮЧЕВОГО СТОЛБЦА.
    Например: ... INNER JOIN y ON X.X1 = Y.Y1 ...
    > Если в столбце Y1 будут строки со значениями, которых нет в X1, то эти
      строки не попадут в результирующую таблицу.
  > При написании выражения, извлекающего данные из нескольких таблиц, если
    в этих таблицах есть столбцы с одинаковыми именами, то в выражении при
    использовании этих столбцов следует уточнять, какой таблице они принадлежать.
    Например: вместо  [clmn_name]  писать  [tbl_name].[clmn_name]
> Join таблицы с самой собой:
  > Это может быть полезно, когда нужно сравнить данные из одной части таблицы X,
    с данными из другой части той же таблицы X. В этом случае можно произвести
    JOIN таблицы с самой собой.
    > Например, если требуется в левой части результирующией таблицы вывести
      питомцев-невест, а в правой - соответствующих им питомцев-женихов.


4.5. Есть 2 режима работы с MySQL: интерактивный и пакетный
> Есть 2 режима работы с MySQL:

  > Интерактивный режим
    > В этом режиме команды пишут прямо в mysql shell или другой клиент для сервера
      MySQL, получают ответ, снова пишут команды, и так далее.

  > Пакетный режим

    > Что такое пакетный режим
      > В этом режиме команды записывают в текстовый файл, то есть создают по сути скрипт.
        И затем в mysql shell или другом клиенте сервера MySQL пишут команду, приказывающую
        прочитать файл со скриптом и последовательно его выполнить.

    > Чем полезны SQL-скрипты?
      > Если какой-то запрос надо запускать периодически, то использование скрипта
        позволит не писать его каждый раз по-новой.
      > Можно создавать новые запросы, используя накопившиеся скрипты (копится база запросов).
      > Использовать скрипт очень удобно, когда пишешь большой запрос, в котором много
        строк.
      > Если результат запроса представляет собой большой массив информации, то можно
        получать вывод через pager:

          mysql < batch-file | more

      > Также вывод можно записать вывод в файл:

          mysql < batch-file > mysql.out

      > Можно передавать скрипт другим людям, которые тоже могут его использовать.
      > Иногда использовать интерактивный режим нельзя. И тогда остается только
        пакетный режим.

    > Как выполнить SQL-скрипт из файла
      > Выполнить файл со скриптом в пакетном режиме можно 2-мя способами:
        1. При установленном подключении с сервером MySQL из клиента mysql shell,
           можно исползовать команду:

              SOURCE file_name
              \. filename

           Здесь SOURCE и \. означают одно и то же.
           Подробнее об этом см. "2. Работа с mysql shell".
        2. При не установленном подключении с сервером MySQL, приказать серверу
           выполнить файл со скриптом прямо в команде установки соединения.
           Также можно указывать ряд доп. опций, влияющих на вывод, таких как -t и -vvv,
           или влияющих на выполнение, таких как --force. Подробнее - см. ниже.
           Примеры:

           Соединиться с MySQL и запустить скрипт из файла file_name:
           -----
              mysql < file_name


           Соединиться с MySQL, установить db_name как БД "по умолчанию", и запустить скрипт из файла file_name
           -----
              mysql db_name < file_name


           В пакетном режиме вывод будет более ущербным, чем в интерактивном. Но это можно поправить:
           - Чтобы сделать вывод в пакетном режиме такимже, как в интерактином, можно
             использовать команду -t. Например:
           -----
              mysql -t < file_name


           Чтобы в выводе присутствовали также выполняемые команды, можно использовать
           команду -vvv. Например:
           -----
              mysql -vvv < file_name


           Чтобы скрипт продолжал выполняться, даже если возникли ошибки, можно
           применить команду --force. Например:
           -----
              mysql --force < file_name


           Также, например, при подключении можно указать хост, логин и пароль:
           -----
              mysql -hhost -uuser -ppassword < file_name




4.6. Об использовании внешних ключей
> Есть 2 способа их использования:
  1. В таблицах на движках INNODB - использовать ключевые слова FOREIGN KEY
     для создания такого типа ключа и связи между колонками разных таблиц.
     При этом можно, например, сделать так, что если изменяеются значения в
     одной из колонок, то в другой такое-же изменение происходит автоматически.
     > Подробнее об INNODB:
         http://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html
     > Подробнее о FOREIGN KEYS:
         http://dev.mysql.com/doc/refman/5.6/en/ansi-diff-foreign-keys.html
  2. В таблицах НЕ на движках INNODB - использовать ключевое слово REFERENCES.
     Оно вообще ничего не делает, кроме как служит напоминанием - ставит метку
     на указанный столбец.
     > Ограничение с использованием внешних ключей не является обязательным для
       создания связи между таблицами. Ведь внешние ключи есть только у движка INNODB,
       и было бы странно, если бы что-то подобное нельзя было реализовать на других движках.
       А на них связи между таблицами можно настроить с помощью выражения:

         REFERENCES tbl_name(col_name)

       Оно не производит никакого эффекта. А служит лишь напоминанием того, что указанная
       колонка col_name помечена, как связанная с какой-то колонкой из другой таблицы.
       Об этом развернуто:
       > MySQL не проверяет, существует ли колонка "col_name" в таблице "tbl_name", и
         не проверяет даже существует ли сама таблица.
       > MySQL не производит с таблицей "tbl_name" никаких опираций, например - DELETE
         или UPDATE - в ответ на удаление или изменения значений из связанной таблицы.
         То есть такого поведения, как при включенных  ON DELETE  и  ON UPDATE в INNODB
         при наличии внешнего ключя, не наблюдается
       > Указанный синтаксис применяется при создании колонки в таблице, и по сути
         ничего не делает, а служит просто напоминанием и меткой. Он не создает никаких
         индексов и ключей (см. пример выше в блоке примеров)


-------------------------------------------------- */


















