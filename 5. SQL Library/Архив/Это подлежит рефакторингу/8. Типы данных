/* INFO
Про типы данных

-----------------
|---> ЧИСЛА <---|---------------------------------------------------
-----------------
                    | ---> INTEGER <--- |     S:signed, U: unsigned   точное значение
TINYINT    |  1 байт   |  S: -128 .. 127                |  U: 0 .. 255
SMALLINT   |  2 байта  |  S: -32768 .. 32768            |  U: 0 .. 65535
MEDIUMINT  |  3 байта  |  S: -8388608 .. 8388608        |  U: 0 .. 16777215
INT        |  4 байта  |  S: -2147483648 .. 2147483648  |  U: 0 .. 4294967295
BIGING     |  8 байт   |  S: -9223372036854775808 .. +..|  U: 0 .. 18446744073709551615

                    | ---> FIXED POINT TYPE <--- |     точное значение
-> SQL хранит целые числа, как десятичные
-> DECIMAL(x,y), x - кол-во символов в числе, y - кол-во символов после запятой
   DECIMAL = DECIMAL(10,0)  -  значение по умолчанию
-> max x = 65

                    | ---> FLOATING POINT TYPE <--- |
FLOAT   |  4 байта
DOUBLE  |  8 байт

                    | ---> АТРИБУТЫ ЧИСЛОВЫХ ЗНАЧЕНИЙ <--- |
SIGNED    |  число может быть + и -. Стоит у всех чисел по умолчанию.
UNSIGNED  |  число может быть только +.
ZEROFILL  |  5 типа int(4) = 0005. Заполняет свободные места нулями.
AUTO_INCREMENT  |  если такой атрибут есть у колонки, и в колонку записать 0,
                    то при следующей записи в нее автоматом подставится 1, и т.д.

                    | ---> ПРЕВЫШЕНИЕ МАХ ЗНАЧЕНИЯ <--- |
Что происходит, когда пытаешься записать число, вылезающее за границы
типа колонки?
1. Если в настройках включен строгий SQL   -   ОШИБКА
2. Если нет, то записывается MAX число диапазона.
Пример: записываю число 300 в UNSIGNED TINYINT (max 255). Получаю 255.




------------------
|---> СТРОКИ <---|--------------------------------------------------
------------------
                    | ---> CHAR  VARCHAR <--- |
-> все CHAR, VARCHAR и TEXT сравниваются без учета пробелов. Т.е. искать в базе
   значение 'John ' надо, как 'John'. Иначе не найдется.
   Также ключ 'John ' и ключ 'John' будут расценены как одинаковые, и будет
   ошибка о дублировании ключа.

              CHAR     |  0 .. 255   байт
-> незанятые байты занимает пробелами
-> CHAR(x)  x - МАХ кол-во байт
-> CHAR(10) 'abc       ' - все равно занимает 10 байт
-> обрезает все пробелы при извлечении

              VARCHAR  |  0 .. 65535 байт
-> незанятые байты ничто не занимает, так можно сэкономить место на диске:
   VARCHAR(10) 'abc' - занимает 4 байта
-> последний 1 (до 255 байт) или 2 байта (свыше 255 байт) занимает служебный
   символ.
-> не обрезает пробелы (если есть) при извлечении


                    | ---> BLOB  TEXT <--- |
-> если попробовать записать то, что не влезает в обозначенный тип данных,
   то это будет усечено (как в числах).
-> для TEXT, как и для чисел, отличающиеся только пробелами строки считаются
   одинаковыми.
-> не могут иметь DEFAULT значения
-> при сортировке задействованы только первые max_sort_lengt байт из-за больших размеров.
   По умолчанию 1024. Изменить: SET max_sort_length = 2000;
-> включение этих типов в запрос заставляет сервер использовать диск вместо
   памяти для оперативного хранения инфы, что ведет к потере скорости. Поэтому
   лучше этого неделать без необходимости, и избегать запросов по всем колонкам
   типа SELECT * ...

             BLOB - Binary Large OBject - большой бинарный объект.
-> может содержать что угодно в бинарном коде
-> сравнивается побайтно
             TEXT - строка символов.
-> Имеет кодировку. Сравнивается с другими в соответствии с назначенным
   данной колонке свойством COLLATION.


TINYTEXT    |  TINYBLOB   |  255 байт
TEXT        |  BLOB       |  65 535 байт
MEDIUMTEXT  |  MEDIUMBLOB |  16 777 215 байт
LONGTEXT    |  LONGBLOB   |  4 294 967 295 байт

                    | ---> ENUM <--- |
ENUM - строковый объект, значение которого равняется одному из однозначно
       определенных при создании данной колонки таблицы.
-> ENUM('x','y','z', ...)  так можно туда вставить 65535 значений (на практике
   менее 3000). В таблице может быть максимум 255 ENUM'ов + SET'ов
-> значениям автоматом присваиваются индексы: 1, 2, ...; в индексе 0 лежит инфа об ошибке.
-> значения отсортированы в том порядке, в котором были вставлены
-> ENUM не может использоваться в выражениях
-> нельзя использовать переменные для назначения значений в ENUM

-> если запросить значение ENUM в числовом контексте, то вернется число-индекс.
   Например: SELECT myEnum+0 FROM myTable;
-> колонкам типа ENUM можно назначить кодировку и COLLATION
-> !!! в ENUM лучше не использовать значения-числа, иначе получится бардак.
   (см. подробнее справку на оф. сайте)!!!
-> '' и NULL могут быть значениями ENUM

                    | ---> SET <--- |
SET - строковый объект, в котором 0 или больше значений, которые однозначно
      определяются при создании данной колонки таблицы.
-> в отличие от ENUM, SET может выдавать не только 1 значение за раз,
   а любую комбинацию своих значений в строку через запятую.
   Пример: SET('один', 'два') может иметь следующие значения:
   1) ''   2) 'один'  3) 'два'  4) 'один,два'
-> поэтому любое значение SET не должно содержать в себе запятую ','.
-> SET может содержать МАХ 64 значения, в таблице МАХ 255 SET'ов + ENUM'ов.
-> пробелы автоматом удаляются из значений, дублирование значений вызывает предупреждение
-> колонкам типа SET можно назначить кодировку и COLLATION
-> если запросить значение SET в числовом контексте, то вернется число бит,
   занимаемых значением SET в данной ячейке.
   Например: SELECT mySet+0 FROM myTable;
-> если попробовать запихнуть число в SET, то он определит, как оно выглядит
   в двоичном коде, и найдет соответствующие ему значения в этом SET,
   их и запишет.
-> На каждый SET есть количество занимаемых бит и его двоичный код.




------------------------             Date And Time == DAT
|---> ДАТА И ВРЕМЯ <---|------------------------------------------------
------------------------
-> Есть следующие типы данных, относящиеся к дате и времени:
   Т И П Ы         Z E R O                F O R M A T                 R A N G E
1) DATE       |  '0000-00-00'          |  YYYY-MM-DD     |  1000-01-01 .. 9999.12.31
2) DATETIME   |  '0000-00-00 00:00:00' |  -//- HH:MM:SS  |  -//- 00:00:00 .. -//- 23:59:59
3) TIME       |  '00:00:00'            |  HHH:MM:SS      |  -838:59:59 .. 838:59:59
4) TIMESTAMP  |  '0000-00-00 00:00:00' |  секунд прошло с 1970.01.01 00:00:00 (UTC)  |  1970.01.01 00:00:00 .. 2038.01.19 03:14:07
5) YEAR       |  '0000'                |  YYYY или YY    |  1901 .. 2155 или 0 .. 99

-> У всех у них есть значение 'zero', означает неправильное значение, которое
   MySQL не может интерпретировать. Когда MySQL сталкивается со значением типа DAT,
   которое выходит за рамки, или неправильное, ему присваивается 'zero'.
   Исключение: значения типа time.
-> Дату надо записывать в формате year-month-day
-> Год лучше записывать в 4-х значном формате yyyy, избегая двусмысленности.
   Иначе '10:11:12' может быть распознано, как 2010-11-12. Облом!!
-> Месяц и дата должны быть правильные. Если нет, сервер запишет 'zero'
   и выдаст предупреждение.
-> Если DAT тип используется в числовом контексте, он автомато преобразуется в число, и наоборот.
-> Можно отменить верификацию дат yy-mm-dd сервером, тогда он будет проверять
   только mm. Для этого надо изменить параметр ALLOW_INVALID_DATES.
-> mm и dd можно в типах DATE и DATETIME можно делать 00, если включен
   параметр NO_ZERO_IN_DATE (по умолчанию да)
-> 'zero' можно назначит, написав дату так: 0000-00-00.
   Это у них называется 'dummy date'.
-> 'zero' даты, проходя через Connector/ODBC, превращаются в NULL.

                    | ---> DATETIME и TIMESTAMP <--- |
-> Могут содержать до 6 символов - микросекунд после секунд. Формат:
  'YYYY-MM-DD HH:MM:SS.fraction'
-> Автоматом обновляются до текущих даты и времени.
-> TIMESTAMP для хранения конвертируется из текущей временной зоны в UTC,
   а при запросе обратно.
-> !! Опасность !! Если сохранить TIMESTAMP в базу, затем поменять временную
   зону на сервере, и запросить значение - оно будет уже не тоРТ!
-> Не может быть значений типа TIMESTAMP, сожержащих 00 дату или месяц.
   Кроме значения 'zero'.

                    | ---> TIME <--- |
-> интервал может быть такой большой (-838:59:59 .. 838:59:59), потому что TIME
   может выражать не только текущее время, но и интервал между событиями.
-> Могут содержать до 6 символов - микросекунд после секунд. Формат:
  'HHH:MM:SS.fraction'

*/

-- пример работы SET
USE test;
CREATE TABLE mYset (col SET('a', 'b', 'c', 'd'));  -- создать таблицу с колонкой типа SET
INSERT INTO myset (col)  -- вставить в колонку типа SET значения
  VALUES
  ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
SELECT col FROM myset;  -- посмотреть, что получилось
/* а получилось:
('a,d'), ('a,d'), ('a,d'), ('a,d'), ('a,d')
 */
