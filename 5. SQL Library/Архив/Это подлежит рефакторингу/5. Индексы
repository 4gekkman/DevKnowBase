/* INFO
Про индексы

-- -----------> Зачем нужны индексы и как работают
> Реляционные БД изначально ориентированы на операции
   OLTP (Online Transaction Processing) - способ организации БД,
   при котором система работает с небольшими по размеру транзакциями,
   но идущими большим потоком, при этом клиенту требуется от системы
   минимальное время отклика.
> И не ориентированы на операции OLAP (online analytical processing) -
   технология обработки данных, заключающаяся в подготовке суммарной
   (агрегированной) информации на основе больших массивов данных,
   структурированных по многомерному принципу.
> Индексы ускоряют работу реляционных БД с операциями OLAP.
   Но при этом замедляют работу с операциями OLTP.
   Так что в какой-то части БД надо ускорять одно и замедлять
   другое, в зависимости от задач.
> Индексы работают так. Сервер создает и держит в актуальном состоянии
   сортированую таблицу ключ-ссылка_на_данные. При добавлении данных
   они добавляются 1) по назначанию; 2) ссылка на них в эту таблицу.
   Когда требуется получить выборку, сервер методом деления пополам
   быстро ищет по ключу ссылки на нужные значения и выдает их.
> Эта таблица индексов может полностью не уместиться в памяти. Тогда
   следует применить прием Сбалансированное Дерево - разбить таблицу
   индексов на куски, и создать таблицу индексов 2-го уровня, содержащую
   ссылки на эти куски. И так можно делать до бесконечности.

-- -----------> Еще об индексах
> индекс это еще одно свойство таблицы
> традиционно индексы начинают на ix (ixName, ixPrice ... )
> индексы применяют к простым типам данных, иначе будет очень тяжело серверу
> индексы не надо применять тотально везде; только к отдельным колонкам отделных
  таблиц; потому что размер индексов соизмерим с размером данных в таблицах;
> у MySQL есть для тяжелых текстовых записей и BLOB есть отдельный
   Полнотекстовый Индекс (full text).

-- -----------> Куда эффективно расставлять индексы в БД
0. Хороший разработчик все запросы пишет в отдельных файлах SQL.
   Потому что потом можно легко их всех отредактировать и проставить
   индексы где надо. А также повторно использовать.
1. Надо индексировать связи.
2. На первичные ключи навешивать еще индексы не надо.
3. На внешние ключи, даже если их в реальности в базе нет, но логически
   они используются, нужно ставить индексы.
4. В фактографические таблицы - например, логи - куда постоянно записывается
   информация, индексы вставлять не надо. Такие таблицы лучше привести в
   1 нормальную форму и использовать движок MyISAM, т.к. он самый быстрый на запись.

*/

-- создаю табличку, для которой далее создам индекс
USE name1;
DROP TABLE IF EXISTS table4;
CREATE TABLE table4
(
  id INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Код товара',
  name VARCHAR(50) NOT NULL DEFAULT '' COMMENT 'Название товара',
  price FLOAT NOT NULL DEFAULT 0 COMMENT 'Цена товара',
  PRIMARY KEY (id)
) COMMENT 'Таблица тоаров с первичным ключом';

-- СПОСОБ 1 создать индекс (мне надо быстро искать цену по имени, например)
CREATE INDEX ixName ON table4 (name);
CREATE INDEX ixPrice ON table4 (price);
    -- можно и так: CREATE INDEX ixIdPrice ON table4 (id, price);
    -- с этого момента сервер автоматически управляет индексами

-- удалить индекс
DROP INDEX ixPrice ON table4;
DROP INDEX ixName ON table4;

-- СПОСОБ 2 создать индекс - при создании таблицы
DROP TABLE table4;   -- удалить таблицу
CREATE TABLE table4  -- пересоздать таблицу сразу с индексами
(
  id INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Код товара',
  code CHAR(4) NOT NULL DEFAULT 'AAAA' COMMENT 'Другой код товара',
  name VARCHAR(50) NOT NULL DEFAULT '' COMMENT 'Название товара',
  price FLOAT NOT NULL DEFAULT 0 COMMENT 'Цена товара',
  -- PRIMARY KEY (id),
  CONSTRAINT pkId PRIMARY KEY (id),    -- добавить ограничение, колонка id становится первичным ключем
  CONSTRAINT ixCode UNIQUE KEY (code), -- добавить ограничение, code становится ключем-кандидатом
  INDEX ixName(name),
  INDEX ixPrice(price)
) COMMENT 'Таблица тоаров с первичным ключом';



/* INFO
Про ограничения (CONSTRAINT)

- наличие PRIMARY KEY или UNIQUE KEY автоматом предусматривает наличие индекса
- для сервера KEYs - это ограничители-предохранители целостности данных
- ограничения тесно связаны с индексом
- ограничение - такой же объект, как index

- огнаничения:
-- PRIMARY KEY   |   первичный ключ
-- UNIQUE KEY    |   ключ-кандидат
-- FOREIGN KEY   |   внешний ключ
-- ENUM          |
-- SET           |

-> FOREIGN KEY в дочерней таблице должен всегда ссылаться только на PRIMARY KEY или
UNIQUE KEY в родительской таблице. На обычную колонку опереть его нельзя.
-> тип колонки с индексом в дочерней таблице должен быть равен типу колонки
с индексом в родительской таблице, на который ссылается первая.
-> в колонке, которая является внешним ключем в дочерней таблице,
при использовании FOREIGN KEY, индексы автоматически не создаются. Нужно
создавать их вручную

- связь таблиц с помощью FOREING KEY работает только на движке INNODB
*/

-- добавить строку в таблицу
INSERT INTO table4 (code, name, price)
    VALUES ('ZZZZ', 'Проба', 16.8);
SELECT * FROM table4; -- посмотреть результат

-- пробую добавить еще одну строку с code == 'ZZZZ'
INSERT INTO table4 (code, name, price)
  VALUES ('ZZZZ', 'Проба', 17.8);  -- ОШИБКА! Дублирование code, который создан
                                    -- как UNIQUE KEY (ключ-кандидат), и должен
                                    -- быть уникальным.

-- пример связи таблиц с ограничениями с помощью внешнего ключа
CREATE TABLE parent
(
  id INT NOT NULL,
  PRIMARY KEY (id)
) ENGINE=INNODB;
CREATE TABLE child
(
  id INT,
  parent_id INT,                      -- тип совпадает с типом (id) в parent
  INDEX parentIndex (parent_id),      -- вручную создаю индекс
  FOREIGN KEY (parent_id) REFERENCES  -- parent_id ссылается на PRIMARY KEY (id) в parent
    parent(id)
  ON DELETE CASCADE   -- если в parent удаляют запись, автомато удалить все соотв. записи из child
) ENGINE=INNODB;




















