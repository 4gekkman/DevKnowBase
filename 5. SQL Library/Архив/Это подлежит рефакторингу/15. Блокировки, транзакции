/* INFO
Темы:
1. Блокировки
2. Транзакции
3. Свойства ACID
4. Типы и выбор хранилищ в MySQL

--------------> Блокировки (устаревший; новый: транзакции)
Для чего нужны:
  - чтобы избежать одновременного выполнения конкурирующих запросов, серьезной
  проблемой является конкуренция серий запросов.
  Примечания:
  -- таблица блокируется, с ней делаю то, что мне надо, затем разблокирую.
  -- пока стоит мой блок, никто другой блок поставить не может.
  -- !!! Блокировка должна быть короткой, как выстрел, чтобы не повесить приложение.
Виды блокировок таблиц:
-> READ                |  блокировка на запись и изменение таблицы (читать можно)
-> WRITE               |  блокировка полностью (на запись и чтение)
-> READ LOCAL
-> LOW_PRIORITY WRITE
Блокировки записей:
-> SELECT GET_LOCK('mylock',5);
-> SELECT RELEASE_LOCK('mylock',5);


--------------> Транзакции
Это процесс, группа операций, которая может быть выполнена либо полностью
успешно, соблюдая целостность данных и независимо от параллельно идущих
других транзакций, либо не выполнена вообще и тогда она не должна произвести
никакого эффекта

Определить, является ли что-то транзацкией, можно с помощью ACID-теста:

1. Atomicity (атомарность): определяет, что транзакция является наименьшим,
неделимым бломок шагов алгоритма. Говоря другими словами, любые части
(подоперации) транзакции либо выполняются все одновременно, либо не выполнеются
ни одной такой части. Поскольку в реальности все же возникает некоторая
последовательность выполнения команд внутри транзакции, вводится понятие
"отката" (rollback), при котором результаты всех до сих пор произведенных
действий возвращатся в исходное состояние.
Т.е. у любой транзакции есть 2 варианта исхода: подтверждение или откат.

2. Consistency (согласованность): по окончанию транзакция оставляет данные
в непротиворечивом состоянии. Скажем, если поле в базе данных описано как
имеющее только уникальные значения строк, то ни при каком исходе транзакции
дубликатов никакой строки появиться не может.

3. Isolation (изоляция): конкурирующие, параллельно текущие во времени
транзакции не могут пересекаться на одних и тех же ресурсах. Для обеспечения
изоляции вводятся, к примеру, специальные замки на измененных ресурсах,
запрещающие другим транзакциям эти ресурсы менять до окончания поменявшей
транзакции.

4. Durability (долговечность): независимо от проблем на нижних уровнях
(к примеру, обесточивание системы или сбои в оборудовании) изменения,
сделанные успешно завершенной транзакцией, останутся сохраненными после
возвращения системы в работу.


УРОВНИ ИЗОЛЯЦИИ ТРАНЗАКЦИИ
0 [никакой изоляции] - Read Uncommitted (Dirty Read) - чтоние незафиксированных изменений своей
транзакции и конкурирующих транзакций; возможны нечистые и неповторяемые
чтения, фантомы.

1 [полуизоляция] - Read Committed - чтение всех изменений своей транзакции и зафиксированных
изменений конкурирующих транзакций; возможны нечистые и неповторяемые чтения,
фантомы.
Иначе говоря, можно видеть изменения своей транзакции другими транзакциями,
но только уже подтвержденные ими.

2 [по умолчанию] - Repeatable Read (Snapshot) - чтение всех изменений своей транзакции, любые
изменения, внесенные конкурирующими транзакциями после начала своей сессии
недоступны, нечистые и неповторяемые чтения невозможны, возможны фантомы.

3 [полная изоляция] - Serializable - сериализуемые транзакции, результат действия которых не
зависит от порядка выполнения шагов транзакции (запрещено чтения всех данных
в своей и чужих транзакциях, измененных с начала транзакции).
Иначе говоря, не видно никаких изменений, даже своей собственной транзакции
до подтверждения.

-- ФАНТОМНОЕ ЧТЕНИЕ - это чтение уже устаревшей информации. Я в своей транзакции
   еще не вижу изменений, которые уже подтвердила конкурирующая транзакция,
   т.к. моя транзакция изолирована (уровни изоляции 2-3)
-- Неповторяющееся чтение - открываю свою транзакцию, читаю 1 раз, читаю
   2 раз, получаю 2 разных результата, потому что между чтениями кто-то
   в другой транзакции уже внес изменения (уровни изоляции 0-1).

*/


-- ------------------> Блокировки <------------------ --
USE fselect;

-- READ - заблокировать запись и изменение таблицы
LOCK TABLES teachers READ;  -- заблокировать таблицу
   -- теперь если другой пользователь (можно открыть 2-ю консоль)
     -- попытается изменить эту таблицу, его консоль зависнет в ожидании,
     -- пока таблица будет разблокирована
     INSERT INTO teachers VALUES (100,'Иван',123456);
UNLOCK TABLES;  -- разблокировать таблицу

-- WRITE - заблокировать таблицу полностью - на чтение и запись
LOCK TABLES teachers WRITE;  -- заблокировать таблицу
   -- теперь если другой пользователь (можно открыть 2-ю консоль)
     -- попытается ПРОЧИТАТЬ или ИЗМЕНИТь эту таблицу, его консоль
     -- зависнет в ожидании, таблица будет разблокирована
     SELECT * FROM teachers;
UNLOCK TABLES;

-- INSERT DELAYED - чтобы скрипт (и сайт вместе с ним) не висел в ожидании разблокировки таблицы,
  -- можно заказать вставку, а скрипт продолжит вополняться дальше
  -- !!! работает не на всех движках; на MyISAM работает
INSERT DELAYED INTO teachers VALUES (101,'Петр',534213);


-- ------------------> Транзакции <------------------ --
-- > пока у меня есть не закрытая транзакция, сервер не позволит другим
--    пользователям менять эту таблицу
-- > во время проведения транзакции сервер не изменяет реальные данные в БД,
--    а записывает, что нужно делать в журнал. Когда я подтверждаю транзакцию COMMIT 'ом,
--    он делает это; когда отменяю ROLLBACK 'ом - не делает.
-- > если с транзакцией работают, например, 2 юзера, у каждого свой собственный
--   журнал изменений. Если сервер в какой-то момент понимает, что применить
--   COMMIT к обоим журналам не сможет, потому что они противоречат друг другу,
--   то он включает блокировку.

-- начать транзакцию
START TRANSACTION;   -- или BEGIN TRANSACTION

  -- внести изменение в таблицу
  INSERT INTO teachers VALUES (101,'Петр',534213);
  -- в этот момент если другой пользователь запросит данные из этой таблицы,
  --  в них не будет записи №101, потому что транзакция еще не была подтверждена.
  DROP TABLE teachers;  -- ... УПС! Случайно удалил таблицу ...

-- откат изменений к началу транзакции
ROLLBACK;  -- ... но ничего, можно откатить все изменения к началу транзакции!
           -- ... это также является признаком конца транзакции

-- одобрить транзакцию
COMMIT;    -- ... это также является признаком конца транзакции

-- параметр для движка INNODB [для массированных операций]
--  > INNODB - транзакционный движок, после каждого INSERT он автоматически
--    делает COMMIT. А если надо сделать 1000 INSERT, это не целесообразно.
--  > Для него AUTOCOMMIT = 1 по умолчанию. Если сделать AUTOCOMMIT = 0,
--    то любые изменения можно будет вносить только через транзакцию.
SET AUTOCOMMIT = 1;


   -- ФАНТОМНОЕ ЧТЕНИЕ - это чтение уже устаревшей информации. Вот как это происходит:
-- может быть ситуация, когда изоляция транзакции не нужна; например, когда
--  идет оплата картой в 1 транзакции, и средства списались, остальные карты
--  должны мгновенно об этом узнать; значит надо нарушить изоляцию транзакции
--  в этой части.
-- > но снятие изоляции ведет к проблемам, ведь если транзакция завершится
--   ROLLBACK'ом, то данные изменятся на прежние, а ведь новые уже кто-то
--   прочитал, отсюда проблемы

  -- изменение уровня изоляции транзакции
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;  -- уровень 0, никакой изоляции
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;    -- уровень 1, полуизоляция
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;   -- уровень 2, по умолчанию
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;      -- уровень 3, полная изоляция