////==================================================////
////                                                  ////
////                       SASS                       ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Официальный сайт SASS
        http://sass-lang.com/

    # Оф.документация по SASS
        http://sass-lang.com/documentation/file.SASS_REFERENCE.html        

  // Видео //
  //-------//



  // Текст //
  //-------//


////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  SASS

    А1. Вводная информация
    А2. Установка и компиляция SASS
    А3. Справочник по SASS CLI
    А4. Экспресс-обзор функционала SASS

    А5. Расширения для CSS
    А6. Комментарии
    А7. Переменные, их типы, операции с ними в SASS
    А8. Встроенные функции в SASS
    А9. @-директивы, условные операции/циклы, миксины, функции

  # Б.  Рецепты и наработки

    Б1. ...


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. Вводная информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Вводная информация про SASS

      - Как расшифровывается SASS
      - Определение SASS
      - SASS компилируется в CSS
      - У SASS есть 2-ва синтаксиса: старый (sass) и новый (scss)

        ▪ Старый синтаксис (sass)
        ▪ Новый синтаксис (scss)
        ▪ Возможна конвертация sass <---> scss

      - Особенности SCSS

        ▪ Любой валидный CSS является валидным SCSS (но не наоборот).     
        ▪ Расширения языка: переменные, вложенность, миксины, ...      
        ▪ Много доп.функций для манипуляции цветом и другими значениями
        ▪ Условные операторы и циклы
        ▪ Красиво отформатированные CSS-файлы на выходе

  --------------------------------------

  > Ссылки

  > Введение
    - Это глава с общей информацией о SASS.

  > Вводная информация про SASS

    # Как расшифровывается SASS
      - Syntactically Awesome StyleSheets.
      - Синтаксичски-фантастические таблицы стилей.

    # Определение SASS
      
      SASS - метаязык на основе CSS, предназначенный для
      увеличения уровня абстрации CSS кода и упрощения
      файлов CSS.

    # SASS компилируется в CSS
      - Использовать sass-файлы прямо в браузере нельзя.
      - Надо сперва скомпилировать их в css-файлы.
      - Библиотека SASS выдаёт на выходе 100% валидный CSS.

    # У SASS есть 2-ва синтаксиса: старый (sass) и новый (scss)

      • Старый синтаксис (sass)
        - Этот синтаксис НЕ является дополнением к синтаксису CSS.
        - В нём не используются {}, а используется индентация для вложенных блоков.
        - Инструкции отделяются друг от друга не ;, а символом новой строки.
        - Он является менее многословным, но и менее понятным обывателю, чем SCSS.
        - Синтаксис sass имеет весь тот же самый функционал, что и scss.
        - Однако некоторая часть этого функционала имеет совершенно отличный синтаксис.
        - Файлы с этим синтаксисом используют расширения .sass
        - В данной методичке синтаксис sass рассмотрен НЕ будет.

      • Новый синтаксис (scss)
        - SCSS расшифровывается, как Sassy (нахальный) CSS.
        - Синтаксис SCSS является дополнением к синтаксису CSS.
        - Следовательно, любой валидный CSS является валидным SCSS (но не наоборот).
        - Именно этот синтаксис рассмотрен в данной методичке.
        - Везде под SASS здесь будет иметься в виду синтаксис scss.
        - Файлы с этим синтаксисом используют расширения .scss

      • Возможна конвертация sass <---> scss
        - Библиотека SASS имеет инструменты для этого.
        - Например, это можно сделать CLI-командой sass-convert.

    # Особенности SCSS

      • Любой валидный CSS является валидным SCSS (но не наоборот).     
      • Расширения языка: переменные, вложенность, миксины, ...      
      • Много доп.функций для манипуляции цветом и другими значениями
      • Условные операторы и циклы
      • Красиво отформатированные CSS-файлы на выходе


А2. Установка и компиляция SASS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Некоторые способы компиляции SASS

      - Способ #1: CLI-приложение SASS

        ▪ CLI-приложение на Ruby
        ▪ Чем может быть полезно это CLI
        ▪ Установка CLI SASS на Ubuntu 14.04

      - Способ #2: gulp + плагин gulp-sass

        ▪ gulp-sass --> node-sass --> libsass
        ▪ Как пользоваться gulp-sass

  --------------------------------------
  
  > Ссылки

    # Оф.инструкция по установке CLI SASS
        http://sass-lang.com/install

    # Видео-инструкция по установке CLI SASS на Ubuntu 14.04
        https://www.youtube.com/watch?v=ziI1nezM3jk

    # Ссылки на: gulp-sass --> node-sass --> libsass
        https://github.com/dlmanning/gulp-sass
        https://github.com/sass/node-sass
        https://github.com/sass/libsass

  > Введение
    - Вообще-то для использования SASS ничего устанавливать не обязательно.
    - Ты можешь взять и написать SASS-код в любом текстовом файле.
    - Но его всё равно потребуется скомпилировать в CSS-файл для использования в браузере.
    - Возникает резонный вопрос, а как, черт возьми, произвести компиляцию?
    - Этот вопрос и раскрывается в данной главе.

  > Некоторые способы компиляции SASS

    # Способ #1: CLI-приложение SASS

      • CLI-приложение на Ruby
        - У SASS есть оф.CLI-приложение, написанное на Ruby.

      • Чем может быть полезно это CLI
        - В нём можно в интерактивном режиме поиграться с SASS.
        - Или же быстренько в терминале скомпилировать SASS в CSS.
        - Ещё у него есть watch-демон для экспресс-автоматизации сборки.
        - Но это так, поиграться. Серьёзные мальчики и девочки используют gulp.

      • Установка CLI SASS на Ubuntu 14.04

        sudo apt-get install -y ruby-full
        sudo gem install sass

    # Способ #2: gulp + плагин gulp-sass

      • gulp-sass --> node-sass --> libsass
        - Есть такой плагин для gulp: "gulp-sass".
        - Он внутри использует npm-модуль: "node-sass".
        - Последний же использует С++-реализацию компилятора SASS: "libsass".

      • Как пользоваться gulp-sass
        - Подробно это описано в моей методичке по gulp.
        - Всё просто, через плагин gulp-sass пускают поток с scss-файлами.
        - После прохождения через плагин, на выходе мы получаем css-файлы. 


А3. Справочник по SASS CLI

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Общее описание CLI
    # Опции команды sass

      • Общие опции

        -I                | Specify a Sass import path
        -r                | Require a Ruby library before running Sass
        --compass         | Make Compass imports available and load project co figuration
        -t                | Output style. Can be nested (default), compact, co pressed, or expanded
        -h                | Show help message
        -v                | Print the Sass version

      • Watching and Updating

        --watch           | Watch files or directories for changes.
                            The location of the generated CSS can be set using a colon:
                              sass --watch input.sass:output.css
                              sass --watch input-dir:output-dir                  
        --poll            | Check for file changes manually, rather than relying on the OS
        --update          | Compile files or directories to CSS.
                            Locations are set like --watch.
        --force           | Recompile every Sass file, even if the CSS file is newer
        --stop-on-erorr   | If a file fails to compile, exit immediately.
                            Only meaningful for --watch and --update.

      • Ввод и вывод

        --scss            | Use the CSS-superset SCSS syntax
        --sourcemap=TYPE  | How to link generated output to the source files.
                            auto (default): relative paths where possible, file URIs elsewhere
        -s                | Read input from standard input instead of an input file.
                            This is the default if no input file is specified
        -E                | Specify the default encoding for input files.
                            Use Unix-style newlines in written files
        -g                | Emit output that can be used by the FireSass Fireb g plugin
        -l                | Emit comments in the generated CSS indicating the corresponding source line

      • Прочее

        -i                            | Run an interactive SassScript shell
        -c                            | Just check syntax, don't evaluate
        --precision NUMBER_OF_DIGITS  | How many digits of precision to use when output in decimal numbers
        --cache-location PATH         | The path to save parsed Sass files. Defaults to .sass-cache
        -C                            | Don't cache parsed Sass files
        --trace                       | Show a full Ruby stack trace on error
        -q                            |  Silence warnings and status messages during compilation


  --------------------------------------  

  > Ссылки

    # Оф.документация по SASS
        http://sass-lang.com/documentation/file.SASS_REFERENCE.html

  > Введение
    - SASS CLI довольно компактен, в этой главе справочник по нему.

  > Общее описание CLI
    - Весь CLI представляет из себя 1-ну команду sass.
    - Эта команда имеет набор опций.
    - Поэтому справочник представляет из себя оный по опциям команды sass.

  > Опции команды sass
    - См.оглавление.


А4. Экспресс-обзор функционала SASS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Препроцессинг

      - Зачем нужны препроцессоры
      - Препроцессинг SASS-файлов в терминале

    # Переменные в SASS

      - О переменных в SASS
      - Пример переменных в SASS

    # Иерархия и вложенность в SASS

      - Про иерархию и вложенность в SASS
      - Избегай чрезмерно глобокой иерархии
      - Пример применения иерархии в SASS

    # Фрагменты и импорт в SASS

      - Фрагменты в SASS

        ▪ Общая информация про фрагменты в SASS
        ▪ Префиксинг имён файлов-фрагментов символом _

      - Импорт в SASS

        ▪ Общая информация про импорт в SASS
        ▪ При импортировании в имени фрагмента не надо указывать префикс _
      
      - Пример фрагментов и импорта в SASS

    # Миксины (функции) в SASS

      - Про миксины (функции) в SASS
      - Пример миксин в SASS

        ▪ Определение миксины с помощью @mixin          
        ▪ Использование миксины с помощью @include          

    # Наследование в SASS

      - Про наследование в SASS
      - Пример наследования в SASS

    # Операторы в SASS

      - Про операторы в SASS
      - Пример использования операторов в SASS

  --------------------------------------

  > Ссылки

    # Оф.экспресс обзор функционала SASS
        http://sass-lang.com/guide

  > Введение
    - В этой главе поверхностный обзор функционала SASS.
    - Всего понемножку.

  > Препроцессинг

    # Зачем нужны препроцессоры
      - В CSS пока нет многих облегчающих жизнь вещей, которые есть в SASS.
      - Без этих вещей с большим кол-вом CSS намного труднее работать.
      - Его трудно поддерживать, изменять, улучшать, повторно использовать.
      - Вот почему профессионалам приходится использовать препроцессоры CSS.


    # Препроцессинг SASS-файлов в терминале
      - Можно запустить демон из SASS CLI.
      - Он будет следить за .scss-файлами в указанной папке.
      - При изменении, компилировать и класть их в указанную папку.
      - Например:

          sass --watch app/sass:public/stylesheets

  > Переменные в SASS

    # О переменных в SASS
      - В переменных SASS можно хранить информацию.
      - Можно хранить CSS-значения, цвета, шрифты.
      - Для переменных в SASS используется $, как в PHP.
      - Ниже есть пример в стиле "до" и "после".

    # Пример переменных в SASS

      • Файл "styles.scss"

        $font-stack:    Helvetica, sans-serif;
        $primary-color: #333;

        body {
          font: 100% $font-stack;
          color: $primary-color;
        }

      • Файл "styles.css"

        body {
          font: 100% Helvetica, sans-serif;
          color: #333;
        }        

  > Иерархия и вложенность в SASS

    # Про иерархию и вложенность в SASS
      - Например, в HTML есть иерархия и вложенность.
      - А в стандартном CSS она отсутствует.
      - SASS же обеспечивает иерархию и вложенностью.

    # Избегай чрезмерно глобокой иерархии
      - При компиляции в CSS иерархия отражается в именах классов.
      - При чрезмерно глубокой иерархии эти имена будут оч.длинные.
      - Ими просто будет трудно и неудобно пользоваться.

    # Пример применения иерархии в SASS

      • Файл "styles.scss"

          nav {
            ul {
              margin: 0;
              padding: 0;
              list-style: none;
            }

            li { display: inline-block; }

            a {
              display: block;
              padding: 6px 12px;
              text-decoration: none;
            }
          }

      • Файл "styles.css"

          nav ul {
            margin: 0;
            padding: 0;
            list-style: none;
          }

          nav li {
            display: inline-block;
          }

          nav a {
            display: block;
            padding: 6px 12px;
            text-decoration: none;
          }

  > Фрагменты и импорт в SASS

    # Фрагменты в SASS
      
      • Общая информация про фрагменты в SASS
        - Ты можешь создавать файлы-фрагменты-scss.
        - В них можно класть небольшие фрагменты scss-кода.
        - Чтобы в дальнейшем повторно использовать их.
        - Импортируя файлы-фрагменты в другие scss-файлы.

      • Префиксинг имён файлов-фрагментов символом _
        - Имя файла фрагмента строится по шаблону:

            _[имя].scss

        - Это даёт понять компилятору SASS, что перед ним файл-фрагмент.
        - И он не компилирует его, как отдельный SASS-файл.

    # Импорт в SASS
      
      • Общая информация про импорт в SASS
        - SASS позволяет импортировать одни .scss-файлы в другие.
        - В CSS тоже есть подобный функционал, но с одним недостатком.
        - Для каждого импортированного файла создаётся отдельный HTTP-запрос.
        - Реализация в SASS же лишена этого недостатка.
        - Ведь при импортирование всё это объединяется в 1 css-файл.
        - Для импортирования используется директива @import.

      • При импортировании в имени фрагмента не надо указывать префикс _
        - Это наглядно продемонстрировано в примере ниже.

    # Пример фрагментов и импорта в SASS

      • Файл "_partial.scss"

          html,
          body,
          ul,
          ol {
            margin: 0;
            padding: 0;
          }

      • Файл "styles.scss"

          @import 'partial';

          body {
            font: 100% Helvetica, sans-serif;
            background-color: #efefef;
          }

      • Файл "styles.css"

          html, body, ul, ol {
            margin: 0;
            padding: 0;
          }

          body {
            font: 100% Helvetica, sans-serif;
            background-color: #efefef;
          }         

  > Миксины (функции) в SASS

    # Про миксины (функции) в SASS
      - Миксины позволяют сгруппировать набор CSS-инструкций.
      - Миксину можно вызвать по имени после определения.
      - Строка вызова будет заменена в css на содержимое миксины.
      - По большому счёту, миксины сильно смахивают на функции.
      - В примере ниже определяется миксина border-radius.
      - Она содержит 4-ре инструкции с разными вендорными префиксами.
      - Типа, еслиб небыло автопрефиксеров, можно былоб делать так.
      - Но, всем понятно, это здесь чисто для примера.

    # Пример миксин в SASS

      • Файл "styles.scss"

        ▪ Определение миксины с помощью @mixin

          @mixin border-radius($radius) {
            -webkit-border-radius: $radius;
               -moz-border-radius: $radius;
                -ms-border-radius: $radius;
                    border-radius: $radius;
          }

        ▪ Использование миксины с помощью @include

          .box { @include border-radius(10px); }

      • Файл "styles.css"            

          .box {
            -webkit-border-radius: 10px;
            -moz-border-radius: 10px;
            -ms-border-radius: 10px;
            border-radius: 10px;
          }

  > Наследование в SASS

    # Про наследование в SASS
      - Это одна из самых полезных функций в SASS.
      - Один селектор может наследовать св-ва у другого.
      - Это можно осуществлять с помощью директивы @extend
      - Наследующий селектор применяет @extend внутри себя.
      - В качестве аргумента указывается наследуемый селектор.
      - Ниже приведёт наглядный пример.

    # Пример наследования в SASS

      • Файл "styles.scss"

          .message {
            border: 1px solid #ccc;
            padding: 10px;
            color: #333;
          }

          .success {
            @extend .message;
            border-color: green;
          }

          .error {
            @extend .message;
            border-color: red;
          }

          .warning {
            @extend .message;
            border-color: yellow;
          }        

      • Файл "styles.css" 

          .message, .success, .error, .warning {
            border: 1px solid #cccccc;
            padding: 10px;
            color: #333;
          }

          .success {
            border-color: green;
          }

          .error {
            border-color: red;
          }

          .warning {
            border-color: yellow;
          }

  > Операторы в SASS

    # Про операторы в SASS
      - SASS позволяет использовать операторы + - * / %
      - Ниже наглядный пример.

    # Пример использования операторов в SASS

      • Файл "styles.scss"

          .container { width: 100%; }

          article[role="main"] {
            float: left;
            width: 600px / 960px * 100%;
          }

          aside[role="complimentary"] {
            float: right;
            width: 300px / 960px * 100%;
          }

      • Файл "styles.css" 

          .container {
            width: 100%;
          }

          article[role="main"] {
            float: left;
            width: 62.5%;
          }

          aside[role="complimentary"] {
            float: right;
            width: 31.25%;
          }


А5. Расширения для CSS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Вложенные CSS-правила

      - Про иерархию и вложенность в SASS
      - Избегай чрезмерно глобокой иерархии
      - Пример применения иерархии в SASS      

    # Ссылка на правило-родителя с помощью &

      - Про &
      - Пример использования &
      - Пример использования & с суффиксом

    # Вложенные CSS-свойства

      - Про вложенные CSS-свойства
      - Примеры использования вложенных CSS-свойств

    # Селекторы-плейсхолдеры %

      - SASS поддерживает спец.типы селекторов - "селекторы-плейсхолдеры"
      - Зачем нужны селекторы-плейсхолдеры
      - Пример использования селектора-плейсхолдера

  --------------------------------------

  > Ссылки

    # Соответствующий раздел оф.документации
        http://sass-lang.com/documentation/file.SASS_REFERENCE.html#css_extensions

  > Введение
    - В этой главе рассмотрим несколько SASS-расширений для CSS.

  > Вложенные CSS-правила

    # Про иерархию и вложенность в SASS
      - Например, в HTML есть иерархия и вложенность.
      - А в стандартном CSS она отсутствует.
      - SASS же обеспечивает иерархию и вложенностью.

    # Избегай чрезмерно глобокой иерархии
      - При компиляции в CSS иерархия отражается в именах классов.
      - При чрезмерно глубокой иерархии эти имена будут оч.длинные.
      - Ими просто будет трудно и неудобно пользоваться.

    # Пример применения иерархии в SASS

      • Файл "styles.scss"

          nav {
            ul {
              margin: 0;
              padding: 0;
              list-style: none;
            }

            li { display: inline-block; }

            a {
              display: block;
              padding: 6px 12px;
              text-decoration: none;
            }
          }

      • Файл "styles.css"

          nav ul {
            margin: 0;
            padding: 0;
            list-style: none;
          }

          nav li {
            display: inline-block;
          }

          nav a {
            display: block;
            padding: 6px 12px;
            text-decoration: none;
          }

  > Ссылка на правило-родителя с помощью &

    # Про &
      - Это ссылка на родительский селектор.
      - & может быть лишь 1-ым символом селектора.
      - К & можно добавлять суффикс.

    # Пример использования &

      • Файл "styles.scss"

          a {
            font-weight: bold;
            text-decoration: none;
            &:hover { text-decoration: underline; }
            body.firefox & { font-weight: normal; }
          }

      • Файл "styles.css"

          a {
            font-weight: bold;
            text-decoration: none; }
            a:hover {
              text-decoration: underline; }
            body.firefox a {
              font-weight: normal; }

    # Пример использования & с суффиксом

      • Файл "styles.scss"

          #main {
            color: black;
            &-sidebar { border: 1px solid; }
          }

      • Файл "styles.css"

          #main {
            color: black; }
            #main-sidebar {
              border: 1px solid; }

  > Вложенные CSS-свойства

    # Про вложенные CSS-свойства
      - В CSS есть малое число св-в в "пространствах имён".
      - Например - font-family, font-size, font-weight - в пр.имён "font".
      - SASS позволяет работать с ними по вложенному сценарию (см.пример).

    # Примеры использования вложенных CSS-свойств

      • Файл "styles.scss"

          .funky {
            font: {
              family: fantasy;
              size: 30em;
              weight: bold;
            }
          }

          .funky {
            font: 20px/24px fantasy {
              weight: bold;
            }
          }          

      • Файл "styles.css"      

          .funky {
            font-family: fantasy;
            font-size: 30em;
            font-weight: bold; }

          .funky {
            font: 20px/24px fantasy;
              font-weight: bold;
          }            

  > Селекторы-плейсхолдеры %   

    # SASS поддерживает спец.типы селекторов - "селекторы-плейсхолдеры"
      - Они типа . и # селекторов, только используется символ %
      - Они предназначены для использования с директивой @extend.
      - Без связки с @extend эти селекторы никак ни на что не влияют.

    # Зачем нужны селекторы-плейсхолдеры
      - Они пригодятся, если:

        • Мы хотим создать новый класс.
        • Но не хотим, чтобы он попал в итоговый CSS.
        • Но хотим наследовать от него в других классах

    # Пример использования селектора-плейсхолдера

      • Файл "styles.scss"

        #context a%extreme {
          color: blue;
          font-weight: bold;
          font-size: 2em;
        }    

        .notice {
          @extend %extreme;
        }

      • Файл "styles.css"     

        #context a.notice {
          color: blue;
          font-weight: bold;
          font-size: 2em; }


А6. Комментарии

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Однострочные комментарии //
    # Многострочные комментарии /* */

      - Они присутствуют в итоговом CSS
      - Если 1-ая буква коммента ! , коммент остаётся даже в сжатом варианте
      - Пример использования многострочных комментариев
      - Переменные в многострочных комментариях также работают

  --------------------------------------

  > Ссылки

    # Соответствующий раздел оф.документации
        http://sass-lang.com/documentation/file.SASS_REFERENCE.html#comments

  > Введение
    - В этой короткой главе рассмотрим комментарии в SASS.

  > Однострочные комментарии //
    - Они не присутствуют в итоговом CSS.
    - Пример:

      • Файл "styles.scss"

          // These comments are only one line long each.
          // They won't appear in the CSS output,
          // since they use the single-line comment syntax.
          a { color: green; }

      • Файл "styles.css"  

          a { color: green; }      

  > Многострочные комментарии /* */
    
    # Они присутствуют в итоговом CSS
      - Сабж.

    # Если 1-ая буква коммента ! , коммент остаётся даже в сжатом варианте
      - Имеется в виду, даже в сжатом варианте итогового CSS.

    # Пример использования многострочных комментариев

      • Файл "styles.scss"

          /* This comment is
           * several lines long.
           * since it uses the CSS comment syntax,
           * it will appear in the CSS output. */
          body { color: black; }    

      • Файл "styles.css"  

          /* This comment is
           * several lines long.
           * since it uses the CSS comment syntax,
           * it will appear in the CSS output. */
          body {
            color: black; }

    # Переменные в многострочных комментариях также работают

      • Файл "styles.scss"

          $version: "1.2.3";
          /* This CSS is generated by My Snazzy Framework version #{$version}. */

      • Файл "styles.css"           

          /* This CSS is generated by My Snazzy Framework version 1.2.3. */


А7. Переменные, их типы, операции с ними в SASS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Интерактивный шелл в SASS CLI
    # Работа с переменными в SASS

      - Переменные: общая информация

        ▪ Переменные начинаются с символа $
        ▪ Как объявлять и инициировать переменные
        ▪ Как использовать переменные
        ▪ Глобальные и локальные переменные

          ▪ Глобальные переменные
          ▪ Флаг !global
          ▪ Локальные переменные

        ▪ Взаимозаменяемость - и _ в именах переменных

      - Переменные: типы данных

        ▪ Тип: числа
        ▪ Тип: строки
          ▪ Примеры строк
          ▪ CSS поддерживает 2 типа строк: в кавычках / не в кавычках
          ▪ SASS сохраняет тип строк в итоговом CSS после компилаяии
          ▪ Исключение: при интерполяции #{} тип строки становится: не в кавчках
        ▪ Тип: цвета
          ▪ Примеры цветов
          ▪ При сжатии будет использовано MIN представление цвета
          ▪ Заключай имена цветов в кавычки, чтобы избежать проблем при интерполяции        
        ▪ Тип: булевы
        ▪ Тип: null
        ▪ Тип: массивы
          ▪ Общая информация о массивах в SASS
          ▪ Разделителем может быть пробел или запятая
          ▪ Обычные переменные тоже массивы, просто с 1-им эл-м
          ▪ Для работы с массивами используй SASS-функции
          ▪ Массивы могут содержать другие массивы, и т.д.
          ▪ Массивы могут быть и пустыми
          ▪ Что происходит с пустыми массивами при компиляции в CSS
          ▪ Массивы с разделителем-запятой могут иметь запятую в конце

        ▪ Тип: объекты
          ▪ Общая информация об объектах в SASS
          ▪ Как объявить объект
          ▪ Key и Value объекта м.б. любым валидным SassScript-объектом
          ▪ Объект не может иметь 2-ух одинаковых ключей
          ▪ Эффективная работа с объектами ведётся SASS-функциями
          ▪ К объектам можно применять функции для работы с массивами
          ▪ Объект не может быть сконвертировать в CSS

      - Переменные: операции

        ▪ Числа [ + - * / % == != > >= < <= ]
          ▪ Операции с несовместимыми типами чисел запрещены
          ▪ Особенность умножения одних и тех же типов
          ▪ В CSS есть разделитель /, а в SASS / это деление. Как быть?
          ▪ Одновременное использование разделителя / и переменных
          ▪ Есть 4 возможных значения оператора -
          ▪ Примеры операций с числами

        ▪ Цвета [ + - * / % == != ]
          ▪ Операции с цветами работают "кусочным" образом
          ▪ Лучше использовать sass-функции для работы с цветами, чем арифм.операции
          ▪ Возможны арифм.операции между цветами и числами
          ▪ Операция между цветами с α-каналом и без вызовет ошибку
          ▪ Примеры операций с цветами

        ▪ Строки [ + == != ]
          ▪ Конкатенация строк в кавычках и без даёт строку в кавычках
          ▪ Можно интерполировать значения прямо внутрь строки ""
          ▪ Примеры операций со строками

        ▪ Булеан [ and or not == != ]
        ▪ Массивы [ == != ]
          ▪ Массивы не поддерживают никаких особых операций
          ▪ Примеры операций с массивами

      - Переменные: порядок операций ()
      - Переменные: интерполяция в селекторах #{}
      - Переменные: списки род.селекторов &
      - Переменные: флаг !default

  --------------------------------------

  > Ссылки

    # Соответствующий раздел оф.документации
        http://sass-lang.com/documentation/file.SASS_REFERENCE.html#sassscript

  > Введение
    - В этой главе рассмотрим работу с переменными в SASS.
    - Общие сведения, типы переменных, операции с ними.

  > Интерактивный шелл в SASS CLI
    - Эксперементировать с SassScript можно в интерактивном шелле.
    - Запустить его можно с помощью опции -i в SASS CLI:

        sass -i

    - Прямо в терминале можно выполнять различные операции.
    - И сразу наблюдать результаты.
    - Например:

        >> 1px + 1px + 1px
        3px

  > Работа с переменными в SASS

    # Переменные: общая информация

      • Переменные начинаются с символа $
        - Сабж.

      • Как объявлять и инициировать переменные

          $width: 5em;

      • Как использовать переменные

          #main {
            width: $width;
          }

      • Глобальные и локальные переменные

        ▪ Глобальные переменные
          - Это все переменные, определённые вне селекторов.
          - А также переменные, определённые с флагом !global.
          - Пример глобальной переменной:

              $width: 5em;
              #main {
                width: $width;
              }            

        ▪ Флаг !global
          - Позволяет определить глобальную переменную даже внутри селектора.
          - Пример:

              #main {
                $width: 5em !global;
                width: $width;
              }            

        ▪ Локальные переменные
          - Определённые внутри селектора.
          - Видны в селекторе и вложенных в него селекторах.
          - Принцип работа такой же, как в JS с переменными в функциях.

      • Взаимозаменяемость - и _ в именах переменных
        - Такая ситуация сложилась по историческим причинам.
        - Описанные ниже вызовы обращаются к одной и той же переменной:

            $main-width     
            $main_width     

    # Переменные: типы данных

      • Тип: числа

        ▪ Примеры чисел
          - 1.2, 13, 10px

      • Тип: строки
        
        ▪ Примеры строк
          - "foo", 'bar', baz

        ▪ CSS поддерживает 2 типа строк: в кавычках / не в кавычках

          ▪ В кавычках
            - Например: "Lucida Grande" или 'http://sass-lang.com'

          ▪ Без кавычек
            - Например: sans-serif или bold

        ▪ SASS сохраняет тип строк в итоговом CSS после компилаяии
          - Если это была строка в кавычках, то она и останется таквой.
          - Если это была строка не в кавычках, то она и останется таковой.

        ▪ Исключение: при интерполяции #{} тип строки становится: не в кавчках
          - Все строки становятся строками не в кавычках.
          - Например:

            • Файл "styles.scss"

                @mixin firefox-message($selector) {
                  body.firefox #{$selector}:before {
                    content: "Hi, Firefox users!";
                  }
                }

                @include firefox-message(".header");

            • Файл "styles.css"

                body.firefox .header:before {
                content: "Hi, Firefox users!"; }

      • Тип: цвета
        
        ▪ Примеры цветов
          - blue, #04a3f9, rgba(255, 0, 0, 0.5)

        ▪ При сжатии будет использовано MIN представление цвета
          - Например, вместо #FF0000 будет red.
          - Например, вместо blanchedalmond будет #FFEBCD.

        ▪ Заключай имена цветов в кавычки, чтобы избежать проблем при интерполяции
          - При интерполяции разработчик ожидает вставки конкретного значения.
          - Но SASS может взять, и заменить это значение на менее длинное.
          - И итоговый код после интерполяции может стать при этом не валидным.
          - Чтобы этого избежать, заключайте имена цветов в кавычки.

      • Тип: булевы
        - Например: true, false

      • Тип: null
        - Например: null

      • Тип: массивы

        ▪ Общая информация о массивах в SASS
          - Массивы представляют из себя списки значений.
          - Они могут быть разделены пробелами или запятыми.

        ▪ Разделителем может быть пробел или запятая

          ▪ Пример массива с разделителем-пробелом
            - 1.5em 1em 0 2em

          ▪ Пример массива с разделителем-запятой
            - Helvetica, Arial, sans-serif

        ▪ Обычные переменные тоже массивы, просто с 1-им эл-м
          - Сабж.

        ▪ Для работы с массивами используй SASS-функции
          - Сами по себе массивы ничего особого не делают.
          - Работать с ними удобно, используя SASS-функции.
          - Такие, как: nth, join, append, директиву @each.

        ▪ Массивы могут содержать другие массивы, и т.д.
          
          ▪ Пример №1
            - Внешний массив содержит 2 элемента.
            - И использует разделитель запятую.
            - Каждый из этих элементов является массивом.
            - Внутренние массивы используют разделитель пробел.
            - Код:

                1px 2px, 5px 6px

          ▪ Пример №2
            - И внешний, и внутренние массивы используют разделитель пробел.
            - В этом случае, следует использовать () для отделения внут.массивов.
            - Код:

                (1px 2px) (5px 6px)

        ▪ Массивы могут быть и пустыми
          - Такие массивы обозначаются, как ()
          - Это обозначение также используется для пустых объектов.
        
        ▪ Что происходит с пустыми массивами при компиляции в CSS

          ▪ Пустые массивы не в составе других массивов вызывают ошибки

          ▪ Пустые массивы и null, как эл-ты других массивов, удаляются
            - Т.Е. эти пустые элементы просто удаляются из массива.

        ▪ Массивы с разделителем-запятой могут иметь запятую в конце
          - Это позволяет определять массивы с одним элементом.
          - Например - (1,) - массив с элементом 1.
          - Например - (1 2 3,) - массив, содержащий 1-ин элемент-массив,
            содержащий 3 элемента: 1 2 и 3.

      • Тип: объекты
        
        ▪ Общая информация об объектах в SASS
          - Они похожи на JS объекты.
          - Объявляются с помощью круглых скобок ()
          - Позволяют собирать значение в именованные группы.

        ▪ Как объявить объект
          - Для этого надо использовть круглые скобки.
          - В качестве разделителя всегда запятые.
          - Пример:

              $map: (key1: value1, key2: value2, key3: value3);

        ▪ Key и Value объекта м.б. любым валидным SassScript-объектом
          - Сабж.

        ▪ Объект не может иметь 2-ух одинаковых ключей
          - Сабж.

        ▪ Эффективная работа с объектами ведётся SASS-функциями
          - Здесь ситуация такая же, как и с массивами.
          - Например: map-get, map-merge, директива @each.

        ▪ К объектам можно применять функции для работы с массивами
          - Функция автоматически конвертирует этот объект в массив.
          - Это получается массив пар значений.
          - Например:

               (key1: value1, key2: value2)   // такой объект
               key1 value1, key2 value2       // превращается в такой массив
      
          - Однако, обратное невозможно.

        ▪ Объект не может быть сконвертировать в CSS
          - То есть нельзя использовать его в кач-ве значений.
          - Проверить, объект ли это или нет, можно так: inspect($value).

    # Переменные: операции

      • Числа [ + - * / % == != > >= < <= ]

        # Операции с несовместимыми типами чисел запрещены
          - Нельзя сложить, например, 1px + 2em, будет ошибка.

        # Особенность умножения одних и тех же типов
          - 10px*10px == 100px*px
          - А в SASS px*px вызовет error при компиляции. Берегись!

        # В CSS есть разделитель /, а в SASS / это деление. Как быть?
          - SASS является дополнением к CSS.
          - Любой валидный CSS должен быть валидным и для SASS.
          - В CSS есть оператор / для разделения номеров в значениях св-в.
          - В SASS есть оператор /, который является оператором деления.
          - Есть 3 случая, когда / будет считаться оператором деления:

            1. Если значение или его часть сохранены в переменной, или возвращается функцией.
            2. Если значение в круглых скобках ()
              - Кроме случая, () это массив, а значение находится внутри.
            3. Если значение является частью другой арифметической операции.

          - Примеры:

            p {
              font: 10px/8px;               // Разделитель
              $width: 1000px;
              width: $width/2;              // Деление (случай 1)
              width: round(1.5)/2;          // Деление (случай 1)
              height: (500px/2);            // Деление (случай 2)
              margin-left: 5px + 8px/2px;   // Деление (случай 3)
              font: (italic bold 10px/8px); // Разделитель (исключение из случая 3)
            }

        # Одновременное использование разделителя / и переменных
          - Для этого можно использовать интерполяцию #{}
          - Например:

            • styles.scss

                p {
                  $font-size: 12px;
                  $line-height: 30px;
                  font: #{$font-size}/#{$line-height};
                }

            • styles.css

                p {
                  font: 12px/30px; }

        # Есть 4 возможных значения оператора -
          - В зависимости от контекста оно компилируется по-разному.
          - Вот эти возможные значения:
            • Бинарный оператор вычитания (5px - 3px)
            • Унарный оператор отрицательности (-$var)
            • Начало отрицательного числа (-3px)
            • Часть идентификатора (font-weight)
          - В большинстве случаев по контексту ясно, какой вариант перед нами.
          - Но есть ситуации, в которых может быть не очень ясно.
          - Чтобы обезопаситься, следуй следующим правилам:

            • При вычитании ставь пробелы справа и слева от -
              - Плохо: 5px-3px
              - Хорошо: 5px - 3px

            • При унарной операции ставь пробел слева, но не справа
              - Плохо: - $x
              - Хорошо: -$x

            • При унарной операции в массиве с разделителями-пробелами используй ()
              - Плохо: 10px -$x
              - Хорошо: 10px (-$x)

          - Примеры:

            • 5px - 3px == 5px-3px  | все ОК
            • 1 - 2 == 1-2          | все ОК
            • 1 -2 != 1-2           | 1 -2 это массив из 2-х элементов
            • 1 -$x == 1 - $x       | все ОК (это не массив, а вычитание)

        # Примеры операций с числами

            $x: 20                  $x: 20px
            $y: 10                  $y: 10px

            $x + $y     | 30        $x + $y     | 30px
            $x - $y     | 10        $x - $y     | 10px
            $x * $y     | 200       $x * $y     | 200px*px  // ошибка!
            $x / $y     | 2         $x / $y     | 2         // без px !
            $x % $y     | 0         $x % $y     | 0px
            $x == $y    | false     $x == $y    | false
            $x != $y    | true      $x != $y    | true
            $x > $y     | true      $x > $y     | true
            $x >= $y    | true      $x >= $y    | true
            $x < $y     | false     $x < $y     | false
            $x <= $y    | false     $x <= $y    | false

      • Цвета [ + - * / % == != ]

        # Операции с цветами работают "кусочным" образом
          - Как известно, RGB-цвет состоит из 3-х составляющи.
          - Например: #112233 имеет составляющие R:11, G:22, B:33
          - Арифм.операции с цветами применяются отдельно к этим 3-ём.
          - Например:

            #010203 + #040506     | #050709

          - Как это получилось? Вот так:

            01 02 03
            +  +  +
            04 05 06
            || || ||
            05 07 09

        # Лучше использовать sass-функции для работы с цветами, чем арифм.операции
          - Так советуют разработчики sass.

        # Возможны арифм.операции между цветами и числами
          - Они также работают кусочным образом.
          - Например:

            #010203 * 2     | #020406

        # Операция между цветами с α-каналом и без вызовет ошибку
          - Либо у обоих операндов-цветов должны быть α-каналы.
          - Либо у обоих операндов-цветов не должно быть α-каналов.
          - В случае наличия α-каналов они ДОЛЖНЫ БЫТЬ ОДИНАКОВЫЕ.
          - При нарушении этих правил будет ошибка.
          - Пример операции без ошибки:

            p {
              color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
            }

        # Примеры операций с цветами

            $x:           #333333     $x:           rgba(255, 0, 0, 0.75)
            $y:           #111111     $y:           rgba(0, 255, 0, 0.75)

            $x + $y     | #444444     $x + $y     | rgba(255, 255, 0, 0.75)
            $x - $y     | #222222     $x - $y     | rgba(255, 0, 0, 0.75)
            $x * $y     | #ffffff     $x * $y     | rgba(0, 0, 0, 0.75)
            $x / $y     | #030303     $x / $y     | ошибка (деление на 0)!
            $x % $y     | #000000     $x % $y     | ошибка (деление на 0)!
            $x == $y    | false       $x == $y    | false
            $x != $y    | true        $x != $y    | true

      • Строки [ + == != ]

        # Конкатенация строк в кавычках и без даёт строку в кавычках
          - Например:

            "Foo " + Bar    | "Foo Bar"

        # Можно интерполировать значения прямо внутрь строки ""
          - Например:

            "I ate #{5 + 10} pies!"   | "I ate 15 pies!"

          - При интерполяции null рассматривается, как пустая строка.
          - Например:

            $value: null;
            "I ate #{$value} pies!"   | "I ate  pies!"

        # Примеры операций со строками

            "Foo " + Bar              | "Foo Bar"
            'Foo ' + Bar              | "Foo Bar"
            foo + bar                 | "foobar"
            "I ate #{5 + 10} pies!"   | "I ate 15 pies!"

            $value: null;
            "I ate #{$value} pies!"   | "I ate  pies!"

      • Булеан [ and or not == != ]

        $x: true                $x: true                $x: false
        $y: true                $y: false               $y: false

        $x and $y   | true      $x and $y   | false     $x and $y   | false
        $x or $y    | true      $x or $y    | true      $x or $y    | false
        not $x      | false     not $x      | false     not $x      | true
        not $y      | false     not $y      | true      not $y      | true

      • Массивы [ == != ]

        # Массивы не поддерживают никаких особых операций
          - Сабж.
          - Поддерживают только == и !=, которые поддерживают все типы.

        # Примеры операций с массивами

          (1,2,3) == (1,2,3)    | true
          (1 2 3) == (1 2 3)    | true
          (1,2,3,4) != (1,2,3)  | true
          (1 2 3 4) != (1 2 3)  | true
          1 2 3 == 1 2 3        | (1 2 false 2 3)
          1,2,3 == 1,2,3        | (1, 2, false, 2, 3)


    # Переменные: порядок операций ()
      - Порядком операций в выражении можно управлять с помощью ()
      - Например, такой SASS:

          p {
            width: 1em + (2em * 3);
          }

      - Превращается в такой CSS:

          p {
            width: 7em; }

    # Переменные: интерполяция в селекторах #{}
      - С помощью конструкции #{} можно делать интерполяцию.
      - То есть вставлять прямо в селектор некоторое значение.
      - Пример говорит красноречивее слов:

        • style.scss

            $name: foo;
            $attr: border;
            p.#{$name} {
              #{$attr}-color: blue;
            }

        • style.css

            p.foo {
              border-color: blue; }

      - Ещё пример, решающий проблему с / - делением и / - разделителем:

        • style.scss

          p {
            $font-size: 12px;
            $line-height: 30px;
            font: #{$font-size}/#{$line-height};
          }

        • style.css

          p {
            font: 12px/30px; }

    # Переменные: списки род.селекторов &

      • Демонстрация сути & при работе с переменными
        - & в SassScript ссылается на текущий родительский селектор.
        - Он возвращает массив массивов родительских селекторов.
        - Внешний массив имеет разделители-запятые, а внутренний - пробелы.
        - Например:

          .foo.bar .baz.bang, .bip.qux {
            $selector: &;
          }

          $selector == ((.foo.bar .baz.bang), .bip.qux)

      • Если родит.селектор отсутствует, & == null
        - Это можно использовать, например, в миксинах.
        - Чтобы определять, существует ли родит.селектор.
        - Пример такой миксины:

          @mixin does-parent-exist {
            @if & {
              &:hover {
                color: red;
              }
            } @else {
              a {
                color: red;
              }
            }
          }

    # Переменные: флаг !default

      • Флаг !default означает: инициировать, если ещё не инициирована
        - Если переменная уже инициирована, ничего не делать.
        - Если ещё не инициирована, инициировать указанным значением.
        - Например:

          • style.scss

            $content: "First content";
            $content: "Second content?" !default;
            $new_content: "First time reference" !default;

            #main {
              content: $content;
              new-content: $new_content;
            }

          • style.css

            #main {
              content: "First content";
              new-content: "First time reference"; }

      • !default считает null-значение не инициированными
        - И действует соответствующе.
        - Например:

          • style.scss

            $content: null;
            $content: "Non-null content" !default;

            #main {
              content: $content;
            }

          • style.css

            #main {
              content: "Non-null content"; }


А8. Встроенные функции в SASS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по встроенным функциям в SASS

      • RGB

        - rgb   | ($red, $green, $blue)         | Создать объект color из значений red/green/blue
        - rgba  | ($red, $green, $blue, $alpha) | Создать объект color из значений red/green/blue/alpha
        - red   | ($color)                      | Извлечь red-компонент из объекта-цвета
        - green | ($color)                      | Извлечь green-компонент из объекта-цвета
        - blue  | ($color)                      | Извлечь blue-компонент из объекта-цвета
        - mix   | ($color1, $color2, [$weight]) | Смешать 2-ва цвета

      • HSL

        - hsl         | ($hue, $saturation, $lightness)         | Создать цвет из значений hue/saturation/lightness
        - hsla        | ($hue, $saturation, $lightness, $alpha) | Создать цвет из значений hue/saturation/lightness/alpha
        - hue         | ($color)                | Извлечь hue-компонент из объекта-цвета
        - saturation  | ($color)                | Извлечь saturation-компонент из объекта-цвета
        - lightness   | ($color)                | Извлечь lightness-компонент из объекта-цвета
        - adjust-hue  | ($color, $degrees)      | Изменить hue-компонент объекта-цвета
        - lighten     | ($color, $amount)       | Сделать цвет светлее
        - darken      | ($color, $amount)       | Сделать цвет темнее
        - saturate    | ($color, $amount)       | Сделать цвет насыщеннее
        - desaturate  | ($color, $amount)       | Сделать цвет менее насыщенным
        - grayscale   | ($color)                | Конвертировать цвет в чёрно-белый
        - complement  | ($color)                | Отразить цвет
        - invert      | ($color)                | Инвертировать цвет

      • Opacity

        - alpha                     | ($color)          | Извлечь alpha-компонент цвета
        - rgba                      | ($color, $alpha)  | Изменить alpha-компонент цвета
        - opacify (fade-in)         | ($color, $amount) | Сделать цвет более прозрачным
        - transparentize (fade-out) | ($color, $amount) | Сделать цвет менее прозрачным

      • Прочие функции для работы с цветами

        - adjust-color            | Увеличить/Уменьшеть 1-ин или более компонентов цвета    | ($color, [$red], [$green], [$blue], [$hue], [$saturation], [$lightness], [$alpha])
        - scale-color             | Гибко масштабировать 1-ин или более компонентов цвета   | ($color, [$red], [$green], [$blue], [$saturation], [$lightness], [$alpha])
        - change-color            | Изменить 1-ин или более компонентов цвета               | ($color, [$red], [$green], [$blue], [$hue], [$saturation], [$lightness], [$alpha])
        - ie-hex-str              | Конвертировать цвет в формат, понимаемый фильтрами IE   | ($color)

      • String

        - unquote       | ($string)             | Удалить кавычки у строки
        - quote         | ($string)             | Завернуть строку в кавычки
        - str-length    | ($string)             | Вернуть кол-во символов в строке
        - str-insert    | ($string, $insert, $index)     | Вставить в строку подстроку на указанной позиции
        - str-index     | ($string, $substring)          | Вернуть позицию первого вхождения подстроки в строку
        - str-slice     | ($string, $start-at, [$end-at])| Получить подстроку из строки начиная с и до
        - to-upper-case | ($string)             | Конвертировать строку в верхний регистр
        - to-lower-case | ($string)             | Конвертировать строку в нижний регистр

      • Number

        - percentage  | ($number)     | Конвертировать простое число в %
        - round       | ($number)     | Округлить число до ближайшего целого
        - ceil        | ($number)     | Округлить число вверх до ближайшего целого
        - floor       | ($number)     | Округлить число вниз до ближайшего целого
        - abs         | ($number)     | Взять число по модулю
        - min         | ($numbers…)   | Найти минимальное из переданных чисел
        - max         | ($numbers…)   | Найти максимальное из переданных чисел
        - random      | ([$limit])    | Вернуть случайное число до указанного лимита

      • List (массивы)

        - length          | ($list)             | Вернуть длину массива
        - nth             | ($list, $n)         | Вернуть эл-т массива с указанным индексом
        - set-nth         | ($list, $n, $value) | Заменить значение эл-та массива с указанным индексом на указанное
        - join            | ($list1, $list2, [$separator])  | Объединить два массива в один
        - append          | ($list1, $val, [$separator])    | Добавить 1-но значение в конец указанного массива
        - zip             | ($lists…)           | Объединить несколько массивов в 1-ин многомерный массив
        - index           | ($list, $value)     | Найти указанное значение в указанном массиве, и вернуть его индекс в массиве
        - list-separator  | ($list)             | Вернуть используемый в массиве разделитель (запятая или пробел)

      • Map (объекты)

        - map-get     | ($map, $key)    | Извлечь из указанного объекта значение с указанным ключём
        - map-merge   | ($map1, $map2)  | Объединить 2-ва указанных объекта в 1-ин
        - map-remove  | ($map, $keys…)  | Удалить из указанного объекта значения с указанными ключами, вернуть новый объект
        - map-keys    | ($map)          | Вернуть массив всех ключей объекта
        - map-values  | ($map)          | Вернуть массив всех значений объекта
        - map-has-key | ($map, $key)    | Проверить наличие указанного ключа в объекте
        - keywords    | ($args)         | Вернуть объект аргументов, переданных функции или миксине

      • Selector

        - selector-nest     | ($selectors…)     | Объедитить значения в строку значений, разделённых пробелами
        - selector-append   | ($selectors…)     | Объедитить значения в строку значений, НЕ разделённых пробелами
        - selector-extend   | ($selector, $extendee, $extender)     | Из 1-го получить 1-ин селектор, состоящий из N селекторов (через запятую)
        - selector-replace  | ($selector, $original, $replacement)  | Find & Replace строку в селекторе
        - selector-unify    | ($selector1, $selector2)              | Скомбинировать 2 сел-ра в 1, который матчит все эл-ы, которые матчили те два, или вернуть null
        - is-superselector  | ($super, $sub)    | Вернуть true/false, матчит ли селектор $super все эл-ты, которые матчик $sub
        - simple-selectors  | ($selector)       | Разбить составной селектор на массив менее сложных
        - selector-parse    | ($selector)       | Распарсить селектор в формат, возвращаемый &

      • Introspection

        - feature-exists          | ($feature)            | Проверить наличие указанного функционала в текущей Sass-runtime
        - variable-exists         | ($name)               | Проверить доступность указанной переменной в текущей области видимости
        - global-variable-exists  | ($name)               | Проверить доступность глобальной указанной переменной
        - function-exists         | ($name)               | Проверить доступность функции с указанным именем
        - mixin-exists            | ($name)               | Проверить доступность миксины с указанным именем
        - inspect                 | ($value)              | Сконвертировать значение sass -> css, получив итоговую строку
        - type-of                 | ($value)              | Получить тип значения
        - unit                    | ($number)             | Получить unit числового значения (%, px, ..)
        - unitless                | ($number)             | Вернуть true/false, имеет ли число unit
        - comparable              | ($number1, $number2)  | Вернуть true/false, могут ли 2 числовых значения +, -, или быть сравнены
        - call                    | ($name, $args…)       | Динамически вызывать sass функцию

      • Прочие

        - if        | ($condition, $if-true, $if-false) | Вернуть 1-е или 2-е значение, в зависимости от того, true или false указанное условие
        - unique-id | ()                                | Вернуть уникальный CSS-идентификатор

  --------------------------------------

  > Ссылки

    # Соответствующий раздел оф.документации
        http://sass-lang.com/documentation/Sass/Script/Functions.html

  > Введение
    - Функции в SASS бывают встроенные и кастомные.
    - В этой главе НЕ описано создание кастомных функций.
    - А лишь присутствует справочник по всем встроенным функциям.

  > Справочник по встроенным функциям в SASS
    - Подавляющее большинство встроенных функций являются интуитивно-понятными.
    - Поэтому тратить время на переписыванию сюда примеров смысла нет.
    - Если что-то станет не понятно, посмотри пример в оф.справочнике:

        http://sass-lang.com/documentation/Sass/Script/Functions.html


А9. @-директивы, условные операции/циклы, миксины, функции

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # @-директивы SASS, условные операции/циклы, миксины, функции

      • Общего назначения

        - @import

          ▪ Общая информация об @import
            ▪ Может импортировать .scss- и .sass-файлы
            ▪ Любые переменные и миксины из @imported-файла м.б. использованы в основном файле
            ▪ SASS ищет .scss- и .sass-файлы в текущем каталоге
            ▪ Ситуации, когда @import скомпилируется в css-директиву
            ▪ Примеры использования @import для импортирования файлов

          ▪ Фрагменты и @import
            ▪ Общая информация про фрагменты в SASS
            ▪ Префиксинг имён файлов-фрагментов символом _
            ▪ Как импортировать файлы-фрагменты

          ▪ Вложенный @import
            ▪ @import можно использовать в css- и @media-правилах
            ▪ В импортируемых не в глобальный scope файлах нельзя применять директивы, разрешённые лишь глобально
            ▪ Пример использования вложенного @import

        - @media

          ▪ Доп.особенность @media в SASS: м.б. вложенными, всплывают
          ▪ Примеры использования @media

        - @extend

          ▪ Про наследование в SASS
          ▪ Примеры наследования в SASS

        - @at-root

          ▪ <selector>
          ▪ { <selector1> <selector2> ... }
          ▪ (without: ...) и (with: ...)
          ▪ Спец.значения: rule / all

        - @debug
        - @warn
        - @error

      • Условные операции и циклы

        - if()
        - @if
        - @for
        - @each
        - @while

      • Миксины

        - @mixin
        - @include

      • Функции

        - @function
        - @return

  --------------------------------------

  > Ссылки

    # Соответствующий раздел оф.документации
        http://sass-lang.com/documentation/file.SASS_REFERENCE.html#directives 

  > Введение
    - В обычном CSS уже присутствует ряд @-директив.
    - Но в этой главе будут рассмотрены лишь @-директивы SASS.

  > @-директивы SASS, условные операции/циклы, миксины, функции

    # @import

      - Общая информация об @import

        • Может импортировать .scss- и .sass-файлы
          - SASS дополняет стандартный @import вот таким вот образом.
          - Все импортированные файлы будут слиты в один css-файл на выходе.

        • Любые переменные и миксины из @imported-файла м.б. использованы в основном файле
          - Сабж.

        • SASS ищет .scss- и .sass-файлы в текущем каталоге
          - А также в каталоге sass-файлов в Rack, Rails, or Merb.
          - Доп.пути для поиска можно указать опцией :load_paths

        • Ситуации, когда @import скомпилируется в css-директиву
          - То есть SASS не будет трогать данную @import-директиву.
          - И она в своём изначальном виде так и попадёт в итоговый css-файл.
          - Такой происходит в следующих случаях:

            ▪ Если расширение импортируемого файла: .css
            ▪ Если имя файла начинается с: http://
            ▪ Если имя файла: url()
            ▪ Если @import имеет любые media-запросы

          - Если ни одно из выше указанных условий не выполнено.
          - И импортируемый файл имеет расширение .scss или .sass.
          - То SASS будет пытаться найти и импортировать этот файл.

        • Примеры использования @import для импортирования файлов

          ▪ В следующем случае SASS обрабатывает @import
            @import "foo.scss";             | @import "foo";

          ▪ В следующих случаях @import попадает в css "как есть"
            @import "foo.css";              | @import "foo.css";
            @import "foo" screen;           | @import "foo" screen;
            @import "http://foo.com/bar";   | @import "http://foo.com/bar";
            @import url(foo);               | @import url(foo);

          ▪ Импортирование сразу нескольких файлов
            @import "rounded-corners", "text-shadow";

          ▪ Применение интерполяции #{} при импортировании
            $family: unquote("Droid+Sans");
            @import url("http://fonts.googleapis.com/css?family=#{$family}");   | @import url("http://fonts.googleapis.com/css?family=Droid+Sans");

      - Фрагменты и @import

        • Общая информация про фрагменты в SASS
          - Ты можешь создавать файлы-фрагменты-scss.
          - В них можно класть небольшие фрагменты scss-кода.
          - Чтобы в дальнейшем повторно использовать их.
          - Импортируя файлы-фрагменты в другие scss-файлы.

        • Префиксинг имён файлов-фрагментов символом _
          - Имя файла фрагмента строится по шаблону:

              _[имя].scss

          - Это даёт понять компилятору SASS, что перед ним файл-фрагмент.
          - И он не компилирует его, как отдельный SASS-файл.

        • Как импортировать файлы-фрагменты
          - Обращаясь к ним по имени, но не указывая префикс _
          - Например:

              @import "[имя]";

      - Вложенный @import

        • @import можно использовать в css- и @media-правилах
          - Чаще всего @import используется в глобальной области видимости.
          - Но можно его использовать и в css-, и @media-правилах.
          - Тогда всё импортируется в соответствующую область видимости.
          - Импортированные правила становятся вложенными в соотв.селектор.

        • В импортируемых не в глобальный scope файлах нельзя применять директивы, разрешённые лишь глобально
          - Например, @mixin или @charset разрешено использовать лишь в глобальной области видимости.
          - Поэтому файл с этими директивами нельзя вложенно импортировать.

        • Пример использования вложенного @import

          ▪ _partial.scss

            .example {
              color: red;
            }

          ▪ styles.scss

            #main {
              @import "example";
            }

          ▪ styles.css

            #main .example {
              color: red;
            }

        •

    # @media

      • Доп.особенность @media в SASS: м.б. вложенными, всплывают
        - @media в SASS ведут себя также, как в обычном CSS.
        - Но с одной дополнительной особенностью.
        - Они могут быть вложены в CSS-правила.
        - Вложенные в CSS-правила @media "всплывают" на глобальный уровень.
        - Добавляя все селекторы на своём пути в правило.

      • Примеры использования @media

        ▪ Пример №1

          ▪ style.scss

            .sidebar {
              width: 300px;
              @media screen and (orientation: landscape) {
                width: 500px;
              }
            }

          ▪ style.css

            .sidebar {
              width: 300px; }
              @media screen and (orientation: landscape) {
                .sidebar {
                  width: 500px; } }

        ▪ Пример №2 (вложенные друг в друга @media)

          ▪ style.scss

              @media screen {
                .sidebar {
                  @media (orientation: landscape) {
                    width: 500px;
                  }
                }
              }

          ▪ style.css

              @media screen and (orientation: landscape) {
                .sidebar {
                  width: 500px; } }

        ▪ Пример №3 (применение SassScript в @media)

          ▪ style.scss

              $media: screen;
              $feature: -webkit-min-device-pixel-ratio;
              $value: 1.5;

              @media #{$media} and ($feature: $value) {
                .sidebar {
                  width: 500px;
                }
              }

          ▪ style.css

              @media screen and (-webkit-min-device-pixel-ratio: 1.5) {
                .sidebar {
                  width: 500px; } }

    # @extend

      • Про наследование в SASS
        - Это одна из самых полезных функций в SASS.
        - Один селектор может наследовать св-ва у другого.
        - Это можно осуществлять с помощью директивы @extend
        - Наследующий селектор применяет @extend внутри себя.
        - В качестве аргумента указывается наследуемый селектор.
        - Ниже приведёт наглядный пример.

      • Обычное наследование
        - Как это работает?
        - SASS ищет все селекторы, которые матчатся с аргументом @extend.
        - И затем просто добавляют им через , селектор плавила в котором @extend.
        - При этом SASS достаточно умён, чтобы избегать дублирования селекторов.
        - Например, scss:

            .error {
              border: 1px #f00;
              background-color: #fdd;
            }
            .error.intrusion {
              background-image: url("/image/hacked.png");
            }
            .seriousError {
              @extend .error;
              border-width: 3px;
            }

        - И css:

            .error, .seriousError {
              border: 1px #f00;
              background-color: #fdd; }

            .error.intrusion, .seriousError.intrusion {
              background-image: url("/image/hacked.png"); }

            .seriousError {
              border-width: 3px; }

      • Наследование для сложных селекторов
        - Наследование работает не только с селекторами классов.
        - А можно применять его для целых HTML-тегов.
        - Например, в следующем случае:

            .hoverlink {
              @extend a:hover;
            }
            a:hover {
              text-decoration: underline;
            }
            .comment a.user:hover {
              font-weight: bold;
            }

        - Стили из обоих селекторов под ним применятся к .hoverlink
        - Даже второй, хоть он и не "a:hover", а "a.user:hover".
        - И в итоговом css будет:

            a:hover, .hoverlink, .comment a.user:hover, .comment .user.hoverlink {
              font-weight: bold; }

      • Множественное наследование
        - Один селектор может наследовать от N селекторов.
        - При это он наследует все стили всех N селекторов.
        - Например, scss:

            .error {
              border: 1px #f00;
              background-color: #fdd;
            }
            .attention {
              font-size: 3em;
              background-color: #ff0;
            }
            .seriousError {
              @extend .error;
              @extend .attention;
              border-width: 3px;
            }

        - И мы имеем следующий css на выходе:

            .error, .seriousError {
              border: 1px #f00;
              background-color: #fdd; }

            .attention, .seriousError {
              font-size: 3em;
              background-color: #ff0; }

            .seriousError {
              border-width: 3px; }

        - Вместо набора выражений типа:

            @extend .error;
            @extend .attention;

        - Можно просто скормить @extend массив с запятыми-разделителями:

            @extend .error, .attention

      • Цепочки наследования
        - 1-ин селектор может наследовать от 2-го, 2-й от 3-го, и т.д.
        - Например, scss:

            .error {
              border: 1px #f00;
              background-color: #fdd;
            }
            .seriousError {
              @extend .error;
              border-width: 3px;
            }
            .criticalError {
              @extend .seriousError;
              position: fixed;
              top: 10%;
              bottom: 10%;
              left: 10%;
              right: 10%;
            }

        - И в итоге имеем css:

            .error, .seriousError, .criticalError {
              border: 1px #f00;
              background-color: #fdd; }

            .seriousError, .criticalError {
              border-width: 3px; }

            .criticalError {
              position: fixed;
              top: 10%;
              bottom: 10%;
              left: 10%;
              right: 10%; }

      • Наследование для цепочек селекторов
        - Цепочки селекторов в настоящий момент не могут быть унаследованными.
        - То есть нельзя указать что-то вроде: @extend .foo .bar
        - Где ".foo .bar" это цепочка селекторов.
        - Зато вложенные селекторы могут сами наследовать.
        - Например, scss:

            #fake-links .link {
              @extend a;
            }

            a {
              color: blue;
              &:hover {
                text-decoration: underline;
              }
            }

        - И итоговый css:

            a, #fake-links .link {
              color: blue; }
              a:hover, #fake-links .link:hover {
                text-decoration: underline; }

      • Наследование от селектора в цепочке селекторов
        - Цепочка селекторов может наследовать от другого селектора.
        - А этот другой селектор может быть в другой цепочке селекторов.
        - Например:

            #admin .tabbar a {
              font-weight: bold;
            }
            #demo .overview .fakelink {
              @extend a;
            }

      • Селекторы-плейсхолдеры %

        ▪ SASS поддерживает спец.типы селекторов - "селекторы-плейсхолдеры"
          - Они типа . и # селекторов, только используется символ %
          - Они предназначены для использования с директивой @extend.
          - Без связки с @extend эти селекторы никак ни на что не влияют.

        ▪ Зачем нужны селекторы-плейсхолдеры
          - Они пригодятся, если:

            ▪ Мы хотим создать новый класс.
            ▪ Но не хотим, чтобы он попал в итоговый CSS.
            ▪ Но хотим наследовать от него в других классах

        ▪ Пример использования селектора-плейсхолдера

          ▪ Файл "styles.scss"

            #context a%extreme {
              color: blue;
              font-weight: bold;
              font-size: 2em;
            }

            .notice {
              @extend %extreme;
            }

          ▪ Файл "styles.css"

            #context a.notice {
              color: blue;
              font-weight: bold;
              font-size: 2em; }

      • Флаг !optional для избежания ошибок
        - Этот флаг можно применять вместе с @extend.
        - Если селектора в аргументе @extend не существует, будет ошибка.
        - Но с флагом !optional эта ошибка при компиляции не возникнет.
        - Просто соответствующий @extend будет проигнорирован.
        - Пример:

            a.important {
              @extend .notice !optional;
            }

      • @extend в директивах
        - Есть кое-какие ограничения на использование @extend внутри других директив.
        - SASS не может заставить CSS-правила вне блоков директив
          примениться к селекторам внутри этих блоков, без создания
          огромного количества доп.стилей, копируя стили отовсюду.
        - Короче, применять @extend внутри блоков других директив надо
          лишь к тем селекторам, которые находятся в этих же блоках.
        - Например, это работает нормально:

            @media print {
              .error {
                border: 1px #f00;
                background-color: #fdd;
              }
              .seriousError {
                @extend .error;
                border-width: 3px;
              }
            }

        - Но вот это вызовет ошибку:

            .error {
              border: 1px #f00;
              background-color: #fdd;
            }

            @media print {
              .seriousError {
                // INVALID EXTEND: .error is used outside of the "@media print" directive
                @extend .error;
                border-width: 3px;
              }
            }

    # @at-root

      • Общая информация об @at-root
        - Позволяет поместить css-правило в глоб-ую область видимости.
        - Актуально для вложенных css-правил.

      • <selector>
         - Формат: @at-root <selector>
         - Например, scss:

            .parent {
              ...
              @at-root .child { ... }
            }

         - И css на выходе:

            .parent { ... }
            .child { ... }

      • { <selector1> <selector2> ... }
         - Или можно использоваь с блоком, содержащим много селекторов.
         - Например, scss:

            .parent {
              ...
              @at-root {
                .child1 { ... }
                .child2 { ... }
              }
              .step-child { ... }
            }

         - И css на выходе:

            .parent { ... }
            .child1 { ... }
            .child2 { ... }
            .parent .step-child { ... }

      • (without: ...) и (with: ...)
        - По умолчанию @at-root применяется к селекторам.
        - Но можно его применять и для вынесения из директив.
        - Например, scss:

            @media print {
              .page {
                width: 8in;
                @at-root (without: media) {
                  color: red;
                }
              }
            }

        - Даёт такой css:

            @media print {
              .page {
                width: 8in;
              }
            }
            .page {
              color: red;
            }

        - Таким образов, without позволяет выносить из директив.
        - Можно также указывать сразу несколько директив:

            (without: media supports)

        - С помощью with можно укзать, откуда выносить не надо.

      • Спец.значения: rule / all
        - rule указывает на то, что надо вынести из всех CSS-правил.
        - all указывает, что надо вынести и из правил, и из директив

    # @debug
      - Выводит значение SassScript выражение в выходной поток ошибок.
      - Применяется для отладки sass-файлов со сложными скриптами.
      - Например:

          @debug 12em + 10em;

      - Даёт такой вывод:

          Line 1 DEBUG: 22em

    # @warn
      - Выводит значение SassScript выражение в выходной поток ошибок.
      - Полезно для библиотек, позволяет предупредить пользователей.
      - Например, об истечении сроков годности.
      - Или сообщить возможные заметки по свежим релизам.
      - Есть 2 важных отличие @warn и @debug:

        1) Warnings можно отключить CLI-опцией --quiet
          - Или SASS-опцией :quiet.

        2) Warnings выводят stylesheet trace

      - Пример использования:

        @mixin adjust-location($x, $y) {
          @if unitless($x) {
            @warn "Assuming #{$x} to be in pixels";
            $x: 1px * $x;
          }
          @if unitless($y) {
            @warn "Assuming #{$y} to be in pixels";
            $y: 1px * $y;
          }
          position: relative; left: $x; top: $y;
        }

    # @error
      - Выводит значение SassScript выражение в выходной поток ошибок.
      - Это считается фатальной ошибкой.
      - Также выводит stack trace.
      - Так можно валидировать аргументы для миксин и функций.
      - Например:

          @mixin adjust-location($x, $y) {
            @if unitless($x) {
              @error "$x may not be unitless, was #{$x}.";
            }
            @if unitless($y) {
              @error "$y may not be unitless, was #{$y}.";
            }
            position: relative; left: $x; top: $y;
          }

      - Однако, на данный момент нет способа отлавливать ошибки.

    # if()


    # @if


    # @for


    # @each


    # @while



    # @mixin


    # @include



    # @function


    # @return






