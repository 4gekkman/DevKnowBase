////==================================================////
////                                                  ////
////                    NodeJS + NPM                  ////
////                                                  ////
////==================================================////
////                      ////
////         Ссылки       ////
////                      ////
////======================////


  // Официальные ресурсы //
  //---------------------//

    # Официальный сайт NodeJS
        http://nodejs.org/

    # Node Package Modules, пакетный менеджер для JS
        https://www.npmjs.com/

    # Официальный справочник по API V5.*
        https://nodejs.org/dist/latest-v5.x/docs/api/


  // Сторонние ресурсы для обучения //
  //--------------------------------//

    # Скринкаст по NodeJS от Ильи Кантора
        http://learn.javascript.ru/screencast/nodejs

    # Руководство по NodeJS от Felix Geisendörfer (2011)
        http://nodeguide.ru/             // RU
        http://nodeguide.com/            // EN

    # Набор блогов про NodeJS, созданный by Tim Caswell, поддерживаемый сообществом
        http://howtonode.org/

    # Quora: what is the best way of learning node js (см. ответ от Samer Buna)
        https://www.quora.com/What-is-the-best-way-of-learning-Node-js

    # Сайт callbackhell.com, понимание асинхронности всего в nodejs
        http://callbackhell.com/

    # Пишем микросервис на KoaJS 2 в стиле ES2017. Часть I: Такая разная ассинхронность
        https://habrahabr.ru/post/306816/

    # Пишем микросервис на KoaJS 2 в стиле ES2017. Часть II: Минималистичный REST
        https://habrahabr.ru/post/307148/
        

////==================================================////
////                         ////
////        Оглавление       ////
////                         ////
////=========================////


  # А.  NodeJS

    А1. NodeJS: общая информация
    А2. Установка NodeJS
    А3. Плагин NodeJS для PHPStorm
    А4. Стабильность модулей NodeJS
    А5. Модули в NodeJS: основы
    А6. Модули в NodeJS: приёмы
    А7. NPM-модуль Util
    А8. NPM-модуль Console
    А9. Наследование от встроенного объекта Error (как обрабатывать ошибки)
    А10. NPM-модуль Events: события, EventEmitter и утечки памяти
    А11. NodeJS: веб-сервер
    А11. NPM-модуль supervisor
    А12. Отладка: node debugger / chrome
    А13. Журналирование: NPM-модули debug / winston + NODE_DEBUG
    А14. Асинхронная разработка: введение
    А15. Таймеры в NodeJS, методы ref/unref
    А16. Файлы
    А17. Чтение параметров из командной строки и окружения
    А18. Потоки

  # Б.  Node Packages Manager (NPM)

    Б1. NPM: общая информация
    Б2. Установка NPM
    Б3. Установка NPM-пакетов (локально/глобально)
    Б4. Пространства имен NPM-пакетов
    Б5. Конфиг NPM-пакета package.json
    Б6. Конфигурирование NPM
    Б7. Структура каталогов NPM: что куда он записывает
    Б8. Скрипты и "хуки" NPM-пакетов (поле "scripts" в package.json)
    Б9. CLI-команды NPM
    Б10. Удаление NPM-пакетов (локальных/глобальных)
    Б11. Обновление NPM-пакетов (локальных/глобальных)

  # В.  Справочники

    В1.

  # Г.  Наработки

    Г1. Просмотр исходных кодов на JS встроенных модулей NodeJS
    Г2. Настройка автодополнения в PHPStorm для каталога с проектом NodeJS


////==================================================////
////                         ////
////        Содержание       ////
////                         ////
////=========================////


А1. NodeJS: общая информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # История создания
    # Что такое NodeJS
    # Области применения

      - Сервер
      - Десктоп
      - Микроконтроллеры

    # Альтернативы для NodeJS
    # Почему NodeJS?

  --------------------------------------

  > Ссылки

    # Wiki
        https://ru.wikipedia.org/wiki/Node.js

  > Введение
    - Рассмотрим общую информацию о NodeJS.
    - Чтобы понимать, что это такое.

  > История создания
    - NodeJS разработал Райан Дал (англ. Ryan Dahl) в 2009 году.
    - В ходе своих исследований он пришёл к выводу, что вместо традиционной модели
      параллелизма на основе потоков следует обратиться к событийно-ориентированным системам.
    - Эта модель была выбрана из-за простоты, низких накладных расходов (по сравнению с
      идеологией «один поток на каждое соединение») и быстродействия.
    - Разработка Node.js спонсируется компанией Joyent.
    - В декабре 2014 года был создан форк io.js.
    - Форк был осуществлён некоторыми из основных разработчиков node.js, недовольными тем, как компания
      Joyent[en] руководила проектом, и неготовностью компании принимать в проект вклад сторонних разработчиков[1],
      из-за чего проект почти не развивался с 2013 года.
    - В мае 2015 года было принято решение о слиянии io.js и Node.js и дальнейшем развитии под эгидой Node.js Foundation.
    - 8 сентября 2015 года вышел Node.js v4.0.0 как результат слияния Node.js v0.12.7 и io.js v3.3.0.

  > Что такое NodeJS

    # Определение с официального сайта

      Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.
      Node.js uses an event-driven, non-blocking I/O model that makes it lightweight
      and efficient. Node.js' package ecosystem, npm, is the largest ecosystem
      of open source libraries in the world.

    # Определение от Ильи Кантора
      - NodeJS = V8 + I/0 + библиотеки.
      - Один V8 не умеет работатью с сетью, читать/писать файлы и т.д.
      - Поэтому Райан добавил эту возможность с помощью спец.библиотек.
      - В результате, из NodeJS можно сделать веб-сервер.

    # NodeJS использует движок V8
      - V8: Движок JavaScript с открытым программным кодом, распространяемый по лицензии BSD.
      - Разработан датским отделением компании Google.
      - Компилирует исходный JS непосредственно в собственный машинный код,
        минуя стадию промежуточного байт-кода.
      - Обладает эффективной системой управления памятью.
      - Суть: превращает javascript из узкоспециализированного языка в язык общего назначения.

    # NodeJS событийно-ориентирован
      - NodeJS является событийно-ориентированной, асинхронной платформой.

    # NodeJS может взаимодействовать с устройствами ввода-вывода
      - Node.js добавляет возможность JS взаимодействовать с устр-ми ввода-вывода.
      - Он может это делать через свой API (написанный на C++).
      - Также есть возможность подключать библиотеки, написанные на других языках.
      - И обеспечивать вызовы к ним из javascript-кода.

  > Области применения

    1) Сервер
      - NodeJS выполняет роль серверной платформы.
      - К примеру, как php или ruby.

    2) Десктоп
      - На NodeJS можно писать десктопные оконные приложения.
      - Применяя, например, NW.js, AppJS или Electron (наверное, лучший вариант).

    3) Микроконтоллеры
      - С помощью NodeJS можно программировать микроконтроллеры.
      - Например, tessel и espruino.

  > Альтернативы для NodeJS
    - Rhino, JSC, WSH, и прочие.
    - Все они уступают в эффективности V8.

  > Почему NodeJS?

    1) Применение JS на сервере.
    2) Применение одних и тех же библиотек общего назначения на сервере и в клеинте.
    3) Позволяет решать основные задачи для web
      - Работа с базами данных.
      - Низкоуровневый доступ к сети (http, https, udp, tcp, ...).
      - Изначально проектировался для решения задач под web.
    4) Хорош там, где нужно поддерживать большое кол-во одновременных соединений.
      - Так как NodeJS событийно-ориентирован.
      - Например, это может быть онлайн игра с большим кол-вом одновременых соединений.
    5) Очень легко сделать рабочий прототип
      - Легко сделать что-то готовое быстро.
    6) Удобный, крупнейший в мире менеджер пакетов NPM
    7) Большое сообщество, поддерживающее NodeJS
      - Благодаря этому существует огромное кол-во готовых модулей.


А2. Установка NodeJS

  --------------------------------------
  Подоглавление:

    # Установка на Windows
    # Установка на Linux
    # Запуск JS-файла под NodeJS

  --------------------------------------

  > Установка на Windows

    1) Скачать с http://nodejs.org/ инсталлер.
    2) Запустить, установить NodeJS в нужную папку.
    3) Интерпретатор будет доступен в этой папке с именем node.exe.
    4) Инсталятор автоматом пропишет в path среды путь к папке с node.
    5) После установки надо перезагрузить conemu, чтобы он всосал новую path.
    6) Проверить работоспособность, можно введя: node -v

  > Установка на Linux

    1) Выполнить команду: sudo apt-get update && apt-get install nodejs
    2) Проверить работоспособность, можно введя: node -v

  > Запуск JS-файла под NodeJS
    - Можно создать новый файл j.js (для теста).
    - В нём написать: console.log(123);
    - И, перейдя в каталог с этим файлом, запустить его через nodejs:

        node j.js

    - В консоли должно быть выведено сообщение: 123.


А3. Плагин NodeJS для PHPStorm

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка плагина
    # Примечание

  --------------------------------------

  > Ссылки

    # Плагин NodeJS для PHPStorm
        https://www.jetbrains.com/phpstorm/help/node-js.html

  > Введение
    - Для PHPStorm существует плагин NodeJS.
    - Благодаря ему PHPStorm распознаёт код для NodeJS.
    - В PHPStorm 10 поддержка NodeJS встроена.

  > Установка плагина
    - Settings -> Plugins -> Browse repositories -> NodeJS
    - 2 раза кликнуть по плагину NodeJS. Нажать apply.
    - PHPStorm должен перезагрузиться.
    - Затем: Settings -> Node.js and NPM, всё там настроить.
    - Затем: Settings -> Javascript -> Libraries, всё там настроить.

  > Примечание
    - Если интерпретатор NodeJS на виртуальной машине или в контейнере.
    - То ничего не выйдет, PHPStorm в начале 2016-го не поддерживает
      работу с удалённым NodeJS.
    - Поэтому, придётся установить NodeJS на винду, и указать её интерпретатор.
    - И получть поддержку хотя бы базового синтаксиса NodeJS в PHPStorm.


А4. Стабильность модулей NodeJS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Коды стабильности

      - 0 - Deprecated
      - 1 - Experimental
      - 2 - Stable
      - 3 - Locked

    # Примечание по поводу нестабильных модулей

  --------------------------------------

  > Ссылки

    # Про коды стабильности модулей в оф.документации
        https://nodejs.org/dist/latest-v5.x/docs/api/documentation.html

  > Введение
    - В NodeJS у каждого модуля есть понятие кода стабильности.
    - Эти коды обозначают некое состояние модуля.
    - На начало 2016-го есть 4 кода стабильности, от 0 до 3.

  > Коды стабильности

    # 0 - Deprecated
      - Есть проблемы с этим модулем.
      - Они либо будет доработан, либо на него будет забито.
      - Не следует им пользоваться.

    # 1 - Experimental
      - Этот модуль активно меняется и дорабатывается.
      - Не следует полагаться на него в продакшн.
      - Пока что можно просто побаловаться.

    # 2 - Stable
      - Стабильный модуль.
      - Можно использовать в продакшн.

    # 3 - Locked
      - Стабильный модуль, закрытый для изменения сообществом.
      - Принимаются только фиксы, связанные с безопасностью.

  > Примечание по поводу нестабильных модулей
    - То, что они не стабильны, не значит, что их не стоит использовать.
    - Они могут работать хорошо, и выполнять возложенные на них задачи.
    - Нестабильный статус означает лишь, что их API может измениться.
    - Просто это надо иметь в виду, и, например, пользоваться конкретной версией.
    - То есть, отключить автообновление до последней версии.


А5. Модули в NodeJS: основы

  --------------------------------------
  Подоглавление:

    # Введение
    # Что такое модуль в NodeJS
    # Виды модулей в NodeJS

      - .js
      - .node
      - .json

    # Виды переменных в модулях

      - var
      - exports
      - global

    # Подключение модулей с помощью require
    # Порядок поиска модулей при подключении с помощью require
    # Пример

  --------------------------------------

  > Введение
    - В этой главе будут описаны принципы и основы работы модулей в NodeJS.
    - А модули являются важнейшей частью концепции NodeJS.
    - По большому счёту, весь полезный функционал упакован в модули.
    - А управление модулями производится через менеджер пакетов NPM.

  > Что такое модуль в NodeJS
    - Это файл, который подключается с помощью require.

  > Виды модулей в NodeJS

    1) .js
      - Наиболее часто используемые модули, написанные на JS.

    2) .node
      - Редко используемые модули, написанные на C++.

    3) .json
      - Это файлы, содержащие валидный JSON.
      - Соотв., содержат некую информацию, которую можно подключить.
      - Например, это может быть какой-нибудь конфиг.

  > Виды переменных в модулях

    1) var
      - В JS-модуле можно, как обычно, определять переменные и функции.
      - Но они по умолчанию будут доступны только внутри модуля.
      - И если модуль подключить к проекту с помощью require, то
        даже в этом случае, определённые в нём переменные/функции
        будут недоступны.
      - Это поведение отличается от того, что происходит в браузерном
        JS, где при подключении JS-файлов, все переменные и функции
        находятся в глобальном пространстве имён.

    2) exports
      - В модуле всегда по умолчанию есть переменная exports.
      - В неё можно записать объект с переменными модуля.
      - При подключении модуля через require, оная вернёт exports модуля.
      - Например:

        module.js               server.js
        ----------              ------------
          exports = {             var z = require("./module");  // {x:10, y:20}
            x: 10,
            y: 20
          };

    3) global
      - В модуле всегда по умолчанию есть переменная global.
      - Она содержит объект, который доступен всем модулям проекта.
      - По сути, global, это аналог window в браузерном JS.
      - Но отличие в том, что в последнем туда попадают все переменные.
      - А в NodeJS только те, которые явно добавлены: global.x = 10;

  > Подключение модулей с помощью require
    - Подключать модули к проекту можно с помощью функции require.
    - В зависимости от типа подключаемого модуля, она возвращает:

      1) .js
        - Содержимое объекта exports js-модуля.

      2) .json
        - Десериализованный объект, получившийся из json в json-модуле.

    - В качестве аргумента, require принимает относительный путь к модулю.
    - Причём, .js в конце имени файла модуля можно не указывать.
    - Алгоритм поиска модуля выглядит следующим образом:

      1) Ищет js-модуль по указанному пути
      2) Если нет, ищет json-модуль по указанному пути.
      3) Если нет, ищет каталог с таким именем по указанному пути
        - А в нём ищет файл с именем index.
        - Если в нём лежит json, интерпретирует, как json-модуль.
        - Если в нём лежит js, интерпретирует, как js-модуль.

  > Порядок поиска модулей при подключении с помощью require
    - Подробно порядок поиска описан в документации.
    - Вот ссылка: https://nodejs.org/api/modules.html#modules_all_together
    - Вот копия из документации (с моими комментариями):

        require(X) from module at path Y
        1. If X is a core module,                  // Если указано имя модуля ядра NodeJS, загрузить сразу
           a. return the core module
           b. STOP
        2. If X begins with './' or '/' or '../'   // Если указана строка, начинающаяся с: './' or '/' or '../'
           a. LOAD_AS_FILE(Y + X)                  // Попробовать найти файл по этому адресу
           b. LOAD_AS_DIRECTORY(Y + X)             // Попробовать найти каталог по этому адресу
        3. LOAD_NODE_MODULES(X, dirname(Y))        // Искать каталог 'node_modules' по всему дереву, начиная от текущего и выше, и в нём искать модуль
        4. THROW "not found"                       // Если ничего не найдено, возбудить исключение "not found"

        LOAD_AS_FILE(X)
        1. If X is a file, load X as JavaScript text.  STOP                 // Ищем файл X, интерпретируем как JS-текст
        2. If X.js is a file, load X.js as JavaScript text.  STOP           // Ищем файл X.js, интерпретируем как JS-текст
        3. If X.json is a file, parse X.json to a JavaScript Object.  STOP  // Ищем файл X.json, интерпретируем как json
        4. If X.node is a file, load X.node as binary addon.  STOP          // Ищем файл X.node, интерпретируем, как бинарный addon

        LOAD_AS_DIRECTORY(X)
        1. If X/package.json is a file,                                               // Если в каталоге X есть файл package.json
           a. Parse X/package.json, and look for "main" field.                        // Ищем в package.json св-во main
           b. let M = X + (json main field)                                           // Загружаем файл из X по относ.адресу из main
           c. LOAD_AS_FILE(M)                                                         // ...
        2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP         // Если в X есть файл index.js, загружаем его, интерпретируем как JS-текст
        3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP // Если в X есть файл index.json, загружаем его, интерпретируем как json
        4. If X/index.node is a file, load X/index.node as binary addon.  STOP        // Если в X есть файл index.node, загружаем его, интерпретируем как бинарный addon

        LOAD_NODE_MODULES(X, START)
        1. let DIRS=NODE_MODULES_PATHS(START)     // Получить массив путей типа ..\..\node_modules (начиная от текущего каталога, и вверх по дереву до конца)
        2. for each DIR in DIRS:                  // Пробежаться по этому массиву
           a. LOAD_AS_FILE(DIR/X)                 // Искать модуль X в каталоге DIR
           b. LOAD_AS_DIRECTORY(DIR/X)            // Искать каталог X в каталоге DIR

        NODE_MODULES_PATHS(START)
        1. let PARTS = path split(START)
        2. let I = count of PARTS - 1
        3. let DIRS = []
        4. while I >= 0,
           a. if PARTS[I] = "node_modules" CONTINUE
           c. DIR = path join(PARTS[0 .. I] + "node_modules")
           b. DIRS = DIRS + DIR
           c. let I = I - 1
        5. return DIRS

    - Кроме того, можно задать доп.каталоги для поиска в переменной окружения NODE_PATH.
    - Также, по историческим причинам, поиск производится в следующих каталогах:

        $HOME/.node_modules
        $HOME/.node_libraries
        $PREFIX/lib/node


  > Пример

    # Файловая структура

      \project          // Каталог проекта
        server.js       // Главный файл проекта
        \user           // Модуль user
          index.js      // Главный файл модуля user
          ru.json       // json-модуль с локализацией

    # server.js

      var user = require('./user');

      var vasya = new user.User("Вася");
      var petya = new user.User("Петя");

      vasya.hello(petya);

    # index.js

      // Подключим json-модуль с локализацией
      var phrases = require("./ru");

      // Создадим новый класс User
      function User(name) {
        this.name = name;
      }

      // Добавим в User новый метод hello
      User.prototype.hello = function(who) {
        console.log(phrases.Hello + ", " + who.name);
      }

      // Добавим в exports св-во User
      exports.User = User;

      // Сообщим, что модуль user успешно загружен
      console.log("user.js is required!");

    # ru.json

      {
        "Hello": "Привет"
      }


А6. Модули в NodeJS: приёмы

  --------------------------------------
  Подоглавление:

    # Введение
    # Объект module
    # Приёмы:

      - Модуль NodeJS м.б. использован, как приложение, или как модуль
      - Свойство module.exports и ссылки exports / this на него
      - Модуль-синглтон
      - Автопоиск модулей при require в каталоге node_modules по всему дереву

  --------------------------------------

  > Введение
    - В этой главе мы углубимся в тему модулей NodeJS.
    - Рассмотрим приёмы работы с ними.

  > Объект module
    - В каждом модуле есть переменная module.
    - Она содержит информацию о модуле.
    - Посмотреть содержимое, можно запустив: console.log(module);
    - Рассмотрим его свойства:

      {
        id          // Полный путь к файлу модуля (используется внутри NodeJS)
        exports     // Что лежит в exports модуля
        parent      // Содержит объект module родительского модуля (который required данный)
        filename    // Полный путь к файлу модуля
        loaded      // Загрузился ли полностью модуль (true / false)
        children    // Дочерние модули для данного (которые он подключил через require)
        paths       // Список путей, где искать модули, если они не найдены в текущем каталоге
      }

  > Приёмы

    # Модуль NodeJS м.б. использован, как приложение, или как модуль

      ## Как приложение
        - Если module.parent это null, значит это приложение.
        - То есть, файл запущен через терминал вызовом: node [файл].

      ## Как модуль
        - Если module.parent не null, значит это модуль.
        - То есть, файл подключен к другому файлу через require.

      ## Пример
        - В коде можно проверить, модуль это, или нет.
        - Этот приём часть применяют в различных консольных приложениях.
        - Которые одновременно могут работать, как приложения, или как модули.

            // Определяем какую-то функцию
            function func() {
              console.log("Сработала функция");
            }

            // Если файл запущен в режиме модуля
            if(module.parent) {

              console.log('Это модуль');      // Сообщаем об этом
              exports.func = func;            // Добавляем в exports ссылку на func

            }

            // Если файл запущен в режиме приложения
            else {

              console.log('Это приложение');  // Сообщаем об этом
              func();                         // Запускаем функцию func

            }


    # Свойство module.exports и ссылки exports / this на него
      - module.exports == exports == this
      - Как упоминалось выше, в каждом модуле всегда есть св-во exports.
      - На самом деле exports является ссылкой на module.exports.
      - И this в глобальной области объекта также ссылается на module.exports.
      - Чаще всего для изменения module.exports используют ссылку exports.
      - Не this, т.к. this внутри функций не указывает на module.exports.
      - Не module.exports, так как это длиннее, чем exports.
      - Однако, есть нюанс:

          Если требуется заменить целый объект module.exports, то надо
          использовать именно module.exports, а не exports.

          exports = "123";        // это не сработает, здесь мы просто затёрли ссылку
          module.exports = "123"; // это сработает

    # Модуль-синглтон
      - Объект module при загрузке ф-ей require является синглтоном
      - Допустим, у нас есть какой-нибудь модуль X в проекте.
      - Его используют модули Y и Z, загружая с помощью require.
      - Цепочка такая: Z -> Y -> X
                         -> X
      - Z в этой цепочки является приложением, вызываемым через терминал.
      - При выполнении кода Z выполняется require(X), и подключается модуль X.
      - При этом создаётся объект module, который является синглтоном.
      - Также в коде Z подключается модуль Y, и срабатывает его код.
      - В нём тоже есть require(X), но в этом случае новых объектов не создаётся.
      - NodeJS ищет во внутреннем кэше файл по его ID.
      - Если находит, то извлекает ссылку на уже ранее созданный объект module.

    # Автопоиск модулей при require в каталоге node_modules по всему дереву
      - В главе А4 был описан алгоритм поиска модуля функцией require.
      - Допустим, мы укажем в require просто имя не встроенного модуля.
      - Тогда NodeJS будет искать его в каталоге node_modules, сначала
        в текущем каталоге, потом выше по дереву, и так до корня.
      - Это позволяет, например, создать в корне проекта каталог node_modules.
      - И размещать там различные внешние модули, типа: module1, module2 и т.д.
      - Это позволит подключать их с помощью require в файлах проекта, просто
        обращаясь к ним по имени, вместо того, чтобы указывать относ.пути:

          \project
            \node_modules
              \module1
                index.js
              \module2
                index.js
            \mymodule1
              index.js      // Здесь применяем require

          НЕУДОБНО:   require('../node_modules/module1')
          УДОБНО:     require('module1')

    # Модуль-фабрика
      - При подключении модуля с помощью require часто требуется передать параметры.
      - Но require не предусматривает из коробки такой возможности.
      - Поэтому, в данном случае, можно использовать петтерн фабрика.
      - Суть в том, что в exports подключаемого модуля мы помещаем ссылку на функцию.
      - И при подключении, мы можем передать в неё параметры:

          $log = require('logger')({ ... объект с параметрами ... })


А7. NPM-модуль Util

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Функционал

      - inspect     // Аналог toString в php, получить строковое представление объекта
      - format      // Получить стоку в определённом формате, собранную из переменных
      - inherits    // Позволяет осуществлять наследование "классов"

  --------------------------------------

  > Ссылки

    # Модуль Util в официальном репозитории NPM
        https://www.npmjs.com/package/util

  > Введение
    - Позволяет красиво вывести любой объект.
    - Util является встроенным модулем NodeJS.

  > Функционал

    // inspect //
    //---------//
    // - Аналог toString в php, получить строковое представление объекта

      # Пример №1

        var util = require('util');
        var obj = {
          a: 5,
          b: 6
        };
        obj.self = obj;
        var str = util.inspect(obj);
        console.log(str);                   // { a: 5, b: 6, self: [Circular] }
        console.log(obj);                   // { a: 5, b: 6, self: [Circular] }

      # Пример №2

        var obj = {
          a: 5,
          b: 6,
          inspect: function(){
            return 123;
          }
        };
        console.log( util.inspect(obj) );     // 123

    // format //
    //--------//
    // - Получить стоку в определённом формате, собранную из переменных

      var util = require('util');
      var obj = {
        a: 5,
        b: 6
      };
      var str = util.format("My %s %d %j", "string", 123, obj);  // My string 123 {"a":5,"b":6}
      console.log("My %s %d %j", "string", 123, obj);            // My string 123 {"a":5,"b":6}

    // inherits //
    //----------//
    // - Позволяет осуществлять наследование "классов"

      // Подключим util
      var util = require('util');

      // Создатим класс-родитель
      function Animal(name) {
        this.name = name;
      }
      Animal.prototype.walk = function() {
        console.log("Ходит " + this.name);
      };

      // Создадим класс-потомок
      function Rabbit(name) {
        this.name = name;
      }
      Rabbit.prototype.jump = function() {
        console.log("Прыгает " + this.name);
      };

      // Пусть Rabbit станет наследником Animal
      util.inherits(Rabbit, Animal);

      // Использование
      var rabbit = new Rabbit("наш кролик");
      rabbit.walk();
      rabbit.jump();


А8. NPM-модуль Console

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка
    # Функционал

      - log       // Вывести данные в std out
      - info      // Синоним log
      - error     // Вывести данные в std err
      - warn      // Синоним error

  --------------------------------------

  > Ссылки

    # Модуль Console в официальном репозитории NPM
        https://www.npmjs.com/package/console

  > Введение
    - Модуль console является встроенным в NodeJS модулем.
    - Также он является глобальной переменной в NodeJS.
    - Что является большой редкостью.
    - Это значит, что его не обязательно подключать с помощью require.
    - Внутри он использует модуль util, его методы format, inspect.

  > Потоки out и err
    - У каждой программы есть 2 потока вывода.
    - Их можно, к примеру, направлять на запись в разные файлы.

  > Функционал

    // log //
    //-----//
    // - Вывести данные в std out

      var x = 123;
      console.log(x);     // 123

    // error //
    //-------//
    // - Вывести данные в std err

      var x = 123;
      console.error(x);   // 123


А9. Наследование от встроенного объекта Error (как обрабатывать ошибки)

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Пример

  --------------------------------------

  > Ссылки

    # Подробно о работе с ошибками в NodeJS
        https://nodejs.org/api/errors.html

  > Введение
    - Здесь просто описано, как можно обрабатывать ошибки.
    - Используя при этом встроенный в NodeJS объект Error.
    - Это сделано на одном простом примере.

  > Пример

    // 1] Подключим модуль util
    var util = require('util');

    // 2] Напишем класс ошибки PhraseError, наследующий от Error
    function PhraseError(message) {
      this.message = message;
      Error.captureStackTrace(this, PhraseError); // получить стек до PhraseError
    }
    util.inherits(PhraseError, Error);
    PhraseError.prototype.name = "PhraseError";

    // 3] Напишем класс ошибки HttpError, наследующий от Error
    function HttpError(status, message) {
      this.status = status;
      this.message = message;
      Error.captureStackTrace(this, HttpError);
    }
    util.inherits(HttpError, Error);
    HttpError.prototype.name = "HttpError";

    // 4] Проведём испытания

      // 4.1] Словарик
      var phrases = {
        "Hello": "Привет",
        "world": "мир"
      };

      // 4.2] Функция для локализации
      function getPhrase(name) {
        if(!phrases[name]) {
          throw new PhraseError("Нет такой фразы: " + name); // HTTP 500, уведомление!
        }
        return phrases[name];
      }

      // 4.3] Функция для роутинга
      function makePage(url) {
        if(url != 'index.html') {
          throw new HttpError(404, "Нет такой страницы");
        }
        return util.format("%s, %s!", getPhrase("*(67*&"), getPhrase("world"));
      }

      // 4.4] Проводим испытания

        //var page = makePage('index.html');  // Тест PhraseError
        //var page = makePage('index');       // Тест HttpError
        console.log(page);


А10. NPM-модуль Events: события, EventEmitter и утечки памяти

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # О событиях в NodeJS

      - Строгий порядок срабатывания обработчиков
      - Возможность получить список обработчиков
      - Возбуждение события error вызывает исключение

    # Функционал

      - on              // Назначить обработчик события
      - emit            // Возбудить событие
      - listeners       // Получить обработчики, назначенные на указанное событие
      - listenerCount   // Получить кол-во обработчиков, назначенных на указанное событие
      - removeListener  // Удалить указанный обработчик из объекта ee

    # Пример работы с событиями
    # Утечка памяти при работе с событиями, борьба с ней

      - Пример сценария, при котором происходит утечка
      - Как боротсья с утечкой памяти

  --------------------------------------

  > Ссылки

    # Подробно о работе с событиями в NodeJS
        https://nodejs.org/api/events.html

  > Введение
    - В этой главе описана работа с событиями в NodeJS.
    - Она основана на встроенном в NodeJS объекте EventEmitter.
    - Или, как его ещё называют разработчики, EE.
    - EE представляет основной объект, реализующий работу с событиями в NodeJS.
    - Большое кол-во прочих встроенных объектов, генерирующий события,
      являются наследниками EE.
    - Сам EE используется редко, в основном используются его наследники.

  > О событиях в NodeJS

    # Строгий порядок срабатывания обработчиков
      - В браузере события срабатывают в произволном порядке.
      - В NodeJS точно в том порядке, в котором были определены.

    # Возможность получить список обработчиков
      - В браузере невозможно получить список обработчиков для эл-та.
      - В NodeJS это можно сделать с помощью метода listeners.
      - Например:

          var ee = require('events').EventEmitter;
          var server = new ee;
          var listeners = server.listeners('request');
          var listenersCount = server.listenerCount('request');

    # Возбуждение события error вызывает исключение
      - Но только в том случае, если нет никакого обработчика.
      - И весь процесс при этом будет, естественно, остановлен.
      - Многие встроенные объекты NodeJS сообщают о своих ошибках именно так.
      - Пример, когда нет ни одного обработчика события error:

        var ee = require('events').EventEmitter;
        var server = new ee;
        server.emit('error');               // throw TypeError
        server.emit('error', new Error());  // throw [объект во 2-м аргументе]

      - Пример, когда имеется обработчик события error:

        var ee = require('events').EventEmitter;
        var server = new ee;
        server.on('error', function(error_object) {
          console.log('Возникла ошибка');
        });
        server.emit('error');                                 // Возникла ошибка
        server.emit('error', new Error('Возникла ошибка'));   // Возникла ошибка

  > Функционал

    // on //
    //----//
    // - Назначить обработчик события

      var ee = require('events').EventEmitter;
      var server = new ee;
      server.on('request', function(request) {
        request.approved = true;
      });

    // emit //
    //------//
    // - Возбудить событие

      var ee = require('events').EventEmitter;
      var server = new ee;
      server.emit('request', {from: 'Клиент'}};

    // listeners //
    //-----------//
    // - Получить обработчики, назначенные на указанное событие

      var ee = require('events').EventEmitter;
      var server = new ee;
      var listeners = server.listeners('request');

    // listenerCount //
    //---------------//
    // - Получить кол-во обработчиков, назначенных на указанное событие

      var ee = require('events').EventEmitter;
      var server = new ee;
      var listenersCount = server.listenerCount('request');


  > Пример работы с событиями

    // 1] Подключим модуль events и получим объект EventEmitter
    var ee = require('events').EventEmitter;

    // 2] Назначим обработчики для события request
    var server = new ee;
    server.on('request', function(request) {
      request.approved = true;
    });
    server.on('request', function(request) {
      console.log(request);
    });

    // 3] Возбудим пару событий request
    server.emit('request', {from: 'Клиент'}};
    server.emit('request', {from: 'Ещё клиент'}};

  > Утечка памяти при работе с событиями, борьба с ней

    # Пример сценария, при котором происходит утечка
      - В сценарии ниже каждые 200мс создаётся объект Request.
      - В конструкторе Request каждый раз назначается обработчик.
      - Обработчик привязывается к объекту db (объект EventEmitter).
      - В объекте db есть объект evens, где эти обработчики хранятся.
      - Каждые 200мс в db.events добавляется новый обработчик.
      - Со временем их кол-во растёт и растёт, т.к. db должен оставаться в памяти.
      - И так до тех пор, пока память не закончится.
      - Причём, когда кол-во обработчиков будет > 10, NodeJS выдаст warning.
      - Скрипт:

        var ee = require('events').EventEmitter;
        var db = new ee;
        function Request() {
          var self = this;
          db.on('data', function(){ return 123; });
        }
        setInterval(function(){
          var request = new Request();
        }, 200);

    # Как боротсья с утечкой памяти
      - Для этого надо удалять обработчик из db.events вручную.
      - Вот пример:

        var ee = require('events').EventEmitter;
        var db = new ee;
        function Request() {
          var self = this;
          this.mylistener = function(){ return 123; };
          this.end = function(){
            db.removeListener('data', mylistener);
          };
          db.on('data', mylistener);
        }
        setInterval(function(){
          var request = new Request();
          // ... какой-то код ...
          request.end();
        }, 200);


А11. NodeJS: веб-сервер

  --------------------------------------
  Подоглавление:

    # Введение
    # Быстрые примеры

      - Простейший веб-сервер: new http.Server()
      - Простейший веб-сервер: http.createServer(...)
      - Простейший echo-сервер

    # Запуск / Остановка веб-сервера
    # Иерархия наследования события new http.Server()
    # События веб-сервера

      - listening
      - connection
      - request

    # Методы для работы с заголовками

      - setHeader         // добавить заголовок
      - writeHead         // добавить заголовок
      - removeHeader      // удалить заголовок

  --------------------------------------

  # Введение
    - В этой главе рассмотрим HTTP-сервер на NodeJS.

  # Быстрые примеры

    // Простейший веб-сервер: new http.Server() //
    //------------------------------------------//
    // - Вариант №1, через: new http.Server()
    // - Использован IP = 192.168.10.10 для homestead
    // - Посмотреть документ можно будет по URL: 192.168.10.10:1337

      // 1] Подключить модуль http
      var http = require('http');

      // 2] Создать новый экземпляр сервера
      // - Который наследует от объекта EventEmitter
      var server = new http.Server();	// EventEmitter

      // 3] Указать серверу, какие IP и порт слушать
      // - Повесив на порт = 1337
      // - И на IP = 192.168.10.10 (для homestead)
      server.listen(1337, '192.168.10.10');

      // 4] Подготовить счётчик
      var counter = 0;

      // 5] Назначить серверу обработчик
      server.on('request', function(req, res){
        res.writeHead(200, {'Content-Type': 'text/plain'});
        counter = +counter + 1;
        res.end(''+counter); 	// Вывести значение счётчика
      });

    // Простейший веб-сервер: http.createServer(...) //
    //-----------------------------------------------//
    // - Вариант №2, через: http.createServer(...)
    // - Использован IP = 192.168.10.10 для homestead
    // - Посмотреть документ можно будет по URL: 192.168.10.10:1337

      // 1] Подключить модуль http
      var http = require('http');

      // 2] Подготовить счётчик
      var counter = 0;

      // 3] Создать новый экземпляр сервера
      // - И сразу назначить ему обработчик
      new http.Server() == http.createServer(function(req, res){
        res.writeHead(200, {'Content-Type': 'text/plain'});
        counter = +counter + 1;
        res.end('123');
      }).listen(1337, '192.168.10.10');

    // Простейший echo-сервер //
    //------------------------//
    // - Использован IP = 192.168.10.10 для homestead
    // - http://192.168.10.10:1337/echo?message=hello
    // - Задача сервера вывести содержимое message из QS.

      // 1] Подключить необходимые модули
      var http = require('http');
      var url = require('url');       // для парсинга url

      // 2] Создать новый экземпляр сервера
      var server = new http.Server(function(req, res){

        // 2.1] Распарсить url
        var parsedurl = url.parse(req.url, true);

        // 2.2] Роутинг

          // 2.2.1] Если message есть в QS, а запрос к /echo
          if(parsedurl.pathname == '/echo' && parsedurl.query.message) {

            // 1) Вернуть в ответ серверу содержимое message из QS
            res.end(parsedurl.query.message);

          }

          // 2.2.2] В противном случае
          else {

            // 1) Установить статус ответа 404
            res.statusCode = 404;

            // 2) Вернуть строку с сообщением, что страница не найдена
            res.end('Page not found');

          }

      });

      // 3] Указать серверу, какие IP и порт слушать
      // - Повесив на порт = 1337
      // - И на IP = 192.168.10.10 (для homestead)
      server.listen(1337, '192.168.10.10');


  # Запуск / Остановка веб-сервера
    - Запустить веб-сервер можно как любую программу NodeJS.
    - Например, запустим в фоновом режиме:

        node server.js &    // PID: 15353

    - Затем, допустим, внесли изменения в файл server.js.
    - Чтобы они вступили в силу, требуется перезапустить сервер.
    - Это можно сделать так:

        kill 15353          // Прибить процесс с сервером
        node server.js &   // Запустить заново в фоновом режиме

  # Иерархия наследования события new http.Server()
    - Создать новый объект-сервер можно так:

        var http = require('http');
        var server = new http.Server();

    - Вопрос в том, наследником каких объектов является Server.
    - Иерархия такова:

        http.Server -> net.Server -> EventEmitter

    - Соответственно, и документацию надо смотреть от всех 3-х "классов".

  # События веб-сервера
    - Вот события веб-сервера:

      1) listening
      2) connection
      3) request

    - Их можно увидеть на практике.
    - Для этого надо просто переопределить метод emit.
    - Этот метод принадлежит классу EventEmitter, от которого наследует Server.
    - В итоге, мы будем видеть имена всех возбуждаемых событий в терминале.
    - Вот код:

      // 1] Подключить модуль http
      var http = require('http');

      // 2] Создать новый экземпляр сервера
      // - Который наследует от объекта EventEmitter
      var server = new http.Server();	// EventEmitter

      // 3] Указать серверу, какие IP и порт слушать
      // - Повесив на порт = 1337
      // - И на IP = 192.168.10.10 (для homestead)
      server.listen(1337, '192.168.10.10');

      // 4] Переопределим метод emit
      var emit = server.emit;
      server.emit = function(event /* , arg1, arg2, ... */) {
        console.log(event); // Вывести имя события
        emit.apply(server, arguments);
      }

      // 5] Назначить серверу обработчик
      server.on('request', function(req, res){
        res.end('Тест'); 	// Вывести значение счётчика
      });

    - Открываем документ в браузере, нажимаем F5 несколько раз.
    - В итоге в консоли видим такую картину:

        listening     // Сервер ожидает соединений
        connection    // Установка нового keep-alive соединения
        request       // Запрос
        request
        request
        request
        request
        request

    - Мы видим, что браузер устанавливает одно keep-alive соединение.
    - И все новые запросы используют это, одно и то же соединение.


А11. NPM-модуль supervisor

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Про supervisor
    # Альтернатива: nodemon

  --------------------------------------

  > Ссылки

    # Ссылка на supervisor в NPM
        https://www.npmjs.com/package/supervisor

    # Ссылка на nodemon в NPM
        https://www.npmjs.com/package/nodemon

  > Введение
    - В процессе разработки для NodeJS есть следующее неудобство.
    - При изменении кода, чтобы он вступил в силу, надо перезагрузить сервер,
      т.к. NodeJS считывает код модуля лишь 1 раз, при запуске сервера.
    - Вести разработку подобные образом было бы в крайней степени неудобно.
    - Поэтому, придумали серию модулей, которые следят за всеми файлами в
      указанном каталоге, и при любом их изменении перезапускают сервер.
    - Одним из таких модулей является supervisor, о нём и пойдёт здесь речь.

  > Про supervisor
    - Модуль супервизор имеет свой CLI.
    - Поэтому, его следует устанавливать глобально:

        sudo npm i supervisor -g

    - После установки, можно использовать supervisor.
    - Вот, как это делается:

        node server.js          // Запуск без supervisor
        supervisor server.js    // Запуск через supervisor

    - При запуске через supervisor, можно вносить изменения в
      server.js, supervisor их сразу обнаруживает, и перезапускает
      сервер.

  > Как работает supervisor
    - По сути, это просто демон, в котором есть бесконечный цикл,
      который выполняется раз в N секунд.
    - Когда запускаешь NodeJS-программу, он определяет каталог,
      за которым будет присматривать.
    - И каждый N секунд проверяет, изменилось ли там что-нибудь.
    - Если да, то убивает процесс работающего сервера, и запускает новый.
    - При этом прописывая в терминал сообщения типа:

        crashing child
        Starting child process with 'node server.js'

  > Недостатки supervisor

    1) Не отслеживает новые файлы
      - При создании нового файла, supervisor не реагирует.
      - Приходится перезапускать его вручную.

    2) Жрёт много ресурсов, когда в каталоге много файлов
      - Особенно, это касается подкаталога node_modules.
      - Там может быть куча модулей и подкаталогов.
      - А ведь supervisor должен каждые N секунд всё это отслеживать.
      - Поэтому, он начинает серьёзно грузить систему.
      - Чтобы с этим справиться, надо использовать флаг --ignore,
        и указывать там каталоги типа node_modules, в которых всё
        равно ничего не будет изменяться.

  > Альтернатива: nodemon
    - Сабж


А12. Отладка: node debugger / chrome

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение

    # Способ отладки №1: node debugger
    # Способ отладки №2: браузером chrome

  --------------------------------------

  > Ссылки

    # Документация по DebuggerProtocol движка v8
        https://github.com/v8/v8/wiki/Debugging%20Protocol

  > Введение
    - В этой главе рассмотрена отладка под NodeJS.

  > Способ отладки №1: node debugger
    - Это встроенный в NodeJS отладчик, никаких доп.модулей не надо.
    - Его используют в редких случаях, когда более продвинутые
      способы откладки почему-то не работают.
    - Ставим в коде инструкцию:

        debugger;

    - Запускаем server.js через node debug:

        node debug server.js

    - Смотрим доступные команды для управления дебаггером с помощью help.
    - Итак, запустили сервер чере node debug, выполнение дошло до
      debugger и остановилось.
    - Можно в терминале глянуть, что лежит в той или иной переменной.
    - Или выполнить какой-нибудь код, к примеру, вернуть response клиенту:

        res.end('ухахаха!');

  > Способ отладки №2: браузером chrome
    - Гораздо удобнее использовать инструменты разработчика из chrome.
    - Для этого понадобится поставить глобально утилиту node inspector:

        sudo npm i node-inspector -g

    - После этого можно запустить server.js с флагом --debug:

        node server.js --debug
        node server.js --debug-brk  // сразу после запуска скрипта входит в состояние остановы

    - Флаг --debug приводит к тому, что NodeJS начинает слушать
      порт 5858, ожидая взаимодействия по нему через протокол
      DebuggerProtocol, который описан в документации к V8.
    - Далее мы запускаем утилиту node-inspector:

        node-inspector

    - На самом деле это веб-сервер, у которого есть веб-интерфейс.
    - Для homestead, он находится по адресу:

        http://192.168.10.10:8080/?port=5858

    - Зайдя туда мы увидим похожие на стандартные инструменты отладки для chrome.
    - Но на самом деле это не они, хотя похожи, т.к. стили взяты из webkit.
    - Node Inspector будет транслировать сигналы из веб-интерфейса
      ноде, которая слушает порт 5858, используя протокол DebuggerProtocol,
      а получать сингалы от ноды с помощью websockets.
    - В итоге, через этот веб-интерфейс, и можно отлаживать сервер.
    - К примеру, можно смотреть значения переменных в консоли и т.д.


А13. Журналирование: NPM-модули debug / winston + NODE_DEBUG

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Модуль debug
    # Модуль winston

      - Основная информация
      - Добавление функционала для winston

    # Средство отладки NODE_DEBUG

  --------------------------------------

  > Ссылки

    # Модуль debug в NPM
        https://www.npmjs.com/package/debug

    # Модуль winston в NPM
        https://www.npmjs.com/package/winston

  > Введение
    - В этой главе рассмотрим модули debug и winston.
    - Они предназначены для журналирования и дебага.

  > Модуль debug
    - Это простейший модуль для отладки.
    - Он просто выводит любую инфу в терминал.
    - Это похоже на console.log для браузерного js.
    - Только вместо console.log надо использовать debug.
    - Установить модуль можно локально:

        npm install debug

    - Пример (файл server.js):

        // 1] Подключаем модули
        var http = require('http');
        var debug = require('debug')('server');  // Указываем тег server

        // 2] Создать новый экземпляр сервера
        // - И сразу назначить ему обработчик
        var server = http.createServer(function(req, res){
          res.writeHead(200, {'Content-Type': 'text/plain'});
          counter = +counter + 1;
          res.end('123');
        }).listen(1337, '192.168.10.10');

        // 3] Тестим debug
        var obj = {
          x: 10,
          y: 20
        };
        debug(obj);

    - Теперь заходим в терминал, в каталог с server.js
    - И запускаем server.js, указав в переменной окружения
      DEBUG (через запятую) список тегов, для которых
      необходимо выводить отладочную инфу. В нашем случае,
      это тег "server":

        DEBUG=server node server.js

  > Модуль winston

    # Основная информация
      - Это более навороченный по сравнению в debug модуль журналирования.
      - В отличие от debug, winston позволяет:

          1) Задать важность того или иного сообщения
          2) Писать вывод не только в std out, но и в файл, БД, и т.д.

      - Установить winston можно локально:

          npm install winston

      - Winston может выводить сообщения разной важности.

          log.debug('msg');   // малая важность
          log.info('msg');    // средняя важность
          log.error('msg');   // высокая важность

      - Причём, по умолчанию, выводит лишь сообщения info и error.
      - Пример (файл server.js):

          // 1] Подключаем модули
          var http = require('http');
          var log = require('winston');

          // 2] Создать новый экземпляр сервера
          // - И сразу назначить ему обработчик
          var server = http.createServer(function(req, res){
            res.writeHead(200, {'Content-Type': 'text/plain'});
            counter = +counter + 1;
            res.end('123');
          }).listen(1337, '192.168.10.10');

          // 3] Тестим winston
          log.debug('111');     // по умолчанию не выведется
          log.info('222');
          log.error('333');

      - Теперь заходим в терминал, в каталог с server.js
      - И запускаем сервер:

          node server.js

      - И видим такой вывод:

          info: 222
          error: 333

    # Добавление функционала для winston
      - Можно самому добавить функционала для winston.
      - Тем же способом, что и для любого другого модуля.
      - Надо создать модуль-обёртку, использующий winston.
      - Который будет содержать необходимую функциональность.
      - И пользоваться им, вместо оригинального winston.
      - Ниже пример такого модуля-обёртки:

        // 1] Подключить модуль winston
        var winston = require('winston');

        // 2] Написать функцию makeLogger
        function makeLogger(path) {

          if(path.match(/request.js$/)) {
            var transports = [

              new winston.transports.Console({
                timestamp: true,
                colorize: true,
                level: 'info'
              }),

              new winston.transports.File({
                filename: 'debug.log',
                level: 'debug'
              })

            ]
          }

        }

        // 3] Добавить данные в exprorts модуля
        module.exports = function(module) {
          return makeLogger(module.filename);
        };

  > Средство отладки NODE_DEBUG
    - Это переменная окружения, которая используется внутри NodeJS.
    - По умолчанию, NODE_DEBUG пуста.
    - Но туда можно добавить строку, в которой указать через пробел
      имена некоторых встроенных модулей, а именно:

        cluster
        fs
        http
        module
        net
        timer
        tls

    - И тогда эти модули будут выводить в терминал отладочную информацию
    - Пример:

        NODE_DEBUG="http net" node server.js


А14. Асинхронная разработка: введение

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Иллюстрация проблемы с "синхронным" кодом на сервере
    # Иллюстрация асинхронного решения проблемы
    # Когда использовать синхронный / асинхронный код?

      - Синхронный
      - Асинхронный

    # Проблема, известная как "event loop starvation"

  --------------------------------------

  > Ссылки


  > Введение
    - Часто серверу требуется выполнять много задач параллельно.
    - А именно, обрабатывать множество параллельных запросов.
    - Поэтому "синхронный" код годится разве что для CLI-скриптов.
    - А для для высоконагруженных серверных приложений не годится.
    - В последнем случае, лучше использовать "асинхронный" код.
    - Эта глава посвящена введению в асинхронную разработку.

  > Иллюстрация проблемы с "синхронным" кодом на сервере
    - Итак, имеется у нас простой скрипт server.js
    - Он должен принять запрос, прочитать файл, и вернуть его содержимое.
    - Вот он:

        var http = require('http');
        var fs = require('fs');

        http.createServer(function(req, res){
          var info;
          if(req.url == '/') {
            info = fs.readFileSync('index.html');
            res.end(info);
          } else if(req.url = '/now') {
            res.end(new Date().toString());
          }
        }).listen(3000);

    - Допустим, Петя и Вася одновременно запросили данные (Петя чуть раньше).
    - Пока скрипт не считает данные из файлов, и не отдаст Пете,
      Вася будет ждать.
    - А теперь представим, к примеру, 100 одновременных запросов.
    - Некоторым придётся ждать ооооооооооооооооочень долго.

  > Иллюстрация асинхронного решения проблемы
    - Выше приведён "синхронный" код простого сервера.
    - Проблему в нём представляет строка синхронного чтения из файла:

        info = fs.readFileSync('index.html');

    - Чтобы её решить, надо сделать это чтение асинхронным.
    - Для этого надо использовать метод readFile (который асинхронен):

        var http = require('http');
        var fs = require('fs');

        http.createServer(function(req, res){
          var info;
          if(req.url == '/') {

            fs.readFile('index.html', function(err, info) {

              // 1] Обработаем ошибку, если она ест
              if(err) {
                console.error(err);
                res.statusCode = 500;
                res.end("На сервера произошла ошибка");
                return;
              }

              // 2] Если ошибки нет, вернуть ответ клиенту
              res.end(info);

            });

          } else if(req.url = '/now') {
            res.end(new Date().toString());
          }
        }).listen(3000);

    - Теперь интерпретатор JS не будет ждать, пока чтение из файла закончится.
    - Он будет обрабатывать следующие запросы, не дожидаясь этого.
    - А когда чтение всё же закончится, тогда и выполнит код в колбэке,
      который и вернёт пользователю нужные данные.

  > Когда использовать синхронный / асинхронный код?

    # Синхронный
      - Когда не требуется параллельная обработка запросов.
      - Как правило, это CLI-скрипты.

    # Асинхронный
      - Когда требуется параллельная обработка запросов.
      - Как правило, это веб-серверы.
      - При асинхронном вызове, результат передаётся в callback-функцию,
        первым аргументом в которую всегда передаётся объект error
        (== null если ошибки нет), а вторым объект с данными.
      - !Внимание:

          При асинхронной разработке, очень важно в callback обрабатывать
          ошибки. То есть смотреть, не пуст ли объект error, и если не
          пуст, как-то его обрабатывать.

          Иначе, эти ошибки потом будет очень трудно отследить, и можно
          сойти с ума.

  > Проблема, известная как "event loop starvation"
    - Это проблема долгих вычислений на сервере JS.
    - В случае их наличия, накапливается большая очередь
      входящих запросов, ожидающих обработки сервера.
    - Поэтому NodeJS используется в 1-ую очередь там, где тяжёлых
      вычислений не требуется, а где требуется интенсивный
      обмен данными.
    - Есть несколько способов бороться с этой проблемой:

      1) Выделить тяжёлые вычисления в отдельный процесс / поток
      2) Запустить север NodeJS в многопроцессном режиме
        - Используя встроенный модуль cluster, и прочие способы.
      3) Разбить тяжёлую вычислительную задачу на части
        - Используя таймеры.
        - Это разрывает обработку одной задачи, и позволяет
          интерпретатору JS во время разрыва выполнять последующие
          задачи из очереди.


А15. Таймеры в NodeJS, методы ref/unref

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Методы

      - clearInterval   // все эти методы
      - clearTimeout    // работают аналогичн
      - setInterval     // как в
      - setTimeout      // браузерном JS

      - unref           // Не учитывать таймер при проверке внутренних вотчеров
      - ref             // Учитывать таймер при проверке внутренних вотчеров

      - setImmediate    // Добавить в очередь немедленно
      - clearImmediate  // Убрать из очереди немедленно

    # Про unref и ref

      - Общая информация
      - Пример проблемы
      - Пример решения

    # Про process.nextTick в NodeJS
    # Про setImmediate/clearImmediate в NodeJS

  --------------------------------------

  > Ссылки

    # Оф.документация по таймерам в NodeJS
        https://nodejs.org/api/timers.html

  > Введение
    - Эта глава про таймеры в NodeJS.
    - И их отличие от таймеров в браузерах.

  > Методы
    - См. оглавление

  > Про unref и ref

    # Общая информация
      - В NodeJS (в отличии от браузерного JS) таймер является объектом
      - Unref указывает либе libUV, что таймер является второстепенным.
      - И его не надо учитывать при проверке внутренних вотчеров.
      - Ref же, это противоположность unref.
      - Внимание! Методы ref/unref есть не только у таймеров, но и у
        серверов, сетевых сокетов, и т.д. Т.Е. это некое решение,
        которое проходит через весь NodeJS красной нитью, решая подобные
        описанной ниже проблемы.

    # Пример проблемы
      - Допустим, есть у нас такой сервер.
      - Он должен завершать работу через 2.5 секунды после начала.
      - Но этого не произойдёт, если присутствует хотя бы 1 таймер.
      - Потому что таймер постоянно добавляется в очередь задач.
      - А сервер не завершит работу, пока все задачи в очереди не будут выполнены.
      - То есть, при наличии таймера, никогда.
      - Код:

        var http = require('http');
        var server = new http.Server(function(req, res){  // ...код...  }).listen(3000);

        setTimeout(function(){ server.close(); }, 2500);
        setInterval(function(){ console.log(process.memoryUsage()); });

    # Пример решения
      - Надо сказать серверу буквально следующее: "если в очереди
        останется лишь 1 задача, связанная с этим таймером, то
        не следует оставлять программу запущенной".
      - Код:

        var http = require('http');
        var server = new http.Server(function(req, res){  // ...код...  }).listen(3000);

        setTimeout(function(){ server.close(); }, 2500);
        var timer = setInterval(function(){ console.log(process.memoryUsage()); });
        timer.unref();

  > Про process.nextTick в NodeJS
    - Что, если требуется добавить задачу в очередь, но не просто.
    - А чтобы она выполнилась гарантированно до прихода нового запроса?
    - Для этого в NodeJS есть встроенная функция process.nextTick:

        process.nextTick(function(){
          // ...код...
        });

    - А если в колбэке выше надо что-то ещё добавить в очередь,
      то эти добавления тоже будут выполнены до обработки следующего запроса.

  > Про setImmediate/clearImmediate в NodeJS
    - Она работает примерно также, как process.nextTick, но с отличиями.
    - В отличие от nextTick, setImmediate срабатывает ПОСЛЕ выполнения
      всех запланированных на следующий тик операций, но до следующего запроса.
    - Рассмотрим пример. Порядок вывода в консоль будет такой: 3 - 1 - 2.

        var fs = require('fs');
        fs.open(__filename, 'r', function(err, file){
          console.log("1");
        });

        setImmediate(function(){
          console.log('2');
        });

        process.nextTick(function(){
          console.log('3');
        });


А16. Файлы

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Sync и не Sync версии функций
    # Объект Buffer
    # Объект Stats
    # Быстрый пример: содание, переименование, удаление
    # Функция sendFileSafe: безопасный путь к файлу от пользователя

  --------------------------------------

  > Ссылки

    # Оф.справка по работе с ФС в NodeJS
        https://nodejs.org/api/fs.html

    # Оф.справка по работе с объектом Buffer
        https://nodejs.org/api/buffer.html

    # Списки кодов ошибок и их описаний (искать по строке "ERRNO_MAP")
        https://github.com/thlorenz/libuv-dox/blob/master/types.md

  > Введение
    - В NodeJS для работы с файлами есть встроенный модуль "fs".
    - В нём есть функционал для самых разных операций с файлами и каталогами.
    - В главе не будет справочника, а лишь описаны особенности работы с ФС.

  > Sync и не Sync версии функций
    - Почти каждая функция в fs имеет sync и обычную (асинхронную) версии.
    - Sync-версии означают синхронное выполнение, а не sync-версии - асинхронное.
    - Sync-версии используют в CLI-приложениях, а не sync-версии в серверах.

  > Объект Buffer
    - Это высокоэффективное средство NodeJS для работы с бинарными данными.
    - Технически, это непрерывная область памяти, заполненная этими данными.
    - Работа с ним похожа на работу со строкой. Можно взять и получить, скажем, 0-й элемент:

        // 1] Подключить модуль fs, считать файл в объект Buffer, и вывести его 0-й элемент
        var fs = require('fs');
        fs.readFile(__filename, function(err, data){
          if(err) {
            console.error(err);
          } else {
            console.log(data[0]);     // 0-й элемент объекта Buffer
            console.log(data.length); // Длина объекта Buffer
          }
        });

    - Как известно, строки в JS нельзя изменить, заменив N-й элемент.
    - А вот объект Buffer изменить можно, для этого есть ряд методов.
    - К примеру, можно просто преобразовать содержимое буфера в строку
      utf-8, и вывести:

          console.log(data.toString());

    - Кодировку можно указать и во время считывания файла:

        // 1] Считать содержимое файла, и преобразовать в строку в utf-8
        var fs = require('fs');
        fs.readFile(__filename, {encoding: 'utf-8'}, function(err, data){
          if(err) {
            console.error(err);
          } else {
            console.log(data);     // Выведет строку
          }
        });

  > Объект Stats
    - Иногда надо узнать, что находится по указанному пути.
    - Для этого можно использовать объект stats:

      var fs = require('fs');
      fs.stat(__filename, function(err,stats){
        console.log(stats.isFile());  // файл ли это
        console.log(stats);           // объект с информацией о том, что находится по указанному адресу
      });

  > Быстрый пример: содание, переименование, удаление

    // Подключить модуль fs
    var fs = require('fs');

    // Создать файл file.tmp со строкой "Пример, мир"
    fs.writeFile("file.tmp", "Привер, мир", function(err){

      // Если нет ошибки, переименовать его в file.tmp
      if(err) throw err;
      fs.rename("file.tmp", "new.tmp", function(err) {

        // Если нет ошибки, удалить файл new.tmp
        if(err) throw err;
        fs.unlink("new.tmp", function(err){
          if(err) throw err;
        });

      });

    });

  > Функция sendFileSafe: безопасный путь к файлу от пользователя
    - Позволяет получить от пользователя путь к файлу.
    - И вернуть ему файл, не выходя за пределы обозначенного каталога.
    - То есть, пользователь не сможет получить файл выше каталога по дереву.
    - В случае появления каких-либо ошибок, функция должна их обработать.
    - Код:

      var http = require('http');
      var fs = require('fs');
      var url = require('url');
      var path = require('path');

      var ROOT = __dirname + "/public/";

      function sendFileSafe(filePath, res) {

        // 1] Декодировать запрос
        try {
          filePath = decodeURIComponent(filePath);
        } catch(e) {
          res.statusCode = 400;
          res.end("Bad Request");
          return;
        }

        // 2] Убедиться, что в строке нет нулевого байта
        if(~filePath.indexOf('\0')) {
          res.statusCode = 400;
          res.end("Bad Request");
          return;
        }

        // 3] Получить путь к файлу в ФС с помощью встроенного модуля path
        filePath = path.normalize(path.join(ROOT, filePath));

        // 4] Убедиться, что filePath находится в ROOT
        if(filePath.indexOf(ROOT) != 0) {
          res.statusCode = 404;
          res.end("File not found");
          return;
        }

        // 5] Если по пути filePath не файл, вернуть ошибку
        // - А если файл, вызвать sendFile
        fs.stat(filePath, function(err, stats) {
          if(err || !stats.isFile()) {
            res.statusCode = 404;
            res.end("File not found");
            return;
          }
          sendFile(filePath, res);
        }

      }

      // Функция для отправки файла
      // - Такой подход к отправки файла не верен, т.к. считывае файл в память
      // - Если файл велик, сервак упадёт.
      // - Вместо этого, надо использовать потоки
      function sendFile(filePath, res) {
        fs.readFile(filePath, function(err, content){
          if(err) throw err;
          var mime = require('mime').lookup(filePath);  // npm install mime
          res.setHeader('Content-Type', mime + "; charset=utf-8");
          res.end(content);
        }
      }


А17. Чтение параметров из командной строки и окружения

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Получение паременных окружения
    # Получение параметров из командной строки

      - Из process.argv
      - С помощью модуля yargs

  --------------------------------------

  > Ссылки

    # NodeJS-модуль yargs
        https://www.npmjs.com/package/yargs

  > Введение
    - В этой главе описано, как читать параметры из командной строки и окружения.

  > Получение паременных окружения
    - Допустим, есть переменная окружения "HOME".
    - Тогда получить её в коде можно так:

        var home = process.env.HOME;

  > Получение параметров из командной строки

    1) Из process.argv
      - Запустим server.js с параметром port=3000 в командной строке:

          node server.js port=3000

      - Теперь в файле server.js прочитаем значение параметра port.
      - Оно находится в переменной: process.argv.
      - Там лежит массив, и в нём:

        [
          ...,
          'port=3000',
          ...
        ]

      - Надо распарсить его, и выдрать 'port=3000'

    2) С помощью модуля yargs
      - Подробнее см.здесь: https://www.npmjs.com/package/yargs
      - Пример использования:

         node server.js --ships=4 --distance=22

          var argv = require('yargs').argv;
          if (argv.ships > 3 && argv.distance < 53.5) {
              console.log('1');
          }
          else {
              console.log('2');
          }


А18. Потоки

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Типы потоков

      - stream.Readable
      - stream.Writable

    # Суть потоков на примере Readable-потока

      - Код примера
      - Описание работы примера
      - Примечание: вся работа с файлами происходит на следующем тике
      - Поток считывает данные из источника кусками <= 64kb
      - Можно дополнять потоки своим функционалом

    # Использование Writable-потока

      - Код примера
      - Описание работы примера

    # Метод pipe у Readable-потоков

  --------------------------------------

  > Ссылки


  > Введение
    - В браузерном JS потоки отсутствуют.
    - А вот в NodeJS потоки присутствуют, и очень важны.
    - Потоки являются универсальным способом работы с источниками данных,
      которые используются повсеместно.
    - Потокам и посвящена эта глава.

  > Типы потоков

    1) stream.Readable
      - Это встроенный класс, реализует потоки для чтения данных.
      - Как правило, используются наследники данного класса.
      - Например, при чтении из файла: fs.ReadStream
      - Или объект-запрос в req: server.on('request', function(req, res){})

    2) stream.Writable
      - Это встроенный класс, реализует потоки для записи данных.
      - Как правило, используются наследники данного класса.
      - Например, при записи в файл: fs.WriteStream
      - Или объект-запрос в res: server.on('request', function(req, res){})

  > Суть потоков на примере Readable-потока

    # Код примера

        var fs = require('fs');                     // Подключить модуль fs
        var stream = new fs.ReadStream(__filename); // fs.ReadStream наследует от stream.Readable

        stream.on('readable', function(){           // Назначить обработчик событию readable
          var data = stream.read();                 // Получить данные из внутреннего буфера потока
          console.log(data);                        // Вывести эти данные
        });

        stream.on('end', function(){                // Назначить обработчик события "End"
          console.log("THE END");                   // Вывести сообщение
        });

        stream.on('error', function(err) {          // Обработчик ошибок
          if(err.code == 'ENOENT') {
            console.log('Файл не найден, попинайте админа, пусть выложит...');
          } else {
            console.error(err);
          }
        });

    # Описание работы примера
      - Когда создаётся объект потока, то он подключается к источнику данных.
      - В нашем случае это файл. И пытается начать из него читать.
      - Когда он что-то прочитал, возбуждает событие "readable".
      - Оно означает, что данные из потока прочитаны, и лежат в его внутреннем буфере.
      - Эти данные можно получить, используя вызов read().
      - Когда источник данных иссякнет, поток возбуждает событие "end".
      - На любом этапе работы с потоком можно его уничтожить методом destroy().
      - Также у потока ReadStream есть доп.события: "open" и "close".
      - "open" возникает перед "readable", а "close" после "end".

    # Примечание: вся работа с файлами происходит на следующем тике
      - Выше в коде есть строка: var stream = ...
      - Все IO-операции реализуются через libuv.
      - Значит, все синхронные IO-обработчики сработают лишь на следующей
        итерации событийного цикла.
      - Значит, после этой строки можно понавешать на stream обработчиков
        событий и быть уверенными, что это будет сделано ещё до того,
        как через поток начнут поступать данные.

    # Поток считывает данные из источника кусками <= 64kb
      - Вот он прочитал первый фрагмент.
      - Пока мы не вызовем stream.read(), он дальше читать не будет.
      - А когда вызовем, то прочитает следующий кусок.
      - Это является важным преимуществом потоков.
      - Какой бы большой файл не был, одновременно работа с ним занимает <= 64kb памяти.

    # Можно дополнять потоки своим функционалом
      - Это является вторым важным преимуществом потоков.
      - Можно создать свой класс, наследующий от stream.Readable.
      - Который работает с теми же самыми событиями.
      - И дополнить его доп.функционалом.

  > Использование Writable-потока

    # Код примера

      var http = require('http');                 // Подключить модуль http
      var fs = require('fs');                     // Подключить модуль fs

      new http.Server(function(req, res){

        if(req.url == '/big.html') {

          var file = new fs.ReadStream('big.html');
          sendFile(file, res);

        }

      }).listen(3000);

      function sendFile(file, res) {

        file.on('readable', write);

        function write() {
          var fileContent = file.read();                // считать

          if(fileContent && !res.write(fileContent)) {  // отправить

            file.removeListener('readable', write);

            res.once('drain', function() {              // подождать
              file.on('readable', write);
              write();
            });

          }

        }
        file.on('end', function(){
          res.end();
        });

      }

    # Описание работы примера
      - В примере res является экземпляром класса http.ServerResponse
      - Который является наследником класса stream.Writable
      - Итак, алгоритм использования writable-потоков следующий.
      - Вначале надо создать объект writable-потока.
      - В нашем случае, у нас http-сервер, и этот объект создаётся за нас,
        и ссылка на него лежит в res в callback-функции.
      - Отправить данные клиенту можно с помощью res.write(data);
      - Наши данные добавляются к спец.св-ву потока - его буферу.
      - Если буфер ещё не достиг лимитов размера (64кб), то
        res.write() вернёт true, что означает, что можно писать ещё.
      - При этом обязательства по отсылке данных берёт на себя сам поток.
        Как правило, эта отсылка происходит асинхронно.
      - Если жа достиг, то res.write() вернёт false. Это будет означать,
        что внутренний буфер потока переполнен.
      - При получении false обычно запись не продолжают, а ждут события
        drain, которое означает, что поток отослал данные и очистил буфер.
      - Итак, можно вызывать res.write() много много раз. И когда все данные
        будут таким образом переданы, надо вызвать метод res.end().
      - End заканчивает запись, и возбуждает событие 'finish', которое
        означает, что запись полностью завершена.
      - На любом этапе работы с потоке можно его уничтожить методом destroy().
      - После destroy(), событие 'finish' уже никогда не будет возбуждено этим потоком.

  > Метод pipe у Readable-потоков
    - Принцип работы: [readable].pipe[writable]
    - Пример:

        var http = require('http');                 // Подключить модуль http
        var fs = require('fs');                     // Подключить модуль fs

        new http.Server(function(req, res){

          if(req.url == '/big.html') {

            var file = new fs.ReadStream('big.html');
            sendFile(file, res);

          }

        }).listen(3000);

        function sendFile(file, res) {

          file.pipe(res);                           // Код метода pipe см.в примере выше про writable-потоки

          file.on('error', function(err) {          // Обработаем ошибки
            res.statusCode = 500;
            res.end("Server Error");
            console.error(err);
          });

          res.on('close', function(){               // Обработать ситуацию при обрыве соединения
            file.destroy();
          });

        });

    - Один и тот же входной поток можно пайпить в несколко выходных.
    - Например:

          file.pipe(res);             // Вывод в ответ клиенту
          file.pipe(process.stdout);  // Вывод в std out



Б1. NPM: общая информация

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Что такое NPM
    # Дополнительные сведения о NPM

  --------------------------------------

  > Ссылки

    # Оф.сайт пакетного менеджера NPM
        https://www.npmjs.com/

    # Оф.документациф NPM
        https://docs.npmjs.com/

    # Правила semver для версий
        https://docs.npmjs.com/misc/semver

  > Что такое NPM
    - NPM являеся пакетным менеджером по умолчанию для управления пакетами для NodeJS.
    - По сути, тоже самое, что composer, только последний для PHP.
    - Пакеты можно искать на оф.сайте NPM.

  > Дополнительные сведения о NPM
    - Начиная с NodeJS 0.6.3, NPM поставляется в комплекте.
    - NPM имеет CLI, и управляет зависимостями NodeJS-пакетов.
    - Пользователи могут как просто использовать эти пакеты.
    - Так и создавать свои, и добавлять их в базу NPM.
    - Так, что другие пользователи могут их найти через поиск NPM, и использовать.
    - NPM полностью написан на JS, и разработан by Isaac Z. Schlueter.


Б2. Установка NPM

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка NPM

  --------------------------------------

  > Ссылки

    # Официальный репозиторий NPM на github
        https://github.com/npm/npm

  > Введение
    - В этой главе описано, как установить NPM.

  > Установка NPM
    - NPM обычно устанавливается вместе с NodeJS.
    - Исполняемый файл NPM лежит в том же каталоге, что NodeJS.
    - При установке NodeJS на любую ОС, его каталог автомат.добавляется в PATH.
    - В результате чего, к NPM можно обращаться в терминале из любого каталога.
    - Проверить, что NPM установлен, можно запросив его версию: npm -v


Б3. Установка NPM-пакетов (локально/глобально)

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка NPM-пакета локально

      - Общая информация
      - Какая версия пакета будет установлена
      - Прикладная информация

    # Установка NPM-пакета глобально

      - Общая информация
      - По поводу prefix
      - Прикладная информация

  --------------------------------------

  > Ссылки

    # Локальная/Глобальная установка NPM-пакетов
        https://docs.npmjs.com/getting-started/installing-npm-packages-locally
        https://docs.npmjs.com/getting-started/installing-npm-packages-globally

  > Введение
    - В этой главе описано, как устанавливать NPM-пакеты.
    - Причём, есть глобальная установка, а есть локальная.

  > Установка NPM-пакета локально

    # Общая информация
      - В большинстве случаев, пакет стоит установить локально.
      - Поскольку чаще всего мы используем пакеты, как зависимости.
      - Подключая их к другим пакетам через функцию require.
      - По умолчанию все пакеты устанавливаются локально командой npm install.

    # Какая версия пакета будет установлена
      - Если в npm root нет файла package.json, то последняя версия.
      - А если есть, то послед.версия в рамках semver-ограничения,
        указанного в package.json для этого пакета.

    # Прикладная информация

      npm root
        - Речь идёт об установке локальных пакетов.
        - Поэтому сначала узнаем, где куда мы будем их устанавливать.
        - Эта команда возвращает путь к ближайшему каталогу
          с node_modules / package.json.
        - Соответственно, команда удаления будет относиться к нему.
        - И будет устанавливать локальный пакет в этот node_modules.

      npm ls
        - Посмотреть список пакетов, установленных в node_modules.
        - В том самом, который находится в npm root.

      npm search [строка поиска]
        - Этой командой можно поискать нужный пакет в оф.реестре NPM.

      npm install [имя пакета] --save
        - Найденный пакет можно установить локально, зная его имя.
        - В тот самый node_modules, который находится в npm root.
        - Флаг --save значит, что он будет добавлен "dependencies"
          в package.json.

          *Примечение №1

            Может статься, что каталога node_modules нет ни в
            текущем каталоге, ни в каком каталоге вверх по дереву,
            вплоть до /

            В этом случае, npm root будет указывать на node_modules
            в текущем каталоге. Т.Е. в текущем каталоге при установке
            пакета будет создан каталог node_modules, и в него будет
            установлен пакет.

          *Примечание №2: поставить пакет в текущий каталог

            А что, если требуется поставить пакет именно в текущий
            каталог. То есть мы не хотим, чтобы npm искал node_modules
            выше по дереву.

            Тогда надо создать в текущем каталоге каталог node_modules.
            И выполнить npm install в текущем каталоге. Пакет будет
            установлен в этот самый node_modules.

          *Примечание №3: установка конкретной версии

            А что, если требуется установить конкретную версию пакета?
            Это можно сделать так (на примере пакета express):
            npm i express@3.0.0

          *Примечание №4: установка из github-репозитория

            А что, если требуется установить последнюю версию
            пакета из github-репозитория? Это можно сделать так:
            npm i https://github.com/expressjs/express

            А если надо ещё и версию/ветку/релиз указать?
            npm i https://github.com/expressjs/express@3.0.0

          *Примечание №5: установка из архива

            Вот скачал ты архив с пакетом себе на компьютер.
            Теперь можно его установить, просто указав путь:
            npm i [путь к пакету]

          *Примечание №6: вызов nmp install без аргументов

            NPM посмотрит где npm root, найдёт там package.json.
            Затем посмотрит dependencies (все виды) в нём.
            И установит все зависимости в node_modules в npm root.

          *Примечание №7: зависимости devDependencies

            Допустим, мы в каталоге /x, и в нём есть package.json
            и node_modules. Выполним npm i в этом каталоге, и в
            node_modules будут установлены все зависимости из
            dependencies из package.json.

            И в каждом из пакето-взависимостий будут установлены
            их dependencies, и т.д. Но вот devDependencies для
            пакетов зависимостей устанавливаться не будут.

            А их можно установить, лишь непосредственно зайдя
            в каталог с пакетом-зависимостью, например, в
            /x/node_modules/somepack, и выполнив там npm i

  > Установка NPM-пакета глобально

    # Общая информация
      - Иногда требуется установить сторонний пакет, работающий как CLI.
      - Он совсем не предназначен для того, чтобы его подключали с помощью require.
      - А служит каким-нибудь вспомогательным CLI-инструментом.
      - Который, желательно, должен быть доступен глобально.
      - И при этом, в его bin и directories.bin путь к точке входа не прописан.
      - Тогда есть смысл установить такой пакет глобально.

    # По поводу prefix
      - При глобальной установке NPM смотрит значение параметра prefix.
      - Его можно узнать, введя:

          npm config get prefix           // "/usr"

      - А изменить prefix можно в настройках NPM.
      - NPM устанавливает пакет в: [prefix]/lib/node_modules/[имя пакета]
      - NPM создает символьную ссылку на точку входа пакета в: [prefix]/bin/[имя пакета]

    # Прикладная информация

      npm ls -g --depth=0
        - Посмотреть список всех установленных глобально пакетов.

      npm search [строка поиска]
        - Этой командой можно поискать нужный пакет в оф.реестре NPM.

      sudo npm install [имя пакета] -g
        - Установить указанный пакет глобально





Б4. Пространства имен NPM-пакетов

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Зачем нужны пр.имён
    # Обратная совместимость с пакетами без пр.имён
    # Установка пакетов с пр.имён
    # Подключение пакетов с пр.имён к другим с помощью require
    # Публикация пакетов с пр.имён

      - Общая информация
      - Публикация публичных пакетов с пр.имён в публичный реестр NPM
      - Публикация приватных пакетов с пр.имён в реестр NPM

    # Ассоциация пр.имён с реестрами

  --------------------------------------

  > Ссылки

    # Ссылка на оф.документацию по конфигурированию NPM
        https://docs.npmjs.com/misc/config
        https://docs.npmjs.com/files/folders

  > Введение
    - Каждый NPM-пакет имеет name.
    - Некоторые имена имеют также префикс в виде пр.имён.
    - Пр.имён должно также соотв.всем ограничениям на name.
    - Пр.имён должно начинаться с @ и заканчиваться на /
    - Пример имени с пр.имён:

        @somescope/somepackagename

  > Зачем нужны пр.имён
    - Это способ сгруппировать связанные пакеты.
    - Также это влияет на несколько вещей, как NPM обрабатывае пакеты.

  > Обратная совместимость с пакетами без пр.имён
    - Пакеты с пр.имён поддерживаются публичным реестром NPM.
    - NPM-клиент обратно совместим с пакетами без пр.имён.
    - Так что он может работать одновременно и с записями
      с пр.имён, и без пр.имён.

  > Установка пакетов с пр.имён
    - Пакеты с пр.имён устанавливаются в подкаталог относ.обычного пути установки.
    - К примеру:

        node_modules/package            // пакет без пр.имён
        node_modules/@4gekkman/package  // пакет с пр.имён

    - Установить пакет с пр.имён можно также, как и без пр.имён.
    - Только надо использовать полное имя, квалифицированное пр.имён:

        sudo npm install @myorg/mypackage

    - Или, в package.json.
    - Но здесь надо быть осторожным, и не пропустить символ @.
    - Иначе NPM сочтёт, что это имя пакета на github.
    - Пример:

        "dependencies": {
          "@myorg/mypackage": "^1.3.0"
        }

  > Подключение пакетов с пр.имён к другим с помощью require
    - Как обычно, надо только учесть, что пакет установлен в каталог с именем пр.имён.
    - С учётом особенностей автопоиска модулей NPM, выходит, что
      для пакетов с пр.имён надо всегда указывать соотв.префикс.
    - Пример:

        require('@myorg/mypackage')

  > Публикация пакетов с пр.имён

    # Общая информация
      - Их можно публиковать в любые реестры, поддерживающие пр.имён.
      - В том числе и в публичный реестр NPM.
      - Последний поддерживает пр.имён, начиная с 2015-04-19.

    # Публикация публичных пакетов с пр.имён в публичный реестр NPM
      - Для этого надо указать npm publish --access public при публикации.
      - Это опубликует пакет и назначит право доступа public.

    # Публикация приватных пакетов с пр.имён в реестр NPM
      - Для этого надо иметь аккаунт npm private modules.
      - Тогда можно будет публиковать приватные пакеты:
          npm publish --access restricted
      - И они будут присутствовать в реестре NPM, с правами restricted.
      - Права доступа можно сменить на npmjs.com или командой npm access.

  > Ассоциация пр.имён с реестрами
    - Пр.имён м.б. ассоциировано с разными реестрами.
    - Это позволяет использовать пакеты из разных реестров.
    - Но с одним и тем же пространством имён.
    - Ассоциировать пр.имён с реестром можно так:

        npm login --registry=http://reg.example.com --scope=@myco

    - Пр.имён имеют n:m связи с реестрами. Один реест может иметь
      много пр.имён, и наоборот.
    - Можно ассоциировать пр.имён с реестром с помощью npm config:

        npm config set @myco:registry http://reg.example.com

    - Допустим, ассоциировали пр.имён с каким-то реестром.
    - Теперь NPM будет в 1-ю очередь устанавливать пакеты,
      которые помечены этим пр.имён, из этого реестра.


Б5. Конфиг NPM-пакета package.json

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Справочник по св-вам package.json

      Обязательные поля

        - name                  // [ОБЯЗАТЕЛЬНО] имя пакета
        - version               // [ОБЯЗАТЕЛЬНО] версия (соотв.semver, т.е. как в composer)

      Наиболее важные поля

        - description           // Описание пакета (если отсутствует, берётся 1-ая строчка из readme.md; по описанию ведётся поиск в npm search)
        - main                  // Точка входа для пакета (если нет, ищет по порядку index.js/index.json/index.node в корне пакета)
        - dependencies          // Зависимости пакета
        - devDependencies       // Зависимости пакета, необходимые лишь при разработке

      Прочие поля

        - author                // Содержит объект с информацией об авторе
        - bin                   // Установить в PATH пути к исполняемым файлам пакета
        - bugs                  // URL к багтреккеру пакета, и email куда слать инфу о багах
        - bundledDependencies   // Тоже, что dependencies, только зависимости заранее скачиваются в пакет
        - config                // Объект с конфигом произвольных параметров для пакета
        - contributors          // Содержит массив объектов с информацией о соавторах
        - cpu                   // Явно указать поддерживаемые и нет архитектуры CPU
        - directories           // Это метоинформация о том, у каком каталоге пакета что лежит
        - engines               // Явно указать версии NodeJS и NPM, с которыми пакет работает нормально.
        - files                 // Массив файлов и каталогов, которые надо включить в пакет при публикации
        - homepage              // URL к домашней странице проекта
        - keywords              // Массив ключевых слов, помогающих найти пакет через NPM.
        - license               // Лицензия пакета
        - man                   // Строка/Массив с путём/путями к справке/справкам для пакета
        - optionalDependencies  // Опциональные зависимости, если нет, то ничего страшного (обработка случаев есть/нет идёт в коде)
        - os                    // Явно указать поддерживаемые и нет ОС
        - peerDependencies      // Можно явно указать совместимость с другими пакетами (часто применяется для плагинов)
        - preferGlobal          // Будет выводить warning, если установить пакет локально
        - private               // Если true, npm откажет в публикации пакета (способ избежать публикации private-пакетов)
        - publishConfig         // Здесь можно перезаписать значения некоторых св-в конфига npm (имеющих отношение к публикации)
        - repository            // Это аналог repositories из composer.json
        - scripts               // Набор скриптов-хуков, реагирующих на разные события с пакетом

  --------------------------------------

  > Ссылки

    # Ссылка на оф.документацию по удалению по package.json
        https://docs.npmjs.com/files/package.json#people-fields-author-contributors

  > Введение
    - Файл package.json, это конфиг для NPM
    - Он как composer.json для composer, но только для NPM.
    - Он позволяет управлять пакетами локально в том каталоге, где он находится.
    - Он содержит json с рядом св-в, позволяющих всё настроить, см.их ниже.

  > Справочник по св-вам package.json

    # name
      - Это обязательное поле. Вместе с version образуют уникальный ID пакета.
      - Требования к имени:

          * < 214 символов
          * Не должно начинатсья с . или _
          * Не должно содержать заглавных букв
          * Имя будет частью URL, поэтому не должно содержать запрещённых в URL символов

      - Несколько рекомендаций:

          * Не используйте имена, занятые модулями ядра NodeJS
          * Не вставляйте JS или NODE в имя файла (если надо, добавьте в engines)
          * Name д.б. коротким и удобоваримым, чтобы удобно было его вставлять в require.
          * Перед name м.б. префик с виде пространства имён (типа: @4gekkman/name)

    # version
      - Это обязательное поле. Вместе с name образуют уникальный ID пакета.
      - Версия должна соответствовать правилам semver (как и версии в composer).
      - Для работы с версиями есть удобный пакет semver.

    # description
      - Описание пакета.
      - Если отсутствует, берётся 1-ая строчка из readme.md.
      - По описанию ведётся поиск в npm search

    # main
      - Позволяет явно указать точку входа для пакета.
      - По аналогии с веб-сервером, где д.б. точка входа типа index.php.
      - Точка входа может быть только одна.
      - По умолчанию, если main не указана, точками входа в корне пакетя являются:
          index.js    // Сначала ищет index.js
          index.json  // Если не нашло, ищет index.json
          index.node  // Если не нашло, ищет index.node

    # dependencies

      ## Общая информация
        - Содержит объект с зависимостями данного пакета.
        - Формат зависимости точно такой же, как в composer:
          Например: {"foo": "~1.0", "bar": "1.0.0"}
        - Форматы версий соответствуют semver и composer.
        - По умолчанию пакет скачивается оттуда, откуда указали авторы.

      ## Можно явно указать, откуда скачивать пакет

        ### URL
          - По этому адресу должен лежать tar-архив с пакетом.
          - Он будет скачен и установлен в ваш пакет.
          - Примеры:  {
                        "foo": "http://site.ru/dependency"
                      }

        ### GIT
          - Можно указывать git-репозиторий, и даже конкретный релиз.
          - В качестве commit-ish м.б.: тег (версия), sha или имя ветки.
          - По умолчанию, если commit-ish не указан, используется master.
          - Примеры:  {
                        "foo": "git://github.com/user/project.git#commit-ish",
                        "bar": "git+ssh://user@hostname:project.git#commit-ish",
                        "baz": "git+ssh://user@hostname/project.git#commit-ish",
                        "loz": "git+http://user@hostname/project/blah.git#commit-ish",
                        "gaz": "git+https://user@hostname/project/blah.git#commit-ish",
                      }

        ### GITHUB
          - Можно указать просто имя github-пакета (типа: "4gekkman/m1").
          - В конце, как описано выше, можно указать commit-ish.
          - Примеры:  {
                        "foo": "visionmedia/express",
                        "bar": "visionmedia/mocha#4727d357ea"
                      }

        ### Local path
          - Можно просто указать какой-нибудь локальный каталог.
          - Этот каталог должен содержать в себе npm-пакет.
          - Примеры:  {
                        "foo": "file:../foo/bar"
                      }

    # devDependencies
      - Тоже самое, что dependencies.
      - Но здесь д.б. зависимости, необходимые лишь во время разработки.
      - Но не нужные конечному пользователю пакета.
      - Эти зависимости можно установить, выполнив npm install из корня пакета.

    # author
      - Содержит объект с информацией об авторе.
      - Формат объекта (на примере):

        {
          "name" : "Barney Rubble",
          "email" : "b@rubble.com",
          "url" : "http://barnyrubble.tumblr.com/"
        }

    # bin
      - Установить в PATH пути к исполняемым файлам пакета.
      - Суть та же самая, как при установке пакета глобально.
      - В prefix/bin кладутся пути из bin.
      - По ключам путей в bin можно запускать соотв.исполняемые файлы.
      - Чаще всего эта фича используется для пакетов с CLI.
      - Примеры:

          "bin": "./path/to/program"                      // Если путь лишь 1, можно передать в виде строки
          "bin" : { "myapp" : "./cli.js" }
          "bin" : { "my-program" : "./path/to/program" }

    # bugs
      - URL к багтреккеру пакета, и email куда слать инфу о багах.
      - Можно использовать как одно, так и оба поля.
      - Если URL указан, он будет использован командой npm bugs.
      - Пример:

          {
            "url": "https://github.com/owner/project/issues",
            "email" : "project@hostname.com"
          }

    # bundledDependencies
      - Тоже самое, что dependencies.
      - Только зависимости заранее скачиваются в пакет.
      - И пакет поставляется сразу вместе с зависимостями.
      - NodeJS активно развивается, и многое во многих зависимостях меняется.
      - В итоге, npm update может легко сломать весь проект из-за того,
        что какой-то чел в своём пакете что-то поменял.
      - Чтобы этого избежать, можно "забандлить" зависимости прямо
        в свой пакет, и быть уверенным, что в них уже никто ничего не изменит.

    # config
      - Объект с конфигом произвольных параметров для пакета.
      - Подробнее об этом: https://docs.npmjs.com/misc/config

    # contributors
      - Содержит массив объектов с информацией о соавторах
      - Формат каждого объекта в массиве (на примере):

        {
          "name" : "Barney Rubble",
          "email" : "b@rubble.com",
          "url" : "http://barnyrubble.tumblr.com/"
        }

    # cpu
      - Явно указать поддерживаемые и нет архитектуры CPU.
      - Если перед именем CPU стоит "!", значит это не поддерживаемая.
      - Примеры:

          "cpu" : [ "x64", "ia32", "!arm" ]

    # directories
      - Это метоинформация о том, у каком каталоге пакета что лежит.
      - Каждый ключ в этом объекте обозначает каталог некого назначения.
      - Часто используемые:

        lib         // где находятся главные файлы пакета (ничего особенного npm с этим не делает)
        bin         // все файлы из bin будут добавлены в path системы (нельзя указывать одновременно с опцией bin конфига)
        man         // каталог с манами (ничего особенного npm с этим не делает)
        doc         // документы markdown
        example     // примеры работы

    # engines
      - Явно указать версии NodeJS и NPM, с которыми пакет работает нормально.
      - Версии соответствуют нотации semver.
      - Примеры:

          "engines" : { "node" : ">=0.10.3 <0.12" }
          "engines" : { "npm" : "~1.0.20" }

    # files
      - Массив файлов и каталогов, которые надо включить в пакет при публикации.
      - Если указан каталог, то будет включено всё его содержимое.
      - В корне пакета можно создать файл .npmignore, работающий, как .gitignore.
        Подробнее про .gitignore см.здесь: https://git-scm.com/docs/gitignore
      - По умолчанию в пакет включаются все файлы, кроме следующих:

          .git
          CVS
          .svn
          .hg
          .lock-wscript
          .wafpickle-N
          *.swp
          .DS_Store
          ._*
          npm-debug.log

      - А следующие файлы включаются в пакет всегда, отменить это нельзя:

          package.json
          README (and its variants)
          CHANGELOG (and its variants)
          LICENSE / LICENCE

    # homepage
      - URL к домашней странице проекта.

    # keywords
      - Массив ключевых слов, помогающих найти пакет через NPM.

    # license
      - Здесь можно указать лицензию пакета.
      - Значение должно быть в формате SPDX: https://www.npmjs.com/package/spdx
      - Примеры:

          { "license" : "BSD-3-Clause" }
          { "license": "ISC" }
          { "license": "(MIT OR Apache-2.0)" }

    # man
      - Строка/Массив с путём/путями к справке/справкам для пакета.
      - Если указана строка, а не массив, то:

        package.json                      Командная строка
        --------------------------        ----------------
          {                                 man foo     // покажет справку для пакета foo
            "name":     "foo",
            "version":  "1.2.3",
            "man" : "./man/doc.1"
          }

      - Если указан массив ссылок на несколько справок.
      - То если имя справки начинается, как имя пакета, то
        можно обратиться к этой справке по имени пакета: man foo
      - В противном случае, к справке можно обратитсья по её имени,
        у которого есть префикс в виде имени пакета: man foo-bar.
      - Пример:

        package.json                                  Командная строка
        --------------------------                    ----------------
          {                                             man foo       // покажет справку foo для пакета foo
            "name":     "foo",                          man foo-bar   // покажет справку bar для пакета foo
            "version":  "1.2.3",
            "man" : ["./man/foo.1", "./man/bar.1",]
          }

    # optionalDependencies
      - Иногда зависимость важна, но не обязательно для пакета.
      - То есть, если установить её по какой-то причине не удастся, ничего страшного.
      - Такие зависимости можно поместить в optionalDependencies.
      - Случаи присутствия/отсутствия зависимости обрабатываются в коде пакета.
      - Внимание! Добавленные в optionalDependencies зависимости затрут
        добавленные в dependencies зависимости. Поэтому, лучше добавлять
        зависимость либо туда, либо туда.

    # os
      - Можно явно указать поддерживаемые и нет операционные системы.
      - Если перед именем ОС стоит "!", значит это не поддерживаемая.
      - Примеры:

          "os" : [ "darwin", "linux", "!win32" ]

    # peerDependencies
      - Иногда требуется явно указать совместимость с другим/ми пакетом/ами.
      - Но при этом, не устанавливать их в качестве зависимостей.
      - Этот приём часто используется для пакетов-плагинов к другим пакетам.
      - Типа, этот плагин работает только с такими-то версиями такого-то пакета.
      - Например:

          {
            "name": "tea-latte",
            "version": "1.3.5",
            "peerDependencies": {
              "tea": "2.x"
            }
          }

      - Здесь мы говорим, что плагин "tea-latte" может работать только
        с пакетом "tea" версий "2.x".
      - Попытка установить "tea-latte" с "tea" версии не "2.x"
        приведёт к ошибке.

    # preferGlobal
      - Будет выводить warning, если установить пакет локально.
      - Актуально, если пакет преимущественно представляет CLI-инструмент.
      - С командами, которые должны быть доступны глобально.
      - Это не поможет предотвратить локальную установку пакета.
      - Но будет выводить предупреждения, что может помочь избежать недоразумений.

    # private
      - Если true, npm откажет в публикации пакета
      - Это такой способ избежать публикации private-пакетов.
      - Настроить публикацию можно в св-ве publishConfig.

    # publishConfig
      - Здесь можно перезаписать значения некоторых св-в конфига npm.
      - Подразумевается, что здесь м.б. перезаписаны относящиеся к публикации св-ва.
      - А именно: "tag", "registry" и "access".

    # repository
      - Это аналог repositories из composer.json.
      - Здесь можно указать, откуда какой пакет устанавливать.
      - По умолчанию, пути пакеты берутся из регистра NPM,
        аналогично, как в случае с composer, из регистра packagist.com.
      - Например, укажем, чтобы NPM устанавливался из указанного github-репозитория:

          "repository": {
            "type": "git",
            "url": "https://github.com/npm/npm.git"
          }

      - Эта возможность важна для соавторов.
      - Чтобы можно было подменить оригинальный репозиторий
        своим формок с изменениями, и потестировать, как всё работает.

    # scripts
      - Набор скриптов-хуков, реагирующих на разные события с пакетом.
      - Подробнее об этом см.здесь: https://docs.npmjs.com/misc/scripts


Б6. Конфигурирование NPM

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Источники параметров конфигурации в убывающем по приоритету порядке

      - CLI flags
      - Переменные среды
      - Файлы npmrc
      - Конфиг по умолчанию

    # Параметры в "config" при запуске "scripts" из package.json
    # Список аргументов для CLI of NPM

      -v      | --version           | версия NPM
      -h      | --help              | справка по команде: npm [команда] -h
      -s      | --silent            |
      -q      | --quiet             |
      -d      | --loglevel info     |
      -dd     | --loglevel verbose  |
      -ddd    | --loglevel silly    |
      -g      | --global            | установить пакет глобально
      -C      | --prefix            |
      -l      | --long              |
      -m      | --message           |
      -p      | --parseable         |
      -reg    | --registry          |
      -f      | --force             |
      -desc   | --description       |
      -S      | --save              |
      -D      | --save-dev          |
      -O      | --save-optional     |
      -B      | --save-bundle       |
      -E      | --save-exact        |
      -y      | --yes               |
      -n      | --yes false         |
      -ll     | ls --long           |

    # Список параметров NPM

      parameter                   default     description
      -------------------------------------------------------------------------------------------------------------------------------------
      - access                  | restricted  | When publishing scoped packages, the access level defaults to restricted.
      - always-auth             | false       | Force npm to always require authentication when accessing the registry, even for GET requests.
      - also                    | null        | When "dev" or "development" and running local npm shrinkwrap, npm outdated, or npm update, is an alias for --dev.
      - bin-links               | true        | Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
      - browser                 | xdg-open    | The browser that is called by the npm docs command to open websites.
      - ca                      | npm sert    | The Certificate Authority signing certificate that is trusted for SSL connections to the registry
      - cafile                  | null        | A path to a file containing one or multiple Certificate Authority signing certificates.
      - cache                   | ~/.npm      | The location of npm's cache directory
      - cache-lock-stale        | 60000(1min) | The number of ms before cache folder lockfiles are considered stale.
      - cache-lock-retries      | 10          | Number of times to retry to acquire a lock on cache folder lockfiles.
      - cache-lock-wait         | 10000(10s)  | Number of ms to wait for cache lock files to expire.
      - cache-max               | Infinity    | The maximum time (in seconds) to keep items in the registry cache before re-checking against the registry.
      - cache-min               | 10          | The minimum time (in seconds) to keep items in the registry cache before re-checking against the registry.
      - cert                    | null        | A client certificate to pass when accessing the registry.
      - color                   | true        | If false, never shows colors. If "always" then always shows colors. If true, then only prints color codes for tty file descriptors.
      - depth                   | Infinity    | The depth to go when recursing directories for npm ls, npm cache ls, and npm outdated.
      - description             | true        | Show the description in npm search
      - dev                     | false       | Install dev-dependencies along with packages.
      - dry-run                 | false       | Indicates that you don't want npm to make any changes and that it should only report what it would have done.
      - editor                  | EDITOR / vi | The command to run for npm edit or npm config edit. EDITOR environment variable if set, or "vi" on Posix, or "notepad" on Windows.
      - engine-strict           | false       | If set to true, then npm will stubbornly refuse to install (or even consider installing) any package that claims to not be compatible with the current Node.js version.
      - force                   | false       | Makes various commands more forceful.
      - fetch-retries           | 2           | The "retries" config for the retry module to use when fetching packages from the registry.
      - fetch-retry-factor      | 10          | The "factor" config for the retry module to use when fetching packages.
      - fetch-retry-mintimeout  | 10000(10s)  | The "minTimeout" config for the retry module to use when fetching packages.
      - fetch-retry-maxtimeout  | 60000(1min) | The "maxTimeout" config for the retry module to use when fetching packages.
      - git                     | git         | The command to use for git commands. If git is installed on the computer, but is not in the PATH, then set this to the full path to the git binary.
      - git-tag-version         | true        | Tag the commit when using the npm version command.
      - global                  | false       | Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory.
      - globalconfig            | {prefix}/etc/npmrc  | The config file to read for global config options.
      - global-style            | false       | Causes npm to install the package into your local node_modules folder with the same layout it uses with the global node_modules folder.
      - group                   | GID of the current process | The group to use when running package scripts in global mode as the root user.
      - heading                 | npm         | The string that starts all the debugging log output.
      - https-proxy             | null        | A proxy to use for outgoing https requests. If the HTTPS_PROXY or https_proxy or HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by the underlying request library.
      - if-present              | false       | If true, npm will not exit with an error code when run-script is invoked for a script that isn't defined in the scripts section of package.json
      - ignore-scripts          | false       | If true, npm does not run scripts specified in package.json files.
      - init-module             | ~/.npm-init.js | A module that will be loaded by the npm init command.
      - init-author-name        | ""          | The value npm init should use by default for the package author's name.
      - init-author-email       | ""          | The value npm init should use by default for the package author's email.
      - init-author-url         | ""          | The value npm init should use by default for the package author's homepage.
      - init-license            | "ISC"       | The value npm init should use by default for the package license.
      - init-version            | "1.0.0"     | The value that npm init should use by default for the package version number, if not already set in package.json.
      - json                    | false       | Whether or not to output JSON data, rather than the normal output.
      - key                     | null        | A client key to pass when accessing the registry.
      - legacy-bundling         | false       | Causes npm to install the package such that versions of npm prior to 1.4, such as the one included with node 0.8, can install the package. This eliminates all automatic deduping. If used with global-style this option will be preferred.
      - link                    | false       | If true, then local installs will link if there is a suitable globally installed package. Note that this means that local installs can cause things to be installed into the global space at the same time.
      - local-address           | undefined   | The IP address of the local interface to use when making connections to the npm registry. Must be IPv4 in versions of Node prior to 0.12.
      - loglevel                | warn        | What level of logs to report. On failure, all logs are written to npm-debug.log in the current working directory. "silent", "error", "warn", "http", "info", "verbose", "silly"
      - logstream               | process.stderr | This is the stream that is passed to the npmlog module at run time.
      - long                    | false       | Show extended information in npm ls and npm search.
      - message                 | "%s"        | Commit message which is used by npm version when creating version commit.
      - node-version            | process.version | The node version to use when checking a package's engines map.
      - npat                    | false       | Run tests on installation.
      - onload-script           | false       | A node module to require() when npm loads. Useful for programmatic usage.
      - only                    | null        | When "dev" or "development" and running local npm install without any arguments, only devDependencies (and their dependencies) are installed. When "dev" or "development" and running local npm ls, npm outdated, or npm update, is an alias for --dev. When "prod" or "production" and running local npm install without any arguments, only non-devDependencies (and their dependencies) are installed. When "prod" or "production" and running local npm ls, npm outdated, or npm update, is an alias for --production.
      - optional                | true        | Attempt to install packages in the optionalDependencies object. Note that if these packages fail to install, the overall installation process is not aborted.
      - parseable               | false       | Output parseable results from commands that write to standard output.
      - prefix                  | see npm-folders | The location to install global items. If set on the command line, then it forces non-global commands to run in the specified folder.
      - production              | false       | Set to true to run in "production" mode. devDependencies are not installed at the topmost level when running local npm install without any arguments. Set the NODE_ENV="production" for lifecycle scripts.
      - progress                | true        | When set to true, npm will display a progress bar during time intensive operations, if process.stderr is a TTY. Set to false to suppress the progress bar.
      - proprietary-attribs     | true        | Whether or not to include proprietary extended attributes in the tarballs created by npm. Unless you are expecting to unpack package tarballs with something other than npm -- particularly a very outdated tar implementation -- leave this as true.
      - proxy                   | null        | A proxy to use for outgoing http requests. If the HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by the underlying request library.
      - rebuild-bundle          | true        | Rebuild bundled dependencies after installation.
      - registry                | https://registry.npmjs.org/ | The base URL of the npm package registry.
      - rollback                | true        | Remove failed installs.
      - save                    | false       | Save installed packages to a package.json file as dependencies. When used with the npm rm command, it removes it from the dependencies object. Only works if there is already a package.json file present.
      - save-bundle             | false       | If a package would be saved at install time by the use of --save, --save-dev, or --save-optional, then also put it in the bundleDependencies list. When used with the npm rm command, it removes it from the bundledDependencies list.
      - save-dev                | false       | Save installed packages to a package.json file as devDependencies. When used with the npm rm command, it removes it from the devDependencies object. Only works if there is already a package.json file present.
      - save-exact              | false       | Dependencies saved to package.json using --save, --save-dev or --save-optional will be configured with an exact version rather than using npm's default semver range operator.
      - save-optional           | false       | Save installed packages to a package.json file as optionalDependencies. When used with the npm rm command, it removes it from the devDependencies object. Only works if there is already a package.json file present.
      - save-prefix             | '^'         | Configure how versions of packages installed to a package.json file via --save or --save-dev get prefixed. For example if a package has version 1.2.3, by default its version is set to ^1.2.3 which allows minor upgrades for that package, but after npm config set save-prefix='~' it would be set to ~1.2.3 which only allows patch upgrades.
      - scope                   | ""          | Associate an operation with a scope for a scoped registry. Useful when logging in to a private registry for the first time: npm login --scope=@organization --registry=registry.organization.com, which will cause @organization to be mapped to the registry for future installation of packages specified according to the pattern @organization/package.
      - searchopts              | ""          | Space-separated options that are always passed to search.
      - searchexclude           | ""          | Space-separated options that limit the results from search.
      - searchsort              | "name"      | Indication of which field to sort search results by. Prefix with a - character to indicate reverse sort.
      - shell                   | SHELL environment variable, or "bash" on Posix | The shell to run for the npm explore command.
      - shrinkwrap              | true        | If set to false, then ignore npm-shrinkwrap.json files when installing.
      - sign-git-tag            | false       | If set to true, then the npm version command will tag the version using -s to add a signature. Note that git requires you to have set up GPG keys in your git configs for this to work properly.
      - strict-ssl              | true        | Whether or not to do SSL key validation when making requests to the registry via https. See also the ca config.
      - tag                     | latest      | If you ask npm to install a package and don't tell it a specific version, then it will install the specified tag. Also the tag that is added to the package@version specified by the npm tag command, if no explicit tag is given.
      - tag-version-prefix      | "v"         | If set, alters the prefix used when tagging a new version when performing a version increment using npm-version. To remove the prefix altogether, set it to the empty string: "". Because other tools may rely on the convention that npm version tags look like v1.0.0, only use this property if it is absolutely necessary. In particular, use care when overriding this setting for public packages.
      - tmp                     | TMPDIR environment variable, or "/tmp" | Where to store temporary files and folders. All temp files are deleted on success, but left behind on failure for forensic purposes.
      - unicode                 | false on windows, true on mac/unix systems with a unicode locale | When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters to draw trees.
      - unsafe-perm             | false if running as root, true otherwise | Set to true to suppress the UID/GID switching when running package scripts. If set explicitly to false, then installing as a non-root user will fail.
      - usage                   | false       | Set to show short usage output (like the -H output) instead of complete help when doing npm-help.
      - user                    | "nobody"    | The UID to set to when running package scripts as root.
      - userconfig              | ~/.npmrc    | The location of user-level configuration settings.
      - umask                   | 022         | The "umask" value to use when setting the file creation mode on files and folders. Folders and executables are given a mode which is 0777 masked against this value. Other files are given a mode which is 0666 masked against this value. Thus, the defaults are 0755 and 0644 respectively.
      - user-agent              | node/{process.version} {process.platform} {process.arch} | Sets a User-Agent to the request header
      - version                 | false       | If true, output the npm version and exit successfully. Only relevant when specified explicitly on the command line.
      - versions                | false       | If true, output the npm version as well as node's process.versions map, and exit successfully. Only relevant when specified explicitly on the command line.
      - viewer                  | "man" on Posix, "browser" on Windows | The program to use to view help content. Set to "browser" to view html help content in the default web browser.


  --------------------------------------

  > Ссылки

    # Ссылка на оф.документацию по конфигурированию NPM
        https://docs.npmjs.com/misc/config

    # Ссылка на оф.документ по конфигам npmrc
        https://docs.npmjs.com/files/npmrc

  > Введение
    - Это глава про конфигурирование самого NPM.
    - Не путать с конфигурированием пакетов в package.json.

  > Источники параметров конфигурации в убывающем по приоритету порядке

    # CLI flags
      - В cli можно использовать флаги.
      - Например:

          --foo bar   // Это установит параметр foo == bar в настройках npm.
          --foo       // Это установит параметр foo == true в настройках npm (!!!но только, если это последний параметр в команде)
          --          // Это говорит npm не считывать флаги справа от него

    # Переменные среды
      - Переменные среды с префиксом "npm_config_" считаются параметрами NPM.
      - Например:

          npm_config_foo=bar                  // Назначить параметр foo == bar в настройках npm.
          npm_config_foo                      // Назначить параметр foo == true настройках npm.
          npm_config_foo == NPM_CONFIG_FOO    // Они регистро-независимы

    # Файлы npmrc
      - Может быть 4 файла npmrc, которые берутся в расчёт.
      - Вот они:

          1) Конфиг проекта           (/path/to/my/project/.npmrc)
          2) Конфиг пользователя      (~/.npmrc)
          3) Глобальный NPM-конфиг    ($PREFIX/etc/npmrc)
          4) Встроенный NPM-конфиг    (/path/to/npm/npmrc)

    # Конфиг по умолчанию
      - Если параметр не перезаписан, для него используется значение по умолчанию.
      - Значения по умолчанию захардкожены где-то в недрах NPM.
      - Посмотреть их можно командой: npm config ls -l

  > Параметры в "config" при запуске "scripts" из package.json
    - В package.json есть, среди прочих, 2 поля: "config" и "scripts".
    - В "scripts" содержатся "хуки", срабатывающие при разных событиях с пакетом.
    - В "config" можно разместить параметры для npm.
    - Они будут применяться для скриптов из "scripts".

  > Список аргументов для CLI of NPM
    - См.оглавление.

  > Список параметров NPM
    - См.оглавление.


Б7. Структура каталогов NPM: что куда он записывает

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Установка NPM-пакета

      - Локальная установка
      - Глобальная установка
      - Установка пакетов с пр.имён

    # Ссылки на исполняемые файлы

      - При локальной установке
      - При глобальной установке

    # Ссылки на man'ы

      - При локальной установке
      - При глобальной установке

    # Файлы кэша
    # Временные файлы
    # Дополнительная информация

      - Что происходит при локальной установке пакета
      - Что происходит при глобальной установке пакета
      - Если пакет уже установлен у пакета-предка, он не установется в текущий каталог

    # Публикация

  --------------------------------------

  > Ссылки

    # Ссылка на оф.документацию по структуре каталогов NPM
        https://docs.npmjs.com/files/folders

  > Введение
    - NPM кладёт разные вещи в разные места у тебя на компе.
    - Это его работа.
    - Данная глава раскрывает, что/куда/когда кладёт NPM.

  > Установка NPM-пакета

    # Локальная установка
      - Нужна, если собираешься использовать пакет через require().
      - Устанавливает в текущий каталог, в:

          ./node_modules/[имя пакета]             // для пакетов без пр.имён
          ./node_modules/[пр.имён]/[имя пакета]   // для пакетов с пр.имён

    # Глобальная установка
      - Нужна, если собираешься использовать CLI пакета глобально.
      - Устанавливает в каталог, в зависимости от параметра prefix конфигурации NPM.
      - По умолчанию, prefix - это:

          Путь к каталогу, который находится на 1 уровень выше
          того каталога, в котором установлен NodeJS.

          На Ubuntu 14.04 NodeJS по умолчанию устанавливается в "/usr/bin"
          Значит, prefix по умолчанию равен "/usr"
          Проверить текущее значение prefix: npm config get prefix

      - NPM устанавливает NPM-пакеты глобально в:

          [prefix]/lib/node_modules/

    # Установка пакетов с пр.имён
      - Их также можно устанавливать локально или глобально.
      - И суть остаётся той же самой.
      - Разница в том, что пакет устанавливается не в /node_modules/[имя пакета].
      - А в /node_modules/[пр.имён]/[имя пакета].

  > Ссылки на исполняемые файлы

    # При локальной установке
      - Ссылки размещаются в: [prefix]/bin

    # При глобальной установке
      - Ссылки размещаются в текущем каталоге.
      - А именно: ./node_modules/.bin

  > Ссылки на man'ы

    # При локальной установке
      - Man'ы не устанавливаются.

    # При глобальной установке
      - Ссылки размещаются в: [prefix]/share/man

  > Файлы кэша
    - Файлы кэша хранятся в ~/.npm
    - Это можно изменить параметром cache в конфигурации NPM.

  > Временные файлы
    - Временные файлы сохраняются в соотв.со значением tmp в конфиге NPM.
    - По умолчанию, это значение глобальной переменной: TMPDIR/TMP/TEMP.
    - При каждом запуске программы создаётся отдельный каталог для временных файлов.
    - После завершения работы программы, этот каталог удаляется.

  > Дополнительная информация

    # Что происходит при локальной установке пакета

      ## Поиск корневого каталога
        - Итак, мы собираемся локально установить пакет, и вводим:

            npm install foo@1.2.3

        - NPM пытается найти корневой каталог для текущего пакета.
        - Для этого он извлекает путь к текущему каталогу из глоб.пер. $PWD.
        - И, двигаясь вверх по дереву, ищет "package.json" или "node_modules":
          1) Если находит, то считает найденный каталог корневым для текущего пакета.
            - И устанавливает пакет foo в каталог node_modules в корневом каталоге.
          2) Если не находит, то считает корневым каталог из $PWD
            - И устанавливает пакет foo в каталог $PWD/node_modules

      ## Размещение пакета в кэш, и распаковка в node_modules
        - Итак, мы выполняем install.
        - Пакет помещается в кэш, и распаковывается в: node_modules/foo.
        - Затем, аналогичным образом, рекурсивно, скачиваются и устанавливаются
          зависимости foo, устанавливаются в node_modules/foo/node_modules/...
          И так далее.

      ## Размещение символьных ссылок на бинарные файлы пакета
        - Символьные ссылки на бинарники каждого пакета размещаются
          в ./node_modules/.bin.

    # Что происходит при глобальной установке пакета
      - Было описано выше.

    # Если пакет уже установлен у пакета-предка, он не установется в текущий каталог
      - Как описано выше, перед установкой пакета NPM пробегается вверх по дереву.
      - И ищет там установленные NPM-пакеты.
      - Если пакет, которые вы пытаетесь установить, уже установлен
        у какого-нибудь предка для этого пакета, то он не будет
        установлен в текущей локации.
      - Например, представим такой сценарий:

          foo -> bar -> baz -> bar -> baz

      - Тут у нас бы вышла рекурсивная зависимость.
      - Чтобы этого избежать, последние bar -> baz не устанавливаются.
      - В итоге имеем:

          foo -> bar -> baz

      - Подключая bar из baz с помощью require("bar"), мы получим
        ту копию bar, которая установлена в foo/node_modules/bar.
      - Однако, ситуация, описанная выше возможна, если пакеты
        bar/bar и baz/baz разных версий.
      - В любом случае, общая рекомендация такая:

          Надо устанавливать пакет X, который должен использоваться
          пакетами A,B,C в node_modules, который находится над
          пакетами A,B,C. Тогда можно будет в любом из A,B,C
          подключить пакет X с помощью require('x').

  > Публикация
    - Во время публикации пакет ищет каталог node_modules.
    - Если пакеты из него не в bundledDependencies, то они
      не будут опубликованы вместе с этим пакетом.
    - Это позволяет разработчику пакета устанавливать локально
      все зависимости этого пакета, но не включать их в релиз.
    - А если всё же надо включить, то он может использовать
      bundledDependencies.


Б8. Скрипты и "хуки" NPM-пакетов (поле "scripts" в package.json)

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Формат объекта "scripts"
    # Список доступных событий

      - prepublish                        | ПЕРЕД публикацией пакета (и при локальном npm install без агрументов)
      - publish, postpublish              | ПОСЛЕ публикации пакета
      - preinstall                        | ПЕРЕД установкой пакета
      - install, postinstall              | ПОСЛЕ установки пакета
      - preuninstall, uninstall           | ПЕРЕД удалением пакета
      - postuninstall                     | ПОСЛЕ удаления пакета
      - preversion, version               | ПЕРЕД увеличением версии пакета
      - postversion                       | ПОСЛЕ увеличения версии пакета
      - pretest, test, posttest           | При запуске npm test
      - prestop, stop, poststop           | При запуске npm stop
      - prestart, start, poststart        | При запуске npm start
      - prerestart, restart, postrestart  | При запуске npm restart

    # Кастомные скрипты в "scripts" и npm run-script
    # Задачки, присутствующие неявно по умолчанию у каждого пакета
    # Задачки запускаются с UID пользователя
    # Ключ исполняющегося скрипта из "scripts" лежит в npm_lifecycle_event
    # Скрипты запускаются в sh и не обязаны быть программами на js или для nodejs
    # Хуки NPM-пакетов
    # Лучшие практики

      - Не возвращайте из исполняемых файлов ничего, кроме 0
      - Не используйте "scripts" для того, что NPM может сделать за вас
      - Проверяйте переменные среды, чтобы понять, куда класть то или иное
      - Не используйте sudo в своих командах
      - Не используйте install

  --------------------------------------

  > Ссылки

    # Оф.документ про npm-scripts
        https://docs.npmjs.com/misc/scripts

  > Введение
    - В package.json может быть параметр "scripts".
    - В него можно добавлять список скриптов.
    - Они будут выполняться в зависимости от событий,
      происходящих с пакетом.

  > Формат объекта "scripts"
    - Это объект, который может содержать ряд пар ключ/значение
    - В качестве ключа выступает название события из ограниченного списка.
    - В качестве значения собственно скрипт, который д.б. выполнен.
    - Пример:

        "scripts": {
          "preinstall" : "./configure",
          "install" : "make && make install",
          "test" : "make test"
        }

  > Список доступных событий
    - См.оглавление

  > Кастомные скрипты в "scripts" и npm run-script
    - Есть возможность добавлять в "scripts" и кастомные скрипты.
    - То есть такие, чей ключ не совпадает со списком доступных событий.
    - Запускать их можно следующей командой:

        npm run-script <pkg> <stage>

    - "Pre" и "Post" скрипты с таким же именем будут также запущены.
    - Например: premyscript, myscript, postmyscript.

  > Задачки, присутствующие неявно по умолчанию у каждого пакета
    - В зависимости от содержимого пакета, NPM может выполнить некоторые задачки.
    - А именно:

      # "start": "node server.js"
        - Если в корне пакета есть файл server.js.
        - Тогда считай вышеуказанная команда автоматом присутствует.

      # "install": "node-gyp rebuild"
        - Если в корне пакета есть файл binding.gyp.
        - Тогда считай вышеуказанная команда автоматом присутствует.

  > Задачки запускаются с UID пользователя
    - В том случае, если NPM был запущен с root-правами.

  > Переменные среды "npm_package_" и "npm_config_"
    - Все св-ва из package.json пакета доступны с префиксом "npm_package_" из скрипта.
    - Все св-ва из конфигурации NPM доступны с префиксом "npm_config_" из скрипта.
    - Св-ва конфигурации NPM перезаписываются св-ми из "config" в package.json.

  > Ключ исполняющегося скрипта из "scripts" лежит в npm_lifecycle_event
    - Т.О. можно иметь в пакете один скрипт на все случаи жизни.
    - Просто он проверяет ключ (имя события), которое его запустило.
    - И в зависимости от этого уже производить какие-либо действия.

  > Скрипты запускаются в sh и не обязаны быть программами на js или для nodejs
    - Они лишь должны быть любыми исполняемыми файлами.
    - Если такой скрипт вернёт что-либо, кроме exit 0, это отменит процесс.

  > Хуки NPM-пакетов

    # Что такое "хук"
      - Это скрипт, который выполняется при наступлении указанного
        события с ЛЮБЫМ пакетом, для этого пакета.
      - В отличие от НЕ ХУКОВ, описанных выше, хук выполняется при
        наступлении указанного события вне зависимости от того,
        с каким именно пакетом это событие произошло.

    # Место для хуков
      - Хуки надо класть в следующий каталог:

          node_modules/.hooks/{eventname}

  > Лучшие практики

    # Не возвращайте из исполняемых файлов ничего, кроме 0
      - Кроме как в uninstall-скриптах, это приведёт к отмене npm-операции.
      - Лучше просто вывести предупреждение и завершить скрипт самому.

    # Не используйте "scripts" для того, что NPM может сделать за вас
      - Внимательно прочтите про package.json.
      - Возможно, то, что вы хотели сделать в "scripts" уже доступно из коробки.

    # Проверяйте переменные среды, чтобы понять, куда класть то или иное
      - Например, если npm_config_binroot == "/home/user/bin".
      - Тогда не надо пытаться установить исполняемые файлы в "/usr/local/bin".

    # Не используйте sudo в своих командах
      - Если операции требуются root-права, пользователю будет выведена ошибка.
      - И тогда он запустит npm-команду с sudo.

    # Не используйте install
      - Вместо этого используйте .gyp для компиляции файлов.
      - И prepublish для прочих вещей.
      - Практически нет случаев, когда реально нужно использовать install или preinstall.
      - Единственный валидный способ использовать install, это для компиляции.


Б9. CLI-команды NPM

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # CLI-команды NPM

      Основные для пользователя

        - npm               | Node Packages Manager
        - npm help [команда]| Показать справку о команде

        - root              | Показать npm root (ближайший каталог с node_modules или package.json, начиная от текущего и вверх по дереву)
        - ls                | Список установленных пакетов для npm root
        - prune             | Удалить extraneous-пакеты (которые есть в node_modules у npm root, но нет в package.json у npm root)

        - install           | Install a package
        - update            | Update a package
        - uninstall         | Remove a package
        - search            | Search for packages

        - prefix            | Display prefix
        - bin               | Display npm bin folder
        - config            | Manage the npm configuration files
        - run-script        | Run arbitrary package scripts

        - start             | Start a package
        - stop              | Stop a package
        - restart           | Restart a package

      Основные для разработчика

        - publish           | Publish a package
        - unpublish         | Remove a package from the registry
        - version           | Bump a package version
        - deprecate         | Deprecate a version of a package
        - tag               | Tag a published version
        - pack              | Create a tarball from a package
        - build             | Build a package
        - rebuild           | Rebuild a package

        - init              | Interactively create a package.json file
        - repo              | Open package repository page in the browser

        - access            | Set access level on published packages
        - owner             | Manage package owners

        - adduser           | Add a registry user account
        - logout            | Log out of the registry
        - whoami            | Display npm username

      Прочие

        - docs          | Docs for a package in a web browser maybe
        - bugs          | Bugs for a package in a web browser maybe
        - cache         | Manipulates packages cache
        - completion    | Tab Completion for npm
        - dedupe        | Reduce duplication
        - dist-tag      | Modify package distribution tags
        - edit          | Edit an installed package
        - explore       | Browse an installed package
        - help-search   | Search npm help documentation
        - install-test  |
        - link          | Symlink a package folder
        - outdated      | Check for outdated packages
        - ping          | Ping npm registry
        - shrinkwrap    | Lock down dependency versions
        - star          | Mark your favorite packages
        - stars         | View packages marked as favorites
        - team          | Manage organization teams and team memberships
        - test          | Test a package
        - view          | View registry info

  --------------------------------------

  > Ссылки

    # Официальный справочник CLI-команд NPM
        https://docs.npmjs.com/

  > Введение
    - В этой главе рассмотрим CLI-команды для NPM.

  > CLI-команды NPM
    - См.список в оглавлении.
    - См.подробности по ссылке выше.


Б10. Удаление NPM-пакетов (локальных/глобальных)

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Удаление локальных NPM-пакетов
    # Удаление глобальных NPM-пакетов

  --------------------------------------

  > Ссылки

    # Оф.документация по удалению локальных и глобальных NPM-пакетов
        https://docs.npmjs.com/getting-started/uninstalling-local-packages
        https://docs.npmjs.com/getting-started/uninstalling-global-packages

  > Введение
    - Глава проливает свет на удаление NPM-пакетов.

  > Удаление локальных NPM-пакетов

    npm root
      - Речь идёт об удалении локальных пакетов.
      - Поэтому сначала узнаем, откуда мы будем их удалять.
      - Эта команда возвращает путь к ближайшему каталогу
        с node_modules / package.json.
      - Соответственно, команда удаления будет относиться к нему.
      - И будет удалять локальный пакет из этого node_modules.

    npm ls
      - Посмотреть список пакетов, установленных в node_modules.
      - В том самом, который находится в npm root.

    npm uninstall [имя пакета] --save
      - Удалить указанный пакет из node_modules.
      - И, благодаря флагу --save, из package.json.
      - Из тех самых, которые находятся в npm root.

    npm prune
      - Бывает, что пакет есть в node_modules, но нет в package.json.
      - Тогда при npm ls будет возникать ошибка extraneous для этого пакета.
      - Чтобы поудалять такие пакеты из node_modules, применяется эта команда.

  > Удаление глобальных NPM-пакетов

    npm ls -g --depth=0
      - Посмотреть список всех установленных глобально пакетов.

    npm uninstall -g [имя пакета]
      - Удалить глобально установленный пакет.


Б11. Обновление NPM-пакетов (локальных/глобальных)

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Введение
    # Обновление локальных NPM-пакетов
    # Обновление глобальных NPM-пакетов

  --------------------------------------

  > Ссылки

    # Оф.документация по удалению локальных и глобальных NPM-пакетов
        https://docs.npmjs.com/getting-started/updating-local-packages
        https://docs.npmjs.com/getting-started/updating-global-packages

  > Введение
    - В главе пролит свет на процесс обновления NPM-пакетов.

  > Обновление локальных NPM-пакетов

    npm root
      - Речь идёт об обновлении локальных пакетов.
      - Поэтому сначала узнаем, где мы будем их обновлять.
      - Эта команда возвращает путь к ближайшему каталогу
        с node_modules / package.json.
      - Соответственно, команда удаления будет относиться к нему.
      - И будет обновлять локальный пакет в этом node_modules.

    npm ls
      - Посмотреть список пакетов, установленных в node_modules.
      - В том самом, который находится в npm root.

    npm outdated
      - Какие пакеты в node_modules имеют более новые версии.
      - В том самом, который находится в npm root.

    npm update
      - Обновить все пакеты в node_modules.
      - В том самом, который находится в npm root.

  > Обновление глобальных NPM-пакетов

    npm ls -g --depth=0
      - Посмотреть список всех установленных глобально пакетов.

    npm outdated -g --depth=0
      - Посмотреть, какие глобально-установленные пакеты имеют более новые версии.
      - То есть, их можно обновить.

    npm update -g
      - Обновить все глобально-установленные пакеты.


Г1. Просмотр исходных кодов на JS встроенных модулей NodeJS

  --------------------------------------
  Подоглавление:

    # Ссылки
    # Не скомпилированные исходники

  --------------------------------------

  > Ссылки

    # JS-исходники встроенных модулей NodeJS
        https://nodejs.org/en/download/stable/

  > Не скомпилированные исходники
    - В NodeJS есть встроенные модули, написанные на JS.
    - Если установить NodeJS из пакета, в каталоге их не будет.
    - Потому что они были скомпилированы V8 в C++, и находятся внутри node.exe.
    - Но иногда хочется посмотреть их содержимое, как там всё работает.
    - Для этого надо скачать не скомпилированные исходники по ссылке выше.
      Обычно, оно называется примерно так: "node-v5.6.0.tar.gz".
    - Исходники лежат внутри архива, в каталоге lib.


Г2. Настройка автодополнения в PHPStorm для каталога с проектом NodeJS

  --------------------------------------
  Подоглавление:

    # Введение
    # Настройка

  --------------------------------------

  > Введение
    - По умолчанию PHPStorm настроен на обычный браузерный JS.
    - Такая настройка всегда по умолчанию действует для всего проекта.
    - Но когда мы пишем код для NodeJS, нам нужно автодополнение для него.
    - То есть, надо изменить настройки автодополнения для каталога с проектом NodeJS.

  > Настройка

    1) Открыть настройки PHPStorm
        Settings -> Javascript -> Libraries -> Manage Scopes

    2) Там для каталога с проектом NodeJS выбрать:
      - NodeJS Globals
      - NodeJS v*.*.*







